/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/AutoCompoundingPodLp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';
   8 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   9 |     | import '@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol';
  10 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
  11 |     | import './interfaces/IDecentralizedIndex.sol';
  12 |     | import './interfaces/IDexAdapter.sol';
  13 |     | import './interfaces/IIndexUtils.sol';
  14 |     | import './interfaces/IRewardsWhitelister.sol';
  15 |     | import './interfaces/IV3TwapUtilities.sol';
  16 |     | 
  17 |     | contract AutoCompoundingPodLp is IERC4626, ERC20, ERC20Permit, Ownable {
  18 |     |   using SafeERC20 for IERC20;
  19 |     | 
  20 |     |   struct Pools {
  21 |     |     address pool1;
  22 |     |     address pool2;
  23 |     |   }
  24 |     | 
  25 |     |   event TokenToPairedLpSwapError(
  26 |     |     address rewardsToken,
  27 |     |     address pairedLpToken,
  28 |     |     uint256 amountIn
  29 |     |   );
  30 |     | 
  31 |     |   uint256 constant FACTOR = 10 ** 18;
  32 |     |   uint24 constant REWARDS_POOL_FEE = 10000;
  33 |     |   uint256 constant LP_SLIPPAGE = 80; // 8%
  34 |     |   uint256 constant REWARDS_SWAP_SLIPPAGE = 20; // 2%
  35 |     | 
  36 |     |   IDexAdapter immutable DEX_ADAPTER;
  37 |     |   IV3TwapUtilities immutable V3_TWAP_UTILS;
  38 |     | 
  39 |     |   IDecentralizedIndex public pod;
  40 |     |   IIndexUtils public indexUtils;
  41 |     |   IRewardsWhitelister public rewardsWhitelister;
  42 |     |   bool public yieldConvEnabled = true;
  43 |     |   uint16 public protocolFee = 50; // 1000 precision
  44 |     |   // token in => token out => swap pool(s)
  45 |     |   mapping(address => mapping(address => Pools)) public swapMaps;
  46 |     | 
  47 |     |   // inputTkn => outputTkn => amountInOverride
  48 |     |   mapping(address => mapping(address => uint256)) _tokenToPairedSwapAmountInOverride;
  49 |     | 
  50 |     |   // internal tracking
  51 |     |   uint256 _totalAssets;
  52 |     | 
  53 |     |   /// @notice can pass _pod as null address and set later if need be
  54 |     |   constructor(
  55 |     |     string memory _name,
  56 |     |     string memory _symbol,
  57 |     |     IDecentralizedIndex _pod,
  58 |     |     IDexAdapter _dexAdapter,
  59 |     |     IIndexUtils _utils,
  60 |     |     IRewardsWhitelister _whitelist,
  61 |     |     IV3TwapUtilities _v3TwapUtilities
  62 |     |   ) ERC20(_name, _symbol) ERC20Permit(_name) {
  63 |     |     DEX_ADAPTER = _dexAdapter;
  64 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  65 |     |     pod = _pod;
  66 |     |     indexUtils = _utils;
  67 |     |     rewardsWhitelister = _whitelist;
  68 |     |   }
  69 |     | 
  70 |     |   function asset() external view override returns (address) {
  71 |     |     return _asset();
  72 |     |   }
  73 |     | 
  74 |     |   function totalAssets() public view override returns (uint256) {
  75 |     |     return _totalAssets;
  76 |     |   }
  77 |     | 
  78 |     |   function convertToShares(
  79 |     |     uint256 _assets
  80 |     |   ) public view override returns (uint256 _shares) {
  81 |     |     return (_assets * FACTOR) / _cbr();
  82 |     |   }
  83 |     | 
  84 |     |   function convertToAssets(
  85 |     |     uint256 _shares
  86 |     |   ) public view override returns (uint256 _assets) {
  87 |     |     return (_shares * _cbr()) / FACTOR;
  88 |     |   }
  89 |     | 
  90 |     |   function maxDeposit(
  91 |     |     address
  92 |     |   ) external pure override returns (uint256 maxAssets) {
  93 |     |     return type(uint256).max - 1;
  94 |     |   }
  95 |     | 
  96 |     |   function previewDeposit(
  97 |     |     uint256 _assets
  98 |     |   ) external view override returns (uint256 _shares) {
  99 |     |     return convertToShares(_assets);
 100 |     |   }
 101 |     | 
 102 |     |   function deposit(
 103 |     |     uint256 _assets,
 104 |     |     address _receiver
 105 |     |   ) external override returns (uint256 _shares) {
 106 |     |     return _deposit(_assets, _receiver);
 107 |     |   }
 108 |     | 
 109 |     |   function _deposit(
 110 |     |     uint256 _assets,
 111 |     |     address _receiver
 112 |     |   ) internal returns (uint256 _shares) {
 113 |     |     require(_assets != 0, 'M');
 114 |     | 
 115 |     |     _processRewardsToPodLp(0, block.timestamp);
 116 |     | 
 117 |     |     _shares = convertToShares(_assets);
 118 |     |     _totalAssets += _assets;
 119 |     |     IERC20(_asset()).safeTransferFrom(_msgSender(), address(this), _assets);
 120 |     |     _mint(_receiver, _shares);
 121 |     |     emit Deposit(_msgSender(), _receiver, _assets, _shares);
 122 |     |   }
 123 |     | 
 124 |     |   function maxMint(address) external pure override returns (uint256 maxShares) {
 125 |     |     maxShares = type(uint256).max - 1;
 126 |     |   }
 127 |     | 
 128 |     |   function previewMint(
 129 |     |     uint256 _shares
 130 |     |   ) external view override returns (uint256 _assets) {
 131 |     |     _assets = convertToAssets(_shares);
 132 |     |   }
 133 |     | 
 134 |     |   function mint(
 135 |     |     uint256 _shares,
 136 |     |     address _receiver
 137 |     |   ) external override returns (uint256 _assets) {
 138 |     |     _assets = convertToAssets(_shares);
 139 |     |     _deposit(_assets, _receiver);
 140 |     |   }
 141 |     | 
 142 |     |   function maxWithdraw(
 143 |     |     address _owner
 144 |     |   ) external view override returns (uint256 maxAssets) {
 145 |     |     maxAssets = (balanceOf(_owner) * _cbr()) / FACTOR;
 146 |     |   }
 147 |     | 
 148 |     |   function previewWithdraw(
 149 |     |     uint256 _assets
 150 |     |   ) external view override returns (uint256 _shares) {
 151 |     |     _shares = convertToShares(_assets);
 152 |     |   }
 153 |     | 
 154 |     |   function withdraw(
 155 |     |     uint256 _assets,
 156 |     |     address _receiver,
 157 |     |     address
 158 |     |   ) external override returns (uint256 _shares) {
 159 |     |     _shares = convertToShares(_assets);
 160 |     |     _withdraw(_shares, _receiver);
 161 |     |   }
 162 |     | 
 163 |     |   function maxRedeem(
 164 |     |     address _owner
 165 |     |   ) external view override returns (uint256 _maxShares) {
 166 |     |     _maxShares = balanceOf(_owner);
 167 |     |   }
 168 |     | 
 169 |     |   function previewRedeem(
 170 |     |     uint256 _shares
 171 |     |   ) external view override returns (uint256 _assets) {
 172 |     |     _assets = convertToAssets(_shares);
 173 |     |   }
 174 |     | 
 175 |     |   function redeem(
 176 |     |     uint256 _shares,
 177 |     |     address _receiver,
 178 |     |     address
 179 |     |   ) external override returns (uint256 _assets) {
 180 |     |     _assets = _withdraw(_shares, _receiver);
 181 |     |   }
 182 |     | 
 183 |     |   function processAllRewardsTokensToPodLp(
 184 |     |     uint256 _amountLpOutMin,
 185 |     |     uint256 _deadline
 186 |     |   ) external onlyOwner returns (uint256) {
 187 |     |     return _processRewardsToPodLp(_amountLpOutMin, _deadline);
 188 |     |   }
 189 |     | 
 190 |     |   function _withdraw(
 191 |     |     uint256 _shares,
 192 |     |     address _receiver
 193 |     |   ) internal returns (uint256 _assets) {
 194 |     |     require(_shares != 0, 'B');
 195 |     | 
 196 |     |     _processRewardsToPodLp(0, block.timestamp);
 197 |     | 
 198 |     |     _assets = convertToAssets(_shares);
 199 |     |     _burn(_msgSender(), _shares);
 200 |     |     IERC20(_asset()).safeTransfer(_receiver, _assets);
 201 |     |     _totalAssets -= _assets;
 202 |     |     emit Withdraw(_msgSender(), _receiver, _receiver, _assets, _shares);
 203 |     |   }
 204 |     | 
 205 |     |   // @notice: assumes underlying vault asset has decimals == 18
 206 |     |   function _cbr() internal view returns (uint256) {
 207 |     |     uint256 _supply = totalSupply();
 208 |     |     return _supply == 0 ? FACTOR : (FACTOR * totalAssets()) / _supply;
 209 |     |   }
 210 |     | 
 211 |     |   function _asset() internal view returns (address) {
 212 |     |     return pod.lpStakingPool();
 213 |     |   }
 214 |     | 
 215 |     |   function _assetDecimals() internal view returns (uint8) {
 216 |     |     return IERC20Metadata(_asset()).decimals();
 217 |     |   }
 218 |     | 
 219 |     |   function _processRewardsToPodLp(
 220 |     |     uint256 _amountLpOutMin,
 221 |     |     uint256 _deadline
 222 |     |   ) internal returns (uint256 _lpAmtOut) {
 223 |     |     if (!yieldConvEnabled) {
 224 |     |       return _lpAmtOut;
 225 |     |     }
 226 |     |     address[] memory _tokens = rewardsWhitelister.getFullWhitelist();
 227 |     |     uint256 _len = _tokens.length;
 228 |     |     for (uint256 _i; _i < _len; _i++) {
 229 |     |       address _token = _tokens[_i];
 230 |     |       uint256 _bal = IERC20(_token).balanceOf(address(this));
 231 |     |       if (_bal == 0) {
 232 |     |         continue;
 233 |     |       }
 234 |     |       uint256 _newLp = _tokenToPodLp(_token, _bal, _amountLpOutMin, _deadline);
 235 |     |       _lpAmtOut += _newLp;
 236 |     |       _totalAssets += _newLp;
 237 |     |     }
 238 |     |   }
 239 |     | 
 240 |     |   function _tokenToPodLp(
 241 |     |     address _token,
 242 |     |     uint256 _amountIn,
 243 |     |     uint256 _amountLpOutMin,
 244 |     |     uint256 _deadline
 245 |     |   ) internal returns (uint256 _lpAmtOut) {
 246 |     |     uint256 _pairedOut = _tokenToPairedLpToken(_token, _amountIn, 0);
 247 |     |     if (protocolFee > 0) {
 248 |     |       uint256 _pairedFee = (_pairedOut * protocolFee) / 1000;
 249 |     |       IERC20(pod.PAIRED_LP_TOKEN()).safeTransfer(owner(), _pairedFee);
 250 |     |       _pairedOut -= _pairedFee;
 251 |     |     }
 252 |     |     _lpAmtOut = _pairedLpTokenToPodLp(_pairedOut, _amountLpOutMin, _deadline);
 253 |     |   }
 254 |     | 
 255 |     |   function _tokenToPairedLpToken(
 256 |     |     address _token,
 257 |     |     uint256 _amountIn,
 258 |     |     uint256 _amountOutMin
 259 |     |   ) internal returns (uint256 _amountOut) {
 260 |     |     address _pairedLpToken = pod.PAIRED_LP_TOKEN();
 261 |     |     if (_token == _pairedLpToken) {
 262 |     |       return _amountIn;
 263 |     |     }
 264 |     | 
 265 |     |     address _rewardsToken = pod.lpRewardsToken();
 266 |     |     if (_token != address(0) && _token != _rewardsToken) {
 267 |     |       return _swap(_token, _pairedLpToken, _amountIn, _amountOutMin);
 268 |     |     }
 269 |     |     uint256 _amountInOverride = _tokenToPairedSwapAmountInOverride[
 270 |     |       _rewardsToken
 271 |     |     ][_pairedLpToken];
 272 |     |     _amountIn = _amountInOverride > 0 ? _amountInOverride : _amountIn;
 273 |     |     (address _token0, address _token1) = _pairedLpToken < _rewardsToken
 274 |     |       ? (_pairedLpToken, _rewardsToken)
 275 |     |       : (_rewardsToken, _pairedLpToken);
 276 |     |     address _pool = DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_POOL_FEE);
 277 |     |     uint160 _rewardsSqrtPriceX96 = V3_TWAP_UTILS
 278 |     |       .sqrtPriceX96FromPoolAndInterval(_pool);
 279 |     |     uint256 _rewardsPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(
 280 |     |       _rewardsSqrtPriceX96
 281 |     |     );
 282 |     |     if (_amountOutMin == 0) {
 283 |     |       uint256 _amountOutNoSlip = _token0 == _rewardsToken
 284 |     |         ? (_rewardsPriceX96 * _amountIn) / FixedPoint96.Q96
 285 |     |         : (_amountIn * FixedPoint96.Q96) / _rewardsPriceX96;
 286 |     |       _amountOutMin =
 287 |     |         (_amountOutNoSlip * (1000 - REWARDS_SWAP_SLIPPAGE)) /
 288 |     |         1000;
 289 |     |     }
 290 |     |     IERC20(_rewardsToken).safeIncreaseAllowance(
 291 |     |       address(DEX_ADAPTER),
 292 |     |       _amountIn
 293 |     |     );
 294 |     |     try
 295 |     |       DEX_ADAPTER.swapV3Single(
 296 |     |         _rewardsToken,
 297 |     |         _pairedLpToken,
 298 |     |         REWARDS_POOL_FEE,
 299 |     |         _amountIn,
 300 |     |         _amountOutMin,
 301 |     |         address(this)
 302 |     |       )
 303 |     |     returns (uint256 __amountOut) {
 304 |     |       _tokenToPairedSwapAmountInOverride[_rewardsToken][_pairedLpToken] = 0;
 305 |     |       _amountOut = __amountOut;
 306 |     |     } catch {
 307 |     |       _tokenToPairedSwapAmountInOverride[_rewardsToken][_pairedLpToken] =
 308 |     |         _amountIn /
 309 |     |         2;
 310 |     |       IERC20(_rewardsToken).safeDecreaseAllowance(
 311 |     |         address(DEX_ADAPTER),
 312 |     |         _amountIn
 313 |     |       );
 314 |     |       emit TokenToPairedLpSwapError(_rewardsToken, _pairedLpToken, _amountIn);
 315 |     |     }
 316 |     |   }
 317 |     | 
 318 |     |   function _pairedLpTokenToPodLp(
 319 |     |     uint256 _amountIn,
 320 |     |     uint256 _amountOutMin,
 321 |     |     uint256 _deadline
 322 |     |   ) internal returns (uint256 _amountOut) {
 323 |     |     address _pairedLpToken = pod.PAIRED_LP_TOKEN();
 324 |     |     uint256 _half = _amountIn / 2;
 325 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(address(DEX_ADAPTER), _half);
 326 |     |     DEX_ADAPTER.swapV2Single(
 327 |     |       _pairedLpToken,
 328 |     |       address(pod),
 329 |     |       _half,
 330 |     |       _amountOutMin,
 331 |     |       address(this)
 332 |     |     );
 333 |     |     uint256 _podAmt = pod.balanceOf(address(this));
 334 |     |     IERC20(pod).safeIncreaseAllowance(address(indexUtils), _podAmt);
 335 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(address(indexUtils), _half);
 336 |     |     return
 337 |     |       indexUtils.addLPAndStake(
 338 |     |         pod,
 339 |     |         _podAmt,
 340 |     |         _pairedLpToken,
 341 |     |         _half,
 342 |     |         _half,
 343 |     |         LP_SLIPPAGE,
 344 |     |         _deadline
 345 |     |       );
 346 |     |   }
 347 |     | 
 348 |     |   function _swap(
 349 |     |     address _in,
 350 |     |     address _out,
 351 |     |     uint256 _amountIn,
 352 |     |     uint256 _amountOutMin
 353 |     |   ) internal returns (uint256 _amountOut) {
 354 |     |     Pools memory _swapMap = swapMaps[_in][_out];
 355 |     |     if (_swapMap.pool1 == address(0)) {
 356 |     |       address[] memory _path1 = new address[](2);
 357 |     |       _path1[0] = _in;
 358 |     |       _path1[1] = _out;
 359 |     |       return _swapV2(_path1, _amountIn, _amountOutMin);
 360 |     |     }
 361 |     |     bool _twoHops = _swapMap.pool2 != address(0);
 362 |     |     address _token0 = IUniswapV2Pair(_swapMap.pool1).token0();
 363 |     |     address[] memory _path = new address[](_twoHops ? 3 : 2);
 364 |     |     _path[0] = _in;
 365 |     |     _path[1] = !_twoHops
 366 |     |       ? _out
 367 |     |       : _token0 == _in
 368 |     |         ? IUniswapV2Pair(_swapMap.pool1).token1()
 369 |     |         : _token0;
 370 |     |     if (_twoHops) {
 371 |     |       _path[2] = _out;
 372 |     |     }
 373 |     |     _amountOut = _swapV2(_path, _amountIn, _amountOutMin);
 374 |     |   }
 375 |     | 
 376 |     |   function _swapV2(
 377 |     |     address[] memory _path,
 378 |     |     uint256 _amountIn,
 379 |     |     uint256 _amountOutMin
 380 |     |   ) internal returns (uint256) {
 381 |     |     address _out = _path.length == 3 ? _path[2] : _path[1];
 382 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 383 |     |     IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);
 384 |     |     DEX_ADAPTER.swapV2Single(
 385 |     |       _path[0],
 386 |     |       _path[1],
 387 |     |       _amountIn,
 388 |     |       _amountOutMin,
 389 |     |       address(this)
 390 |     |     );
 391 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 392 |     |   }
 393 |     | 
 394 |     |   function setZapMap(
 395 |     |     address _in,
 396 |     |     address _out,
 397 |     |     Pools memory _pools
 398 |     |   ) external onlyOwner {
 399 |     |     swapMaps[_in][_out] = _pools;
 400 |     |   }
 401 |     | 
 402 |     |   function setPod(IDecentralizedIndex _pod) external onlyOwner {
 403 |     |     require(address(pod) == address(0), 'S');
 404 |     |     pod = _pod;
 405 |     |   }
 406 |     | 
 407 |     |   function setIndexUtils(IIndexUtils _utils) external onlyOwner {
 408 |     |     indexUtils = _utils;
 409 |     |   }
 410 |     | 
 411 |     |   function setRewardsWhitelister(IRewardsWhitelister _wl) external onlyOwner {
 412 |     |     rewardsWhitelister = _wl;
 413 |     |   }
 414 |     | 
 415 |     |   function setYieldConvEnabled(bool _enabled) external onlyOwner {
 416 |     |     require(yieldConvEnabled != _enabled, 'T');
 417 |     |     yieldConvEnabled = _enabled;
 418 |     |   }
 419 |     | 
 420 |     |   function setProtocolFee(uint16 _newFee) external onlyOwner {
 421 |     |     require(_newFee <= 1000, 'MAX');
 422 |     |     protocolFee = _newFee;
 423 |     |   }
 424 |     | }
 425 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/AutoCompoundingPodLpFactory.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';
   7 |     | import './AutoCompoundingPodLp.sol';
   8 |     | 
   9 |     | contract AutoCompoundingPodLpFactory is Ownable {
  10 |     |   using SafeERC20 for IERC20;
  11 |     | 
  12 |     |   uint256 minimumDepositAtCreation = 10 ** 3;
  13 |     | 
  14 |     |   event Create(address newAspTkn);
  15 |     | 
  16 |     |   function create(
  17 |     |     string memory _name,
  18 |     |     string memory _symbol,
  19 |     |     IDecentralizedIndex _pod,
  20 |     |     IDexAdapter _dexAdapter,
  21 |     |     IIndexUtils _utils,
  22 |     |     IRewardsWhitelister _whitelist,
  23 |     |     IV3TwapUtilities _v3TwapUtilities,
  24 |     |     uint256 _salt
  25 |     |   ) external onlyOwner {
  26 |     |     address _aspAddy = _deploy(
  27 |     |       getBytecode(
  28 |     |         _name,
  29 |     |         _symbol,
  30 |     |         _pod,
  31 |     |         _dexAdapter,
  32 |     |         _utils,
  33 |     |         _whitelist,
  34 |     |         _v3TwapUtilities
  35 |     |       ),
  36 |     |       _getFullSalt(_salt)
  37 |     |     );
  38 |     |     if (address(_pod) != address(0) && minimumDepositAtCreation > 0) {
  39 |     |       _depositMin(_aspAddy, _pod);
  40 |     |     }
  41 |     |     AutoCompoundingPodLp(_aspAddy).transferOwnership(_msgSender());
  42 |     |     emit Create(_aspAddy);
  43 |     |   }
  44 |     | 
  45 |     |   function _depositMin(address _aspAddy, IDecentralizedIndex _pod) internal {
  46 |     |     address _lpToken = _pod.lpStakingPool();
  47 |     |     IERC20(_lpToken).safeTransferFrom(
  48 |     |       _msgSender(),
  49 |     |       address(this),
  50 |     |       minimumDepositAtCreation
  51 |     |     );
  52 |     |     IERC20(_lpToken).safeApprove(_aspAddy, minimumDepositAtCreation);
  53 |     |     AutoCompoundingPodLp(_aspAddy).deposit(
  54 |     |       minimumDepositAtCreation,
  55 |     |       _msgSender()
  56 |     |     );
  57 |     |   }
  58 |     | 
  59 |     |   function getNewCaFromParams(
  60 |     |     string memory _name,
  61 |     |     string memory _symbol,
  62 |     |     IDecentralizedIndex _pod,
  63 |     |     IDexAdapter _dexAdapter,
  64 |     |     IIndexUtils _utils,
  65 |     |     IRewardsWhitelister _whitelist,
  66 |     |     IV3TwapUtilities _v3TwapUtilities,
  67 |     |     uint256 _salt
  68 |     |   ) external view returns (address) {
  69 |     |     bytes memory _bytecode = getBytecode(
  70 |     |       _name,
  71 |     |       _symbol,
  72 |     |       _pod,
  73 |     |       _dexAdapter,
  74 |     |       _utils,
  75 |     |       _whitelist,
  76 |     |       _v3TwapUtilities
  77 |     |     );
  78 |     |     return getNewCaAddress(_bytecode, _salt);
  79 |     |   }
  80 |     | 
  81 |     |   function getBytecode(
  82 |     |     string memory _name,
  83 |     |     string memory _symbol,
  84 |     |     IDecentralizedIndex _pod,
  85 |     |     IDexAdapter _dexAdapter,
  86 |     |     IIndexUtils _utils,
  87 |     |     IRewardsWhitelister _whitelist,
  88 |     |     IV3TwapUtilities _v3TwapUtilities
  89 |     |   ) public pure returns (bytes memory) {
  90 |     |     bytes memory _bytecode = type(AutoCompoundingPodLp).creationCode;
  91 |     |     return
  92 |     |       abi.encodePacked(
  93 |     |         _bytecode,
  94 |     |         abi.encode(
  95 |     |           _name,
  96 |     |           _symbol,
  97 |     |           _pod,
  98 |     |           _dexAdapter,
  99 |     |           _utils,
 100 |     |           _whitelist,
 101 |     |           _v3TwapUtilities
 102 |     |         )
 103 |     |       );
 104 |     |   }
 105 |     | 
 106 |     |   function getNewCaAddress(
 107 |     |     bytes memory _bytecode,
 108 |     |     uint256 _salt
 109 |     |   ) public view returns (address) {
 110 |     |     bytes32 _hash = keccak256(
 111 |     |       abi.encodePacked(
 112 |     |         bytes1(0xff),
 113 |     |         address(this),
 114 |     |         _getFullSalt(_salt),
 115 |     |         keccak256(_bytecode)
 116 |     |       )
 117 |     |     );
 118 |     |     return address(uint160(uint256(_hash)));
 119 |     |   }
 120 |     | 
 121 |     |   function _getFullSalt(uint256 _salt) internal view returns (uint256) {
 122 |     |     return uint256(uint160(address(this))) + _salt;
 123 |     |   }
 124 |     | 
 125 |     |   function _deploy(
 126 |     |     bytes memory _bytecode,
 127 |     |     uint256 _finalSalt
 128 |     |   ) internal returns (address _addr) {
 129 |     |     assembly {
 130 |     |       _addr := create2(
 131 |     |         callvalue(),
 132 |     |         add(_bytecode, 0x20),
 133 |     |         mload(_bytecode),
 134 |     |         _finalSalt
 135 |     |       )
 136 |     |       if iszero(extcodesize(_addr)) {
 137 |     |         revert(0, 0)
 138 |     |       }
 139 |     |     }
 140 |     |   }
 141 |     | 
 142 |     |   function setMinimumDepositAtCreation(uint256 _minDeposit) external onlyOwner {
 143 |     |     minimumDepositAtCreation = _minDeposit;
 144 |     |   }
 145 |     | }
 146 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/DecentralizedIndex.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   8 |     | import './interfaces/IDecentralizedIndex.sol';
   9 |     | import './interfaces/IDexAdapter.sol';
  10 |     | import './interfaces/IFlashLoanRecipient.sol';
  11 |     | import './interfaces/IProtocolFeeRouter.sol';
  12 |     | import './interfaces/IRewardsWhitelister.sol';
  13 |     | import './interfaces/ITokenRewards.sol';
  14 |     | import './StakingPoolToken.sol';
  15 |     | 
  16 |     | abstract contract DecentralizedIndex is
  17 |     |   IDecentralizedIndex,
  18 |     |   ERC20,
  19 |     |   ERC20Permit
  20 |     | {
  21 |     |   using SafeERC20 for IERC20;
  22 |     | 
  23 | *   |   uint16 constant DEN = 10000;
  24 |     |   uint8 constant SWAP_DELAY = 20; // seconds
  25 |     |   address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;
  26 |     |   IProtocolFeeRouter constant PROTOCOL_FEE_ROUTER =
  27 |     |     IProtocolFeeRouter(0x7d544DD34ABbE24C8832db27820Ff53C151e949b);
  28 |     |   IRewardsWhitelister constant REWARDS_WHITELIST =
  29 |     |     IRewardsWhitelister(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F);
  30 |     |   IV3TwapUtilities constant V3_TWAP_UTILS =
  31 |     |     IV3TwapUtilities(0x024ff47D552cB222b265D68C7aeB26E586D5229D);
  32 |     | 
  33 |     |   uint256 public immutable override FLASH_FEE_AMOUNT_DAI; // 10 DAI
  34 |     |   address public immutable override PAIRED_LP_TOKEN;
  35 |     |   IDexAdapter public immutable DEX_HANDLER;
  36 |     |   address immutable V2_ROUTER;
  37 |     |   address immutable V3_ROUTER;
  38 |     |   address immutable WETH;
  39 |     |   address V2_POOL;
  40 |     | 
  41 |     |   IndexType public immutable override indexType;
  42 |     |   uint256 public immutable override created;
  43 |     |   address public immutable override lpRewardsToken;
  44 |     |   address public override lpStakingPool;
  45 |     |   uint8 public override unlocked = 1;
  46 |     | 
  47 |     |   Config public config;
  48 |     |   Fees public fees;
  49 |     |   IndexAssetInfo[] public indexTokens;
  50 |     |   mapping(address => bool) _isTokenInIndex;
  51 |     |   mapping(address => uint8) _fundTokenIdx;
  52 |     |   mapping(address => bool) _blacklist;
  53 |     | 
  54 |     |   uint64 _partnerFirstWrapped;
  55 |     | 
  56 |     |   uint64 _lastSwap;
  57 |     |   uint8 _swapping;
  58 |     |   uint8 _swapAndFeeOn = 1;
  59 |     |   bool _initialized;
  60 |     | 
  61 |     |   event FlashLoan(
  62 |     |     address indexed executor,
  63 |     |     address indexed recipient,
  64 |     |     address token,
  65 |     |     uint256 amount
  66 |     |   );
  67 |     | 
  68 |     |   modifier lock() {
  69 | *   |     require(unlocked == 1, 'L');
  70 | *   |     unlocked = 0;
  71 |     |     _;
  72 | *   |     unlocked = 1;
  73 |     |   }
  74 |     | 
  75 |     |   modifier onlyPartner() {
  76 |     |     require(_msgSender() == config.partner, 'P');
  77 |     |     _;
  78 |     |   }
  79 |     | 
  80 |     |   modifier noSwapOrFee() {
  81 | *   |     _swapAndFeeOn = 0;
  82 |     |     _;
  83 | *   |     _swapAndFeeOn = 1;
  84 |     |   }
  85 |     | 
  86 |     |   event Debug(string a);
  87 |     |   event DebugUint(string a, uint256 b);
  88 |     |   event DebugAddress(string a, address b);
  89 |     |   event DebugBool(string a, bool b);
  90 |     | 
  91 |     |   constructor(
  92 |     |     string memory _name,
  93 |     |     string memory _symbol,
  94 |     |     IndexType _idxType,
  95 |     |     Config memory _config,
  96 |     |     Fees memory _fees,
  97 |     |     address _pairedLpToken,
  98 |     |     address _lpRewardsToken,
  99 |     |     address _dexHandler,
 100 |     |     bool _stakeRestriction
 101 |     |   ) ERC20(_name, _symbol) ERC20Permit(_name) {
 102 |     |     require(_fees.buy <= (uint256(DEN) * 20) / 100);
 103 |     |     require(_fees.sell <= (uint256(DEN) * 20) / 100);
 104 |     |     require(_fees.burn <= (uint256(DEN) * 70) / 100);
 105 |     |     require(_fees.bond <= (uint256(DEN) * 99) / 100);
 106 |     |     require(_fees.debond <= (uint256(DEN) * 99) / 100);
 107 |     |     require(_fees.partner <= (uint256(DEN) * 5) / 100);
 108 |     | 
 109 |     | 
 110 |     |     indexType = _idxType;
 111 |     |     created = block.timestamp;
 112 |     |     fees = _fees;
 113 |     |     config = _config;
 114 |     |     lpRewardsToken = _lpRewardsToken;
 115 |     |     DEX_HANDLER = IDexAdapter(_dexHandler);
 116 |     |     address _v2Router = DEX_HANDLER.V2_ROUTER();
 117 |     |     V2_ROUTER = _v2Router;
 118 |     |     V3_ROUTER = DEX_HANDLER.V3_ROUTER();
 119 |     |     address _finalPairedLpToken = _pairedLpToken == address(0)
 120 |     |       ? DAI
 121 |     |       : _pairedLpToken;
 122 |     |     PAIRED_LP_TOKEN = _finalPairedLpToken;
 123 |     |     FLASH_FEE_AMOUNT_DAI = 10 * 10 ** IERC20Metadata(DAI).decimals(); // 10 DAI
 124 |     | 
 125 |     |     emit Debug("BEFORE STAKING POOL TOKEN");
 126 |     |     
 127 |     |     lpStakingPool = address(
 128 |     |       new StakingPoolToken(
 129 |     |         string.concat('Staked ', _name),
 130 |     |         string.concat('s', _symbol),
 131 |     |         _finalPairedLpToken,
 132 |     |         lpRewardsToken,
 133 |     |         _stakeRestriction ? _msgSender() : address(0),
 134 |     |         PROTOCOL_FEE_ROUTER,
 135 |     |         REWARDS_WHITELIST,
 136 |     |         DEX_HANDLER,
 137 |     |         V3_TWAP_UTILS
 138 |     |       )
 139 |     |     );
 140 |     |     emit Debug("AFTER STAKING POOL TOKEN");
 141 |     |     if (!DEX_HANDLER.ASYNC_INITIALIZE()) {
 142 |     |       _initialize();
 143 |     |     }
 144 |     |     WETH = IDexAdapter(_dexHandler).WETH();
 145 |     |     emit Create(address(this), _msgSender());
 146 |     |   }
 147 |     | 
 148 | *   |   function initialize() external {
 149 | *   |     _initialize();
 150 |     |   }
 151 |     | 
 152 |     |   /// @notice The ```_initialize``` function initialized a new LP pair for the pod + pairedLpAsset
 153 |     |   function _initialize() internal {
 154 |     |     require(!_initialized, 'O');
 155 |     |     _initialized = true;
 156 |     |     address _v2Pool = DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN);
 157 |     |     if (_v2Pool == address(0)) {
 158 |     |       _v2Pool = DEX_HANDLER.createV2Pool(address(this), PAIRED_LP_TOKEN);
 159 |     |     }
 160 |     |     StakingPoolToken(lpStakingPool).setStakingToken(_v2Pool);
 161 |     |     StakingPoolToken(lpStakingPool).renounceOwnership();
 162 |     |     V2_POOL = _v2Pool;
 163 |     |     emit Initialize(_msgSender(), _v2Pool);
 164 |     |   }
 165 |     | 
 166 |     |   /// @notice The ```_transfer``` function overrides the standard ERC20 _transfer to handle fee processing for a pod
 167 |     |   /// @param _from Where pTKN are being transferred from
 168 |     |   /// @param _to Where pTKN are being transferred to
 169 |     |   /// @param _amount Amount of pTKN being transferred
 170 |     |   function _transfer(
 171 |     |     address _from,
 172 |     |     address _to,
 173 |     |     uint256 _amount
 174 |     |   ) internal virtual override {
 175 |     |     require(!_blacklist[_to], 'BK');
 176 |     |     bool _buy = _from == V2_POOL && _to != V2_ROUTER;
 177 |     |     bool _sell = _to == V2_POOL;
 178 |     |     uint256 _fee;
 179 |     |     if (_swapping == 0 && _swapAndFeeOn == 1) {
 180 |     |       if (_from != V2_POOL) {
 181 |     |         _processPreSwapFeesAndSwap();
 182 |     |       }
 183 |     |       if (_buy && fees.buy > 0) {
 184 |     |         _fee = (_amount * fees.buy) / DEN;
 185 |     |         super._transfer(_from, address(this), _fee);
 186 |     |       }
 187 |     |       if (_sell && fees.sell > 0) {
 188 |     |         _fee = (_amount * fees.sell) / DEN;
 189 |     |         super._transfer(_from, address(this), _fee);
 190 |     |       }
 191 |     |       if (!_buy && !_sell && config.hasTransferTax) {
 192 |     |         _fee = _amount / 10000; // 0.01%
 193 |     |         _fee = _fee == 0 && _amount > 0 ? 1 : _fee;
 194 |     |         super._transfer(_from, address(this), _fee);
 195 |     |       }
 196 |     |     }
 197 |     |     _processBurnFee(_fee);
 198 |     |     super._transfer(_from, _to, _amount - _fee);
 199 |     |   }
 200 |     | 
 201 |     |   /// @notice The ```_processPreSwapFeesAndSwap``` function processes fees that could be pending for a pod
 202 |     |   function _processPreSwapFeesAndSwap() internal {
 203 |     |     bool _passesSwapDelay = block.timestamp > _lastSwap + SWAP_DELAY;
 204 |     |     if (!_passesSwapDelay) {
 205 |     |       return;
 206 |     |     }
 207 |     |     uint256 _bal = balanceOf(address(this));
 208 |     |     if (_bal == 0) {
 209 |     |       return;
 210 |     |     }
 211 |     |     uint256 _lpBal = balanceOf(V2_POOL);
 212 |     |     uint256 _min = block.chainid == 1 ? _lpBal / 1000 : _lpBal / 4000; // 0.1%/0.025% LP bal
 213 |     |     uint256 _max = _lpBal / 100; // 1%
 214 |     |     if (_bal >= _min && _lpBal > 0) {
 215 |     |       _swapping = 1;
 216 |     |       _lastSwap = uint64(block.timestamp);
 217 |     |       uint256 _totalAmt = _bal > _max ? _max : _bal;
 218 |     |       uint256 _partnerAmt;
 219 |     |       if (
 220 |     |         fees.partner > 0 &&
 221 |     |         config.partner != address(0) &&
 222 |     |         !_blacklist[config.partner]
 223 |     |       ) {
 224 |     |         _partnerAmt = (_totalAmt * fees.partner) / DEN;
 225 |     |         super._transfer(address(this), config.partner, _partnerAmt);
 226 |     |       }
 227 |     |       _feeSwap(_totalAmt - _partnerAmt);
 228 |     |       _swapping = 0;
 229 |     |     }
 230 |     |   }
 231 |     | 
 232 |     |   /// @notice The ```_processBurnFee``` function burns pTKN based on the burn fee, which turns the pod
 233 |     |   /// @notice into a vault where holders have more underlying TKN to pTKN as burn fees process over time
 234 |     |   /// @param _amtToProcess Number of pTKN being burned
 235 | *   |   function _processBurnFee(uint256 _amtToProcess) internal {
 236 | *   |     if (_amtToProcess == 0 || fees.burn == 0) {
 237 |     |       return;
 238 |     |     }
 239 | *   |     _burn(address(this), (_amtToProcess * fees.burn) / DEN);
 240 |     |   }
 241 |     | 
 242 |     |   /// @notice The ```_feeSwap``` function processes built up fees by converting to pairedLpToken
 243 |     |   /// @param _amount Number of pTKN being processed for yield
 244 |     |   function _feeSwap(uint256 _amount) internal {
 245 |     |     _approve(address(this), address(DEX_HANDLER), _amount);
 246 |     |     address _rewards = StakingPoolToken(lpStakingPool).POOL_REWARDS();
 247 |     |     uint256 _pairedLpBalBefore = IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards);
 248 |     |     DEX_HANDLER.swapV2Single(
 249 |     |       address(this),
 250 |     |       PAIRED_LP_TOKEN,
 251 |     |       _amount,
 252 |     |       0,
 253 |     |       _rewards
 254 |     |     );
 255 |     | 
 256 |     |     if (PAIRED_LP_TOKEN == lpRewardsToken) {
 257 |     |       uint256 _newPairedLpTkns = IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards) -
 258 |     |         _pairedLpBalBefore;
 259 |     |       if (_newPairedLpTkns > 0) {
 260 |     |         ITokenRewards(_rewards).depositRewardsNoTransfer(
 261 |     |           PAIRED_LP_TOKEN,
 262 |     |           _newPairedLpTkns
 263 |     |         );
 264 |     |       }
 265 |     |     } else if (IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards) > 0) {
 266 |     |       ITokenRewards(_rewards).depositFromPairedLpToken(0);
 267 |     |     }
 268 |     |   }
 269 |     | 
 270 |     |   /// @notice The ```_transferFromAndValidate``` function is basically the _transfer with hardcoded _to to this CA and executes
 271 |     |   /// @notice a token transfer with balance validation to revert if balances aren't updated as expected
 272 |     |   /// @notice on transfer (i.e. transfer fees, etc.)
 273 |     |   /// @param _token The token we're transferring
 274 |     |   /// @param _sender The token we're transferring
 275 |     |   /// @param _amount Number of tokens to transfer
 276 | *   |   function _transferFromAndValidate(
 277 |     |     IERC20 _token,
 278 |     |     address _sender,
 279 |     |     uint256 _amount
 280 |     |   ) internal {
 281 | *   |     uint256 _balanceBefore = _token.balanceOf(address(this));
 282 | *   |     _token.safeTransferFrom(_sender, address(this), _amount);
 283 | *   |     require(_token.balanceOf(address(this)) >= _balanceBefore + _amount, 'TV');
 284 |     |   }
 285 |     | 
 286 |     |   /// @notice The ```_bond``` function should be called from external bond() to handle validation and partner logic
 287 | *   |   function _bond() internal {
 288 | *   |     require(_initialized, 'I');
 289 | *   |     if (_partnerFirstWrapped == 0 && _msgSender() == config.partner) {
 290 |     |       _partnerFirstWrapped = uint64(block.timestamp);
 291 |     |     }
 292 |     |   }
 293 |     | 
 294 |     |   /// @notice The ```_canWrapFeeFree``` function checks if the wrapping user can wrap without fees
 295 |     |   /// @param _wrapper The user wrapping into the pod
 296 |     |   /// @return bool Whether the user can wrap fee free
 297 | *   |   function _canWrapFeeFree(address _wrapper) internal view returns (bool) {
 298 |     |     return
 299 | *   |       _isFirstIn() ||
 300 | *   |       (_wrapper == config.partner &&
 301 |     |         _partnerFirstWrapped == 0 &&
 302 |     |         block.timestamp <= created + 7 days);
 303 |     |   }
 304 |     | 
 305 |     |   /// @notice The ```_isFirstIn``` function confirms if the user is the first to wrap
 306 |     |   /// @return bool Whether the user is the first one in
 307 | *   |   function _isFirstIn() internal view returns (bool) {
 308 | *   |     return totalSupply() == 0;
 309 |     |   }
 310 |     | 
 311 |     |   /// @notice The ```_isLastOut``` function checks if the user is the last one out
 312 |     |   /// @param _debondAmount Number of pTKN being unwrapped
 313 |     |   /// @return bool Whether the user is the last one out
 314 |     |   function _isLastOut(uint256 _debondAmount) internal view returns (bool) {
 315 |     |     return _debondAmount >= (totalSupply() * 98) / 100;
 316 |     |   }
 317 |     | 
 318 |     |   /// @notice The ```processPreSwapFeesAndSwap``` function allows the rewards CA for the pod to process fees as needed
 319 |     |   function processPreSwapFeesAndSwap() external override {
 320 |     |     require(
 321 |     |       _msgSender() == StakingPoolToken(lpStakingPool).POOL_REWARDS(),
 322 |     |       'R'
 323 |     |     );
 324 |     |     _processPreSwapFeesAndSwap();
 325 |     |   }
 326 |     | 
 327 |     |   function partner() external view override returns (address) {
 328 |     |     return config.partner;
 329 |     |   }
 330 |     | 
 331 |     |   function BOND_FEE() external view override returns (uint16) {
 332 |     |     return fees.bond;
 333 |     |   }
 334 |     | 
 335 |     |   function DEBOND_FEE() external view override returns (uint16) {
 336 |     |     return fees.debond;
 337 |     |   }
 338 |     | 
 339 |     |   function isAsset(address _token) public view override returns (bool) {
 340 |     |     return _isTokenInIndex[_token];
 341 |     |   }
 342 |     | 
 343 | *   |   function getAllAssets()
 344 |     |     external
 345 |     |     view
 346 |     |     override
 347 | *   |     returns (IndexAssetInfo[] memory)
 348 |     |   {
 349 | *   |     return indexTokens;
 350 |     |   }
 351 |     | 
 352 |     |   /// @notice The ```burn``` function allows any user to burn an amount of their pTKN
 353 |     |   /// @param _amount Number of pTKN to burn
 354 |     |   function burn(uint256 _amount) external lock {
 355 |     |     _burn(_msgSender(), _amount);
 356 |     |   }
 357 |     | 
 358 |     |   /// @notice The ```addLiquidityV2``` function mints new liquidity for the pod
 359 |     |   /// @param _idxLPTokens Number pTKN to add to liquidity
 360 |     |   /// @param _pairedLPTokens Number of pairedLpToken to add to liquidity
 361 |     |   /// @param _slippage LP slippage with 1000 precision
 362 |     |   /// @param _deadline LP validation deadline
 363 |     |   /// @return _liquidity Number of new liquidity tokens minted
 364 |     |   function addLiquidityV2(
 365 |     |     uint256 _idxLPTokens,
 366 |     |     uint256 _pairedLPTokens,
 367 |     |     uint256 _slippage, // 100 == 10%, 1000 == 100%
 368 |     |     uint256 _deadline
 369 |     |   ) external override lock noSwapOrFee returns (uint256) {
 370 |     |     uint256 _idxTokensBefore = balanceOf(address(this));
 371 |     |     uint256 _pairedBefore = IERC20(PAIRED_LP_TOKEN).balanceOf(address(this));
 372 |     | 
 373 |     |     super._transfer(_msgSender(), address(this), _idxLPTokens);
 374 |     |     _approve(address(this), address(DEX_HANDLER), _idxLPTokens);
 375 |     | 
 376 |     |     emit DebugUint("PAIRED_LP_TOKEN BALANCE", IERC20(PAIRED_LP_TOKEN).balanceOf(_msgSender()));
 377 |     |     emit DebugAddress("PAIRED_LP_TOKEN", PAIRED_LP_TOKEN);
 378 |     |     emit DebugAddress("ms.sender", _msgSender());
 379 |     |     emit DebugBool("PAIRED_LP_TOKEN is DAI", PAIRED_LP_TOKEN == 0x6B175474E89094C44Da98b954EedeAC495271d0F);
 380 |     |     IERC20(PAIRED_LP_TOKEN).safeTransferFrom(
 381 |     |       _msgSender(),
 382 |     |       address(this),
 383 |     |       _pairedLPTokens
 384 |     |     );
 385 |     |     IERC20(PAIRED_LP_TOKEN).safeIncreaseAllowance(
 386 |     |       address(DEX_HANDLER),
 387 |     |       _pairedLPTokens
 388 |     |     );
 389 |     | 
 390 |     |     uint256 _poolBalBefore = IERC20(
 391 |     |       DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN)
 392 |     |     ).balanceOf(_msgSender());
 393 |     |     DEX_HANDLER.addLiquidity(
 394 |     |       address(this),
 395 |     |       PAIRED_LP_TOKEN,
 396 |     |       _idxLPTokens,
 397 |     |       _pairedLPTokens,
 398 |     |       (_idxLPTokens * (1000 - _slippage)) / 1000,
 399 |     |       (_pairedLPTokens * (1000 - _slippage)) / 1000,
 400 |     |       _msgSender(),
 401 |     |       _deadline
 402 |     |     );
 403 |     |     IERC20(PAIRED_LP_TOKEN).safeApprove(address(DEX_HANDLER), 0);
 404 |     | 
 405 |     |     // check & refund excess tokens from LPing
 406 |     |     if (balanceOf(address(this)) > _idxTokensBefore) {
 407 |     |       super._transfer(
 408 |     |         address(this),
 409 |     |         _msgSender(),
 410 |     |         balanceOf(address(this)) - _idxTokensBefore
 411 |     |       );
 412 |     |     }
 413 |     |     if (IERC20(PAIRED_LP_TOKEN).balanceOf(address(this)) > _pairedBefore) {
 414 |     |       IERC20(PAIRED_LP_TOKEN).safeTransfer(
 415 |     |         _msgSender(),
 416 |     |         IERC20(PAIRED_LP_TOKEN).balanceOf(address(this)) - _pairedBefore
 417 |     |       );
 418 |     |     }
 419 |     |     emit AddLiquidity(_msgSender(), _idxLPTokens, _pairedLPTokens);
 420 |     |     return
 421 |     |       IERC20(DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN)).balanceOf(
 422 |     |         _msgSender()
 423 |     |       ) - _poolBalBefore;
 424 |     |   }
 425 |     | 
 426 |     |   /// @notice The ```removeLiquidityV2``` function burns pod liquidity
 427 |     |   /// @param _lpTokens Number of liquidity tokens to burn/remove
 428 |     |   /// @param _minIdxTokens Number of pTKN to receive at a minimum, slippage
 429 |     |   /// @param _minPairedLpToken Number of pairedLpToken to receive at a minimum, slippage
 430 |     |   /// @param _deadline LP validation deadline
 431 |     |   function removeLiquidityV2(
 432 |     |     uint256 _lpTokens,
 433 |     |     uint256 _minIdxTokens, // 0 == 100% slippage
 434 |     |     uint256 _minPairedLpToken, // 0 == 100% slippage
 435 |     |     uint256 _deadline
 436 |     |   ) external override lock noSwapOrFee {
 437 |     |     _lpTokens = _lpTokens == 0
 438 |     |       ? IERC20(V2_POOL).balanceOf(_msgSender())
 439 |     |       : _lpTokens;
 440 |     |     require(_lpTokens > 0, 'LT');
 441 |     | 
 442 |     |     IERC20(V2_POOL).safeTransferFrom(_msgSender(), address(this), _lpTokens);
 443 |     |     IERC20(V2_POOL).safeIncreaseAllowance(address(DEX_HANDLER), _lpTokens);
 444 |     |     DEX_HANDLER.removeLiquidity(
 445 |     |       address(this),
 446 |     |       PAIRED_LP_TOKEN,
 447 |     |       _lpTokens,
 448 |     |       _minIdxTokens,
 449 |     |       _minPairedLpToken,
 450 |     |       _msgSender(),
 451 |     |       _deadline
 452 |     |     );
 453 |     |     emit RemoveLiquidity(_msgSender(), _lpTokens);
 454 |     |   }
 455 |     | 
 456 |     |   /// @notice The ```flash``` function allows to flash loan underlying TKN from the pod
 457 |     |   /// @param _recipient User to receive underlying TKN for the flash loan
 458 |     |   /// @param _token TKN to borrow
 459 |     |   /// @param _amount Number of underying TKN to borrow
 460 |     |   /// @param _data Any data the recipient wants to be passed on the flash loan callback callback
 461 |     |   function flash(
 462 |     |     address _recipient,
 463 |     |     address _token,
 464 |     |     uint256 _amount,
 465 |     |     bytes calldata _data
 466 |     |   ) external override lock {
 467 |     |     require(_isTokenInIndex[_token], 'X');
 468 |     |     address _rewards = StakingPoolToken(lpStakingPool).POOL_REWARDS();
 469 |     |     address _feeRecipient = lpRewardsToken == DAI
 470 |     |       ? address(this)
 471 |     |       : PAIRED_LP_TOKEN == DAI
 472 |     |         ? _rewards
 473 |     |         : Ownable(address(V3_TWAP_UTILS)).owner();
 474 |     |     IERC20(DAI).safeTransferFrom(
 475 |     |       _msgSender(),
 476 |     |       _feeRecipient,
 477 |     |       FLASH_FEE_AMOUNT_DAI
 478 |     |     );
 479 |     |     if (lpRewardsToken == DAI) {
 480 |     |       IERC20(DAI).safeIncreaseAllowance(_rewards, FLASH_FEE_AMOUNT_DAI);
 481 |     |       ITokenRewards(_rewards).depositRewards(DAI, FLASH_FEE_AMOUNT_DAI);
 482 |     |     }
 483 |     |     uint256 _balance = IERC20(_token).balanceOf(address(this));
 484 |     |     IERC20(_token).safeTransfer(_recipient, _amount);
 485 |     |     IFlashLoanRecipient(_recipient).callback(_data);
 486 |     |     require(IERC20(_token).balanceOf(address(this)) >= _balance, 'FA');
 487 |     |     emit FlashLoan(_msgSender(), _recipient, _token, _amount);
 488 |     |   }
 489 |     | 
 490 |     |   function setPartner(address _partner) external onlyPartner {
 491 |     |     config.partner = _partner;
 492 |     |     emit SetPartner(_msgSender(), _partner);
 493 |     |   }
 494 |     | 
 495 |     |   function setPartnerFee(uint16 _fee) external onlyPartner {
 496 |     |     require(_fee < fees.partner, 'L');
 497 |     |     fees.partner = _fee;
 498 |     |     emit SetPartnerFee(_msgSender(), _fee);
 499 |     |   }
 500 |     | 
 501 |     |   function rescueERC20(address _token) external lock {
 502 |     |     // cannot withdraw tokens/assets that belong to the index
 503 |     |     require(!isAsset(_token) && _token != address(this), 'U');
 504 |     |     IERC20(_token).safeTransfer(
 505 |     |       Ownable(address(V3_TWAP_UTILS)).owner(),
 506 |     |       IERC20(_token).balanceOf(address(this))
 507 |     |     );
 508 |     |   }
 509 |     | 
 510 | *   |   function rescueETH() external lock {
 511 |     |     require(address(this).balance > 0, 'E');
 512 |     |     (bool _sent, ) = Ownable(address(V3_TWAP_UTILS)).owner().call{
 513 |     |       value: address(this).balance
 514 |     |     }('');
 515 |     |     require(_sent, 'S');
 516 |     |   }
 517 |     | 
 518 |     |   receive() external payable {}
 519 |     | }
 520 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/IndexUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   6 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   7 |     | import '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';
   8 |     | import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
   9 |     | import './interfaces/IDecentralizedIndex.sol';
  10 |     | import './interfaces/IDexAdapter.sol';
  11 |     | import './interfaces/IIndexUtils.sol';
  12 |     | import './interfaces/IStakingPoolToken.sol';
  13 |     | import './interfaces/ITokenRewards.sol';
  14 |     | import './interfaces/IUniswapV2Factory.sol';
  15 |     | import './interfaces/IUniswapV3Pool.sol';
  16 |     | import './interfaces/IUniswapV2Router02.sol';
  17 |     | import './interfaces/IWETH.sol';
  18 |     | import './Zapper.sol';
  19 |     | 
  20 |     | contract IndexUtils is Context, IIndexUtils, Zapper {
  21 |     |   using SafeERC20 for IERC20;
  22 |     | 
  23 |     |   constructor(
  24 |     |     IV3TwapUtilities _v3TwapUtilities,
  25 |     |     IDexAdapter _dexAdapter
  26 |     |   ) Zapper(_v3TwapUtilities, _dexAdapter) {}
  27 |     | 
  28 |     |   function bond(
  29 |     |     IDecentralizedIndex _indexFund,
  30 |     |     address _token,
  31 |     |     uint256 _amount,
  32 |     |     uint256 _amountMintMin
  33 |     |   ) external {
  34 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund
  35 |     |       .getAllAssets();
  36 |     |     uint256[] memory _balsBefore = new uint256[](_assets.length);
  37 |     | 
  38 |     |     uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(_indexFund));
  39 |     |     uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0
  40 |     |       ? FixedPoint96.Q96
  41 |     |       : (_amount * FixedPoint96.Q96) / _tokenCurSupply;
  42 |     |     uint256 _al = _assets.length;
  43 |     |     for (uint256 _i; _i < _al; _i++) {
  44 |     |       uint256 _amountNeeded = _indexFund.totalSupply() == 0
  45 |     |         ? _indexFund.getInitialAmount(_token, _amount, _assets[_i].token)
  46 |     |         : (IERC20(_assets[_i].token).balanceOf(address(_indexFund)) *
  47 |     |           _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;
  48 |     |       _balsBefore[_i] = IERC20(_assets[_i].token).balanceOf(address(this));
  49 |     |       IERC20(_assets[_i].token).safeTransferFrom(
  50 |     |         _msgSender(),
  51 |     |         address(this),
  52 |     |         _amountNeeded
  53 |     |       );
  54 |     |       IERC20(_assets[_i].token).safeIncreaseAllowance(
  55 |     |         address(_indexFund),
  56 |     |         _amountNeeded
  57 |     |       );
  58 |     |     }
  59 |     |     uint256 _idxBalBefore = IERC20(_indexFund).balanceOf(address(this));
  60 |     |     _indexFund.bond(_token, _amount, _amountMintMin);
  61 |     |     IERC20(_indexFund).safeTransfer(
  62 |     |       _msgSender(),
  63 |     |       IERC20(_indexFund).balanceOf(address(this)) - _idxBalBefore
  64 |     |     );
  65 |     | 
  66 |     |     // refund any excess tokens to user we didn't use to bond
  67 |     |     for (uint256 _i; _i < _al; _i++) {
  68 |     |       _checkAndRefundERC20(_msgSender(), _assets[_i].token, _balsBefore[_i]);
  69 |     |     }
  70 |     |   }
  71 |     | 
  72 |     |   function bondWeightedFromNative(
  73 |     |     IDecentralizedIndex _indexFund,
  74 |     |     uint256 _assetIdx,
  75 |     |     uint256 _amountTokensForAssetIdx,
  76 |     |     uint256 _amountMintMin,
  77 |     |     uint256 _amountPairedLpTokenMin,
  78 |     |     uint256 _slippage, // 1 == 0.1%, 10 == 1%, 1000 == 100%
  79 |     |     uint256 _deadline,
  80 |     |     bool _stakeAsWell
  81 |     |   ) external payable {
  82 |     |     require(msg.value > 0, 'NATIVE');
  83 |     |     uint256 _ethBalBefore = address(this).balance - msg.value;
  84 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund
  85 |     |       .getAllAssets();
  86 |     |     (
  87 |     |       uint256[] memory _balancesBefore,
  88 |     |       uint256[] memory _amountsReceived
  89 |     |     ) = _swapNativeForTokensWeightedV2(
  90 |     |         _indexFund,
  91 |     |         _stakeAsWell ? msg.value / 2 : msg.value,
  92 |     |         _assets,
  93 |     |         _assetIdx,
  94 |     |         _amountTokensForAssetIdx
  95 |     |       );
  96 |     | 
  97 |     |     // allowance for _assetIdx is increased in _bondToRecipient below,
  98 |     |     // we just need to increase allowance for any other index tokens here first
  99 |     |     for (uint256 _i; _i < _assets.length; _i++) {
 100 |     |       if (_i == _assetIdx) {
 101 |     |         continue;
 102 |     |       }
 103 |     |       IERC20(_assets[_i].token).safeIncreaseAllowance(
 104 |     |         address(_indexFund),
 105 |     |         _amountsReceived[_i]
 106 |     |       );
 107 |     |     }
 108 |     |     uint256 _idxTokensGained = _bondToRecipient(
 109 |     |       _indexFund,
 110 |     |       _assets[_assetIdx].token,
 111 |     |       _amountsReceived[_assetIdx],
 112 |     |       _amountMintMin,
 113 |     |       _stakeAsWell ? address(this) : _msgSender()
 114 |     |     );
 115 |     | 
 116 |     |     if (_stakeAsWell) {
 117 |     |       _zapIndexTokensAndNative(
 118 |     |         _msgSender(),
 119 |     |         _indexFund,
 120 |     |         _idxTokensGained,
 121 |     |         msg.value / 2,
 122 |     |         _amountPairedLpTokenMin,
 123 |     |         _slippage,
 124 |     |         _deadline
 125 |     |       );
 126 |     |     }
 127 |     | 
 128 |     |     // refund any excess tokens to user we didn't use to bond
 129 |     |     for (uint256 _i; _i < _assets.length; _i++) {
 130 |     |       _checkAndRefundERC20(
 131 |     |         _msgSender(),
 132 |     |         _assets[_i].token,
 133 |     |         _balancesBefore[_i]
 134 |     |       );
 135 |     |     }
 136 |     | 
 137 |     |     // refund excess ETH
 138 |     |     if (address(this).balance > _ethBalBefore) {
 139 |     |       (bool _s, ) = payable(_msgSender()).call{
 140 |     |         value: address(this).balance - _ethBalBefore
 141 |     |       }('');
 142 |     |       require(_s, 'ETHREFUND');
 143 |     |     }
 144 |     |   }
 145 |     | 
 146 |     |   function addLPAndStake(
 147 |     |     IDecentralizedIndex _indexFund,
 148 |     |     uint256 _amountIdxTokens,
 149 |     |     address _pairedLpTokenProvided,
 150 |     |     uint256 _amtPairedLpTokenProvided,
 151 |     |     uint256 _amountPairedLpTokenMin,
 152 |     |     uint256 _slippage,
 153 |     |     uint256 _deadline
 154 |     |   ) external payable override returns (uint256 _amountOut) {
 155 |     |     address _indexFundAddy = address(_indexFund);
 156 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 157 |     |     uint256 _idxTokensBefore = IERC20(_indexFundAddy).balanceOf(address(this));
 158 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 159 |     |       address(this)
 160 |     |     );
 161 |     |     uint256 _ethBefore = address(this).balance - msg.value;
 162 |     |     IERC20(_indexFundAddy).safeTransferFrom(
 163 |     |       _msgSender(),
 164 |     |       address(this),
 165 |     |       _amountIdxTokens
 166 |     |     );
 167 |     |     if (_pairedLpTokenProvided == address(0)) {
 168 |     |       require(msg.value > 0, 'NEEDETH');
 169 |     |       _amtPairedLpTokenProvided = msg.value;
 170 |     |     } else {
 171 |     |       IERC20(_pairedLpTokenProvided).safeTransferFrom(
 172 |     |         _msgSender(),
 173 |     |         address(this),
 174 |     |         _amtPairedLpTokenProvided
 175 |     |       );
 176 |     |     }
 177 |     |     if (_pairedLpTokenProvided != _pairedLpToken) {
 178 |     |       _zap(
 179 |     |         _pairedLpTokenProvided,
 180 |     |         _pairedLpToken,
 181 |     |         _amtPairedLpTokenProvided,
 182 |     |         _amountPairedLpTokenMin
 183 |     |       );
 184 |     |     }
 185 |     | 
 186 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(
 187 |     |       _indexFundAddy,
 188 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 189 |     |     );
 190 |     |     _amountOut = _indexFund.addLiquidityV2(
 191 |     |       IERC20(_indexFundAddy).balanceOf(address(this)) - _idxTokensBefore,
 192 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,
 193 |     |       _slippage,
 194 |     |       _deadline
 195 |     |     );
 196 |     | 
 197 |     |     IERC20(DEX_ADAPTER.getV2Pool(_indexFundAddy, _pairedLpToken))
 198 |     |       .safeIncreaseAllowance(_indexFund.lpStakingPool(), _amountOut);
 199 |     |     IStakingPoolToken(_indexFund.lpStakingPool()).stake(
 200 |     |       _msgSender(),
 201 |     |       _amountOut
 202 |     |     );
 203 |     | 
 204 |     |     // refunds if needed for index tokens and pairedLpToken
 205 |     |     if (address(this).balance > _ethBefore) {
 206 |     |       (bool _s, ) = payable(_msgSender()).call{
 207 |     |         value: address(this).balance - _ethBefore
 208 |     |       }('');
 209 |     |       require(_s && address(this).balance >= _ethBefore, 'TOOMUCH');
 210 |     |     }
 211 |     |     _checkAndRefundERC20(_msgSender(), _indexFundAddy, _idxTokensBefore);
 212 |     |     _checkAndRefundERC20(_msgSender(), _pairedLpToken, _pairedLpTokenBefore);
 213 |     |   }
 214 |     | 
 215 |     |   function unstakeAndRemoveLP(
 216 |     |     IDecentralizedIndex _indexFund,
 217 |     |     uint256 _amountStakedTokens,
 218 |     |     uint256 _minLPTokens,
 219 |     |     uint256 _minPairedLpToken,
 220 |     |     uint256 _deadline
 221 |     |   ) external override {
 222 |     |     address _stakingPool = _indexFund.lpStakingPool();
 223 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 224 |     |     uint256 _stakingBalBefore = IERC20(_stakingPool).balanceOf(address(this));
 225 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 226 |     |       address(this)
 227 |     |     );
 228 |     |     IERC20(_stakingPool).safeTransferFrom(
 229 |     |       _msgSender(),
 230 |     |       address(this),
 231 |     |       _amountStakedTokens
 232 |     |     );
 233 |     |     uint256 _indexBalBefore = _unstakeAndRemoveLP(
 234 |     |       _indexFund,
 235 |     |       _stakingPool,
 236 |     |       IERC20(_stakingPool).balanceOf(address(this)) - _stakingBalBefore,
 237 |     |       _minLPTokens,
 238 |     |       _minPairedLpToken,
 239 |     |       _deadline
 240 |     |     );
 241 |     |     if (
 242 |     |       IERC20(address(_indexFund)).balanceOf(address(this)) > _indexBalBefore
 243 |     |     ) {
 244 |     |       IERC20(address(_indexFund)).safeTransfer(
 245 |     |         _msgSender(),
 246 |     |         IERC20(address(_indexFund)).balanceOf(address(this)) - _indexBalBefore
 247 |     |       );
 248 |     |     }
 249 |     |     if (
 250 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) > _pairedLpTokenBefore
 251 |     |     ) {
 252 |     |       IERC20(_pairedLpToken).safeTransfer(
 253 |     |         _msgSender(),
 254 |     |         IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 255 |     |       );
 256 |     |     }
 257 |     |   }
 258 |     | 
 259 |     |   function claimRewardsMulti(address[] memory _rewards) external {
 260 |     |     uint256 _rl = _rewards.length;
 261 |     |     for (uint256 _i; _i < _rl; _i++) {
 262 |     |       ITokenRewards(_rewards[_i]).claimReward(_msgSender());
 263 |     |     }
 264 |     |   }
 265 |     | 
 266 |     |   function _swapNativeForTokensWeightedV2(
 267 |     |     IDecentralizedIndex _indexFund,
 268 |     |     uint256 _amountNative,
 269 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets,
 270 |     |     uint256 _poolIdx,
 271 |     |     uint256 _amountForPoolIdx
 272 |     |   ) internal returns (uint256[] memory, uint256[] memory) {
 273 |     |     uint256[] memory _amountBefore = new uint256[](_assets.length);
 274 |     |     uint256[] memory _amountReceived = new uint256[](_assets.length);
 275 |     |     uint256 _tokenCurSupply = IERC20(_assets[_poolIdx].token).balanceOf(
 276 |     |       address(_indexFund)
 277 |     |     );
 278 |     |     uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0
 279 |     |       ? FixedPoint96.Q96
 280 |     |       : (_amountForPoolIdx * FixedPoint96.Q96) / _tokenCurSupply;
 281 |     |     uint256 _nativeLeft = _amountNative;
 282 |     |     uint256 _al = _assets.length;
 283 |     |     for (uint256 _i; _i < _al; _i++) {
 284 |     |       (_nativeLeft, _amountBefore[_i], _amountReceived[_i]) = _swapForIdxToken(
 285 |     |         _indexFund,
 286 |     |         _assets[_poolIdx].token,
 287 |     |         _amountForPoolIdx,
 288 |     |         _assets[_i].token,
 289 |     |         _tokenAmtSupplyRatioX96,
 290 |     |         _nativeLeft
 291 |     |       );
 292 |     |     }
 293 |     |     return (_amountBefore, _amountReceived);
 294 |     |   }
 295 |     | 
 296 |     |   function _swapForIdxToken(
 297 |     |     IDecentralizedIndex _indexFund,
 298 |     |     address _initToken,
 299 |     |     uint256 _initTokenAmount,
 300 |     |     address _outToken,
 301 |     |     uint256 _tokenAmtSupplyRatioX96,
 302 |     |     uint256 _nativeLeft
 303 |     |   )
 304 |     |     internal
 305 |     |     returns (
 306 |     |       uint256 _newNativeLeft,
 307 |     |       uint256 _amountBefore,
 308 |     |       uint256 _amountReceived
 309 |     |     )
 310 |     |   {
 311 |     |     address _weth = DEX_ADAPTER.WETH();
 312 |     |     if (address(this).balance > 0) {
 313 |     |       IWETH(WETH).deposit{ value: address(this).balance }();
 314 |     |     }
 315 |     |     uint256 _nativeBefore = IERC20(_weth).balanceOf(address(this));
 316 |     |     _amountBefore = IERC20(_outToken).balanceOf(address(this));
 317 |     |     uint256 _amountOut = _indexFund.totalSupply() == 0
 318 |     |       ? _indexFund.getInitialAmount(_initToken, _initTokenAmount, _outToken)
 319 |     |       : (IERC20(_outToken).balanceOf(address(_indexFund)) *
 320 |     |         _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;
 321 |     |     DEX_ADAPTER.swapV2Single(
 322 |     |       _weth,
 323 |     |       _outToken,
 324 |     |       _nativeLeft,
 325 |     |       _amountOut,
 326 |     |       address(this)
 327 |     |     );
 328 |     |     _newNativeLeft =
 329 |     |       _nativeLeft -
 330 |     |       (_nativeBefore - IERC20(_weth).balanceOf(address(this)));
 331 |     |     _amountReceived =
 332 |     |       IERC20(_outToken).balanceOf(address(this)) -
 333 |     |       _amountBefore;
 334 |     |   }
 335 |     | 
 336 |     |   function _unstakeAndRemoveLP(
 337 |     |     IDecentralizedIndex _indexFund,
 338 |     |     address _stakingPool,
 339 |     |     uint256 _unstakeAmount,
 340 |     |     uint256 _minLPTokens,
 341 |     |     uint256 _minPairedLpTokens,
 342 |     |     uint256 _deadline
 343 |     |   ) internal returns (uint256 _fundTokensBefore) {
 344 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 345 |     |     address _v2Pool = DEX_ADAPTER.getV2Pool(
 346 |     |       address(_indexFund),
 347 |     |       _pairedLpToken
 348 |     |     );
 349 |     |     uint256 _v2TokensBefore = IERC20(_v2Pool).balanceOf(address(this));
 350 |     |     IStakingPoolToken(_stakingPool).unstake(_unstakeAmount);
 351 |     | 
 352 |     |     _fundTokensBefore = _indexFund.balanceOf(address(this));
 353 |     |     IERC20(_v2Pool).safeIncreaseAllowance(
 354 |     |       address(_indexFund),
 355 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore
 356 |     |     );
 357 |     |     _indexFund.removeLiquidityV2(
 358 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore,
 359 |     |       _minLPTokens,
 360 |     |       _minPairedLpTokens,
 361 |     |       _deadline
 362 |     |     );
 363 |     |   }
 364 |     | 
 365 |     |   function _bondToRecipient(
 366 |     |     IDecentralizedIndex _indexFund,
 367 |     |     address _indexToken,
 368 |     |     uint256 _bondTokens,
 369 |     |     uint256 _amountMintMin,
 370 |     |     address _recipient
 371 |     |   ) internal returns (uint256) {
 372 |     |     uint256 _idxTokensBefore = IERC20(address(_indexFund)).balanceOf(
 373 |     |       address(this)
 374 |     |     );
 375 |     |     IERC20(_indexToken).safeIncreaseAllowance(address(_indexFund), _bondTokens);
 376 |     |     _indexFund.bond(_indexToken, _bondTokens, _amountMintMin);
 377 |     |     uint256 _idxTokensGained = IERC20(address(_indexFund)).balanceOf(
 378 |     |       address(this)
 379 |     |     ) - _idxTokensBefore;
 380 |     |     if (_recipient != address(this)) {
 381 |     |       IERC20(address(_indexFund)).safeTransfer(_recipient, _idxTokensGained);
 382 |     |     }
 383 |     |     return _idxTokensGained;
 384 |     |   }
 385 |     | 
 386 |     |   function _zapIndexTokensAndNative(
 387 |     |     address _user,
 388 |     |     IDecentralizedIndex _indexFund,
 389 |     |     uint256 _amountTokens,
 390 |     |     uint256 _amountETH,
 391 |     |     uint256 _amtPairedLpTokenMin,
 392 |     |     uint256 _slippage,
 393 |     |     uint256 _deadline
 394 |     |   ) internal {
 395 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 396 |     |     uint256 _tokensBefore = IERC20(address(_indexFund)).balanceOf(
 397 |     |       address(this)
 398 |     |     ) - _amountTokens;
 399 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 400 |     |       address(this)
 401 |     |     );
 402 |     |     address _stakingPool = _indexFund.lpStakingPool();
 403 |     | 
 404 |     |     _zap(address(0), _pairedLpToken, _amountETH, _amtPairedLpTokenMin);
 405 |     | 
 406 |     |     address _v2Pool = DEX_ADAPTER.getV2Pool(
 407 |     |       address(_indexFund),
 408 |     |       _pairedLpToken
 409 |     |     );
 410 |     |     uint256 _lpTokensBefore = IERC20(_v2Pool).balanceOf(address(this));
 411 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(
 412 |     |       address(_indexFund),
 413 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 414 |     |     );
 415 |     |     _indexFund.addLiquidityV2(
 416 |     |       _amountTokens,
 417 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,
 418 |     |       _slippage,
 419 |     |       _deadline
 420 |     |     );
 421 |     |     IERC20(_v2Pool).safeIncreaseAllowance(
 422 |     |       _stakingPool,
 423 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore
 424 |     |     );
 425 |     |     IStakingPoolToken(_stakingPool).stake(
 426 |     |       _user,
 427 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore
 428 |     |     );
 429 |     | 
 430 |     |     // check & refund excess tokens from LPing as needed
 431 |     |     if (IERC20(address(_indexFund)).balanceOf(address(this)) > _tokensBefore) {
 432 |     |       IERC20(address(_indexFund)).safeTransfer(
 433 |     |         _user,
 434 |     |         IERC20(address(_indexFund)).balanceOf(address(this)) - _tokensBefore
 435 |     |       );
 436 |     |     }
 437 |     |     if (
 438 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) > _pairedLpTokenBefore
 439 |     |     ) {
 440 |     |       IERC20(_pairedLpToken).safeTransfer(
 441 |     |         _user,
 442 |     |         IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 443 |     |       );
 444 |     |     }
 445 |     |   }
 446 |     | 
 447 |     |   function _checkAndRefundERC20(
 448 |     |     address _user,
 449 |     |     address _asset,
 450 |     |     uint256 _beforeBal
 451 |     |   ) internal {
 452 |     |     uint256 _curBal = IERC20(_asset).balanceOf(address(this));
 453 |     |     if (_curBal > _beforeBal) {
 454 |     |       IERC20(_asset).safeTransfer(_user, _curBal - _beforeBal);
 455 |     |     }
 456 |     |   }
 457 |     | }
 458 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/LendingAssetVault.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';
   8 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   9 |     | import './interfaces/ILendingAssetVault.sol';
  10 |     | 
  11 |     | interface IVaultInterestUpdate {
  12 |     |   function addInterest() external;
  13 |     | }
  14 |     | 
  15 |     | contract LendingAssetVault is
  16 |     |   IERC4626,
  17 |     |   ILendingAssetVault,
  18 |     |   ERC20,
  19 |     |   ERC20Permit,
  20 |     |   Ownable
  21 |     | {
  22 |     |   using SafeERC20 for IERC20;
  23 |     | 
  24 |     |   uint16 constant PERCENTAGE_PRECISION = 10000;
  25 |     |   uint256 constant PRECISION = 10 ** 27;
  26 |     | 
  27 |     |   address _asset;
  28 |     |   uint256 _totalAssets;
  29 |     |   uint256 _totalAssetsUtilized;
  30 |     |   bool _updateInterestOnVaults = true;
  31 |     | 
  32 |     |   uint8 public maxVaults = 12;
  33 |     |   uint256 public lastAssetChange;
  34 |     |   mapping(address => bool) public vaultWhitelist;
  35 |     |   mapping(address => uint256) public vaultUtilization;
  36 |     |   mapping(address => uint256) _vaultMaxPerc;
  37 |     |   mapping(address => uint256) _vaultWhitelistCbr;
  38 |     | 
  39 |     |   address[] _vaultWhitelistAry;
  40 |     |   // vault address => idx in _vaultWhitelistAry
  41 |     |   mapping(address => uint256) _vaultWhitelistAryIdx;
  42 |     | 
  43 |     |   modifier onlyWhitelist() {
  44 |     |     require(vaultWhitelist[_msgSender()], 'WL');
  45 |     |     _;
  46 |     |   }
  47 |     | 
  48 |     |   constructor(
  49 |     |     string memory _name,
  50 |     |     string memory _symbol,
  51 |     |     address __asset
  52 |     |   ) ERC20(_name, _symbol) ERC20Permit(_name) {
  53 |     |     _asset = __asset;
  54 |     |   }
  55 |     | 
  56 |     |   function asset() external view override returns (address) {
  57 |     |     return _asset;
  58 |     |   }
  59 |     | 
  60 |     |   function totalAssets() public view override returns (uint256) {
  61 |     |     return _totalAssets;
  62 |     |   }
  63 |     | 
  64 |     |   function totalAvailableAssets() public view override returns (uint256) {
  65 |     |     return _totalAssets - _totalAssetsUtilized;
  66 |     |   }
  67 |     | 
  68 |     |   function convertToShares(
  69 |     |     uint256 _assets
  70 |     |   ) public view override returns (uint256 _shares) {
  71 |     |     _shares = (_assets * PRECISION) / _cbr();
  72 |     |   }
  73 |     | 
  74 |     |   function convertToAssets(
  75 |     |     uint256 _shares
  76 |     |   ) public view override returns (uint256 _assets) {
  77 |     |     _assets = (_shares * _cbr()) / PRECISION;
  78 |     |   }
  79 |     | 
  80 |     |   function maxDeposit(
  81 |     |     address
  82 |     |   ) external pure override returns (uint256 maxAssets) {
  83 |     |     maxAssets = type(uint256).max - 1;
  84 |     |   }
  85 |     | 
  86 |     |   function previewDeposit(
  87 |     |     uint256 _assets
  88 |     |   ) external view override returns (uint256 _shares) {
  89 |     |     _shares = convertToShares(_assets);
  90 |     |   }
  91 |     | 
  92 |     |   function deposit(
  93 |     |     uint256 _assets,
  94 |     |     address _receiver
  95 |     |   ) external override returns (uint256 _shares) {
  96 |     |     _shares = _deposit(_assets, _receiver);
  97 |     |   }
  98 |     | 
  99 |     |   function _deposit(
 100 |     |     uint256 _assets,
 101 |     |     address _receiver
 102 |     |   ) internal returns (uint256 _shares) {
 103 |     |     lastAssetChange = block.timestamp;
 104 |     |     _shares = convertToShares(_assets);
 105 |     |     _totalAssets += _assets;
 106 |     |     _mint(_receiver, _shares);
 107 |     |     IERC20(_asset).safeTransferFrom(_msgSender(), address(this), _assets);
 108 |     |     _updateInterestInAllVaults();
 109 |     |     emit Deposit(_msgSender(), _receiver, _assets, _shares);
 110 |     |   }
 111 |     | 
 112 |     |   function maxMint(address) external pure override returns (uint256 maxShares) {
 113 |     |     maxShares = type(uint256).max - 1;
 114 |     |   }
 115 |     | 
 116 |     |   function previewMint(
 117 |     |     uint256 _shares
 118 |     |   ) external view override returns (uint256 _assets) {
 119 |     |     _assets = convertToAssets(_shares);
 120 |     |   }
 121 |     | 
 122 |     |   function mint(
 123 |     |     uint256 _shares,
 124 |     |     address _receiver
 125 |     |   ) external override returns (uint256 _assets) {
 126 |     |     _assets = convertToAssets(_shares);
 127 |     |     _deposit(_assets, _receiver);
 128 |     |   }
 129 |     | 
 130 |     |   function maxWithdraw(
 131 |     |     address _owner
 132 |     |   ) external view override returns (uint256 _maxAssets) {
 133 |     |     _maxAssets = (balanceOf(_owner) * _cbr()) / PRECISION;
 134 |     |   }
 135 |     | 
 136 |     |   function previewWithdraw(
 137 |     |     uint256 _assets
 138 |     |   ) external view override returns (uint256 _shares) {
 139 |     |     _shares = convertToShares(_assets);
 140 |     |   }
 141 |     | 
 142 |     |   function withdraw(
 143 |     |     uint256 _assets,
 144 |     |     address _receiver,
 145 |     |     address
 146 |     |   ) external override returns (uint256 _shares) {
 147 |     |     _shares = convertToShares(_assets);
 148 |     |     _withdraw(_shares, _receiver);
 149 |     |   }
 150 |     | 
 151 |     |   function maxRedeem(
 152 |     |     address _owner
 153 |     |   ) external view override returns (uint256 _maxShares) {
 154 |     |     _maxShares = balanceOf(_owner);
 155 |     |   }
 156 |     | 
 157 |     |   function previewRedeem(
 158 |     |     uint256 _shares
 159 |     |   ) external view override returns (uint256 _assets) {
 160 |     |     return convertToAssets(_shares);
 161 |     |   }
 162 |     | 
 163 |     |   function redeem(
 164 |     |     uint256 _shares,
 165 |     |     address _receiver,
 166 |     |     address
 167 |     |   ) external override returns (uint256 _assets) {
 168 |     |     _assets = _withdraw(_shares, _receiver);
 169 |     |   }
 170 |     | 
 171 |     |   function donate(uint256 _assetAmt) external {
 172 |     |     _deposit(_assetAmt, address(this));
 173 |     |     _burn(address(this), convertToShares(_assetAmt));
 174 |     |     emit DonateAssets(_msgSender(), _assetAmt);
 175 |     |   }
 176 |     | 
 177 |     |   /// @notice The ```whitelistWithdraw``` is called by any whitelisted vault to withdraw assets.
 178 |     |   /// @param _assetAmt the amount of underlying assets to withdraw
 179 |     |   function whitelistWithdraw(
 180 |     |     uint256 _assetAmt
 181 |     |   ) external override onlyWhitelist {
 182 |     |     address _vault = _msgSender();
 183 |     |     _updateAssetMetadataFromVault(_vault);
 184 |     | 
 185 |     |     // validate that our new vault utilization does not exceed our max. Since we
 186 |     |     // call this after updating _totalAssets above it reflects the latest total,
 187 |     |     // but this is okay since we should validate total utilization after we account
 188 |     |     // for changes from this vault anyways
 189 |     |     require(
 190 |     |       (PERCENTAGE_PRECISION * (vaultUtilization[_vault] + _assetAmt)) /
 191 |     |         _totalAssets <=
 192 |     |         _vaultMaxPerc[_vault],
 193 |     |       'MAX'
 194 |     |     );
 195 |     |     vaultUtilization[_vault] += _assetAmt;
 196 |     |     _totalAssetsUtilized += _assetAmt;
 197 |     |     IERC20(_asset).safeTransfer(_vault, _assetAmt);
 198 |     |     emit WhitelistWithdraw(_vault, _assetAmt);
 199 |     |   }
 200 |     | 
 201 |     |   /// @notice The ```whitelistDeposit``` is called by any whitelisted target vault to deposit assets back into this vault.
 202 |     |   /// @notice need this instead of direct depositing in order to handle accounting for used assets and validation
 203 |     |   /// @param _assetAmt the amount of underlying assets to deposit
 204 |     |   function whitelistDeposit(uint256 _assetAmt) external override onlyWhitelist {
 205 |     |     address _vault = _msgSender();
 206 |     |     _updateAssetMetadataFromVault(_vault);
 207 |     |     vaultUtilization[_vault] -= _assetAmt;
 208 |     |     _totalAssetsUtilized -= _assetAmt;
 209 |     |     IERC20(_asset).safeTransferFrom(_vault, address(this), _assetAmt);
 210 |     |     emit WhitelistDeposit(_vault, _assetAmt);
 211 |     |   }
 212 |     | 
 213 |     |   /// @notice The ```_updateAssetMetadataFromVault``` updates _totalAssets based on  the current ratio
 214 |     |   /// @notice of assets in the target vault to previously recorded ratio
 215 |     |   /// @notice to correctly calculate the change in total assets here based on how the vault share
 216 |     |   /// @notice has changed over time
 217 |     |   /// @param _vault the vault we're adjusting _totalAssets from based on it's CBR updates from last check
 218 |     |   function _updateAssetMetadataFromVault(address _vault) internal {
 219 |     |     uint256 _prevVaultCbr = _vaultWhitelistCbr[_vault];
 220 |     |     _vaultWhitelistCbr[_vault] = IERC4626(_vault).convertToAssets(PRECISION);
 221 |     |     if (_prevVaultCbr == 0) {
 222 |     |       return;
 223 |     |     }
 224 |     |     uint256 _vaultAssetRatioChange = _prevVaultCbr > _vaultWhitelistCbr[_vault]
 225 |     |       ? ((PRECISION * _prevVaultCbr) / _vaultWhitelistCbr[_vault]) - PRECISION
 226 |     |       : ((PRECISION * _vaultWhitelistCbr[_vault]) / _prevVaultCbr) - PRECISION;
 227 |     | 
 228 |     |     uint256 _currentAssetsUtilized = vaultUtilization[_vault];
 229 |     |     vaultUtilization[_vault] = _prevVaultCbr > _vaultWhitelistCbr[_vault]
 230 |     |       ? _currentAssetsUtilized -
 231 |     |         (_currentAssetsUtilized * _vaultAssetRatioChange) /
 232 |     |         PRECISION
 233 |     |       : _currentAssetsUtilized +
 234 |     |         (_currentAssetsUtilized * _vaultAssetRatioChange) /
 235 |     |         PRECISION;
 236 |     |     _totalAssetsUtilized =
 237 |     |       _totalAssetsUtilized -
 238 |     |       _currentAssetsUtilized +
 239 |     |       vaultUtilization[_vault];
 240 |     |     _totalAssets =
 241 |     |       _totalAssets -
 242 |     |       _currentAssetsUtilized +
 243 |     |       vaultUtilization[_vault];
 244 |     |   }
 245 |     | 
 246 |     |   function _withdraw(
 247 |     |     uint256 _shares,
 248 |     |     address _receiver
 249 |     |   ) internal returns (uint256 _assets) {
 250 |     |     lastAssetChange = block.timestamp;
 251 |     |     _assets = convertToAssets(_shares);
 252 |     |     _burn(_msgSender(), _shares);
 253 |     |     IERC20(_asset).safeTransfer(_receiver, _assets);
 254 |     |     _totalAssets -= _assets;
 255 |     |     _updateInterestInAllVaults();
 256 |     |     emit Withdraw(_msgSender(), _receiver, _receiver, _assets, _shares);
 257 |     |   }
 258 |     | 
 259 |     |   /// @notice Assumes underlying vault asset has decimals == 18
 260 |     |   function _cbr() internal view returns (uint256) {
 261 |     |     uint256 _supply = totalSupply();
 262 |     |     return _supply == 0 ? PRECISION : (PRECISION * _totalAssets) / _supply;
 263 |     |   }
 264 |     | 
 265 |     |   function _assetDecimals() internal view returns (uint8) {
 266 |     |     return IERC20Metadata(_asset).decimals();
 267 |     |   }
 268 |     | 
 269 |     |   function _updateInterestInAllVaults() internal {
 270 |     |     if (!_updateInterestOnVaults) {
 271 |     |       return;
 272 |     |     }
 273 |     |     for (uint256 _i; _i < _vaultWhitelistAry.length; _i++) {
 274 |     |       IVaultInterestUpdate(_vaultWhitelistAry[_i]).addInterest();
 275 |     |     }
 276 |     |   }
 277 |     | 
 278 |     |   function setMaxVaults(uint8 _newMax) external onlyOwner {
 279 |     |     require(_newMax <= 20, 'M');
 280 |     |     maxVaults = _newMax;
 281 |     |   }
 282 |     | 
 283 |     |   function setUpdateInterestOnVaults(bool _exec) external onlyOwner {
 284 |     |     require(_updateInterestOnVaults != _exec, 'T');
 285 |     |     _updateInterestOnVaults = _exec;
 286 |     |   }
 287 |     | 
 288 |     |   function setVaultWhitelist(address _vault, bool _allowed) external onlyOwner {
 289 |     |     require(vaultWhitelist[_vault] != _allowed, 'T');
 290 |     |     vaultWhitelist[_vault] = _allowed;
 291 |     |     if (_allowed) {
 292 |     |       require(_vaultWhitelistAry.length <= maxVaults, 'M');
 293 |     |       _vaultWhitelistAryIdx[_vault] = _vaultWhitelistAry.length;
 294 |     |       _vaultWhitelistAry.push(_vault);
 295 |     |     } else {
 296 |     |       uint256 _idx = _vaultWhitelistAryIdx[_vault];
 297 |     |       address _movingVault = _vaultWhitelistAry[_vaultWhitelistAry.length - 1];
 298 |     |       _vaultWhitelistAry[_idx] = _movingVault;
 299 |     |       _vaultWhitelistAryIdx[_movingVault] = _idx;
 300 |     |       _vaultWhitelistAry.pop();
 301 |     |     }
 302 |     |     emit SetVaultWhitelist(_vault, _allowed);
 303 |     |   }
 304 |     | 
 305 |     |   /// @notice The ```setVaultMaxPerc``` sets the maximum amount of vault assets allowed to be allocated to a whitelisted vault
 306 |     |   /// @param _vault the vault we're allocating to
 307 |     |   /// @param _percentage the percentage, up to PERCENTAGE_PRECISION (100%), of assets we can allocate to this vault
 308 |     |   function setVaultMaxPerc(
 309 |     |     address _vault,
 310 |     |     uint256 _percentage
 311 |     |   ) external onlyOwner {
 312 |     |     require(_percentage <= PERCENTAGE_PRECISION, 'MAX');
 313 |     |     _vaultMaxPerc[_vault] = _percentage;
 314 |     |     emit SetVaultMaxAlloPercentage(_vault, _percentage);
 315 |     |   }
 316 |     | }
 317 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/PEAS.sol
  1 |     | // https://peapods.finance
  2 |     | 
  3 |     | // SPDX-License-Identifier: MIT
  4 |     | pragma solidity ^0.8.19;
  5 |     | 
  6 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
  7 |     | import './interfaces/IPEAS.sol';
  8 |     | 
  9 | *   | contract PEAS is IPEAS, ERC20 {
 10 |     |   constructor(
 11 |     |     string memory _name,
 12 |     |     string memory _symbol
 13 |     |   ) ERC20(_name, _symbol) {
 14 |     |     _mint(_msgSender(), 10_000_000 * 10 ** 18);
 15 |     |   }
 16 |     | 
 17 |     |   function burn(uint256 _amount) external virtual override {
 18 |     |     _burn(_msgSender(), _amount);
 19 |     |     emit Burn(_msgSender(), _amount);
 20 |     |   }
 21 |     | }
 22 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/RewardsWhitelist.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
  5 |     | import './interfaces/IRewardsWhitelister.sol';
  6 |     | 
  7 |     | contract RewardsWhitelist is IRewardsWhitelister, Ownable {
  8 |     |   mapping(address => bool) public override whitelist;
  9 |     |   address[] public _whitelistAry;
 10 |     |   mapping(address => uint256) _whitelistAryIdx;
 11 |     | 
 12 |     |   event ToggleToken(address indexed token, bool isWhitelisted);
 13 |     | 
 14 |     |   function getFullWhitelist()
 15 |     |     external
 16 |     |     view
 17 |     |     override
 18 |     |     returns (address[] memory)
 19 |     |   {
 20 |     |     return _whitelistAry;
 21 |     |   }
 22 |     | 
 23 |     |   function toggleRewardsToken(
 24 |     |     address _token,
 25 |     |     bool _isWhitelisted
 26 |     |   ) external onlyOwner {
 27 |     |     require(whitelist[_token] != _isWhitelisted, 'OPP');
 28 |     |     whitelist[_token] = _isWhitelisted;
 29 |     |     if (_isWhitelisted) {
 30 |     |       _whitelistAryIdx[_token] = _whitelistAry.length;
 31 |     |       _whitelistAry.push(_token);
 32 |     |     } else {
 33 |     |       uint256 _idx = _whitelistAryIdx[_token];
 34 |     |       _whitelistAry[_idx] = _whitelistAry[_whitelistAry.length - 1];
 35 |     |       _whitelistAryIdx[_whitelistAry[_idx]] = _idx;
 36 |     |       _whitelistAry.pop();
 37 |     |     }
 38 |     |     emit ToggleToken(_token, _isWhitelisted);
 39 |     |   }
 40 |     | }
 41 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/StakingPoolToken.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   7 |     | import './interfaces/IDexAdapter.sol';
   8 |     | import './interfaces/IRewardsWhitelister.sol';
   9 |     | import './interfaces/IProtocolFeeRouter.sol';
  10 |     | import './interfaces/IStakingPoolToken.sol';
  11 |     | import './TokenRewards.sol';
  12 |     | 
  13 |     | contract StakingPoolToken is IStakingPoolToken, ERC20, Ownable {
  14 |     |   using SafeERC20 for IERC20;
  15 |     | 
  16 |     |   address public immutable override INDEX_FUND;
  17 |     |   address public immutable override POOL_REWARDS;
  18 |     | 
  19 |     |   address public override stakeUserRestriction;
  20 |     |   address public override stakingToken;
  21 |     | 
  22 |     |   IDexAdapter immutable DEX_ADAPTER;
  23 |     |   IV3TwapUtilities immutable V3_TWAP_UTILS;
  24 |     | 
  25 |     |   modifier onlyRestricted() {
  26 |     |     require(_msgSender() == stakeUserRestriction, 'R');
  27 |     |     _;
  28 |     |   }
  29 |     | 
  30 |     |   event Debug(string a);
  31 |     | 
  32 |     |   constructor(
  33 |     |     string memory _name,
  34 |     |     string memory _symbol,
  35 |     |     address _pairedLpToken,
  36 |     |     address _rewardsToken,
  37 |     |     address _stakeUserRestriction,
  38 |     |     IProtocolFeeRouter _feeRouter,
  39 |     |     IRewardsWhitelister _rewardsWhitelist,
  40 |     |     IDexAdapter _dexAdapter,
  41 |     |     IV3TwapUtilities _v3TwapUtilities
  42 |     |   ) ERC20(_name, _symbol) {
  43 |     |     emit Debug("BEFORE TOKEN REWARDS");
  44 |     |     stakeUserRestriction = _stakeUserRestriction;
  45 |     |     INDEX_FUND = _msgSender();
  46 |     |     DEX_ADAPTER = _dexAdapter;
  47 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  48 |     | 
  49 |     |     emit Debug("BEFORE TOKEN REWARDS");
  50 |     |     POOL_REWARDS = address(
  51 |     |       new TokenRewards(
  52 |     |         _feeRouter,
  53 |     |         _rewardsWhitelist,
  54 |     |         _dexAdapter,
  55 |     |         _v3TwapUtilities,
  56 |     |         INDEX_FUND,
  57 |     |         _pairedLpToken,
  58 |     |         address(this),
  59 |     |         _rewardsToken
  60 |     |       )
  61 |     |     );
  62 |     |     emit Debug("AFTER TOKEN REWARDS");
  63 |     |   }
  64 |     | 
  65 |     |   /// @dev backwards compatibility
  66 |     |   function indexFund() external view override returns (address) {
  67 |     |     return INDEX_FUND;
  68 |     |   }
  69 |     | 
  70 |     |   /// @dev backwards compatibility
  71 |     |   function poolRewards() external view override returns (address) {
  72 |     |     return POOL_REWARDS;
  73 |     |   }
  74 |     | 
  75 |     |   function stake(address _user, uint256 _amount) external override {
  76 |     |     require(stakingToken != address(0), 'I');
  77 |     |     if (stakeUserRestriction != address(0)) {
  78 |     |       require(_user == stakeUserRestriction, 'U');
  79 |     |     }
  80 |     |     _mint(_user, _amount);
  81 |     |     IERC20(stakingToken).safeTransferFrom(_msgSender(), address(this), _amount);
  82 |     |     emit Stake(_msgSender(), _user, _amount);
  83 |     |   }
  84 |     | 
  85 |     |   function unstake(uint256 _amount) external override {
  86 |     |     _burn(_msgSender(), _amount);
  87 |     |     IERC20(stakingToken).safeTransfer(_msgSender(), _amount);
  88 |     |     emit Unstake(_msgSender(), _amount);
  89 |     |   }
  90 |     | 
  91 |     |   function externalRewardHook(
  92 |     |     address _token0,
  93 |     |     address _token1
  94 |     |   ) external override {
  95 |     |     (bool _success, bytes memory _data) = address(DEX_ADAPTER).delegatecall(
  96 |     |       abi.encodeWithSignature(
  97 |     |         'extraRewardsHook(address,address)',
  98 |     |         _token0,
  99 |     |         _token1
 100 |     |       )
 101 |     |     );
 102 |     |     require(_success, 'UNS');
 103 |     |     (address[] memory _tokens, uint256[] memory _amounts) = abi.decode(
 104 |     |       _data,
 105 |     |       (address[], uint256[])
 106 |     |     );
 107 |     |     address _receiver = Ownable(address(V3_TWAP_UTILS)).owner();
 108 |     |     for (uint256 _i; _i < _tokens.length; _i++) {
 109 |     |       if (_tokens[_i] == address(0)) {
 110 |     |         (bool _s, ) = payable(_receiver).call{ value: _amounts[_i] }('');
 111 |     |         require(_s, 'ES');
 112 |     |       } else {
 113 |     |         IERC20(_tokens[_i]).safeTransfer(_receiver, _amounts[_i]);
 114 |     |       }
 115 |     |     }
 116 |     |   }
 117 |     | 
 118 |     |   function setStakingToken(address _stakingToken) external onlyOwner {
 119 |     |     require(stakingToken == address(0), 'S');
 120 |     |     stakingToken = _stakingToken;
 121 |     |   }
 122 |     | 
 123 |     |   function removeStakeUserRestriction() external onlyRestricted {
 124 |     |     stakeUserRestriction = address(0);
 125 |     |   }
 126 |     | 
 127 |     |   function setStakeUserRestriction(address _user) external onlyRestricted {
 128 |     |     stakeUserRestriction = _user;
 129 |     |   }
 130 |     | 
 131 |     |   function _afterTokenTransfer(
 132 |     |     address _from,
 133 |     |     address _to,
 134 |     |     uint256 _amount
 135 |     |   ) internal override {
 136 |     |     if (_from != address(0) && _from != address(0xdead)) {
 137 |     |       TokenRewards(POOL_REWARDS).setShares(_from, _amount, true);
 138 |     |     }
 139 |     |     if (_to != address(0) && _to != address(0xdead)) {
 140 |     |       TokenRewards(POOL_REWARDS).setShares(_to, _amount, false);
 141 |     |     }
 142 |     |   }
 143 |     | }
 144 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/TokenRewards.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   7 |     | import '@openzeppelin/contracts/utils/Context.sol';
   8 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   9 |     | import './interfaces/IDecentralizedIndex.sol';
  10 |     | import './interfaces/IDexAdapter.sol';
  11 |     | import './interfaces/IPEAS.sol';
  12 |     | import './interfaces/IRewardsWhitelister.sol';
  13 |     | import './interfaces/IProtocolFees.sol';
  14 |     | import './interfaces/IProtocolFeeRouter.sol';
  15 |     | import './interfaces/ITokenRewards.sol';
  16 |     | import './interfaces/IV3TwapUtilities.sol';
  17 |     | 
  18 |     | contract TokenRewards is ITokenRewards, Context {
  19 |     |   using SafeERC20 for IERC20;
  20 |     | 
  21 |     |   uint256 constant PRECISION = 10 ** 36;
  22 |     |   uint256 constant REWARDS_SWAP_SLIPPAGE = 20; // 2%
  23 |     |   uint24 constant REWARDS_POOL_FEE = 10000; // 1%
  24 |     |   int24 constant REWARDS_TICK_SPACING = 200;
  25 |     |   address immutable INDEX_FUND;
  26 |     |   address immutable PAIRED_LP_TOKEN;
  27 |     |   IProtocolFeeRouter immutable PROTOCOL_FEE_ROUTER;
  28 |     |   IRewardsWhitelister immutable REWARDS_WHITELISTER;
  29 |     |   IDexAdapter immutable DEX_ADAPTER;
  30 |     |   IV3TwapUtilities immutable V3_TWAP_UTILS;
  31 |     | 
  32 |     |   struct Reward {
  33 |     |     uint256 excluded;
  34 |     |     uint256 realized;
  35 |     |   }
  36 |     | 
  37 |     |   address public immutable override trackingToken;
  38 |     |   address public immutable override rewardsToken; // main rewards token
  39 |     |   uint256 public override totalShares;
  40 |     |   uint256 public override totalStakers;
  41 |     |   mapping(address => uint256) public shares;
  42 |     |   // reward token => user => Reward
  43 |     |   mapping(address => mapping(address => Reward)) public rewards;
  44 |     | 
  45 |     |   uint256 _rewardsSwapAmountInOverride;
  46 |     |   // reward token => amount
  47 |     |   mapping(address => uint256) _rewardsPerShare;
  48 |     |   // reward token => amount
  49 |     |   mapping(address => uint256) public rewardsDistributed;
  50 |     |   // reward token => amount
  51 |     |   mapping(address => uint256) public rewardsDeposited;
  52 |     |   // all deposited rewards tokens
  53 |     |   address[] _allRewardsTokens;
  54 |     |   mapping(address => bool) _depositedRewardsToken;
  55 |     | 
  56 |     |     event Debug(string a);
  57 |     | 
  58 |     |   constructor(
  59 |     |     IProtocolFeeRouter _feeRouter,
  60 |     |     IRewardsWhitelister _rewardsWhitelist,
  61 |     |     IDexAdapter _dexHandler,
  62 |     |     IV3TwapUtilities _v3TwapUtilities,
  63 |     |     address _indexFund,
  64 |     |     address _pairedLpToken,
  65 |     |     address _trackingToken,
  66 |     |     address _rewardsToken
  67 |     |   ) {
  68 |     |     emit Debug("WTF");
  69 |     |     PROTOCOL_FEE_ROUTER = _feeRouter;
  70 |     |     REWARDS_WHITELISTER = _rewardsWhitelist;
  71 |     |     DEX_ADAPTER = _dexHandler;
  72 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  73 |     |     INDEX_FUND = _indexFund;
  74 |     |     PAIRED_LP_TOKEN = _pairedLpToken;
  75 |     |     trackingToken = _trackingToken;
  76 |     |     rewardsToken = _rewardsToken;
  77 |     |   }
  78 |     | 
  79 |     |   function setShares(
  80 |     |     address _wallet,
  81 |     |     uint256 _amount,
  82 |     |     bool _sharesRemoving
  83 |     |   ) external override {
  84 |     |     require(_msgSender() == trackingToken, 'UNAUTHORIZED');
  85 |     |     _setShares(_wallet, _amount, _sharesRemoving);
  86 |     |   }
  87 |     | 
  88 |     |   function _setShares(
  89 |     |     address _wallet,
  90 |     |     uint256 _amount,
  91 |     |     bool _sharesRemoving
  92 |     |   ) internal {
  93 |     |     _processFeesIfApplicable();
  94 |     |     if (_sharesRemoving) {
  95 |     |       _removeShares(_wallet, _amount);
  96 |     |       emit RemoveShares(_wallet, _amount);
  97 |     |     } else {
  98 |     |       _addShares(_wallet, _amount);
  99 |     |       emit AddShares(_wallet, _amount);
 100 |     |     }
 101 |     |   }
 102 |     | 
 103 |     |   function _addShares(address _wallet, uint256 _amount) internal {
 104 |     |     if (shares[_wallet] > 0) {
 105 |     |       _distributeReward(_wallet);
 106 |     |     }
 107 |     |     uint256 sharesBefore = shares[_wallet];
 108 |     |     totalShares += _amount;
 109 |     |     shares[_wallet] += _amount;
 110 |     |     if (sharesBefore == 0 && shares[_wallet] > 0) {
 111 |     |       totalStakers++;
 112 |     |     }
 113 |     |     _resetExcluded(_wallet);
 114 |     |   }
 115 |     | 
 116 |     |   function _removeShares(address _wallet, uint256 _amount) internal {
 117 |     |     require(shares[_wallet] > 0 && _amount <= shares[_wallet], 'RE');
 118 |     |     _distributeReward(_wallet);
 119 |     |     totalShares -= _amount;
 120 |     |     shares[_wallet] -= _amount;
 121 |     |     if (shares[_wallet] == 0) {
 122 |     |       totalStakers--;
 123 |     |     }
 124 |     |     _resetExcluded(_wallet);
 125 |     |   }
 126 |     | 
 127 |     |   function _processFeesIfApplicable() internal {
 128 |     |     IDecentralizedIndex(INDEX_FUND).processPreSwapFeesAndSwap();
 129 |     |   }
 130 |     | 
 131 |     |   function depositFromPairedLpToken(
 132 |     |     uint256 _amountTknDepositing
 133 |     |   ) public override {
 134 |     |     require(PAIRED_LP_TOKEN != rewardsToken, 'R');
 135 |     |     if (_amountTknDepositing > 0) {
 136 |     |       IERC20(PAIRED_LP_TOKEN).safeTransferFrom(
 137 |     |         _msgSender(),
 138 |     |         address(this),
 139 |     |         _amountTknDepositing
 140 |     |       );
 141 |     |     }
 142 |     |     uint256 _amountTkn = IERC20(PAIRED_LP_TOKEN).balanceOf(address(this));
 143 |     |     require(_amountTkn > 0, 'A');
 144 |     |     uint256 _adminAmt = _getAdminFeeFromAmount(_amountTkn);
 145 |     |     _amountTkn -= _adminAmt;
 146 |     |     (address _token0, address _token1) = PAIRED_LP_TOKEN < rewardsToken
 147 |     |       ? (PAIRED_LP_TOKEN, rewardsToken)
 148 |     |       : (rewardsToken, PAIRED_LP_TOKEN);
 149 |     |     address _pool;
 150 |     |     try DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_POOL_FEE) returns (
 151 |     |       address __pool
 152 |     |     ) {
 153 |     |       _pool = __pool;
 154 |     |     } catch {
 155 |     |       _pool = DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_TICK_SPACING);
 156 |     |     }
 157 |     |     uint160 _rewardsSqrtPriceX96 = V3_TWAP_UTILS
 158 |     |       .sqrtPriceX96FromPoolAndInterval(_pool);
 159 |     |     uint256 _rewardsPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(
 160 |     |       _rewardsSqrtPriceX96
 161 |     |     );
 162 |     |     uint256 _amountOut = _token0 == PAIRED_LP_TOKEN
 163 |     |       ? (_rewardsPriceX96 * _amountTkn) / FixedPoint96.Q96
 164 |     |       : (_amountTkn * FixedPoint96.Q96) / _rewardsPriceX96;
 165 |     |     _swapForRewards(_amountTkn, _amountOut, _adminAmt);
 166 |     |   }
 167 |     | 
 168 |     |   function depositRewards(address _token, uint256 _amount) external override {
 169 |     |     _depositRewardsFromToken(_msgSender(), _token, _amount, true);
 170 |     |   }
 171 |     | 
 172 |     |   function depositRewardsNoTransfer(
 173 |     |     address _token,
 174 |     |     uint256 _amount
 175 |     |   ) external override {
 176 |     |     require(_msgSender() == INDEX_FUND, 'AUTH');
 177 |     |     _depositRewardsFromToken(_msgSender(), _token, _amount, false);
 178 |     |   }
 179 |     | 
 180 |     |   function _depositRewardsFromToken(
 181 |     |     address _user,
 182 |     |     address _token,
 183 |     |     uint256 _amount,
 184 |     |     bool _shouldTransfer
 185 |     |   ) internal {
 186 |     |     require(_amount > 0, 'A');
 187 |     |     require(_isValidRewardsToken(_token), 'V');
 188 |     |     uint256 _finalAmt = _amount;
 189 |     |     if (_shouldTransfer) {
 190 |     |       uint256 _balBefore = IERC20(_token).balanceOf(address(this));
 191 |     |       IERC20(_token).safeTransferFrom(_user, address(this), _finalAmt);
 192 |     |       _finalAmt = IERC20(_token).balanceOf(address(this)) - _balBefore;
 193 |     |     }
 194 |     |     uint256 _adminAmt = _getAdminFeeFromAmount(_finalAmt);
 195 |     |     if (_adminAmt > 0) {
 196 |     |       IERC20(_token).safeTransfer(
 197 |     |         Ownable(address(V3_TWAP_UTILS)).owner(),
 198 |     |         _adminAmt
 199 |     |       );
 200 |     |       _finalAmt -= _adminAmt;
 201 |     |     }
 202 |     |     _depositRewards(_token, _finalAmt);
 203 |     |   }
 204 |     | 
 205 |     |   function _depositRewards(address _token, uint256 _amountTotal) internal {
 206 |     |     if (!_depositedRewardsToken[_token]) {
 207 |     |       _depositedRewardsToken[_token] = true;
 208 |     |       _allRewardsTokens.push(_token);
 209 |     |     }
 210 |     |     if (_amountTotal == 0) {
 211 |     |       return;
 212 |     |     }
 213 |     |     if (totalShares == 0) {
 214 |     |       require(_token == rewardsToken, 'R');
 215 |     |       _burnRewards(_amountTotal);
 216 |     |       return;
 217 |     |     }
 218 |     | 
 219 |     |     uint256 _depositAmount = _amountTotal;
 220 |     |     if (_token == rewardsToken) {
 221 |     |       (, uint256 _yieldBurnFee) = _getYieldFees();
 222 |     |       if (_yieldBurnFee > 0) {
 223 |     |         uint256 _burnAmount = (_amountTotal * _yieldBurnFee) /
 224 |     |           PROTOCOL_FEE_ROUTER.protocolFees().DEN();
 225 |     |         if (_burnAmount > 0) {
 226 |     |           _burnRewards(_burnAmount);
 227 |     |           _depositAmount -= _burnAmount;
 228 |     |         }
 229 |     |       }
 230 |     |     }
 231 |     |     rewardsDeposited[_token] += _depositAmount;
 232 |     |     _rewardsPerShare[_token] += (PRECISION * _depositAmount) / totalShares;
 233 |     |     emit DepositRewards(_msgSender(), _token, _depositAmount);
 234 |     |   }
 235 |     | 
 236 |     |   function _distributeReward(address _wallet) internal {
 237 |     |     if (shares[_wallet] == 0) {
 238 |     |       return;
 239 |     |     }
 240 |     |     for (uint256 _i; _i < _allRewardsTokens.length; _i++) {
 241 |     |       address _token = _allRewardsTokens[_i];
 242 |     |       uint256 _amount = getUnpaid(_token, _wallet);
 243 |     |       rewards[_token][_wallet].realized += _amount;
 244 |     |       rewards[_token][_wallet].excluded = _cumulativeRewards(
 245 |     |         _token,
 246 |     |         shares[_wallet]
 247 |     |       );
 248 |     |       if (_amount > 0) {
 249 |     |         rewardsDistributed[_token] += _amount;
 250 |     |         IERC20(_token).safeTransfer(_wallet, _amount);
 251 |     |         emit DistributeReward(_wallet, _token, _amount);
 252 |     |       }
 253 |     |     }
 254 |     |   }
 255 |     | 
 256 |     |   function _resetExcluded(address _wallet) internal {
 257 |     |     for (uint256 _i; _i < _allRewardsTokens.length; _i++) {
 258 |     |       address _token = _allRewardsTokens[_i];
 259 |     |       rewards[_token][_wallet].excluded = _cumulativeRewards(
 260 |     |         _token,
 261 |     |         shares[_wallet]
 262 |     |       );
 263 |     |     }
 264 |     |   }
 265 |     | 
 266 |     |   function _burnRewards(uint256 _burnAmount) internal {
 267 |     |     try IPEAS(rewardsToken).burn(_burnAmount) {} catch {
 268 |     |       IERC20(rewardsToken).safeTransfer(address(0xdead), _burnAmount);
 269 |     |     }
 270 |     |   }
 271 |     | 
 272 |     |   function _isValidRewardsToken(address _token) internal view returns (bool) {
 273 |     |     return _token == rewardsToken || REWARDS_WHITELISTER.whitelist(_token);
 274 |     |   }
 275 |     | 
 276 |     |   function _getAdminFeeFromAmount(
 277 |     |     uint256 _amount
 278 |     |   ) internal view returns (uint256) {
 279 |     |     (uint256 _yieldAdminFee, ) = _getYieldFees();
 280 |     |     if (_yieldAdminFee == 0) {
 281 |     |       return 0;
 282 |     |     }
 283 |     |     return
 284 |     |       (_amount * _yieldAdminFee) / PROTOCOL_FEE_ROUTER.protocolFees().DEN();
 285 |     |   }
 286 |     | 
 287 |     |   function _getYieldFees()
 288 |     |     internal
 289 |     |     view
 290 |     |     returns (uint256 _admin, uint256 _burn)
 291 |     |   {
 292 |     |     IProtocolFees _fees = PROTOCOL_FEE_ROUTER.protocolFees();
 293 |     |     if (address(_fees) != address(0)) {
 294 |     |       _admin = _fees.yieldAdmin();
 295 |     |       _burn = _fees.yieldBurn();
 296 |     |     }
 297 |     |   }
 298 |     | 
 299 |     |   function _swapForRewards(
 300 |     |     uint256 _amountIn,
 301 |     |     uint256 _amountOut,
 302 |     |     uint256 _adminAmt
 303 |     |   ) internal {
 304 |     |     _amountIn = _rewardsSwapAmountInOverride > 0
 305 |     |       ? _rewardsSwapAmountInOverride
 306 |     |       : _amountIn;
 307 |     |     uint256 _balBefore = IERC20(rewardsToken).balanceOf(address(this));
 308 |     |     IERC20(PAIRED_LP_TOKEN).safeIncreaseAllowance(
 309 |     |       address(DEX_ADAPTER),
 310 |     |       _amountIn
 311 |     |     );
 312 |     |     try
 313 |     |       DEX_ADAPTER.swapV3Single(
 314 |     |         PAIRED_LP_TOKEN,
 315 |     |         rewardsToken,
 316 |     |         REWARDS_POOL_FEE,
 317 |     |         _amountIn,
 318 |     |         (_amountOut * (1000 - REWARDS_SWAP_SLIPPAGE)) / 1000,
 319 |     |         address(this)
 320 |     |       )
 321 |     |     {
 322 |     |       _rewardsSwapAmountInOverride = 0;
 323 |     |       if (_adminAmt > 0) {
 324 |     |         IERC20(PAIRED_LP_TOKEN).safeTransfer(
 325 |     |           Ownable(address(V3_TWAP_UTILS)).owner(),
 326 |     |           _adminAmt
 327 |     |         );
 328 |     |       }
 329 |     |       _depositRewards(
 330 |     |         rewardsToken,
 331 |     |         IERC20(rewardsToken).balanceOf(address(this)) - _balBefore
 332 |     |       );
 333 |     |     } catch {
 334 |     |       _rewardsSwapAmountInOverride = _amountIn / 2;
 335 |     |       IERC20(PAIRED_LP_TOKEN).safeDecreaseAllowance(
 336 |     |         address(DEX_ADAPTER),
 337 |     |         _amountIn
 338 |     |       );
 339 |     |       emit RewardSwapError(_amountIn);
 340 |     |     }
 341 |     |   }
 342 |     | 
 343 |     |   function claimReward(address _wallet) external override {
 344 |     |     _distributeReward(_wallet);
 345 |     |     emit ClaimReward(_wallet);
 346 |     |   }
 347 |     | 
 348 |     |   function getUnpaid(
 349 |     |     address _token,
 350 |     |     address _wallet
 351 |     |   ) public view returns (uint256) {
 352 |     |     if (shares[_wallet] == 0) {
 353 |     |       return 0;
 354 |     |     }
 355 |     |     uint256 earnedRewards = _cumulativeRewards(_token, shares[_wallet]);
 356 |     |     uint256 rewardsExcluded = rewards[_token][_wallet].excluded;
 357 |     |     if (earnedRewards <= rewardsExcluded) {
 358 |     |       return 0;
 359 |     |     }
 360 |     |     return earnedRewards - rewardsExcluded;
 361 |     |   }
 362 |     | 
 363 |     |   function _cumulativeRewards(
 364 |     |     address _token,
 365 |     |     uint256 _share
 366 |     |   ) internal view returns (uint256) {
 367 |     |     return (_share * _rewardsPerShare[_token]) / PRECISION;
 368 |     |   }
 369 |     | }
 370 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/WeightedIndex.sol
   1 |     | // https://peapods.finance
   2 |     | 
   3 |     | // SPDX-License-Identifier: MIT
   4 |     | pragma solidity ^0.8.19;
   5 |     | 
   6 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   7 |     | import './interfaces/IUniswapV2Pair.sol';
   8 |     | import './interfaces/IV3TwapUtilities.sol';
   9 |     | import './DecentralizedIndex.sol';
  10 |     | 
  11 | *   | contract WeightedIndex is DecentralizedIndex {
  12 |     |   using SafeERC20 for IERC20;
  13 |     | 
  14 |     |   uint256 _totalWeights;
  15 |     | 
  16 |     |   constructor(
  17 |     |     string memory _name,
  18 |     |     string memory _symbol,
  19 |     |     Config memory _config,
  20 |     |     Fees memory _fees,
  21 |     |     address[] memory _tokens,
  22 |     |     uint256[] memory _weights,
  23 |     |     address _pairedLpToken,
  24 |     |     address _lpRewardsToken,
  25 |     |     address _dexHandler,
  26 |     |     bool _stakeRestriction
  27 |     |   )
  28 |     |     DecentralizedIndex(
  29 |     |       _name,
  30 |     |       _symbol,
  31 |     |       IndexType.WEIGHTED,
  32 |     |       _config,
  33 |     |       _fees,
  34 |     |       _pairedLpToken,
  35 |     |       _lpRewardsToken,
  36 |     |       _dexHandler,
  37 |     |       _stakeRestriction
  38 |     |     )
  39 |     |   {
  40 |     |     require(_tokens.length == _weights.length, 'V');
  41 |     |     uint256 _tl = _tokens.length;
  42 |     |     for (uint8 _i; _i < _tl; _i++) {
  43 |     |       require(!_isTokenInIndex[_tokens[_i]], 'D');
  44 |     |       require(_weights[_i] > 0, 'W');
  45 |     |       indexTokens.push(
  46 |     |         IndexAssetInfo({
  47 |     |           token: _tokens[_i],
  48 |     |           basePriceUSDX96: 0,
  49 |     |           weighting: _weights[_i],
  50 |     |           c1: address(0),
  51 |     |           q1: 0 // amountsPerIdxTokenX96
  52 |     |         })
  53 |     |       );
  54 |     |       _totalWeights += _weights[_i];
  55 |     |       _fundTokenIdx[_tokens[_i]] = _i;
  56 |     |       _isTokenInIndex[_tokens[_i]] = true;
  57 |     | 
  58 |     |       if (_config.blacklistTKNpTKNPoolV2 && _tokens[_i] != _pairedLpToken) {
  59 |     |         address _blkPool = IDexAdapter(_dexHandler).createV2Pool(
  60 |     |           address(this),
  61 |     |           _tokens[_i]
  62 |     |         );
  63 |     |         _blacklist[_blkPool] = true;
  64 |     |       }
  65 |     |     }
  66 |     |     // at idx == 0, need to find X in [1/X = tokenWeightAtIdx/totalWeights]
  67 |     |     // at idx > 0, need to find Y in (Y/X = tokenWeightAtIdx/totalWeights)
  68 |     |     uint256 _xX96 = (FixedPoint96.Q96 * _totalWeights) / _weights[0];
  69 |     |     for (uint256 _i; _i < _tl; _i++) {
  70 |     |       indexTokens[_i].q1 =
  71 |     |         (_weights[_i] * _xX96 * 10 ** IERC20Metadata(_tokens[_i]).decimals()) /
  72 |     |         _totalWeights;
  73 |     |     }
  74 |     |   }
  75 |     | 
  76 |     |   /// @notice The ```_getNativePriceUSDX96``` function gets an *unsafe* native tkn (ETH) price from a UniswapV2 pool
  77 |     |   /// @return _priceX96 USD/native price scaled by Q96
  78 |     |   function _getNativePriceUSDX96() internal view returns (uint256) {
  79 |     |     IUniswapV2Pair _nativeStablePool = IUniswapV2Pair(
  80 |     |       DEX_HANDLER.getV2Pool(DAI, WETH)
  81 |     |     );
  82 |     |     address _token0 = _nativeStablePool.token0();
  83 |     |     (uint8 _decimals0, uint8 _decimals1) = (
  84 |     |       IERC20Metadata(_token0).decimals(),
  85 |     |       IERC20Metadata(_nativeStablePool.token1()).decimals()
  86 |     |     );
  87 |     |     (uint112 _res0, uint112 _res1, ) = _nativeStablePool.getReserves();
  88 |     |     return
  89 |     |       _token0 == DAI
  90 |     |         ? (FixedPoint96.Q96 * _res0 * 10 ** _decimals1) /
  91 |     |           _res1 /
  92 |     |           10 ** _decimals0
  93 |     |         : (FixedPoint96.Q96 * _res1 * 10 ** _decimals0) /
  94 |     |           _res0 /
  95 |     |           10 ** _decimals1;
  96 |     |   }
  97 |     | 
  98 |     |   /// @notice The ```_getTokenPriceUSDX96``` function gets an *unsafe* tkn price from a UniswapV2 pool
  99 |     |   /// @param _token token we're getting the price for
 100 |     |   /// @return _priceX96 USD/TKN price scaled by Q96
 101 |     |   function _getTokenPriceUSDX96(
 102 |     |     address _token
 103 |     |   ) internal view returns (uint256) {
 104 |     |     if (_token == WETH) {
 105 |     |       return _getNativePriceUSDX96();
 106 |     |     }
 107 |     |     IUniswapV2Pair _pool = IUniswapV2Pair(DEX_HANDLER.getV2Pool(_token, WETH));
 108 |     |     address _token0 = _pool.token0();
 109 |     |     uint8 _decimals0 = IERC20Metadata(_token0).decimals();
 110 |     |     uint8 _decimals1 = IERC20Metadata(_pool.token1()).decimals();
 111 |     |     (uint112 _res0, uint112 _res1, ) = _pool.getReserves();
 112 |     |     uint256 _nativePriceUSDX96 = _getNativePriceUSDX96();
 113 |     |     return
 114 |     |       _token0 == WETH
 115 |     |         ? (_nativePriceUSDX96 * _res0 * 10 ** _decimals1) /
 116 |     |           _res1 /
 117 |     |           10 ** _decimals0
 118 |     |         : (_nativePriceUSDX96 * _res1 * 10 ** _decimals0) /
 119 |     |           _res0 /
 120 |     |           10 ** _decimals1;
 121 |     |   }
 122 |     | 
 123 |     |   /// @notice The ```bond``` function wraps a user into a pod and mints new pTKN
 124 |     |   /// @param _token The token used to calculate the amount of pTKN minted
 125 |     |   /// @param _amount Number of _tokens used to wrap into the pod
 126 |     |   /// @param _amountMintMin Number of pTKN minimum that should be minted (slippage)
 127 | *   |   function bond(
 128 |     |     address _token,
 129 |     |     uint256 _amount,
 130 |     |     uint256 _amountMintMin
 131 |     |   ) external override lock noSwapOrFee {
 132 | *   |     require(_isTokenInIndex[_token], 'IT');
 133 | *   |     uint256 _tokenIdx = _fundTokenIdx[_token];
 134 | *   |     uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(this));
 135 | *   |     bool _firstIn = _isFirstIn();
 136 | *   |     uint256 _tokenAmtSupplyRatioX96 = _firstIn
 137 |     |       ? FixedPoint96.Q96
 138 | *   |       : (_amount * FixedPoint96.Q96) / _tokenCurSupply;
 139 | *   |     uint256 _tokensMinted;
 140 | *   |     if (_firstIn) {
 141 |     |       _tokensMinted =
 142 |     |         (_amount * FixedPoint96.Q96 * 10 ** decimals()) /
 143 |     |         indexTokens[_tokenIdx].q1;
 144 |     |     } else {
 145 | *   |       _tokensMinted =
 146 | *   |         (totalSupply() * _tokenAmtSupplyRatioX96) /
 147 |     |         FixedPoint96.Q96;
 148 |     |     }
 149 | *   |     uint256 _feeTokens = _canWrapFeeFree(_msgSender())
 150 |     |       ? 0
 151 | *   |       : (_tokensMinted * fees.bond) / DEN;
 152 | *   |     require(_tokensMinted - _feeTokens >= _amountMintMin, 'M');
 153 | *   |     _mint(_msgSender(), _tokensMinted - _feeTokens);
 154 | *   |     if (_feeTokens > 0) {
 155 | *   |       _mint(address(this), _feeTokens);
 156 | *   |       _processBurnFee(_feeTokens);
 157 |     |     }
 158 | *   |     uint256 _il = indexTokens.length;
 159 | *   |     for (uint256 _i; _i < _il; _i++) {
 160 | *   |       uint256 _transferAmt = _firstIn
 161 | *   |         ? getInitialAmount(_token, _amount, indexTokens[_i].token)
 162 | *   |         : (IERC20(indexTokens[_i].token).balanceOf(address(this)) *
 163 | *   |           _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;
 164 | *   |       _transferFromAndValidate(
 165 | *   |         IERC20(indexTokens[_i].token),
 166 |     |         _msgSender(),
 167 | *   |         _transferAmt
 168 |     |       );
 169 |     |     }
 170 | *   |     _bond();
 171 | *   |     emit Bond(_msgSender(), _token, _amount, _tokensMinted);
 172 |     |   }
 173 |     | 
 174 |     |   /// @notice The ```debond``` function unwraps a user out of a pod and burns pTKN
 175 |     |   /// @param _amount Number of pTKN to burn
 176 |     |   function debond(
 177 |     |     uint256 _amount,
 178 |     |     address[] memory,
 179 |     |     uint8[] memory
 180 |     |   ) external override lock noSwapOrFee {
 181 |     |     uint256 _amountAfterFee = _isLastOut(_amount)
 182 |     |       ? _amount
 183 |     |       : (_amount * (DEN - fees.debond)) / DEN;
 184 |     |     uint256 _percAfterFeeX96 = (_amountAfterFee * FixedPoint96.Q96) /
 185 |     |       totalSupply();
 186 |     |     super._transfer(_msgSender(), address(this), _amount);
 187 |     |     _burn(address(this), _amountAfterFee);
 188 |     |     _processBurnFee(_amount - _amountAfterFee);
 189 |     |     uint256 _il = indexTokens.length;
 190 |     |     for (uint256 _i; _i < _il; _i++) {
 191 |     |       uint256 _tokenSupply = IERC20(indexTokens[_i].token).balanceOf(
 192 |     |         address(this)
 193 |     |       );
 194 |     |       uint256 _debondAmount = (_tokenSupply * _percAfterFeeX96) /
 195 |     |         FixedPoint96.Q96;
 196 |     |       if (_debondAmount > 0) {
 197 |     |         IERC20(indexTokens[_i].token).safeTransfer(_msgSender(), _debondAmount);
 198 |     |       }
 199 |     |     }
 200 |     |     // an arbitrage path of buy pTKN > debond > sell TKN does not trigger rewards
 201 |     |     // so let's trigger processing here at debond to keep things moving along
 202 |     |     _processPreSwapFeesAndSwap();
 203 |     |     emit Debond(_msgSender(), _amount);
 204 |     |   }
 205 |     | 
 206 |     |   /// @notice The ```getInitialAmount``` function determines the initial amount of TKN2 needed
 207 |     |   /// @notice based on an amount of TKN1 to wrap with. After an initial bond, vault share takes over
 208 |     |   /// @param _sourceToken TKN we're referencing
 209 |     |   /// @param _sourceAmount Amount of TKN we're referencing
 210 |     |   /// @param _targetToken Target TKN we will return the amount that is needed
 211 |     |   /// @return _amtTargetTkn Amount of _targetToken needed to wrap with
 212 | *   |   function getInitialAmount(
 213 |     |     address _sourceToken,
 214 |     |     uint256 _sourceAmount,
 215 |     |     address _targetToken
 216 | *   |   ) public view override returns (uint256) {
 217 | *   |     uint256 _sourceTokenIdx = _fundTokenIdx[_sourceToken];
 218 | *   |     uint256 _targetTokenIdx = _fundTokenIdx[_targetToken];
 219 | *   |     return
 220 | *   |       (_sourceAmount *
 221 | *   |         indexTokens[_targetTokenIdx].weighting *
 222 | *   |         10 ** IERC20Metadata(_targetToken).decimals()) /
 223 | *   |       indexTokens[_sourceTokenIdx].weighting /
 224 | *   |       10 ** IERC20Metadata(_sourceToken).decimals();
 225 |     |   }
 226 |     | 
 227 |     |   /// @notice The ```getTokenPriceUSDX96``` function is an external version of _getTokenPriceUSDX96, which gets an *unsafe* tkn price from a UniswapV2 pool
 228 |     |   /// @notice This is used as a frontend helper but is NOT safe to be used as an oracle.
 229 |     |   /// @param _token token we're getting the price for
 230 |     |   /// @return _priceX96 USD/TKN price scaled by Q96
 231 |     |   function getTokenPriceUSDX96(
 232 |     |     address _token
 233 |     |   ) external view override returns (uint256) {
 234 |     |     return _getTokenPriceUSDX96(_token);
 235 |     |   }
 236 |     | 
 237 |     |   /// @notice The ```getIdxPriceUSDX96``` function gets an *unsafe* pTKN price from all TKNs using UniswapV2 pools
 238 |     |   /// @notice This is used as a frontend helper but is NOT safe to be used as an oracle.
 239 |     |   /// @return _priceX96 USD/TKN price scaled by Q96
 240 |     |   function getIdxPriceUSDX96()
 241 |     |     external
 242 |     |     view
 243 |     |     override
 244 |     |     returns (uint256, uint256)
 245 |     |   {
 246 |     |     uint256 _priceX96;
 247 |     |     uint256 _X96_2 = 2 ** (96 / 2);
 248 |     |     uint256 _il = indexTokens.length;
 249 |     |     for (uint256 _i; _i < _il; _i++) {
 250 |     |       uint256 _tokenPriceUSDX96_2 = _getTokenPriceUSDX96(
 251 |     |         indexTokens[_i].token
 252 |     |       ) / _X96_2;
 253 |     |       _priceX96 +=
 254 |     |         (_tokenPriceUSDX96_2 * indexTokens[_i].q1) /
 255 |     |         10 ** IERC20Metadata(indexTokens[_i].token).decimals() /
 256 |     |         _X96_2;
 257 |     |     }
 258 |     |     return (0, _priceX96);
 259 |     |   }
 260 |     | }
 261 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/Zapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   8 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   9 |     | import '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';
  10 |     | import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
  11 |     | import './interfaces/ICurvePool.sol';
  12 |     | import './interfaces/IDecentralizedIndex.sol';
  13 |     | import './interfaces/IDexAdapter.sol';
  14 |     | import './interfaces/IUniswapV2Pair.sol';
  15 |     | import './interfaces/IUniswapV3Pool.sol';
  16 |     | import './interfaces/IV3TwapUtilities.sol';
  17 |     | import './interfaces/IWETH.sol';
  18 |     | import './interfaces/IZapper.sol';
  19 |     | 
  20 |     | contract Zapper is IZapper, Context, Ownable {
  21 |     |   using SafeERC20 for IERC20;
  22 |     | 
  23 |     |   address constant STYETH = 0x583019fF0f430721aDa9cfb4fac8F06cA104d0B4;
  24 |     |   address constant YETH = 0x1BED97CBC3c24A4fb5C069C6E311a967386131f7;
  25 |     |   address constant WETH_YETH_POOL = 0x69ACcb968B19a53790f43e57558F5E443A91aF22;
  26 |     |   address constant V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;
  27 |     |   address immutable V2_ROUTER;
  28 |     |   address immutable WETH;
  29 |     |   IV3TwapUtilities immutable V3_TWAP_UTILS;
  30 |     |   IDexAdapter immutable DEX_ADAPTER;
  31 |     | 
  32 |     |   uint256 _slippage = 30; // 3%
  33 |     | 
  34 |     |   address public OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;
  35 |     |   address public pOHM;
  36 |     | 
  37 |     |   // token in => token out => swap pool(s)
  38 |     |   mapping(address => mapping(address => Pools)) public zapMap;
  39 |     |   // curve pool => token => idx
  40 |     |   mapping(address => mapping(address => int128)) public curveTokenIdx;
  41 |     | 
  42 |     |   event Message(string a);
  43 |     | 
  44 |     |   constructor(IV3TwapUtilities _v3TwapUtilities, IDexAdapter _dexAdapter) {
  45 |     |     V2_ROUTER = _dexAdapter.V2_ROUTER();
  46 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  47 |     |     DEX_ADAPTER = _dexAdapter;
  48 |     |     WETH = _dexAdapter.WETH();
  49 |     | 
  50 |     |     emit Message("Here");
  51 |     | 
  52 |     |     if (block.chainid == 1) {
  53 |     |       // WETH/YETH
  54 |     |       _setZapMapFromPoolSingle(
  55 |     |         PoolType.CURVE,
  56 |     |         0x69ACcb968B19a53790f43e57558F5E443A91aF22
  57 |     |       );
  58 |     |       // WETH/DAI
  59 |     |       _setZapMapFromPoolSingle(
  60 |     |         PoolType.V3,
  61 |     |         0x60594a405d53811d3BC4766596EFD80fd545A270
  62 |     |       );
  63 |     |       // WETH/USDC
  64 |     |       _setZapMapFromPoolSingle(
  65 |     |         PoolType.V3,
  66 |     |         0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640
  67 |     |       );
  68 |     |       // WETH/OHM
  69 |     |       _setZapMapFromPoolSingle(
  70 |     |         PoolType.V3,
  71 |     |         0x88051B0eea095007D3bEf21aB287Be961f3d8598
  72 |     |       );
  73 |     |       // USDC/OHM
  74 |     |       _setZapMapFromPoolSingle(
  75 |     |         PoolType.V3,
  76 |     |         0x893f503FaC2Ee1e5B78665db23F9c94017Aae97D
  77 |     |       );
  78 |     |     }
  79 |     |   }
  80 |     | 
  81 |     |   function _zap(
  82 |     |     address _in,
  83 |     |     address _out,
  84 |     |     uint256 _amountIn,
  85 |     |     uint256 _amountOutMin
  86 |     |   ) internal returns (uint256 _amountOut) {
  87 |     |     if (_in == address(0)) {
  88 |     |       _amountIn = _ethToWETH(_amountIn);
  89 |     |       _in = WETH;
  90 |     |       if (_out == WETH) {
  91 |     |         return _amountIn;
  92 |     |       }
  93 |     |     }
  94 |     |     // handle pOHM separately through pod, modularize later
  95 |     |     bool _isOutPOHM;
  96 |     |     if (pOHM == _out) {
  97 |     |       _isOutPOHM = true;
  98 |     |       _out = OHM;
  99 |     |     }
 100 |     |     // handle yETH and st-yETH special through curve pool, modularize later
 101 |     |     if (_out == YETH || _out == STYETH) {
 102 |     |       require(_in == WETH, 'YETHIN');
 103 |     |       return _wethToYeth(_amountIn, _amountOutMin, _out == STYETH);
 104 |     |     } else if (_in == YETH || _in == STYETH) {
 105 |     |       require(_out == WETH, 'YETHOUT');
 106 |     |       return _styethToWeth(_amountIn, _amountOutMin, _in == YETH);
 107 |     |     }
 108 |     |     Pools memory _poolInfo = zapMap[_in][_out];
 109 |     |     // no pool so just try to swap over one path univ2
 110 |     |     if (_poolInfo.pool1 == address(0)) {
 111 |     |       address[] memory _path = new address[](2);
 112 |     |       _path[0] = _in;
 113 |     |       _path[1] = _out;
 114 |     |       _amountOut = _swapV2(_path, _amountIn, _amountOutMin);
 115 |     |     } else {
 116 |     |       bool _twoHops = _poolInfo.pool2 != address(0);
 117 |     |       if (_poolInfo.poolType == PoolType.CURVE) {
 118 |     |         // curve
 119 |     |         _amountOut = _swapCurve(
 120 |     |           _poolInfo.pool1,
 121 |     |           curveTokenIdx[_poolInfo.pool1][_in],
 122 |     |           curveTokenIdx[_poolInfo.pool1][_out],
 123 |     |           _amountIn,
 124 |     |           _amountOutMin
 125 |     |         );
 126 |     |       } else if (_poolInfo.poolType == PoolType.V2) {
 127 |     |         // univ2
 128 |     |         address _token0 = IUniswapV2Pair(_poolInfo.pool1).token0();
 129 |     |         address[] memory _path = new address[](_twoHops ? 3 : 2);
 130 |     |         _path[0] = _in;
 131 |     |         _path[1] = !_twoHops ? _out : _token0 == _in
 132 |     |           ? IUniswapV2Pair(_poolInfo.pool1).token1()
 133 |     |           : _token0;
 134 |     |         if (_twoHops) {
 135 |     |           _path[2] = _out;
 136 |     |         }
 137 |     |         _amountOut = _swapV2(_path, _amountIn, _amountOutMin);
 138 |     |       } else {
 139 |     |         // univ3
 140 |     |         if (_twoHops) {
 141 |     |           address _t0 = IUniswapV3Pool(_poolInfo.pool1).token0();
 142 |     |           _amountOut = _swapV3Multi(
 143 |     |             _in,
 144 |     |             _getPoolFee(_poolInfo.pool1),
 145 |     |             _t0 == _in ? IUniswapV3Pool(_poolInfo.pool1).token1() : _t0,
 146 |     |             _getPoolFee(_poolInfo.pool2),
 147 |     |             _out,
 148 |     |             _amountIn,
 149 |     |             _amountOutMin
 150 |     |           );
 151 |     |         } else {
 152 |     |           _amountOut = _swapV3Single(
 153 |     |             _in,
 154 |     |             _getPoolFee(_poolInfo.pool1),
 155 |     |             _out,
 156 |     |             _amountIn,
 157 |     |             _amountOutMin
 158 |     |           );
 159 |     |         }
 160 |     |       }
 161 |     |     }
 162 |     |     if (!_isOutPOHM) {
 163 |     |       return _amountOut;
 164 |     |     }
 165 |     |     uint256 _pOHMBefore = IERC20(pOHM).balanceOf(address(this));
 166 |     |     IERC20(OHM).safeIncreaseAllowance(pOHM, _amountOut);
 167 |     |     IDecentralizedIndex(pOHM).bond(OHM, _amountOut, 0);
 168 |     |     return IERC20(pOHM).balanceOf(address(this)) - _pOHMBefore;
 169 |     |   }
 170 |     | 
 171 |     |   function _getPoolFee(address _pool) internal view returns (uint24) {
 172 |     |     return block.chainid == 42161 ? 0 : IUniswapV3Pool(_pool).fee();
 173 |     |   }
 174 |     | 
 175 |     |   function _ethToWETH(uint256 _amountETH) internal returns (uint256) {
 176 |     |     uint256 _wethBal = IERC20(WETH).balanceOf(address(this));
 177 |     |     IWETH(WETH).deposit{ value: _amountETH }();
 178 |     |     return IERC20(WETH).balanceOf(address(this)) - _wethBal;
 179 |     |   }
 180 |     | 
 181 |     |   function _swapV3Single(
 182 |     |     address _in,
 183 |     |     uint24 _fee,
 184 |     |     address _out,
 185 |     |     uint256 _amountIn,
 186 |     |     uint256 _amountOutMin
 187 |     |   ) internal returns (uint256) {
 188 |     |     if (_amountOutMin == 0) {
 189 |     |       address _v3Pool;
 190 |     |       try DEX_ADAPTER.getV3Pool(_in, _out, uint24(10000)) returns (
 191 |     |         address __v3Pool
 192 |     |       ) {
 193 |     |         _v3Pool = __v3Pool;
 194 |     |       } catch {
 195 |     |         _v3Pool = DEX_ADAPTER.getV3Pool(_in, _out, int24(200));
 196 |     |       }
 197 |     |       address _token0 = _in < _out ? _in : _out;
 198 |     |       uint256 _poolPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(
 199 |     |         V3_TWAP_UTILS.sqrtPriceX96FromPoolAndInterval(_v3Pool)
 200 |     |       );
 201 |     |       _amountOutMin = _in == _token0
 202 |     |         ? (_poolPriceX96 * _amountIn) / FixedPoint96.Q96
 203 |     |         : (_amountIn * FixedPoint96.Q96) / _poolPriceX96;
 204 |     |     }
 205 |     | 
 206 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 207 |     |     IERC20(_in).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);
 208 |     |     DEX_ADAPTER.swapV3Single(
 209 |     |       _in,
 210 |     |       _out,
 211 |     |       _fee,
 212 |     |       _amountIn,
 213 |     |       (_amountOutMin * (1000 - _slippage)) / 1000,
 214 |     |       address(this)
 215 |     |     );
 216 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 217 |     |   }
 218 |     | 
 219 |     |   function _swapV3Multi(
 220 |     |     address _in,
 221 |     |     uint24 _fee1,
 222 |     |     address _in2,
 223 |     |     uint24 _fee2,
 224 |     |     address _out,
 225 |     |     uint256 _amountIn,
 226 |     |     uint256 _amountOutMin
 227 |     |   ) internal returns (uint256) {
 228 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 229 |     |     IERC20(_in).safeIncreaseAllowance(V3_ROUTER, _amountIn);
 230 |     |     bytes memory _path = abi.encodePacked(_in, _fee1, _in2, _fee2, _out);
 231 |     |     ISwapRouter(V3_ROUTER).exactInput(
 232 |     |       ISwapRouter.ExactInputParams({
 233 |     |         path: _path,
 234 |     |         recipient: address(this),
 235 |     |         deadline: block.timestamp,
 236 |     |         amountIn: _amountIn,
 237 |     |         amountOutMinimum: _amountOutMin
 238 |     |       })
 239 |     |     );
 240 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 241 |     |   }
 242 |     | 
 243 |     |   function _swapV2(
 244 |     |     address[] memory _path,
 245 |     |     uint256 _amountIn,
 246 |     |     uint256 _amountOutMin
 247 |     |   ) internal returns (uint256) {
 248 |     |     address _out = _path.length == 3 ? _path[2] : _path[1];
 249 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 250 |     |     IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);
 251 |     |     DEX_ADAPTER.swapV2Single(
 252 |     |       _path[0],
 253 |     |       _path[1],
 254 |     |       _amountIn,
 255 |     |       _amountOutMin,
 256 |     |       address(this)
 257 |     |     );
 258 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 259 |     |   }
 260 |     | 
 261 |     |   function _swapCurve(
 262 |     |     address _pool,
 263 |     |     int128 _i,
 264 |     |     int128 _j,
 265 |     |     uint256 _amountIn,
 266 |     |     uint256 _amountOutMin
 267 |     |   ) internal returns (uint256) {
 268 |     |     IERC20(ICurvePool(_pool).coins(uint128(_i))).safeIncreaseAllowance(
 269 |     |       _pool,
 270 |     |       _amountIn
 271 |     |     );
 272 |     |     return
 273 |     |       ICurvePool(_pool).exchange(
 274 |     |         _i,
 275 |     |         _j,
 276 |     |         _amountIn,
 277 |     |         _amountOutMin,
 278 |     |         address(this)
 279 |     |       );
 280 |     |   }
 281 |     | 
 282 |     |   function _wethToYeth(
 283 |     |     uint256 _ethAmount,
 284 |     |     uint256 _minYethAmount,
 285 |     |     bool _stakeToStyeth
 286 |     |   ) internal returns (uint256) {
 287 |     |     uint256 _boughtYeth = _swapCurve(
 288 |     |       WETH_YETH_POOL,
 289 |     |       0,
 290 |     |       1,
 291 |     |       _ethAmount,
 292 |     |       _minYethAmount
 293 |     |     );
 294 |     |     if (_stakeToStyeth) {
 295 |     |       IERC20(YETH).safeIncreaseAllowance(STYETH, _boughtYeth);
 296 |     |       return IERC4626(STYETH).deposit(_boughtYeth, address(this));
 297 |     |     }
 298 |     |     return _boughtYeth;
 299 |     |   }
 300 |     | 
 301 |     |   function _styethToWeth(
 302 |     |     uint256 _stYethAmount,
 303 |     |     uint256 _minWethAmount,
 304 |     |     bool _isYethOnly
 305 |     |   ) internal returns (uint256) {
 306 |     |     uint256 _yethAmount;
 307 |     |     if (_isYethOnly) {
 308 |     |       _yethAmount = _stYethAmount;
 309 |     |     } else {
 310 |     |       _yethAmount = IERC4626(STYETH).redeem(
 311 |     |         _stYethAmount,
 312 |     |         address(this),
 313 |     |         address(this)
 314 |     |       );
 315 |     |     }
 316 |     |     return _swapCurve(WETH_YETH_POOL, 1, 0, _yethAmount, _minWethAmount);
 317 |     |   }
 318 |     | 
 319 |     |   function _setZapMapFromPoolSingle(PoolType _type, address _pool) internal {
 320 |     |     address _t0;
 321 |     |     address _t1;
 322 |     |     if (_type == PoolType.CURVE) {
 323 |     |       _t0 = ICurvePool(_pool).coins(0);
 324 |     |       _t1 = ICurvePool(_pool).coins(1);
 325 |     |       curveTokenIdx[_pool][_t0] = 0;
 326 |     |       curveTokenIdx[_pool][_t1] = 1;
 327 |     |     } else {
 328 |     |       _t0 = IUniswapV3Pool(_pool).token0();
 329 |     |       _t1 = IUniswapV3Pool(_pool).token1();
 330 |     |     }
 331 |     |     Pools memory _poolConf = Pools({
 332 |     |       poolType: _type,
 333 |     |       pool1: _pool,
 334 |     |       pool2: address(0)
 335 |     |     });
 336 |     |     zapMap[_t0][_t1] = _poolConf;
 337 |     |     zapMap[_t1][_t0] = _poolConf;
 338 |     |   }
 339 |     | 
 340 |     |   function setOHM(address _OHM, address _pOHM) external onlyOwner {
 341 |     |     OHM = _OHM == address(0) ? OHM : _OHM;
 342 |     |     pOHM = _pOHM == address(0) ? pOHM : _pOHM;
 343 |     |   }
 344 |     | 
 345 |     |   function setSlippage(uint256 _slip) external onlyOwner {
 346 |     |     require(_slip >= 0 && _slip <= 1000, 'BOUNDS');
 347 |     |     _slippage = _slip;
 348 |     |   }
 349 |     | 
 350 |     |   function setZapMap(
 351 |     |     address _in,
 352 |     |     address _out,
 353 |     |     Pools memory _pools
 354 |     |   ) external onlyOwner {
 355 |     |     zapMap[_in][_out] = _pools;
 356 |     |   }
 357 |     | 
 358 |     |   function setZapMapFromPoolSingle(
 359 |     |     PoolType _type,
 360 |     |     address _pool
 361 |     |   ) external onlyOwner {
 362 |     |     _setZapMapFromPoolSingle(_type, _pool);
 363 |     |   }
 364 |     | 
 365 |     |   function rescueETH() external onlyOwner {
 366 |     |     (bool _sent, ) = payable(owner()).call{ value: address(this).balance }('');
 367 |     |     require(_sent);
 368 |     |   }
 369 |     | 
 370 |     |   function rescueERC20(IERC20 _token) external onlyOwner {
 371 |     |     require(_token.balanceOf(address(this)) > 0);
 372 |     |     _token.safeTransfer(owner(), _token.balanceOf(address(this)));
 373 |     |   }
 374 |     | 
 375 |     |   receive() external payable {}
 376 |     | }
 377 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/dex/UniswapDexAdapter.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/utils/Context.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   7 |     | import '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';
   8 |     | import '../interfaces/IDexAdapter.sol';
   9 |     | import '../interfaces/ISwapRouter02.sol';
  10 |     | import '../interfaces/IUniswapV2Factory.sol';
  11 |     | import '../interfaces/IUniswapV2Router02.sol';
  12 |     | import '../interfaces/IV3TwapUtilities.sol';
  13 |     | 
  14 |     | contract UniswapDexAdapter is IDexAdapter, Context {
  15 |     |   using SafeERC20 for IERC20;
  16 |     | 
  17 |     |   IV3TwapUtilities public immutable V3_TWAP_UTILS;
  18 |     |   address public immutable override V2_ROUTER;
  19 |     |   address public immutable override V3_ROUTER;
  20 |     |   bool public immutable override ASYNC_INITIALIZE;
  21 |     | 
  22 |     |   constructor(
  23 |     |     IV3TwapUtilities _v3TwapUtilities,
  24 |     |     address _v2Router,
  25 |     |     address _v3Router,
  26 |     |     bool _asyncInit
  27 |     |   ) {
  28 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  29 |     |     V2_ROUTER = _v2Router;
  30 |     |     V3_ROUTER = _v3Router;
  31 |     |     ASYNC_INITIALIZE = _asyncInit;
  32 |     |   }
  33 |     | 
  34 |     |   function WETH() external view virtual override returns (address) {
  35 |     |     return IUniswapV2Router02(V2_ROUTER).WETH();
  36 |     |   }
  37 |     | 
  38 |     |   function getV3Pool(
  39 |     |     address,
  40 |     |     address,
  41 |     |     int24
  42 |     |   ) external view virtual override returns (address _p) {
  43 |     |     _p;
  44 |     |     require(false, 'I0');
  45 |     |   }
  46 |     | 
  47 |     |   function getV3Pool(
  48 |     |     address _token0,
  49 |     |     address _token1,
  50 |     |     uint24 _poolFee
  51 |     |   ) external view virtual override returns (address) {
  52 |     |     return
  53 |     |       V3_TWAP_UTILS.getV3Pool(
  54 |     |         IPeripheryImmutableState(V3_ROUTER).factory(),
  55 |     |         _token0,
  56 |     |         _token1,
  57 |     |         _poolFee
  58 |     |       );
  59 |     |   }
  60 |     | 
  61 |     |   function getV2Pool(
  62 |     |     address _token0,
  63 |     |     address _token1
  64 |     |   ) external view virtual override returns (address) {
  65 |     |     return
  66 |     |       IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory()).getPair(
  67 |     |         _token0,
  68 |     |         _token1
  69 |     |       );
  70 |     |   }
  71 |     | 
  72 |     |   function createV2Pool(
  73 |     |     address _token0,
  74 |     |     address _token1
  75 |     |   ) external virtual override returns (address) {
  76 |     |     return
  77 |     |       IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory()).createPair(
  78 |     |         _token0,
  79 |     |         _token1
  80 |     |       );
  81 |     |   }
  82 |     | 
  83 |     |   function swapV2Single(
  84 |     |     address _tokenIn,
  85 |     |     address _tokenOut,
  86 |     |     uint256 _amountIn,
  87 |     |     uint256 _amountOutMin,
  88 |     |     address _recipient
  89 |     |   ) external virtual override returns (uint256 _amountOut) {
  90 |     |     uint256 _outBefore = IERC20(_tokenOut).balanceOf(_recipient);
  91 |     |     if (_amountIn == 0) {
  92 |     |       _amountIn = IERC20(_tokenIn).balanceOf(address(this));
  93 |     |     } else {
  94 |     |       IERC20(_tokenIn).safeTransferFrom(_msgSender(), address(this), _amountIn);
  95 |     |     }
  96 |     |     address[] memory _path = new address[](2);
  97 |     |     _path[0] = _tokenIn;
  98 |     |     _path[1] = _tokenOut;
  99 |     |     IERC20(_tokenIn).safeIncreaseAllowance(V2_ROUTER, _amountIn);
 100 |     |     IUniswapV2Router02(V2_ROUTER)
 101 |     |       .swapExactTokensForTokensSupportingFeeOnTransferTokens(
 102 |     |         _amountIn,
 103 |     |         _amountOutMin,
 104 |     |         _path,
 105 |     |         _recipient,
 106 |     |         block.timestamp
 107 |     |       );
 108 |     |     return IERC20(_tokenOut).balanceOf(_recipient) - _outBefore;
 109 |     |   }
 110 |     | 
 111 |     |   function swapV2SingleExactOut(
 112 |     |     address _tokenIn,
 113 |     |     address _tokenOut,
 114 |     |     uint256 _amountInMax,
 115 |     |     uint256 _amountOut,
 116 |     |     address _recipient
 117 |     |   ) external virtual override returns (uint256 _amountInUsed) {
 118 |     |     uint256 _inBefore = IERC20(_tokenIn).balanceOf(address(this));
 119 |     |     if (_amountInMax == 0) {
 120 |     |       _amountInMax = IERC20(_tokenIn).balanceOf(address(this));
 121 |     |     } else {
 122 |     |       IERC20(_tokenIn).safeTransferFrom(
 123 |     |         _msgSender(),
 124 |     |         address(this),
 125 |     |         _amountInMax
 126 |     |       );
 127 |     |     }
 128 |     |     address[] memory _path = new address[](2);
 129 |     |     _path[0] = _tokenIn;
 130 |     |     _path[1] = _tokenOut;
 131 |     |     IERC20(_tokenIn).safeIncreaseAllowance(V2_ROUTER, _amountInMax);
 132 |     |     IUniswapV2Router02(V2_ROUTER).swapTokensForExactTokens(
 133 |     |       _amountOut,
 134 |     |       _amountInMax,
 135 |     |       _path,
 136 |     |       _recipient,
 137 |     |       block.timestamp
 138 |     |     );
 139 |     |     uint256 _inRemaining = IERC20(_tokenIn).balanceOf(address(this)) -
 140 |     |       _inBefore;
 141 |     |     if (_inRemaining > 0) {
 142 |     |       IERC20(_tokenIn).safeTransfer(_msgSender(), _inRemaining);
 143 |     |     }
 144 |     |     _amountInUsed = _amountInMax - _inRemaining;
 145 |     |   }
 146 |     | 
 147 |     |   function swapV3Single(
 148 |     |     address _tokenIn,
 149 |     |     address _tokenOut,
 150 |     |     uint24 _fee,
 151 |     |     uint256 _amountIn,
 152 |     |     uint256 _amountOutMin,
 153 |     |     address _recipient
 154 |     |   ) external virtual override returns (uint256 _amountOut) {
 155 |     |     uint256 _outBefore = IERC20(_tokenOut).balanceOf(_recipient);
 156 |     |     if (_amountIn == 0) {
 157 |     |       _amountIn = IERC20(_tokenIn).balanceOf(address(this));
 158 |     |     } else {
 159 |     |       IERC20(_tokenIn).safeTransferFrom(_msgSender(), address(this), _amountIn);
 160 |     |     }
 161 |     |     IERC20(_tokenIn).safeIncreaseAllowance(V3_ROUTER, _amountIn);
 162 |     |     ISwapRouter02(V3_ROUTER).exactInputSingle(
 163 |     |       ISwapRouter02.ExactInputSingleParams({
 164 |     |         tokenIn: _tokenIn,
 165 |     |         tokenOut: _tokenOut,
 166 |     |         fee: _fee,
 167 |     |         recipient: _recipient,
 168 |     |         amountIn: _amountIn,
 169 |     |         amountOutMinimum: _amountOutMin,
 170 |     |         sqrtPriceLimitX96: 0
 171 |     |       })
 172 |     |     );
 173 |     |     return IERC20(_tokenOut).balanceOf(_recipient) - _outBefore;
 174 |     |   }
 175 |     | 
 176 |     |   function addLiquidity(
 177 |     |     address _tokenA,
 178 |     |     address _tokenB,
 179 |     |     uint256 _amountADesired,
 180 |     |     uint256 _amountBDesired,
 181 |     |     uint256 _amountAMin,
 182 |     |     uint256 _amountBMin,
 183 |     |     address _to,
 184 |     |     uint256 _deadline
 185 |     |   ) external virtual override {
 186 |     |     uint256 _aBefore = IERC20(_tokenA).balanceOf(address(this));
 187 |     |     uint256 _bBefore = IERC20(_tokenB).balanceOf(address(this));
 188 |     |     IERC20(_tokenA).safeTransferFrom(
 189 |     |       _msgSender(),
 190 |     |       address(this),
 191 |     |       _amountADesired
 192 |     |     );
 193 |     |     IERC20(_tokenB).safeTransferFrom(
 194 |     |       _msgSender(),
 195 |     |       address(this),
 196 |     |       _amountBDesired
 197 |     |     );
 198 |     |     IERC20(_tokenA).safeIncreaseAllowance(V2_ROUTER, _amountADesired);
 199 |     |     IERC20(_tokenB).safeIncreaseAllowance(V2_ROUTER, _amountBDesired);
 200 |     |     IUniswapV2Router02(V2_ROUTER).addLiquidity(
 201 |     |       _tokenA,
 202 |     |       _tokenB,
 203 |     |       _amountADesired,
 204 |     |       _amountBDesired,
 205 |     |       _amountAMin,
 206 |     |       _amountBMin,
 207 |     |       _to,
 208 |     |       _deadline
 209 |     |     );
 210 |     |     if (IERC20(_tokenA).balanceOf(address(this)) > _aBefore) {
 211 |     |       IERC20(_tokenA).safeTransfer(
 212 |     |         _to,
 213 |     |         IERC20(_tokenA).balanceOf(address(this)) - _aBefore
 214 |     |       );
 215 |     |     }
 216 |     |     if (IERC20(_tokenB).balanceOf(address(this)) > _bBefore) {
 217 |     |       IERC20(_tokenB).safeTransfer(
 218 |     |         _to,
 219 |     |         IERC20(_tokenB).balanceOf(address(this)) - _bBefore
 220 |     |       );
 221 |     |     }
 222 |     |   }
 223 |     | 
 224 |     |   function removeLiquidity(
 225 |     |     address _tokenA,
 226 |     |     address _tokenB,
 227 |     |     uint256 _liquidity,
 228 |     |     uint256 _amountAMin,
 229 |     |     uint256 _amountBMin,
 230 |     |     address _to,
 231 |     |     uint256 _deadline
 232 |     |   ) external virtual override {
 233 |     |     address _pool = IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory())
 234 |     |       .getPair(_tokenA, _tokenB);
 235 |     |     uint256 _lpBefore = IERC20(_pool).balanceOf(address(this));
 236 |     |     IERC20(_pool).safeTransferFrom(_msgSender(), address(this), _liquidity);
 237 |     |     IERC20(_pool).safeIncreaseAllowance(V2_ROUTER, _liquidity);
 238 |     |     IUniswapV2Router02(V2_ROUTER).removeLiquidity(
 239 |     |       _tokenA,
 240 |     |       _tokenB,
 241 |     |       _liquidity,
 242 |     |       _amountAMin,
 243 |     |       _amountBMin,
 244 |     |       _to,
 245 |     |       _deadline
 246 |     |     );
 247 |     |     if (IERC20(_pool).balanceOf(address(this)) > _lpBefore) {
 248 |     |       IERC20(_pool).safeTransfer(
 249 |     |         _to,
 250 |     |         IERC20(_pool).balanceOf(address(this)) - _lpBefore
 251 |     |       );
 252 |     |     }
 253 |     |   }
 254 |     | 
 255 |     |   function extraRewardsHook(
 256 |     |     address,
 257 |     |     address
 258 |     |   )
 259 |     |     external
 260 |     |     virtual
 261 |     |     override
 262 |     |     returns (address[] memory _t, uint256[] memory _a)
 263 |     |   {
 264 |     |     _t;
 265 |     |     _a;
 266 |     |   }
 267 |     | }
 268 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ICurvePool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface ICurvePool {
  5 |     |   function coins(uint256 _idx) external returns (address);
  6 |     | 
  7 |     |   function exchange(
  8 |     |     int128 i,
  9 |     |     int128 j,
 10 |     |     uint256 dx,
 11 |     |     uint256 minDy,
 12 |     |     address receiver
 13 |     |   ) external returns (uint256);
 14 |     | }
 15 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IDecentralizedIndex.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   5 |     | 
   6 |     | interface IDecentralizedIndex is IERC20 {
   7 |     |   enum IndexType {
   8 |     |     WEIGHTED,
   9 |     |     UNWEIGHTED
  10 |     |   }
  11 |     | 
  12 |     |   struct Config {
  13 |     |     address partner;
  14 |     |     bool hasTransferTax;
  15 |     |     bool blacklistTKNpTKNPoolV2;
  16 |     |   }
  17 |     | 
  18 |     |   // all fees: 1 == 0.01%, 10 == 0.1%, 100 == 1%
  19 |     |   struct Fees {
  20 |     |     uint16 burn;
  21 |     |     uint16 bond;
  22 |     |     uint16 debond;
  23 |     |     uint16 buy;
  24 |     |     uint16 sell;
  25 |     |     uint16 partner;
  26 |     |   }
  27 |     | 
  28 |     |   struct IndexAssetInfo {
  29 |     |     address token;
  30 |     |     uint256 weighting;
  31 |     |     uint256 basePriceUSDX96;
  32 |     |     address c1; // arbitrary contract/address field we can use for an index
  33 |     |     uint256 q1; // arbitrary quantity/number field we can use for an index
  34 |     |   }
  35 |     | 
  36 |     |   /// @notice The ```Create``` event fires when a new decentralized index has been created
  37 |     |   /// @param newIdx The CA of the new index contract
  38 |     |   /// @param wallet The creator of the new index
  39 |     |   event Create(address indexed newIdx, address indexed wallet);
  40 |     | 
  41 |     |   /// @notice The ```Initialize``` event fires when the new pod has been initialized,
  42 |     |   /// @notice which is at creation on some and in another txn for others (gas limits)
  43 |     |   /// @param wallet The wallet that initialized
  44 |     |   /// @param v2Pool The new UniV2 derivative pool that was created at initialization
  45 |     |   event Initialize(address indexed wallet, address v2Pool);
  46 |     | 
  47 |     |   /// @notice The ```Bond``` event fires when someone wraps into the pod which mints new pod tokens
  48 |     |   /// @param wallet The wallet that wrapped
  49 |     |   /// @param token The token that was used as a ref to wrap into, representing an underlying tkn
  50 |     |   /// @param amountTokensBonded Amount of underlying tkns used to wrap/bond
  51 |     |   /// @param amountTokensMinted Amount of new pod tokens (pTKN) minted
  52 |     |   event Bond(
  53 |     |     address indexed wallet,
  54 |     |     address indexed token,
  55 |     |     uint256 amountTokensBonded,
  56 |     |     uint256 amountTokensMinted
  57 |     |   );
  58 |     | 
  59 |     |   /// @notice The ```Debond``` event fires when someone unwraps from a pod and redeems underlying tkn(s)
  60 |     |   /// @param wallet The wallet that unwrapped/debond
  61 |     |   /// @param amountDebonded Amount of pTKNs burned/unwrapped
  62 |     |   event Debond(address indexed wallet, uint256 amountDebonded);
  63 |     | 
  64 |     |   /// @notice The ```AddLiquidity``` event fires when new liquidity (LP) for a pod is added
  65 |     |   /// @param wallet The wallet that added LP
  66 |     |   /// @param amountTokens Amount of pTKNs used for LP
  67 |     |   /// @param amountDAI Amount of pairedLpAsset used for LP
  68 |     |   event AddLiquidity(
  69 |     |     address indexed wallet,
  70 |     |     uint256 amountTokens,
  71 |     |     uint256 amountDAI
  72 |     |   );
  73 |     | 
  74 |     |   /// @notice The ```RemoveLiquidity``` event fires when LP is removed for a pod
  75 |     |   /// @param wallet The wallet that removed LP
  76 |     |   /// @param amountLiquidity Amount of liquidity removed
  77 |     |   event RemoveLiquidity(address indexed wallet, uint256 amountLiquidity);
  78 |     | 
  79 |     |   event SetPartner(address indexed wallet, address newPartner);
  80 |     | 
  81 |     |   event SetPartnerFee(address indexed wallet, uint16 newFee);
  82 |     | 
  83 |     |   function BOND_FEE() external view returns (uint16);
  84 |     | 
  85 |     |   function DEBOND_FEE() external view returns (uint16);
  86 |     | 
  87 |     |   function FLASH_FEE_AMOUNT_DAI() external view returns (uint256);
  88 |     | 
  89 |     |   function PAIRED_LP_TOKEN() external view returns (address);
  90 |     | 
  91 |     |   function unlocked() external view returns (uint8);
  92 |     | 
  93 |     |   function indexType() external view returns (IndexType);
  94 |     | 
  95 |     |   function created() external view returns (uint256);
  96 |     | 
  97 |     |   function lpStakingPool() external view returns (address);
  98 |     | 
  99 |     |   function lpRewardsToken() external view returns (address);
 100 |     | 
 101 |     |   function partner() external view returns (address);
 102 |     | 
 103 |     |   function getIdxPriceUSDX96() external view returns (uint256, uint256);
 104 |     | 
 105 |     |   function isAsset(address token) external view returns (bool);
 106 |     | 
 107 |     |   function getAllAssets() external view returns (IndexAssetInfo[] memory);
 108 |     | 
 109 |     |   function getInitialAmount(
 110 |     |     address sToken,
 111 |     |     uint256 sAmount,
 112 |     |     address tToken
 113 |     |   ) external view returns (uint256);
 114 |     | 
 115 |     |   function getTokenPriceUSDX96(address token) external view returns (uint256);
 116 |     | 
 117 |     |   function processPreSwapFeesAndSwap() external;
 118 |     | 
 119 |     |   function bond(address token, uint256 amount, uint256 amountMintMin) external;
 120 |     | 
 121 |     |   function debond(
 122 |     |     uint256 amount,
 123 |     |     address[] memory token,
 124 |     |     uint8[] memory percentage
 125 |     |   ) external;
 126 |     | 
 127 |     |   function addLiquidityV2(
 128 |     |     uint256 idxTokens,
 129 |     |     uint256 daiTokens,
 130 |     |     uint256 slippage,
 131 |     |     uint256 deadline
 132 |     |   ) external returns (uint256);
 133 |     | 
 134 |     |   function removeLiquidityV2(
 135 |     |     uint256 lpTokens,
 136 |     |     uint256 minTokens,
 137 |     |     uint256 minDAI,
 138 |     |     uint256 deadline
 139 |     |   ) external;
 140 |     | 
 141 |     |   function flash(
 142 |     |     address recipient,
 143 |     |     address token,
 144 |     |     uint256 amount,
 145 |     |     bytes calldata data
 146 |     |   ) external;
 147 |     | }
 148 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IDexAdapter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IDexAdapter {
  5 |     |   function ASYNC_INITIALIZE() external view returns (bool);
  6 |     | 
  7 |     |   function V2_ROUTER() external view returns (address);
  8 |     | 
  9 |     |   function V3_ROUTER() external view returns (address);
 10 |     | 
 11 |     |   function WETH() external view returns (address);
 12 |     | 
 13 |     |   function getV3Pool(
 14 |     |     address _token0,
 15 |     |     address _token1,
 16 |     |     int24 _tickSpacing
 17 |     |   ) external view returns (address _pool);
 18 |     | 
 19 |     |   function getV3Pool(
 20 |     |     address _token0,
 21 |     |     address _token1,
 22 |     |     uint24 _poolFee
 23 |     |   ) external view returns (address _pool);
 24 |     | 
 25 |     |   function getV2Pool(
 26 |     |     address _token0,
 27 |     |     address _token1
 28 |     |   ) external view returns (address _pool);
 29 |     | 
 30 |     |   function createV2Pool(
 31 |     |     address _token0,
 32 |     |     address _token1
 33 |     |   ) external returns (address _pool);
 34 |     | 
 35 |     |   function swapV2Single(
 36 |     |     address _tokenIn,
 37 |     |     address _tokenOut,
 38 |     |     uint256 _amountIn,
 39 |     |     uint256 _amountOutMin,
 40 |     |     address _recipient
 41 |     |   ) external returns (uint256 _amountOut);
 42 |     | 
 43 |     |   function swapV2SingleExactOut(
 44 |     |     address _tokenIn,
 45 |     |     address _tokenOut,
 46 |     |     uint256 _amountInMax,
 47 |     |     uint256 _amountOut,
 48 |     |     address _recipient
 49 |     |   ) external returns (uint256 _amountInUsed);
 50 |     | 
 51 |     |   function swapV3Single(
 52 |     |     address _tokenIn,
 53 |     |     address _tokenOut,
 54 |     |     uint24 _fee,
 55 |     |     uint256 _amountIn,
 56 |     |     uint256 _amountOutMin,
 57 |     |     address _recipient
 58 |     |   ) external returns (uint256 _amountOut);
 59 |     | 
 60 |     |   function addLiquidity(
 61 |     |     address tokenA,
 62 |     |     address tokenB,
 63 |     |     uint256 amountADesired,
 64 |     |     uint256 amountBDesired,
 65 |     |     uint256 amountAMin,
 66 |     |     uint256 amountBMin,
 67 |     |     address to,
 68 |     |     uint256 deadline
 69 |     |   ) external;
 70 |     | 
 71 |     |   function removeLiquidity(
 72 |     |     address tokenA,
 73 |     |     address tokenB,
 74 |     |     uint256 liquidity,
 75 |     |     uint256 amountAMin,
 76 |     |     uint256 amountBMin,
 77 |     |     address to,
 78 |     |     uint256 deadline
 79 |     |   ) external;
 80 |     | 
 81 |     |   function extraRewardsHook(
 82 |     |     address _token0,
 83 |     |     address _token1
 84 |     |   ) external returns (address[] memory tokens, uint256[] memory amounts);
 85 |     | }
 86 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IERC20Metadata.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.19;
 3 |     | 
 4 |     | interface IERC20Metadata {
 5 |     |   function decimals() external view returns (uint8);
 6 |     | }
 7 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFlashLoanRecipient.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.19;
 3 |     | 
 4 |     | interface IFlashLoanRecipient {
 5 |     |   function callback(bytes calldata data) external;
 6 |     | }
 7 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFlashLoanSource.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IFlashLoanSource {
  5 |     |   struct FlashData {
  6 |     |     address recipient;
  7 |     |     address token;
  8 |     |     uint256 amount;
  9 |     |     bytes data;
 10 |     |     uint256 fee;
 11 |     |   }
 12 |     | 
 13 |     |   function source() external view returns (address);
 14 |     | 
 15 |     |   function paymentToken() external view returns (address);
 16 |     | 
 17 |     |   function paymentAmount() external view returns (uint256);
 18 |     | 
 19 |     |   function flash(
 20 |     |     address token,
 21 |     |     uint256 amount,
 22 |     |     address recipient,
 23 |     |     bytes calldata data
 24 |     |   ) external;
 25 |     | }
 26 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFraxlendPair.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/interfaces/IERC20.sol';
  5 |     | import { VaultAccount } from '../libraries/VaultAccount.sol';
  6 |     | 
  7 |     | interface IFraxlendPair is IERC20 {
  8 |     |   function totalBorrow() external view returns (VaultAccount memory);
  9 |     | 
 10 |     |   function asset() external view returns (address);
 11 |     | 
 12 |     |   function collateralContract() external view returns (address);
 13 |     | 
 14 |     |   function userCollateralBalance(address user) external view returns (uint256); // amount of collateral each user is backed
 15 |     | 
 16 |     |   function userBorrowShares(address user) external view returns (uint256); // represents the shares held by individuals
 17 |     | 
 18 |     |   function deposit(
 19 |     |     uint256 _amount,
 20 |     |     address _receiver
 21 |     |   ) external returns (uint256 _sharesReceived);
 22 |     | 
 23 |     |   function redeem(
 24 |     |     uint256 _shares,
 25 |     |     address _receiver,
 26 |     |     address _owner
 27 |     |   ) external returns (uint256 _amountToReturn);
 28 |     | 
 29 |     |   function borrowAsset(
 30 |     |     uint256 _borrowAmount,
 31 |     |     uint256 _collateralAmount,
 32 |     |     address _receiver
 33 |     |   ) external returns (uint256 _shares);
 34 |     | 
 35 |     |   function repayAsset(
 36 |     |     uint256 _shares,
 37 |     |     address _borrower
 38 |     |   ) external returns (uint256 _amountToRepay);
 39 |     | 
 40 |     |   function addCollateral(uint256 _collateralAmount, address _borrower) external;
 41 |     | 
 42 |     |   function removeCollateral(
 43 |     |     uint256 _collateralAmount,
 44 |     |     address _receiver
 45 |     |   ) external;
 46 |     | }
 47 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IIndexUtils.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import './IDecentralizedIndex.sol';
  5 |     | 
  6 |     | interface IIndexUtils {
  7 |     |   function addLPAndStake(
  8 |     |     IDecentralizedIndex indexFund,
  9 |     |     uint256 amountIdxTokens,
 10 |     |     address pairedLpTokenProvided,
 11 |     |     uint256 amtPairedLpTokenProvided,
 12 |     |     uint256 amountPairedLpTokenMin,
 13 |     |     uint256 slippage,
 14 |     |     uint256 deadline
 15 |     |   ) external payable returns (uint256 amountOut);
 16 |     | 
 17 |     |   function unstakeAndRemoveLP(
 18 |     |     IDecentralizedIndex indexFund,
 19 |     |     uint256 amountStakedTokens,
 20 |     |     uint256 minLPTokens,
 21 |     |     uint256 minPairedLpToken,
 22 |     |     uint256 deadline
 23 |     |   ) external;
 24 |     | }
 25 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IIndexUtils_LEGACY.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import './IDecentralizedIndex.sol';
  5 |     | 
  6 |     | interface IIndexUtils_LEGACY {
  7 |     |   function addLPAndStake(
  8 |     |     IDecentralizedIndex _indexFund,
  9 |     |     uint256 _amountIdxTokens,
 10 |     |     address _pairedLpTokenProvided,
 11 |     |     uint256 _amtPairedLpTokenProvided,
 12 |     |     uint256 _amountPairedLpTokenMin,
 13 |     |     uint256 _slippage,
 14 |     |     uint256 _deadline
 15 |     |   ) external payable;
 16 |     | 
 17 |     |   function unstakeAndRemoveLP(
 18 |     |     IDecentralizedIndex _indexFund,
 19 |     |     uint256 _amountStakedTokens,
 20 |     |     uint256 _minLPTokens,
 21 |     |     uint256 _minPairedLpToken,
 22 |     |     uint256 _deadline
 23 |     |   ) external;
 24 |     | }
 25 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ILendingAssetVault.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface ILendingAssetVault {
  5 |     |   event DonateAssets(address indexed user, uint256 amount);
  6 |     | 
  7 |     |   event PayBackUsedAssets(address indexed user, uint256 amount);
  8 |     | 
  9 |     |   event SetVaultWhitelist(address indexed vault, bool isWhitelisted);
 10 |     | 
 11 |     |   event SetVaultMaxAlloPercentage(address indexed vault, uint256 percentage);
 12 |     | 
 13 |     |   event WhitelistDeposit(address indexed user, uint256 amount);
 14 |     | 
 15 |     |   event WhitelistWithdraw(address indexed user, uint256 amount);
 16 |     | 
 17 |     |   function totalAvailableAssets() external view returns (uint256);
 18 |     | 
 19 |     |   function whitelistDeposit(uint256 amount) external;
 20 |     | 
 21 |     |   function whitelistWithdraw(uint256 amount) external;
 22 |     | }
 23 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ILeverageManager.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface ILeverageManager {
  5 |     |   enum FlashCallbackMethod {
  6 |     |     ADD,
  7 |     |     REMOVE
  8 |     |   }
  9 |     | 
 10 |     |   struct LeverageFlashProps {
 11 |     |     FlashCallbackMethod method;
 12 |     |     uint256 positionId;
 13 |     |     address user;
 14 |     |     address pod;
 15 |     |     uint256 podAmount;
 16 |     |     uint256 pairedLpDesired;
 17 |     |     uint256 pairedLpAmtMin;
 18 |     |     uint256 overrideBorrowAmt;
 19 |     |     uint256 slippage;
 20 |     |     uint256 deadline;
 21 |     |     address selfLendingPairPod;
 22 |     |   }
 23 |     | 
 24 |     |   struct LeveragePositionProps {
 25 |     |     address pod;
 26 |     |     address lendingPair;
 27 |     |     address custodian;
 28 |     |     address selfLendingPod;
 29 |     |   }
 30 |     | 
 31 |     |   function initializePosition(
 32 |     |     address _pod,
 33 |     |     address _recipient,
 34 |     |     address _selfLendingPairPod
 35 |     |   ) external;
 36 |     | 
 37 |     |   function addLeverage(
 38 |     |     uint256 _positionId,
 39 |     |     address _pod,
 40 |     |     uint256 _podAmount,
 41 |     |     uint256 _pairedLpDesired,
 42 |     |     uint256 _pairedLpAmtMin,
 43 |     |     uint256 _overrideBorrowAmt,
 44 |     |     uint256 _slippage,
 45 |     |     uint256 _deadline,
 46 |     |     address _selfLendingPairPod
 47 |     |   ) external;
 48 |     | 
 49 |     |   function removeLeverage(
 50 |     |     uint256 _positionId,
 51 |     |     uint256 _borrowAssetAmt,
 52 |     |     uint256 _collateralAssetAmtRemove,
 53 |     |     uint256 _podAmtMin,
 54 |     |     uint256 _pairedAssetAmtMin,
 55 |     |     address _dexAdapter,
 56 |     |     uint256 _userProvidedDebtAmtMax
 57 |     |   ) external;
 58 |     | }
 59 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IMinimalOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IMinimalOracle {
  5 |     |   function getPrices()
  6 |     |     external
  7 |     |     view
  8 |     |     returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);
  9 |     | }
 10 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IMinimalSinglePriceOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IMinimalSinglePriceOracle {
  5 |     |   function getPriceUSD18(
  6 |     |     address base,
  7 |     |     address quote,
  8 |     |     address a1, // any extra address parameter an implementation may need
  9 |     |     uint256 q1 // any extra uint256 parameter an implementation may need
 10 |     |   ) external view returns (bool isBadData, uint256 price18);
 11 |     | }
 12 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IPEAS.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
  5 |     | 
  6 |     | interface IPEAS is IERC20 {
  7 |     |   event Burn(address indexed user, uint256 amount);
  8 |     | 
  9 |     |   function burn(uint256 amount) external;
 10 |     | }
 11 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IProtocolFeeRouter.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import './IProtocolFees.sol';
  5 |     | 
  6 |     | interface IProtocolFeeRouter {
  7 |     |   function protocolFees() external view returns (IProtocolFees);
  8 |     | }
  9 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IProtocolFees.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IProtocolFees {
  5 |     |   event SetYieldAdmin(uint256 newFee);
  6 |     |   event SetYieldBurn(uint256 newFee);
  7 |     | 
  8 |     |   function DEN() external view returns (uint256);
  9 |     | 
 10 |     |   function yieldAdmin() external view returns (uint256);
 11 |     | 
 12 |     |   function yieldBurn() external view returns (uint256);
 13 |     | }
 14 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IRewardsWhitelister.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IRewardsWhitelister {
  5 |     |   function whitelist(address token) external view returns (bool);
  6 |     | 
  7 |     |   function getFullWhitelist() external view returns (address[] memory);
  8 |     | }
  9 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IStakingPoolToken.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IStakingPoolToken {
  5 |     |   event Stake(address indexed executor, address indexed user, uint256 amount);
  6 |     | 
  7 |     |   event Unstake(address indexed user, uint256 amount);
  8 |     | 
  9 |     |   function INDEX_FUND() external view returns (address);
 10 |     | 
 11 |     |   function indexFund() external view returns (address);
 12 |     | 
 13 |     |   function POOL_REWARDS() external view returns (address);
 14 |     | 
 15 |     |   function poolRewards() external view returns (address);
 16 |     | 
 17 |     |   function stakingToken() external view returns (address);
 18 |     | 
 19 |     |   function stakeUserRestriction() external view returns (address);
 20 |     | 
 21 |     |   function stake(address user, uint256 amount) external;
 22 |     | 
 23 |     |   function unstake(uint256 amount) external;
 24 |     | 
 25 |     |   function externalRewardHook(address token0, address token1) external;
 26 |     | }
 27 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ISwapRouter02.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface ISwapRouter02 {
  5 |     |   struct ExactInputSingleParams {
  6 |     |     address tokenIn;
  7 |     |     address tokenOut;
  8 |     |     uint24 fee;
  9 |     |     address recipient;
 10 |     |     uint256 amountIn;
 11 |     |     uint256 amountOutMinimum;
 12 |     |     uint160 sqrtPriceLimitX96;
 13 |     |   }
 14 |     | 
 15 |     |   function exactInputSingle(
 16 |     |     ExactInputSingleParams calldata params
 17 |     |   ) external payable returns (uint256 amountOut);
 18 |     | 
 19 |     |   struct ExactInputParams {
 20 |     |     bytes path;
 21 |     |     address recipient;
 22 |     |     uint256 amountIn;
 23 |     |     uint256 amountOutMinimum;
 24 |     |   }
 25 |     | 
 26 |     |   function exactInput(
 27 |     |     ExactInputParams calldata params
 28 |     |   ) external payable returns (uint256 amountOut);
 29 |     | }
 30 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ITokenRewards.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface ITokenRewards {
  5 |     |   event AddShares(address indexed wallet, uint256 amount);
  6 |     | 
  7 |     |   event RemoveShares(address indexed wallet, uint256 amount);
  8 |     | 
  9 |     |   event ClaimReward(address indexed wallet);
 10 |     | 
 11 |     |   event DistributeReward(
 12 |     |     address indexed wallet,
 13 |     |     address indexed token,
 14 |     |     uint256 amount
 15 |     |   );
 16 |     | 
 17 |     |   event DepositRewards(
 18 |     |     address indexed wallet,
 19 |     |     address indexed token,
 20 |     |     uint256 amount
 21 |     |   );
 22 |     | 
 23 |     |   event RewardSwapError(uint256 amountIn);
 24 |     | 
 25 |     |   function totalShares() external view returns (uint256);
 26 |     | 
 27 |     |   function totalStakers() external view returns (uint256);
 28 |     | 
 29 |     |   function rewardsToken() external view returns (address);
 30 |     | 
 31 |     |   function trackingToken() external view returns (address);
 32 |     | 
 33 |     |   function depositFromPairedLpToken(uint256 amount) external;
 34 |     | 
 35 |     |   function depositRewards(address token, uint256 amount) external;
 36 |     | 
 37 |     |   function depositRewardsNoTransfer(address token, uint256 amount) external;
 38 |     | 
 39 |     |   function claimReward(address wallet) external;
 40 |     | 
 41 |     |   function setShares(
 42 |     |     address wallet,
 43 |     |     uint256 amount,
 44 |     |     bool sharesRemoving
 45 |     |   ) external;
 46 |     | }
 47 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Factory.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IUniswapV2Factory {
  5 |     |   function createPair(
  6 |     |     address tokenA,
  7 |     |     address tokenB
  8 |     |   ) external returns (address pair);
  9 |     | 
 10 |     |   function getPair(
 11 |     |     address tokenA,
 12 |     |     address tokenB
 13 |     |   ) external view returns (address pair);
 14 |     | }
 15 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Pair.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IUniswapV2Pair {
  5 |     |   function token0() external view returns (address);
  6 |     | 
  7 |     |   function token1() external view returns (address);
  8 |     | 
  9 |     |   function getReserves()
 10 |     |     external
 11 |     |     view
 12 |     |     returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
 13 |     | }
 14 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Router02.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IUniswapV2Router02 {
  5 |     |   function factory() external view returns (address);
  6 |     | 
  7 |     |   function WETH() external view returns (address);
  8 |     | 
  9 |     |   function addLiquidity(
 10 |     |     address tokenA,
 11 |     |     address tokenB,
 12 |     |     uint amountADesired,
 13 |     |     uint amountBDesired,
 14 |     |     uint amountAMin,
 15 |     |     uint amountBMin,
 16 |     |     address to,
 17 |     |     uint deadline
 18 |     |   ) external returns (uint amountA, uint amountB, uint liquidity);
 19 |     | 
 20 |     |   function removeLiquidity(
 21 |     |     address tokenA,
 22 |     |     address tokenB,
 23 |     |     uint liquidity,
 24 |     |     uint amountAMin,
 25 |     |     uint amountBMin,
 26 |     |     address to,
 27 |     |     uint deadline
 28 |     |   ) external returns (uint amountA, uint amountB);
 29 |     | 
 30 |     |   function swapETHForExactTokens(
 31 |     |     uint256 amountOut,
 32 |     |     address[] calldata path,
 33 |     |     address to,
 34 |     |     uint256 deadline
 35 |     |   ) external payable returns (uint256[] memory amounts);
 36 |     | 
 37 |     |   function swapExactTokensForTokensSupportingFeeOnTransferTokens(
 38 |     |     uint amountIn,
 39 |     |     uint amountOutMin,
 40 |     |     address[] calldata path,
 41 |     |     address to,
 42 |     |     uint deadline
 43 |     |   ) external returns (uint[] memory amounts);
 44 |     | 
 45 |     |   function swapTokensForExactTokens(
 46 |     |     uint amountOut,
 47 |     |     uint amountInMax,
 48 |     |     address[] calldata path,
 49 |     |     address to,
 50 |     |     uint deadline
 51 |     |   ) external returns (uint[] memory amounts);
 52 |     | }
 53 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IUniswapV3Pool {
  5 |     |   /// @notice The first of the two tokens of the pool, sorted by address
  6 |     |   /// @return The token contract address
  7 |     |   function token0() external view returns (address);
  8 |     | 
  9 |     |   /// @notice The second of the two tokens of the pool, sorted by address
 10 |     |   /// @return The token contract address
 11 |     |   function token1() external view returns (address);
 12 |     | 
 13 |     |   /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 14 |     |   /// @return The fee
 15 |     |   function fee() external view returns (uint24);
 16 |     | 
 17 |     |   /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
 18 |     |   /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 19 |     |   /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 20 |     |   /// you must call it with secondsAgos = [3600, 0].
 21 |     |   /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 22 |     |   /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 23 |     |   /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 24 |     |   /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 25 |     |   /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 26 |     |   /// timestamp
 27 |     |   function observe(
 28 |     |     uint32[] calldata secondsAgos
 29 |     |   )
 30 |     |     external
 31 |     |     view
 32 |     |     returns (
 33 |     |       int56[] memory tickCumulatives,
 34 |     |       uint160[] memory secondsPerLiquidityCumulativeX128s
 35 |     |     );
 36 |     | 
 37 |     |   /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
 38 |     |   /// when accessed externally.
 39 |     |   /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
 40 |     |   /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
 41 |     |   /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
 42 |     |   /// boundary.
 43 |     |   /// observationIndex The index of the last oracle observation that was written,
 44 |     |   /// observationCardinality The current maximum number of observations stored in the pool,
 45 |     |   /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
 46 |     |   /// feeProtocol The protocol fee for both tokens of the pool.
 47 |     |   /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
 48 |     |   /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
 49 |     |   /// unlocked Whether the pool is currently locked to reentrancy
 50 |     |   function slot0()
 51 |     |     external
 52 |     |     view
 53 |     |     returns (
 54 |     |       uint160 sqrtPriceX96,
 55 |     |       int24 tick,
 56 |     |       uint16 observationIndex,
 57 |     |       uint16 observationCardinality,
 58 |     |       uint16 observationCardinalityNext,
 59 |     |       uint8 feeProtocol,
 60 |     |       bool unlocked
 61 |     |     );
 62 |     | }
 63 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IV2Reserves.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IV2Reserves {
  5 |     |   function getReserves(
  6 |     |     address _pair
  7 |     |   ) external view returns (uint112 reserve0, uint112 reserve1);
  8 |     | }
  9 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IV3TwapUtilities.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IV3TwapUtilities {
  5 |     |   function getV3Pool(
  6 |     |     address v3Factory,
  7 |     |     address token0,
  8 |     |     address token1
  9 |     |   ) external view returns (address);
 10 |     | 
 11 |     |   function getV3Pool(
 12 |     |     address v3Factory,
 13 |     |     address token0,
 14 |     |     address token1,
 15 |     |     uint24 poolFee
 16 |     |   ) external view returns (address);
 17 |     | 
 18 |     |   function getV3Pool(
 19 |     |     address v3Factory,
 20 |     |     address token0,
 21 |     |     address token1,
 22 |     |     int24 tickSpacing
 23 |     |   ) external view returns (address);
 24 |     | 
 25 |     |   function getPoolPriceUSDX96(
 26 |     |     address pricePool,
 27 |     |     address nativeStablePool,
 28 |     |     address WETH9
 29 |     |   ) external view returns (uint256);
 30 |     | 
 31 |     |   function sqrtPriceX96FromPoolAndInterval(
 32 |     |     address pool
 33 |     |   ) external view returns (uint160);
 34 |     | 
 35 |     |   function sqrtPriceX96FromPoolAndPassedInterval(
 36 |     |     address pool,
 37 |     |     uint32 interval
 38 |     |   ) external view returns (uint160);
 39 |     | 
 40 |     |   function priceX96FromSqrtPriceX96(
 41 |     |     uint160 sqrtPriceX96
 42 |     |   ) external pure returns (uint256);
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IWETH.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IWETH {
  5 |     |   function deposit() external payable;
  6 |     | 
  7 |     |   function withdraw(uint256 _amount) external;
  8 |     | }
  9 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IZapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IZapper {
  5 |     |   enum PoolType {
  6 |     |     CURVE,
  7 |     |     V2,
  8 |     |     V3
  9 |     |   }
 10 |     | 
 11 |     |   struct Pools {
 12 |     |     PoolType poolType; // assume same for both pool1 and pool2
 13 |     |     address pool1;
 14 |     |     address pool2;
 15 |     |   }
 16 |     | }
 17 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | // https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol
   5 |     | 
   6 |     | /// @title Contains 512-bit math functions
   7 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   8 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   9 |     | library FullMath {
  10 |     |   /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  11 |     |   /// @param a The multiplicand
  12 |     |   /// @param b The multiplier
  13 |     |   /// @param denominator The divisor
  14 |     |   /// @return result The 256-bit result
  15 |     |   /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  16 |     |   function mulDiv(
  17 |     |     uint256 a,
  18 |     |     uint256 b,
  19 |     |     uint256 denominator
  20 |     |   ) internal pure returns (uint256 result) {
  21 |     |     unchecked {
  22 |     |       // 512-bit multiply [prod1 prod0] = a * b
  23 |     |       // Compute the product mod 2**256 and mod 2**256 - 1
  24 |     |       // then use the Chinese Remainder Theorem to reconstruct
  25 |     |       // the 512 bit result. The result is stored in two 256
  26 |     |       // variables such that product = prod1 * 2**256 + prod0
  27 |     |       uint256 prod0; // Least significant 256 bits of the product
  28 |     |       uint256 prod1; // Most significant 256 bits of the product
  29 |     |       assembly {
  30 |     |         let mm := mulmod(a, b, not(0))
  31 |     |         prod0 := mul(a, b)
  32 |     |         prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  33 |     |       }
  34 |     | 
  35 |     |       // Handle non-overflow cases, 256 by 256 division
  36 |     |       if (prod1 == 0) {
  37 |     |         require(denominator > 0);
  38 |     |         assembly {
  39 |     |           result := div(prod0, denominator)
  40 |     |         }
  41 |     |         return result;
  42 |     |       }
  43 |     | 
  44 |     |       // Make sure the result is less than 2**256.
  45 |     |       // Also prevents denominator == 0
  46 |     |       require(denominator > prod1);
  47 |     | 
  48 |     |       ///////////////////////////////////////////////
  49 |     |       // 512 by 256 division.
  50 |     |       ///////////////////////////////////////////////
  51 |     | 
  52 |     |       // Make division exact by subtracting the remainder from [prod1 prod0]
  53 |     |       // Compute remainder using mulmod
  54 |     |       uint256 remainder;
  55 |     |       assembly {
  56 |     |         remainder := mulmod(a, b, denominator)
  57 |     |       }
  58 |     |       // Subtract 256 bit number from 512 bit number
  59 |     |       assembly {
  60 |     |         prod1 := sub(prod1, gt(remainder, prod0))
  61 |     |         prod0 := sub(prod0, remainder)
  62 |     |       }
  63 |     | 
  64 |     |       // Factor powers of two out of denominator
  65 |     |       // Compute largest power of two divisor of denominator.
  66 |     |       // Always >= 1.
  67 |     |       uint256 twos = (0 - denominator) & denominator;
  68 |     |       // Divide denominator by power of two
  69 |     |       assembly {
  70 |     |         denominator := div(denominator, twos)
  71 |     |       }
  72 |     | 
  73 |     |       // Divide [prod1 prod0] by the factors of two
  74 |     |       assembly {
  75 |     |         prod0 := div(prod0, twos)
  76 |     |       }
  77 |     |       // Shift in bits from prod1 into prod0. For this we need
  78 |     |       // to flip `twos` such that it is 2**256 / twos.
  79 |     |       // If twos is zero, then it becomes one
  80 |     |       assembly {
  81 |     |         twos := add(div(sub(0, twos), twos), 1)
  82 |     |       }
  83 |     |       prod0 |= prod1 * twos;
  84 |     | 
  85 |     |       // Invert denominator mod 2**256
  86 |     |       // Now that denominator is an odd number, it has an inverse
  87 |     |       // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  88 |     |       // Compute the inverse by starting with a seed that is correct
  89 |     |       // correct for four bits. That is, denominator * inv = 1 mod 2**4
  90 |     |       uint256 inv = (3 * denominator) ^ 2;
  91 |     |       // Now use Newton-Raphson iteration to improve the precision.
  92 |     |       // Thanks to Hensel's lifting lemma, this also works in modular
  93 |     |       // arithmetic, doubling the correct bits in each step.
  94 |     |       inv *= 2 - denominator * inv; // inverse mod 2**8
  95 |     |       inv *= 2 - denominator * inv; // inverse mod 2**16
  96 |     |       inv *= 2 - denominator * inv; // inverse mod 2**32
  97 |     |       inv *= 2 - denominator * inv; // inverse mod 2**64
  98 |     |       inv *= 2 - denominator * inv; // inverse mod 2**128
  99 |     |       inv *= 2 - denominator * inv; // inverse mod 2**256
 100 |     | 
 101 |     |       // Because the division is now exact we can divide by multiplying
 102 |     |       // with the modular inverse of denominator. This will give us the
 103 |     |       // correct result modulo 2**256. Since the precoditions guarantee
 104 |     |       // that the outcome is less than 2**256, this is the final result.
 105 |     |       // We don't need to compute the high bits of the result and prod1
 106 |     |       // is no longer required.
 107 |     |       result = prod0 * inv;
 108 |     |       return result;
 109 |     |     }
 110 |     |   }
 111 |     | 
 112 |     |   /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 113 |     |   /// @param a The multiplicand
 114 |     |   /// @param b The multiplier
 115 |     |   /// @param denominator The divisor
 116 |     |   /// @return result The 256-bit result
 117 |     |   function mulDivRoundingUp(
 118 |     |     uint256 a,
 119 |     |     uint256 b,
 120 |     |     uint256 denominator
 121 |     |   ) internal pure returns (uint256 result) {
 122 |     |     unchecked {
 123 |     |       result = mulDiv(a, b, denominator);
 124 |     |       if (mulmod(a, b, denominator) > 0) {
 125 |     |         require(result < type(uint256).max);
 126 |     |         result++;
 127 |     |       }
 128 |     |     }
 129 |     |   }
 130 |     | }
 131 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/PoolAddress.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
  5 |     | library PoolAddress {
  6 |     |   bytes32 internal constant POOL_INIT_CODE_HASH =
  7 |     |     0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
  8 |     | 
  9 |     |   /// @notice The identifying key of the pool
 10 |     |   struct PoolKey {
 11 |     |     address token0;
 12 |     |     address token1;
 13 |     |     uint24 fee;
 14 |     |   }
 15 |     | 
 16 |     |   /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
 17 |     |   /// @param tokenA The first token of a pool, unsorted
 18 |     |   /// @param tokenB The second token of a pool, unsorted
 19 |     |   /// @param fee The fee level of the pool
 20 |     |   /// @return Poolkey The pool details with ordered token0 and token1 assignments
 21 |     |   function getPoolKey(
 22 |     |     address tokenA,
 23 |     |     address tokenB,
 24 |     |     uint24 fee
 25 |     |   ) internal pure returns (PoolKey memory) {
 26 |     |     if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
 27 |     |     return PoolKey({ token0: tokenA, token1: tokenB, fee: fee });
 28 |     |   }
 29 |     | 
 30 |     |   /// @notice Deterministically computes the pool address given the factory and PoolKey
 31 |     |   /// @param factory The Uniswap V3 factory contract address
 32 |     |   /// @param key The PoolKey
 33 |     |   /// @return pool The contract address of the V3 pool
 34 |     |   function computeAddress(
 35 |     |     address factory,
 36 |     |     PoolKey memory key
 37 |     |   ) internal pure returns (address pool) {
 38 |     |     require(key.token0 < key.token1);
 39 |     |     pool = address(
 40 |     |       uint160(
 41 |     |         uint256(
 42 |     |           keccak256(
 43 |     |             abi.encodePacked(
 44 |     |               hex'ff',
 45 |     |               factory,
 46 |     |               keccak256(abi.encode(key.token0, key.token1, key.fee)),
 47 |     |               POOL_INIT_CODE_HASH
 48 |     |             )
 49 |     |           )
 50 |     |         )
 51 |     |       )
 52 |     |     );
 53 |     |   }
 54 |     | }
 55 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | // https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol
   5 |     | 
   6 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   7 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   8 |     | /// prices between 2**-128 and 2**128
   9 |     | library TickMath {
  10 |     |   error T();
  11 |     |   error R();
  12 |     | 
  13 |     |   /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
  14 |     |   int24 internal constant MIN_TICK = -887272;
  15 |     |   /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  16 |     |   int24 internal constant MAX_TICK = -MIN_TICK;
  17 |     | 
  18 |     |   /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  19 |     |   uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  20 |     |   /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  21 |     |   uint160 internal constant MAX_SQRT_RATIO =
  22 |     |     1461446703485210103287273052203988822378723970342;
  23 |     | 
  24 |     |   /// @notice Calculates sqrt(1.0001^tick) * 2^96
  25 |     |   /// @dev Throws if |tick| > max tick
  26 |     |   /// @param tick The input tick for the above formula
  27 |     |   /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  28 |     |   /// at the given tick
  29 |     |   function getSqrtRatioAtTick(
  30 |     |     int24 tick
  31 |     |   ) internal pure returns (uint160 sqrtPriceX96) {
  32 |     |     unchecked {
  33 |     |       uint256 absTick = tick < 0
  34 |     |         ? uint256(-int256(tick))
  35 |     |         : uint256(int256(tick));
  36 |     |       if (absTick > uint256(int256(MAX_TICK))) revert T();
  37 |     | 
  38 |     |       uint256 ratio = absTick & 0x1 != 0
  39 |     |         ? 0xfffcb933bd6fad37aa2d162d1a594001
  40 |     |         : 0x100000000000000000000000000000000;
  41 |     |       if (absTick & 0x2 != 0)
  42 |     |         ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  43 |     |       if (absTick & 0x4 != 0)
  44 |     |         ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  45 |     |       if (absTick & 0x8 != 0)
  46 |     |         ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  47 |     |       if (absTick & 0x10 != 0)
  48 |     |         ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  49 |     |       if (absTick & 0x20 != 0)
  50 |     |         ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  51 |     |       if (absTick & 0x40 != 0)
  52 |     |         ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  53 |     |       if (absTick & 0x80 != 0)
  54 |     |         ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  55 |     |       if (absTick & 0x100 != 0)
  56 |     |         ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  57 |     |       if (absTick & 0x200 != 0)
  58 |     |         ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  59 |     |       if (absTick & 0x400 != 0)
  60 |     |         ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  61 |     |       if (absTick & 0x800 != 0)
  62 |     |         ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  63 |     |       if (absTick & 0x1000 != 0)
  64 |     |         ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  65 |     |       if (absTick & 0x2000 != 0)
  66 |     |         ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  67 |     |       if (absTick & 0x4000 != 0)
  68 |     |         ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  69 |     |       if (absTick & 0x8000 != 0)
  70 |     |         ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  71 |     |       if (absTick & 0x10000 != 0)
  72 |     |         ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  73 |     |       if (absTick & 0x20000 != 0)
  74 |     |         ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  75 |     |       if (absTick & 0x40000 != 0)
  76 |     |         ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  77 |     |       if (absTick & 0x80000 != 0)
  78 |     |         ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  79 |     | 
  80 |     |       if (tick > 0) ratio = type(uint256).max / ratio;
  81 |     | 
  82 |     |       // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  83 |     |       // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  84 |     |       // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  85 |     |       sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  86 |     |     }
  87 |     |   }
  88 |     | 
  89 |     |   /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  90 |     |   /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  91 |     |   /// ever return.
  92 |     |   /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  93 |     |   /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  94 |     |   function getTickAtSqrtRatio(
  95 |     |     uint160 sqrtPriceX96
  96 |     |   ) internal pure returns (int24 tick) {
  97 |     |     unchecked {
  98 |     |       // second inequality must be < because the price can never reach the price at the max tick
  99 |     |       if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO))
 100 |     |         revert R();
 101 |     |       uint256 ratio = uint256(sqrtPriceX96) << 32;
 102 |     | 
 103 |     |       uint256 r = ratio;
 104 |     |       uint256 msb = 0;
 105 |     | 
 106 |     |       assembly {
 107 |     |         let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
 108 |     |         msb := or(msb, f)
 109 |     |         r := shr(f, r)
 110 |     |       }
 111 |     |       assembly {
 112 |     |         let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
 113 |     |         msb := or(msb, f)
 114 |     |         r := shr(f, r)
 115 |     |       }
 116 |     |       assembly {
 117 |     |         let f := shl(5, gt(r, 0xFFFFFFFF))
 118 |     |         msb := or(msb, f)
 119 |     |         r := shr(f, r)
 120 |     |       }
 121 |     |       assembly {
 122 |     |         let f := shl(4, gt(r, 0xFFFF))
 123 |     |         msb := or(msb, f)
 124 |     |         r := shr(f, r)
 125 |     |       }
 126 |     |       assembly {
 127 |     |         let f := shl(3, gt(r, 0xFF))
 128 |     |         msb := or(msb, f)
 129 |     |         r := shr(f, r)
 130 |     |       }
 131 |     |       assembly {
 132 |     |         let f := shl(2, gt(r, 0xF))
 133 |     |         msb := or(msb, f)
 134 |     |         r := shr(f, r)
 135 |     |       }
 136 |     |       assembly {
 137 |     |         let f := shl(1, gt(r, 0x3))
 138 |     |         msb := or(msb, f)
 139 |     |         r := shr(f, r)
 140 |     |       }
 141 |     |       assembly {
 142 |     |         let f := gt(r, 0x1)
 143 |     |         msb := or(msb, f)
 144 |     |       }
 145 |     | 
 146 |     |       if (msb >= 128) r = ratio >> (msb - 127);
 147 |     |       else r = ratio << (127 - msb);
 148 |     | 
 149 |     |       int256 log_2 = (int256(msb) - 128) << 64;
 150 |     | 
 151 |     |       assembly {
 152 |     |         r := shr(127, mul(r, r))
 153 |     |         let f := shr(128, r)
 154 |     |         log_2 := or(log_2, shl(63, f))
 155 |     |         r := shr(f, r)
 156 |     |       }
 157 |     |       assembly {
 158 |     |         r := shr(127, mul(r, r))
 159 |     |         let f := shr(128, r)
 160 |     |         log_2 := or(log_2, shl(62, f))
 161 |     |         r := shr(f, r)
 162 |     |       }
 163 |     |       assembly {
 164 |     |         r := shr(127, mul(r, r))
 165 |     |         let f := shr(128, r)
 166 |     |         log_2 := or(log_2, shl(61, f))
 167 |     |         r := shr(f, r)
 168 |     |       }
 169 |     |       assembly {
 170 |     |         r := shr(127, mul(r, r))
 171 |     |         let f := shr(128, r)
 172 |     |         log_2 := or(log_2, shl(60, f))
 173 |     |         r := shr(f, r)
 174 |     |       }
 175 |     |       assembly {
 176 |     |         r := shr(127, mul(r, r))
 177 |     |         let f := shr(128, r)
 178 |     |         log_2 := or(log_2, shl(59, f))
 179 |     |         r := shr(f, r)
 180 |     |       }
 181 |     |       assembly {
 182 |     |         r := shr(127, mul(r, r))
 183 |     |         let f := shr(128, r)
 184 |     |         log_2 := or(log_2, shl(58, f))
 185 |     |         r := shr(f, r)
 186 |     |       }
 187 |     |       assembly {
 188 |     |         r := shr(127, mul(r, r))
 189 |     |         let f := shr(128, r)
 190 |     |         log_2 := or(log_2, shl(57, f))
 191 |     |         r := shr(f, r)
 192 |     |       }
 193 |     |       assembly {
 194 |     |         r := shr(127, mul(r, r))
 195 |     |         let f := shr(128, r)
 196 |     |         log_2 := or(log_2, shl(56, f))
 197 |     |         r := shr(f, r)
 198 |     |       }
 199 |     |       assembly {
 200 |     |         r := shr(127, mul(r, r))
 201 |     |         let f := shr(128, r)
 202 |     |         log_2 := or(log_2, shl(55, f))
 203 |     |         r := shr(f, r)
 204 |     |       }
 205 |     |       assembly {
 206 |     |         r := shr(127, mul(r, r))
 207 |     |         let f := shr(128, r)
 208 |     |         log_2 := or(log_2, shl(54, f))
 209 |     |         r := shr(f, r)
 210 |     |       }
 211 |     |       assembly {
 212 |     |         r := shr(127, mul(r, r))
 213 |     |         let f := shr(128, r)
 214 |     |         log_2 := or(log_2, shl(53, f))
 215 |     |         r := shr(f, r)
 216 |     |       }
 217 |     |       assembly {
 218 |     |         r := shr(127, mul(r, r))
 219 |     |         let f := shr(128, r)
 220 |     |         log_2 := or(log_2, shl(52, f))
 221 |     |         r := shr(f, r)
 222 |     |       }
 223 |     |       assembly {
 224 |     |         r := shr(127, mul(r, r))
 225 |     |         let f := shr(128, r)
 226 |     |         log_2 := or(log_2, shl(51, f))
 227 |     |         r := shr(f, r)
 228 |     |       }
 229 |     |       assembly {
 230 |     |         r := shr(127, mul(r, r))
 231 |     |         let f := shr(128, r)
 232 |     |         log_2 := or(log_2, shl(50, f))
 233 |     |       }
 234 |     | 
 235 |     |       int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 236 |     | 
 237 |     |       int24 tickLow = int24(
 238 |     |         (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128
 239 |     |       );
 240 |     |       int24 tickHi = int24(
 241 |     |         (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128
 242 |     |       );
 243 |     | 
 244 |     |       tick = tickLow == tickHi
 245 |     |         ? tickLow
 246 |     |         : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96
 247 |     |         ? tickHi
 248 |     |         : tickLow;
 249 |     |     }
 250 |     |   }
 251 |     | }
 252 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/VaultAccount.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | struct VaultAccount {
  5 |     |     uint128 amount; // Total amount, analogous to market cap
  6 |     |     uint128 shares; // Total shares, analogous to shares outstanding
  7 |     | }
  8 |     | 
  9 |     | /// @title VaultAccount Library
 10 |     | /// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto
 11 |     | /// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations
 12 |     | /// @dev Uses uint128 to save on storage
 13 |     | library VaultAccountingLibrary {
 14 |     |     /// @notice Calculates the shares value in relationship to `amount` and `total`
 15 |     |     /// @dev Given an amount, return the appropriate number of shares
 16 |     |     function toShares(VaultAccount memory total, uint256 amount, bool roundUp) internal pure returns (uint256 shares) {
 17 |     |         if (total.amount == 0) {
 18 |     |             shares = amount;
 19 |     |         } else {
 20 |     |             shares = (amount * total.shares) / total.amount;
 21 |     |             if (roundUp && (shares * total.amount) / total.shares < amount) {
 22 |     |                 shares = shares + 1;
 23 |     |             }
 24 |     |         }
 25 |     |     }
 26 |     | 
 27 |     |     /// @notice Calculates the amount value in relationship to `shares` and `total`
 28 |     |     /// @dev Given a number of shares, returns the appropriate amount
 29 |     |     function toAmount(VaultAccount memory total, uint256 shares, bool roundUp) internal pure returns (uint256 amount) {
 30 |     |         if (total.shares == 0) {
 31 |     |             amount = shares;
 32 |     |         } else {
 33 |     |             amount = (shares * total.amount) / total.shares;
 34 |     |             if (roundUp && (amount * total.shares) / total.amount < shares) {
 35 |     |                 amount = amount + 1;
 36 |     |             }
 37 |     |         }
 38 |     |     }
 39 |     | }
 40 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeverageManager.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   7 |     | import '@openzeppelin/contracts/utils/Context.sol';
   8 |     | import '../interfaces/IDecentralizedIndex.sol';
   9 |     | import '../interfaces/IDexAdapter.sol';
  10 |     | import '../interfaces/IFlashLoanRecipient.sol';
  11 |     | // import '../interfaces/IIndexUtils.sol';
  12 |     | import '../interfaces/IIndexUtils_LEGACY.sol';
  13 |     | import '../interfaces/ILeverageManager.sol';
  14 |     | import { VaultAccount, VaultAccountingLibrary } from '../libraries/VaultAccount.sol';
  15 |     | import '../AutoCompoundingPodLp.sol';
  16 |     | import './LeverageManagerAccessControl.sol';
  17 |     | import './LeveragePositions.sol';
  18 |     | import './LeveragePositionCustodian.sol';
  19 |     | 
  20 |     | contract LeverageManager is
  21 |     |   ILeverageManager,
  22 |     |   IFlashLoanRecipient,
  23 |     |   Context,
  24 |     |   LeverageManagerAccessControl
  25 |     | {
  26 |     |   using SafeERC20 for IERC20;
  27 |     |   using VaultAccountingLibrary for VaultAccount;
  28 |     | 
  29 |     |   IIndexUtils_LEGACY public indexUtils;
  30 |     |   LeveragePositions public positionNFT;
  31 |     | 
  32 |     |   uint16 public openFeePerc; // 1000 precision
  33 |     |   uint16 public closeFeePerc; // 1000 precision
  34 |     | 
  35 |     |   // positionId => position props
  36 |     |   mapping(uint256 => LeveragePositionProps) public positionProps;
  37 |     | 
  38 |     |   event AddLeverage(uint256 indexed positionId, address indexed user);
  39 |     | 
  40 |     |   modifier onlyPositionOwner(uint256 _positionId) {
  41 |     |     require(positionNFT.ownerOf(_positionId) == _msgSender(), 'AUTH');
  42 |     |     _;
  43 |     |   }
  44 |     | 
  45 |     |   bool _initialised;
  46 |     |   modifier workflow(bool _starting) {
  47 |     |     if (_starting) {
  48 |     |       require(!_initialised, 'W0');
  49 |     |       _initialised = true;
  50 |     |     } else {
  51 |     |       require(_initialised, 'W1');
  52 |     |       _initialised = false;
  53 |     |     }
  54 |     |     _;
  55 |     |   }
  56 |     | 
  57 |     |   constructor(
  58 |     |     string memory _positionName,
  59 |     |     string memory _positionSymbol,
  60 |     |     IIndexUtils_LEGACY _idxUtils
  61 |     |   ) {
  62 |     |     indexUtils = _idxUtils;
  63 |     |     positionNFT = new LeveragePositions(_positionName, _positionSymbol);
  64 |     |   }
  65 |     | 
  66 |     |   /// @notice The ```initializePosition``` function initializes a new position and mints a new position NFT
  67 |     |   /// @param _pod The pod to leverage against for the new position
  68 |     |   /// @param _recipient User to receive the position NFT
  69 |     |   /// @param _selfLendingPod Optional self lending pod, use address(0) if not applicable
  70 |     |   function initializePosition(
  71 |     |     address _pod,
  72 |     |     address _recipient,
  73 |     |     address _selfLendingPod
  74 |     |   ) external override {
  75 |     |     _initializePosition(_pod, _recipient, _selfLendingPod);
  76 |     |   }
  77 |     | 
  78 |     |   /// @notice The ```addLeverage``` function adds leverage to a position (or creates a new one and adds leverage)
  79 |     |   /// @param _positionId The NFT ID of an existing position to add leverage to, or 0 if a new position should be created
  80 |     |   /// @param _pod The pod to leverage against for the position
  81 |     |   /// @param _podAmount Amount of pTKN to use to leverage against
  82 |     |   /// @param _pairedLpDesired Number of pairedLpTkn for the pod to use to add LP for the new position
  83 |     |   /// @param _pairedLpAmtMin Minimum number of pairedLpTkn for LP, slippage
  84 |     |   /// @param _overrideBorrowAmt Override amount to borrow from the lending pair, only matters if max LTV is >50% on the lending pair
  85 |     |   /// @param _slippage Slippage for the LP execution with 1000 precision (1000 == 100%)
  86 |     |   /// @param _deadline LP deadline for the UniswapV2 implementation
  87 |     |   /// @param _selfLendingPairPod Advanced implementation parameter that is a pod to wrap pairedLpTkn into before adding leverage, or address(0) if not applicable
  88 |     |   function addLeverage(
  89 |     |     uint256 _positionId,
  90 |     |     address _pod,
  91 |     |     uint256 _podAmount,
  92 |     |     uint256 _pairedLpDesired,
  93 |     |     uint256 _pairedLpAmtMin,
  94 |     |     uint256 _overrideBorrowAmt,
  95 |     |     uint256 _slippage,
  96 |     |     uint256 _deadline,
  97 |     |     address _selfLendingPairPod
  98 |     |   ) external override workflow(true) {
  99 |     |     address _sender = _msgSender();
 100 |     |     if (_positionId == 0) {
 101 |     |       _positionId = _initializePosition(_pod, _sender, _selfLendingPairPod);
 102 |     |     } else {
 103 |     |       address _owner = positionNFT.ownerOf(_positionId);
 104 |     |       address _approvedAddress = positionNFT.getApproved(_positionId);
 105 |     |       bool _isApprovedAll = positionNFT.isApprovedForAll(_owner, _sender);
 106 |     |       require(
 107 |     |         _owner == _sender || _approvedAddress == _sender || _isApprovedAll,
 108 |     |         'AUTH'
 109 |     |       );
 110 |     |       _pod = positionProps[_positionId].pod;
 111 |     |       require(_pod != address(0), 'PV');
 112 |     |     }
 113 |     |     require(flashSource[_pod] != address(0), 'FSV');
 114 |     |     require(lendingPairs[_pod] != address(0), 'LVP');
 115 |     | 
 116 |     |     IERC20(_pod).safeTransferFrom(_sender, address(this), _podAmount);
 117 |     | 
 118 |     |     // if additional fees required for flash source, handle that here
 119 |     |     _processExtraFlashLoanPayment(_pod, _sender);
 120 |     | 
 121 |     |     bytes memory _noop;
 122 |     |     bytes memory _leverageData = abi.encode(
 123 |     |       LeverageFlashProps({
 124 |     |         method: FlashCallbackMethod.ADD,
 125 |     |         positionId: _positionId,
 126 |     |         user: _sender,
 127 |     |         pod: _pod,
 128 |     |         podAmount: _podAmount,
 129 |     |         pairedLpDesired: _pairedLpDesired,
 130 |     |         pairedLpAmtMin: _pairedLpAmtMin,
 131 |     |         overrideBorrowAmt: _overrideBorrowAmt,
 132 |     |         slippage: _slippage,
 133 |     |         deadline: _deadline,
 134 |     |         selfLendingPairPod: _selfLendingPairPod
 135 |     |       }),
 136 |     |       _noop
 137 |     |     );
 138 |     |     IFlashLoanSource(flashSource[_pod]).flash(
 139 |     |       _getBorrowTknForPod(_pod),
 140 |     |       _pairedLpDesired,
 141 |     |       address(this),
 142 |     |       _leverageData
 143 |     |     );
 144 |     |   }
 145 |     | 
 146 |     |   /// @notice The ```removeLeverage``` function removes leverage from a position
 147 |     |   /// @param _positionId The NFT ID for the position
 148 |     |   /// @param _borrowAssetAmt Amount of borrowed assets to flash loan and use pay back and remove leverage
 149 |     |   /// @param _collateralAssetRemoveAmt Amount of collateral asset to remvoe from the position
 150 |     |   /// @param _podAmtMin Minimum amount of pTKN to receive on remove LP transaction (slippage)
 151 |     |   /// @param _pairedAssetAmtMin Minimum amount of pairedLpTkn to receive on remove LP transaction (slippage)
 152 |     |   /// @param _dexAdapter Adapter to use to optionally swap pod token into borrow token if not received enough to pay back flash loan
 153 |     |   /// @param _userProvidedDebtAmtMax Amt of borrow token a user will allow to transfer from their wallet to pay back flash loan
 154 |     |   function removeLeverage(
 155 |     |     uint256 _positionId,
 156 |     |     uint256 _borrowAssetAmt,
 157 |     |     uint256 _collateralAssetRemoveAmt,
 158 |     |     uint256 _podAmtMin,
 159 |     |     uint256 _pairedAssetAmtMin,
 160 |     |     address _dexAdapter,
 161 |     |     uint256 _userProvidedDebtAmtMax
 162 |     |   ) external override onlyPositionOwner(_positionId) workflow(true) {
 163 |     |     LeveragePositionProps memory _props = positionProps[_positionId];
 164 |     | 
 165 |     |     // if additional fees required for flash source, handle that here
 166 |     |     _processExtraFlashLoanPayment(_props.pod, _msgSender());
 167 |     | 
 168 |     |     address _borrowTkn = _getBorrowTknForPod(_props.pod);
 169 |     |     uint256 _borrowSharesToRepay = IFraxlendPair(lendingPairs[_props.pod])
 170 |     |       .totalBorrow()
 171 |     |       .toShares(_borrowAssetAmt, true);
 172 |     | 
 173 |     |     // needed to repay flash loaned asset in lending pair
 174 |     |     // before removing collateral and unwinding
 175 |     |     IERC20(_borrowTkn).safeIncreaseAllowance(
 176 |     |       lendingPairs[_props.pod],
 177 |     |       _borrowAssetAmt
 178 |     |     );
 179 |     | 
 180 |     |     LeverageFlashProps memory _position;
 181 |     |     _position.method = FlashCallbackMethod.REMOVE;
 182 |     |     _position.positionId = _positionId;
 183 |     |     _position.user = _msgSender();
 184 |     |     _position.pod = _props.pod;
 185 |     |     bytes memory _additionalInfo = abi.encode(
 186 |     |       _borrowSharesToRepay,
 187 |     |       _collateralAssetRemoveAmt,
 188 |     |       _podAmtMin,
 189 |     |       _pairedAssetAmtMin,
 190 |     |       _dexAdapter,
 191 |     |       _userProvidedDebtAmtMax
 192 |     |     );
 193 |     |     IFlashLoanSource(flashSource[_props.pod]).flash(
 194 |     |       _borrowTkn,
 195 |     |       _borrowAssetAmt,
 196 |     |       address(this),
 197 |     |       abi.encode(_position, _additionalInfo)
 198 |     |     );
 199 |     |   }
 200 |     | 
 201 |     |   /// @notice The ```withdrawAssets``` function allows a position owner to withdraw any assets in the position custodian
 202 |     |   /// @param _positionId The NFT ID for the position
 203 |     |   /// @param _token The token to withdraw assets from
 204 |     |   /// @param _recipient Where the received assets should go
 205 |     |   /// @param _amount How much to withdraw
 206 |     |   function withdrawAssets(
 207 |     |     uint256 _positionId,
 208 |     |     address _token,
 209 |     |     address _recipient,
 210 |     |     uint256 _amount
 211 |     |   ) external onlyPositionOwner(_positionId) {
 212 |     |     LeveragePositionCustodian(positionProps[_positionId].custodian).withdraw(
 213 |     |       _token,
 214 |     |       _recipient,
 215 |     |       _amount
 216 |     |     );
 217 |     |   }
 218 |     | 
 219 |     |   /// @notice The ```callback``` function can only be called within the addLeverage or removeLeverage workflow,
 220 |     |   /// @notice and is called by the flash source implementation used to borrow assets to initiate adding or removing lev
 221 |     |   /// @param _userData Config/info to unpack and extract individual pieces when adding/removing leverage, see addLeverage and removeLeverage
 222 |     |   function callback(bytes memory _userData) external override workflow(false) {
 223 |     |     IFlashLoanSource.FlashData memory _d = abi.decode(
 224 |     |       _userData,
 225 |     |       (IFlashLoanSource.FlashData)
 226 |     |     );
 227 |     |     (LeverageFlashProps memory _posProps, ) = abi.decode(
 228 |     |       _d.data,
 229 |     |       (LeverageFlashProps, bytes)
 230 |     |     );
 231 |     | 
 232 |     |     require(flashSource[_posProps.pod] == _msgSender(), 'AUTH');
 233 |     | 
 234 |     |     if (_posProps.method == FlashCallbackMethod.ADD) {
 235 |     |       uint256 _podRefundAmt = _addLeverage(_userData);
 236 |     |       if (_podRefundAmt > 0) {
 237 |     |         IERC20(_posProps.pod).safeTransfer(_posProps.user, _podRefundAmt);
 238 |     |       }
 239 |     |     } else if (_posProps.method == FlashCallbackMethod.REMOVE) {
 240 |     |       (uint256 _podAmtToUser, uint256 _pairedLpToUser) = _removeLeverage(
 241 |     |         _userData
 242 |     |       );
 243 |     |       if (_podAmtToUser > 0) {
 244 |     |         // if there's a close fee send returned pod tokens for fee to protocol
 245 |     |         if (closeFeePerc > 0) {
 246 |     |           uint256 _closeFeeAmt = (_podAmtToUser * closeFeePerc) / 1000;
 247 |     |           IERC20(_posProps.pod).safeTransfer(owner(), _closeFeeAmt);
 248 |     |           _podAmtToUser -= _closeFeeAmt;
 249 |     |         }
 250 |     |         IERC20(_posProps.pod).safeTransfer(_posProps.user, _podAmtToUser);
 251 |     |       }
 252 |     |       if (_pairedLpToUser > 0) {
 253 |     |         IERC20(IDecentralizedIndex(_posProps.pod).PAIRED_LP_TOKEN())
 254 |     |           .safeTransfer(_posProps.user, _pairedLpToUser);
 255 |     |       }
 256 |     |     } else {
 257 |     |       require(false, 'NI');
 258 |     |     }
 259 |     |   }
 260 |     | 
 261 |     |   function _initializePosition(
 262 |     |     address _pod,
 263 |     |     address _recipient,
 264 |     |     address _selfLendingPod
 265 |     |   ) internal returns (uint256 _positionId) {
 266 |     |     require(lendingPairs[_pod] != address(0), 'LVP');
 267 |     |     _positionId = positionNFT.mint(_recipient);
 268 |     |     LeveragePositionCustodian _custodian = new LeveragePositionCustodian();
 269 |     |     positionProps[_positionId] = LeveragePositionProps({
 270 |     |       pod: _pod,
 271 |     |       lendingPair: lendingPairs[_pod],
 272 |     |       custodian: address(_custodian),
 273 |     |       selfLendingPod: _selfLendingPod
 274 |     |     });
 275 |     |   }
 276 |     | 
 277 |     |   function _processExtraFlashLoanPayment(address _pod, address _user) internal {
 278 |     |     IFlashLoanSource _flashLoanSource = IFlashLoanSource(flashSource[_pod]);
 279 |     |     uint256 _flashPaymentAmount = _flashLoanSource.paymentAmount();
 280 |     |     if (_flashPaymentAmount > 0) {
 281 |     |       address _paymentAsset = _flashLoanSource.paymentToken();
 282 |     |       IERC20(_paymentAsset).safeTransferFrom(
 283 |     |         _user,
 284 |     |         address(this),
 285 |     |         _flashPaymentAmount
 286 |     |       );
 287 |     |       IERC20(_paymentAsset).safeIncreaseAllowance(
 288 |     |         flashSource[_pod],
 289 |     |         _flashPaymentAmount
 290 |     |       );
 291 |     |     }
 292 |     |   }
 293 |     | 
 294 |     |   function _addLeverage(
 295 |     |     bytes memory _data
 296 |     |   ) internal returns (uint256 _refundAmt) {
 297 |     |     IFlashLoanSource.FlashData memory _d = abi.decode(
 298 |     |       _data,
 299 |     |       (IFlashLoanSource.FlashData)
 300 |     |     );
 301 |     |     (LeverageFlashProps memory _props, ) = abi.decode(
 302 |     |       _d.data,
 303 |     |       (LeverageFlashProps, bytes)
 304 |     |     );
 305 |     |     (uint256 _aspTknCollateralBal, uint256 _podAmountUsed, ) = _lpAndStakeInPod(
 306 |     |       IDecentralizedIndex(_props.pod).lpStakingPool(),
 307 |     |       _d,
 308 |     |       _props
 309 |     |     );
 310 |     |     _refundAmt = _props.podAmount - _podAmountUsed;
 311 |     | 
 312 |     |     // if there's an open fee send aspTKN generated to protocol
 313 |     |     address _aspTkn = _getAspTkn(_props.pod);
 314 |     |     if (openFeePerc > 0) {
 315 |     |       uint256 _openFeeAmt = (_aspTknCollateralBal * openFeePerc) / 1000;
 316 |     |       IERC20(_aspTkn).safeTransfer(owner(), _openFeeAmt);
 317 |     |       _aspTknCollateralBal -= _openFeeAmt;
 318 |     |     }
 319 |     | 
 320 |     |     IERC20(_aspTkn).safeTransfer(
 321 |     |       positionProps[_props.positionId].custodian,
 322 |     |       _aspTknCollateralBal
 323 |     |     );
 324 |     |     LeveragePositionCustodian(positionProps[_props.positionId].custodian)
 325 |     |       .borrowAsset(
 326 |     |         lendingPairs[_props.pod],
 327 |     |         _props.overrideBorrowAmt > _props.pairedLpDesired
 328 |     |           ? _props.overrideBorrowAmt
 329 |     |           : _props.pairedLpDesired,
 330 |     |         _aspTknCollateralBal,
 331 |     |         address(this)
 332 |     |       );
 333 |     | 
 334 |     |     // pay back flash loan and send remaining to borrower
 335 |     |     uint256 _flashPaybackAmt = _d.amount + _d.fee;
 336 |     |     IERC20(_d.token).safeTransfer(
 337 |     |       IFlashLoanSource(flashSource[_props.pod]).source(),
 338 |     |       _flashPaybackAmt
 339 |     |     );
 340 |     |     uint256 _remaining = IERC20(_d.token).balanceOf(address(this));
 341 |     |     if (_remaining != 0) {
 342 |     |       IERC20(_d.token).safeTransfer(_props.user, _remaining);
 343 |     |     }
 344 |     |     emit AddLeverage(_props.positionId, _props.user);
 345 |     |   }
 346 |     | 
 347 |     |   function _removeLeverage(
 348 |     |     bytes memory _userData
 349 |     |   ) internal returns (uint256 _podAmtRemaining, uint256 _borrowAmtRemaining) {
 350 |     |     IFlashLoanSource.FlashData memory _d = abi.decode(
 351 |     |       _userData,
 352 |     |       (IFlashLoanSource.FlashData)
 353 |     |     );
 354 |     |     (LeverageFlashProps memory _props, bytes memory _additionalInfo) = abi
 355 |     |       .decode(_d.data, (LeverageFlashProps, bytes));
 356 |     |     (
 357 |     |       uint256 _borrowSharesToRepay,
 358 |     |       uint256 _collateralAssetRemoveAmt,
 359 |     |       uint256 _podAmtMin,
 360 |     |       uint256 _pairedAssetAmtMin,
 361 |     |       address _dexAdapter,
 362 |     |       uint256 _userProvidedDebtAmtMax
 363 |     |     ) = abi.decode(
 364 |     |         _additionalInfo,
 365 |     |         (uint256, uint256, uint256, uint256, address, uint256)
 366 |     |       );
 367 |     | 
 368 |     |     address _lendingPair = lendingPairs[_props.pod];
 369 |     | 
 370 |     |     // allowance increases for _borrowAssetAmt prior to flash loaning asset
 371 |     |     IFraxlendPair(_lendingPair).repayAsset(
 372 |     |       _borrowSharesToRepay,
 373 |     |       positionProps[_props.positionId].custodian
 374 |     |     );
 375 |     |     LeveragePositionCustodian(positionProps[_props.positionId].custodian)
 376 |     |       .removeCollateral(_lendingPair, _collateralAssetRemoveAmt, address(this));
 377 |     |     (uint256 _podAmtReceived, uint256 _pairedAmtReceived) = _unstakeAndRemoveLP(
 378 |     |       _props.pod,
 379 |     |       _collateralAssetRemoveAmt,
 380 |     |       _podAmtMin,
 381 |     |       _pairedAssetAmtMin
 382 |     |     );
 383 |     |     _podAmtRemaining = _podAmtReceived;
 384 |     | 
 385 |     |     // redeem borrow asset from lending pair for self lending positions
 386 |     |     if (_isSelfLendingAndOrPodded(_props.pod)) {
 387 |     |       // unwrap from self lending pod for lending pair asset
 388 |     |       if (positionProps[_props.positionId].selfLendingPod != address(0)) {
 389 |     |         _pairedAmtReceived = _debondFromSelfLendingPod(
 390 |     |           positionProps[_props.positionId].selfLendingPod,
 391 |     |           _pairedAmtReceived
 392 |     |         );
 393 |     |       }
 394 |     | 
 395 |     |       IFraxlendPair(_lendingPair).redeem(
 396 |     |         _pairedAmtReceived,
 397 |     |         address(this),
 398 |     |         address(this)
 399 |     |       );
 400 |     |       _pairedAmtReceived = IERC20(_d.token).balanceOf(address(this));
 401 |     |     }
 402 |     | 
 403 |     |     // pay back flash loan and send remaining to borrower
 404 |     |     uint256 _repayAmount = _d.amount + _d.fee;
 405 |     |     if (_pairedAmtReceived < _repayAmount) {
 406 |     |       _podAmtRemaining = _acquireBorrowTokenForRepayment(
 407 |     |         _props.pod,
 408 |     |         _props.user,
 409 |     |         _d.token,
 410 |     |         _dexAdapter,
 411 |     |         _repayAmount,
 412 |     |         _pairedAmtReceived,
 413 |     |         _podAmtReceived,
 414 |     |         _userProvidedDebtAmtMax
 415 |     |       );
 416 |     |     }
 417 |     |     IERC20(_d.token).safeTransfer(
 418 |     |       IFlashLoanSource(flashSource[_props.pod]).source(),
 419 |     |       _repayAmount
 420 |     |     );
 421 |     |     _borrowAmtRemaining = _pairedAmtReceived > _repayAmount
 422 |     |       ? _pairedAmtReceived - _repayAmount
 423 |     |       : 0;
 424 |     |   }
 425 |     | 
 426 |     |   function _debondFromSelfLendingPod(
 427 |     |     address _pod,
 428 |     |     uint256 _amount
 429 |     |   ) internal returns (uint256 _amtOut) {
 430 |     |     IDecentralizedIndex.IndexAssetInfo[]
 431 |     |       memory _podAssets = IDecentralizedIndex(_pod).getAllAssets();
 432 |     |     address[] memory _tokens = new address[](1);
 433 |     |     uint8[] memory _percentages = new uint8[](1);
 434 |     |     _tokens[0] = _podAssets[0].token;
 435 |     |     _percentages[0] = 100;
 436 |     |     IDecentralizedIndex(_pod).debond(_amount, _tokens, _percentages);
 437 |     |     _amtOut = IERC20(_tokens[0]).balanceOf(address(this));
 438 |     |   }
 439 |     | 
 440 |     |   function _acquireBorrowTokenForRepayment(
 441 |     |     address _pod,
 442 |     |     address _user,
 443 |     |     address _borrowToken,
 444 |     |     address _dexAdapter,
 445 |     |     uint256 _repayAmount,
 446 |     |     uint256 _pairedAmtReceived,
 447 |     |     uint256 _podAmtReceived,
 448 |     |     uint256 _userProvidedDebtAmtMax
 449 |     |   ) internal returns (uint256 _podAmtRemaining) {
 450 |     |     _podAmtRemaining = _podAmtReceived;
 451 |     |     uint256 _borrowNeeded = _repayAmount - _pairedAmtReceived;
 452 |     |     uint256 _borrowAmtNeededToSwap = _borrowNeeded;
 453 |     |     if (_userProvidedDebtAmtMax > 0) {
 454 |     |       uint256 _borrowAmtFromUser = _userProvidedDebtAmtMax >= _borrowNeeded
 455 |     |         ? _borrowNeeded
 456 |     |         : _userProvidedDebtAmtMax;
 457 |     |       _borrowAmtNeededToSwap -= _borrowAmtFromUser;
 458 |     |       IERC20(_borrowToken).safeTransferFrom(
 459 |     |         _user,
 460 |     |         address(this),
 461 |     |         _borrowAmtFromUser
 462 |     |       );
 463 |     |     }
 464 |     |     if (_borrowAmtNeededToSwap > 0) {
 465 |     |       // sell pod token into LP for enough borrow token to get enough to repay
 466 |     |       _podAmtRemaining = _swapPodForBorrowToken(
 467 |     |         IDexAdapter(_dexAdapter),
 468 |     |         _pod,
 469 |     |         _borrowToken,
 470 |     |         _podAmtReceived,
 471 |     |         _borrowAmtNeededToSwap
 472 |     |       );
 473 |     |     }
 474 |     |   }
 475 |     | 
 476 |     |   function _swapPodForBorrowToken(
 477 |     |     IDexAdapter _dexAdapter,
 478 |     |     address _sourceToken,
 479 |     |     address _targetToken,
 480 |     |     uint256 _sourceAmt,
 481 |     |     uint256 _targetNeededAmt
 482 |     |   ) internal returns (uint256 _podRemainingAmt) {
 483 |     |     uint256 _balBefore = IERC20(_sourceToken).balanceOf(address(this));
 484 |     |     IERC20(_sourceToken).safeIncreaseAllowance(
 485 |     |       address(_dexAdapter),
 486 |     |       _sourceAmt
 487 |     |     );
 488 |     |     _dexAdapter.swapV2SingleExactOut(
 489 |     |       _sourceToken,
 490 |     |       _targetToken,
 491 |     |       _sourceAmt,
 492 |     |       _targetNeededAmt,
 493 |     |       address(this)
 494 |     |     );
 495 |     |     _podRemainingAmt =
 496 |     |       _sourceAmt -
 497 |     |       (_balBefore - IERC20(_sourceToken).balanceOf(address(this)));
 498 |     |   }
 499 |     | 
 500 |     |   function _lpAndStakeInPod(
 501 |     |     address _spTKN,
 502 |     |     IFlashLoanSource.FlashData memory _d,
 503 |     |     LeverageFlashProps memory _props
 504 |     |   )
 505 |     |     internal
 506 |     |     returns (uint256 _newAspTkns, uint256 _podAmountUsed, uint256 _pairedLpUsed)
 507 |     |   {
 508 |     |     (address _pairedLpForPod, uint256 _pairedLpAmt) = _getPairedTknAndAmt(
 509 |     |       _props.pod,
 510 |     |       _d.token,
 511 |     |       _d.amount,
 512 |     |       _props.selfLendingPairPod
 513 |     |     );
 514 |     |     uint256 _podBalBefore = IERC20(_props.pod).balanceOf(address(this));
 515 |     |     uint256 _pairedLpBalBefore = IERC20(_pairedLpForPod).balanceOf(
 516 |     |       address(this)
 517 |     |     );
 518 |     |     IERC20(_props.pod).safeIncreaseAllowance(
 519 |     |       address(indexUtils),
 520 |     |       _props.podAmount
 521 |     |     );
 522 |     |     IERC20(_pairedLpForPod).safeIncreaseAllowance(
 523 |     |       address(indexUtils),
 524 |     |       _pairedLpAmt
 525 |     |     );
 526 |     |     indexUtils.addLPAndStake(
 527 |     |       IDecentralizedIndex(_props.pod),
 528 |     |       _props.podAmount,
 529 |     |       _pairedLpForPod,
 530 |     |       _pairedLpAmt,
 531 |     |       _props.pairedLpAmtMin,
 532 |     |       _props.slippage,
 533 |     |       _props.deadline
 534 |     |     );
 535 |     | 
 536 |     |     address _aspTkn = _getAspTkn(_props.pod);
 537 |     |     uint256 _stakingBal = IERC20(_spTKN).balanceOf(address(this));
 538 |     |     IERC20(_spTKN).safeIncreaseAllowance(_aspTkn, _stakingBal);
 539 |     |     _newAspTkns = IERC4626(_aspTkn).deposit(_stakingBal, address(this));
 540 |     |     _podAmountUsed =
 541 |     |       _podBalBefore -
 542 |     |       IERC20(_props.pod).balanceOf(address(this));
 543 |     |     _pairedLpUsed =
 544 |     |       _pairedLpBalBefore -
 545 |     |       IERC20(_pairedLpForPod).balanceOf(address(this));
 546 |     | 
 547 |     |     // for self lending pods redeem any extra paired LP asset back into main asset
 548 |     |     uint256 _pairedLeftover = _pairedLpBalBefore - _pairedLpUsed;
 549 |     |     if (_isSelfLendingAndOrPodded(_props.pod) && _pairedLeftover > 0) {
 550 |     |       if (_props.selfLendingPairPod != address(0)) {
 551 |     |         address[] memory _noop1 = new address[](0);
 552 |     |         uint8[] memory _noop2 = new uint8[](0);
 553 |     |         IDecentralizedIndex(_props.selfLendingPairPod).debond(
 554 |     |           _pairedLeftover,
 555 |     |           _noop1,
 556 |     |           _noop2
 557 |     |         );
 558 |     |         _pairedLeftover = IERC20(lendingPairs[_props.pod]).balanceOf(
 559 |     |           address(this)
 560 |     |         );
 561 |     |       }
 562 |     |       IFraxlendPair(lendingPairs[_props.pod]).redeem(
 563 |     |         _pairedLeftover,
 564 |     |         address(this),
 565 |     |         address(this)
 566 |     |       );
 567 |     |     }
 568 |     |   }
 569 |     | 
 570 |     |   function _getPairedTknAndAmt(
 571 |     |     address _pod,
 572 |     |     address _borrowedTkn,
 573 |     |     uint256 _borrowedAmt,
 574 |     |     address _selfLendingPairPod
 575 |     |   ) internal returns (address _finalPairedTkn, uint256 _finalPairedAmt) {
 576 |     |     _finalPairedTkn = _borrowedTkn;
 577 |     |     _finalPairedAmt = _borrowedAmt;
 578 |     |     if (_isSelfLendingAndOrPodded(_pod)) {
 579 |     |       _finalPairedTkn = lendingPairs[_pod];
 580 |     |       IERC20(_borrowedTkn).safeIncreaseAllowance(
 581 |     |         lendingPairs[_pod],
 582 |     |         _finalPairedAmt
 583 |     |       );
 584 |     |       _finalPairedAmt = IFraxlendPair(lendingPairs[_pod]).deposit(
 585 |     |         _finalPairedAmt,
 586 |     |         address(this)
 587 |     |       );
 588 |     | 
 589 |     |       // self lending+podded
 590 |     |       if (_selfLendingPairPod != address(0)) {
 591 |     |         _finalPairedTkn = _selfLendingPairPod;
 592 |     |         IERC20(lendingPairs[_pod]).safeIncreaseAllowance(
 593 |     |           _selfLendingPairPod,
 594 |     |           _finalPairedAmt
 595 |     |         );
 596 |     |         IDecentralizedIndex(_selfLendingPairPod).bond(
 597 |     |           lendingPairs[_pod],
 598 |     |           _finalPairedAmt,
 599 |     |           0
 600 |     |         );
 601 |     |         _finalPairedAmt = IERC20(_selfLendingPairPod).balanceOf(address(this));
 602 |     |       }
 603 |     |     }
 604 |     |   }
 605 |     | 
 606 |     |   function _unstakeAndRemoveLP(
 607 |     |     address _pod,
 608 |     |     uint256 _collateralAssetRemoveAmt,
 609 |     |     uint256 _podAmtMin,
 610 |     |     uint256 _pairedAssetAmtMin
 611 |     |   ) internal returns (uint256 _podAmtReceived, uint256 _pairedAmtReceived) {
 612 |     |     address _spTKN = IDecentralizedIndex(_pod).lpStakingPool();
 613 |     |     address _pairedLpToken = IDecentralizedIndex(_pod).PAIRED_LP_TOKEN();
 614 |     | 
 615 |     |     uint256 _podAmtBefore = IERC20(_pod).balanceOf(address(this));
 616 |     |     uint256 _pairedTokenAmtBefore = IERC20(_pairedLpToken).balanceOf(
 617 |     |       address(this)
 618 |     |     );
 619 |     | 
 620 |     |     uint256 _spTKNAmtReceived = IERC4626(_getAspTkn(_pod)).redeem(
 621 |     |       _collateralAssetRemoveAmt,
 622 |     |       address(this),
 623 |     |       address(this)
 624 |     |     );
 625 |     |     IERC20(_spTKN).safeIncreaseAllowance(
 626 |     |       address(indexUtils),
 627 |     |       _spTKNAmtReceived
 628 |     |     );
 629 |     |     indexUtils.unstakeAndRemoveLP(
 630 |     |       IDecentralizedIndex(_pod),
 631 |     |       _spTKNAmtReceived,
 632 |     |       _podAmtMin,
 633 |     |       _pairedAssetAmtMin,
 634 |     |       block.timestamp
 635 |     |     );
 636 |     |     _podAmtReceived = IERC20(_pod).balanceOf(address(this)) - _podAmtBefore;
 637 |     |     _pairedAmtReceived =
 638 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) -
 639 |     |       _pairedTokenAmtBefore;
 640 |     |   }
 641 |     | 
 642 |     |   function _isSelfLendingAndOrPodded(
 643 |     |     address _pod
 644 |     |   ) internal view returns (bool) {
 645 |     |     return
 646 |     |       IDecentralizedIndex(_pod).PAIRED_LP_TOKEN() !=
 647 |     |       IFraxlendPair(lendingPairs[_pod]).asset();
 648 |     |   }
 649 |     | 
 650 |     |   function _getBorrowTknForPod(address _pod) internal view returns (address) {
 651 |     |     return
 652 |     |       _isSelfLendingAndOrPodded(_pod)
 653 |     |         ? IFraxlendPair(lendingPairs[_pod]).asset()
 654 |     |         : IDecentralizedIndex(_pod).PAIRED_LP_TOKEN();
 655 |     |   }
 656 |     | 
 657 |     |   function _getAspTkn(address _pod) internal view returns (address) {
 658 |     |     return IFraxlendPair(lendingPairs[_pod]).collateralContract();
 659 |     |   }
 660 |     | 
 661 |     |   function setIndexUtils(IIndexUtils_LEGACY _utils) external onlyOwner {
 662 |     |     indexUtils = _utils;
 663 |     |   }
 664 |     | 
 665 |     |   function setOpenFeePerc(uint16 _newFee) external onlyOwner {
 666 |     |     require(_newFee <= 250, 'MAX');
 667 |     |     openFeePerc = _newFee;
 668 |     |   }
 669 |     | 
 670 |     |   function setCloseFeePerc(uint16 _newFee) external onlyOwner {
 671 |     |     require(_newFee <= 250, 'MAX');
 672 |     |     closeFeePerc = _newFee;
 673 |     |   }
 674 |     | 
 675 |     |   function rescueETH() external onlyOwner {
 676 |     |     (bool _s, ) = payable(_msgSender()).call{ value: address(this).balance }(
 677 |     |       ''
 678 |     |     );
 679 |     |     require(_s, 'S');
 680 |     |   }
 681 |     | 
 682 |     |   function rescueTokens(IERC20 _token) external onlyOwner {
 683 |     |     _token.safeTransfer(_msgSender(), _token.balanceOf(address(this)));
 684 |     |   }
 685 |     | 
 686 |     |   receive() external payable {}
 687 |     | }
 688 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeverageManagerAccessControl.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
  5 |     | import '../interfaces/IFlashLoanSource.sol';
  6 |     | import '../interfaces/IFraxlendPair.sol';
  7 |     | 
  8 |     | contract LeverageManagerAccessControl is Ownable {
  9 |     |   // pod => pair
 10 |     |   mapping(address => address) public lendingPairs;
 11 |     |   // pod => flash source
 12 |     |   mapping(address => address) public flashSource;
 13 |     | 
 14 |     |   function setLendingPair(address _pod, address _pair) external onlyOwner {
 15 |     |     if (_pair != address(0)) {
 16 |     |       require(IFraxlendPair(_pair).collateralContract() != address(0), 'AV');
 17 |     |     }
 18 |     |     lendingPairs[_pod] = _pair;
 19 |     |   }
 20 |     | 
 21 |     |   function setFlashSource(
 22 |     |     address _pod,
 23 |     |     address _flashSource
 24 |     |   ) external onlyOwner {
 25 |     |     if (_flashSource != address(0)) {
 26 |     |       require(IFlashLoanSource(_flashSource).source() != address(0), 'AFS');
 27 |     |     }
 28 |     |     flashSource[_pod] = _flashSource;
 29 |     |   }
 30 |     | }
 31 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeveragePositionCustodian.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
  5 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
  6 |     | import '@openzeppelin/contracts/access/Ownable.sol';
  7 |     | import '@openzeppelin/contracts/utils/Context.sol';
  8 |     | import '../interfaces/IFraxlendPair.sol';
  9 |     | 
 10 |     | contract LeveragePositionCustodian is Context, Ownable {
 11 |     |   using SafeERC20 for IERC20;
 12 |     | 
 13 |     |   function borrowAsset(
 14 |     |     address _pair,
 15 |     |     uint256 _borrowAmount,
 16 |     |     uint256 _collateralAmount,
 17 |     |     address _receiver
 18 |     |   ) external onlyOwner {
 19 |     |     IERC20(IFraxlendPair(_pair).collateralContract()).safeIncreaseAllowance(
 20 |     |       _pair,
 21 |     |       _collateralAmount
 22 |     |     );
 23 |     |     IFraxlendPair(_pair).borrowAsset(
 24 |     |       _borrowAmount,
 25 |     |       _collateralAmount,
 26 |     |       _receiver
 27 |     |     );
 28 |     |   }
 29 |     | 
 30 |     |   function removeCollateral(
 31 |     |     address _pair,
 32 |     |     uint256 _collateralAmount,
 33 |     |     address _receiver
 34 |     |   ) external onlyOwner {
 35 |     |     IFraxlendPair(_pair).removeCollateral(_collateralAmount, _receiver);
 36 |     |   }
 37 |     | 
 38 |     |   function withdraw(
 39 |     |     address _token,
 40 |     |     address _recipient,
 41 |     |     uint256 _amount
 42 |     |   ) external onlyOwner {
 43 |     |     _amount = _amount == 0 ? IERC20(_token).balanceOf(address(this)) : _amount;
 44 |     |     IERC20(_token).safeTransfer(_recipient, _amount);
 45 |     |   }
 46 |     | }
 47 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeveragePositions.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/utils/Context.sol';
  5 |     | import 'erc721a/contracts/ERC721A.sol';
  6 |     | 
  7 |     | contract LeveragePositions is Context, ERC721A {
  8 |     |   address _controller;
  9 |     | 
 10 |     |   constructor(
 11 |     |     string memory _name,
 12 |     |     string memory _symbol
 13 |     |   ) ERC721A(_name, _symbol) {
 14 |     |     _controller = _msgSender();
 15 |     |   }
 16 |     | 
 17 |     |   function mint(address _receiver) external returns (uint256 _tokenId) {
 18 |     |     require(_msgSender() == _controller, 'AUTH');
 19 |     |     _tokenId = _nextTokenId();
 20 |     |     _mint(_receiver, 1);
 21 |     |   }
 22 |     | 
 23 |     |   function _startTokenId() internal pure override returns (uint256) {
 24 |     |     return 1;
 25 |     |   }
 26 |     | }
 27 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/ChainlinkSinglePriceOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
  5 |     | import '@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol';
  6 |     | import '../interfaces/IMinimalSinglePriceOracle.sol';
  7 |     | 
  8 |     | contract ChainlinkSinglePriceOracle is IMinimalSinglePriceOracle, Ownable {
  9 |     |   event SetMaxOracleDelay(uint256 _oldDelay, uint256 _newDelay);
 10 |     | 
 11 |     |   uint256 public maxOracleDelay = 1 days;
 12 |     | 
 13 |     |   /// @notice The ```getPriceUSD18``` function gets the QUOTE/BASE price (mathematically BASE per QUOTE)
 14 |     |   /// @param _priceFeedQuote Chainlink price feed representing the quote token, probably quote/USD (mathematically USD per quote)
 15 |     |   /// @param _priceFeedBase Chainlink price feed representing the base token, probably quote/USD (mathematically USD per base)
 16 |     |   /// @return _isBadData Whether the oracle is returning what we should assume is bad data
 17 |     |   /// @return _price18 Number representing the price with 1e18 precision
 18 |     |   function getPriceUSD18(
 19 |     |     address _priceFeedQuote,
 20 |     |     address _priceFeedBase,
 21 |     |     address,
 22 |     |     uint256
 23 |     |   ) external view virtual override returns (bool _isBadData, uint256 _price18) {
 24 |     |     uint256 _quoteUpdatedAt;
 25 |     |     uint256 _isBadTime = block.timestamp - maxOracleDelay;
 26 |     |     (_price18, _quoteUpdatedAt) = _getChainlinkPriceFeedPrice18(
 27 |     |       _priceFeedQuote
 28 |     |     );
 29 |     |     _isBadData = _quoteUpdatedAt < _isBadTime;
 30 |     |     if (_priceFeedBase != address(0)) {
 31 |     |       (
 32 |     |         uint256 _basePrice18,
 33 |     |         uint256 _baseUpdatedAt
 34 |     |       ) = _getChainlinkPriceFeedPrice18(_priceFeedBase);
 35 |     |       _price18 = (10 ** 18 * _price18) / _basePrice18;
 36 |     |       _isBadData = _isBadData || _baseUpdatedAt < _isBadTime;
 37 |     |     }
 38 |     |   }
 39 |     | 
 40 |     |   function _getChainlinkPriceFeedPrice18(
 41 |     |     address _priceFeed
 42 |     |   ) internal view returns (uint256 _price18, uint256 _updatedAt) {
 43 |     |     uint8 _decimals = AggregatorV3Interface(_priceFeed).decimals();
 44 |     |     (, int256 _price, , uint256 _lastUpdated, ) = AggregatorV3Interface(
 45 |     |       _priceFeed
 46 |     |     ).latestRoundData();
 47 |     |     _price18 = uint256(_price) * (10 ** 18 / 10 ** _decimals);
 48 |     |     _updatedAt = _lastUpdated;
 49 |     |   }
 50 |     | 
 51 |     |   function setMaxOracleDelay(uint256 _newDelaySeconds) external onlyOwner {
 52 |     |     uint256 _current = maxOracleDelay;
 53 |     |     maxOracleDelay = _newDelaySeconds;
 54 |     |     emit SetMaxOracleDelay(_current, _newDelaySeconds);
 55 |     |   }
 56 |     | }
 57 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/UniswapV3SinglePriceOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
  5 |     | import '../libraries/FullMath.sol';
  6 |     | import '../libraries/TickMath.sol';
  7 |     | import '../interfaces/IERC20Metadata.sol';
  8 |     | import '../interfaces/IMinimalSinglePriceOracle.sol';
  9 |     | import '../interfaces/IUniswapV3Pool.sol';
 10 |     | import './ChainlinkSinglePriceOracle.sol';
 11 |     | 
 12 |     | contract UniswapV3SinglePriceOracle is ChainlinkSinglePriceOracle {
 13 |     |   function getPriceUSD18(
 14 |     |     address _clBaseConversionPoolPriceFeed,
 15 |     |     address _quoteToken,
 16 |     |     address _quoteV3Pool,
 17 |     |     uint256 _twapInterval
 18 |     |   ) external view virtual override returns (bool _isBadData, uint256 _price18) {
 19 |     |     uint256 _quotePriceX96 = _getPoolPriceTokenDenomenator(
 20 |     |       _quoteToken,
 21 |     |       _quoteV3Pool,
 22 |     |       uint32(_twapInterval)
 23 |     |     );
 24 |     |     // default base price to 1, which just means return only quote pool price without any base conversion
 25 |     |     uint256 _basePrice18 = 10 ** 18;
 26 |     |     uint256 _updatedAt = block.timestamp;
 27 |     |     if (_clBaseConversionPoolPriceFeed != address(0)) {
 28 |     |       (_basePrice18, _updatedAt) = _getChainlinkPriceFeedPrice18(
 29 |     |         _clBaseConversionPoolPriceFeed
 30 |     |       );
 31 |     |     }
 32 |     |     _price18 = (_quotePriceX96 * _basePrice18) / FixedPoint96.Q96;
 33 |     |     _isBadData = _updatedAt < block.timestamp - maxOracleDelay;
 34 |     |   }
 35 |     | 
 36 |     |   function _getPoolPriceTokenDenomenator(
 37 |     |     address _priceToken,
 38 |     |     address _pricePool,
 39 |     |     uint32 _interval
 40 |     |   ) internal view returns (uint256) {
 41 |     |     address _t0 = IUniswapV3Pool(_pricePool).token0();
 42 |     |     return
 43 |     |       _normalizedPriceX96(
 44 |     |         IUniswapV3Pool(_pricePool),
 45 |     |         _interval,
 46 |     |         _t0 == _priceToken ? IUniswapV3Pool(_pricePool).token1() : _t0
 47 |     |       );
 48 |     |   }
 49 |     | 
 50 |     |   function _getSqrtPriceX96FromPool(
 51 |     |     IUniswapV3Pool _pool,
 52 |     |     uint32 _interval
 53 |     |   ) public view returns (uint160 _sqrtPriceX96) {
 54 |     |     if (_interval == 0) {
 55 |     |       (_sqrtPriceX96, , , , , , ) = _pool.slot0();
 56 |     |     } else {
 57 |     |       uint32[] memory secondsAgo = new uint32[](2);
 58 |     |       secondsAgo[0] = _interval;
 59 |     |       secondsAgo[1] = 0; // to (now)
 60 |     |       (int56[] memory tickCumulatives, ) = _pool.observe(secondsAgo);
 61 |     |       _sqrtPriceX96 = TickMath.getSqrtRatioAtTick(
 62 |     |         int24((tickCumulatives[1] - tickCumulatives[0]) / int32(_interval))
 63 |     |       );
 64 |     |     }
 65 |     |   }
 66 |     | 
 67 |     |   function _normalizedPriceX96(
 68 |     |     IUniswapV3Pool _pool,
 69 |     |     uint32 _twapInterval,
 70 |     |     address _numeratorToken
 71 |     |   ) internal view returns (uint256) {
 72 |     |     address _token1 = _pool.token1();
 73 |     |     uint8 _decimals0 = IERC20Metadata(_pool.token0()).decimals();
 74 |     |     uint8 _decimals1 = IERC20Metadata(_token1).decimals();
 75 |     |     uint160 _sqrtPriceX96 = _getSqrtPriceX96FromPool(_pool, _twapInterval);
 76 |     |     uint256 _priceX96 = FullMath.mulDiv(
 77 |     |       _sqrtPriceX96,
 78 |     |       _sqrtPriceX96,
 79 |     |       FixedPoint96.Q96
 80 |     |     );
 81 |     |     uint256 _correctedPriceX96 = _token1 == _numeratorToken
 82 |     |       ? _priceX96
 83 |     |       : FixedPoint96.Q96 ** 2 / _priceX96;
 84 |     |     return
 85 |     |       _token1 == _numeratorToken
 86 |     |         ? (_correctedPriceX96 * 10 ** _decimals0) / 10 ** _decimals1
 87 |     |         : (_correctedPriceX96 * 10 ** _decimals1) / 10 ** _decimals0;
 88 |     |   }
 89 |     | }
 90 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/V2ReservesUniswap.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '../interfaces/IUniswapV2Pair.sol';
  5 |     | import '../interfaces/IV2Reserves.sol';
  6 |     | 
  7 |     | contract V2ReservesUniswap is IV2Reserves {
  8 |     |   function getReserves(
  9 |     |     address _pair
 10 |     |   )
 11 |     |     external
 12 |     |     view
 13 |     |     virtual
 14 |     |     override
 15 |     |     returns (uint112 _reserve0, uint112 _reserve1)
 16 |     |   {
 17 |     |     (_reserve0, _reserve1, ) = IUniswapV2Pair(_pair).getReserves();
 18 |     |   }
 19 |     | }
 20 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/aspTKNMinimalOracle.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
  5 |     | import './spTKNMinimalOracle.sol';
  6 |     | 
  7 |     | contract aspTKNMinimalOracle is spTKNMinimalOracle {
  8 |     |   address public immutable ASP_TKN; // QUOTE_TOKEN
  9 |     | 
 10 |     |   constructor(
 11 |     |     address _aspTKN,
 12 |     |     address _baseToken,
 13 |     |     bool _baseIsPod,
 14 |     |     address _spTKN,
 15 |     |     address _underlyingClPool,
 16 |     |     address _baseConversionChainlinkFeed,
 17 |     |     address _baseConversionClPool,
 18 |     |     address _clBaseFeed,
 19 |     |     address _clQuoteFeed,
 20 |     |     address _clSinglePriceOracle,
 21 |     |     address _uniswapSinglePriceOracle,
 22 |     |     address _v2Reserves
 23 |     |   )
 24 |     |     spTKNMinimalOracle(
 25 |     |       _baseToken,
 26 |     |       _baseIsPod,
 27 |     |       _spTKN,
 28 |     |       _underlyingClPool,
 29 |     |       _baseConversionChainlinkFeed,
 30 |     |       _baseConversionClPool,
 31 |     |       _clBaseFeed,
 32 |     |       _clQuoteFeed,
 33 |     |       _clSinglePriceOracle,
 34 |     |       _uniswapSinglePriceOracle,
 35 |     |       _v2Reserves
 36 |     |     )
 37 |     |   {
 38 |     |     ASP_TKN = _aspTKN;
 39 |     |   }
 40 |     | 
 41 |     |   function getPrices()
 42 |     |     public
 43 |     |     view
 44 |     |     virtual
 45 |     |     override
 46 |     |     returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)
 47 |     |   {
 48 |     |     uint256 _assetFactor = 10 ** 18;
 49 |     |     uint256 _aspTknPerSpTkn = IERC4626(ASP_TKN).convertToShares(_assetFactor);
 50 |     |     (_isBadData, _priceLow, _priceHigh) = super.getPrices();
 51 |     |     _priceLow = (_priceLow * _assetFactor) / _aspTknPerSpTkn;
 52 |     |     _priceHigh = (_priceHigh * _assetFactor) / _aspTknPerSpTkn;
 53 |     |   }
 54 |     | }
 55 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/spTKNMinimalOracle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';
   6 |     | import '../interfaces/IDecentralizedIndex.sol';
   7 |     | import '../interfaces/IStakingPoolToken.sol';
   8 |     | import '../interfaces/IUniswapV2Pair.sol';
   9 |     | import '../interfaces/IMinimalOracle.sol';
  10 |     | import '../interfaces/IMinimalSinglePriceOracle.sol';
  11 |     | import '../interfaces/IV2Reserves.sol';
  12 |     | 
  13 |     | contract spTKNMinimalOracle is IMinimalOracle, Ownable {
  14 |     |   /// @dev The base token we will price against in the oracle. Will be either pairedLpAsset
  15 |     |   /// @dev or the borrow token in a lending pair
  16 |     |   address public immutable BASE_TOKEN;
  17 |     |   bool public immutable BASE_IS_POD;
  18 |     | 
  19 |     |   /// @dev The pod stake token and oracle quote token that custodies UniV2 LP tokens
  20 |     |   address public immutable SP_TKN; // QUOTE_TOKEN
  21 |     |   address public immutable POD;
  22 |     | 
  23 |     |   /// @dev The concentrated liquidity UniV3 pool where we get the TWAP to price the underlying TKN
  24 |     |   /// @dev of the pod represented through SP_TKN and then convert it to the spTKN price
  25 |     |   address public immutable UNDERLYING_TKN_CL_POOL;
  26 |     |   address public immutable UNDERLYING_TKN;
  27 |     | 
  28 |     |   /// @dev The Chainlink price feed we can use to convert the price we fetch through UNDERLYING_TKN_CL_POOL
  29 |     |   /// @dev into a BASE_TOKEN normalized price,
  30 |     |   /// @dev NOTE: only needed if the paired token of the CL_POOL is not BASE_TOKEN
  31 |     |   address public immutable BASE_CONVERSION_CHAINLINK_FEED;
  32 |     |   address public immutable BASE_CONVERSION_CL_POOL;
  33 |     | 
  34 |     |   /// @dev Chainlink config to fetch a 2nd price for the oracle
  35 |     |   /// @dev The assumption would be that the paired asset of both oracles are the same
  36 |     |   /// @dev For example, if base=ETH, quote=BTC, the feeds we could use would be ETH/USD & BTC/USD
  37 |     |   address public immutable CHAINLINK_BASE_PRICE_FEED;
  38 |     |   address public immutable CHAINLINK_QUOTE_PRICE_FEED;
  39 |     | 
  40 |     |   /// @dev Single price oracle helpers to get already formatted prices that are easy to convert/use
  41 |     |   address public immutable CHAINLINK_SINGLE_PRICE_ORACLE;
  42 |     |   address public immutable UNISWAP_V3_SINGLE_PRICE_ORACLE;
  43 |     | 
  44 |     |   /// @dev Different networks will use different forked implementations of UniswapV2, so
  45 |     |   /// @dev this allows us to define a uniform interface to fetch the reserves of each asset in a pair
  46 |     |   IV2Reserves public immutable V2_RESERVES;
  47 |     | 
  48 |     |   uint32 twapInterval = 10 minutes;
  49 |     | 
  50 |     |   constructor(
  51 |     |     address _baseToken,
  52 |     |     bool _baseIsPod,
  53 |     |     address _spTKN,
  54 |     |     address _underlyingClPool,
  55 |     |     address _baseConversionChainlinkFeed,
  56 |     |     address _baseConversionClPool,
  57 |     |     address _clBaseFeed,
  58 |     |     address _clQuoteFeed,
  59 |     |     address _clSinglePriceOracle,
  60 |     |     address _uniswapSinglePriceOracle,
  61 |     |     address _v2Reserves
  62 |     |   ) {
  63 |     |     // only one (or neither) of the base conversion config should be populated
  64 |     |     require(
  65 |     |       _baseConversionChainlinkFeed == address(0) ||
  66 |     |         _baseConversionClPool == address(0),
  67 |     |       'CONV'
  68 |     |     );
  69 |     | 
  70 |     |     BASE_TOKEN = _baseToken;
  71 |     |     BASE_IS_POD = _baseIsPod;
  72 |     |     SP_TKN = _spTKN;
  73 |     |     UNDERLYING_TKN_CL_POOL = _underlyingClPool;
  74 |     |     BASE_CONVERSION_CHAINLINK_FEED = _baseConversionChainlinkFeed;
  75 |     |     BASE_CONVERSION_CL_POOL = _baseConversionClPool;
  76 |     |     CHAINLINK_BASE_PRICE_FEED = _clBaseFeed;
  77 |     |     CHAINLINK_QUOTE_PRICE_FEED = _clQuoteFeed;
  78 |     |     CHAINLINK_SINGLE_PRICE_ORACLE = _clSinglePriceOracle;
  79 |     |     UNISWAP_V3_SINGLE_PRICE_ORACLE = _uniswapSinglePriceOracle;
  80 |     |     V2_RESERVES = IV2Reserves(_v2Reserves);
  81 |     | 
  82 |     |     address _pod = IStakingPoolToken(_spTKN).indexFund();
  83 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(
  84 |     |       _pod
  85 |     |     ).getAllAssets();
  86 |     |     POD = _pod;
  87 |     |     UNDERLYING_TKN = _assets[0].token;
  88 |     |   }
  89 |     | 
  90 |     |   /// @notice The ```getPrices``` function gets the mathematical price of SP_TKN / BASE_TOKEN, so in plain english will
  91 |     |   /// @notice be the number of SP_TKN per every BASE_TOKEN
  92 |     |   /// @return _isBadData Whether the price(s) returned should be considered bad
  93 |     |   /// @return _priceLow The lower of the dual prices returned
  94 |     |   /// @return _priceHigh The higher of the dual prices returned
  95 |     |   function getPrices()
  96 |     |     public
  97 |     |     view
  98 |     |     virtual
  99 |     |     override
 100 |     |     returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)
 101 |     |   {
 102 |     |     uint256 _priceBaseSpTKN = _calculateBasePerSpTkn(0);
 103 |     |     _isBadData = _priceBaseSpTKN == 0;
 104 |     |     uint256 _priceOne18 = _priceBaseSpTKN *
 105 |     |       10 ** (18 - IERC20Metadata(BASE_TOKEN).decimals());
 106 |     | 
 107 |     |     uint256 _priceTwo18 = _priceOne18;
 108 |     |     if (
 109 |     |       CHAINLINK_BASE_PRICE_FEED != address(0) &&
 110 |     |       CHAINLINK_QUOTE_PRICE_FEED != address(0)
 111 |     |     ) {
 112 |     |       uint256 _clPrice18 = _chainlinkBasePerPaired18();
 113 |     |       uint256 _clPriceBaseSpTKN = _calculateBasePerSpTkn(_clPrice18);
 114 |     |       _priceTwo18 =
 115 |     |         _clPriceBaseSpTKN *
 116 |     |         10 ** (18 - IERC20Metadata(BASE_TOKEN).decimals());
 117 |     |       _isBadData = _isBadData || _clPrice18 == 0;
 118 |     |     }
 119 |     | 
 120 |     |     // If the prices are the same it means the CL price was pulled as the UniV3 price
 121 |     |     _priceLow = _priceOne18 > _priceTwo18 ? _priceTwo18 : _priceOne18;
 122 |     |     _priceHigh = _priceOne18 > _priceTwo18 ? _priceOne18 : _priceTwo18;
 123 |     |   }
 124 |     | 
 125 |     |   function _calculateBasePerSpTkn(
 126 |     |     uint256 _price18
 127 |     |   ) internal view returns (uint256 _spTknBasePrice18) {
 128 |     |     // pull from UniV3 TWAP if passed as 0
 129 |     |     address _baseInCl = _getBaseTokenInClPool();
 130 |     |     if (_price18 == 0) {
 131 |     |       bool _isBadData;
 132 |     |       (_isBadData, _price18) = IMinimalSinglePriceOracle(
 133 |     |         UNISWAP_V3_SINGLE_PRICE_ORACLE
 134 |     |       ).getPriceUSD18(
 135 |     |           BASE_CONVERSION_CHAINLINK_FEED,
 136 |     |           UNDERLYING_TKN,
 137 |     |           UNDERLYING_TKN_CL_POOL,
 138 |     |           twapInterval
 139 |     |         );
 140 |     |       if (_isBadData) {
 141 |     |         return 0;
 142 |     |       }
 143 |     | 
 144 |     |       if (BASE_CONVERSION_CL_POOL != address(0)) {
 145 |     |         (
 146 |     |           bool _subBadData,
 147 |     |           uint256 _baseConvPrice18
 148 |     |         ) = IMinimalSinglePriceOracle(UNISWAP_V3_SINGLE_PRICE_ORACLE)
 149 |     |             .getPriceUSD18(
 150 |     |               address(0),
 151 |     |               _baseInCl,
 152 |     |               BASE_CONVERSION_CL_POOL,
 153 |     |               twapInterval
 154 |     |             );
 155 |     |         if (_subBadData) {
 156 |     |           return 0;
 157 |     |         }
 158 |     |         _price18 = (10 ** 18 * _baseConvPrice18) / _price18;
 159 |     |       }
 160 |     |     }
 161 |     |     address _pair = _getPair();
 162 |     |     address _clT0 = IUniswapV2Pair(UNDERLYING_TKN_CL_POOL).token0();
 163 |     |     uint8 _clT0Decimals = IERC20Metadata(_clT0).decimals();
 164 |     |     address _clT1 = IUniswapV2Pair(UNDERLYING_TKN_CL_POOL).token1();
 165 |     |     uint8 _clT1Decimals = IERC20Metadata(_clT1).decimals();
 166 |     |     uint256 _pricePTKNPerBase18 = _clT1 == _baseInCl
 167 |     |       ? _accountForCBRInPrice(POD, UNDERLYING_TKN, _price18)
 168 |     |       : 10 ** (18 * 2) / _accountForCBRInPrice(POD, UNDERLYING_TKN, _price18);
 169 |     | 
 170 |     |     // adjust current price for spTKN pod unwrap fee, which will end up making the end price
 171 |     |     // (spTKN per base) higher, meaning it will take more spTKN to equal the value
 172 |     |     // of base token. This will more accurately ensure healthy LTVs when lending since
 173 |     |     // a liquidation path will need to account for unwrap fees
 174 |     |     _pricePTKNPerBase18 = _accountForUnwrapFeeInPrice(POD, _pricePTKNPerBase18);
 175 |     | 
 176 |     |     (uint112 _reserve0, uint112 _reserve1) = V2_RESERVES.getReserves(_pair);
 177 |     |     uint256 _k = uint256(_reserve0) * _reserve1;
 178 |     |     uint256 _kDec = 10 **
 179 |     |       IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals() *
 180 |     |       10 ** IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();
 181 |     |     uint256 _avgBaseAssetInLp18 = _sqrt((_pricePTKNPerBase18 * _k) / _kDec) *
 182 |     |       10 ** (18 / 2);
 183 |     |     uint256 _pairPrice18 = (2 *
 184 |     |       _avgBaseAssetInLp18 *
 185 |     |       10 ** ((_clT0Decimals + _clT1Decimals) / 2)) /
 186 |     |       IERC20(_pair).totalSupply();
 187 |     |     uint256 _baseTDecimals = _clT1 == _baseInCl ? _clT1Decimals : _clT0Decimals;
 188 |     |     _spTknBasePrice18 =
 189 |     |       10 ** (18 * 2) /
 190 |     |       ((_pairPrice18 * 10 ** _baseTDecimals) / 10 ** 18);
 191 |     | 
 192 |     |     // if the base asset is a pod, we will assume that the CL/chainlink pool(s) are
 193 |     |     // pricing the underlying asset of the base asset pod, and therefore we will
 194 |     |     // adjust the output price by CBR and unwrap fee for this pod for more accuracy and
 195 |     |     // better handling accounting for liquidation path
 196 |     |     if (BASE_IS_POD) {
 197 |     |       _spTknBasePrice18 = _checkAndHandleBaseTokenPodConfig(_spTknBasePrice18);
 198 |     |     }
 199 |     |   }
 200 |     | 
 201 |     |   function _getBaseTokenInClPool() internal view returns (address _base) {
 202 |     |     _base = BASE_TOKEN;
 203 |     |     if (BASE_IS_POD) {
 204 |     |       IDecentralizedIndex.IndexAssetInfo[]
 205 |     |         memory _baseAssets = IDecentralizedIndex(BASE_TOKEN).getAllAssets();
 206 |     |       _base = _baseAssets[0].token;
 207 |     |     }
 208 |     |   }
 209 |     | 
 210 |     |   function _checkAndHandleBaseTokenPodConfig(
 211 |     |     uint256 _currentPrice18
 212 |     |   ) internal view returns (uint256 _finalPrice18) {
 213 |     |     _finalPrice18 = _accountForCBRInPrice(
 214 |     |       BASE_TOKEN,
 215 |     |       address(0),
 216 |     |       _currentPrice18
 217 |     |     );
 218 |     |     _finalPrice18 = _accountForUnwrapFeeInPrice(BASE_TOKEN, _finalPrice18);
 219 |     |   }
 220 |     | 
 221 |     |   function _chainlinkBasePerPaired18()
 222 |     |     internal
 223 |     |     view
 224 |     |     returns (uint256 _price18)
 225 |     |   {
 226 |     |     (bool _isBadData, uint256 _basePerPaired18) = IMinimalSinglePriceOracle(
 227 |     |       CHAINLINK_SINGLE_PRICE_ORACLE
 228 |     |     ).getPriceUSD18(
 229 |     |         CHAINLINK_QUOTE_PRICE_FEED,
 230 |     |         CHAINLINK_BASE_PRICE_FEED,
 231 |     |         address(0),
 232 |     |         0
 233 |     |       );
 234 |     |     if (_isBadData) {
 235 |     |       return 0;
 236 |     |     }
 237 |     |     _price18 = _basePerPaired18;
 238 |     |   }
 239 |     | 
 240 |     |   function _getPair() private view returns (address) {
 241 |     |     return IStakingPoolToken(SP_TKN).stakingToken();
 242 |     |   }
 243 |     | 
 244 |     |   function _accountForCBRInPrice(
 245 |     |     address _pod,
 246 |     |     address _underlying,
 247 |     |     uint256 _amtUnderlying
 248 |     |   ) internal view returns (uint256) {
 249 |     |     require(IDecentralizedIndex(_pod).unlocked() == 1, 'OU');
 250 |     |     if (_underlying == address(0)) {
 251 |     |       IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(
 252 |     |         _pod
 253 |     |       ).getAllAssets();
 254 |     |       _underlying = _assets[0].token;
 255 |     |     }
 256 |     |     return
 257 |     |       (_amtUnderlying *
 258 |     |         IERC20(_underlying).balanceOf(_pod) *
 259 |     |         10 ** IERC20Metadata(_pod).decimals()) /
 260 |     |       IERC20(_pod).totalSupply() /
 261 |     |       10 ** IERC20Metadata(_underlying).decimals();
 262 |     |   }
 263 |     | 
 264 |     |   function _accountForUnwrapFeeInPrice(
 265 |     |     address _pod,
 266 |     |     uint256 _currentPrice
 267 |     |   ) internal view returns (uint256 _newPrice) {
 268 |     |     uint16 _unwrapFee = IDecentralizedIndex(_pod).DEBOND_FEE();
 269 |     |     _newPrice = _currentPrice - (_currentPrice * _unwrapFee) / 10000;
 270 |     |   }
 271 |     | 
 272 |     |   function _sqrt(uint256 x) private pure returns (uint256 y) {
 273 |     |     uint256 z = (x + 1) / 2;
 274 |     |     y = x;
 275 |     |     while (z < y) {
 276 |     |       y = z;
 277 |     |       z = (x / z + z) / 2;
 278 |     |     }
 279 |     |   }
 280 |     | 
 281 |     |   function setTwapInterval(uint32 _interval) external onlyOwner {
 282 |     |     twapInterval = _interval;
 283 |     |   }
 284 |     | }
 285 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/test/TestERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
  5 |     | 
  6 |     | contract TestERC20 is ERC20 {
  7 |     |   constructor(
  8 |     |     string memory _name,
  9 |     |     string memory _symbol
 10 |     |   ) ERC20(_name, _symbol) {
 11 |     |     _mint(_msgSender(), 10_000_000 * 10 ** 18);
 12 |     |   }
 13 |     | 
 14 |     |   function burn(uint256 _amount) external {
 15 |     |     _burn(_msgSender(), _amount);
 16 |     |   }
 17 |     | }
 18 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/test/TestERC4626Vault.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/ERC20.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   8 |     | import '../interfaces/ILendingAssetVault.sol';
   9 |     | 
  10 |     | contract TestERC4626Vault is IERC4626, ERC20, ERC20Permit {
  11 |     |   using SafeERC20 for IERC20;
  12 |     | 
  13 |     |   uint256 constant PRECISION = 10 ** 18;
  14 |     | 
  15 |     |   address _asset;
  16 |     | 
  17 |     |   constructor(
  18 |     |     address __asset
  19 |     |   ) ERC20('Test Vault', 'tVAULT') ERC20Permit('Test Vault') {
  20 |     |     _asset = __asset;
  21 |     |   }
  22 |     | 
  23 |     |   // Needed for LendingAssetVault
  24 |     |   function addInterest() external {}
  25 |     | 
  26 |     |   function asset() external view override returns (address) {
  27 |     |     return _asset;
  28 |     |   }
  29 |     | 
  30 |     |   function totalAssets() public view override returns (uint256) {
  31 |     |     return IERC20(_asset).balanceOf(address(this));
  32 |     |   }
  33 |     | 
  34 |     |   function convertToShares(
  35 |     |     uint256 _assets
  36 |     |   ) public view override returns (uint256 _shares) {
  37 |     |     _shares = (_assets * PRECISION) / _cbr();
  38 |     |   }
  39 |     | 
  40 |     |   function convertToAssets(
  41 |     |     uint256 _shares
  42 |     |   ) public view override returns (uint256 _assets) {
  43 |     |     _assets = (_shares * _cbr()) / PRECISION;
  44 |     |   }
  45 |     | 
  46 |     |   function maxDeposit(
  47 |     |     address
  48 |     |   ) external pure override returns (uint256 maxAssets) {
  49 |     |     maxAssets = type(uint256).max - 1;
  50 |     |   }
  51 |     | 
  52 |     |   function previewDeposit(
  53 |     |     uint256 _assets
  54 |     |   ) external view override returns (uint256 _shares) {
  55 |     |     _shares = convertToShares(_assets);
  56 |     |   }
  57 |     | 
  58 |     |   function deposit(
  59 |     |     uint256 _assets,
  60 |     |     address _receiver
  61 |     |   ) external override returns (uint256 _shares) {
  62 |     |     _shares = _deposit(_assets, _receiver, _msgSender());
  63 |     |   }
  64 |     | 
  65 |     |   function depositFromLendingAssetVault(
  66 |     |     address _vault,
  67 |     |     uint256 _amountAssets
  68 |     |   ) external {
  69 |     |     ILendingAssetVault(_vault).whitelistWithdraw(_amountAssets);
  70 |     |     uint256 _newShares = _deposit(_amountAssets, address(this), address(this));
  71 |     |     _transfer(address(this), _vault, _newShares);
  72 |     |   }
  73 |     | 
  74 |     |   function withdrawToLendingAssetVault(
  75 |     |     address _vault,
  76 |     |     uint256 _amountAssets
  77 |     |   ) external {
  78 |     |     uint256 _shares = convertToShares(_amountAssets);
  79 |     |     _transfer(_vault, address(this), _shares);
  80 |     |     IERC20(_asset).approve(_vault, _amountAssets);
  81 |     |     ILendingAssetVault(_vault).whitelistDeposit(_amountAssets);
  82 |     |     _withdraw(_shares, address(this), address(this));
  83 |     |   }
  84 |     | 
  85 |     |   function _deposit(
  86 |     |     uint256 _assets,
  87 |     |     address _receiver,
  88 |     |     address _owner
  89 |     |   ) internal returns (uint256 _shares) {
  90 |     |     _shares = convertToShares(_assets);
  91 |     |     _mint(_receiver, _shares);
  92 |     |     if (_owner != address(this)) {
  93 |     |       IERC20(_asset).safeTransferFrom(_owner, address(this), _assets);
  94 |     |     }
  95 |     |     emit Deposit(_owner, _receiver, _assets, _shares);
  96 |     |   }
  97 |     | 
  98 |     |   function maxMint(address) external pure override returns (uint256 maxShares) {
  99 |     |     maxShares = type(uint256).max - 1;
 100 |     |   }
 101 |     | 
 102 |     |   function previewMint(
 103 |     |     uint256 _shares
 104 |     |   ) external view override returns (uint256 _assets) {
 105 |     |     _assets = convertToAssets(_shares);
 106 |     |   }
 107 |     | 
 108 |     |   function mint(
 109 |     |     uint256 _shares,
 110 |     |     address _receiver
 111 |     |   ) external override returns (uint256 _assets) {
 112 |     |     _assets = convertToAssets(_shares);
 113 |     |     _deposit(_assets, _receiver, _msgSender());
 114 |     |   }
 115 |     | 
 116 |     |   function maxWithdraw(
 117 |     |     address _owner
 118 |     |   ) external view override returns (uint256 _maxAssets) {
 119 |     |     _maxAssets = (balanceOf(_owner) * _cbr()) / PRECISION;
 120 |     |   }
 121 |     | 
 122 |     |   function previewWithdraw(
 123 |     |     uint256 _assets
 124 |     |   ) external view override returns (uint256 _shares) {
 125 |     |     _shares = convertToShares(_assets);
 126 |     |   }
 127 |     | 
 128 |     |   function withdraw(
 129 |     |     uint256 _assets,
 130 |     |     address _receiver,
 131 |     |     address
 132 |     |   ) external override returns (uint256 _shares) {
 133 |     |     _shares = convertToShares(_assets);
 134 |     |     _withdraw(_shares, _receiver, _msgSender());
 135 |     |   }
 136 |     | 
 137 |     |   function maxRedeem(
 138 |     |     address _owner
 139 |     |   ) external view override returns (uint256 _maxShares) {
 140 |     |     _maxShares = balanceOf(_owner);
 141 |     |   }
 142 |     | 
 143 |     |   function previewRedeem(
 144 |     |     uint256 _shares
 145 |     |   ) external view override returns (uint256 _assets) {
 146 |     |     return convertToAssets(_shares);
 147 |     |   }
 148 |     | 
 149 |     |   function redeem(
 150 |     |     uint256 _shares,
 151 |     |     address _receiver,
 152 |     |     address
 153 |     |   ) external override returns (uint256 _assets) {
 154 |     |     _assets = _withdraw(_shares, _receiver, _msgSender());
 155 |     |   }
 156 |     | 
 157 |     |   function _withdraw(
 158 |     |     uint256 _shares,
 159 |     |     address _receiver,
 160 |     |     address _owner
 161 |     |   ) internal returns (uint256 _assets) {
 162 |     |     _assets = convertToAssets(_shares);
 163 |     |     _burn(_owner, _shares);
 164 |     |     IERC20(_asset).safeTransfer(_receiver, _assets);
 165 |     |     emit Withdraw(_owner, _receiver, _receiver, _assets, _shares);
 166 |     |   }
 167 |     | 
 168 |     |   function _cbr() internal view returns (uint256) {
 169 |     |     uint256 _supply = totalSupply();
 170 |     |     return _supply == 0 ? PRECISION : (PRECISION * totalAssets()) / _supply;
 171 |     |   }
 172 |     | 
 173 |     |   function _assetDecimals() internal view returns (uint8) {
 174 |     |     return IERC20Metadata(_asset).decimals();
 175 |     |   }
 176 |     | }
 177 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/twaputils/V3TwapUtilities.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   6 |     | import '../interfaces/IERC20Metadata.sol';
   7 |     | import '../interfaces/IUniswapV3Pool.sol';
   8 |     | import '../interfaces/IV3TwapUtilities.sol';
   9 |     | import '../libraries/FullMath.sol';
  10 |     | import '../libraries/PoolAddress.sol';
  11 |     | import '../libraries/TickMath.sol';
  12 |     | 
  13 |     | contract V3TwapUtilities is IV3TwapUtilities, Ownable {
  14 |     |   uint32 constant INTERVAL = 10 minutes;
  15 |     | 
  16 |     |   function getV3Pool(
  17 |     |     address _v3Factory,
  18 |     |     address _t0,
  19 |     |     address _t1,
  20 |     |     uint24 _poolFee
  21 |     |   ) external pure override returns (address) {
  22 |     |     (address _token0, address _token1) = _t0 < _t1 ? (_t0, _t1) : (_t1, _t0);
  23 |     |     PoolAddress.PoolKey memory _key = PoolAddress.PoolKey({
  24 |     |       token0: _token0,
  25 |     |       token1: _token1,
  26 |     |       fee: _poolFee
  27 |     |     });
  28 |     |     return PoolAddress.computeAddress(_v3Factory, _key);
  29 |     |   }
  30 |     | 
  31 |     |   function getV3Pool(
  32 |     |     address,
  33 |     |     address,
  34 |     |     address,
  35 |     |     int24
  36 |     |   ) external pure override returns (address) {
  37 |     |     require(false, 'I0');
  38 |     |     return address(0);
  39 |     |   }
  40 |     | 
  41 |     |   function getV3Pool(
  42 |     |     address,
  43 |     |     address,
  44 |     |     address
  45 |     |   ) external pure override returns (address) {
  46 |     |     require(false, 'I1');
  47 |     |     return address(0);
  48 |     |   }
  49 |     | 
  50 |     |   function getPoolPriceUSDX96(
  51 |     |     address _pricePool,
  52 |     |     address _nativeStablePool,
  53 |     |     address _WETH9
  54 |     |   ) public view override returns (uint256) {
  55 |     |     address _token0 = IUniswapV3Pool(_nativeStablePool).token0();
  56 |     |     uint256 _priceStableWETH9X96 = _adjustedPriceX96(
  57 |     |       IUniswapV3Pool(_nativeStablePool),
  58 |     |       _token0 == _WETH9 ? IUniswapV3Pool(_nativeStablePool).token1() : _token0
  59 |     |     );
  60 |     |     if (_pricePool == _nativeStablePool) {
  61 |     |       return _priceStableWETH9X96;
  62 |     |     }
  63 |     |     uint256 _priceMainX96 = _adjustedPriceX96(
  64 |     |       IUniswapV3Pool(_pricePool),
  65 |     |       _WETH9
  66 |     |     );
  67 |     |     return (_priceStableWETH9X96 * _priceMainX96) / FixedPoint96.Q96;
  68 |     |   }
  69 |     | 
  70 |     |   function sqrtPriceX96FromPoolAndInterval(
  71 |     |     address _poolAddress
  72 |     |   ) public view override returns (uint160 sqrtPriceX96) {
  73 |     |     sqrtPriceX96 = _sqrtPriceX96FromPoolAndInterval(_poolAddress, INTERVAL);
  74 |     |   }
  75 |     | 
  76 |     |   function sqrtPriceX96FromPoolAndPassedInterval(
  77 |     |     address _poolAddress,
  78 |     |     uint32 _interval
  79 |     |   ) external view override returns (uint160 sqrtPriceX96) {
  80 |     |     sqrtPriceX96 = _sqrtPriceX96FromPoolAndInterval(_poolAddress, _interval);
  81 |     |   }
  82 |     | 
  83 |     |   function _sqrtPriceX96FromPoolAndInterval(
  84 |     |     address _poolAddress,
  85 |     |     uint32 _interval
  86 |     |   ) internal view returns (uint160 sqrtPriceX96) {
  87 |     |     IUniswapV3Pool _pool = IUniswapV3Pool(_poolAddress);
  88 |     |     if (_interval == 0) {
  89 |     |       (sqrtPriceX96, , , , , , ) = _pool.slot0();
  90 |     |     } else {
  91 |     |       uint32[] memory secondsAgo = new uint32[](2);
  92 |     |       secondsAgo[0] = _interval;
  93 |     |       secondsAgo[1] = 0;
  94 |     |       (int56[] memory tickCumulatives, ) = _pool.observe(secondsAgo);
  95 |     |       sqrtPriceX96 = TickMath.getSqrtRatioAtTick(
  96 |     |         int24((tickCumulatives[1] - tickCumulatives[0]) / int32(_interval))
  97 |     |       );
  98 |     |     }
  99 |     |   }
 100 |     | 
 101 |     |   function priceX96FromSqrtPriceX96(
 102 |     |     uint160 sqrtPriceX96
 103 |     |   ) public pure override returns (uint256 priceX96) {
 104 |     |     return FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96);
 105 |     |   }
 106 |     | 
 107 |     |   function _adjustedPriceX96(
 108 |     |     IUniswapV3Pool _pool,
 109 |     |     address _numeratorToken
 110 |     |   ) internal view returns (uint256) {
 111 |     |     address _token1 = _pool.token1();
 112 |     |     uint8 _decimals0 = IERC20Metadata(_pool.token0()).decimals();
 113 |     |     uint8 _decimals1 = IERC20Metadata(_token1).decimals();
 114 |     |     uint160 _sqrtPriceX96 = sqrtPriceX96FromPoolAndInterval(address(_pool));
 115 |     |     uint256 _priceX96 = priceX96FromSqrtPriceX96(_sqrtPriceX96);
 116 |     |     uint256 _ratioPriceX96 = _token1 == _numeratorToken
 117 |     |       ? _priceX96
 118 |     |       : FixedPoint96.Q96 ** 2 / _priceX96;
 119 |     |     return
 120 |     |       _token1 == _numeratorToken
 121 |     |         ? (_ratioPriceX96 * 10 ** _decimals0) / 10 ** _decimals1
 122 |     |         : (_ratioPriceX96 * 10 ** _decimals1) / 10 ** _decimals0;
 123 |     |   }
 124 |     | }
 125 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Base.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | import {StdStorage} from "./StdStorage.sol";
  5 |     | import {Vm, VmSafe} from "./Vm.sol";
  6 |     | 
  7 |     | abstract contract CommonBase {
  8 |     |     // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.
  9 |     |     address internal constant VM_ADDRESS = address(uint160(uint256(keccak256("hevm cheat code"))));
 10 |     |     // console.sol and console2.sol work by executing a staticcall to this address.
 11 |     |     address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;
 12 |     |     // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
 13 |     |     address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
 14 |     |     // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.
 15 |     |     address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256("foundry default caller"))));
 16 |     |     // Address of the test contract, deployed by the DEFAULT_SENDER.
 17 |     |     address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;
 18 |     |     // Deterministic deployment address of the Multicall3 contract.
 19 |     |     address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;
 20 |     |     // The order of the secp256k1 curve.
 21 |     |     uint256 internal constant SECP256K1_ORDER =
 22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
 23 |     | 
 24 |     |     uint256 internal constant UINT256_MAX =
 25 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
 26 |     | 
 27 |     |     Vm internal constant vm = Vm(VM_ADDRESS);
 28 |     |     StdStorage internal stdstore;
 29 |     | }
 30 |     | 
 31 |     | abstract contract TestBase is CommonBase {}
 32 |     | 
 33 |     | abstract contract ScriptBase is CommonBase {
 34 |     |     VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);
 35 |     | }
 36 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdAssertions.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | pragma experimental ABIEncoderV2;
   4 |     | 
   5 |     | import {Vm} from "./Vm.sol";
   6 |     | 
   7 |     | abstract contract StdAssertions {
   8 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
   9 |     | 
  10 |     |     event log(string);
  11 |     |     event logs(bytes);
  12 |     | 
  13 |     |     event log_address(address);
  14 |     |     event log_bytes32(bytes32);
  15 |     |     event log_int(int256);
  16 |     |     event log_uint(uint256);
  17 |     |     event log_bytes(bytes);
  18 |     |     event log_string(string);
  19 |     | 
  20 |     |     event log_named_address(string key, address val);
  21 |     |     event log_named_bytes32(string key, bytes32 val);
  22 |     |     event log_named_decimal_int(string key, int256 val, uint256 decimals);
  23 |     |     event log_named_decimal_uint(string key, uint256 val, uint256 decimals);
  24 |     |     event log_named_int(string key, int256 val);
  25 |     |     event log_named_uint(string key, uint256 val);
  26 |     |     event log_named_bytes(string key, bytes val);
  27 |     |     event log_named_string(string key, string val);
  28 |     | 
  29 |     |     event log_array(uint256[] val);
  30 |     |     event log_array(int256[] val);
  31 |     |     event log_array(address[] val);
  32 |     |     event log_named_array(string key, uint256[] val);
  33 |     |     event log_named_array(string key, int256[] val);
  34 |     |     event log_named_array(string key, address[] val);
  35 |     | 
  36 |     |     bool private _failed;
  37 |     | 
  38 | *   |     function failed() public view returns (bool) {
  39 | *   |         if (_failed) {
  40 |     |             return _failed;
  41 |     |         } else {
  42 | *   |             return vm.load(address(vm), bytes32("failed")) != bytes32(0);
  43 |     |         }
  44 |     |     }
  45 |     | 
  46 |     |     function fail() internal virtual {
  47 |     |         vm.store(address(vm), bytes32("failed"), bytes32(uint256(1)));
  48 |     |         _failed = true;
  49 |     |     }
  50 |     | 
  51 |     |     function assertTrue(bool data) internal pure virtual {
  52 |     |         vm.assertTrue(data);
  53 |     |     }
  54 |     | 
  55 |     |     function assertTrue(bool data, string memory err) internal pure virtual {
  56 |     |         vm.assertTrue(data, err);
  57 |     |     }
  58 |     | 
  59 |     |     function assertFalse(bool data) internal pure virtual {
  60 |     |         vm.assertFalse(data);
  61 |     |     }
  62 |     | 
  63 |     |     function assertFalse(bool data, string memory err) internal pure virtual {
  64 |     |         vm.assertFalse(data, err);
  65 |     |     }
  66 |     | 
  67 |     |     function assertEq(bool left, bool right) internal pure virtual {
  68 |     |         vm.assertEq(left, right);
  69 |     |     }
  70 |     | 
  71 |     |     function assertEq(bool left, bool right, string memory err) internal pure virtual {
  72 |     |         vm.assertEq(left, right, err);
  73 |     |     }
  74 |     | 
  75 |     |     function assertEq(uint256 left, uint256 right) internal pure virtual {
  76 |     |         vm.assertEq(left, right);
  77 |     |     }
  78 |     | 
  79 |     |     function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {
  80 |     |         vm.assertEq(left, right, err);
  81 |     |     }
  82 |     | 
  83 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
  84 |     |         vm.assertEqDecimal(left, right, decimals);
  85 |     |     }
  86 |     | 
  87 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
  88 |     |         vm.assertEqDecimal(left, right, decimals, err);
  89 |     |     }
  90 |     | 
  91 |     |     function assertEq(int256 left, int256 right) internal pure virtual {
  92 |     |         vm.assertEq(left, right);
  93 |     |     }
  94 |     | 
  95 |     |     function assertEq(int256 left, int256 right, string memory err) internal pure virtual {
  96 |     |         vm.assertEq(left, right, err);
  97 |     |     }
  98 |     | 
  99 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 100 |     |         vm.assertEqDecimal(left, right, decimals);
 101 |     |     }
 102 |     | 
 103 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 104 |     |         vm.assertEqDecimal(left, right, decimals, err);
 105 |     |     }
 106 |     | 
 107 |     |     function assertEq(address left, address right) internal pure virtual {
 108 |     |         vm.assertEq(left, right);
 109 |     |     }
 110 |     | 
 111 |     |     function assertEq(address left, address right, string memory err) internal pure virtual {
 112 |     |         vm.assertEq(left, right, err);
 113 |     |     }
 114 |     | 
 115 |     |     function assertEq(bytes32 left, bytes32 right) internal pure virtual {
 116 |     |         vm.assertEq(left, right);
 117 |     |     }
 118 |     | 
 119 |     |     function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 120 |     |         vm.assertEq(left, right, err);
 121 |     |     }
 122 |     | 
 123 |     |     function assertEq32(bytes32 left, bytes32 right) internal pure virtual {
 124 |     |         assertEq(left, right);
 125 |     |     }
 126 |     | 
 127 |     |     function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 128 |     |         assertEq(left, right, err);
 129 |     |     }
 130 |     | 
 131 |     |     function assertEq(string memory left, string memory right) internal pure virtual {
 132 |     |         vm.assertEq(left, right);
 133 |     |     }
 134 |     | 
 135 |     |     function assertEq(string memory left, string memory right, string memory err) internal pure virtual {
 136 |     |         vm.assertEq(left, right, err);
 137 |     |     }
 138 |     | 
 139 |     |     function assertEq(bytes memory left, bytes memory right) internal pure virtual {
 140 |     |         vm.assertEq(left, right);
 141 |     |     }
 142 |     | 
 143 |     |     function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 144 |     |         vm.assertEq(left, right, err);
 145 |     |     }
 146 |     | 
 147 |     |     function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {
 148 |     |         vm.assertEq(left, right);
 149 |     |     }
 150 |     | 
 151 |     |     function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 152 |     |         vm.assertEq(left, right, err);
 153 |     |     }
 154 |     | 
 155 |     |     function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 156 |     |         vm.assertEq(left, right);
 157 |     |     }
 158 |     | 
 159 |     |     function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 160 |     |         vm.assertEq(left, right, err);
 161 |     |     }
 162 |     | 
 163 |     |     function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {
 164 |     |         vm.assertEq(left, right);
 165 |     |     }
 166 |     | 
 167 |     |     function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 168 |     |         vm.assertEq(left, right, err);
 169 |     |     }
 170 |     | 
 171 |     |     function assertEq(address[] memory left, address[] memory right) internal pure virtual {
 172 |     |         vm.assertEq(left, right);
 173 |     |     }
 174 |     | 
 175 |     |     function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 176 |     |         vm.assertEq(left, right, err);
 177 |     |     }
 178 |     | 
 179 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 180 |     |         vm.assertEq(left, right);
 181 |     |     }
 182 |     | 
 183 |     |     function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 184 |     |         vm.assertEq(left, right, err);
 185 |     |     }
 186 |     | 
 187 |     |     function assertEq(string[] memory left, string[] memory right) internal pure virtual {
 188 |     |         vm.assertEq(left, right);
 189 |     |     }
 190 |     | 
 191 |     |     function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 192 |     |         vm.assertEq(left, right, err);
 193 |     |     }
 194 |     | 
 195 |     |     function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 196 |     |         vm.assertEq(left, right);
 197 |     |     }
 198 |     | 
 199 |     |     function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 200 |     |         vm.assertEq(left, right, err);
 201 |     |     }
 202 |     | 
 203 |     |     // Legacy helper
 204 |     |     function assertEqUint(uint256 left, uint256 right) internal pure virtual {
 205 |     |         assertEq(left, right);
 206 |     |     }
 207 |     | 
 208 |     |     function assertNotEq(bool left, bool right) internal pure virtual {
 209 |     |         vm.assertNotEq(left, right);
 210 |     |     }
 211 |     | 
 212 |     |     function assertNotEq(bool left, bool right, string memory err) internal pure virtual {
 213 |     |         vm.assertNotEq(left, right, err);
 214 |     |     }
 215 |     | 
 216 |     |     function assertNotEq(uint256 left, uint256 right) internal pure virtual {
 217 |     |         vm.assertNotEq(left, right);
 218 |     |     }
 219 |     | 
 220 |     |     function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {
 221 |     |         vm.assertNotEq(left, right, err);
 222 |     |     }
 223 |     | 
 224 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 225 |     |         vm.assertNotEqDecimal(left, right, decimals);
 226 |     |     }
 227 |     | 
 228 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)
 229 |     |         internal
 230 |     |         pure
 231 |     |         virtual
 232 |     |     {
 233 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 234 |     |     }
 235 |     | 
 236 |     |     function assertNotEq(int256 left, int256 right) internal pure virtual {
 237 |     |         vm.assertNotEq(left, right);
 238 |     |     }
 239 |     | 
 240 |     |     function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {
 241 |     |         vm.assertNotEq(left, right, err);
 242 |     |     }
 243 |     | 
 244 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 245 |     |         vm.assertNotEqDecimal(left, right, decimals);
 246 |     |     }
 247 |     | 
 248 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 249 |     |         vm.assertNotEqDecimal(left, right, decimals, err);
 250 |     |     }
 251 |     | 
 252 |     |     function assertNotEq(address left, address right) internal pure virtual {
 253 |     |         vm.assertNotEq(left, right);
 254 |     |     }
 255 |     | 
 256 |     |     function assertNotEq(address left, address right, string memory err) internal pure virtual {
 257 |     |         vm.assertNotEq(left, right, err);
 258 |     |     }
 259 |     | 
 260 |     |     function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {
 261 |     |         vm.assertNotEq(left, right);
 262 |     |     }
 263 |     | 
 264 |     |     function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 265 |     |         vm.assertNotEq(left, right, err);
 266 |     |     }
 267 |     | 
 268 |     |     function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {
 269 |     |         assertNotEq(left, right);
 270 |     |     }
 271 |     | 
 272 |     |     function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {
 273 |     |         assertNotEq(left, right, err);
 274 |     |     }
 275 |     | 
 276 |     |     function assertNotEq(string memory left, string memory right) internal pure virtual {
 277 |     |         vm.assertNotEq(left, right);
 278 |     |     }
 279 |     | 
 280 |     |     function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {
 281 |     |         vm.assertNotEq(left, right, err);
 282 |     |     }
 283 |     | 
 284 |     |     function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {
 285 |     |         vm.assertNotEq(left, right);
 286 |     |     }
 287 |     | 
 288 |     |     function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 289 |     |         vm.assertNotEq(left, right, err);
 290 |     |     }
 291 |     | 
 292 |     |     function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {
 293 |     |         vm.assertNotEq(left, right);
 294 |     |     }
 295 |     | 
 296 |     |     function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {
 297 |     |         vm.assertNotEq(left, right, err);
 298 |     |     }
 299 |     | 
 300 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {
 301 |     |         vm.assertNotEq(left, right);
 302 |     |     }
 303 |     | 
 304 |     |     function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {
 305 |     |         vm.assertNotEq(left, right, err);
 306 |     |     }
 307 |     | 
 308 |     |     function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {
 309 |     |         vm.assertNotEq(left, right);
 310 |     |     }
 311 |     | 
 312 |     |     function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {
 313 |     |         vm.assertNotEq(left, right, err);
 314 |     |     }
 315 |     | 
 316 |     |     function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {
 317 |     |         vm.assertNotEq(left, right);
 318 |     |     }
 319 |     | 
 320 |     |     function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {
 321 |     |         vm.assertNotEq(left, right, err);
 322 |     |     }
 323 |     | 
 324 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {
 325 |     |         vm.assertNotEq(left, right);
 326 |     |     }
 327 |     | 
 328 |     |     function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {
 329 |     |         vm.assertNotEq(left, right, err);
 330 |     |     }
 331 |     | 
 332 |     |     function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {
 333 |     |         vm.assertNotEq(left, right);
 334 |     |     }
 335 |     | 
 336 |     |     function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {
 337 |     |         vm.assertNotEq(left, right, err);
 338 |     |     }
 339 |     | 
 340 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {
 341 |     |         vm.assertNotEq(left, right);
 342 |     |     }
 343 |     | 
 344 |     |     function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {
 345 |     |         vm.assertNotEq(left, right, err);
 346 |     |     }
 347 |     | 
 348 |     |     function assertLt(uint256 left, uint256 right) internal pure virtual {
 349 |     |         vm.assertLt(left, right);
 350 |     |     }
 351 |     | 
 352 |     |     function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {
 353 |     |         vm.assertLt(left, right, err);
 354 |     |     }
 355 |     | 
 356 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 357 |     |         vm.assertLtDecimal(left, right, decimals);
 358 |     |     }
 359 |     | 
 360 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 361 |     |         vm.assertLtDecimal(left, right, decimals, err);
 362 |     |     }
 363 |     | 
 364 |     |     function assertLt(int256 left, int256 right) internal pure virtual {
 365 |     |         vm.assertLt(left, right);
 366 |     |     }
 367 |     | 
 368 |     |     function assertLt(int256 left, int256 right, string memory err) internal pure virtual {
 369 |     |         vm.assertLt(left, right, err);
 370 |     |     }
 371 |     | 
 372 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 373 |     |         vm.assertLtDecimal(left, right, decimals);
 374 |     |     }
 375 |     | 
 376 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 377 |     |         vm.assertLtDecimal(left, right, decimals, err);
 378 |     |     }
 379 |     | 
 380 |     |     function assertGt(uint256 left, uint256 right) internal pure virtual {
 381 |     |         vm.assertGt(left, right);
 382 |     |     }
 383 |     | 
 384 |     |     function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {
 385 |     |         vm.assertGt(left, right, err);
 386 |     |     }
 387 |     | 
 388 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 389 |     |         vm.assertGtDecimal(left, right, decimals);
 390 |     |     }
 391 |     | 
 392 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 393 |     |         vm.assertGtDecimal(left, right, decimals, err);
 394 |     |     }
 395 |     | 
 396 |     |     function assertGt(int256 left, int256 right) internal pure virtual {
 397 |     |         vm.assertGt(left, right);
 398 |     |     }
 399 |     | 
 400 |     |     function assertGt(int256 left, int256 right, string memory err) internal pure virtual {
 401 |     |         vm.assertGt(left, right, err);
 402 |     |     }
 403 |     | 
 404 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 405 |     |         vm.assertGtDecimal(left, right, decimals);
 406 |     |     }
 407 |     | 
 408 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 409 |     |         vm.assertGtDecimal(left, right, decimals, err);
 410 |     |     }
 411 |     | 
 412 |     |     function assertLe(uint256 left, uint256 right) internal pure virtual {
 413 |     |         vm.assertLe(left, right);
 414 |     |     }
 415 |     | 
 416 |     |     function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {
 417 |     |         vm.assertLe(left, right, err);
 418 |     |     }
 419 |     | 
 420 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 421 |     |         vm.assertLeDecimal(left, right, decimals);
 422 |     |     }
 423 |     | 
 424 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 425 |     |         vm.assertLeDecimal(left, right, decimals, err);
 426 |     |     }
 427 |     | 
 428 |     |     function assertLe(int256 left, int256 right) internal pure virtual {
 429 |     |         vm.assertLe(left, right);
 430 |     |     }
 431 |     | 
 432 |     |     function assertLe(int256 left, int256 right, string memory err) internal pure virtual {
 433 |     |         vm.assertLe(left, right, err);
 434 |     |     }
 435 |     | 
 436 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 437 |     |         vm.assertLeDecimal(left, right, decimals);
 438 |     |     }
 439 |     | 
 440 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 441 |     |         vm.assertLeDecimal(left, right, decimals, err);
 442 |     |     }
 443 |     | 
 444 |     |     function assertGe(uint256 left, uint256 right) internal pure virtual {
 445 |     |         vm.assertGe(left, right);
 446 |     |     }
 447 |     | 
 448 |     |     function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {
 449 |     |         vm.assertGe(left, right, err);
 450 |     |     }
 451 |     | 
 452 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {
 453 |     |         vm.assertGeDecimal(left, right, decimals);
 454 |     |     }
 455 |     | 
 456 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {
 457 |     |         vm.assertGeDecimal(left, right, decimals, err);
 458 |     |     }
 459 |     | 
 460 |     |     function assertGe(int256 left, int256 right) internal pure virtual {
 461 |     |         vm.assertGe(left, right);
 462 |     |     }
 463 |     | 
 464 |     |     function assertGe(int256 left, int256 right, string memory err) internal pure virtual {
 465 |     |         vm.assertGe(left, right, err);
 466 |     |     }
 467 |     | 
 468 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {
 469 |     |         vm.assertGeDecimal(left, right, decimals);
 470 |     |     }
 471 |     | 
 472 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {
 473 |     |         vm.assertGeDecimal(left, right, decimals, err);
 474 |     |     }
 475 |     | 
 476 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {
 477 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 478 |     |     }
 479 |     | 
 480 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)
 481 |     |         internal
 482 |     |         pure
 483 |     |         virtual
 484 |     |     {
 485 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 486 |     |     }
 487 |     | 
 488 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)
 489 |     |         internal
 490 |     |         pure
 491 |     |         virtual
 492 |     |     {
 493 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 494 |     |     }
 495 |     | 
 496 |     |     function assertApproxEqAbsDecimal(
 497 |     |         uint256 left,
 498 |     |         uint256 right,
 499 |     |         uint256 maxDelta,
 500 |     |         uint256 decimals,
 501 |     |         string memory err
 502 |     |     ) internal pure virtual {
 503 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 504 |     |     }
 505 |     | 
 506 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {
 507 |     |         vm.assertApproxEqAbs(left, right, maxDelta);
 508 |     |     }
 509 |     | 
 510 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {
 511 |     |         vm.assertApproxEqAbs(left, right, maxDelta, err);
 512 |     |     }
 513 |     | 
 514 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)
 515 |     |         internal
 516 |     |         pure
 517 |     |         virtual
 518 |     |     {
 519 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);
 520 |     |     }
 521 |     | 
 522 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)
 523 |     |         internal
 524 |     |         pure
 525 |     |         virtual
 526 |     |     {
 527 |     |         vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);
 528 |     |     }
 529 |     | 
 530 |     |     function assertApproxEqRel(
 531 |     |         uint256 left,
 532 |     |         uint256 right,
 533 |     |         uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%
 534 |     |     ) internal pure virtual {
 535 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 536 |     |     }
 537 |     | 
 538 |     |     function assertApproxEqRel(
 539 |     |         uint256 left,
 540 |     |         uint256 right,
 541 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 542 |     |         string memory err
 543 |     |     ) internal pure virtual {
 544 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 545 |     |     }
 546 |     | 
 547 |     |     function assertApproxEqRelDecimal(
 548 |     |         uint256 left,
 549 |     |         uint256 right,
 550 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 551 |     |         uint256 decimals
 552 |     |     ) internal pure virtual {
 553 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 554 |     |     }
 555 |     | 
 556 |     |     function assertApproxEqRelDecimal(
 557 |     |         uint256 left,
 558 |     |         uint256 right,
 559 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 560 |     |         uint256 decimals,
 561 |     |         string memory err
 562 |     |     ) internal pure virtual {
 563 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 564 |     |     }
 565 |     | 
 566 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {
 567 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta);
 568 |     |     }
 569 |     | 
 570 |     |     function assertApproxEqRel(
 571 |     |         int256 left,
 572 |     |         int256 right,
 573 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 574 |     |         string memory err
 575 |     |     ) internal pure virtual {
 576 |     |         vm.assertApproxEqRel(left, right, maxPercentDelta, err);
 577 |     |     }
 578 |     | 
 579 |     |     function assertApproxEqRelDecimal(
 580 |     |         int256 left,
 581 |     |         int256 right,
 582 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 583 |     |         uint256 decimals
 584 |     |     ) internal pure virtual {
 585 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);
 586 |     |     }
 587 |     | 
 588 |     |     function assertApproxEqRelDecimal(
 589 |     |         int256 left,
 590 |     |         int256 right,
 591 |     |         uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%
 592 |     |         uint256 decimals,
 593 |     |         string memory err
 594 |     |     ) internal pure virtual {
 595 |     |         vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);
 596 |     |     }
 597 |     | 
 598 |     |     // Inherited from DSTest, not used but kept for backwards-compatibility
 599 |     |     function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {
 600 |     |         return keccak256(left) == keccak256(right);
 601 |     |     }
 602 |     | 
 603 |     |     function assertEq0(bytes memory left, bytes memory right) internal pure virtual {
 604 |     |         assertEq(left, right);
 605 |     |     }
 606 |     | 
 607 |     |     function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 608 |     |         assertEq(left, right, err);
 609 |     |     }
 610 |     | 
 611 |     |     function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {
 612 |     |         assertNotEq(left, right);
 613 |     |     }
 614 |     | 
 615 |     |     function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {
 616 |     |         assertNotEq(left, right, err);
 617 |     |     }
 618 |     | 
 619 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {
 620 |     |         assertEqCall(target, callDataA, target, callDataB, true);
 621 |     |     }
 622 |     | 
 623 |     |     function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)
 624 |     |         internal
 625 |     |         virtual
 626 |     |     {
 627 |     |         assertEqCall(targetA, callDataA, targetB, callDataB, true);
 628 |     |     }
 629 |     | 
 630 |     |     function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)
 631 |     |         internal
 632 |     |         virtual
 633 |     |     {
 634 |     |         assertEqCall(target, callDataA, target, callDataB, strictRevertData);
 635 |     |     }
 636 |     | 
 637 |     |     function assertEqCall(
 638 |     |         address targetA,
 639 |     |         bytes memory callDataA,
 640 |     |         address targetB,
 641 |     |         bytes memory callDataB,
 642 |     |         bool strictRevertData
 643 |     |     ) internal virtual {
 644 |     |         (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);
 645 |     |         (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);
 646 |     | 
 647 |     |         if (successA && successB) {
 648 |     |             assertEq(returnDataA, returnDataB, "Call return data does not match");
 649 |     |         }
 650 |     | 
 651 |     |         if (!successA && !successB && strictRevertData) {
 652 |     |             assertEq(returnDataA, returnDataB, "Call revert data does not match");
 653 |     |         }
 654 |     | 
 655 |     |         if (!successA && successB) {
 656 |     |             emit log("Error: Calls were not equal");
 657 |     |             emit log_named_bytes("  Left call revert data", returnDataA);
 658 |     |             emit log_named_bytes(" Right call return data", returnDataB);
 659 |     |             revert("assertion failed");
 660 |     |         }
 661 |     | 
 662 |     |         if (successA && !successB) {
 663 |     |             emit log("Error: Calls were not equal");
 664 |     |             emit log_named_bytes("  Left call return data", returnDataA);
 665 |     |             emit log_named_bytes(" Right call revert data", returnDataB);
 666 |     |             revert("assertion failed");
 667 |     |         }
 668 |     |     }
 669 |     | }
 670 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdChains.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | /**
   7 |     |  * StdChains provides information about EVM compatible chains that can be used in scripts/tests.
   8 |     |  * For each chain, the chain's name, chain ID, and a default RPC URL are provided. Chains are
   9 |     |  * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of
  10 |     |  * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the
  11 |     |  * alias used in this contract, which can be found as the first argument to the
  12 |     |  * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.
  13 |     |  *
  14 |     |  * There are two main ways to use this contract:
  15 |     |  *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or
  16 |     |  *      `setChain(string memory chainAlias, Chain memory chain)`
  17 |     |  *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.
  18 |     |  *
  19 |     |  * The first time either of those are used, chains are initialized with the default set of RPC URLs.
  20 |     |  * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in
  21 |     |  * `defaultRpcUrls`.
  22 |     |  *
  23 |     |  * The `setChain` function is straightforward, and it simply saves off the given chain data.
  24 |     |  *
  25 |     |  * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let's say
  26 |     |  * we want to retrieve the RPC URL for `mainnet`:
  27 |     |  *   - If you have specified data with `setChain`, it will return that.
  28 |     |  *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it
  29 |     |  *     is valid (e.g. a URL is specified, or an environment variable is given and exists).
  30 |     |  *   - If neither of the above conditions is met, the default data is returned.
  31 |     |  *
  32 |     |  * Summarizing the above, the prioritization hierarchy is `setChain` -> `foundry.toml` -> environment variable -> defaults.
  33 |     |  */
  34 |     | abstract contract StdChains {
  35 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  36 |     | 
  37 |     |     bool private stdChainsInitialized;
  38 |     | 
  39 |     |     struct ChainData {
  40 |     |         string name;
  41 |     |         uint256 chainId;
  42 |     |         string rpcUrl;
  43 |     |     }
  44 |     | 
  45 |     |     struct Chain {
  46 |     |         // The chain name.
  47 |     |         string name;
  48 |     |         // The chain's Chain ID.
  49 |     |         uint256 chainId;
  50 |     |         // The chain's alias. (i.e. what gets specified in `foundry.toml`).
  51 |     |         string chainAlias;
  52 |     |         // A default RPC endpoint for this chain.
  53 |     |         // NOTE: This default RPC URL is included for convenience to facilitate quick tests and
  54 |     |         // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy
  55 |     |         // usage as you will be throttled and this is a disservice to others who need this endpoint.
  56 |     |         string rpcUrl;
  57 |     |     }
  58 |     | 
  59 |     |     // Maps from the chain's alias (matching the alias in the `foundry.toml` file) to chain data.
  60 |     |     mapping(string => Chain) private chains;
  61 |     |     // Maps from the chain's alias to it's default RPC URL.
  62 |     |     mapping(string => string) private defaultRpcUrls;
  63 |     |     // Maps from a chain ID to it's alias.
  64 |     |     mapping(uint256 => string) private idToAlias;
  65 |     | 
  66 |     |     bool private fallbackToDefaultRpcUrls = true;
  67 |     | 
  68 |     |     // The RPC URL will be fetched from config or defaultRpcUrls if possible.
  69 |     |     function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {
  70 |     |         require(bytes(chainAlias).length != 0, "StdChains getChain(string): Chain alias cannot be the empty string.");
  71 |     | 
  72 |     |         initializeStdChains();
  73 |     |         chain = chains[chainAlias];
  74 |     |         require(
  75 |     |             chain.chainId != 0,
  76 |     |             string(abi.encodePacked("StdChains getChain(string): Chain with alias \"", chainAlias, "\" not found."))
  77 |     |         );
  78 |     | 
  79 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  80 |     |     }
  81 |     | 
  82 |     |     function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {
  83 |     |         require(chainId != 0, "StdChains getChain(uint256): Chain ID cannot be 0.");
  84 |     |         initializeStdChains();
  85 |     |         string memory chainAlias = idToAlias[chainId];
  86 |     | 
  87 |     |         chain = chains[chainAlias];
  88 |     | 
  89 |     |         require(
  90 |     |             chain.chainId != 0,
  91 |     |             string(abi.encodePacked("StdChains getChain(uint256): Chain with ID ", vm.toString(chainId), " not found."))
  92 |     |         );
  93 |     | 
  94 |     |         chain = getChainWithUpdatedRpcUrl(chainAlias, chain);
  95 |     |     }
  96 |     | 
  97 |     |     // set chain info, with priority to argument's rpcUrl field.
  98 |     |     function setChain(string memory chainAlias, ChainData memory chain) internal virtual {
  99 |     |         require(
 100 |     |             bytes(chainAlias).length != 0,
 101 |     |             "StdChains setChain(string,ChainData): Chain alias cannot be the empty string."
 102 |     |         );
 103 |     | 
 104 |     |         require(chain.chainId != 0, "StdChains setChain(string,ChainData): Chain ID cannot be 0.");
 105 |     | 
 106 |     |         initializeStdChains();
 107 |     |         string memory foundAlias = idToAlias[chain.chainId];
 108 |     | 
 109 |     |         require(
 110 |     |             bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),
 111 |     |             string(
 112 |     |                 abi.encodePacked(
 113 |     |                     "StdChains setChain(string,ChainData): Chain ID ",
 114 |     |                     vm.toString(chain.chainId),
 115 |     |                     " already used by \"",
 116 |     |                     foundAlias,
 117 |     |                     "\"."
 118 |     |                 )
 119 |     |             )
 120 |     |         );
 121 |     | 
 122 |     |         uint256 oldChainId = chains[chainAlias].chainId;
 123 |     |         delete idToAlias[oldChainId];
 124 |     | 
 125 |     |         chains[chainAlias] =
 126 |     |             Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});
 127 |     |         idToAlias[chain.chainId] = chainAlias;
 128 |     |     }
 129 |     | 
 130 |     |     // set chain info, with priority to argument's rpcUrl field.
 131 |     |     function setChain(string memory chainAlias, Chain memory chain) internal virtual {
 132 |     |         setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));
 133 |     |     }
 134 |     | 
 135 |     |     function _toUpper(string memory str) private pure returns (string memory) {
 136 |     |         bytes memory strb = bytes(str);
 137 |     |         bytes memory copy = new bytes(strb.length);
 138 |     |         for (uint256 i = 0; i < strb.length; i++) {
 139 |     |             bytes1 b = strb[i];
 140 |     |             if (b >= 0x61 && b <= 0x7A) {
 141 |     |                 copy[i] = bytes1(uint8(b) - 32);
 142 |     |             } else {
 143 |     |                 copy[i] = b;
 144 |     |             }
 145 |     |         }
 146 |     |         return string(copy);
 147 |     |     }
 148 |     | 
 149 |     |     // lookup rpcUrl, in descending order of priority:
 150 |     |     // current -> config (foundry.toml) -> environment variable -> default
 151 |     |     function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)
 152 |     |         private
 153 |     |         view
 154 |     |         returns (Chain memory)
 155 |     |     {
 156 |     |         if (bytes(chain.rpcUrl).length == 0) {
 157 |     |             try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {
 158 |     |                 chain.rpcUrl = configRpcUrl;
 159 |     |             } catch (bytes memory err) {
 160 |     |                 string memory envName = string(abi.encodePacked(_toUpper(chainAlias), "_RPC_URL"));
 161 |     |                 if (fallbackToDefaultRpcUrls) {
 162 |     |                     chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);
 163 |     |                 } else {
 164 |     |                     chain.rpcUrl = vm.envString(envName);
 165 |     |                 }
 166 |     |                 // Distinguish 'not found' from 'cannot read'
 167 |     |                 // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions
 168 |     |                 bytes memory oldNotFoundError =
 169 |     |                     abi.encodeWithSignature("CheatCodeError", string(abi.encodePacked("invalid rpc url ", chainAlias)));
 170 |     |                 bytes memory newNotFoundError = abi.encodeWithSignature(
 171 |     |                     "CheatcodeError(string)", string(abi.encodePacked("invalid rpc url: ", chainAlias))
 172 |     |                 );
 173 |     |                 bytes32 errHash = keccak256(err);
 174 |     |                 if (
 175 |     |                     (errHash != keccak256(oldNotFoundError) && errHash != keccak256(newNotFoundError))
 176 |     |                         || bytes(chain.rpcUrl).length == 0
 177 |     |                 ) {
 178 |     |                     /// @solidity memory-safe-assembly
 179 |     |                     assembly {
 180 |     |                         revert(add(32, err), mload(err))
 181 |     |                     }
 182 |     |                 }
 183 |     |             }
 184 |     |         }
 185 |     |         return chain;
 186 |     |     }
 187 |     | 
 188 |     |     function setFallbackToDefaultRpcUrls(bool useDefault) internal {
 189 |     |         fallbackToDefaultRpcUrls = useDefault;
 190 |     |     }
 191 |     | 
 192 |     |     function initializeStdChains() private {
 193 |     |         if (stdChainsInitialized) return;
 194 |     | 
 195 |     |         stdChainsInitialized = true;
 196 |     | 
 197 |     |         // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`
 198 |     |         setChainWithDefaultRpcUrl("anvil", ChainData("Anvil", 31337, "http://127.0.0.1:8545"));
 199 |     |         setChainWithDefaultRpcUrl(
 200 |     |             "mainnet", ChainData("Mainnet", 1, "https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP")
 201 |     |         );
 202 |     |         setChainWithDefaultRpcUrl(
 203 |     |             "sepolia", ChainData("Sepolia", 11155111, "https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001")
 204 |     |         );
 205 |     |         setChainWithDefaultRpcUrl("holesky", ChainData("Holesky", 17000, "https://rpc.holesky.ethpandaops.io"));
 206 |     |         setChainWithDefaultRpcUrl("optimism", ChainData("Optimism", 10, "https://mainnet.optimism.io"));
 207 |     |         setChainWithDefaultRpcUrl(
 208 |     |             "optimism_sepolia", ChainData("Optimism Sepolia", 11155420, "https://sepolia.optimism.io")
 209 |     |         );
 210 |     |         setChainWithDefaultRpcUrl("arbitrum_one", ChainData("Arbitrum One", 42161, "https://arb1.arbitrum.io/rpc"));
 211 |     |         setChainWithDefaultRpcUrl(
 212 |     |             "arbitrum_one_sepolia", ChainData("Arbitrum One Sepolia", 421614, "https://sepolia-rollup.arbitrum.io/rpc")
 213 |     |         );
 214 |     |         setChainWithDefaultRpcUrl("arbitrum_nova", ChainData("Arbitrum Nova", 42170, "https://nova.arbitrum.io/rpc"));
 215 |     |         setChainWithDefaultRpcUrl("polygon", ChainData("Polygon", 137, "https://polygon-rpc.com"));
 216 |     |         setChainWithDefaultRpcUrl(
 217 |     |             "polygon_amoy", ChainData("Polygon Amoy", 80002, "https://rpc-amoy.polygon.technology")
 218 |     |         );
 219 |     |         setChainWithDefaultRpcUrl("avalanche", ChainData("Avalanche", 43114, "https://api.avax.network/ext/bc/C/rpc"));
 220 |     |         setChainWithDefaultRpcUrl(
 221 |     |             "avalanche_fuji", ChainData("Avalanche Fuji", 43113, "https://api.avax-test.network/ext/bc/C/rpc")
 222 |     |         );
 223 |     |         setChainWithDefaultRpcUrl(
 224 |     |             "bnb_smart_chain", ChainData("BNB Smart Chain", 56, "https://bsc-dataseed1.binance.org")
 225 |     |         );
 226 |     |         setChainWithDefaultRpcUrl(
 227 |     |             "bnb_smart_chain_testnet",
 228 |     |             ChainData("BNB Smart Chain Testnet", 97, "https://rpc.ankr.com/bsc_testnet_chapel")
 229 |     |         );
 230 |     |         setChainWithDefaultRpcUrl("gnosis_chain", ChainData("Gnosis Chain", 100, "https://rpc.gnosischain.com"));
 231 |     |         setChainWithDefaultRpcUrl("moonbeam", ChainData("Moonbeam", 1284, "https://rpc.api.moonbeam.network"));
 232 |     |         setChainWithDefaultRpcUrl(
 233 |     |             "moonriver", ChainData("Moonriver", 1285, "https://rpc.api.moonriver.moonbeam.network")
 234 |     |         );
 235 |     |         setChainWithDefaultRpcUrl("moonbase", ChainData("Moonbase", 1287, "https://rpc.testnet.moonbeam.network"));
 236 |     |         setChainWithDefaultRpcUrl("base_sepolia", ChainData("Base Sepolia", 84532, "https://sepolia.base.org"));
 237 |     |         setChainWithDefaultRpcUrl("base", ChainData("Base", 8453, "https://mainnet.base.org"));
 238 |     |         setChainWithDefaultRpcUrl("blast_sepolia", ChainData("Blast Sepolia", 168587773, "https://sepolia.blast.io"));
 239 |     |         setChainWithDefaultRpcUrl("blast", ChainData("Blast", 81457, "https://rpc.blast.io"));
 240 |     |         setChainWithDefaultRpcUrl("fantom_opera", ChainData("Fantom Opera", 250, "https://rpc.ankr.com/fantom/"));
 241 |     |         setChainWithDefaultRpcUrl(
 242 |     |             "fantom_opera_testnet", ChainData("Fantom Opera Testnet", 4002, "https://rpc.ankr.com/fantom_testnet/")
 243 |     |         );
 244 |     |         setChainWithDefaultRpcUrl("fraxtal", ChainData("Fraxtal", 252, "https://rpc.frax.com"));
 245 |     |         setChainWithDefaultRpcUrl("fraxtal_testnet", ChainData("Fraxtal Testnet", 2522, "https://rpc.testnet.frax.com"));
 246 |     |         setChainWithDefaultRpcUrl(
 247 |     |             "berachain_bartio_testnet", ChainData("Berachain bArtio Testnet", 80084, "https://bartio.rpc.berachain.com")
 248 |     |         );
 249 |     |     }
 250 |     | 
 251 |     |     // set chain info, with priority to chainAlias' rpc url in foundry.toml
 252 |     |     function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {
 253 |     |         string memory rpcUrl = chain.rpcUrl;
 254 |     |         defaultRpcUrls[chainAlias] = rpcUrl;
 255 |     |         chain.rpcUrl = "";
 256 |     |         setChain(chainAlias, chain);
 257 |     |         chain.rpcUrl = rpcUrl; // restore argument
 258 |     |     }
 259 |     | }
 260 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdCheats.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
   7 |     | import {console2} from "./console2.sol";
   8 |     | import {Vm} from "./Vm.sol";
   9 |     | 
  10 |     | abstract contract StdCheatsSafe {
  11 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  12 |     | 
  13 |     |     uint256 private constant UINT256_MAX =
  14 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  15 |     | 
  16 |     |     bool private gasMeteringOff;
  17 |     | 
  18 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  19 |     |     // that conform to EIP1559. The Raw structs is what is parsed from the JSON
  20 |     |     // and then converted to the one that is used by the user for better UX.
  21 |     | 
  22 |     |     struct RawTx1559 {
  23 |     |         string[] arguments;
  24 |     |         address contractAddress;
  25 |     |         string contractName;
  26 |     |         // json value name = function
  27 |     |         string functionSig;
  28 |     |         bytes32 hash;
  29 |     |         // json value name = tx
  30 |     |         RawTx1559Detail txDetail;
  31 |     |         // json value name = type
  32 |     |         string opcode;
  33 |     |     }
  34 |     | 
  35 |     |     struct RawTx1559Detail {
  36 |     |         AccessList[] accessList;
  37 |     |         bytes data;
  38 |     |         address from;
  39 |     |         bytes gas;
  40 |     |         bytes nonce;
  41 |     |         address to;
  42 |     |         bytes txType;
  43 |     |         bytes value;
  44 |     |     }
  45 |     | 
  46 |     |     struct Tx1559 {
  47 |     |         string[] arguments;
  48 |     |         address contractAddress;
  49 |     |         string contractName;
  50 |     |         string functionSig;
  51 |     |         bytes32 hash;
  52 |     |         Tx1559Detail txDetail;
  53 |     |         string opcode;
  54 |     |     }
  55 |     | 
  56 |     |     struct Tx1559Detail {
  57 |     |         AccessList[] accessList;
  58 |     |         bytes data;
  59 |     |         address from;
  60 |     |         uint256 gas;
  61 |     |         uint256 nonce;
  62 |     |         address to;
  63 |     |         uint256 txType;
  64 |     |         uint256 value;
  65 |     |     }
  66 |     | 
  67 |     |     // Data structures to parse Transaction objects from the broadcast artifact
  68 |     |     // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON
  69 |     |     // and then converted to the one that is used by the user for better UX.
  70 |     | 
  71 |     |     struct TxLegacy {
  72 |     |         string[] arguments;
  73 |     |         address contractAddress;
  74 |     |         string contractName;
  75 |     |         string functionSig;
  76 |     |         string hash;
  77 |     |         string opcode;
  78 |     |         TxDetailLegacy transaction;
  79 |     |     }
  80 |     | 
  81 |     |     struct TxDetailLegacy {
  82 |     |         AccessList[] accessList;
  83 |     |         uint256 chainId;
  84 |     |         bytes data;
  85 |     |         address from;
  86 |     |         uint256 gas;
  87 |     |         uint256 gasPrice;
  88 |     |         bytes32 hash;
  89 |     |         uint256 nonce;
  90 |     |         bytes1 opcode;
  91 |     |         bytes32 r;
  92 |     |         bytes32 s;
  93 |     |         uint256 txType;
  94 |     |         address to;
  95 |     |         uint8 v;
  96 |     |         uint256 value;
  97 |     |     }
  98 |     | 
  99 |     |     struct AccessList {
 100 |     |         address accessAddress;
 101 |     |         bytes32[] storageKeys;
 102 |     |     }
 103 |     | 
 104 |     |     // Data structures to parse Receipt objects from the broadcast artifact.
 105 |     |     // The Raw structs is what is parsed from the JSON
 106 |     |     // and then converted to the one that is used by the user for better UX.
 107 |     | 
 108 |     |     struct RawReceipt {
 109 |     |         bytes32 blockHash;
 110 |     |         bytes blockNumber;
 111 |     |         address contractAddress;
 112 |     |         bytes cumulativeGasUsed;
 113 |     |         bytes effectiveGasPrice;
 114 |     |         address from;
 115 |     |         bytes gasUsed;
 116 |     |         RawReceiptLog[] logs;
 117 |     |         bytes logsBloom;
 118 |     |         bytes status;
 119 |     |         address to;
 120 |     |         bytes32 transactionHash;
 121 |     |         bytes transactionIndex;
 122 |     |     }
 123 |     | 
 124 |     |     struct Receipt {
 125 |     |         bytes32 blockHash;
 126 |     |         uint256 blockNumber;
 127 |     |         address contractAddress;
 128 |     |         uint256 cumulativeGasUsed;
 129 |     |         uint256 effectiveGasPrice;
 130 |     |         address from;
 131 |     |         uint256 gasUsed;
 132 |     |         ReceiptLog[] logs;
 133 |     |         bytes logsBloom;
 134 |     |         uint256 status;
 135 |     |         address to;
 136 |     |         bytes32 transactionHash;
 137 |     |         uint256 transactionIndex;
 138 |     |     }
 139 |     | 
 140 |     |     // Data structures to parse the entire broadcast artifact, assuming the
 141 |     |     // transactions conform to EIP1559.
 142 |     | 
 143 |     |     struct EIP1559ScriptArtifact {
 144 |     |         string[] libraries;
 145 |     |         string path;
 146 |     |         string[] pending;
 147 |     |         Receipt[] receipts;
 148 |     |         uint256 timestamp;
 149 |     |         Tx1559[] transactions;
 150 |     |         TxReturn[] txReturns;
 151 |     |     }
 152 |     | 
 153 |     |     struct RawEIP1559ScriptArtifact {
 154 |     |         string[] libraries;
 155 |     |         string path;
 156 |     |         string[] pending;
 157 |     |         RawReceipt[] receipts;
 158 |     |         TxReturn[] txReturns;
 159 |     |         uint256 timestamp;
 160 |     |         RawTx1559[] transactions;
 161 |     |     }
 162 |     | 
 163 |     |     struct RawReceiptLog {
 164 |     |         // json value = address
 165 |     |         address logAddress;
 166 |     |         bytes32 blockHash;
 167 |     |         bytes blockNumber;
 168 |     |         bytes data;
 169 |     |         bytes logIndex;
 170 |     |         bool removed;
 171 |     |         bytes32[] topics;
 172 |     |         bytes32 transactionHash;
 173 |     |         bytes transactionIndex;
 174 |     |         bytes transactionLogIndex;
 175 |     |     }
 176 |     | 
 177 |     |     struct ReceiptLog {
 178 |     |         // json value = address
 179 |     |         address logAddress;
 180 |     |         bytes32 blockHash;
 181 |     |         uint256 blockNumber;
 182 |     |         bytes data;
 183 |     |         uint256 logIndex;
 184 |     |         bytes32[] topics;
 185 |     |         uint256 transactionIndex;
 186 |     |         uint256 transactionLogIndex;
 187 |     |         bool removed;
 188 |     |     }
 189 |     | 
 190 |     |     struct TxReturn {
 191 |     |         string internalType;
 192 |     |         string value;
 193 |     |     }
 194 |     | 
 195 |     |     struct Account {
 196 |     |         address addr;
 197 |     |         uint256 key;
 198 |     |     }
 199 |     | 
 200 |     |     enum AddressType {
 201 |     |         Payable,
 202 |     |         NonPayable,
 203 |     |         ZeroAddress,
 204 |     |         Precompile,
 205 |     |         ForgeAddress
 206 |     |     }
 207 |     | 
 208 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 209 |     |     function assumeNotBlacklisted(address token, address addr) internal view virtual {
 210 |     |         // Nothing to check if `token` is not a contract.
 211 |     |         uint256 tokenCodeSize;
 212 |     |         assembly {
 213 |     |             tokenCodeSize := extcodesize(token)
 214 |     |         }
 215 |     |         require(tokenCodeSize > 0, "StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.");
 216 |     | 
 217 |     |         bool success;
 218 |     |         bytes memory returnData;
 219 |     | 
 220 |     |         // 4-byte selector for `isBlacklisted(address)`, used by USDC.
 221 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));
 222 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 223 |     | 
 224 |     |         // 4-byte selector for `isBlackListed(address)`, used by USDT.
 225 |     |         (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));
 226 |     |         vm.assume(!success || abi.decode(returnData, (bool)) == false);
 227 |     |     }
 228 |     | 
 229 |     |     // Checks that `addr` is not blacklisted by token contracts that have a blacklist.
 230 |     |     // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for
 231 |     |     // backwards compatibility, since this name was used in the original PR which has already has
 232 |     |     // a release. This function can be removed in a future release once we want a breaking change.
 233 |     |     function assumeNoBlacklisted(address token, address addr) internal view virtual {
 234 |     |         assumeNotBlacklisted(token, addr);
 235 |     |     }
 236 |     | 
 237 |     |     function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {
 238 |     |         if (addressType == AddressType.Payable) {
 239 |     |             assumeNotPayable(addr);
 240 |     |         } else if (addressType == AddressType.NonPayable) {
 241 |     |             assumePayable(addr);
 242 |     |         } else if (addressType == AddressType.ZeroAddress) {
 243 |     |             assumeNotZeroAddress(addr);
 244 |     |         } else if (addressType == AddressType.Precompile) {
 245 |     |             assumeNotPrecompile(addr);
 246 |     |         } else if (addressType == AddressType.ForgeAddress) {
 247 |     |             assumeNotForgeAddress(addr);
 248 |     |         }
 249 |     |     }
 250 |     | 
 251 |     |     function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {
 252 |     |         assumeAddressIsNot(addr, addressType1);
 253 |     |         assumeAddressIsNot(addr, addressType2);
 254 |     |     }
 255 |     | 
 256 |     |     function assumeAddressIsNot(
 257 |     |         address addr,
 258 |     |         AddressType addressType1,
 259 |     |         AddressType addressType2,
 260 |     |         AddressType addressType3
 261 |     |     ) internal virtual {
 262 |     |         assumeAddressIsNot(addr, addressType1);
 263 |     |         assumeAddressIsNot(addr, addressType2);
 264 |     |         assumeAddressIsNot(addr, addressType3);
 265 |     |     }
 266 |     | 
 267 |     |     function assumeAddressIsNot(
 268 |     |         address addr,
 269 |     |         AddressType addressType1,
 270 |     |         AddressType addressType2,
 271 |     |         AddressType addressType3,
 272 |     |         AddressType addressType4
 273 |     |     ) internal virtual {
 274 |     |         assumeAddressIsNot(addr, addressType1);
 275 |     |         assumeAddressIsNot(addr, addressType2);
 276 |     |         assumeAddressIsNot(addr, addressType3);
 277 |     |         assumeAddressIsNot(addr, addressType4);
 278 |     |     }
 279 |     | 
 280 |     |     // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to
 281 |     |     // `addr` and checking the `success` return value.
 282 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 283 |     |     // implemented by `addr`, which should be taken into account when this function is used.
 284 |     |     function _isPayable(address addr) private returns (bool) {
 285 |     |         require(
 286 |     |             addr.balance < UINT256_MAX,
 287 |     |             "StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds"
 288 |     |         );
 289 |     |         uint256 origBalanceTest = address(this).balance;
 290 |     |         uint256 origBalanceAddr = address(addr).balance;
 291 |     | 
 292 |     |         vm.deal(address(this), 1);
 293 |     |         (bool success,) = payable(addr).call{value: 1}("");
 294 |     | 
 295 |     |         // reset balances
 296 |     |         vm.deal(address(this), origBalanceTest);
 297 |     |         vm.deal(addr, origBalanceAddr);
 298 |     | 
 299 |     |         return success;
 300 |     |     }
 301 |     | 
 302 |     |     // NOTE: This function may result in state changes depending on the fallback/receive logic
 303 |     |     // implemented by `addr`, which should be taken into account when this function is used. See the
 304 |     |     // `_isPayable` method for more information.
 305 |     |     function assumePayable(address addr) internal virtual {
 306 |     |         vm.assume(_isPayable(addr));
 307 |     |     }
 308 |     | 
 309 |     |     function assumeNotPayable(address addr) internal virtual {
 310 |     |         vm.assume(!_isPayable(addr));
 311 |     |     }
 312 |     | 
 313 |     |     function assumeNotZeroAddress(address addr) internal pure virtual {
 314 |     |         vm.assume(addr != address(0));
 315 |     |     }
 316 |     | 
 317 |     |     function assumeNotPrecompile(address addr) internal pure virtual {
 318 |     |         assumeNotPrecompile(addr, _pureChainId());
 319 |     |     }
 320 |     | 
 321 |     |     function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {
 322 |     |         // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific
 323 |     |         // address), but the same rationale for excluding them applies so we include those too.
 324 |     | 
 325 |     |         // These should be present on all EVM-compatible chains.
 326 |     |         vm.assume(addr < address(0x1) || addr > address(0x9));
 327 |     | 
 328 |     |         // forgefmt: disable-start
 329 |     |         if (chainId == 10 || chainId == 420) {
 330 |     |             // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21
 331 |     |             vm.assume(addr < address(0x4200000000000000000000000000000000000000) || addr > address(0x4200000000000000000000000000000000000800));
 332 |     |         } else if (chainId == 42161 || chainId == 421613) {
 333 |     |             // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains
 334 |     |             vm.assume(addr < address(0x0000000000000000000000000000000000000064) || addr > address(0x0000000000000000000000000000000000000068));
 335 |     |         } else if (chainId == 43114 || chainId == 43113) {
 336 |     |             // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59
 337 |     |             vm.assume(addr < address(0x0100000000000000000000000000000000000000) || addr > address(0x01000000000000000000000000000000000000ff));
 338 |     |             vm.assume(addr < address(0x0200000000000000000000000000000000000000) || addr > address(0x02000000000000000000000000000000000000FF));
 339 |     |             vm.assume(addr < address(0x0300000000000000000000000000000000000000) || addr > address(0x03000000000000000000000000000000000000Ff));
 340 |     |         }
 341 |     |         // forgefmt: disable-end
 342 |     |     }
 343 |     | 
 344 |     |     function assumeNotForgeAddress(address addr) internal pure virtual {
 345 |     |         // vm, console, and Create2Deployer addresses
 346 |     |         vm.assume(
 347 |     |             addr != address(vm) && addr != 0x000000000000000000636F6e736F6c652e6c6f67
 348 |     |                 && addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C
 349 |     |         );
 350 |     |     }
 351 |     | 
 352 |     |     function readEIP1559ScriptArtifact(string memory path)
 353 |     |         internal
 354 |     |         view
 355 |     |         virtual
 356 |     |         returns (EIP1559ScriptArtifact memory)
 357 |     |     {
 358 |     |         string memory data = vm.readFile(path);
 359 |     |         bytes memory parsedData = vm.parseJson(data);
 360 |     |         RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));
 361 |     |         EIP1559ScriptArtifact memory artifact;
 362 |     |         artifact.libraries = rawArtifact.libraries;
 363 |     |         artifact.path = rawArtifact.path;
 364 |     |         artifact.timestamp = rawArtifact.timestamp;
 365 |     |         artifact.pending = rawArtifact.pending;
 366 |     |         artifact.txReturns = rawArtifact.txReturns;
 367 |     |         artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);
 368 |     |         artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);
 369 |     |         return artifact;
 370 |     |     }
 371 |     | 
 372 |     |     function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {
 373 |     |         Tx1559[] memory txs = new Tx1559[](rawTxs.length);
 374 |     |         for (uint256 i; i < rawTxs.length; i++) {
 375 |     |             txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);
 376 |     |         }
 377 |     |         return txs;
 378 |     |     }
 379 |     | 
 380 |     |     function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {
 381 |     |         Tx1559 memory transaction;
 382 |     |         transaction.arguments = rawTx.arguments;
 383 |     |         transaction.contractName = rawTx.contractName;
 384 |     |         transaction.functionSig = rawTx.functionSig;
 385 |     |         transaction.hash = rawTx.hash;
 386 |     |         transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);
 387 |     |         transaction.opcode = rawTx.opcode;
 388 |     |         return transaction;
 389 |     |     }
 390 |     | 
 391 |     |     function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)
 392 |     |         internal
 393 |     |         pure
 394 |     |         virtual
 395 |     |         returns (Tx1559Detail memory)
 396 |     |     {
 397 |     |         Tx1559Detail memory txDetail;
 398 |     |         txDetail.data = rawDetail.data;
 399 |     |         txDetail.from = rawDetail.from;
 400 |     |         txDetail.to = rawDetail.to;
 401 |     |         txDetail.nonce = _bytesToUint(rawDetail.nonce);
 402 |     |         txDetail.txType = _bytesToUint(rawDetail.txType);
 403 |     |         txDetail.value = _bytesToUint(rawDetail.value);
 404 |     |         txDetail.gas = _bytesToUint(rawDetail.gas);
 405 |     |         txDetail.accessList = rawDetail.accessList;
 406 |     |         return txDetail;
 407 |     |     }
 408 |     | 
 409 |     |     function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {
 410 |     |         string memory deployData = vm.readFile(path);
 411 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".transactions");
 412 |     |         RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));
 413 |     |         return rawToConvertedEIPTx1559s(rawTxs);
 414 |     |     }
 415 |     | 
 416 |     |     function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {
 417 |     |         string memory deployData = vm.readFile(path);
 418 |     |         string memory key = string(abi.encodePacked(".transactions[", vm.toString(index), "]"));
 419 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 420 |     |         RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));
 421 |     |         return rawToConvertedEIPTx1559(rawTx);
 422 |     |     }
 423 |     | 
 424 |     |     // Analogous to readTransactions, but for receipts.
 425 |     |     function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {
 426 |     |         string memory deployData = vm.readFile(path);
 427 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, ".receipts");
 428 |     |         RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));
 429 |     |         return rawToConvertedReceipts(rawReceipts);
 430 |     |     }
 431 |     | 
 432 |     |     function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {
 433 |     |         string memory deployData = vm.readFile(path);
 434 |     |         string memory key = string(abi.encodePacked(".receipts[", vm.toString(index), "]"));
 435 |     |         bytes memory parsedDeployData = vm.parseJson(deployData, key);
 436 |     |         RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));
 437 |     |         return rawToConvertedReceipt(rawReceipt);
 438 |     |     }
 439 |     | 
 440 |     |     function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {
 441 |     |         Receipt[] memory receipts = new Receipt[](rawReceipts.length);
 442 |     |         for (uint256 i; i < rawReceipts.length; i++) {
 443 |     |             receipts[i] = rawToConvertedReceipt(rawReceipts[i]);
 444 |     |         }
 445 |     |         return receipts;
 446 |     |     }
 447 |     | 
 448 |     |     function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {
 449 |     |         Receipt memory receipt;
 450 |     |         receipt.blockHash = rawReceipt.blockHash;
 451 |     |         receipt.to = rawReceipt.to;
 452 |     |         receipt.from = rawReceipt.from;
 453 |     |         receipt.contractAddress = rawReceipt.contractAddress;
 454 |     |         receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);
 455 |     |         receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);
 456 |     |         receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);
 457 |     |         receipt.status = _bytesToUint(rawReceipt.status);
 458 |     |         receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);
 459 |     |         receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);
 460 |     |         receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);
 461 |     |         receipt.logsBloom = rawReceipt.logsBloom;
 462 |     |         receipt.transactionHash = rawReceipt.transactionHash;
 463 |     |         return receipt;
 464 |     |     }
 465 |     | 
 466 |     |     function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)
 467 |     |         internal
 468 |     |         pure
 469 |     |         virtual
 470 |     |         returns (ReceiptLog[] memory)
 471 |     |     {
 472 |     |         ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);
 473 |     |         for (uint256 i; i < rawLogs.length; i++) {
 474 |     |             logs[i].logAddress = rawLogs[i].logAddress;
 475 |     |             logs[i].blockHash = rawLogs[i].blockHash;
 476 |     |             logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);
 477 |     |             logs[i].data = rawLogs[i].data;
 478 |     |             logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);
 479 |     |             logs[i].topics = rawLogs[i].topics;
 480 |     |             logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);
 481 |     |             logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);
 482 |     |             logs[i].removed = rawLogs[i].removed;
 483 |     |         }
 484 |     |         return logs;
 485 |     |     }
 486 |     | 
 487 |     |     // Deploy a contract by fetching the contract bytecode from
 488 |     |     // the artifacts directory
 489 |     |     // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`
 490 |     |     function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {
 491 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 492 |     |         /// @solidity memory-safe-assembly
 493 |     |         assembly {
 494 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 495 |     |         }
 496 |     | 
 497 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes): Deployment failed.");
 498 |     |     }
 499 |     | 
 500 |     |     function deployCode(string memory what) internal virtual returns (address addr) {
 501 |     |         bytes memory bytecode = vm.getCode(what);
 502 |     |         /// @solidity memory-safe-assembly
 503 |     |         assembly {
 504 |     |             addr := create(0, add(bytecode, 0x20), mload(bytecode))
 505 |     |         }
 506 |     | 
 507 |     |         require(addr != address(0), "StdCheats deployCode(string): Deployment failed.");
 508 |     |     }
 509 |     | 
 510 |     |     /// @dev deploy contract with value on construction
 511 |     |     function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {
 512 |     |         bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);
 513 |     |         /// @solidity memory-safe-assembly
 514 |     |         assembly {
 515 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 516 |     |         }
 517 |     | 
 518 |     |         require(addr != address(0), "StdCheats deployCode(string,bytes,uint256): Deployment failed.");
 519 |     |     }
 520 |     | 
 521 |     |     function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {
 522 |     |         bytes memory bytecode = vm.getCode(what);
 523 |     |         /// @solidity memory-safe-assembly
 524 |     |         assembly {
 525 |     |             addr := create(val, add(bytecode, 0x20), mload(bytecode))
 526 |     |         }
 527 |     | 
 528 |     |         require(addr != address(0), "StdCheats deployCode(string,uint256): Deployment failed.");
 529 |     |     }
 530 |     | 
 531 |     |     // creates a labeled address and the corresponding private key
 532 |     |     function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {
 533 |     |         privateKey = uint256(keccak256(abi.encodePacked(name)));
 534 |     |         addr = vm.addr(privateKey);
 535 |     |         vm.label(addr, name);
 536 |     |     }
 537 |     | 
 538 |     |     // creates a labeled address
 539 |     |     function makeAddr(string memory name) internal virtual returns (address addr) {
 540 |     |         (addr,) = makeAddrAndKey(name);
 541 |     |     }
 542 |     | 
 543 |     |     // Destroys an account immediately, sending the balance to beneficiary.
 544 |     |     // Destroying means: balance will be zero, code will be empty, and nonce will be 0
 545 |     |     // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce
 546 |     |     // only after tx ends, this will run immediately.
 547 |     |     function destroyAccount(address who, address beneficiary) internal virtual {
 548 |     |         uint256 currBalance = who.balance;
 549 |     |         vm.etch(who, abi.encode());
 550 |     |         vm.deal(who, 0);
 551 |     |         vm.resetNonce(who);
 552 |     | 
 553 |     |         uint256 beneficiaryBalance = beneficiary.balance;
 554 |     |         vm.deal(beneficiary, currBalance + beneficiaryBalance);
 555 |     |     }
 556 |     | 
 557 |     |     // creates a struct containing both a labeled address and the corresponding private key
 558 |     |     function makeAccount(string memory name) internal virtual returns (Account memory account) {
 559 |     |         (account.addr, account.key) = makeAddrAndKey(name);
 560 |     |     }
 561 |     | 
 562 |     |     function deriveRememberKey(string memory mnemonic, uint32 index)
 563 |     |         internal
 564 |     |         virtual
 565 |     |         returns (address who, uint256 privateKey)
 566 |     |     {
 567 |     |         privateKey = vm.deriveKey(mnemonic, index);
 568 |     |         who = vm.rememberKey(privateKey);
 569 |     |     }
 570 |     | 
 571 |     |     function _bytesToUint(bytes memory b) private pure returns (uint256) {
 572 |     |         require(b.length <= 32, "StdCheats _bytesToUint(bytes): Bytes length exceeds 32.");
 573 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
 574 |     |     }
 575 |     | 
 576 |     |     function isFork() internal view virtual returns (bool status) {
 577 |     |         try vm.activeFork() {
 578 |     |             status = true;
 579 |     |         } catch (bytes memory) {}
 580 |     |     }
 581 |     | 
 582 |     |     modifier skipWhenForking() {
 583 |     |         if (!isFork()) {
 584 |     |             _;
 585 |     |         }
 586 |     |     }
 587 |     | 
 588 |     |     modifier skipWhenNotForking() {
 589 |     |         if (isFork()) {
 590 |     |             _;
 591 |     |         }
 592 |     |     }
 593 |     | 
 594 |     |     modifier noGasMetering() {
 595 |     |         vm.pauseGasMetering();
 596 |     |         // To prevent turning gas monitoring back on with nested functions that use this modifier,
 597 |     |         // we check if gasMetering started in the off position. If it did, we don't want to turn
 598 |     |         // it back on until we exit the top level function that used the modifier
 599 |     |         //
 600 |     |         // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.
 601 |     |         // funcA will have `gasStartedOff` as false, funcB will have it as true,
 602 |     |         // so we only turn metering back on at the end of the funcA
 603 |     |         bool gasStartedOff = gasMeteringOff;
 604 |     |         gasMeteringOff = true;
 605 |     | 
 606 |     |         _;
 607 |     | 
 608 |     |         // if gas metering was on when this modifier was called, turn it back on at the end
 609 |     |         if (!gasStartedOff) {
 610 |     |             gasMeteringOff = false;
 611 |     |             vm.resumeGasMetering();
 612 |     |         }
 613 |     |     }
 614 |     | 
 615 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 616 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 617 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 618 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 619 |     |     function _viewChainId() private view returns (uint256 chainId) {
 620 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 621 |     |         assembly {
 622 |     |             chainId := chainid()
 623 |     |         }
 624 |     | 
 625 |     |         address(this); // Silence warnings in older Solc versions.
 626 |     |     }
 627 |     | 
 628 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 629 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 630 |     |         function() internal pure returns (uint256) pureChainId;
 631 |     |         assembly {
 632 |     |             pureChainId := fnIn
 633 |     |         }
 634 |     |         chainId = pureChainId();
 635 |     |     }
 636 |     | }
 637 |     | 
 638 |     | // Wrappers around cheatcodes to avoid footguns
 639 |     | abstract contract StdCheats is StdCheatsSafe {
 640 |     |     using stdStorage for StdStorage;
 641 |     | 
 642 |     |     StdStorage private stdstore;
 643 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 644 |     |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
 645 |     | 
 646 |     |     // Skip forward or rewind time by the specified number of seconds
 647 |     |     function skip(uint256 time) internal virtual {
 648 |     |         vm.warp(block.timestamp + time);
 649 |     |     }
 650 |     | 
 651 |     |     function rewind(uint256 time) internal virtual {
 652 |     |         vm.warp(block.timestamp - time);
 653 |     |     }
 654 |     | 
 655 |     |     // Setup a prank from an address that has some ether
 656 |     |     function hoax(address msgSender) internal virtual {
 657 |     |         vm.deal(msgSender, 1 << 128);
 658 |     |         vm.prank(msgSender);
 659 |     |     }
 660 |     | 
 661 |     |     function hoax(address msgSender, uint256 give) internal virtual {
 662 |     |         vm.deal(msgSender, give);
 663 |     |         vm.prank(msgSender);
 664 |     |     }
 665 |     | 
 666 |     |     function hoax(address msgSender, address origin) internal virtual {
 667 |     |         vm.deal(msgSender, 1 << 128);
 668 |     |         vm.prank(msgSender, origin);
 669 |     |     }
 670 |     | 
 671 |     |     function hoax(address msgSender, address origin, uint256 give) internal virtual {
 672 |     |         vm.deal(msgSender, give);
 673 |     |         vm.prank(msgSender, origin);
 674 |     |     }
 675 |     | 
 676 |     |     // Start perpetual prank from an address that has some ether
 677 |     |     function startHoax(address msgSender) internal virtual {
 678 |     |         vm.deal(msgSender, 1 << 128);
 679 |     |         vm.startPrank(msgSender);
 680 |     |     }
 681 |     | 
 682 |     |     function startHoax(address msgSender, uint256 give) internal virtual {
 683 |     |         vm.deal(msgSender, give);
 684 |     |         vm.startPrank(msgSender);
 685 |     |     }
 686 |     | 
 687 |     |     // Start perpetual prank from an address that has some ether
 688 |     |     // tx.origin is set to the origin parameter
 689 |     |     function startHoax(address msgSender, address origin) internal virtual {
 690 |     |         vm.deal(msgSender, 1 << 128);
 691 |     |         vm.startPrank(msgSender, origin);
 692 |     |     }
 693 |     | 
 694 |     |     function startHoax(address msgSender, address origin, uint256 give) internal virtual {
 695 |     |         vm.deal(msgSender, give);
 696 |     |         vm.startPrank(msgSender, origin);
 697 |     |     }
 698 |     | 
 699 |     |     function changePrank(address msgSender) internal virtual {
 700 |     |         console2_log_StdCheats("changePrank is deprecated. Please use vm.startPrank instead.");
 701 |     |         vm.stopPrank();
 702 |     |         vm.startPrank(msgSender);
 703 |     |     }
 704 |     | 
 705 |     |     function changePrank(address msgSender, address txOrigin) internal virtual {
 706 |     |         vm.stopPrank();
 707 |     |         vm.startPrank(msgSender, txOrigin);
 708 |     |     }
 709 |     | 
 710 |     |     // The same as Vm's `deal`
 711 |     |     // Use the alternative signature for ERC20 tokens
 712 |     |     function deal(address to, uint256 give) internal virtual {
 713 |     |         vm.deal(to, give);
 714 |     |     }
 715 |     | 
 716 |     |     // Set the balance of an account for any ERC20 token
 717 |     |     // Use the alternative signature to update `totalSupply`
 718 |     |     function deal(address token, address to, uint256 give) internal virtual {
 719 |     |         deal(token, to, give, false);
 720 |     |     }
 721 |     | 
 722 |     |     // Set the balance of an account for any ERC1155 token
 723 |     |     // Use the alternative signature to update `totalSupply`
 724 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {
 725 |     |         dealERC1155(token, to, id, give, false);
 726 |     |     }
 727 |     | 
 728 |     |     function deal(address token, address to, uint256 give, bool adjust) internal virtual {
 729 |     |         // get current balance
 730 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 731 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 732 |     | 
 733 |     |         // update balance
 734 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);
 735 |     | 
 736 |     |         // update total supply
 737 |     |         if (adjust) {
 738 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));
 739 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 740 |     |             if (give < prevBal) {
 741 |     |                 totSup -= (prevBal - give);
 742 |     |             } else {
 743 |     |                 totSup += (give - prevBal);
 744 |     |             }
 745 |     |             stdstore.target(token).sig(0x18160ddd).checked_write(totSup);
 746 |     |         }
 747 |     |     }
 748 |     | 
 749 |     |     function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {
 750 |     |         // get current balance
 751 |     |         (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));
 752 |     |         uint256 prevBal = abi.decode(balData, (uint256));
 753 |     | 
 754 |     |         // update balance
 755 |     |         stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);
 756 |     | 
 757 |     |         // update total supply
 758 |     |         if (adjust) {
 759 |     |             (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));
 760 |     |             require(
 761 |     |                 totSupData.length != 0,
 762 |     |                 "StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply."
 763 |     |             );
 764 |     |             uint256 totSup = abi.decode(totSupData, (uint256));
 765 |     |             if (give < prevBal) {
 766 |     |                 totSup -= (prevBal - give);
 767 |     |             } else {
 768 |     |                 totSup += (give - prevBal);
 769 |     |             }
 770 |     |             stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);
 771 |     |         }
 772 |     |     }
 773 |     | 
 774 |     |     function dealERC721(address token, address to, uint256 id) internal virtual {
 775 |     |         // check if token id is already minted and the actual owner.
 776 |     |         (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));
 777 |     |         require(successMinted, "StdCheats deal(address,address,uint,bool): id not minted.");
 778 |     | 
 779 |     |         // get owner current balance
 780 |     |         (, bytes memory fromBalData) =
 781 |     |             token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));
 782 |     |         uint256 fromPrevBal = abi.decode(fromBalData, (uint256));
 783 |     | 
 784 |     |         // get new user current balance
 785 |     |         (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));
 786 |     |         uint256 toPrevBal = abi.decode(toBalData, (uint256));
 787 |     | 
 788 |     |         // update balances
 789 |     |         stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);
 790 |     |         stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);
 791 |     | 
 792 |     |         // update owner
 793 |     |         stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);
 794 |     |     }
 795 |     | 
 796 |     |     function deployCodeTo(string memory what, address where) internal virtual {
 797 |     |         deployCodeTo(what, "", 0, where);
 798 |     |     }
 799 |     | 
 800 |     |     function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {
 801 |     |         deployCodeTo(what, args, 0, where);
 802 |     |     }
 803 |     | 
 804 |     |     function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {
 805 |     |         bytes memory creationCode = vm.getCode(what);
 806 |     |         vm.etch(where, abi.encodePacked(creationCode, args));
 807 |     |         (bool success, bytes memory runtimeBytecode) = where.call{value: value}("");
 808 |     |         require(success, "StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.");
 809 |     |         vm.etch(where, runtimeBytecode);
 810 |     |     }
 811 |     | 
 812 |     |     // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.
 813 |     |     function console2_log_StdCheats(string memory p0) private view {
 814 |     |         (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature("log(string)", p0));
 815 |     |         status;
 816 |     |     }
 817 |     | }
 818 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdError.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // Panics work for versions >=0.8.0, but we lowered the pragma to make this compatible with Test
  3 |     | pragma solidity >=0.6.2 <0.9.0;
  4 |     | 
  5 |     | library stdError {
  6 |     |     bytes public constant assertionError = abi.encodeWithSignature("Panic(uint256)", 0x01);
  7 |     |     bytes public constant arithmeticError = abi.encodeWithSignature("Panic(uint256)", 0x11);
  8 |     |     bytes public constant divisionError = abi.encodeWithSignature("Panic(uint256)", 0x12);
  9 |     |     bytes public constant enumConversionError = abi.encodeWithSignature("Panic(uint256)", 0x21);
 10 |     |     bytes public constant encodeStorageError = abi.encodeWithSignature("Panic(uint256)", 0x22);
 11 |     |     bytes public constant popError = abi.encodeWithSignature("Panic(uint256)", 0x31);
 12 |     |     bytes public constant indexOOBError = abi.encodeWithSignature("Panic(uint256)", 0x32);
 13 |     |     bytes public constant memOverflowError = abi.encodeWithSignature("Panic(uint256)", 0x41);
 14 |     |     bytes public constant zeroVarError = abi.encodeWithSignature("Panic(uint256)", 0x51);
 15 |     | }
 16 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdInvariant.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | abstract contract StdInvariant {
   7 |     |     struct FuzzSelector {
   8 |     |         address addr;
   9 |     |         bytes4[] selectors;
  10 |     |     }
  11 |     | 
  12 |     |     struct FuzzArtifactSelector {
  13 |     |         string artifact;
  14 |     |         bytes4[] selectors;
  15 |     |     }
  16 |     | 
  17 |     |     struct FuzzInterface {
  18 |     |         address addr;
  19 |     |         string[] artifacts;
  20 |     |     }
  21 |     | 
  22 |     |     address[] private _excludedContracts;
  23 |     |     address[] private _excludedSenders;
  24 |     |     address[] private _targetedContracts;
  25 |     |     address[] private _targetedSenders;
  26 |     | 
  27 |     |     string[] private _excludedArtifacts;
  28 |     |     string[] private _targetedArtifacts;
  29 |     | 
  30 |     |     FuzzArtifactSelector[] private _targetedArtifactSelectors;
  31 |     | 
  32 |     |     FuzzSelector[] private _excludedSelectors;
  33 |     |     FuzzSelector[] private _targetedSelectors;
  34 |     | 
  35 |     |     FuzzInterface[] private _targetedInterfaces;
  36 |     | 
  37 |     |     // Functions for users:
  38 |     |     // These are intended to be called in tests.
  39 |     | 
  40 |     |     function excludeContract(address newExcludedContract_) internal {
  41 |     |         _excludedContracts.push(newExcludedContract_);
  42 |     |     }
  43 |     | 
  44 |     |     function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {
  45 |     |         _excludedSelectors.push(newExcludedSelector_);
  46 |     |     }
  47 |     | 
  48 |     |     function excludeSender(address newExcludedSender_) internal {
  49 |     |         _excludedSenders.push(newExcludedSender_);
  50 |     |     }
  51 |     | 
  52 |     |     function excludeArtifact(string memory newExcludedArtifact_) internal {
  53 |     |         _excludedArtifacts.push(newExcludedArtifact_);
  54 |     |     }
  55 |     | 
  56 |     |     function targetArtifact(string memory newTargetedArtifact_) internal {
  57 |     |         _targetedArtifacts.push(newTargetedArtifact_);
  58 |     |     }
  59 |     | 
  60 |     |     function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {
  61 |     |         _targetedArtifactSelectors.push(newTargetedArtifactSelector_);
  62 |     |     }
  63 |     | 
  64 |     |     function targetContract(address newTargetedContract_) internal {
  65 |     |         _targetedContracts.push(newTargetedContract_);
  66 |     |     }
  67 |     | 
  68 |     |     function targetSelector(FuzzSelector memory newTargetedSelector_) internal {
  69 |     |         _targetedSelectors.push(newTargetedSelector_);
  70 |     |     }
  71 |     | 
  72 |     |     function targetSender(address newTargetedSender_) internal {
  73 |     |         _targetedSenders.push(newTargetedSender_);
  74 |     |     }
  75 |     | 
  76 |     |     function targetInterface(FuzzInterface memory newTargetedInterface_) internal {
  77 |     |         _targetedInterfaces.push(newTargetedInterface_);
  78 |     |     }
  79 |     | 
  80 |     |     // Functions for forge:
  81 |     |     // These are called by forge to run invariant tests and don't need to be called in tests.
  82 |     | 
  83 | *   |     function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {
  84 | *   |         excludedArtifacts_ = _excludedArtifacts;
  85 |     |     }
  86 |     | 
  87 | *   |     function excludeContracts() public view returns (address[] memory excludedContracts_) {
  88 | *   |         excludedContracts_ = _excludedContracts;
  89 |     |     }
  90 |     | 
  91 | *   |     function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {
  92 | *   |         excludedSelectors_ = _excludedSelectors;
  93 |     |     }
  94 |     | 
  95 | *   |     function excludeSenders() public view returns (address[] memory excludedSenders_) {
  96 | *   |         excludedSenders_ = _excludedSenders;
  97 |     |     }
  98 |     | 
  99 | *   |     function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {
 100 | *   |         targetedArtifacts_ = _targetedArtifacts;
 101 |     |     }
 102 |     | 
 103 | *   |     function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {
 104 | *   |         targetedArtifactSelectors_ = _targetedArtifactSelectors;
 105 |     |     }
 106 |     | 
 107 | *   |     function targetContracts() public view returns (address[] memory targetedContracts_) {
 108 | *   |         targetedContracts_ = _targetedContracts;
 109 |     |     }
 110 |     | 
 111 | *   |     function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {
 112 | *   |         targetedSelectors_ = _targetedSelectors;
 113 |     |     }
 114 |     | 
 115 | *   |     function targetSenders() public view returns (address[] memory targetedSenders_) {
 116 | *   |         targetedSenders_ = _targetedSenders;
 117 |     |     }
 118 |     | 
 119 | *   |     function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {
 120 | *   |         targetedInterfaces_ = _targetedInterfaces;
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdJson.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing JSON files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdJson for string;
  12 |     | // string memory json = vm.readFile("<some_path>");
  13 |     | // json.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdJson for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdJson {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {
  29 |     |         return vm.parseJson(json, key);
  30 |     |     }
  31 |     | 
  32 |     |     function readUint(string memory json, string memory key) internal pure returns (uint256) {
  33 |     |         return vm.parseJsonUint(json, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {
  37 |     |         return vm.parseJsonUintArray(json, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readInt(string memory json, string memory key) internal pure returns (int256) {
  41 |     |         return vm.parseJsonInt(json, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {
  45 |     |         return vm.parseJsonIntArray(json, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {
  49 |     |         return vm.parseJsonBytes32(json, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {
  53 |     |         return vm.parseJsonBytes32Array(json, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readString(string memory json, string memory key) internal pure returns (string memory) {
  57 |     |         return vm.parseJsonString(json, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {
  61 |     |         return vm.parseJsonStringArray(json, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readAddress(string memory json, string memory key) internal pure returns (address) {
  65 |     |         return vm.parseJsonAddress(json, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {
  69 |     |         return vm.parseJsonAddressArray(json, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readBool(string memory json, string memory key) internal pure returns (bool) {
  73 |     |         return vm.parseJsonBool(json, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {
  77 |     |         return vm.parseJsonBoolArray(json, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {
  81 |     |         return vm.parseJsonBytes(json, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {
  85 |     |         return vm.parseJsonBytesArray(json, key);
  86 |     |     }
  87 |     | 
  88 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
  89 |     |         return vm.serializeJson(jsonKey, rootObject);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeJson(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeJson(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | library stdMath {
  5 |     |     int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;
  6 |     | 
  7 |     |     function abs(int256 a) internal pure returns (uint256) {
  8 |     |         // Required or it will fail when `a = type(int256).min`
  9 |     |         if (a == INT256_MIN) {
 10 |     |             return 57896044618658097711785492504343953926634992332820282019728792003956564819968;
 11 |     |         }
 12 |     | 
 13 |     |         return uint256(a > 0 ? a : -a);
 14 |     |     }
 15 |     | 
 16 |     |     function delta(uint256 a, uint256 b) internal pure returns (uint256) {
 17 |     |         return a > b ? a - b : b - a;
 18 |     |     }
 19 |     | 
 20 |     |     function delta(int256 a, int256 b) internal pure returns (uint256) {
 21 |     |         // a and b are of the same sign
 22 |     |         // this works thanks to two's complement, the left-most bit is the sign bit
 23 |     |         if ((a ^ b) > -1) {
 24 |     |             return delta(abs(a), abs(b));
 25 |     |         }
 26 |     | 
 27 |     |         // a and b are of opposite signs
 28 |     |         return abs(a) + abs(b);
 29 |     |     }
 30 |     | 
 31 |     |     function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {
 32 |     |         uint256 absDelta = delta(a, b);
 33 |     | 
 34 |     |         return absDelta * 1e18 / b;
 35 |     |     }
 36 |     | 
 37 |     |     function percentDelta(int256 a, int256 b) internal pure returns (uint256) {
 38 |     |         uint256 absDelta = delta(a, b);
 39 |     |         uint256 absB = abs(b);
 40 |     | 
 41 |     |         return absDelta * 1e18 / absB;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdStorage.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {Vm} from "./Vm.sol";
   5 |     | 
   6 |     | struct FindData {
   7 |     |     uint256 slot;
   8 |     |     uint256 offsetLeft;
   9 |     |     uint256 offsetRight;
  10 |     |     bool found;
  11 |     | }
  12 |     | 
  13 |     | struct StdStorage {
  14 |     |     mapping(address => mapping(bytes4 => mapping(bytes32 => FindData))) finds;
  15 |     |     bytes32[] _keys;
  16 |     |     bytes4 _sig;
  17 |     |     uint256 _depth;
  18 |     |     address _target;
  19 |     |     bytes32 _set;
  20 |     |     bool _enable_packed_slots;
  21 |     |     bytes _calldata;
  22 |     | }
  23 |     | 
  24 |     | library stdStorageSafe {
  25 |     |     event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);
  26 |     |     event WARNING_UninitedSlot(address who, uint256 slot);
  27 |     | 
  28 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
  29 |     |     uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;
  30 |     | 
  31 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
  32 |     |         return bytes4(keccak256(bytes(sigStr)));
  33 |     |     }
  34 |     | 
  35 |     |     function getCallParams(StdStorage storage self) internal view returns (bytes memory) {
  36 |     |         if (self._calldata.length == 0) {
  37 |     |             return flatten(self._keys);
  38 |     |         } else {
  39 |     |             return self._calldata;
  40 |     |         }
  41 |     |     }
  42 |     | 
  43 |     |     // Calls target contract with configured parameters
  44 |     |     function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {
  45 |     |         bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));
  46 |     |         (bool success, bytes memory rdat) = self._target.staticcall(cald);
  47 |     |         bytes32 result = bytesToBytes32(rdat, 32 * self._depth);
  48 |     | 
  49 |     |         return (success, result);
  50 |     |     }
  51 |     | 
  52 |     |     // Tries mutating slot value to determine if the targeted value is stored in it.
  53 |     |     // If current value is 0, then we are setting slot value to type(uint256).max
  54 |     |     // Otherwise, we set it to 0. That way, return value should always be affected.
  55 |     |     function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {
  56 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  57 |     |         (bool success, bytes32 prevReturnValue) = callTarget(self);
  58 |     | 
  59 |     |         bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);
  60 |     |         vm.store(self._target, slot, testVal);
  61 |     | 
  62 |     |         (, bytes32 newReturnValue) = callTarget(self);
  63 |     | 
  64 |     |         vm.store(self._target, slot, prevSlotValue);
  65 |     | 
  66 |     |         return (success && (prevReturnValue != newReturnValue));
  67 |     |     }
  68 |     | 
  69 |     |     // Tries setting one of the bits in slot to 1 until return value changes.
  70 |     |     // Index of resulted bit is an offset packed slot has from left/right side
  71 |     |     function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {
  72 |     |         for (uint256 offset = 0; offset < 256; offset++) {
  73 |     |             uint256 valueToPut = left ? (1 << (255 - offset)) : (1 << offset);
  74 |     |             vm.store(self._target, slot, bytes32(valueToPut));
  75 |     | 
  76 |     |             (bool success, bytes32 data) = callTarget(self);
  77 |     | 
  78 |     |             if (success && (uint256(data) > 0)) {
  79 |     |                 return (true, offset);
  80 |     |             }
  81 |     |         }
  82 |     |         return (false, 0);
  83 |     |     }
  84 |     | 
  85 |     |     function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {
  86 |     |         bytes32 prevSlotValue = vm.load(self._target, slot);
  87 |     | 
  88 |     |         (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);
  89 |     |         (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);
  90 |     | 
  91 |     |         // `findOffset` may mutate slot value, so we are setting it to initial value
  92 |     |         vm.store(self._target, slot, prevSlotValue);
  93 |     |         return (foundLeft && foundRight, offsetLeft, offsetRight);
  94 |     |     }
  95 |     | 
  96 |     |     function find(StdStorage storage self) internal returns (FindData storage) {
  97 |     |         return find(self, true);
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against
 101 |     |     // slot complexity:
 102 |     |     //  if flat, will be bytes32(uint256(uint));
 103 |     |     //  if map, will be keccak256(abi.encode(key, uint(slot)));
 104 |     |     //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));
 105 |     |     //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);
 106 |     |     function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {
 107 |     |         address who = self._target;
 108 |     |         bytes4 fsig = self._sig;
 109 |     |         uint256 field_depth = self._depth;
 110 |     |         bytes memory params = getCallParams(self);
 111 |     | 
 112 |     |         // calldata to test against
 113 |     |         if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 114 |     |             if (_clear) {
 115 |     |                 clear(self);
 116 |     |             }
 117 |     |             return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 118 |     |         }
 119 |     |         vm.record();
 120 |     |         (, bytes32 callResult) = callTarget(self);
 121 |     |         (bytes32[] memory reads,) = vm.accesses(address(who));
 122 |     | 
 123 |     |         if (reads.length == 0) {
 124 |     |             revert("stdStorage find(StdStorage): No storage use detected for target.");
 125 |     |         } else {
 126 |     |             for (uint256 i = 0; i < reads.length; i++) {
 127 |     |                 bytes32 prev = vm.load(who, reads[i]);
 128 |     |                 if (prev == bytes32(0)) {
 129 |     |                     emit WARNING_UninitedSlot(who, uint256(reads[i]));
 130 |     |                 }
 131 |     | 
 132 |     |                 if (!checkSlotMutatesCall(self, reads[i])) {
 133 |     |                     continue;
 134 |     |                 }
 135 |     | 
 136 |     |                 (uint256 offsetLeft, uint256 offsetRight) = (0, 0);
 137 |     | 
 138 |     |                 if (self._enable_packed_slots) {
 139 |     |                     bool found;
 140 |     |                     (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);
 141 |     |                     if (!found) {
 142 |     |                         continue;
 143 |     |                     }
 144 |     |                 }
 145 |     | 
 146 |     |                 // Check that value between found offsets is equal to the current call result
 147 |     |                 uint256 curVal = (uint256(prev) & getMaskByOffsets(offsetLeft, offsetRight)) >> offsetRight;
 148 |     | 
 149 |     |                 if (uint256(callResult) != curVal) {
 150 |     |                     continue;
 151 |     |                 }
 152 |     | 
 153 |     |                 emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));
 154 |     |                 self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =
 155 |     |                     FindData(uint256(reads[i]), offsetLeft, offsetRight, true);
 156 |     |                 break;
 157 |     |             }
 158 |     |         }
 159 |     | 
 160 |     |         require(
 161 |     |             self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,
 162 |     |             "stdStorage find(StdStorage): Slot(s) not found."
 163 |     |         );
 164 |     | 
 165 |     |         if (_clear) {
 166 |     |             clear(self);
 167 |     |         }
 168 |     |         return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 169 |     |     }
 170 |     | 
 171 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 172 |     |         self._target = _target;
 173 |     |         return self;
 174 |     |     }
 175 |     | 
 176 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 177 |     |         self._sig = _sig;
 178 |     |         return self;
 179 |     |     }
 180 |     | 
 181 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 182 |     |         self._sig = sigs(_sig);
 183 |     |         return self;
 184 |     |     }
 185 |     | 
 186 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 187 |     |         self._calldata = _calldata;
 188 |     |         return self;
 189 |     |     }
 190 |     | 
 191 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 192 |     |         self._keys.push(bytes32(uint256(uint160(who))));
 193 |     |         return self;
 194 |     |     }
 195 |     | 
 196 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 197 |     |         self._keys.push(bytes32(amt));
 198 |     |         return self;
 199 |     |     }
 200 |     | 
 201 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 202 |     |         self._keys.push(key);
 203 |     |         return self;
 204 |     |     }
 205 |     | 
 206 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 207 |     |         self._enable_packed_slots = true;
 208 |     |         return self;
 209 |     |     }
 210 |     | 
 211 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 212 |     |         self._depth = _depth;
 213 |     |         return self;
 214 |     |     }
 215 |     | 
 216 |     |     function read(StdStorage storage self) private returns (bytes memory) {
 217 |     |         FindData storage data = find(self, false);
 218 |     |         uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);
 219 |     |         uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) & mask) >> data.offsetRight;
 220 |     |         clear(self);
 221 |     |         return abi.encode(value);
 222 |     |     }
 223 |     | 
 224 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 225 |     |         return abi.decode(read(self), (bytes32));
 226 |     |     }
 227 |     | 
 228 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 229 |     |         int256 v = read_int(self);
 230 |     |         if (v == 0) return false;
 231 |     |         if (v == 1) return true;
 232 |     |         revert("stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.");
 233 |     |     }
 234 |     | 
 235 |     |     function read_address(StdStorage storage self) internal returns (address) {
 236 |     |         return abi.decode(read(self), (address));
 237 |     |     }
 238 |     | 
 239 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 240 |     |         return abi.decode(read(self), (uint256));
 241 |     |     }
 242 |     | 
 243 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 244 |     |         return abi.decode(read(self), (int256));
 245 |     |     }
 246 |     | 
 247 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 248 |     |         address who = self._target;
 249 |     |         uint256 field_depth = self._depth;
 250 |     |         vm.startMappingRecording();
 251 |     |         uint256 child = find(self, true).slot - field_depth;
 252 |     |         (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 253 |     |         if (!found) {
 254 |     |             revert(
 255 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 256 |     |             );
 257 |     |         }
 258 |     |         return (uint256(parent_slot), key);
 259 |     |     }
 260 |     | 
 261 |     |     function root(StdStorage storage self) internal returns (uint256) {
 262 |     |         address who = self._target;
 263 |     |         uint256 field_depth = self._depth;
 264 |     |         vm.startMappingRecording();
 265 |     |         uint256 child = find(self, true).slot - field_depth;
 266 |     |         bool found;
 267 |     |         bytes32 root_slot;
 268 |     |         bytes32 parent_slot;
 269 |     |         (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));
 270 |     |         if (!found) {
 271 |     |             revert(
 272 |     |                 "stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called."
 273 |     |             );
 274 |     |         }
 275 |     |         while (found) {
 276 |     |             root_slot = parent_slot;
 277 |     |             (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));
 278 |     |         }
 279 |     |         return uint256(root_slot);
 280 |     |     }
 281 |     | 
 282 |     |     function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {
 283 |     |         bytes32 out;
 284 |     | 
 285 |     |         uint256 max = b.length > 32 ? 32 : b.length;
 286 |     |         for (uint256 i = 0; i < max; i++) {
 287 |     |             out |= bytes32(b[offset + i] & 0xFF) >> (i * 8);
 288 |     |         }
 289 |     |         return out;
 290 |     |     }
 291 |     | 
 292 |     |     function flatten(bytes32[] memory b) private pure returns (bytes memory) {
 293 |     |         bytes memory result = new bytes(b.length * 32);
 294 |     |         for (uint256 i = 0; i < b.length; i++) {
 295 |     |             bytes32 k = b[i];
 296 |     |             /// @solidity memory-safe-assembly
 297 |     |             assembly {
 298 |     |                 mstore(add(result, add(32, mul(32, i))), k)
 299 |     |             }
 300 |     |         }
 301 |     | 
 302 |     |         return result;
 303 |     |     }
 304 |     | 
 305 |     |     function clear(StdStorage storage self) internal {
 306 |     |         delete self._target;
 307 |     |         delete self._sig;
 308 |     |         delete self._keys;
 309 |     |         delete self._depth;
 310 |     |         delete self._enable_packed_slots;
 311 |     |         delete self._calldata;
 312 |     |     }
 313 |     | 
 314 |     |     // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`
 315 |     |     // (slotValue & mask) >> offsetRight will be the value of the given packed variable
 316 |     |     function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {
 317 |     |         // mask = ((1 << (256 - (offsetRight + offsetLeft))) - 1) << offsetRight;
 318 |     |         // using assembly because (1 << 256) causes overflow
 319 |     |         assembly {
 320 |     |             mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))
 321 |     |         }
 322 |     |     }
 323 |     | 
 324 |     |     // Returns slot value with updated packed variable.
 325 |     |     function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)
 326 |     |         internal
 327 |     |         pure
 328 |     |         returns (bytes32 newValue)
 329 |     |     {
 330 |     |         return bytes32((uint256(curValue) & ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue << offsetRight));
 331 |     |     }
 332 |     | }
 333 |     | 
 334 |     | library stdStorage {
 335 |     |     Vm private constant vm = Vm(address(uint160(uint256(keccak256("hevm cheat code")))));
 336 |     | 
 337 |     |     function sigs(string memory sigStr) internal pure returns (bytes4) {
 338 |     |         return stdStorageSafe.sigs(sigStr);
 339 |     |     }
 340 |     | 
 341 |     |     function find(StdStorage storage self) internal returns (uint256) {
 342 |     |         return find(self, true);
 343 |     |     }
 344 |     | 
 345 |     |     function find(StdStorage storage self, bool _clear) internal returns (uint256) {
 346 |     |         return stdStorageSafe.find(self, _clear).slot;
 347 |     |     }
 348 |     | 
 349 |     |     function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {
 350 |     |         return stdStorageSafe.target(self, _target);
 351 |     |     }
 352 |     | 
 353 |     |     function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {
 354 |     |         return stdStorageSafe.sig(self, _sig);
 355 |     |     }
 356 |     | 
 357 |     |     function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {
 358 |     |         return stdStorageSafe.sig(self, _sig);
 359 |     |     }
 360 |     | 
 361 |     |     function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {
 362 |     |         return stdStorageSafe.with_key(self, who);
 363 |     |     }
 364 |     | 
 365 |     |     function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {
 366 |     |         return stdStorageSafe.with_key(self, amt);
 367 |     |     }
 368 |     | 
 369 |     |     function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {
 370 |     |         return stdStorageSafe.with_key(self, key);
 371 |     |     }
 372 |     | 
 373 |     |     function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {
 374 |     |         return stdStorageSafe.with_calldata(self, _calldata);
 375 |     |     }
 376 |     | 
 377 |     |     function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {
 378 |     |         return stdStorageSafe.enable_packed_slots(self);
 379 |     |     }
 380 |     | 
 381 |     |     function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {
 382 |     |         return stdStorageSafe.depth(self, _depth);
 383 |     |     }
 384 |     | 
 385 |     |     function clear(StdStorage storage self) internal {
 386 |     |         stdStorageSafe.clear(self);
 387 |     |     }
 388 |     | 
 389 |     |     function checked_write(StdStorage storage self, address who) internal {
 390 |     |         checked_write(self, bytes32(uint256(uint160(who))));
 391 |     |     }
 392 |     | 
 393 |     |     function checked_write(StdStorage storage self, uint256 amt) internal {
 394 |     |         checked_write(self, bytes32(amt));
 395 |     |     }
 396 |     | 
 397 |     |     function checked_write_int(StdStorage storage self, int256 val) internal {
 398 |     |         checked_write(self, bytes32(uint256(val)));
 399 |     |     }
 400 |     | 
 401 |     |     function checked_write(StdStorage storage self, bool write) internal {
 402 |     |         bytes32 t;
 403 |     |         /// @solidity memory-safe-assembly
 404 |     |         assembly {
 405 |     |             t := write
 406 |     |         }
 407 |     |         checked_write(self, t);
 408 |     |     }
 409 |     | 
 410 |     |     function checked_write(StdStorage storage self, bytes32 set) internal {
 411 |     |         address who = self._target;
 412 |     |         bytes4 fsig = self._sig;
 413 |     |         uint256 field_depth = self._depth;
 414 |     |         bytes memory params = stdStorageSafe.getCallParams(self);
 415 |     | 
 416 |     |         if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {
 417 |     |             find(self, false);
 418 |     |         }
 419 |     |         FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];
 420 |     |         if ((data.offsetLeft + data.offsetRight) > 0) {
 421 |     |             uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));
 422 |     |             require(
 423 |     |                 uint256(set) < maxVal,
 424 |     |                 string(
 425 |     |                     abi.encodePacked(
 426 |     |                         "stdStorage find(StdStorage): Packed slot. We can't fit value greater than ",
 427 |     |                         vm.toString(maxVal)
 428 |     |                     )
 429 |     |                 )
 430 |     |             );
 431 |     |         }
 432 |     |         bytes32 curVal = vm.load(who, bytes32(data.slot));
 433 |     |         bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);
 434 |     | 
 435 |     |         vm.store(who, bytes32(data.slot), valToSet);
 436 |     | 
 437 |     |         (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);
 438 |     | 
 439 |     |         if (!success || callResult != set) {
 440 |     |             vm.store(who, bytes32(data.slot), curVal);
 441 |     |             revert("stdStorage find(StdStorage): Failed to write value.");
 442 |     |         }
 443 |     |         clear(self);
 444 |     |     }
 445 |     | 
 446 |     |     function read_bytes32(StdStorage storage self) internal returns (bytes32) {
 447 |     |         return stdStorageSafe.read_bytes32(self);
 448 |     |     }
 449 |     | 
 450 |     |     function read_bool(StdStorage storage self) internal returns (bool) {
 451 |     |         return stdStorageSafe.read_bool(self);
 452 |     |     }
 453 |     | 
 454 |     |     function read_address(StdStorage storage self) internal returns (address) {
 455 |     |         return stdStorageSafe.read_address(self);
 456 |     |     }
 457 |     | 
 458 |     |     function read_uint(StdStorage storage self) internal returns (uint256) {
 459 |     |         return stdStorageSafe.read_uint(self);
 460 |     |     }
 461 |     | 
 462 |     |     function read_int(StdStorage storage self) internal returns (int256) {
 463 |     |         return stdStorageSafe.read_int(self);
 464 |     |     }
 465 |     | 
 466 |     |     function parent(StdStorage storage self) internal returns (uint256, bytes32) {
 467 |     |         return stdStorageSafe.parent(self);
 468 |     |     }
 469 |     | 
 470 |     |     function root(StdStorage storage self) internal returns (uint256) {
 471 |     |         return stdStorageSafe.root(self);
 472 |     |     }
 473 |     | }
 474 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdStyle.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.4.22 <0.9.0;
   3 |     | 
   4 |     | import {VmSafe} from "./Vm.sol";
   5 |     | 
   6 |     | library StdStyle {
   7 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
   8 |     | 
   9 |     |     string constant RED = "\u001b[91m";
  10 |     |     string constant GREEN = "\u001b[92m";
  11 |     |     string constant YELLOW = "\u001b[93m";
  12 |     |     string constant BLUE = "\u001b[94m";
  13 |     |     string constant MAGENTA = "\u001b[95m";
  14 |     |     string constant CYAN = "\u001b[96m";
  15 |     |     string constant BOLD = "\u001b[1m";
  16 |     |     string constant DIM = "\u001b[2m";
  17 |     |     string constant ITALIC = "\u001b[3m";
  18 |     |     string constant UNDERLINE = "\u001b[4m";
  19 |     |     string constant INVERSE = "\u001b[7m";
  20 |     |     string constant RESET = "\u001b[0m";
  21 |     | 
  22 |     |     function styleConcat(string memory style, string memory self) private pure returns (string memory) {
  23 |     |         return string(abi.encodePacked(style, self, RESET));
  24 |     |     }
  25 |     | 
  26 |     |     function red(string memory self) internal pure returns (string memory) {
  27 |     |         return styleConcat(RED, self);
  28 |     |     }
  29 |     | 
  30 |     |     function red(uint256 self) internal pure returns (string memory) {
  31 |     |         return red(vm.toString(self));
  32 |     |     }
  33 |     | 
  34 |     |     function red(int256 self) internal pure returns (string memory) {
  35 |     |         return red(vm.toString(self));
  36 |     |     }
  37 |     | 
  38 |     |     function red(address self) internal pure returns (string memory) {
  39 |     |         return red(vm.toString(self));
  40 |     |     }
  41 |     | 
  42 |     |     function red(bool self) internal pure returns (string memory) {
  43 |     |         return red(vm.toString(self));
  44 |     |     }
  45 |     | 
  46 |     |     function redBytes(bytes memory self) internal pure returns (string memory) {
  47 |     |         return red(vm.toString(self));
  48 |     |     }
  49 |     | 
  50 |     |     function redBytes32(bytes32 self) internal pure returns (string memory) {
  51 |     |         return red(vm.toString(self));
  52 |     |     }
  53 |     | 
  54 |     |     function green(string memory self) internal pure returns (string memory) {
  55 |     |         return styleConcat(GREEN, self);
  56 |     |     }
  57 |     | 
  58 |     |     function green(uint256 self) internal pure returns (string memory) {
  59 |     |         return green(vm.toString(self));
  60 |     |     }
  61 |     | 
  62 |     |     function green(int256 self) internal pure returns (string memory) {
  63 |     |         return green(vm.toString(self));
  64 |     |     }
  65 |     | 
  66 |     |     function green(address self) internal pure returns (string memory) {
  67 |     |         return green(vm.toString(self));
  68 |     |     }
  69 |     | 
  70 |     |     function green(bool self) internal pure returns (string memory) {
  71 |     |         return green(vm.toString(self));
  72 |     |     }
  73 |     | 
  74 |     |     function greenBytes(bytes memory self) internal pure returns (string memory) {
  75 |     |         return green(vm.toString(self));
  76 |     |     }
  77 |     | 
  78 |     |     function greenBytes32(bytes32 self) internal pure returns (string memory) {
  79 |     |         return green(vm.toString(self));
  80 |     |     }
  81 |     | 
  82 |     |     function yellow(string memory self) internal pure returns (string memory) {
  83 |     |         return styleConcat(YELLOW, self);
  84 |     |     }
  85 |     | 
  86 |     |     function yellow(uint256 self) internal pure returns (string memory) {
  87 |     |         return yellow(vm.toString(self));
  88 |     |     }
  89 |     | 
  90 |     |     function yellow(int256 self) internal pure returns (string memory) {
  91 |     |         return yellow(vm.toString(self));
  92 |     |     }
  93 |     | 
  94 |     |     function yellow(address self) internal pure returns (string memory) {
  95 |     |         return yellow(vm.toString(self));
  96 |     |     }
  97 |     | 
  98 |     |     function yellow(bool self) internal pure returns (string memory) {
  99 |     |         return yellow(vm.toString(self));
 100 |     |     }
 101 |     | 
 102 |     |     function yellowBytes(bytes memory self) internal pure returns (string memory) {
 103 |     |         return yellow(vm.toString(self));
 104 |     |     }
 105 |     | 
 106 |     |     function yellowBytes32(bytes32 self) internal pure returns (string memory) {
 107 |     |         return yellow(vm.toString(self));
 108 |     |     }
 109 |     | 
 110 |     |     function blue(string memory self) internal pure returns (string memory) {
 111 |     |         return styleConcat(BLUE, self);
 112 |     |     }
 113 |     | 
 114 |     |     function blue(uint256 self) internal pure returns (string memory) {
 115 |     |         return blue(vm.toString(self));
 116 |     |     }
 117 |     | 
 118 |     |     function blue(int256 self) internal pure returns (string memory) {
 119 |     |         return blue(vm.toString(self));
 120 |     |     }
 121 |     | 
 122 |     |     function blue(address self) internal pure returns (string memory) {
 123 |     |         return blue(vm.toString(self));
 124 |     |     }
 125 |     | 
 126 |     |     function blue(bool self) internal pure returns (string memory) {
 127 |     |         return blue(vm.toString(self));
 128 |     |     }
 129 |     | 
 130 |     |     function blueBytes(bytes memory self) internal pure returns (string memory) {
 131 |     |         return blue(vm.toString(self));
 132 |     |     }
 133 |     | 
 134 |     |     function blueBytes32(bytes32 self) internal pure returns (string memory) {
 135 |     |         return blue(vm.toString(self));
 136 |     |     }
 137 |     | 
 138 |     |     function magenta(string memory self) internal pure returns (string memory) {
 139 |     |         return styleConcat(MAGENTA, self);
 140 |     |     }
 141 |     | 
 142 |     |     function magenta(uint256 self) internal pure returns (string memory) {
 143 |     |         return magenta(vm.toString(self));
 144 |     |     }
 145 |     | 
 146 |     |     function magenta(int256 self) internal pure returns (string memory) {
 147 |     |         return magenta(vm.toString(self));
 148 |     |     }
 149 |     | 
 150 |     |     function magenta(address self) internal pure returns (string memory) {
 151 |     |         return magenta(vm.toString(self));
 152 |     |     }
 153 |     | 
 154 |     |     function magenta(bool self) internal pure returns (string memory) {
 155 |     |         return magenta(vm.toString(self));
 156 |     |     }
 157 |     | 
 158 |     |     function magentaBytes(bytes memory self) internal pure returns (string memory) {
 159 |     |         return magenta(vm.toString(self));
 160 |     |     }
 161 |     | 
 162 |     |     function magentaBytes32(bytes32 self) internal pure returns (string memory) {
 163 |     |         return magenta(vm.toString(self));
 164 |     |     }
 165 |     | 
 166 |     |     function cyan(string memory self) internal pure returns (string memory) {
 167 |     |         return styleConcat(CYAN, self);
 168 |     |     }
 169 |     | 
 170 |     |     function cyan(uint256 self) internal pure returns (string memory) {
 171 |     |         return cyan(vm.toString(self));
 172 |     |     }
 173 |     | 
 174 |     |     function cyan(int256 self) internal pure returns (string memory) {
 175 |     |         return cyan(vm.toString(self));
 176 |     |     }
 177 |     | 
 178 |     |     function cyan(address self) internal pure returns (string memory) {
 179 |     |         return cyan(vm.toString(self));
 180 |     |     }
 181 |     | 
 182 |     |     function cyan(bool self) internal pure returns (string memory) {
 183 |     |         return cyan(vm.toString(self));
 184 |     |     }
 185 |     | 
 186 |     |     function cyanBytes(bytes memory self) internal pure returns (string memory) {
 187 |     |         return cyan(vm.toString(self));
 188 |     |     }
 189 |     | 
 190 |     |     function cyanBytes32(bytes32 self) internal pure returns (string memory) {
 191 |     |         return cyan(vm.toString(self));
 192 |     |     }
 193 |     | 
 194 |     |     function bold(string memory self) internal pure returns (string memory) {
 195 |     |         return styleConcat(BOLD, self);
 196 |     |     }
 197 |     | 
 198 |     |     function bold(uint256 self) internal pure returns (string memory) {
 199 |     |         return bold(vm.toString(self));
 200 |     |     }
 201 |     | 
 202 |     |     function bold(int256 self) internal pure returns (string memory) {
 203 |     |         return bold(vm.toString(self));
 204 |     |     }
 205 |     | 
 206 |     |     function bold(address self) internal pure returns (string memory) {
 207 |     |         return bold(vm.toString(self));
 208 |     |     }
 209 |     | 
 210 |     |     function bold(bool self) internal pure returns (string memory) {
 211 |     |         return bold(vm.toString(self));
 212 |     |     }
 213 |     | 
 214 |     |     function boldBytes(bytes memory self) internal pure returns (string memory) {
 215 |     |         return bold(vm.toString(self));
 216 |     |     }
 217 |     | 
 218 |     |     function boldBytes32(bytes32 self) internal pure returns (string memory) {
 219 |     |         return bold(vm.toString(self));
 220 |     |     }
 221 |     | 
 222 |     |     function dim(string memory self) internal pure returns (string memory) {
 223 |     |         return styleConcat(DIM, self);
 224 |     |     }
 225 |     | 
 226 |     |     function dim(uint256 self) internal pure returns (string memory) {
 227 |     |         return dim(vm.toString(self));
 228 |     |     }
 229 |     | 
 230 |     |     function dim(int256 self) internal pure returns (string memory) {
 231 |     |         return dim(vm.toString(self));
 232 |     |     }
 233 |     | 
 234 |     |     function dim(address self) internal pure returns (string memory) {
 235 |     |         return dim(vm.toString(self));
 236 |     |     }
 237 |     | 
 238 |     |     function dim(bool self) internal pure returns (string memory) {
 239 |     |         return dim(vm.toString(self));
 240 |     |     }
 241 |     | 
 242 |     |     function dimBytes(bytes memory self) internal pure returns (string memory) {
 243 |     |         return dim(vm.toString(self));
 244 |     |     }
 245 |     | 
 246 |     |     function dimBytes32(bytes32 self) internal pure returns (string memory) {
 247 |     |         return dim(vm.toString(self));
 248 |     |     }
 249 |     | 
 250 |     |     function italic(string memory self) internal pure returns (string memory) {
 251 |     |         return styleConcat(ITALIC, self);
 252 |     |     }
 253 |     | 
 254 |     |     function italic(uint256 self) internal pure returns (string memory) {
 255 |     |         return italic(vm.toString(self));
 256 |     |     }
 257 |     | 
 258 |     |     function italic(int256 self) internal pure returns (string memory) {
 259 |     |         return italic(vm.toString(self));
 260 |     |     }
 261 |     | 
 262 |     |     function italic(address self) internal pure returns (string memory) {
 263 |     |         return italic(vm.toString(self));
 264 |     |     }
 265 |     | 
 266 |     |     function italic(bool self) internal pure returns (string memory) {
 267 |     |         return italic(vm.toString(self));
 268 |     |     }
 269 |     | 
 270 |     |     function italicBytes(bytes memory self) internal pure returns (string memory) {
 271 |     |         return italic(vm.toString(self));
 272 |     |     }
 273 |     | 
 274 |     |     function italicBytes32(bytes32 self) internal pure returns (string memory) {
 275 |     |         return italic(vm.toString(self));
 276 |     |     }
 277 |     | 
 278 |     |     function underline(string memory self) internal pure returns (string memory) {
 279 |     |         return styleConcat(UNDERLINE, self);
 280 |     |     }
 281 |     | 
 282 |     |     function underline(uint256 self) internal pure returns (string memory) {
 283 |     |         return underline(vm.toString(self));
 284 |     |     }
 285 |     | 
 286 |     |     function underline(int256 self) internal pure returns (string memory) {
 287 |     |         return underline(vm.toString(self));
 288 |     |     }
 289 |     | 
 290 |     |     function underline(address self) internal pure returns (string memory) {
 291 |     |         return underline(vm.toString(self));
 292 |     |     }
 293 |     | 
 294 |     |     function underline(bool self) internal pure returns (string memory) {
 295 |     |         return underline(vm.toString(self));
 296 |     |     }
 297 |     | 
 298 |     |     function underlineBytes(bytes memory self) internal pure returns (string memory) {
 299 |     |         return underline(vm.toString(self));
 300 |     |     }
 301 |     | 
 302 |     |     function underlineBytes32(bytes32 self) internal pure returns (string memory) {
 303 |     |         return underline(vm.toString(self));
 304 |     |     }
 305 |     | 
 306 |     |     function inverse(string memory self) internal pure returns (string memory) {
 307 |     |         return styleConcat(INVERSE, self);
 308 |     |     }
 309 |     | 
 310 |     |     function inverse(uint256 self) internal pure returns (string memory) {
 311 |     |         return inverse(vm.toString(self));
 312 |     |     }
 313 |     | 
 314 |     |     function inverse(int256 self) internal pure returns (string memory) {
 315 |     |         return inverse(vm.toString(self));
 316 |     |     }
 317 |     | 
 318 |     |     function inverse(address self) internal pure returns (string memory) {
 319 |     |         return inverse(vm.toString(self));
 320 |     |     }
 321 |     | 
 322 |     |     function inverse(bool self) internal pure returns (string memory) {
 323 |     |         return inverse(vm.toString(self));
 324 |     |     }
 325 |     | 
 326 |     |     function inverseBytes(bytes memory self) internal pure returns (string memory) {
 327 |     |         return inverse(vm.toString(self));
 328 |     |     }
 329 |     | 
 330 |     |     function inverseBytes32(bytes32 self) internal pure returns (string memory) {
 331 |     |         return inverse(vm.toString(self));
 332 |     |     }
 333 |     | }
 334 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdToml.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.0 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {VmSafe} from "./Vm.sol";
   7 |     | 
   8 |     | // Helpers for parsing and writing TOML files
   9 |     | // To parse:
  10 |     | // ```
  11 |     | // using stdToml for string;
  12 |     | // string memory toml = vm.readFile("<some_path>");
  13 |     | // toml.readUint("<json_path>");
  14 |     | // ```
  15 |     | // To write:
  16 |     | // ```
  17 |     | // using stdToml for string;
  18 |     | // string memory json = "json";
  19 |     | // json.serialize("a", uint256(123));
  20 |     | // string memory semiFinal = json.serialize("b", string("test"));
  21 |     | // string memory finalJson = json.serialize("c", semiFinal);
  22 |     | // finalJson.write("<some_path>");
  23 |     | // ```
  24 |     | 
  25 |     | library stdToml {
  26 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  27 |     | 
  28 |     |     function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {
  29 |     |         return vm.parseToml(toml, key);
  30 |     |     }
  31 |     | 
  32 |     |     function readUint(string memory toml, string memory key) internal pure returns (uint256) {
  33 |     |         return vm.parseTomlUint(toml, key);
  34 |     |     }
  35 |     | 
  36 |     |     function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {
  37 |     |         return vm.parseTomlUintArray(toml, key);
  38 |     |     }
  39 |     | 
  40 |     |     function readInt(string memory toml, string memory key) internal pure returns (int256) {
  41 |     |         return vm.parseTomlInt(toml, key);
  42 |     |     }
  43 |     | 
  44 |     |     function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {
  45 |     |         return vm.parseTomlIntArray(toml, key);
  46 |     |     }
  47 |     | 
  48 |     |     function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {
  49 |     |         return vm.parseTomlBytes32(toml, key);
  50 |     |     }
  51 |     | 
  52 |     |     function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {
  53 |     |         return vm.parseTomlBytes32Array(toml, key);
  54 |     |     }
  55 |     | 
  56 |     |     function readString(string memory toml, string memory key) internal pure returns (string memory) {
  57 |     |         return vm.parseTomlString(toml, key);
  58 |     |     }
  59 |     | 
  60 |     |     function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {
  61 |     |         return vm.parseTomlStringArray(toml, key);
  62 |     |     }
  63 |     | 
  64 |     |     function readAddress(string memory toml, string memory key) internal pure returns (address) {
  65 |     |         return vm.parseTomlAddress(toml, key);
  66 |     |     }
  67 |     | 
  68 |     |     function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {
  69 |     |         return vm.parseTomlAddressArray(toml, key);
  70 |     |     }
  71 |     | 
  72 |     |     function readBool(string memory toml, string memory key) internal pure returns (bool) {
  73 |     |         return vm.parseTomlBool(toml, key);
  74 |     |     }
  75 |     | 
  76 |     |     function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {
  77 |     |         return vm.parseTomlBoolArray(toml, key);
  78 |     |     }
  79 |     | 
  80 |     |     function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {
  81 |     |         return vm.parseTomlBytes(toml, key);
  82 |     |     }
  83 |     | 
  84 |     |     function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {
  85 |     |         return vm.parseTomlBytesArray(toml, key);
  86 |     |     }
  87 |     | 
  88 |     |     function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {
  89 |     |         return vm.serializeJson(jsonKey, rootObject);
  90 |     |     }
  91 |     | 
  92 |     |     function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {
  93 |     |         return vm.serializeBool(jsonKey, key, value);
  94 |     |     }
  95 |     | 
  96 |     |     function serialize(string memory jsonKey, string memory key, bool[] memory value)
  97 |     |         internal
  98 |     |         returns (string memory)
  99 |     |     {
 100 |     |         return vm.serializeBool(jsonKey, key, value);
 101 |     |     }
 102 |     | 
 103 |     |     function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {
 104 |     |         return vm.serializeUint(jsonKey, key, value);
 105 |     |     }
 106 |     | 
 107 |     |     function serialize(string memory jsonKey, string memory key, uint256[] memory value)
 108 |     |         internal
 109 |     |         returns (string memory)
 110 |     |     {
 111 |     |         return vm.serializeUint(jsonKey, key, value);
 112 |     |     }
 113 |     | 
 114 |     |     function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {
 115 |     |         return vm.serializeInt(jsonKey, key, value);
 116 |     |     }
 117 |     | 
 118 |     |     function serialize(string memory jsonKey, string memory key, int256[] memory value)
 119 |     |         internal
 120 |     |         returns (string memory)
 121 |     |     {
 122 |     |         return vm.serializeInt(jsonKey, key, value);
 123 |     |     }
 124 |     | 
 125 |     |     function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {
 126 |     |         return vm.serializeAddress(jsonKey, key, value);
 127 |     |     }
 128 |     | 
 129 |     |     function serialize(string memory jsonKey, string memory key, address[] memory value)
 130 |     |         internal
 131 |     |         returns (string memory)
 132 |     |     {
 133 |     |         return vm.serializeAddress(jsonKey, key, value);
 134 |     |     }
 135 |     | 
 136 |     |     function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {
 137 |     |         return vm.serializeBytes32(jsonKey, key, value);
 138 |     |     }
 139 |     | 
 140 |     |     function serialize(string memory jsonKey, string memory key, bytes32[] memory value)
 141 |     |         internal
 142 |     |         returns (string memory)
 143 |     |     {
 144 |     |         return vm.serializeBytes32(jsonKey, key, value);
 145 |     |     }
 146 |     | 
 147 |     |     function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {
 148 |     |         return vm.serializeBytes(jsonKey, key, value);
 149 |     |     }
 150 |     | 
 151 |     |     function serialize(string memory jsonKey, string memory key, bytes[] memory value)
 152 |     |         internal
 153 |     |         returns (string memory)
 154 |     |     {
 155 |     |         return vm.serializeBytes(jsonKey, key, value);
 156 |     |     }
 157 |     | 
 158 |     |     function serialize(string memory jsonKey, string memory key, string memory value)
 159 |     |         internal
 160 |     |         returns (string memory)
 161 |     |     {
 162 |     |         return vm.serializeString(jsonKey, key, value);
 163 |     |     }
 164 |     | 
 165 |     |     function serialize(string memory jsonKey, string memory key, string[] memory value)
 166 |     |         internal
 167 |     |         returns (string memory)
 168 |     |     {
 169 |     |         return vm.serializeString(jsonKey, key, value);
 170 |     |     }
 171 |     | 
 172 |     |     function write(string memory jsonKey, string memory path) internal {
 173 |     |         vm.writeToml(jsonKey, path);
 174 |     |     }
 175 |     | 
 176 |     |     function write(string memory jsonKey, string memory path, string memory valueKey) internal {
 177 |     |         vm.writeToml(jsonKey, path, valueKey);
 178 |     |     }
 179 |     | }
 180 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | pragma experimental ABIEncoderV2;
   5 |     | 
   6 |     | import {IMulticall3} from "./interfaces/IMulticall3.sol";
   7 |     | import {MockERC20} from "./mocks/MockERC20.sol";
   8 |     | import {MockERC721} from "./mocks/MockERC721.sol";
   9 |     | import {VmSafe} from "./Vm.sol";
  10 |     | 
  11 |     | abstract contract StdUtils {
  12 |     |     /*//////////////////////////////////////////////////////////////////////////
  13 |     |                                      CONSTANTS
  14 |     |     //////////////////////////////////////////////////////////////////////////*/
  15 |     | 
  16 |     |     IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);
  17 |     |     VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256("hevm cheat code")))));
  18 | *   |     address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;
  19 |     |     uint256 private constant INT256_MIN_ABS =
  20 |     |         57896044618658097711785492504343953926634992332820282019728792003956564819968;
  21 |     |     uint256 private constant SECP256K1_ORDER =
  22 |     |         115792089237316195423570985008687907852837564279074904382605163141518161494337;
  23 |     |     uint256 private constant UINT256_MAX =
  24 |     |         115792089237316195423570985008687907853269984665640564039457584007913129639935;
  25 |     | 
  26 |     |     // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.
  27 |     |     address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;
  28 |     | 
  29 |     |     /*//////////////////////////////////////////////////////////////////////////
  30 |     |                                  INTERNAL FUNCTIONS
  31 |     |     //////////////////////////////////////////////////////////////////////////*/
  32 |     | 
  33 | *   |     function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  34 | *   |         require(min <= max, "StdUtils bound(uint256,uint256,uint256): Max is less than min.");
  35 |     |         // If x is between min and max, return x directly. This is to ensure that dictionary values
  36 |     |         // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188
  37 | *   |         if (x >= min && x <= max) return x;
  38 |     | 
  39 | *   |         uint256 size = max - min + 1;
  40 |     | 
  41 |     |         // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.
  42 |     |         // This helps ensure coverage of the min/max values.
  43 | *   |         if (x <= 3 && size > x) return min + x;
  44 | *   |         if (x >= UINT256_MAX - 3 && size > UINT256_MAX - x) return max - (UINT256_MAX - x);
  45 |     | 
  46 |     |         // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.
  47 | *   |         if (x > max) {
  48 | *   |             uint256 diff = x - max;
  49 | *   |             uint256 rem = diff % size;
  50 | *   |             if (rem == 0) return max;
  51 | *   |             result = min + rem - 1;
  52 | *   |         } else if (x < min) {
  53 |     |             uint256 diff = min - x;
  54 |     |             uint256 rem = diff % size;
  55 |     |             if (rem == 0) return min;
  56 |     |             result = max - rem + 1;
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 | *   |     function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {
  61 | *   |         result = _bound(x, min, max);
  62 | *   |         console2_log_StdUtils("Bound result", result);
  63 |     |     }
  64 |     | 
  65 |     |     function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  66 |     |         require(min <= max, "StdUtils bound(int256,int256,int256): Max is less than min.");
  67 |     | 
  68 |     |         // Shifting all int256 values to uint256 to use _bound function. The range of two types are:
  69 |     |         // int256 : -(2**255) ~ (2**255 - 1)
  70 |     |         // uint256:     0     ~ (2**256 - 1)
  71 |     |         // So, add 2**255, INT256_MIN_ABS to the integer values.
  72 |     |         //
  73 |     |         // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.
  74 |     |         // So, use `~uint256(x) + 1` instead.
  75 |     |         uint256 _x = x < 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);
  76 |     |         uint256 _min = min < 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);
  77 |     |         uint256 _max = max < 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);
  78 |     | 
  79 |     |         uint256 y = _bound(_x, _min, _max);
  80 |     | 
  81 |     |         // To move it back to int256 value, subtract INT256_MIN_ABS at here.
  82 |     |         result = y < INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);
  83 |     |     }
  84 |     | 
  85 |     |     function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {
  86 |     |         result = _bound(x, min, max);
  87 |     |         console2_log_StdUtils("Bound result", vm.toString(result));
  88 |     |     }
  89 |     | 
  90 |     |     function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {
  91 |     |         result = _bound(privateKey, 1, SECP256K1_ORDER - 1);
  92 |     |     }
  93 |     | 
  94 |     |     function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {
  95 |     |         require(b.length <= 32, "StdUtils bytesToUint(bytes): Bytes length exceeds 32.");
  96 |     |         return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));
  97 |     |     }
  98 |     | 
  99 |     |     /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce
 100 |     |     /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)
 101 |     |     function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {
 102 |     |         console2_log_StdUtils("computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.");
 103 |     |         return vm.computeCreateAddress(deployer, nonce);
 104 |     |     }
 105 |     | 
 106 |     |     function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)
 107 |     |         internal
 108 |     |         pure
 109 |     |         virtual
 110 |     |         returns (address)
 111 |     |     {
 112 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 113 |     |         return vm.computeCreate2Address(salt, initcodeHash, deployer);
 114 |     |     }
 115 |     | 
 116 |     |     /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer
 117 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {
 118 |     |         console2_log_StdUtils("computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.");
 119 |     |         return vm.computeCreate2Address(salt, initCodeHash);
 120 |     |     }
 121 |     | 
 122 |     |     /// @dev returns an initialized mock ERC20 contract
 123 |     |     function deployMockERC20(string memory name, string memory symbol, uint8 decimals)
 124 |     |         internal
 125 |     |         returns (MockERC20 mock)
 126 |     |     {
 127 |     |         mock = new MockERC20();
 128 |     |         mock.initialize(name, symbol, decimals);
 129 |     |     }
 130 |     | 
 131 |     |     /// @dev returns an initialized mock ERC721 contract
 132 |     |     function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {
 133 |     |         mock = new MockERC721();
 134 |     |         mock.initialize(name, symbol);
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments
 138 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 139 |     |     function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {
 140 |     |         return hashInitCode(creationCode, "");
 141 |     |     }
 142 |     | 
 143 |     |     /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2
 144 |     |     /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode
 145 |     |     /// @param args the ABI-encoded arguments to the constructor of C
 146 |     |     function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {
 147 |     |         return keccak256(abi.encodePacked(creationCode, args));
 148 |     |     }
 149 |     | 
 150 |     |     // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.
 151 |     |     function getTokenBalances(address token, address[] memory addresses)
 152 |     |         internal
 153 |     |         virtual
 154 |     |         returns (uint256[] memory balances)
 155 |     |     {
 156 |     |         uint256 tokenCodeSize;
 157 |     |         assembly {
 158 |     |             tokenCodeSize := extcodesize(token)
 159 |     |         }
 160 |     |         require(tokenCodeSize > 0, "StdUtils getTokenBalances(address,address[]): Token address is not a contract.");
 161 |     | 
 162 |     |         // ABI encode the aggregate call to Multicall3.
 163 |     |         uint256 length = addresses.length;
 164 |     |         IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);
 165 |     |         for (uint256 i = 0; i < length; ++i) {
 166 |     |             // 0x70a08231 = bytes4("balanceOf(address)"))
 167 |     |             calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});
 168 |     |         }
 169 |     | 
 170 |     |         // Make the aggregate call.
 171 |     |         (, bytes[] memory returnData) = multicall.aggregate(calls);
 172 |     | 
 173 |     |         // ABI decode the return data and return the balances.
 174 |     |         balances = new uint256[](length);
 175 |     |         for (uint256 i = 0; i < length; ++i) {
 176 |     |             balances[i] = abi.decode(returnData[i], (uint256));
 177 |     |         }
 178 |     |     }
 179 |     | 
 180 |     |     /*//////////////////////////////////////////////////////////////////////////
 181 |     |                                  PRIVATE FUNCTIONS
 182 |     |     //////////////////////////////////////////////////////////////////////////*/
 183 |     | 
 184 |     |     function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {
 185 |     |         return address(uint160(uint256(bytesValue)));
 186 |     |     }
 187 |     | 
 188 |     |     // This section is used to prevent the compilation of console, which shortens the compilation time when console is
 189 |     |     // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid
 190 |     |     // any breaking changes to function signatures.
 191 |     |     function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)
 192 |     |         internal
 193 |     |         pure
 194 |     |         returns (function(bytes memory) internal pure fnOut)
 195 |     |     {
 196 |     |         assembly {
 197 |     |             fnOut := fnIn
 198 |     |         }
 199 |     |     }
 200 |     | 
 201 | *   |     function _sendLogPayload(bytes memory payload) internal pure {
 202 | *   |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
 203 |     |     }
 204 |     | 
 205 | *   |     function _sendLogPayloadView(bytes memory payload) private view {
 206 | *   |         uint256 payloadLength = payload.length;
 207 |     |         address consoleAddress = CONSOLE2_ADDRESS;
 208 |     |         /// @solidity memory-safe-assembly
 209 | *   |         assembly {
 210 | *   |             let payloadStart := add(payload, 32)
 211 | *   |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
 212 |     |         }
 213 |     |     }
 214 |     | 
 215 |     |     function console2_log_StdUtils(string memory p0) private pure {
 216 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
 217 |     |     }
 218 |     | 
 219 | *   |     function console2_log_StdUtils(string memory p0, uint256 p1) private pure {
 220 | *   |         _sendLogPayload(abi.encodeWithSignature("log(string,uint256)", p0, p1));
 221 |     |     }
 222 |     | 
 223 |     |     function console2_log_StdUtils(string memory p0, string memory p1) private pure {
 224 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
 225 |     |     }
 226 |     | }
 227 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Test.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | //  ABOUT
  7 |     | // Forge Std's default Test.
  8 |     | 
  9 |     | //  MODULES
 10 |     | import {console} from "./console.sol";
 11 |     | import {console2} from "./console2.sol";
 12 |     | import {safeconsole} from "./safeconsole.sol";
 13 |     | import {StdAssertions} from "./StdAssertions.sol";
 14 |     | import {StdChains} from "./StdChains.sol";
 15 |     | import {StdCheats} from "./StdCheats.sol";
 16 |     | import {stdError} from "./StdError.sol";
 17 |     | import {StdInvariant} from "./StdInvariant.sol";
 18 |     | import {stdJson} from "./StdJson.sol";
 19 |     | import {stdMath} from "./StdMath.sol";
 20 |     | import {StdStorage, stdStorage} from "./StdStorage.sol";
 21 |     | import {StdStyle} from "./StdStyle.sol";
 22 |     | import {stdToml} from "./StdToml.sol";
 23 |     | import {StdUtils} from "./StdUtils.sol";
 24 |     | import {Vm} from "./Vm.sol";
 25 |     | 
 26 |     | //  BOILERPLATE
 27 |     | import {TestBase} from "./Base.sol";
 28 |     | 
 29 |     | //  TEST
 30 |     | abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {
 31 |     |     // Note: IS_TEST() must return true.
 32 | *   |     bool public IS_TEST = true;
 33 |     | }
 34 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Vm.sol
    1 |     | // Automatically @generated by scripts/vm.py. Do not modify manually.
    2 |     | 
    3 |     | // SPDX-License-Identifier: MIT OR Apache-2.0
    4 |     | pragma solidity >=0.6.2 <0.9.0;
    5 |     | pragma experimental ABIEncoderV2;
    6 |     | 
    7 |     | /// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may
    8 |     | /// result in Script simulations differing from on-chain execution. It is recommended to only use
    9 |     | /// these cheats in scripts.
   10 |     | interface VmSafe {
   11 |     |     /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.
   12 |     |     enum CallerMode {
   13 |     |         // No caller modification is currently active.
   14 |     |         None,
   15 |     |         // A one time broadcast triggered by a `vm.broadcast()` call is currently active.
   16 |     |         Broadcast,
   17 |     |         // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.
   18 |     |         RecurrentBroadcast,
   19 |     |         // A one time prank triggered by a `vm.prank()` call is currently active.
   20 |     |         Prank,
   21 |     |         // A recurrent prank triggered by a `vm.startPrank()` call is currently active.
   22 |     |         RecurrentPrank
   23 |     |     }
   24 |     | 
   25 |     |     /// The kind of account access that occurred.
   26 |     |     enum AccountAccessKind {
   27 |     |         // The account was called.
   28 |     |         Call,
   29 |     |         // The account was called via delegatecall.
   30 |     |         DelegateCall,
   31 |     |         // The account was called via callcode.
   32 |     |         CallCode,
   33 |     |         // The account was called via staticcall.
   34 |     |         StaticCall,
   35 |     |         // The account was created.
   36 |     |         Create,
   37 |     |         // The account was selfdestructed.
   38 |     |         SelfDestruct,
   39 |     |         // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).
   40 |     |         Resume,
   41 |     |         // The account's balance was read.
   42 |     |         Balance,
   43 |     |         // The account's codesize was read.
   44 |     |         Extcodesize,
   45 |     |         // The account's codehash was read.
   46 |     |         Extcodehash,
   47 |     |         // The account's code was copied.
   48 |     |         Extcodecopy
   49 |     |     }
   50 |     | 
   51 |     |     /// Forge execution contexts.
   52 |     |     enum ForgeContext {
   53 |     |         // Test group execution context (test, coverage or snapshot).
   54 |     |         TestGroup,
   55 |     |         // `forge test` execution context.
   56 |     |         Test,
   57 |     |         // `forge coverage` execution context.
   58 |     |         Coverage,
   59 |     |         // `forge snapshot` execution context.
   60 |     |         Snapshot,
   61 |     |         // Script group execution context (dry run, broadcast or resume).
   62 |     |         ScriptGroup,
   63 |     |         // `forge script` execution context.
   64 |     |         ScriptDryRun,
   65 |     |         // `forge script --broadcast` execution context.
   66 |     |         ScriptBroadcast,
   67 |     |         // `forge script --resume` execution context.
   68 |     |         ScriptResume,
   69 |     |         // Unknown `forge` execution context.
   70 |     |         Unknown
   71 |     |     }
   72 |     | 
   73 |     |     /// An Ethereum log. Returned by `getRecordedLogs`.
   74 |     |     struct Log {
   75 |     |         // The topics of the log, including the signature, if any.
   76 |     |         bytes32[] topics;
   77 |     |         // The raw data of the log.
   78 |     |         bytes data;
   79 |     |         // The address of the log's emitter.
   80 |     |         address emitter;
   81 |     |     }
   82 |     | 
   83 |     |     /// An RPC URL and its alias. Returned by `rpcUrlStructs`.
   84 |     |     struct Rpc {
   85 |     |         // The alias of the RPC URL.
   86 |     |         string key;
   87 |     |         // The RPC URL.
   88 |     |         string url;
   89 |     |     }
   90 |     | 
   91 |     |     /// An RPC log object. Returned by `eth_getLogs`.
   92 |     |     struct EthGetLogs {
   93 |     |         // The address of the log's emitter.
   94 |     |         address emitter;
   95 |     |         // The topics of the log, including the signature, if any.
   96 |     |         bytes32[] topics;
   97 |     |         // The raw data of the log.
   98 |     |         bytes data;
   99 |     |         // The block hash.
  100 |     |         bytes32 blockHash;
  101 |     |         // The block number.
  102 |     |         uint64 blockNumber;
  103 |     |         // The transaction hash.
  104 |     |         bytes32 transactionHash;
  105 |     |         // The transaction index in the block.
  106 |     |         uint64 transactionIndex;
  107 |     |         // The log index.
  108 |     |         uint256 logIndex;
  109 |     |         // Whether the log was removed.
  110 |     |         bool removed;
  111 |     |     }
  112 |     | 
  113 |     |     /// A single entry in a directory listing. Returned by `readDir`.
  114 |     |     struct DirEntry {
  115 |     |         // The error message, if any.
  116 |     |         string errorMessage;
  117 |     |         // The path of the entry.
  118 |     |         string path;
  119 |     |         // The depth of the entry.
  120 |     |         uint64 depth;
  121 |     |         // Whether the entry is a directory.
  122 |     |         bool isDir;
  123 |     |         // Whether the entry is a symlink.
  124 |     |         bool isSymlink;
  125 |     |     }
  126 |     | 
  127 |     |     /// Metadata information about a file.
  128 |     |     /// This structure is returned from the `fsMetadata` function and represents known
  129 |     |     /// metadata about a file such as its permissions, size, modification
  130 |     |     /// times, etc.
  131 |     |     struct FsMetadata {
  132 |     |         // True if this metadata is for a directory.
  133 |     |         bool isDir;
  134 |     |         // True if this metadata is for a symlink.
  135 |     |         bool isSymlink;
  136 |     |         // The size of the file, in bytes, this metadata is for.
  137 |     |         uint256 length;
  138 |     |         // True if this metadata is for a readonly (unwritable) file.
  139 |     |         bool readOnly;
  140 |     |         // The last modification time listed in this metadata.
  141 |     |         uint256 modified;
  142 |     |         // The last access time of this metadata.
  143 |     |         uint256 accessed;
  144 |     |         // The creation time listed in this metadata.
  145 |     |         uint256 created;
  146 |     |     }
  147 |     | 
  148 |     |     /// A wallet with a public and private key.
  149 |     |     struct Wallet {
  150 |     |         // The wallet's address.
  151 |     |         address addr;
  152 |     |         // The wallet's public key `X`.
  153 |     |         uint256 publicKeyX;
  154 |     |         // The wallet's public key `Y`.
  155 |     |         uint256 publicKeyY;
  156 |     |         // The wallet's private key.
  157 |     |         uint256 privateKey;
  158 |     |     }
  159 |     | 
  160 |     |     /// The result of a `tryFfi` call.
  161 |     |     struct FfiResult {
  162 |     |         // The exit code of the call.
  163 |     |         int32 exitCode;
  164 |     |         // The optionally hex-decoded `stdout` data.
  165 |     |         bytes stdout;
  166 |     |         // The `stderr` data.
  167 |     |         bytes stderr;
  168 |     |     }
  169 |     | 
  170 |     |     /// Information on the chain and fork.
  171 |     |     struct ChainInfo {
  172 |     |         // The fork identifier. Set to zero if no fork is active.
  173 |     |         uint256 forkId;
  174 |     |         // The chain ID of the current fork.
  175 |     |         uint256 chainId;
  176 |     |     }
  177 |     | 
  178 |     |     /// The result of a `stopAndReturnStateDiff` call.
  179 |     |     struct AccountAccess {
  180 |     |         // The chain and fork the access occurred.
  181 |     |         ChainInfo chainInfo;
  182 |     |         // The kind of account access that determines what the account is.
  183 |     |         // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.
  184 |     |         // If kind is Create, then the account is the newly created account.
  185 |     |         // If kind is SelfDestruct, then the account is the selfdestruct recipient.
  186 |     |         // If kind is a Resume, then account represents a account context that has resumed.
  187 |     |         AccountAccessKind kind;
  188 |     |         // The account that was accessed.
  189 |     |         // It's either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.
  190 |     |         address account;
  191 |     |         // What accessed the account.
  192 |     |         address accessor;
  193 |     |         // If the account was initialized or empty prior to the access.
  194 |     |         // An account is considered initialized if it has code, a
  195 |     |         // non-zero nonce, or a non-zero balance.
  196 |     |         bool initialized;
  197 |     |         // The previous balance of the accessed account.
  198 |     |         uint256 oldBalance;
  199 |     |         // The potential new balance of the accessed account.
  200 |     |         // That is, all balance changes are recorded here, even if reverts occurred.
  201 |     |         uint256 newBalance;
  202 |     |         // Code of the account deployed by CREATE.
  203 |     |         bytes deployedCode;
  204 |     |         // Value passed along with the account access
  205 |     |         uint256 value;
  206 |     |         // Input data provided to the CREATE or CALL
  207 |     |         bytes data;
  208 |     |         // If this access reverted in either the current or parent context.
  209 |     |         bool reverted;
  210 |     |         // An ordered list of storage accesses made during an account access operation.
  211 |     |         StorageAccess[] storageAccesses;
  212 |     |         // Call depth traversed during the recording of state differences
  213 |     |         uint64 depth;
  214 |     |     }
  215 |     | 
  216 |     |     /// The storage accessed during an `AccountAccess`.
  217 |     |     struct StorageAccess {
  218 |     |         // The account whose storage was accessed.
  219 |     |         address account;
  220 |     |         // The slot that was accessed.
  221 |     |         bytes32 slot;
  222 |     |         // If the access was a write.
  223 |     |         bool isWrite;
  224 |     |         // The previous value of the slot.
  225 |     |         bytes32 previousValue;
  226 |     |         // The new value of the slot.
  227 |     |         bytes32 newValue;
  228 |     |         // If the access was reverted.
  229 |     |         bool reverted;
  230 |     |     }
  231 |     | 
  232 |     |     /// Gas used. Returned by `lastCallGas`.
  233 |     |     struct Gas {
  234 |     |         // The gas limit of the call.
  235 |     |         uint64 gasLimit;
  236 |     |         // The total gas used.
  237 |     |         uint64 gasTotalUsed;
  238 |     |         // DEPRECATED: The amount of gas used for memory expansion. Ref: <https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939>
  239 |     |         uint64 gasMemoryUsed;
  240 |     |         // The amount of gas refunded.
  241 |     |         int64 gasRefunded;
  242 |     |         // The amount of gas remaining.
  243 |     |         uint64 gasRemaining;
  244 |     |     }
  245 |     | 
  246 |     |     // ======== Environment ========
  247 |     | 
  248 |     |     /// Gets the environment variable `name` and parses it as `address`.
  249 |     |     /// Reverts if the variable was not found or could not be parsed.
  250 |     |     function envAddress(string calldata name) external view returns (address value);
  251 |     | 
  252 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  253 |     |     /// Reverts if the variable was not found or could not be parsed.
  254 |     |     function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);
  255 |     | 
  256 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  257 |     |     /// Reverts if the variable was not found or could not be parsed.
  258 |     |     function envBool(string calldata name) external view returns (bool value);
  259 |     | 
  260 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  261 |     |     /// Reverts if the variable was not found or could not be parsed.
  262 |     |     function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);
  263 |     | 
  264 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  265 |     |     /// Reverts if the variable was not found or could not be parsed.
  266 |     |     function envBytes32(string calldata name) external view returns (bytes32 value);
  267 |     | 
  268 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  269 |     |     /// Reverts if the variable was not found or could not be parsed.
  270 |     |     function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);
  271 |     | 
  272 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  273 |     |     /// Reverts if the variable was not found or could not be parsed.
  274 |     |     function envBytes(string calldata name) external view returns (bytes memory value);
  275 |     | 
  276 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  277 |     |     /// Reverts if the variable was not found or could not be parsed.
  278 |     |     function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);
  279 |     | 
  280 |     |     /// Gets the environment variable `name` and returns true if it exists, else returns false.
  281 |     |     function envExists(string calldata name) external view returns (bool result);
  282 |     | 
  283 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  284 |     |     /// Reverts if the variable was not found or could not be parsed.
  285 |     |     function envInt(string calldata name) external view returns (int256 value);
  286 |     | 
  287 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  288 |     |     /// Reverts if the variable was not found or could not be parsed.
  289 |     |     function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);
  290 |     | 
  291 |     |     /// Gets the environment variable `name` and parses it as `bool`.
  292 |     |     /// Reverts if the variable could not be parsed.
  293 |     |     /// Returns `defaultValue` if the variable was not found.
  294 |     |     function envOr(string calldata name, bool defaultValue) external view returns (bool value);
  295 |     | 
  296 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  297 |     |     /// Reverts if the variable could not be parsed.
  298 |     |     /// Returns `defaultValue` if the variable was not found.
  299 |     |     function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);
  300 |     | 
  301 |     |     /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.
  302 |     |     /// Reverts if the variable could not be parsed.
  303 |     |     /// Returns `defaultValue` if the variable was not found.
  304 |     |     function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)
  305 |     |         external
  306 |     |         view
  307 |     |         returns (address[] memory value);
  308 |     | 
  309 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.
  310 |     |     /// Reverts if the variable could not be parsed.
  311 |     |     /// Returns `defaultValue` if the variable was not found.
  312 |     |     function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)
  313 |     |         external
  314 |     |         view
  315 |     |         returns (bytes32[] memory value);
  316 |     | 
  317 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  318 |     |     /// Reverts if the variable could not be parsed.
  319 |     |     /// Returns `defaultValue` if the variable was not found.
  320 |     |     function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)
  321 |     |         external
  322 |     |         view
  323 |     |         returns (string[] memory value);
  324 |     | 
  325 |     |     /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.
  326 |     |     /// Reverts if the variable could not be parsed.
  327 |     |     /// Returns `defaultValue` if the variable was not found.
  328 |     |     function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)
  329 |     |         external
  330 |     |         view
  331 |     |         returns (bytes[] memory value);
  332 |     | 
  333 |     |     /// Gets the environment variable `name` and parses it as `int256`.
  334 |     |     /// Reverts if the variable could not be parsed.
  335 |     |     /// Returns `defaultValue` if the variable was not found.
  336 |     |     function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);
  337 |     | 
  338 |     |     /// Gets the environment variable `name` and parses it as `address`.
  339 |     |     /// Reverts if the variable could not be parsed.
  340 |     |     /// Returns `defaultValue` if the variable was not found.
  341 |     |     function envOr(string calldata name, address defaultValue) external view returns (address value);
  342 |     | 
  343 |     |     /// Gets the environment variable `name` and parses it as `bytes32`.
  344 |     |     /// Reverts if the variable could not be parsed.
  345 |     |     /// Returns `defaultValue` if the variable was not found.
  346 |     |     function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);
  347 |     | 
  348 |     |     /// Gets the environment variable `name` and parses it as `string`.
  349 |     |     /// Reverts if the variable could not be parsed.
  350 |     |     /// Returns `defaultValue` if the variable was not found.
  351 |     |     function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);
  352 |     | 
  353 |     |     /// Gets the environment variable `name` and parses it as `bytes`.
  354 |     |     /// Reverts if the variable could not be parsed.
  355 |     |     /// Returns `defaultValue` if the variable was not found.
  356 |     |     function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);
  357 |     | 
  358 |     |     /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.
  359 |     |     /// Reverts if the variable could not be parsed.
  360 |     |     /// Returns `defaultValue` if the variable was not found.
  361 |     |     function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)
  362 |     |         external
  363 |     |         view
  364 |     |         returns (bool[] memory value);
  365 |     | 
  366 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  367 |     |     /// Reverts if the variable could not be parsed.
  368 |     |     /// Returns `defaultValue` if the variable was not found.
  369 |     |     function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)
  370 |     |         external
  371 |     |         view
  372 |     |         returns (uint256[] memory value);
  373 |     | 
  374 |     |     /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.
  375 |     |     /// Reverts if the variable could not be parsed.
  376 |     |     /// Returns `defaultValue` if the variable was not found.
  377 |     |     function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)
  378 |     |         external
  379 |     |         view
  380 |     |         returns (int256[] memory value);
  381 |     | 
  382 |     |     /// Gets the environment variable `name` and parses it as `string`.
  383 |     |     /// Reverts if the variable was not found or could not be parsed.
  384 |     |     function envString(string calldata name) external view returns (string memory value);
  385 |     | 
  386 |     |     /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.
  387 |     |     /// Reverts if the variable was not found or could not be parsed.
  388 |     |     function envString(string calldata name, string calldata delim) external view returns (string[] memory value);
  389 |     | 
  390 |     |     /// Gets the environment variable `name` and parses it as `uint256`.
  391 |     |     /// Reverts if the variable was not found or could not be parsed.
  392 |     |     function envUint(string calldata name) external view returns (uint256 value);
  393 |     | 
  394 |     |     /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.
  395 |     |     /// Reverts if the variable was not found or could not be parsed.
  396 |     |     function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);
  397 |     | 
  398 |     |     /// Returns true if `forge` command was executed in given context.
  399 |     |     function isContext(ForgeContext context) external view returns (bool result);
  400 |     | 
  401 |     |     /// Sets environment variables.
  402 |     |     function setEnv(string calldata name, string calldata value) external;
  403 |     | 
  404 |     |     // ======== EVM ========
  405 |     | 
  406 |     |     /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.
  407 |     |     function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);
  408 |     | 
  409 |     |     /// Gets the address for a given private key.
  410 |     |     function addr(uint256 privateKey) external pure returns (address keyAddr);
  411 |     | 
  412 |     |     /// Gets all the logs according to specified filter.
  413 |     |     function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)
  414 |     |         external
  415 |     |         returns (EthGetLogs[] memory logs);
  416 |     | 
  417 |     |     /// Gets the current `block.blobbasefee`.
  418 |     |     /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,
  419 |     |     /// and as a result will get optimized out by the compiler.
  420 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  421 |     |     function getBlobBaseFee() external view returns (uint256 blobBaseFee);
  422 |     | 
  423 |     |     /// Gets the current `block.number`.
  424 |     |     /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,
  425 |     |     /// and as a result will get optimized out by the compiler.
  426 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  427 |     |     function getBlockNumber() external view returns (uint256 height);
  428 |     | 
  429 |     |     /// Gets the current `block.timestamp`.
  430 |     |     /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,
  431 |     |     /// and as a result will get optimized out by the compiler.
  432 |     |     /// See https://github.com/foundry-rs/foundry/issues/6180
  433 |     |     function getBlockTimestamp() external view returns (uint256 timestamp);
  434 |     | 
  435 |     |     /// Gets the map key and parent of a mapping at a given slot, for a given address.
  436 |     |     function getMappingKeyAndParentOf(address target, bytes32 elementSlot)
  437 |     |         external
  438 |     |         returns (bool found, bytes32 key, bytes32 parent);
  439 |     | 
  440 |     |     /// Gets the number of elements in the mapping at the given slot, for a given address.
  441 |     |     function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);
  442 |     | 
  443 |     |     /// Gets the elements at index idx of the mapping at the given slot, for a given address. The
  444 |     |     /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).
  445 |     |     function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);
  446 |     | 
  447 |     |     /// Gets the nonce of an account.
  448 |     |     function getNonce(address account) external view returns (uint64 nonce);
  449 |     | 
  450 |     |     /// Gets all the recorded logs.
  451 |     |     function getRecordedLogs() external returns (Log[] memory logs);
  452 |     | 
  453 |     |     /// Gets the gas used in the last call.
  454 |     |     function lastCallGas() external view returns (Gas memory gas);
  455 |     | 
  456 |     |     /// Loads a storage slot from an address.
  457 |     |     function load(address target, bytes32 slot) external view returns (bytes32 data);
  458 |     | 
  459 |     |     /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.
  460 |     |     function pauseGasMetering() external;
  461 |     | 
  462 |     |     /// Records all storage reads and writes.
  463 |     |     function record() external;
  464 |     | 
  465 |     |     /// Record all the transaction logs.
  466 |     |     function recordLogs() external;
  467 |     | 
  468 |     |     /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.
  469 |     |     function resumeGasMetering() external;
  470 |     | 
  471 |     |     /// Performs an Ethereum JSON-RPC request to the current fork URL.
  472 |     |     function rpc(string calldata method, string calldata params) external returns (bytes memory data);
  473 |     | 
  474 |     |     /// Signs `digest` with `privateKey` using the secp256r1 curve.
  475 |     |     function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);
  476 |     | 
  477 |     |     /// Signs `digest` with `privateKey` using the secp256k1 curve.
  478 |     |     function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  479 |     | 
  480 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  481 |     |     /// If `--sender` is provided, the signer with provided address is used, otherwise,
  482 |     |     /// if exactly one signer is provided to the script, that signer is used.
  483 |     |     /// Raises error if signer passed through `--sender` does not match any unlocked signers or
  484 |     |     /// if `--sender` is not provided and not exactly one signer is passed to the script.
  485 |     |     function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  486 |     | 
  487 |     |     /// Signs `digest` with signer provided to script using the secp256k1 curve.
  488 |     |     /// Raises error if none of the signers passed into the script have provided address.
  489 |     |     function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);
  490 |     | 
  491 |     |     /// Starts recording all map SSTOREs for later retrieval.
  492 |     |     function startMappingRecording() external;
  493 |     | 
  494 |     |     /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,
  495 |     |     /// along with the context of the calls
  496 |     |     function startStateDiffRecording() external;
  497 |     | 
  498 |     |     /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.
  499 |     |     function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);
  500 |     | 
  501 |     |     /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.
  502 |     |     function stopMappingRecording() external;
  503 |     | 
  504 |     |     // ======== Filesystem ========
  505 |     | 
  506 |     |     /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.
  507 |     |     /// `path` is relative to the project root.
  508 |     |     function closeFile(string calldata path) external;
  509 |     | 
  510 |     |     /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.
  511 |     |     /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.
  512 |     |     /// Both `from` and `to` are relative to the project root.
  513 |     |     function copyFile(string calldata from, string calldata to) external returns (uint64 copied);
  514 |     | 
  515 |     |     /// Creates a new, empty directory at the provided path.
  516 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  517 |     |     /// - User lacks permissions to modify `path`.
  518 |     |     /// - A parent of the given path doesn't exist and `recursive` is false.
  519 |     |     /// - `path` already exists and `recursive` is false.
  520 |     |     /// `path` is relative to the project root.
  521 |     |     function createDir(string calldata path, bool recursive) external;
  522 |     | 
  523 |     |     /// Returns true if the given path points to an existing entity, else returns false.
  524 |     |     function exists(string calldata path) external returns (bool result);
  525 |     | 
  526 |     |     /// Performs a foreign function call via the terminal.
  527 |     |     function ffi(string[] calldata commandInput) external returns (bytes memory result);
  528 |     | 
  529 |     |     /// Given a path, query the file system to get information about a file, directory, etc.
  530 |     |     function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);
  531 |     | 
  532 |     |     /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  533 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  534 |     |     function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);
  535 |     | 
  536 |     |     /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the
  537 |     |     /// artifact in the form of <path>:<contract>:<version> where <contract> and <version> parts are optional.
  538 |     |     function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);
  539 |     | 
  540 |     |     /// Returns true if the path exists on disk and is pointing at a directory, else returns false.
  541 |     |     function isDir(string calldata path) external returns (bool result);
  542 |     | 
  543 |     |     /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.
  544 |     |     function isFile(string calldata path) external returns (bool result);
  545 |     | 
  546 |     |     /// Get the path of the current project root.
  547 |     |     function projectRoot() external view returns (string memory path);
  548 |     | 
  549 |     |     /// Prompts the user for a string value in the terminal.
  550 |     |     function prompt(string calldata promptText) external returns (string memory input);
  551 |     | 
  552 |     |     /// Prompts the user for an address in the terminal.
  553 |     |     function promptAddress(string calldata promptText) external returns (address);
  554 |     | 
  555 |     |     /// Prompts the user for a hidden string value in the terminal.
  556 |     |     function promptSecret(string calldata promptText) external returns (string memory input);
  557 |     | 
  558 |     |     /// Prompts the user for hidden uint256 in the terminal (usually pk).
  559 |     |     function promptSecretUint(string calldata promptText) external returns (uint256);
  560 |     | 
  561 |     |     /// Prompts the user for uint256 in the terminal.
  562 |     |     function promptUint(string calldata promptText) external returns (uint256);
  563 |     | 
  564 |     |     /// Reads the directory at the given path recursively, up to `maxDepth`.
  565 |     |     /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.
  566 |     |     /// Follows symbolic links if `followLinks` is true.
  567 |     |     function readDir(string calldata path) external view returns (DirEntry[] memory entries);
  568 |     | 
  569 |     |     /// See `readDir(string)`.
  570 |     |     function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);
  571 |     | 
  572 |     |     /// See `readDir(string)`.
  573 |     |     function readDir(string calldata path, uint64 maxDepth, bool followLinks)
  574 |     |         external
  575 |     |         view
  576 |     |         returns (DirEntry[] memory entries);
  577 |     | 
  578 |     |     /// Reads the entire content of file to string. `path` is relative to the project root.
  579 |     |     function readFile(string calldata path) external view returns (string memory data);
  580 |     | 
  581 |     |     /// Reads the entire content of file as binary. `path` is relative to the project root.
  582 |     |     function readFileBinary(string calldata path) external view returns (bytes memory data);
  583 |     | 
  584 |     |     /// Reads next line of file to string.
  585 |     |     function readLine(string calldata path) external view returns (string memory line);
  586 |     | 
  587 |     |     /// Reads a symbolic link, returning the path that the link points to.
  588 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  589 |     |     /// - `path` is not a symbolic link.
  590 |     |     /// - `path` does not exist.
  591 |     |     function readLink(string calldata linkPath) external view returns (string memory targetPath);
  592 |     | 
  593 |     |     /// Removes a directory at the provided path.
  594 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  595 |     |     /// - `path` doesn't exist.
  596 |     |     /// - `path` isn't a directory.
  597 |     |     /// - User lacks permissions to modify `path`.
  598 |     |     /// - The directory is not empty and `recursive` is false.
  599 |     |     /// `path` is relative to the project root.
  600 |     |     function removeDir(string calldata path, bool recursive) external;
  601 |     | 
  602 |     |     /// Removes a file from the filesystem.
  603 |     |     /// This cheatcode will revert in the following situations, but is not limited to just these cases:
  604 |     |     /// - `path` points to a directory.
  605 |     |     /// - The file doesn't exist.
  606 |     |     /// - The user lacks permissions to remove the file.
  607 |     |     /// `path` is relative to the project root.
  608 |     |     function removeFile(string calldata path) external;
  609 |     | 
  610 |     |     /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.
  611 |     |     function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);
  612 |     | 
  613 |     |     /// Returns the time since unix epoch in milliseconds.
  614 |     |     function unixTime() external returns (uint256 milliseconds);
  615 |     | 
  616 |     |     /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.
  617 |     |     /// `path` is relative to the project root.
  618 |     |     function writeFile(string calldata path, string calldata data) external;
  619 |     | 
  620 |     |     /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.
  621 |     |     /// `path` is relative to the project root.
  622 |     |     function writeFileBinary(string calldata path, bytes calldata data) external;
  623 |     | 
  624 |     |     /// Writes line to file, creating a file if it does not exist.
  625 |     |     /// `path` is relative to the project root.
  626 |     |     function writeLine(string calldata path, string calldata data) external;
  627 |     | 
  628 |     |     // ======== JSON ========
  629 |     | 
  630 |     |     /// Checks if `key` exists in a JSON object
  631 |     |     /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.
  632 |     |     function keyExists(string calldata json, string calldata key) external view returns (bool);
  633 |     | 
  634 |     |     /// Checks if `key` exists in a JSON object.
  635 |     |     function keyExistsJson(string calldata json, string calldata key) external view returns (bool);
  636 |     | 
  637 |     |     /// Parses a string of JSON data at `key` and coerces it to `address`.
  638 |     |     function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);
  639 |     | 
  640 |     |     /// Parses a string of JSON data at `key` and coerces it to `address[]`.
  641 |     |     function parseJsonAddressArray(string calldata json, string calldata key)
  642 |     |         external
  643 |     |         pure
  644 |     |         returns (address[] memory);
  645 |     | 
  646 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool`.
  647 |     |     function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);
  648 |     | 
  649 |     |     /// Parses a string of JSON data at `key` and coerces it to `bool[]`.
  650 |     |     function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);
  651 |     | 
  652 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes`.
  653 |     |     function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);
  654 |     | 
  655 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32`.
  656 |     |     function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);
  657 |     | 
  658 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.
  659 |     |     function parseJsonBytes32Array(string calldata json, string calldata key)
  660 |     |         external
  661 |     |         pure
  662 |     |         returns (bytes32[] memory);
  663 |     | 
  664 |     |     /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.
  665 |     |     function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);
  666 |     | 
  667 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256`.
  668 |     |     function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);
  669 |     | 
  670 |     |     /// Parses a string of JSON data at `key` and coerces it to `int256[]`.
  671 |     |     function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);
  672 |     | 
  673 |     |     /// Returns an array of all the keys in a JSON object.
  674 |     |     function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);
  675 |     | 
  676 |     |     /// Parses a string of JSON data at `key` and coerces it to `string`.
  677 |     |     function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);
  678 |     | 
  679 |     |     /// Parses a string of JSON data at `key` and coerces it to `string[]`.
  680 |     |     function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);
  681 |     | 
  682 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256`.
  683 |     |     function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);
  684 |     | 
  685 |     |     /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.
  686 |     |     function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);
  687 |     | 
  688 |     |     /// ABI-encodes a JSON object.
  689 |     |     function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);
  690 |     | 
  691 |     |     /// ABI-encodes a JSON object at `key`.
  692 |     |     function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);
  693 |     | 
  694 |     |     /// See `serializeJson`.
  695 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address value)
  696 |     |         external
  697 |     |         returns (string memory json);
  698 |     | 
  699 |     |     /// See `serializeJson`.
  700 |     |     function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)
  701 |     |         external
  702 |     |         returns (string memory json);
  703 |     | 
  704 |     |     /// See `serializeJson`.
  705 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool value)
  706 |     |         external
  707 |     |         returns (string memory json);
  708 |     | 
  709 |     |     /// See `serializeJson`.
  710 |     |     function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)
  711 |     |         external
  712 |     |         returns (string memory json);
  713 |     | 
  714 |     |     /// See `serializeJson`.
  715 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)
  716 |     |         external
  717 |     |         returns (string memory json);
  718 |     | 
  719 |     |     /// See `serializeJson`.
  720 |     |     function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)
  721 |     |         external
  722 |     |         returns (string memory json);
  723 |     | 
  724 |     |     /// See `serializeJson`.
  725 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)
  726 |     |         external
  727 |     |         returns (string memory json);
  728 |     | 
  729 |     |     /// See `serializeJson`.
  730 |     |     function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)
  731 |     |         external
  732 |     |         returns (string memory json);
  733 |     | 
  734 |     |     /// See `serializeJson`.
  735 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)
  736 |     |         external
  737 |     |         returns (string memory json);
  738 |     | 
  739 |     |     /// See `serializeJson`.
  740 |     |     function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)
  741 |     |         external
  742 |     |         returns (string memory json);
  743 |     | 
  744 |     |     /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.
  745 |     |     /// Returns the stringified version of the specific JSON file up to that moment.
  746 |     |     function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);
  747 |     | 
  748 |     |     /// See `serializeJson`.
  749 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)
  750 |     |         external
  751 |     |         returns (string memory json);
  752 |     | 
  753 |     |     /// See `serializeJson`.
  754 |     |     function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)
  755 |     |         external
  756 |     |         returns (string memory json);
  757 |     | 
  758 |     |     /// See `serializeJson`.
  759 |     |     function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)
  760 |     |         external
  761 |     |         returns (string memory json);
  762 |     | 
  763 |     |     /// See `serializeJson`.
  764 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)
  765 |     |         external
  766 |     |         returns (string memory json);
  767 |     | 
  768 |     |     /// See `serializeJson`.
  769 |     |     function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)
  770 |     |         external
  771 |     |         returns (string memory json);
  772 |     | 
  773 |     |     /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.
  774 |     |     function writeJson(string calldata json, string calldata path) external;
  775 |     | 
  776 |     |     /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = <value_key.>
  777 |     |     /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.
  778 |     |     function writeJson(string calldata json, string calldata path, string calldata valueKey) external;
  779 |     | 
  780 |     |     // ======== Scripting ========
  781 |     | 
  782 |     |     /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.
  783 |     |     /// Broadcasting address is determined by checking the following in order:
  784 |     |     /// 1. If `--sender` argument was provided, that address is used.
  785 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
  786 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
  787 |     |     function broadcast() external;
  788 |     | 
  789 |     |     /// Has the next call (at this call depth only) create a transaction with the address provided
  790 |     |     /// as the sender that can later be signed and sent onchain.
  791 |     |     function broadcast(address signer) external;
  792 |     | 
  793 |     |     /// Has the next call (at this call depth only) create a transaction with the private key
  794 |     |     /// provided as the sender that can later be signed and sent onchain.
  795 |     |     function broadcast(uint256 privateKey) external;
  796 |     | 
  797 |     |     /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.
  798 |     |     /// Broadcasting address is determined by checking the following in order:
  799 |     |     /// 1. If `--sender` argument was provided, that address is used.
  800 |     |     /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.
  801 |     |     /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.
  802 |     |     function startBroadcast() external;
  803 |     | 
  804 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the address
  805 |     |     /// provided that can later be signed and sent onchain.
  806 |     |     function startBroadcast(address signer) external;
  807 |     | 
  808 |     |     /// Has all subsequent calls (at this call depth only) create transactions with the private key
  809 |     |     /// provided that can later be signed and sent onchain.
  810 |     |     function startBroadcast(uint256 privateKey) external;
  811 |     | 
  812 |     |     /// Stops collecting onchain transactions.
  813 |     |     function stopBroadcast() external;
  814 |     | 
  815 |     |     // ======== String ========
  816 |     | 
  817 |     |     /// Returns the index of the first occurrence of a `key` in an `input` string.
  818 |     |     /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.
  819 |     |     /// Returns 0 in case of an empty `key`.
  820 |     |     function indexOf(string calldata input, string calldata key) external pure returns (uint256);
  821 |     | 
  822 |     |     /// Parses the given `string` into an `address`.
  823 |     |     function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);
  824 |     | 
  825 |     |     /// Parses the given `string` into a `bool`.
  826 |     |     function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);
  827 |     | 
  828 |     |     /// Parses the given `string` into `bytes`.
  829 |     |     function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);
  830 |     | 
  831 |     |     /// Parses the given `string` into a `bytes32`.
  832 |     |     function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);
  833 |     | 
  834 |     |     /// Parses the given `string` into a `int256`.
  835 |     |     function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);
  836 |     | 
  837 |     |     /// Parses the given `string` into a `uint256`.
  838 |     |     function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);
  839 |     | 
  840 |     |     /// Replaces occurrences of `from` in the given `string` with `to`.
  841 |     |     function replace(string calldata input, string calldata from, string calldata to)
  842 |     |         external
  843 |     |         pure
  844 |     |         returns (string memory output);
  845 |     | 
  846 |     |     /// Splits the given `string` into an array of strings divided by the `delimiter`.
  847 |     |     function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);
  848 |     | 
  849 |     |     /// Converts the given `string` value to Lowercase.
  850 |     |     function toLowercase(string calldata input) external pure returns (string memory output);
  851 |     | 
  852 |     |     /// Converts the given value to a `string`.
  853 |     |     function toString(address value) external pure returns (string memory stringifiedValue);
  854 |     | 
  855 |     |     /// Converts the given value to a `string`.
  856 |     |     function toString(bytes calldata value) external pure returns (string memory stringifiedValue);
  857 |     | 
  858 |     |     /// Converts the given value to a `string`.
  859 |     |     function toString(bytes32 value) external pure returns (string memory stringifiedValue);
  860 |     | 
  861 |     |     /// Converts the given value to a `string`.
  862 |     |     function toString(bool value) external pure returns (string memory stringifiedValue);
  863 |     | 
  864 |     |     /// Converts the given value to a `string`.
  865 |     |     function toString(uint256 value) external pure returns (string memory stringifiedValue);
  866 |     | 
  867 |     |     /// Converts the given value to a `string`.
  868 |     |     function toString(int256 value) external pure returns (string memory stringifiedValue);
  869 |     | 
  870 |     |     /// Converts the given `string` value to Uppercase.
  871 |     |     function toUppercase(string calldata input) external pure returns (string memory output);
  872 |     | 
  873 |     |     /// Trims leading and trailing whitespace from the given `string` value.
  874 |     |     function trim(string calldata input) external pure returns (string memory output);
  875 |     | 
  876 |     |     // ======== Testing ========
  877 |     | 
  878 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  879 |     |     /// Formats values with decimals in failure message.
  880 |     |     function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;
  881 |     | 
  882 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  883 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  884 |     |     function assertApproxEqAbsDecimal(
  885 |     |         uint256 left,
  886 |     |         uint256 right,
  887 |     |         uint256 maxDelta,
  888 |     |         uint256 decimals,
  889 |     |         string calldata error
  890 |     |     ) external pure;
  891 |     | 
  892 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  893 |     |     /// Formats values with decimals in failure message.
  894 |     |     function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;
  895 |     | 
  896 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  897 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  898 |     |     function assertApproxEqAbsDecimal(
  899 |     |         int256 left,
  900 |     |         int256 right,
  901 |     |         uint256 maxDelta,
  902 |     |         uint256 decimals,
  903 |     |         string calldata error
  904 |     |     ) external pure;
  905 |     | 
  906 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  907 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;
  908 |     | 
  909 |     |     /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.
  910 |     |     /// Includes error message into revert string on failure.
  911 |     |     function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;
  912 |     | 
  913 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  914 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;
  915 |     | 
  916 |     |     /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.
  917 |     |     /// Includes error message into revert string on failure.
  918 |     |     function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;
  919 |     | 
  920 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  921 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  922 |     |     /// Formats values with decimals in failure message.
  923 |     |     function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)
  924 |     |         external
  925 |     |         pure;
  926 |     | 
  927 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  928 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  929 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  930 |     |     function assertApproxEqRelDecimal(
  931 |     |         uint256 left,
  932 |     |         uint256 right,
  933 |     |         uint256 maxPercentDelta,
  934 |     |         uint256 decimals,
  935 |     |         string calldata error
  936 |     |     ) external pure;
  937 |     | 
  938 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  939 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  940 |     |     /// Formats values with decimals in failure message.
  941 |     |     function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)
  942 |     |         external
  943 |     |         pure;
  944 |     | 
  945 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  946 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  947 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
  948 |     |     function assertApproxEqRelDecimal(
  949 |     |         int256 left,
  950 |     |         int256 right,
  951 |     |         uint256 maxPercentDelta,
  952 |     |         uint256 decimals,
  953 |     |         string calldata error
  954 |     |     ) external pure;
  955 |     | 
  956 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  957 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  958 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;
  959 |     | 
  960 |     |     /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  961 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  962 |     |     /// Includes error message into revert string on failure.
  963 |     |     function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)
  964 |     |         external
  965 |     |         pure;
  966 |     | 
  967 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  968 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  969 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;
  970 |     | 
  971 |     |     /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.
  972 |     |     /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%
  973 |     |     /// Includes error message into revert string on failure.
  974 |     |     function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)
  975 |     |         external
  976 |     |         pure;
  977 |     | 
  978 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
  979 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
  980 |     | 
  981 |     |     /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.
  982 |     |     /// Includes error message into revert string on failure.
  983 |     |     function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
  984 |     | 
  985 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
  986 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
  987 |     | 
  988 |     |     /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.
  989 |     |     /// Includes error message into revert string on failure.
  990 |     |     function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
  991 |     | 
  992 |     |     /// Asserts that two `bool` values are equal.
  993 |     |     function assertEq(bool left, bool right) external pure;
  994 |     | 
  995 |     |     /// Asserts that two `bool` values are equal and includes error message into revert string on failure.
  996 |     |     function assertEq(bool left, bool right, string calldata error) external pure;
  997 |     | 
  998 |     |     /// Asserts that two `string` values are equal.
  999 |     |     function assertEq(string calldata left, string calldata right) external pure;
 1000 |     | 
 1001 |     |     /// Asserts that two `string` values are equal and includes error message into revert string on failure.
 1002 |     |     function assertEq(string calldata left, string calldata right, string calldata error) external pure;
 1003 |     | 
 1004 |     |     /// Asserts that two `bytes` values are equal.
 1005 |     |     function assertEq(bytes calldata left, bytes calldata right) external pure;
 1006 |     | 
 1007 |     |     /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.
 1008 |     |     function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1009 |     | 
 1010 |     |     /// Asserts that two arrays of `bool` values are equal.
 1011 |     |     function assertEq(bool[] calldata left, bool[] calldata right) external pure;
 1012 |     | 
 1013 |     |     /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.
 1014 |     |     function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1015 |     | 
 1016 |     |     /// Asserts that two arrays of `uint256 values are equal.
 1017 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1018 |     | 
 1019 |     |     /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.
 1020 |     |     function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1021 |     | 
 1022 |     |     /// Asserts that two arrays of `int256` values are equal.
 1023 |     |     function assertEq(int256[] calldata left, int256[] calldata right) external pure;
 1024 |     | 
 1025 |     |     /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.
 1026 |     |     function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1027 |     | 
 1028 |     |     /// Asserts that two `uint256` values are equal.
 1029 |     |     function assertEq(uint256 left, uint256 right) external pure;
 1030 |     | 
 1031 |     |     /// Asserts that two arrays of `address` values are equal.
 1032 |     |     function assertEq(address[] calldata left, address[] calldata right) external pure;
 1033 |     | 
 1034 |     |     /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.
 1035 |     |     function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1036 |     | 
 1037 |     |     /// Asserts that two arrays of `bytes32` values are equal.
 1038 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1039 |     | 
 1040 |     |     /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.
 1041 |     |     function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1042 |     | 
 1043 |     |     /// Asserts that two arrays of `string` values are equal.
 1044 |     |     function assertEq(string[] calldata left, string[] calldata right) external pure;
 1045 |     | 
 1046 |     |     /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.
 1047 |     |     function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1048 |     | 
 1049 |     |     /// Asserts that two arrays of `bytes` values are equal.
 1050 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1051 |     | 
 1052 |     |     /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.
 1053 |     |     function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1054 |     | 
 1055 |     |     /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.
 1056 |     |     function assertEq(uint256 left, uint256 right, string calldata error) external pure;
 1057 |     | 
 1058 |     |     /// Asserts that two `int256` values are equal.
 1059 |     |     function assertEq(int256 left, int256 right) external pure;
 1060 |     | 
 1061 |     |     /// Asserts that two `int256` values are equal and includes error message into revert string on failure.
 1062 |     |     function assertEq(int256 left, int256 right, string calldata error) external pure;
 1063 |     | 
 1064 |     |     /// Asserts that two `address` values are equal.
 1065 |     |     function assertEq(address left, address right) external pure;
 1066 |     | 
 1067 |     |     /// Asserts that two `address` values are equal and includes error message into revert string on failure.
 1068 |     |     function assertEq(address left, address right, string calldata error) external pure;
 1069 |     | 
 1070 |     |     /// Asserts that two `bytes32` values are equal.
 1071 |     |     function assertEq(bytes32 left, bytes32 right) external pure;
 1072 |     | 
 1073 |     |     /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.
 1074 |     |     function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1075 |     | 
 1076 |     |     /// Asserts that the given condition is false.
 1077 |     |     function assertFalse(bool condition) external pure;
 1078 |     | 
 1079 |     |     /// Asserts that the given condition is false and includes error message into revert string on failure.
 1080 |     |     function assertFalse(bool condition, string calldata error) external pure;
 1081 |     | 
 1082 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1083 |     |     /// Formats values with decimals in failure message.
 1084 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1085 |     | 
 1086 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1087 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1088 |     |     function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1089 |     | 
 1090 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1091 |     |     /// Formats values with decimals in failure message.
 1092 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1093 |     | 
 1094 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1095 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1096 |     |     function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1097 |     | 
 1098 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1099 |     |     function assertGe(uint256 left, uint256 right) external pure;
 1100 |     | 
 1101 |     |     /// Compares two `uint256` values. Expects first value to be greater than or equal to second.
 1102 |     |     /// Includes error message into revert string on failure.
 1103 |     |     function assertGe(uint256 left, uint256 right, string calldata error) external pure;
 1104 |     | 
 1105 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1106 |     |     function assertGe(int256 left, int256 right) external pure;
 1107 |     | 
 1108 |     |     /// Compares two `int256` values. Expects first value to be greater than or equal to second.
 1109 |     |     /// Includes error message into revert string on failure.
 1110 |     |     function assertGe(int256 left, int256 right, string calldata error) external pure;
 1111 |     | 
 1112 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1113 |     |     /// Formats values with decimals in failure message.
 1114 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1115 |     | 
 1116 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1117 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1118 |     |     function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1119 |     | 
 1120 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1121 |     |     /// Formats values with decimals in failure message.
 1122 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1123 |     | 
 1124 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1125 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1126 |     |     function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1127 |     | 
 1128 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1129 |     |     function assertGt(uint256 left, uint256 right) external pure;
 1130 |     | 
 1131 |     |     /// Compares two `uint256` values. Expects first value to be greater than second.
 1132 |     |     /// Includes error message into revert string on failure.
 1133 |     |     function assertGt(uint256 left, uint256 right, string calldata error) external pure;
 1134 |     | 
 1135 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1136 |     |     function assertGt(int256 left, int256 right) external pure;
 1137 |     | 
 1138 |     |     /// Compares two `int256` values. Expects first value to be greater than second.
 1139 |     |     /// Includes error message into revert string on failure.
 1140 |     |     function assertGt(int256 left, int256 right, string calldata error) external pure;
 1141 |     | 
 1142 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1143 |     |     /// Formats values with decimals in failure message.
 1144 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1145 |     | 
 1146 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1147 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1148 |     |     function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1149 |     | 
 1150 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1151 |     |     /// Formats values with decimals in failure message.
 1152 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1153 |     | 
 1154 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1155 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1156 |     |     function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1157 |     | 
 1158 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1159 |     |     function assertLe(uint256 left, uint256 right) external pure;
 1160 |     | 
 1161 |     |     /// Compares two `uint256` values. Expects first value to be less than or equal to second.
 1162 |     |     /// Includes error message into revert string on failure.
 1163 |     |     function assertLe(uint256 left, uint256 right, string calldata error) external pure;
 1164 |     | 
 1165 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1166 |     |     function assertLe(int256 left, int256 right) external pure;
 1167 |     | 
 1168 |     |     /// Compares two `int256` values. Expects first value to be less than or equal to second.
 1169 |     |     /// Includes error message into revert string on failure.
 1170 |     |     function assertLe(int256 left, int256 right, string calldata error) external pure;
 1171 |     | 
 1172 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1173 |     |     /// Formats values with decimals in failure message.
 1174 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1175 |     | 
 1176 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1177 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1178 |     |     function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1179 |     | 
 1180 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1181 |     |     /// Formats values with decimals in failure message.
 1182 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1183 |     | 
 1184 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1185 |     |     /// Formats values with decimals in failure message. Includes error message into revert string on failure.
 1186 |     |     function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1187 |     | 
 1188 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1189 |     |     function assertLt(uint256 left, uint256 right) external pure;
 1190 |     | 
 1191 |     |     /// Compares two `uint256` values. Expects first value to be less than second.
 1192 |     |     /// Includes error message into revert string on failure.
 1193 |     |     function assertLt(uint256 left, uint256 right, string calldata error) external pure;
 1194 |     | 
 1195 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1196 |     |     function assertLt(int256 left, int256 right) external pure;
 1197 |     | 
 1198 |     |     /// Compares two `int256` values. Expects first value to be less than second.
 1199 |     |     /// Includes error message into revert string on failure.
 1200 |     |     function assertLt(int256 left, int256 right, string calldata error) external pure;
 1201 |     | 
 1202 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1203 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;
 1204 |     | 
 1205 |     |     /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.
 1206 |     |     /// Includes error message into revert string on failure.
 1207 |     |     function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;
 1208 |     | 
 1209 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1210 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;
 1211 |     | 
 1212 |     |     /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.
 1213 |     |     /// Includes error message into revert string on failure.
 1214 |     |     function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;
 1215 |     | 
 1216 |     |     /// Asserts that two `bool` values are not equal.
 1217 |     |     function assertNotEq(bool left, bool right) external pure;
 1218 |     | 
 1219 |     |     /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.
 1220 |     |     function assertNotEq(bool left, bool right, string calldata error) external pure;
 1221 |     | 
 1222 |     |     /// Asserts that two `string` values are not equal.
 1223 |     |     function assertNotEq(string calldata left, string calldata right) external pure;
 1224 |     | 
 1225 |     |     /// Asserts that two `string` values are not equal and includes error message into revert string on failure.
 1226 |     |     function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;
 1227 |     | 
 1228 |     |     /// Asserts that two `bytes` values are not equal.
 1229 |     |     function assertNotEq(bytes calldata left, bytes calldata right) external pure;
 1230 |     | 
 1231 |     |     /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.
 1232 |     |     function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;
 1233 |     | 
 1234 |     |     /// Asserts that two arrays of `bool` values are not equal.
 1235 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;
 1236 |     | 
 1237 |     |     /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.
 1238 |     |     function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;
 1239 |     | 
 1240 |     |     /// Asserts that two arrays of `uint256` values are not equal.
 1241 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;
 1242 |     | 
 1243 |     |     /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.
 1244 |     |     function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;
 1245 |     | 
 1246 |     |     /// Asserts that two arrays of `int256` values are not equal.
 1247 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;
 1248 |     | 
 1249 |     |     /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.
 1250 |     |     function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;
 1251 |     | 
 1252 |     |     /// Asserts that two `uint256` values are not equal.
 1253 |     |     function assertNotEq(uint256 left, uint256 right) external pure;
 1254 |     | 
 1255 |     |     /// Asserts that two arrays of `address` values are not equal.
 1256 |     |     function assertNotEq(address[] calldata left, address[] calldata right) external pure;
 1257 |     | 
 1258 |     |     /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.
 1259 |     |     function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;
 1260 |     | 
 1261 |     |     /// Asserts that two arrays of `bytes32` values are not equal.
 1262 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;
 1263 |     | 
 1264 |     |     /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.
 1265 |     |     function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;
 1266 |     | 
 1267 |     |     /// Asserts that two arrays of `string` values are not equal.
 1268 |     |     function assertNotEq(string[] calldata left, string[] calldata right) external pure;
 1269 |     | 
 1270 |     |     /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.
 1271 |     |     function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;
 1272 |     | 
 1273 |     |     /// Asserts that two arrays of `bytes` values are not equal.
 1274 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;
 1275 |     | 
 1276 |     |     /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.
 1277 |     |     function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;
 1278 |     | 
 1279 |     |     /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.
 1280 |     |     function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;
 1281 |     | 
 1282 |     |     /// Asserts that two `int256` values are not equal.
 1283 |     |     function assertNotEq(int256 left, int256 right) external pure;
 1284 |     | 
 1285 |     |     /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.
 1286 |     |     function assertNotEq(int256 left, int256 right, string calldata error) external pure;
 1287 |     | 
 1288 |     |     /// Asserts that two `address` values are not equal.
 1289 |     |     function assertNotEq(address left, address right) external pure;
 1290 |     | 
 1291 |     |     /// Asserts that two `address` values are not equal and includes error message into revert string on failure.
 1292 |     |     function assertNotEq(address left, address right, string calldata error) external pure;
 1293 |     | 
 1294 |     |     /// Asserts that two `bytes32` values are not equal.
 1295 |     |     function assertNotEq(bytes32 left, bytes32 right) external pure;
 1296 |     | 
 1297 |     |     /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.
 1298 |     |     function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;
 1299 |     | 
 1300 |     |     /// Asserts that the given condition is true.
 1301 |     |     function assertTrue(bool condition) external pure;
 1302 |     | 
 1303 |     |     /// Asserts that the given condition is true and includes error message into revert string on failure.
 1304 |     |     function assertTrue(bool condition, string calldata error) external pure;
 1305 |     | 
 1306 |     |     /// If the condition is false, discard this run's fuzz inputs and generate new ones.
 1307 |     |     function assume(bool condition) external pure;
 1308 |     | 
 1309 |     |     /// Writes a breakpoint to jump to in the debugger.
 1310 |     |     function breakpoint(string calldata char) external;
 1311 |     | 
 1312 |     |     /// Writes a conditional breakpoint to jump to in the debugger.
 1313 |     |     function breakpoint(string calldata char, bool value) external;
 1314 |     | 
 1315 |     |     /// Returns the RPC url for the given alias.
 1316 |     |     function rpcUrl(string calldata rpcAlias) external view returns (string memory json);
 1317 |     | 
 1318 |     |     /// Returns all rpc urls and their aliases as structs.
 1319 |     |     function rpcUrlStructs() external view returns (Rpc[] memory urls);
 1320 |     | 
 1321 |     |     /// Returns all rpc urls and their aliases `[alias, url][]`.
 1322 |     |     function rpcUrls() external view returns (string[2][] memory urls);
 1323 |     | 
 1324 |     |     /// Suspends execution of the main thread for `duration` milliseconds.
 1325 |     |     function sleep(uint256 duration) external;
 1326 |     | 
 1327 |     |     // ======== Toml ========
 1328 |     | 
 1329 |     |     /// Checks if `key` exists in a TOML table.
 1330 |     |     function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);
 1331 |     | 
 1332 |     |     /// Parses a string of TOML data at `key` and coerces it to `address`.
 1333 |     |     function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);
 1334 |     | 
 1335 |     |     /// Parses a string of TOML data at `key` and coerces it to `address[]`.
 1336 |     |     function parseTomlAddressArray(string calldata toml, string calldata key)
 1337 |     |         external
 1338 |     |         pure
 1339 |     |         returns (address[] memory);
 1340 |     | 
 1341 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool`.
 1342 |     |     function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);
 1343 |     | 
 1344 |     |     /// Parses a string of TOML data at `key` and coerces it to `bool[]`.
 1345 |     |     function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);
 1346 |     | 
 1347 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes`.
 1348 |     |     function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);
 1349 |     | 
 1350 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32`.
 1351 |     |     function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);
 1352 |     | 
 1353 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.
 1354 |     |     function parseTomlBytes32Array(string calldata toml, string calldata key)
 1355 |     |         external
 1356 |     |         pure
 1357 |     |         returns (bytes32[] memory);
 1358 |     | 
 1359 |     |     /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.
 1360 |     |     function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);
 1361 |     | 
 1362 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256`.
 1363 |     |     function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);
 1364 |     | 
 1365 |     |     /// Parses a string of TOML data at `key` and coerces it to `int256[]`.
 1366 |     |     function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);
 1367 |     | 
 1368 |     |     /// Returns an array of all the keys in a TOML table.
 1369 |     |     function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);
 1370 |     | 
 1371 |     |     /// Parses a string of TOML data at `key` and coerces it to `string`.
 1372 |     |     function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);
 1373 |     | 
 1374 |     |     /// Parses a string of TOML data at `key` and coerces it to `string[]`.
 1375 |     |     function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);
 1376 |     | 
 1377 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256`.
 1378 |     |     function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);
 1379 |     | 
 1380 |     |     /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.
 1381 |     |     function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);
 1382 |     | 
 1383 |     |     /// ABI-encodes a TOML table.
 1384 |     |     function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);
 1385 |     | 
 1386 |     |     /// ABI-encodes a TOML table at `key`.
 1387 |     |     function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);
 1388 |     | 
 1389 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.
 1390 |     |     function writeToml(string calldata json, string calldata path) external;
 1391 |     | 
 1392 |     |     /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = <value_key.>
 1393 |     |     /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.
 1394 |     |     function writeToml(string calldata json, string calldata path, string calldata valueKey) external;
 1395 |     | 
 1396 |     |     // ======== Utilities ========
 1397 |     | 
 1398 |     |     /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.
 1399 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)
 1400 |     |         external
 1401 |     |         pure
 1402 |     |         returns (address);
 1403 |     | 
 1404 |     |     /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.
 1405 |     |     function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);
 1406 |     | 
 1407 |     |     /// Compute the address a contract will be deployed at for a given deployer address and nonce.
 1408 |     |     function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);
 1409 |     | 
 1410 |     |     /// Derives a private key from the name, labels the account with that name, and returns the wallet.
 1411 |     |     function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);
 1412 |     | 
 1413 |     |     /// Generates a wallet from the private key and returns the wallet.
 1414 |     |     function createWallet(uint256 privateKey) external returns (Wallet memory wallet);
 1415 |     | 
 1416 |     |     /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.
 1417 |     |     function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);
 1418 |     | 
 1419 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
 1420 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
 1421 |     |     function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);
 1422 |     | 
 1423 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path)
 1424 |     |     /// at `{derivationPath}{index}`.
 1425 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)
 1426 |     |         external
 1427 |     |         pure
 1428 |     |         returns (uint256 privateKey);
 1429 |     | 
 1430 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
 1431 |     |     /// at the derivation path `m/44'/60'/0'/0/{index}`.
 1432 |     |     function deriveKey(string calldata mnemonic, uint32 index, string calldata language)
 1433 |     |         external
 1434 |     |         pure
 1435 |     |         returns (uint256 privateKey);
 1436 |     | 
 1437 |     |     /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language
 1438 |     |     /// at `{derivationPath}{index}`.
 1439 |     |     function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)
 1440 |     |         external
 1441 |     |         pure
 1442 |     |         returns (uint256 privateKey);
 1443 |     | 
 1444 |     |     /// Returns ENS namehash for provided string.
 1445 |     |     function ensNamehash(string calldata name) external pure returns (bytes32);
 1446 |     | 
 1447 |     |     /// Gets the label for the specified address.
 1448 |     |     function getLabel(address account) external view returns (string memory currentLabel);
 1449 |     | 
 1450 |     |     /// Get a `Wallet`'s nonce.
 1451 |     |     function getNonce(Wallet calldata wallet) external returns (uint64 nonce);
 1452 |     | 
 1453 |     |     /// Labels an address in call traces.
 1454 |     |     function label(address account, string calldata newLabel) external;
 1455 |     | 
 1456 |     |     /// Returns a random `address`.
 1457 |     |     function randomAddress() external returns (address);
 1458 |     | 
 1459 |     |     /// Returns a random uint256 value.
 1460 |     |     function randomUint() external returns (uint256);
 1461 |     | 
 1462 |     |     /// Returns random uin256 value between the provided range (=min..=max).
 1463 |     |     function randomUint(uint256 min, uint256 max) external returns (uint256);
 1464 |     | 
 1465 |     |     /// Adds a private key to the local forge wallet and returns the address.
 1466 |     |     function rememberKey(uint256 privateKey) external returns (address keyAddr);
 1467 |     | 
 1468 |     |     /// Signs data with a `Wallet`.
 1469 |     |     function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);
 1470 |     | 
 1471 |     |     /// Encodes a `bytes` value to a base64url string.
 1472 |     |     function toBase64URL(bytes calldata data) external pure returns (string memory);
 1473 |     | 
 1474 |     |     /// Encodes a `string` value to a base64url string.
 1475 |     |     function toBase64URL(string calldata data) external pure returns (string memory);
 1476 |     | 
 1477 |     |     /// Encodes a `bytes` value to a base64 string.
 1478 |     |     function toBase64(bytes calldata data) external pure returns (string memory);
 1479 |     | 
 1480 |     |     /// Encodes a `string` value to a base64 string.
 1481 |     |     function toBase64(string calldata data) external pure returns (string memory);
 1482 |     | }
 1483 |     | 
 1484 |     | /// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used
 1485 |     | /// in tests, but it is not recommended to use these cheats in scripts.
 1486 |     | interface Vm is VmSafe {
 1487 |     |     // ======== EVM ========
 1488 |     | 
 1489 |     |     /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.
 1490 |     |     function activeFork() external view returns (uint256 forkId);
 1491 |     | 
 1492 |     |     /// In forking mode, explicitly grant the given address cheatcode access.
 1493 |     |     function allowCheatcodes(address account) external;
 1494 |     | 
 1495 |     |     /// Sets `block.blobbasefee`
 1496 |     |     function blobBaseFee(uint256 newBlobBaseFee) external;
 1497 |     | 
 1498 |     |     /// Sets the blobhashes in the transaction.
 1499 |     |     /// Not available on EVM versions before Cancun.
 1500 |     |     /// If used on unsupported EVM versions it will revert.
 1501 |     |     function blobhashes(bytes32[] calldata hashes) external;
 1502 |     | 
 1503 |     |     /// Sets `block.chainid`.
 1504 |     |     function chainId(uint256 newChainId) external;
 1505 |     | 
 1506 |     |     /// Clears all mocked calls.
 1507 |     |     function clearMockedCalls() external;
 1508 |     | 
 1509 |     |     /// Sets `block.coinbase`.
 1510 |     |     function coinbase(address newCoinbase) external;
 1511 |     | 
 1512 |     |     /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.
 1513 |     |     function createFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1514 |     | 
 1515 |     |     /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.
 1516 |     |     function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1517 |     | 
 1518 |     |     /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,
 1519 |     |     /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.
 1520 |     |     function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1521 |     | 
 1522 |     |     /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.
 1523 |     |     function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);
 1524 |     | 
 1525 |     |     /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.
 1526 |     |     function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);
 1527 |     | 
 1528 |     |     /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,
 1529 |     |     /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.
 1530 |     |     function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);
 1531 |     | 
 1532 |     |     /// Sets an address' balance.
 1533 |     |     function deal(address account, uint256 newBalance) external;
 1534 |     | 
 1535 |     |     /// Removes the snapshot with the given ID created by `snapshot`.
 1536 |     |     /// Takes the snapshot ID to delete.
 1537 |     |     /// Returns `true` if the snapshot was successfully deleted.
 1538 |     |     /// Returns `false` if the snapshot does not exist.
 1539 |     |     function deleteSnapshot(uint256 snapshotId) external returns (bool success);
 1540 |     | 
 1541 |     |     /// Removes _all_ snapshots previously created by `snapshot`.
 1542 |     |     function deleteSnapshots() external;
 1543 |     | 
 1544 |     |     /// Sets `block.difficulty`.
 1545 |     |     /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.
 1546 |     |     /// Reverts if used on unsupported EVM versions.
 1547 |     |     function difficulty(uint256 newDifficulty) external;
 1548 |     | 
 1549 |     |     /// Dump a genesis JSON file's `allocs` to disk.
 1550 |     |     function dumpState(string calldata pathToStateJson) external;
 1551 |     | 
 1552 |     |     /// Sets an address' code.
 1553 |     |     function etch(address target, bytes calldata newRuntimeBytecode) external;
 1554 |     | 
 1555 |     |     /// Sets `block.basefee`.
 1556 |     |     function fee(uint256 newBasefee) external;
 1557 |     | 
 1558 |     |     /// Gets the blockhashes from the current transaction.
 1559 |     |     /// Not available on EVM versions before Cancun.
 1560 |     |     /// If used on unsupported EVM versions it will revert.
 1561 |     |     function getBlobhashes() external view returns (bytes32[] memory hashes);
 1562 |     | 
 1563 |     |     /// Returns true if the account is marked as persistent.
 1564 |     |     function isPersistent(address account) external view returns (bool persistent);
 1565 |     | 
 1566 |     |     /// Load a genesis JSON file's `allocs` into the in-memory revm state.
 1567 |     |     function loadAllocs(string calldata pathToAllocsJson) external;
 1568 |     | 
 1569 |     |     /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup
 1570 |     |     /// Meaning, changes made to the state of this account will be kept when switching forks.
 1571 |     |     function makePersistent(address account) external;
 1572 |     | 
 1573 |     |     /// See `makePersistent(address)`.
 1574 |     |     function makePersistent(address account0, address account1) external;
 1575 |     | 
 1576 |     |     /// See `makePersistent(address)`.
 1577 |     |     function makePersistent(address account0, address account1, address account2) external;
 1578 |     | 
 1579 |     |     /// See `makePersistent(address)`.
 1580 |     |     function makePersistent(address[] calldata accounts) external;
 1581 |     | 
 1582 |     |     /// Reverts a call to an address with specified revert data.
 1583 |     |     function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;
 1584 |     | 
 1585 |     |     /// Reverts a call to an address with a specific `msg.value`, with specified revert data.
 1586 |     |     function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)
 1587 |     |         external;
 1588 |     | 
 1589 |     |     /// Mocks a call to an address, returning specified data.
 1590 |     |     /// Calldata can either be strict or a partial match, e.g. if you only
 1591 |     |     /// pass a Solidity selector to the expected calldata, then the entire Solidity
 1592 |     |     /// function will be mocked.
 1593 |     |     function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;
 1594 |     | 
 1595 |     |     /// Mocks a call to an address with a specific `msg.value`, returning specified data.
 1596 |     |     /// Calldata match takes precedence over `msg.value` in case of ambiguity.
 1597 |     |     function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;
 1598 |     | 
 1599 |     |     /// Sets the *next* call's `msg.sender` to be the input address.
 1600 |     |     function prank(address msgSender) external;
 1601 |     | 
 1602 |     |     /// Sets the *next* call's `msg.sender` to be the input address, and the `tx.origin` to be the second input.
 1603 |     |     function prank(address msgSender, address txOrigin) external;
 1604 |     | 
 1605 |     |     /// Sets `block.prevrandao`.
 1606 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 1607 |     |     /// If used on unsupported EVM versions it will revert.
 1608 |     |     function prevrandao(bytes32 newPrevrandao) external;
 1609 |     | 
 1610 |     |     /// Sets `block.prevrandao`.
 1611 |     |     /// Not available on EVM versions before Paris. Use `difficulty` instead.
 1612 |     |     /// If used on unsupported EVM versions it will revert.
 1613 |     |     function prevrandao(uint256 newPrevrandao) external;
 1614 |     | 
 1615 |     |     /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.
 1616 |     |     function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);
 1617 |     | 
 1618 |     |     /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.
 1619 |     |     function resetNonce(address account) external;
 1620 |     | 
 1621 |     |     /// Revert the state of the EVM to a previous snapshot
 1622 |     |     /// Takes the snapshot ID to revert to.
 1623 |     |     /// Returns `true` if the snapshot was successfully reverted.
 1624 |     |     /// Returns `false` if the snapshot does not exist.
 1625 |     |     /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.
 1626 |     |     function revertTo(uint256 snapshotId) external returns (bool success);
 1627 |     | 
 1628 |     |     /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots
 1629 |     |     /// Takes the snapshot ID to revert to.
 1630 |     |     /// Returns `true` if the snapshot was successfully reverted and deleted.
 1631 |     |     /// Returns `false` if the snapshot does not exist.
 1632 |     |     function revertToAndDelete(uint256 snapshotId) external returns (bool success);
 1633 |     | 
 1634 |     |     /// Revokes persistent status from the address, previously added via `makePersistent`.
 1635 |     |     function revokePersistent(address account) external;
 1636 |     | 
 1637 |     |     /// See `revokePersistent(address)`.
 1638 |     |     function revokePersistent(address[] calldata accounts) external;
 1639 |     | 
 1640 |     |     /// Sets `block.height`.
 1641 |     |     function roll(uint256 newHeight) external;
 1642 |     | 
 1643 |     |     /// Updates the currently active fork to given block number
 1644 |     |     /// This is similar to `roll` but for the currently active fork.
 1645 |     |     function rollFork(uint256 blockNumber) external;
 1646 |     | 
 1647 |     |     /// Updates the currently active fork to given transaction. This will `rollFork` with the number
 1648 |     |     /// of the block the transaction was mined in and replays all transaction mined before it in the block.
 1649 |     |     function rollFork(bytes32 txHash) external;
 1650 |     | 
 1651 |     |     /// Updates the given fork to given block number.
 1652 |     |     function rollFork(uint256 forkId, uint256 blockNumber) external;
 1653 |     | 
 1654 |     |     /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.
 1655 |     |     function rollFork(uint256 forkId, bytes32 txHash) external;
 1656 |     | 
 1657 |     |     /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.
 1658 |     |     function selectFork(uint256 forkId) external;
 1659 |     | 
 1660 |     |     /// Sets the nonce of an account. Must be higher than the current nonce of the account.
 1661 |     |     function setNonce(address account, uint64 newNonce) external;
 1662 |     | 
 1663 |     |     /// Sets the nonce of an account to an arbitrary value.
 1664 |     |     function setNonceUnsafe(address account, uint64 newNonce) external;
 1665 |     | 
 1666 |     |     /// Snapshot the current state of the evm.
 1667 |     |     /// Returns the ID of the snapshot that was created.
 1668 |     |     /// To revert a snapshot use `revertTo`.
 1669 |     |     function snapshot() external returns (uint256 snapshotId);
 1670 |     | 
 1671 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called.
 1672 |     |     function startPrank(address msgSender) external;
 1673 |     | 
 1674 |     |     /// Sets all subsequent calls' `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.
 1675 |     |     function startPrank(address msgSender, address txOrigin) external;
 1676 |     | 
 1677 |     |     /// Resets subsequent calls' `msg.sender` to be `address(this)`.
 1678 |     |     function stopPrank() external;
 1679 |     | 
 1680 |     |     /// Stores a value to an address' storage slot.
 1681 |     |     function store(address target, bytes32 slot, bytes32 value) external;
 1682 |     | 
 1683 |     |     /// Fetches the given transaction from the active fork and executes it on the current state.
 1684 |     |     function transact(bytes32 txHash) external;
 1685 |     | 
 1686 |     |     /// Fetches the given transaction from the given fork and executes it on the current state.
 1687 |     |     function transact(uint256 forkId, bytes32 txHash) external;
 1688 |     | 
 1689 |     |     /// Sets `tx.gasprice`.
 1690 |     |     function txGasPrice(uint256 newGasPrice) external;
 1691 |     | 
 1692 |     |     /// Sets `block.timestamp`.
 1693 |     |     function warp(uint256 newTimestamp) external;
 1694 |     | 
 1695 |     |     // ======== Testing ========
 1696 |     | 
 1697 |     |     /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1698 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;
 1699 |     | 
 1700 |     |     /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.
 1701 |     |     function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)
 1702 |     |         external;
 1703 |     | 
 1704 |     |     /// Expects a call to an address with the specified calldata.
 1705 |     |     /// Calldata can either be a strict or a partial match.
 1706 |     |     function expectCall(address callee, bytes calldata data) external;
 1707 |     | 
 1708 |     |     /// Expects given number of calls to an address with the specified calldata.
 1709 |     |     function expectCall(address callee, bytes calldata data, uint64 count) external;
 1710 |     | 
 1711 |     |     /// Expects a call to an address with the specified `msg.value` and calldata.
 1712 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data) external;
 1713 |     | 
 1714 |     |     /// Expects given number of calls to an address with the specified `msg.value` and calldata.
 1715 |     |     function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;
 1716 |     | 
 1717 |     |     /// Expect a call to an address with the specified `msg.value`, gas, and calldata.
 1718 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;
 1719 |     | 
 1720 |     |     /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.
 1721 |     |     function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;
 1722 |     | 
 1723 |     |     /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).
 1724 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1725 |     |     /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).
 1726 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;
 1727 |     | 
 1728 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1729 |     |     function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)
 1730 |     |         external;
 1731 |     | 
 1732 |     |     /// Prepare an expected log with all topic and data checks enabled.
 1733 |     |     /// Call this function, then emit an event, then call a function. Internally after the call, we check if
 1734 |     |     /// logs were emitted in the expected order with the expected topics and data.
 1735 |     |     function expectEmit() external;
 1736 |     | 
 1737 |     |     /// Same as the previous method, but also checks supplied address against emitting contract.
 1738 |     |     function expectEmit(address emitter) external;
 1739 |     | 
 1740 |     |     /// Expects an error on next call with any revert data.
 1741 |     |     function expectRevert() external;
 1742 |     | 
 1743 |     |     /// Expects an error on next call that starts with the revert data.
 1744 |     |     function expectRevert(bytes4 revertData) external;
 1745 |     | 
 1746 |     |     /// Expects an error on next call that exactly matches the revert data.
 1747 |     |     function expectRevert(bytes calldata revertData) external;
 1748 |     | 
 1749 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other
 1750 |     |     /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.
 1751 |     |     function expectSafeMemory(uint64 min, uint64 max) external;
 1752 |     | 
 1753 |     |     /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.
 1754 |     |     /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges
 1755 |     |     /// to the set.
 1756 |     |     function expectSafeMemoryCall(uint64 min, uint64 max) external;
 1757 |     | 
 1758 |     |     /// Marks a test as skipped. Must be called at the top of the test.
 1759 |     |     function skip(bool skipTest) external;
 1760 |     | 
 1761 |     |     /// Stops all safe memory expectation in the current subcontext.
 1762 |     |     function stopExpectSafeMemory() external;
 1763 |     | }
 1764 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/console.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | pragma solidity >=0.4.22 <0.9.0;
    3 |     | 
    4 |     | library console {
    5 |     |     address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);
    6 |     | 
    7 |     |     function _castLogPayloadViewToPure(
    8 |     |         function(bytes memory) internal view fnIn
    9 |     |     ) internal pure returns (function(bytes memory) internal pure fnOut) {
   10 |     |         assembly {
   11 |     |             fnOut := fnIn
   12 |     |         }
   13 |     |     }
   14 |     | 
   15 |     |     function _sendLogPayload(bytes memory payload) internal pure {
   16 |     |         _castLogPayloadViewToPure(_sendLogPayloadView)(payload);
   17 |     |     }
   18 |     | 
   19 |     |     function _sendLogPayloadView(bytes memory payload) private view {
   20 |     |         uint256 payloadLength = payload.length;
   21 |     |         address consoleAddress = CONSOLE_ADDRESS;
   22 |     |         /// @solidity memory-safe-assembly
   23 |     |         assembly {
   24 |     |             let payloadStart := add(payload, 32)
   25 |     |             let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)
   26 |     |         }
   27 |     |     }
   28 |     | 
   29 |     |     function log() internal pure {
   30 |     |         _sendLogPayload(abi.encodeWithSignature("log()"));
   31 |     |     }
   32 |     | 
   33 |     |     function logInt(int p0) internal pure {
   34 |     |         _sendLogPayload(abi.encodeWithSignature("log(int)", p0));
   35 |     |     }
   36 |     | 
   37 |     |     function logUint(uint p0) internal pure {
   38 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
   39 |     |     }
   40 |     | 
   41 |     |     function logString(string memory p0) internal pure {
   42 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
   43 |     |     }
   44 |     | 
   45 |     |     function logBool(bool p0) internal pure {
   46 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
   47 |     |     }
   48 |     | 
   49 |     |     function logAddress(address p0) internal pure {
   50 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
   51 |     |     }
   52 |     | 
   53 |     |     function logBytes(bytes memory p0) internal pure {
   54 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes)", p0));
   55 |     |     }
   56 |     | 
   57 |     |     function logBytes1(bytes1 p0) internal pure {
   58 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes1)", p0));
   59 |     |     }
   60 |     | 
   61 |     |     function logBytes2(bytes2 p0) internal pure {
   62 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes2)", p0));
   63 |     |     }
   64 |     | 
   65 |     |     function logBytes3(bytes3 p0) internal pure {
   66 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes3)", p0));
   67 |     |     }
   68 |     | 
   69 |     |     function logBytes4(bytes4 p0) internal pure {
   70 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes4)", p0));
   71 |     |     }
   72 |     | 
   73 |     |     function logBytes5(bytes5 p0) internal pure {
   74 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes5)", p0));
   75 |     |     }
   76 |     | 
   77 |     |     function logBytes6(bytes6 p0) internal pure {
   78 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes6)", p0));
   79 |     |     }
   80 |     | 
   81 |     |     function logBytes7(bytes7 p0) internal pure {
   82 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes7)", p0));
   83 |     |     }
   84 |     | 
   85 |     |     function logBytes8(bytes8 p0) internal pure {
   86 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes8)", p0));
   87 |     |     }
   88 |     | 
   89 |     |     function logBytes9(bytes9 p0) internal pure {
   90 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes9)", p0));
   91 |     |     }
   92 |     | 
   93 |     |     function logBytes10(bytes10 p0) internal pure {
   94 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes10)", p0));
   95 |     |     }
   96 |     | 
   97 |     |     function logBytes11(bytes11 p0) internal pure {
   98 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes11)", p0));
   99 |     |     }
  100 |     | 
  101 |     |     function logBytes12(bytes12 p0) internal pure {
  102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes12)", p0));
  103 |     |     }
  104 |     | 
  105 |     |     function logBytes13(bytes13 p0) internal pure {
  106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes13)", p0));
  107 |     |     }
  108 |     | 
  109 |     |     function logBytes14(bytes14 p0) internal pure {
  110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes14)", p0));
  111 |     |     }
  112 |     | 
  113 |     |     function logBytes15(bytes15 p0) internal pure {
  114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes15)", p0));
  115 |     |     }
  116 |     | 
  117 |     |     function logBytes16(bytes16 p0) internal pure {
  118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes16)", p0));
  119 |     |     }
  120 |     | 
  121 |     |     function logBytes17(bytes17 p0) internal pure {
  122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes17)", p0));
  123 |     |     }
  124 |     | 
  125 |     |     function logBytes18(bytes18 p0) internal pure {
  126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes18)", p0));
  127 |     |     }
  128 |     | 
  129 |     |     function logBytes19(bytes19 p0) internal pure {
  130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes19)", p0));
  131 |     |     }
  132 |     | 
  133 |     |     function logBytes20(bytes20 p0) internal pure {
  134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes20)", p0));
  135 |     |     }
  136 |     | 
  137 |     |     function logBytes21(bytes21 p0) internal pure {
  138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes21)", p0));
  139 |     |     }
  140 |     | 
  141 |     |     function logBytes22(bytes22 p0) internal pure {
  142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes22)", p0));
  143 |     |     }
  144 |     | 
  145 |     |     function logBytes23(bytes23 p0) internal pure {
  146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes23)", p0));
  147 |     |     }
  148 |     | 
  149 |     |     function logBytes24(bytes24 p0) internal pure {
  150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes24)", p0));
  151 |     |     }
  152 |     | 
  153 |     |     function logBytes25(bytes25 p0) internal pure {
  154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes25)", p0));
  155 |     |     }
  156 |     | 
  157 |     |     function logBytes26(bytes26 p0) internal pure {
  158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes26)", p0));
  159 |     |     }
  160 |     | 
  161 |     |     function logBytes27(bytes27 p0) internal pure {
  162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes27)", p0));
  163 |     |     }
  164 |     | 
  165 |     |     function logBytes28(bytes28 p0) internal pure {
  166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes28)", p0));
  167 |     |     }
  168 |     | 
  169 |     |     function logBytes29(bytes29 p0) internal pure {
  170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes29)", p0));
  171 |     |     }
  172 |     | 
  173 |     |     function logBytes30(bytes30 p0) internal pure {
  174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes30)", p0));
  175 |     |     }
  176 |     | 
  177 |     |     function logBytes31(bytes31 p0) internal pure {
  178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes31)", p0));
  179 |     |     }
  180 |     | 
  181 |     |     function logBytes32(bytes32 p0) internal pure {
  182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bytes32)", p0));
  183 |     |     }
  184 |     | 
  185 |     |     function log(uint p0) internal pure {
  186 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint)", p0));
  187 |     |     }
  188 |     | 
  189 |     |     function log(string memory p0) internal pure {
  190 |     |         _sendLogPayload(abi.encodeWithSignature("log(string)", p0));
  191 |     |     }
  192 |     | 
  193 |     |     function log(bool p0) internal pure {
  194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool)", p0));
  195 |     |     }
  196 |     | 
  197 |     |     function log(address p0) internal pure {
  198 |     |         _sendLogPayload(abi.encodeWithSignature("log(address)", p0));
  199 |     |     }
  200 |     | 
  201 |     |     function log(uint p0, uint p1) internal pure {
  202 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint)", p0, p1));
  203 |     |     }
  204 |     | 
  205 |     |     function log(uint p0, string memory p1) internal pure {
  206 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string)", p0, p1));
  207 |     |     }
  208 |     | 
  209 |     |     function log(uint p0, bool p1) internal pure {
  210 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool)", p0, p1));
  211 |     |     }
  212 |     | 
  213 |     |     function log(uint p0, address p1) internal pure {
  214 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address)", p0, p1));
  215 |     |     }
  216 |     | 
  217 |     |     function log(string memory p0, uint p1) internal pure {
  218 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint)", p0, p1));
  219 |     |     }
  220 |     | 
  221 |     |     function log(string memory p0, string memory p1) internal pure {
  222 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string)", p0, p1));
  223 |     |     }
  224 |     | 
  225 |     |     function log(string memory p0, bool p1) internal pure {
  226 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool)", p0, p1));
  227 |     |     }
  228 |     | 
  229 |     |     function log(string memory p0, address p1) internal pure {
  230 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address)", p0, p1));
  231 |     |     }
  232 |     | 
  233 |     |     function log(bool p0, uint p1) internal pure {
  234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint)", p0, p1));
  235 |     |     }
  236 |     | 
  237 |     |     function log(bool p0, string memory p1) internal pure {
  238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string)", p0, p1));
  239 |     |     }
  240 |     | 
  241 |     |     function log(bool p0, bool p1) internal pure {
  242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool)", p0, p1));
  243 |     |     }
  244 |     | 
  245 |     |     function log(bool p0, address p1) internal pure {
  246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address)", p0, p1));
  247 |     |     }
  248 |     | 
  249 |     |     function log(address p0, uint p1) internal pure {
  250 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint)", p0, p1));
  251 |     |     }
  252 |     | 
  253 |     |     function log(address p0, string memory p1) internal pure {
  254 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string)", p0, p1));
  255 |     |     }
  256 |     | 
  257 |     |     function log(address p0, bool p1) internal pure {
  258 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool)", p0, p1));
  259 |     |     }
  260 |     | 
  261 |     |     function log(address p0, address p1) internal pure {
  262 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address)", p0, p1));
  263 |     |     }
  264 |     | 
  265 |     |     function log(uint p0, uint p1, uint p2) internal pure {
  266 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint)", p0, p1, p2));
  267 |     |     }
  268 |     | 
  269 |     |     function log(uint p0, uint p1, string memory p2) internal pure {
  270 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string)", p0, p1, p2));
  271 |     |     }
  272 |     | 
  273 |     |     function log(uint p0, uint p1, bool p2) internal pure {
  274 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool)", p0, p1, p2));
  275 |     |     }
  276 |     | 
  277 |     |     function log(uint p0, uint p1, address p2) internal pure {
  278 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address)", p0, p1, p2));
  279 |     |     }
  280 |     | 
  281 |     |     function log(uint p0, string memory p1, uint p2) internal pure {
  282 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint)", p0, p1, p2));
  283 |     |     }
  284 |     | 
  285 |     |     function log(uint p0, string memory p1, string memory p2) internal pure {
  286 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string)", p0, p1, p2));
  287 |     |     }
  288 |     | 
  289 |     |     function log(uint p0, string memory p1, bool p2) internal pure {
  290 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool)", p0, p1, p2));
  291 |     |     }
  292 |     | 
  293 |     |     function log(uint p0, string memory p1, address p2) internal pure {
  294 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address)", p0, p1, p2));
  295 |     |     }
  296 |     | 
  297 |     |     function log(uint p0, bool p1, uint p2) internal pure {
  298 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint)", p0, p1, p2));
  299 |     |     }
  300 |     | 
  301 |     |     function log(uint p0, bool p1, string memory p2) internal pure {
  302 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string)", p0, p1, p2));
  303 |     |     }
  304 |     | 
  305 |     |     function log(uint p0, bool p1, bool p2) internal pure {
  306 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool)", p0, p1, p2));
  307 |     |     }
  308 |     | 
  309 |     |     function log(uint p0, bool p1, address p2) internal pure {
  310 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address)", p0, p1, p2));
  311 |     |     }
  312 |     | 
  313 |     |     function log(uint p0, address p1, uint p2) internal pure {
  314 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint)", p0, p1, p2));
  315 |     |     }
  316 |     | 
  317 |     |     function log(uint p0, address p1, string memory p2) internal pure {
  318 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string)", p0, p1, p2));
  319 |     |     }
  320 |     | 
  321 |     |     function log(uint p0, address p1, bool p2) internal pure {
  322 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool)", p0, p1, p2));
  323 |     |     }
  324 |     | 
  325 |     |     function log(uint p0, address p1, address p2) internal pure {
  326 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address)", p0, p1, p2));
  327 |     |     }
  328 |     | 
  329 |     |     function log(string memory p0, uint p1, uint p2) internal pure {
  330 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint)", p0, p1, p2));
  331 |     |     }
  332 |     | 
  333 |     |     function log(string memory p0, uint p1, string memory p2) internal pure {
  334 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string)", p0, p1, p2));
  335 |     |     }
  336 |     | 
  337 |     |     function log(string memory p0, uint p1, bool p2) internal pure {
  338 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool)", p0, p1, p2));
  339 |     |     }
  340 |     | 
  341 |     |     function log(string memory p0, uint p1, address p2) internal pure {
  342 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address)", p0, p1, p2));
  343 |     |     }
  344 |     | 
  345 |     |     function log(string memory p0, string memory p1, uint p2) internal pure {
  346 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint)", p0, p1, p2));
  347 |     |     }
  348 |     | 
  349 |     |     function log(string memory p0, string memory p1, string memory p2) internal pure {
  350 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string)", p0, p1, p2));
  351 |     |     }
  352 |     | 
  353 |     |     function log(string memory p0, string memory p1, bool p2) internal pure {
  354 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool)", p0, p1, p2));
  355 |     |     }
  356 |     | 
  357 |     |     function log(string memory p0, string memory p1, address p2) internal pure {
  358 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address)", p0, p1, p2));
  359 |     |     }
  360 |     | 
  361 |     |     function log(string memory p0, bool p1, uint p2) internal pure {
  362 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint)", p0, p1, p2));
  363 |     |     }
  364 |     | 
  365 |     |     function log(string memory p0, bool p1, string memory p2) internal pure {
  366 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string)", p0, p1, p2));
  367 |     |     }
  368 |     | 
  369 |     |     function log(string memory p0, bool p1, bool p2) internal pure {
  370 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool)", p0, p1, p2));
  371 |     |     }
  372 |     | 
  373 |     |     function log(string memory p0, bool p1, address p2) internal pure {
  374 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address)", p0, p1, p2));
  375 |     |     }
  376 |     | 
  377 |     |     function log(string memory p0, address p1, uint p2) internal pure {
  378 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint)", p0, p1, p2));
  379 |     |     }
  380 |     | 
  381 |     |     function log(string memory p0, address p1, string memory p2) internal pure {
  382 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string)", p0, p1, p2));
  383 |     |     }
  384 |     | 
  385 |     |     function log(string memory p0, address p1, bool p2) internal pure {
  386 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool)", p0, p1, p2));
  387 |     |     }
  388 |     | 
  389 |     |     function log(string memory p0, address p1, address p2) internal pure {
  390 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address)", p0, p1, p2));
  391 |     |     }
  392 |     | 
  393 |     |     function log(bool p0, uint p1, uint p2) internal pure {
  394 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint)", p0, p1, p2));
  395 |     |     }
  396 |     | 
  397 |     |     function log(bool p0, uint p1, string memory p2) internal pure {
  398 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string)", p0, p1, p2));
  399 |     |     }
  400 |     | 
  401 |     |     function log(bool p0, uint p1, bool p2) internal pure {
  402 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool)", p0, p1, p2));
  403 |     |     }
  404 |     | 
  405 |     |     function log(bool p0, uint p1, address p2) internal pure {
  406 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address)", p0, p1, p2));
  407 |     |     }
  408 |     | 
  409 |     |     function log(bool p0, string memory p1, uint p2) internal pure {
  410 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint)", p0, p1, p2));
  411 |     |     }
  412 |     | 
  413 |     |     function log(bool p0, string memory p1, string memory p2) internal pure {
  414 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string)", p0, p1, p2));
  415 |     |     }
  416 |     | 
  417 |     |     function log(bool p0, string memory p1, bool p2) internal pure {
  418 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool)", p0, p1, p2));
  419 |     |     }
  420 |     | 
  421 |     |     function log(bool p0, string memory p1, address p2) internal pure {
  422 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address)", p0, p1, p2));
  423 |     |     }
  424 |     | 
  425 |     |     function log(bool p0, bool p1, uint p2) internal pure {
  426 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint)", p0, p1, p2));
  427 |     |     }
  428 |     | 
  429 |     |     function log(bool p0, bool p1, string memory p2) internal pure {
  430 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string)", p0, p1, p2));
  431 |     |     }
  432 |     | 
  433 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  434 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool)", p0, p1, p2));
  435 |     |     }
  436 |     | 
  437 |     |     function log(bool p0, bool p1, address p2) internal pure {
  438 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address)", p0, p1, p2));
  439 |     |     }
  440 |     | 
  441 |     |     function log(bool p0, address p1, uint p2) internal pure {
  442 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint)", p0, p1, p2));
  443 |     |     }
  444 |     | 
  445 |     |     function log(bool p0, address p1, string memory p2) internal pure {
  446 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string)", p0, p1, p2));
  447 |     |     }
  448 |     | 
  449 |     |     function log(bool p0, address p1, bool p2) internal pure {
  450 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool)", p0, p1, p2));
  451 |     |     }
  452 |     | 
  453 |     |     function log(bool p0, address p1, address p2) internal pure {
  454 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address)", p0, p1, p2));
  455 |     |     }
  456 |     | 
  457 |     |     function log(address p0, uint p1, uint p2) internal pure {
  458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint)", p0, p1, p2));
  459 |     |     }
  460 |     | 
  461 |     |     function log(address p0, uint p1, string memory p2) internal pure {
  462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string)", p0, p1, p2));
  463 |     |     }
  464 |     | 
  465 |     |     function log(address p0, uint p1, bool p2) internal pure {
  466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool)", p0, p1, p2));
  467 |     |     }
  468 |     | 
  469 |     |     function log(address p0, uint p1, address p2) internal pure {
  470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address)", p0, p1, p2));
  471 |     |     }
  472 |     | 
  473 |     |     function log(address p0, string memory p1, uint p2) internal pure {
  474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint)", p0, p1, p2));
  475 |     |     }
  476 |     | 
  477 |     |     function log(address p0, string memory p1, string memory p2) internal pure {
  478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string)", p0, p1, p2));
  479 |     |     }
  480 |     | 
  481 |     |     function log(address p0, string memory p1, bool p2) internal pure {
  482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool)", p0, p1, p2));
  483 |     |     }
  484 |     | 
  485 |     |     function log(address p0, string memory p1, address p2) internal pure {
  486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address)", p0, p1, p2));
  487 |     |     }
  488 |     | 
  489 |     |     function log(address p0, bool p1, uint p2) internal pure {
  490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint)", p0, p1, p2));
  491 |     |     }
  492 |     | 
  493 |     |     function log(address p0, bool p1, string memory p2) internal pure {
  494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string)", p0, p1, p2));
  495 |     |     }
  496 |     | 
  497 |     |     function log(address p0, bool p1, bool p2) internal pure {
  498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool)", p0, p1, p2));
  499 |     |     }
  500 |     | 
  501 |     |     function log(address p0, bool p1, address p2) internal pure {
  502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address)", p0, p1, p2));
  503 |     |     }
  504 |     | 
  505 |     |     function log(address p0, address p1, uint p2) internal pure {
  506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint)", p0, p1, p2));
  507 |     |     }
  508 |     | 
  509 |     |     function log(address p0, address p1, string memory p2) internal pure {
  510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string)", p0, p1, p2));
  511 |     |     }
  512 |     | 
  513 |     |     function log(address p0, address p1, bool p2) internal pure {
  514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool)", p0, p1, p2));
  515 |     |     }
  516 |     | 
  517 |     |     function log(address p0, address p1, address p2) internal pure {
  518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address)", p0, p1, p2));
  519 |     |     }
  520 |     | 
  521 |     |     function log(uint p0, uint p1, uint p2, uint p3) internal pure {
  522 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,uint)", p0, p1, p2, p3));
  523 |     |     }
  524 |     | 
  525 |     |     function log(uint p0, uint p1, uint p2, string memory p3) internal pure {
  526 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,string)", p0, p1, p2, p3));
  527 |     |     }
  528 |     | 
  529 |     |     function log(uint p0, uint p1, uint p2, bool p3) internal pure {
  530 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,bool)", p0, p1, p2, p3));
  531 |     |     }
  532 |     | 
  533 |     |     function log(uint p0, uint p1, uint p2, address p3) internal pure {
  534 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,uint,address)", p0, p1, p2, p3));
  535 |     |     }
  536 |     | 
  537 |     |     function log(uint p0, uint p1, string memory p2, uint p3) internal pure {
  538 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,uint)", p0, p1, p2, p3));
  539 |     |     }
  540 |     | 
  541 |     |     function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {
  542 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,string)", p0, p1, p2, p3));
  543 |     |     }
  544 |     | 
  545 |     |     function log(uint p0, uint p1, string memory p2, bool p3) internal pure {
  546 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,bool)", p0, p1, p2, p3));
  547 |     |     }
  548 |     | 
  549 |     |     function log(uint p0, uint p1, string memory p2, address p3) internal pure {
  550 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,string,address)", p0, p1, p2, p3));
  551 |     |     }
  552 |     | 
  553 |     |     function log(uint p0, uint p1, bool p2, uint p3) internal pure {
  554 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,uint)", p0, p1, p2, p3));
  555 |     |     }
  556 |     | 
  557 |     |     function log(uint p0, uint p1, bool p2, string memory p3) internal pure {
  558 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,string)", p0, p1, p2, p3));
  559 |     |     }
  560 |     | 
  561 |     |     function log(uint p0, uint p1, bool p2, bool p3) internal pure {
  562 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,bool)", p0, p1, p2, p3));
  563 |     |     }
  564 |     | 
  565 |     |     function log(uint p0, uint p1, bool p2, address p3) internal pure {
  566 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,bool,address)", p0, p1, p2, p3));
  567 |     |     }
  568 |     | 
  569 |     |     function log(uint p0, uint p1, address p2, uint p3) internal pure {
  570 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,uint)", p0, p1, p2, p3));
  571 |     |     }
  572 |     | 
  573 |     |     function log(uint p0, uint p1, address p2, string memory p3) internal pure {
  574 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,string)", p0, p1, p2, p3));
  575 |     |     }
  576 |     | 
  577 |     |     function log(uint p0, uint p1, address p2, bool p3) internal pure {
  578 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,bool)", p0, p1, p2, p3));
  579 |     |     }
  580 |     | 
  581 |     |     function log(uint p0, uint p1, address p2, address p3) internal pure {
  582 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,uint,address,address)", p0, p1, p2, p3));
  583 |     |     }
  584 |     | 
  585 |     |     function log(uint p0, string memory p1, uint p2, uint p3) internal pure {
  586 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,uint)", p0, p1, p2, p3));
  587 |     |     }
  588 |     | 
  589 |     |     function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {
  590 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,string)", p0, p1, p2, p3));
  591 |     |     }
  592 |     | 
  593 |     |     function log(uint p0, string memory p1, uint p2, bool p3) internal pure {
  594 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,bool)", p0, p1, p2, p3));
  595 |     |     }
  596 |     | 
  597 |     |     function log(uint p0, string memory p1, uint p2, address p3) internal pure {
  598 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,uint,address)", p0, p1, p2, p3));
  599 |     |     }
  600 |     | 
  601 |     |     function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {
  602 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,uint)", p0, p1, p2, p3));
  603 |     |     }
  604 |     | 
  605 |     |     function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {
  606 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,string)", p0, p1, p2, p3));
  607 |     |     }
  608 |     | 
  609 |     |     function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {
  610 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,bool)", p0, p1, p2, p3));
  611 |     |     }
  612 |     | 
  613 |     |     function log(uint p0, string memory p1, string memory p2, address p3) internal pure {
  614 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,string,address)", p0, p1, p2, p3));
  615 |     |     }
  616 |     | 
  617 |     |     function log(uint p0, string memory p1, bool p2, uint p3) internal pure {
  618 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,uint)", p0, p1, p2, p3));
  619 |     |     }
  620 |     | 
  621 |     |     function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {
  622 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,string)", p0, p1, p2, p3));
  623 |     |     }
  624 |     | 
  625 |     |     function log(uint p0, string memory p1, bool p2, bool p3) internal pure {
  626 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,bool)", p0, p1, p2, p3));
  627 |     |     }
  628 |     | 
  629 |     |     function log(uint p0, string memory p1, bool p2, address p3) internal pure {
  630 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,bool,address)", p0, p1, p2, p3));
  631 |     |     }
  632 |     | 
  633 |     |     function log(uint p0, string memory p1, address p2, uint p3) internal pure {
  634 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,uint)", p0, p1, p2, p3));
  635 |     |     }
  636 |     | 
  637 |     |     function log(uint p0, string memory p1, address p2, string memory p3) internal pure {
  638 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,string)", p0, p1, p2, p3));
  639 |     |     }
  640 |     | 
  641 |     |     function log(uint p0, string memory p1, address p2, bool p3) internal pure {
  642 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,bool)", p0, p1, p2, p3));
  643 |     |     }
  644 |     | 
  645 |     |     function log(uint p0, string memory p1, address p2, address p3) internal pure {
  646 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,string,address,address)", p0, p1, p2, p3));
  647 |     |     }
  648 |     | 
  649 |     |     function log(uint p0, bool p1, uint p2, uint p3) internal pure {
  650 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,uint)", p0, p1, p2, p3));
  651 |     |     }
  652 |     | 
  653 |     |     function log(uint p0, bool p1, uint p2, string memory p3) internal pure {
  654 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,string)", p0, p1, p2, p3));
  655 |     |     }
  656 |     | 
  657 |     |     function log(uint p0, bool p1, uint p2, bool p3) internal pure {
  658 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,bool)", p0, p1, p2, p3));
  659 |     |     }
  660 |     | 
  661 |     |     function log(uint p0, bool p1, uint p2, address p3) internal pure {
  662 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,uint,address)", p0, p1, p2, p3));
  663 |     |     }
  664 |     | 
  665 |     |     function log(uint p0, bool p1, string memory p2, uint p3) internal pure {
  666 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,uint)", p0, p1, p2, p3));
  667 |     |     }
  668 |     | 
  669 |     |     function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {
  670 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,string)", p0, p1, p2, p3));
  671 |     |     }
  672 |     | 
  673 |     |     function log(uint p0, bool p1, string memory p2, bool p3) internal pure {
  674 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,bool)", p0, p1, p2, p3));
  675 |     |     }
  676 |     | 
  677 |     |     function log(uint p0, bool p1, string memory p2, address p3) internal pure {
  678 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,string,address)", p0, p1, p2, p3));
  679 |     |     }
  680 |     | 
  681 |     |     function log(uint p0, bool p1, bool p2, uint p3) internal pure {
  682 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,uint)", p0, p1, p2, p3));
  683 |     |     }
  684 |     | 
  685 |     |     function log(uint p0, bool p1, bool p2, string memory p3) internal pure {
  686 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,string)", p0, p1, p2, p3));
  687 |     |     }
  688 |     | 
  689 |     |     function log(uint p0, bool p1, bool p2, bool p3) internal pure {
  690 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,bool)", p0, p1, p2, p3));
  691 |     |     }
  692 |     | 
  693 |     |     function log(uint p0, bool p1, bool p2, address p3) internal pure {
  694 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,bool,address)", p0, p1, p2, p3));
  695 |     |     }
  696 |     | 
  697 |     |     function log(uint p0, bool p1, address p2, uint p3) internal pure {
  698 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,uint)", p0, p1, p2, p3));
  699 |     |     }
  700 |     | 
  701 |     |     function log(uint p0, bool p1, address p2, string memory p3) internal pure {
  702 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,string)", p0, p1, p2, p3));
  703 |     |     }
  704 |     | 
  705 |     |     function log(uint p0, bool p1, address p2, bool p3) internal pure {
  706 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,bool)", p0, p1, p2, p3));
  707 |     |     }
  708 |     | 
  709 |     |     function log(uint p0, bool p1, address p2, address p3) internal pure {
  710 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,bool,address,address)", p0, p1, p2, p3));
  711 |     |     }
  712 |     | 
  713 |     |     function log(uint p0, address p1, uint p2, uint p3) internal pure {
  714 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,uint)", p0, p1, p2, p3));
  715 |     |     }
  716 |     | 
  717 |     |     function log(uint p0, address p1, uint p2, string memory p3) internal pure {
  718 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,string)", p0, p1, p2, p3));
  719 |     |     }
  720 |     | 
  721 |     |     function log(uint p0, address p1, uint p2, bool p3) internal pure {
  722 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,bool)", p0, p1, p2, p3));
  723 |     |     }
  724 |     | 
  725 |     |     function log(uint p0, address p1, uint p2, address p3) internal pure {
  726 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,uint,address)", p0, p1, p2, p3));
  727 |     |     }
  728 |     | 
  729 |     |     function log(uint p0, address p1, string memory p2, uint p3) internal pure {
  730 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,uint)", p0, p1, p2, p3));
  731 |     |     }
  732 |     | 
  733 |     |     function log(uint p0, address p1, string memory p2, string memory p3) internal pure {
  734 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,string)", p0, p1, p2, p3));
  735 |     |     }
  736 |     | 
  737 |     |     function log(uint p0, address p1, string memory p2, bool p3) internal pure {
  738 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,bool)", p0, p1, p2, p3));
  739 |     |     }
  740 |     | 
  741 |     |     function log(uint p0, address p1, string memory p2, address p3) internal pure {
  742 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,string,address)", p0, p1, p2, p3));
  743 |     |     }
  744 |     | 
  745 |     |     function log(uint p0, address p1, bool p2, uint p3) internal pure {
  746 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,uint)", p0, p1, p2, p3));
  747 |     |     }
  748 |     | 
  749 |     |     function log(uint p0, address p1, bool p2, string memory p3) internal pure {
  750 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,string)", p0, p1, p2, p3));
  751 |     |     }
  752 |     | 
  753 |     |     function log(uint p0, address p1, bool p2, bool p3) internal pure {
  754 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,bool)", p0, p1, p2, p3));
  755 |     |     }
  756 |     | 
  757 |     |     function log(uint p0, address p1, bool p2, address p3) internal pure {
  758 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,bool,address)", p0, p1, p2, p3));
  759 |     |     }
  760 |     | 
  761 |     |     function log(uint p0, address p1, address p2, uint p3) internal pure {
  762 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,uint)", p0, p1, p2, p3));
  763 |     |     }
  764 |     | 
  765 |     |     function log(uint p0, address p1, address p2, string memory p3) internal pure {
  766 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,string)", p0, p1, p2, p3));
  767 |     |     }
  768 |     | 
  769 |     |     function log(uint p0, address p1, address p2, bool p3) internal pure {
  770 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,bool)", p0, p1, p2, p3));
  771 |     |     }
  772 |     | 
  773 |     |     function log(uint p0, address p1, address p2, address p3) internal pure {
  774 |     |         _sendLogPayload(abi.encodeWithSignature("log(uint,address,address,address)", p0, p1, p2, p3));
  775 |     |     }
  776 |     | 
  777 |     |     function log(string memory p0, uint p1, uint p2, uint p3) internal pure {
  778 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,uint)", p0, p1, p2, p3));
  779 |     |     }
  780 |     | 
  781 |     |     function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {
  782 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,string)", p0, p1, p2, p3));
  783 |     |     }
  784 |     | 
  785 |     |     function log(string memory p0, uint p1, uint p2, bool p3) internal pure {
  786 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,bool)", p0, p1, p2, p3));
  787 |     |     }
  788 |     | 
  789 |     |     function log(string memory p0, uint p1, uint p2, address p3) internal pure {
  790 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,uint,address)", p0, p1, p2, p3));
  791 |     |     }
  792 |     | 
  793 |     |     function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {
  794 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,uint)", p0, p1, p2, p3));
  795 |     |     }
  796 |     | 
  797 |     |     function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {
  798 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,string)", p0, p1, p2, p3));
  799 |     |     }
  800 |     | 
  801 |     |     function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {
  802 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,bool)", p0, p1, p2, p3));
  803 |     |     }
  804 |     | 
  805 |     |     function log(string memory p0, uint p1, string memory p2, address p3) internal pure {
  806 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,string,address)", p0, p1, p2, p3));
  807 |     |     }
  808 |     | 
  809 |     |     function log(string memory p0, uint p1, bool p2, uint p3) internal pure {
  810 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,uint)", p0, p1, p2, p3));
  811 |     |     }
  812 |     | 
  813 |     |     function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {
  814 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,string)", p0, p1, p2, p3));
  815 |     |     }
  816 |     | 
  817 |     |     function log(string memory p0, uint p1, bool p2, bool p3) internal pure {
  818 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,bool)", p0, p1, p2, p3));
  819 |     |     }
  820 |     | 
  821 |     |     function log(string memory p0, uint p1, bool p2, address p3) internal pure {
  822 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,bool,address)", p0, p1, p2, p3));
  823 |     |     }
  824 |     | 
  825 |     |     function log(string memory p0, uint p1, address p2, uint p3) internal pure {
  826 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,uint)", p0, p1, p2, p3));
  827 |     |     }
  828 |     | 
  829 |     |     function log(string memory p0, uint p1, address p2, string memory p3) internal pure {
  830 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,string)", p0, p1, p2, p3));
  831 |     |     }
  832 |     | 
  833 |     |     function log(string memory p0, uint p1, address p2, bool p3) internal pure {
  834 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,bool)", p0, p1, p2, p3));
  835 |     |     }
  836 |     | 
  837 |     |     function log(string memory p0, uint p1, address p2, address p3) internal pure {
  838 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,uint,address,address)", p0, p1, p2, p3));
  839 |     |     }
  840 |     | 
  841 |     |     function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {
  842 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,uint)", p0, p1, p2, p3));
  843 |     |     }
  844 |     | 
  845 |     |     function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {
  846 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,string)", p0, p1, p2, p3));
  847 |     |     }
  848 |     | 
  849 |     |     function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {
  850 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,bool)", p0, p1, p2, p3));
  851 |     |     }
  852 |     | 
  853 |     |     function log(string memory p0, string memory p1, uint p2, address p3) internal pure {
  854 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,uint,address)", p0, p1, p2, p3));
  855 |     |     }
  856 |     | 
  857 |     |     function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {
  858 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,uint)", p0, p1, p2, p3));
  859 |     |     }
  860 |     | 
  861 |     |     function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {
  862 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,string)", p0, p1, p2, p3));
  863 |     |     }
  864 |     | 
  865 |     |     function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {
  866 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,bool)", p0, p1, p2, p3));
  867 |     |     }
  868 |     | 
  869 |     |     function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {
  870 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,string,address)", p0, p1, p2, p3));
  871 |     |     }
  872 |     | 
  873 |     |     function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {
  874 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,uint)", p0, p1, p2, p3));
  875 |     |     }
  876 |     | 
  877 |     |     function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {
  878 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,string)", p0, p1, p2, p3));
  879 |     |     }
  880 |     | 
  881 |     |     function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {
  882 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,bool)", p0, p1, p2, p3));
  883 |     |     }
  884 |     | 
  885 |     |     function log(string memory p0, string memory p1, bool p2, address p3) internal pure {
  886 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,bool,address)", p0, p1, p2, p3));
  887 |     |     }
  888 |     | 
  889 |     |     function log(string memory p0, string memory p1, address p2, uint p3) internal pure {
  890 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,uint)", p0, p1, p2, p3));
  891 |     |     }
  892 |     | 
  893 |     |     function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {
  894 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,string)", p0, p1, p2, p3));
  895 |     |     }
  896 |     | 
  897 |     |     function log(string memory p0, string memory p1, address p2, bool p3) internal pure {
  898 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,bool)", p0, p1, p2, p3));
  899 |     |     }
  900 |     | 
  901 |     |     function log(string memory p0, string memory p1, address p2, address p3) internal pure {
  902 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,string,address,address)", p0, p1, p2, p3));
  903 |     |     }
  904 |     | 
  905 |     |     function log(string memory p0, bool p1, uint p2, uint p3) internal pure {
  906 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,uint)", p0, p1, p2, p3));
  907 |     |     }
  908 |     | 
  909 |     |     function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {
  910 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,string)", p0, p1, p2, p3));
  911 |     |     }
  912 |     | 
  913 |     |     function log(string memory p0, bool p1, uint p2, bool p3) internal pure {
  914 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,bool)", p0, p1, p2, p3));
  915 |     |     }
  916 |     | 
  917 |     |     function log(string memory p0, bool p1, uint p2, address p3) internal pure {
  918 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,uint,address)", p0, p1, p2, p3));
  919 |     |     }
  920 |     | 
  921 |     |     function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {
  922 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,uint)", p0, p1, p2, p3));
  923 |     |     }
  924 |     | 
  925 |     |     function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {
  926 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,string)", p0, p1, p2, p3));
  927 |     |     }
  928 |     | 
  929 |     |     function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {
  930 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,bool)", p0, p1, p2, p3));
  931 |     |     }
  932 |     | 
  933 |     |     function log(string memory p0, bool p1, string memory p2, address p3) internal pure {
  934 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,string,address)", p0, p1, p2, p3));
  935 |     |     }
  936 |     | 
  937 |     |     function log(string memory p0, bool p1, bool p2, uint p3) internal pure {
  938 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,uint)", p0, p1, p2, p3));
  939 |     |     }
  940 |     | 
  941 |     |     function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {
  942 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,string)", p0, p1, p2, p3));
  943 |     |     }
  944 |     | 
  945 |     |     function log(string memory p0, bool p1, bool p2, bool p3) internal pure {
  946 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,bool)", p0, p1, p2, p3));
  947 |     |     }
  948 |     | 
  949 |     |     function log(string memory p0, bool p1, bool p2, address p3) internal pure {
  950 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,bool,address)", p0, p1, p2, p3));
  951 |     |     }
  952 |     | 
  953 |     |     function log(string memory p0, bool p1, address p2, uint p3) internal pure {
  954 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,uint)", p0, p1, p2, p3));
  955 |     |     }
  956 |     | 
  957 |     |     function log(string memory p0, bool p1, address p2, string memory p3) internal pure {
  958 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,string)", p0, p1, p2, p3));
  959 |     |     }
  960 |     | 
  961 |     |     function log(string memory p0, bool p1, address p2, bool p3) internal pure {
  962 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,bool)", p0, p1, p2, p3));
  963 |     |     }
  964 |     | 
  965 |     |     function log(string memory p0, bool p1, address p2, address p3) internal pure {
  966 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,bool,address,address)", p0, p1, p2, p3));
  967 |     |     }
  968 |     | 
  969 |     |     function log(string memory p0, address p1, uint p2, uint p3) internal pure {
  970 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,uint)", p0, p1, p2, p3));
  971 |     |     }
  972 |     | 
  973 |     |     function log(string memory p0, address p1, uint p2, string memory p3) internal pure {
  974 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,string)", p0, p1, p2, p3));
  975 |     |     }
  976 |     | 
  977 |     |     function log(string memory p0, address p1, uint p2, bool p3) internal pure {
  978 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,bool)", p0, p1, p2, p3));
  979 |     |     }
  980 |     | 
  981 |     |     function log(string memory p0, address p1, uint p2, address p3) internal pure {
  982 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,uint,address)", p0, p1, p2, p3));
  983 |     |     }
  984 |     | 
  985 |     |     function log(string memory p0, address p1, string memory p2, uint p3) internal pure {
  986 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,uint)", p0, p1, p2, p3));
  987 |     |     }
  988 |     | 
  989 |     |     function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {
  990 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,string)", p0, p1, p2, p3));
  991 |     |     }
  992 |     | 
  993 |     |     function log(string memory p0, address p1, string memory p2, bool p3) internal pure {
  994 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,bool)", p0, p1, p2, p3));
  995 |     |     }
  996 |     | 
  997 |     |     function log(string memory p0, address p1, string memory p2, address p3) internal pure {
  998 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,string,address)", p0, p1, p2, p3));
  999 |     |     }
 1000 |     | 
 1001 |     |     function log(string memory p0, address p1, bool p2, uint p3) internal pure {
 1002 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,uint)", p0, p1, p2, p3));
 1003 |     |     }
 1004 |     | 
 1005 |     |     function log(string memory p0, address p1, bool p2, string memory p3) internal pure {
 1006 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,string)", p0, p1, p2, p3));
 1007 |     |     }
 1008 |     | 
 1009 |     |     function log(string memory p0, address p1, bool p2, bool p3) internal pure {
 1010 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,bool)", p0, p1, p2, p3));
 1011 |     |     }
 1012 |     | 
 1013 |     |     function log(string memory p0, address p1, bool p2, address p3) internal pure {
 1014 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,bool,address)", p0, p1, p2, p3));
 1015 |     |     }
 1016 |     | 
 1017 |     |     function log(string memory p0, address p1, address p2, uint p3) internal pure {
 1018 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,uint)", p0, p1, p2, p3));
 1019 |     |     }
 1020 |     | 
 1021 |     |     function log(string memory p0, address p1, address p2, string memory p3) internal pure {
 1022 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,string)", p0, p1, p2, p3));
 1023 |     |     }
 1024 |     | 
 1025 |     |     function log(string memory p0, address p1, address p2, bool p3) internal pure {
 1026 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,bool)", p0, p1, p2, p3));
 1027 |     |     }
 1028 |     | 
 1029 |     |     function log(string memory p0, address p1, address p2, address p3) internal pure {
 1030 |     |         _sendLogPayload(abi.encodeWithSignature("log(string,address,address,address)", p0, p1, p2, p3));
 1031 |     |     }
 1032 |     | 
 1033 |     |     function log(bool p0, uint p1, uint p2, uint p3) internal pure {
 1034 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,uint)", p0, p1, p2, p3));
 1035 |     |     }
 1036 |     | 
 1037 |     |     function log(bool p0, uint p1, uint p2, string memory p3) internal pure {
 1038 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,string)", p0, p1, p2, p3));
 1039 |     |     }
 1040 |     | 
 1041 |     |     function log(bool p0, uint p1, uint p2, bool p3) internal pure {
 1042 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,bool)", p0, p1, p2, p3));
 1043 |     |     }
 1044 |     | 
 1045 |     |     function log(bool p0, uint p1, uint p2, address p3) internal pure {
 1046 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,uint,address)", p0, p1, p2, p3));
 1047 |     |     }
 1048 |     | 
 1049 |     |     function log(bool p0, uint p1, string memory p2, uint p3) internal pure {
 1050 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,uint)", p0, p1, p2, p3));
 1051 |     |     }
 1052 |     | 
 1053 |     |     function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {
 1054 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,string)", p0, p1, p2, p3));
 1055 |     |     }
 1056 |     | 
 1057 |     |     function log(bool p0, uint p1, string memory p2, bool p3) internal pure {
 1058 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,bool)", p0, p1, p2, p3));
 1059 |     |     }
 1060 |     | 
 1061 |     |     function log(bool p0, uint p1, string memory p2, address p3) internal pure {
 1062 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,string,address)", p0, p1, p2, p3));
 1063 |     |     }
 1064 |     | 
 1065 |     |     function log(bool p0, uint p1, bool p2, uint p3) internal pure {
 1066 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,uint)", p0, p1, p2, p3));
 1067 |     |     }
 1068 |     | 
 1069 |     |     function log(bool p0, uint p1, bool p2, string memory p3) internal pure {
 1070 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,string)", p0, p1, p2, p3));
 1071 |     |     }
 1072 |     | 
 1073 |     |     function log(bool p0, uint p1, bool p2, bool p3) internal pure {
 1074 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,bool)", p0, p1, p2, p3));
 1075 |     |     }
 1076 |     | 
 1077 |     |     function log(bool p0, uint p1, bool p2, address p3) internal pure {
 1078 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,bool,address)", p0, p1, p2, p3));
 1079 |     |     }
 1080 |     | 
 1081 |     |     function log(bool p0, uint p1, address p2, uint p3) internal pure {
 1082 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,uint)", p0, p1, p2, p3));
 1083 |     |     }
 1084 |     | 
 1085 |     |     function log(bool p0, uint p1, address p2, string memory p3) internal pure {
 1086 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,string)", p0, p1, p2, p3));
 1087 |     |     }
 1088 |     | 
 1089 |     |     function log(bool p0, uint p1, address p2, bool p3) internal pure {
 1090 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,bool)", p0, p1, p2, p3));
 1091 |     |     }
 1092 |     | 
 1093 |     |     function log(bool p0, uint p1, address p2, address p3) internal pure {
 1094 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,uint,address,address)", p0, p1, p2, p3));
 1095 |     |     }
 1096 |     | 
 1097 |     |     function log(bool p0, string memory p1, uint p2, uint p3) internal pure {
 1098 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,uint)", p0, p1, p2, p3));
 1099 |     |     }
 1100 |     | 
 1101 |     |     function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {
 1102 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,string)", p0, p1, p2, p3));
 1103 |     |     }
 1104 |     | 
 1105 |     |     function log(bool p0, string memory p1, uint p2, bool p3) internal pure {
 1106 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,bool)", p0, p1, p2, p3));
 1107 |     |     }
 1108 |     | 
 1109 |     |     function log(bool p0, string memory p1, uint p2, address p3) internal pure {
 1110 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,uint,address)", p0, p1, p2, p3));
 1111 |     |     }
 1112 |     | 
 1113 |     |     function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {
 1114 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,uint)", p0, p1, p2, p3));
 1115 |     |     }
 1116 |     | 
 1117 |     |     function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {
 1118 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,string)", p0, p1, p2, p3));
 1119 |     |     }
 1120 |     | 
 1121 |     |     function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {
 1122 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,bool)", p0, p1, p2, p3));
 1123 |     |     }
 1124 |     | 
 1125 |     |     function log(bool p0, string memory p1, string memory p2, address p3) internal pure {
 1126 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,string,address)", p0, p1, p2, p3));
 1127 |     |     }
 1128 |     | 
 1129 |     |     function log(bool p0, string memory p1, bool p2, uint p3) internal pure {
 1130 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,uint)", p0, p1, p2, p3));
 1131 |     |     }
 1132 |     | 
 1133 |     |     function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {
 1134 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,string)", p0, p1, p2, p3));
 1135 |     |     }
 1136 |     | 
 1137 |     |     function log(bool p0, string memory p1, bool p2, bool p3) internal pure {
 1138 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,bool)", p0, p1, p2, p3));
 1139 |     |     }
 1140 |     | 
 1141 |     |     function log(bool p0, string memory p1, bool p2, address p3) internal pure {
 1142 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,bool,address)", p0, p1, p2, p3));
 1143 |     |     }
 1144 |     | 
 1145 |     |     function log(bool p0, string memory p1, address p2, uint p3) internal pure {
 1146 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,uint)", p0, p1, p2, p3));
 1147 |     |     }
 1148 |     | 
 1149 |     |     function log(bool p0, string memory p1, address p2, string memory p3) internal pure {
 1150 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,string)", p0, p1, p2, p3));
 1151 |     |     }
 1152 |     | 
 1153 |     |     function log(bool p0, string memory p1, address p2, bool p3) internal pure {
 1154 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,bool)", p0, p1, p2, p3));
 1155 |     |     }
 1156 |     | 
 1157 |     |     function log(bool p0, string memory p1, address p2, address p3) internal pure {
 1158 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,string,address,address)", p0, p1, p2, p3));
 1159 |     |     }
 1160 |     | 
 1161 |     |     function log(bool p0, bool p1, uint p2, uint p3) internal pure {
 1162 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,uint)", p0, p1, p2, p3));
 1163 |     |     }
 1164 |     | 
 1165 |     |     function log(bool p0, bool p1, uint p2, string memory p3) internal pure {
 1166 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,string)", p0, p1, p2, p3));
 1167 |     |     }
 1168 |     | 
 1169 |     |     function log(bool p0, bool p1, uint p2, bool p3) internal pure {
 1170 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,bool)", p0, p1, p2, p3));
 1171 |     |     }
 1172 |     | 
 1173 |     |     function log(bool p0, bool p1, uint p2, address p3) internal pure {
 1174 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,uint,address)", p0, p1, p2, p3));
 1175 |     |     }
 1176 |     | 
 1177 |     |     function log(bool p0, bool p1, string memory p2, uint p3) internal pure {
 1178 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,uint)", p0, p1, p2, p3));
 1179 |     |     }
 1180 |     | 
 1181 |     |     function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {
 1182 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,string)", p0, p1, p2, p3));
 1183 |     |     }
 1184 |     | 
 1185 |     |     function log(bool p0, bool p1, string memory p2, bool p3) internal pure {
 1186 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,bool)", p0, p1, p2, p3));
 1187 |     |     }
 1188 |     | 
 1189 |     |     function log(bool p0, bool p1, string memory p2, address p3) internal pure {
 1190 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,string,address)", p0, p1, p2, p3));
 1191 |     |     }
 1192 |     | 
 1193 |     |     function log(bool p0, bool p1, bool p2, uint p3) internal pure {
 1194 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,uint)", p0, p1, p2, p3));
 1195 |     |     }
 1196 |     | 
 1197 |     |     function log(bool p0, bool p1, bool p2, string memory p3) internal pure {
 1198 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,string)", p0, p1, p2, p3));
 1199 |     |     }
 1200 |     | 
 1201 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
 1202 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,bool)", p0, p1, p2, p3));
 1203 |     |     }
 1204 |     | 
 1205 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
 1206 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,bool,address)", p0, p1, p2, p3));
 1207 |     |     }
 1208 |     | 
 1209 |     |     function log(bool p0, bool p1, address p2, uint p3) internal pure {
 1210 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,uint)", p0, p1, p2, p3));
 1211 |     |     }
 1212 |     | 
 1213 |     |     function log(bool p0, bool p1, address p2, string memory p3) internal pure {
 1214 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,string)", p0, p1, p2, p3));
 1215 |     |     }
 1216 |     | 
 1217 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
 1218 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,bool)", p0, p1, p2, p3));
 1219 |     |     }
 1220 |     | 
 1221 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
 1222 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,bool,address,address)", p0, p1, p2, p3));
 1223 |     |     }
 1224 |     | 
 1225 |     |     function log(bool p0, address p1, uint p2, uint p3) internal pure {
 1226 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,uint)", p0, p1, p2, p3));
 1227 |     |     }
 1228 |     | 
 1229 |     |     function log(bool p0, address p1, uint p2, string memory p3) internal pure {
 1230 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,string)", p0, p1, p2, p3));
 1231 |     |     }
 1232 |     | 
 1233 |     |     function log(bool p0, address p1, uint p2, bool p3) internal pure {
 1234 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,bool)", p0, p1, p2, p3));
 1235 |     |     }
 1236 |     | 
 1237 |     |     function log(bool p0, address p1, uint p2, address p3) internal pure {
 1238 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,uint,address)", p0, p1, p2, p3));
 1239 |     |     }
 1240 |     | 
 1241 |     |     function log(bool p0, address p1, string memory p2, uint p3) internal pure {
 1242 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,uint)", p0, p1, p2, p3));
 1243 |     |     }
 1244 |     | 
 1245 |     |     function log(bool p0, address p1, string memory p2, string memory p3) internal pure {
 1246 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,string)", p0, p1, p2, p3));
 1247 |     |     }
 1248 |     | 
 1249 |     |     function log(bool p0, address p1, string memory p2, bool p3) internal pure {
 1250 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,bool)", p0, p1, p2, p3));
 1251 |     |     }
 1252 |     | 
 1253 |     |     function log(bool p0, address p1, string memory p2, address p3) internal pure {
 1254 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,string,address)", p0, p1, p2, p3));
 1255 |     |     }
 1256 |     | 
 1257 |     |     function log(bool p0, address p1, bool p2, uint p3) internal pure {
 1258 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,uint)", p0, p1, p2, p3));
 1259 |     |     }
 1260 |     | 
 1261 |     |     function log(bool p0, address p1, bool p2, string memory p3) internal pure {
 1262 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,string)", p0, p1, p2, p3));
 1263 |     |     }
 1264 |     | 
 1265 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
 1266 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,bool)", p0, p1, p2, p3));
 1267 |     |     }
 1268 |     | 
 1269 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
 1270 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,bool,address)", p0, p1, p2, p3));
 1271 |     |     }
 1272 |     | 
 1273 |     |     function log(bool p0, address p1, address p2, uint p3) internal pure {
 1274 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,uint)", p0, p1, p2, p3));
 1275 |     |     }
 1276 |     | 
 1277 |     |     function log(bool p0, address p1, address p2, string memory p3) internal pure {
 1278 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,string)", p0, p1, p2, p3));
 1279 |     |     }
 1280 |     | 
 1281 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
 1282 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,bool)", p0, p1, p2, p3));
 1283 |     |     }
 1284 |     | 
 1285 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
 1286 |     |         _sendLogPayload(abi.encodeWithSignature("log(bool,address,address,address)", p0, p1, p2, p3));
 1287 |     |     }
 1288 |     | 
 1289 |     |     function log(address p0, uint p1, uint p2, uint p3) internal pure {
 1290 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,uint)", p0, p1, p2, p3));
 1291 |     |     }
 1292 |     | 
 1293 |     |     function log(address p0, uint p1, uint p2, string memory p3) internal pure {
 1294 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,string)", p0, p1, p2, p3));
 1295 |     |     }
 1296 |     | 
 1297 |     |     function log(address p0, uint p1, uint p2, bool p3) internal pure {
 1298 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,bool)", p0, p1, p2, p3));
 1299 |     |     }
 1300 |     | 
 1301 |     |     function log(address p0, uint p1, uint p2, address p3) internal pure {
 1302 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,uint,address)", p0, p1, p2, p3));
 1303 |     |     }
 1304 |     | 
 1305 |     |     function log(address p0, uint p1, string memory p2, uint p3) internal pure {
 1306 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,uint)", p0, p1, p2, p3));
 1307 |     |     }
 1308 |     | 
 1309 |     |     function log(address p0, uint p1, string memory p2, string memory p3) internal pure {
 1310 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,string)", p0, p1, p2, p3));
 1311 |     |     }
 1312 |     | 
 1313 |     |     function log(address p0, uint p1, string memory p2, bool p3) internal pure {
 1314 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,bool)", p0, p1, p2, p3));
 1315 |     |     }
 1316 |     | 
 1317 |     |     function log(address p0, uint p1, string memory p2, address p3) internal pure {
 1318 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,string,address)", p0, p1, p2, p3));
 1319 |     |     }
 1320 |     | 
 1321 |     |     function log(address p0, uint p1, bool p2, uint p3) internal pure {
 1322 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,uint)", p0, p1, p2, p3));
 1323 |     |     }
 1324 |     | 
 1325 |     |     function log(address p0, uint p1, bool p2, string memory p3) internal pure {
 1326 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,string)", p0, p1, p2, p3));
 1327 |     |     }
 1328 |     | 
 1329 |     |     function log(address p0, uint p1, bool p2, bool p3) internal pure {
 1330 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,bool)", p0, p1, p2, p3));
 1331 |     |     }
 1332 |     | 
 1333 |     |     function log(address p0, uint p1, bool p2, address p3) internal pure {
 1334 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,bool,address)", p0, p1, p2, p3));
 1335 |     |     }
 1336 |     | 
 1337 |     |     function log(address p0, uint p1, address p2, uint p3) internal pure {
 1338 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,uint)", p0, p1, p2, p3));
 1339 |     |     }
 1340 |     | 
 1341 |     |     function log(address p0, uint p1, address p2, string memory p3) internal pure {
 1342 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,string)", p0, p1, p2, p3));
 1343 |     |     }
 1344 |     | 
 1345 |     |     function log(address p0, uint p1, address p2, bool p3) internal pure {
 1346 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,bool)", p0, p1, p2, p3));
 1347 |     |     }
 1348 |     | 
 1349 |     |     function log(address p0, uint p1, address p2, address p3) internal pure {
 1350 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,uint,address,address)", p0, p1, p2, p3));
 1351 |     |     }
 1352 |     | 
 1353 |     |     function log(address p0, string memory p1, uint p2, uint p3) internal pure {
 1354 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,uint)", p0, p1, p2, p3));
 1355 |     |     }
 1356 |     | 
 1357 |     |     function log(address p0, string memory p1, uint p2, string memory p3) internal pure {
 1358 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,string)", p0, p1, p2, p3));
 1359 |     |     }
 1360 |     | 
 1361 |     |     function log(address p0, string memory p1, uint p2, bool p3) internal pure {
 1362 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,bool)", p0, p1, p2, p3));
 1363 |     |     }
 1364 |     | 
 1365 |     |     function log(address p0, string memory p1, uint p2, address p3) internal pure {
 1366 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,uint,address)", p0, p1, p2, p3));
 1367 |     |     }
 1368 |     | 
 1369 |     |     function log(address p0, string memory p1, string memory p2, uint p3) internal pure {
 1370 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,uint)", p0, p1, p2, p3));
 1371 |     |     }
 1372 |     | 
 1373 |     |     function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {
 1374 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,string)", p0, p1, p2, p3));
 1375 |     |     }
 1376 |     | 
 1377 |     |     function log(address p0, string memory p1, string memory p2, bool p3) internal pure {
 1378 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,bool)", p0, p1, p2, p3));
 1379 |     |     }
 1380 |     | 
 1381 |     |     function log(address p0, string memory p1, string memory p2, address p3) internal pure {
 1382 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,string,address)", p0, p1, p2, p3));
 1383 |     |     }
 1384 |     | 
 1385 |     |     function log(address p0, string memory p1, bool p2, uint p3) internal pure {
 1386 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,uint)", p0, p1, p2, p3));
 1387 |     |     }
 1388 |     | 
 1389 |     |     function log(address p0, string memory p1, bool p2, string memory p3) internal pure {
 1390 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,string)", p0, p1, p2, p3));
 1391 |     |     }
 1392 |     | 
 1393 |     |     function log(address p0, string memory p1, bool p2, bool p3) internal pure {
 1394 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,bool)", p0, p1, p2, p3));
 1395 |     |     }
 1396 |     | 
 1397 |     |     function log(address p0, string memory p1, bool p2, address p3) internal pure {
 1398 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,bool,address)", p0, p1, p2, p3));
 1399 |     |     }
 1400 |     | 
 1401 |     |     function log(address p0, string memory p1, address p2, uint p3) internal pure {
 1402 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,uint)", p0, p1, p2, p3));
 1403 |     |     }
 1404 |     | 
 1405 |     |     function log(address p0, string memory p1, address p2, string memory p3) internal pure {
 1406 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,string)", p0, p1, p2, p3));
 1407 |     |     }
 1408 |     | 
 1409 |     |     function log(address p0, string memory p1, address p2, bool p3) internal pure {
 1410 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,bool)", p0, p1, p2, p3));
 1411 |     |     }
 1412 |     | 
 1413 |     |     function log(address p0, string memory p1, address p2, address p3) internal pure {
 1414 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,string,address,address)", p0, p1, p2, p3));
 1415 |     |     }
 1416 |     | 
 1417 |     |     function log(address p0, bool p1, uint p2, uint p3) internal pure {
 1418 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,uint)", p0, p1, p2, p3));
 1419 |     |     }
 1420 |     | 
 1421 |     |     function log(address p0, bool p1, uint p2, string memory p3) internal pure {
 1422 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,string)", p0, p1, p2, p3));
 1423 |     |     }
 1424 |     | 
 1425 |     |     function log(address p0, bool p1, uint p2, bool p3) internal pure {
 1426 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,bool)", p0, p1, p2, p3));
 1427 |     |     }
 1428 |     | 
 1429 |     |     function log(address p0, bool p1, uint p2, address p3) internal pure {
 1430 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,uint,address)", p0, p1, p2, p3));
 1431 |     |     }
 1432 |     | 
 1433 |     |     function log(address p0, bool p1, string memory p2, uint p3) internal pure {
 1434 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,uint)", p0, p1, p2, p3));
 1435 |     |     }
 1436 |     | 
 1437 |     |     function log(address p0, bool p1, string memory p2, string memory p3) internal pure {
 1438 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,string)", p0, p1, p2, p3));
 1439 |     |     }
 1440 |     | 
 1441 |     |     function log(address p0, bool p1, string memory p2, bool p3) internal pure {
 1442 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,bool)", p0, p1, p2, p3));
 1443 |     |     }
 1444 |     | 
 1445 |     |     function log(address p0, bool p1, string memory p2, address p3) internal pure {
 1446 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,string,address)", p0, p1, p2, p3));
 1447 |     |     }
 1448 |     | 
 1449 |     |     function log(address p0, bool p1, bool p2, uint p3) internal pure {
 1450 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,uint)", p0, p1, p2, p3));
 1451 |     |     }
 1452 |     | 
 1453 |     |     function log(address p0, bool p1, bool p2, string memory p3) internal pure {
 1454 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,string)", p0, p1, p2, p3));
 1455 |     |     }
 1456 |     | 
 1457 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
 1458 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,bool)", p0, p1, p2, p3));
 1459 |     |     }
 1460 |     | 
 1461 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
 1462 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,bool,address)", p0, p1, p2, p3));
 1463 |     |     }
 1464 |     | 
 1465 |     |     function log(address p0, bool p1, address p2, uint p3) internal pure {
 1466 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,uint)", p0, p1, p2, p3));
 1467 |     |     }
 1468 |     | 
 1469 |     |     function log(address p0, bool p1, address p2, string memory p3) internal pure {
 1470 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,string)", p0, p1, p2, p3));
 1471 |     |     }
 1472 |     | 
 1473 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
 1474 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,bool)", p0, p1, p2, p3));
 1475 |     |     }
 1476 |     | 
 1477 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
 1478 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,bool,address,address)", p0, p1, p2, p3));
 1479 |     |     }
 1480 |     | 
 1481 |     |     function log(address p0, address p1, uint p2, uint p3) internal pure {
 1482 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,uint)", p0, p1, p2, p3));
 1483 |     |     }
 1484 |     | 
 1485 |     |     function log(address p0, address p1, uint p2, string memory p3) internal pure {
 1486 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,string)", p0, p1, p2, p3));
 1487 |     |     }
 1488 |     | 
 1489 |     |     function log(address p0, address p1, uint p2, bool p3) internal pure {
 1490 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,bool)", p0, p1, p2, p3));
 1491 |     |     }
 1492 |     | 
 1493 |     |     function log(address p0, address p1, uint p2, address p3) internal pure {
 1494 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,uint,address)", p0, p1, p2, p3));
 1495 |     |     }
 1496 |     | 
 1497 |     |     function log(address p0, address p1, string memory p2, uint p3) internal pure {
 1498 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,uint)", p0, p1, p2, p3));
 1499 |     |     }
 1500 |     | 
 1501 |     |     function log(address p0, address p1, string memory p2, string memory p3) internal pure {
 1502 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,string)", p0, p1, p2, p3));
 1503 |     |     }
 1504 |     | 
 1505 |     |     function log(address p0, address p1, string memory p2, bool p3) internal pure {
 1506 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,bool)", p0, p1, p2, p3));
 1507 |     |     }
 1508 |     | 
 1509 |     |     function log(address p0, address p1, string memory p2, address p3) internal pure {
 1510 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,string,address)", p0, p1, p2, p3));
 1511 |     |     }
 1512 |     | 
 1513 |     |     function log(address p0, address p1, bool p2, uint p3) internal pure {
 1514 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,uint)", p0, p1, p2, p3));
 1515 |     |     }
 1516 |     | 
 1517 |     |     function log(address p0, address p1, bool p2, string memory p3) internal pure {
 1518 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,string)", p0, p1, p2, p3));
 1519 |     |     }
 1520 |     | 
 1521 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
 1522 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,bool)", p0, p1, p2, p3));
 1523 |     |     }
 1524 |     | 
 1525 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
 1526 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,bool,address)", p0, p1, p2, p3));
 1527 |     |     }
 1528 |     | 
 1529 |     |     function log(address p0, address p1, address p2, uint p3) internal pure {
 1530 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,uint)", p0, p1, p2, p3));
 1531 |     |     }
 1532 |     | 
 1533 |     |     function log(address p0, address p1, address p2, string memory p3) internal pure {
 1534 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,string)", p0, p1, p2, p3));
 1535 |     |     }
 1536 |     | 
 1537 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
 1538 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,bool)", p0, p1, p2, p3));
 1539 |     |     }
 1540 |     | 
 1541 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
 1542 |     |         _sendLogPayload(abi.encodeWithSignature("log(address,address,address,address)", p0, p1, p2, p3));
 1543 |     |     }
 1544 |     | }
 1545 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/console2.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity >=0.4.22 <0.9.0;
 3 |     | 
 4 |     | import {console as console2} from "./console.sol";
 5 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | interface IERC165 {
  5 |     |     /// @notice Query if a contract implements an interface
  6 |     |     /// @param interfaceID The interface identifier, as specified in ERC-165
  7 |     |     /// @dev Interface identification is specified in ERC-165. This function
  8 |     |     /// uses less than 30,000 gas.
  9 |     |     /// @return `true` if the contract implements `interfaceID` and
 10 |     |     /// `interfaceID` is not 0xffffffff, `false` otherwise
 11 |     |     function supportsInterface(bytes4 interfaceID) external view returns (bool);
 12 |     | }
 13 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | /// @dev Interface of the ERC20 standard as defined in the EIP.
  5 |     | /// @dev This includes the optional name, symbol, and decimals metadata.
  6 |     | interface IERC20 {
  7 |     |     /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
  8 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  9 |     | 
 10 |     |     /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
 11 |     |     /// is the new allowance.
 12 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 13 |     | 
 14 |     |     /// @notice Returns the amount of tokens in existence.
 15 |     |     function totalSupply() external view returns (uint256);
 16 |     | 
 17 |     |     /// @notice Returns the amount of tokens owned by `account`.
 18 |     |     function balanceOf(address account) external view returns (uint256);
 19 |     | 
 20 |     |     /// @notice Moves `amount` tokens from the caller's account to `to`.
 21 |     |     function transfer(address to, uint256 amount) external returns (bool);
 22 |     | 
 23 |     |     /// @notice Returns the remaining number of tokens that `spender` is allowed
 24 |     |     /// to spend on behalf of `owner`
 25 |     |     function allowance(address owner, address spender) external view returns (uint256);
 26 |     | 
 27 |     |     /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
 28 |     |     /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 29 |     |     function approve(address spender, uint256 amount) external returns (bool);
 30 |     | 
 31 |     |     /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
 32 |     |     /// `amount` is then deducted from the caller's allowance.
 33 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 34 |     | 
 35 |     |     /// @notice Returns the name of the token.
 36 |     |     function name() external view returns (string memory);
 37 |     | 
 38 |     |     /// @notice Returns the symbol of the token.
 39 |     |     function symbol() external view returns (string memory);
 40 |     | 
 41 |     |     /// @notice Returns the decimals places of the token.
 42 |     |     function decimals() external view returns (uint8);
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2;
   3 |     | 
   4 |     | import "./IERC165.sol";
   5 |     | 
   6 |     | /// @title ERC-721 Non-Fungible Token Standard
   7 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
   8 |     | /// Note: the ERC-165 identifier for this interface is 0x80ac58cd.
   9 |     | interface IERC721 is IERC165 {
  10 |     |     /// @dev This emits when ownership of any NFT changes by any mechanism.
  11 |     |     /// This event emits when NFTs are created (`from` == 0) and destroyed
  12 |     |     /// (`to` == 0). Exception: during contract creation, any number of NFTs
  13 |     |     /// may be created and assigned without emitting Transfer. At the time of
  14 |     |     /// any transfer, the approved address for that NFT (if any) is reset to none.
  15 |     |     event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
  16 |     | 
  17 |     |     /// @dev This emits when the approved address for an NFT is changed or
  18 |     |     /// reaffirmed. The zero address indicates there is no approved address.
  19 |     |     /// When a Transfer event emits, this also indicates that the approved
  20 |     |     /// address for that NFT (if any) is reset to none.
  21 |     |     event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
  22 |     | 
  23 |     |     /// @dev This emits when an operator is enabled or disabled for an owner.
  24 |     |     /// The operator can manage all NFTs of the owner.
  25 |     |     event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);
  26 |     | 
  27 |     |     /// @notice Count all NFTs assigned to an owner
  28 |     |     /// @dev NFTs assigned to the zero address are considered invalid, and this
  29 |     |     /// function throws for queries about the zero address.
  30 |     |     /// @param _owner An address for whom to query the balance
  31 |     |     /// @return The number of NFTs owned by `_owner`, possibly zero
  32 |     |     function balanceOf(address _owner) external view returns (uint256);
  33 |     | 
  34 |     |     /// @notice Find the owner of an NFT
  35 |     |     /// @dev NFTs assigned to zero address are considered invalid, and queries
  36 |     |     /// about them do throw.
  37 |     |     /// @param _tokenId The identifier for an NFT
  38 |     |     /// @return The address of the owner of the NFT
  39 |     |     function ownerOf(uint256 _tokenId) external view returns (address);
  40 |     | 
  41 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  42 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  43 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  44 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  45 |     |     /// `_tokenId` is not a valid NFT. When transfer is complete, this function
  46 |     |     /// checks if `_to` is a smart contract (code size > 0). If so, it calls
  47 |     |     /// `onERC721Received` on `_to` and throws if the return value is not
  48 |     |     /// `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`.
  49 |     |     /// @param _from The current owner of the NFT
  50 |     |     /// @param _to The new owner
  51 |     |     /// @param _tokenId The NFT to transfer
  52 |     |     /// @param data Additional data with no specified format, sent in call to `_to`
  53 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;
  54 |     | 
  55 |     |     /// @notice Transfers the ownership of an NFT from one address to another address
  56 |     |     /// @dev This works identically to the other function with an extra data parameter,
  57 |     |     /// except this function just sets data to "".
  58 |     |     /// @param _from The current owner of the NFT
  59 |     |     /// @param _to The new owner
  60 |     |     /// @param _tokenId The NFT to transfer
  61 |     |     function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
  62 |     | 
  63 |     |     /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE
  64 |     |     /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE
  65 |     |     /// THEY MAY BE PERMANENTLY LOST
  66 |     |     /// @dev Throws unless `msg.sender` is the current owner, an authorized
  67 |     |     /// operator, or the approved address for this NFT. Throws if `_from` is
  68 |     |     /// not the current owner. Throws if `_to` is the zero address. Throws if
  69 |     |     /// `_tokenId` is not a valid NFT.
  70 |     |     /// @param _from The current owner of the NFT
  71 |     |     /// @param _to The new owner
  72 |     |     /// @param _tokenId The NFT to transfer
  73 |     |     function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
  74 |     | 
  75 |     |     /// @notice Change or reaffirm the approved address for an NFT
  76 |     |     /// @dev The zero address indicates there is no approved address.
  77 |     |     /// Throws unless `msg.sender` is the current NFT owner, or an authorized
  78 |     |     /// operator of the current owner.
  79 |     |     /// @param _approved The new approved NFT controller
  80 |     |     /// @param _tokenId The NFT to approve
  81 |     |     function approve(address _approved, uint256 _tokenId) external payable;
  82 |     | 
  83 |     |     /// @notice Enable or disable approval for a third party ("operator") to manage
  84 |     |     /// all of `msg.sender`'s assets
  85 |     |     /// @dev Emits the ApprovalForAll event. The contract MUST allow
  86 |     |     /// multiple operators per owner.
  87 |     |     /// @param _operator Address to add to the set of authorized operators
  88 |     |     /// @param _approved True if the operator is approved, false to revoke approval
  89 |     |     function setApprovalForAll(address _operator, bool _approved) external;
  90 |     | 
  91 |     |     /// @notice Get the approved address for a single NFT
  92 |     |     /// @dev Throws if `_tokenId` is not a valid NFT.
  93 |     |     /// @param _tokenId The NFT to find the approved address for
  94 |     |     /// @return The approved address for this NFT, or the zero address if there is none
  95 |     |     function getApproved(uint256 _tokenId) external view returns (address);
  96 |     | 
  97 |     |     /// @notice Query if an address is an authorized operator for another address
  98 |     |     /// @param _owner The address that owns the NFTs
  99 |     |     /// @param _operator The address that acts on behalf of the owner
 100 |     |     /// @return True if `_operator` is an approved operator for `_owner`, false otherwise
 101 |     |     function isApprovedForAll(address _owner, address _operator) external view returns (bool);
 102 |     | }
 103 |     | 
 104 |     | /// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.
 105 |     | interface IERC721TokenReceiver {
 106 |     |     /// @notice Handle the receipt of an NFT
 107 |     |     /// @dev The ERC721 smart contract calls this function on the recipient
 108 |     |     /// after a `transfer`. This function MAY throw to revert and reject the
 109 |     |     /// transfer. Return of other than the magic value MUST result in the
 110 |     |     /// transaction being reverted.
 111 |     |     /// Note: the contract address is always the message sender.
 112 |     |     /// @param _operator The address which called `safeTransferFrom` function
 113 |     |     /// @param _from The address which previously owned the token
 114 |     |     /// @param _tokenId The NFT identifier which is being transferred
 115 |     |     /// @param _data Additional data with no specified format
 116 |     |     /// @return `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`
 117 |     |     ///  unless throwing
 118 |     |     function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)
 119 |     |         external
 120 |     |         returns (bytes4);
 121 |     | }
 122 |     | 
 123 |     | /// @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 124 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 125 |     | /// Note: the ERC-165 identifier for this interface is 0x5b5e139f.
 126 |     | interface IERC721Metadata is IERC721 {
 127 |     |     /// @notice A descriptive name for a collection of NFTs in this contract
 128 |     |     function name() external view returns (string memory _name);
 129 |     | 
 130 |     |     /// @notice An abbreviated name for NFTs in this contract
 131 |     |     function symbol() external view returns (string memory _symbol);
 132 |     | 
 133 |     |     /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.
 134 |     |     /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC
 135 |     |     /// 3986. The URI may point to a JSON file that conforms to the "ERC721
 136 |     |     /// Metadata JSON Schema".
 137 |     |     function tokenURI(uint256 _tokenId) external view returns (string memory);
 138 |     | }
 139 |     | 
 140 |     | /// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension
 141 |     | /// @dev See https://eips.ethereum.org/EIPS/eip-721
 142 |     | /// Note: the ERC-165 identifier for this interface is 0x780e9d63.
 143 |     | interface IERC721Enumerable is IERC721 {
 144 |     |     /// @notice Count NFTs tracked by this contract
 145 |     |     /// @return A count of valid NFTs tracked by this contract, where each one of
 146 |     |     /// them has an assigned and queryable owner not equal to the zero address
 147 |     |     function totalSupply() external view returns (uint256);
 148 |     | 
 149 |     |     /// @notice Enumerate valid NFTs
 150 |     |     /// @dev Throws if `_index` >= `totalSupply()`.
 151 |     |     /// @param _index A counter less than `totalSupply()`
 152 |     |     /// @return The token identifier for the `_index`th NFT,
 153 |     |     /// (sort order not specified)
 154 |     |     function tokenByIndex(uint256 _index) external view returns (uint256);
 155 |     | 
 156 |     |     /// @notice Enumerate NFTs assigned to an owner
 157 |     |     /// @dev Throws if `_index` >= `balanceOf(_owner)` or if
 158 |     |     /// `_owner` is the zero address, representing invalid NFTs.
 159 |     |     /// @param _owner An address where we are interested in NFTs owned by them
 160 |     |     /// @param _index A counter less than `balanceOf(_owner)`
 161 |     |     /// @return The token identifier for the `_index`th NFT assigned to `_owner`,
 162 |     |     /// (sort order not specified)
 163 |     |     function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);
 164 |     | }
 165 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IMulticall3.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2 <0.9.0;
  3 |     | 
  4 |     | pragma experimental ABIEncoderV2;
  5 |     | 
  6 |     | interface IMulticall3 {
  7 |     |     struct Call {
  8 |     |         address target;
  9 |     |         bytes callData;
 10 |     |     }
 11 |     | 
 12 |     |     struct Call3 {
 13 |     |         address target;
 14 |     |         bool allowFailure;
 15 |     |         bytes callData;
 16 |     |     }
 17 |     | 
 18 |     |     struct Call3Value {
 19 |     |         address target;
 20 |     |         bool allowFailure;
 21 |     |         uint256 value;
 22 |     |         bytes callData;
 23 |     |     }
 24 |     | 
 25 |     |     struct Result {
 26 |     |         bool success;
 27 |     |         bytes returnData;
 28 |     |     }
 29 |     | 
 30 |     |     function aggregate(Call[] calldata calls)
 31 |     |         external
 32 |     |         payable
 33 |     |         returns (uint256 blockNumber, bytes[] memory returnData);
 34 |     | 
 35 |     |     function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);
 36 |     | 
 37 |     |     function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);
 38 |     | 
 39 |     |     function blockAndAggregate(Call[] calldata calls)
 40 |     |         external
 41 |     |         payable
 42 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 43 |     | 
 44 |     |     function getBasefee() external view returns (uint256 basefee);
 45 |     | 
 46 |     |     function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);
 47 |     | 
 48 |     |     function getBlockNumber() external view returns (uint256 blockNumber);
 49 |     | 
 50 |     |     function getChainId() external view returns (uint256 chainid);
 51 |     | 
 52 |     |     function getCurrentBlockCoinbase() external view returns (address coinbase);
 53 |     | 
 54 |     |     function getCurrentBlockDifficulty() external view returns (uint256 difficulty);
 55 |     | 
 56 |     |     function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);
 57 |     | 
 58 |     |     function getCurrentBlockTimestamp() external view returns (uint256 timestamp);
 59 |     | 
 60 |     |     function getEthBalance(address addr) external view returns (uint256 balance);
 61 |     | 
 62 |     |     function getLastBlockHash() external view returns (bytes32 blockHash);
 63 |     | 
 64 |     |     function tryAggregate(bool requireSuccess, Call[] calldata calls)
 65 |     |         external
 66 |     |         payable
 67 |     |         returns (Result[] memory returnData);
 68 |     | 
 69 |     |     function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)
 70 |     |         external
 71 |     |         payable
 72 |     |         returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);
 73 |     | }
 74 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/mocks/MockERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC20} from "../interfaces/IERC20.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol
   8 |     | contract MockERC20 is IERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                             METADATA STORAGE
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     uint8 internal _decimals;
  18 |     | 
  19 |     |     function name() external view override returns (string memory) {
  20 |     |         return _name;
  21 |     |     }
  22 |     | 
  23 |     |     function symbol() external view override returns (string memory) {
  24 |     |         return _symbol;
  25 |     |     }
  26 |     | 
  27 |     |     function decimals() external view override returns (uint8) {
  28 |     |         return _decimals;
  29 |     |     }
  30 |     | 
  31 |     |     /*//////////////////////////////////////////////////////////////
  32 |     |                               ERC20 STORAGE
  33 |     |     //////////////////////////////////////////////////////////////*/
  34 |     | 
  35 |     |     uint256 internal _totalSupply;
  36 |     | 
  37 |     |     mapping(address => uint256) internal _balanceOf;
  38 |     | 
  39 |     |     mapping(address => mapping(address => uint256)) internal _allowance;
  40 |     | 
  41 |     |     function totalSupply() external view override returns (uint256) {
  42 |     |         return _totalSupply;
  43 |     |     }
  44 |     | 
  45 |     |     function balanceOf(address owner) external view override returns (uint256) {
  46 |     |         return _balanceOf[owner];
  47 |     |     }
  48 |     | 
  49 |     |     function allowance(address owner, address spender) external view override returns (uint256) {
  50 |     |         return _allowance[owner][spender];
  51 |     |     }
  52 |     | 
  53 |     |     /*//////////////////////////////////////////////////////////////
  54 |     |                             EIP-2612 STORAGE
  55 |     |     //////////////////////////////////////////////////////////////*/
  56 |     | 
  57 |     |     uint256 internal INITIAL_CHAIN_ID;
  58 |     | 
  59 |     |     bytes32 internal INITIAL_DOMAIN_SEPARATOR;
  60 |     | 
  61 |     |     mapping(address => uint256) public nonces;
  62 |     | 
  63 |     |     /*//////////////////////////////////////////////////////////////
  64 |     |                                INITIALIZE
  65 |     |     //////////////////////////////////////////////////////////////*/
  66 |     | 
  67 |     |     /// @dev A bool to track whether the contract has been initialized.
  68 |     |     bool private initialized;
  69 |     | 
  70 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  71 |     |     /// syntaxes, we add an initialization function that can be called only once.
  72 |     |     function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {
  73 |     |         require(!initialized, "ALREADY_INITIALIZED");
  74 |     | 
  75 |     |         _name = name_;
  76 |     |         _symbol = symbol_;
  77 |     |         _decimals = decimals_;
  78 |     | 
  79 |     |         INITIAL_CHAIN_ID = _pureChainId();
  80 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  81 |     | 
  82 |     |         initialized = true;
  83 |     |     }
  84 |     | 
  85 |     |     /*//////////////////////////////////////////////////////////////
  86 |     |                                ERC20 LOGIC
  87 |     |     //////////////////////////////////////////////////////////////*/
  88 |     | 
  89 |     |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  90 |     |         _allowance[msg.sender][spender] = amount;
  91 |     | 
  92 |     |         emit Approval(msg.sender, spender, amount);
  93 |     | 
  94 |     |         return true;
  95 |     |     }
  96 |     | 
  97 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
  98 |     |         _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);
  99 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 100 |     | 
 101 |     |         emit Transfer(msg.sender, to, amount);
 102 |     | 
 103 |     |         return true;
 104 |     |     }
 105 |     | 
 106 |     |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 107 |     |         uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.
 108 |     | 
 109 |     |         if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);
 110 |     | 
 111 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 112 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 113 |     | 
 114 |     |         emit Transfer(from, to, amount);
 115 |     | 
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /*//////////////////////////////////////////////////////////////
 120 |     |                              EIP-2612 LOGIC
 121 |     |     //////////////////////////////////////////////////////////////*/
 122 |     | 
 123 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 124 |     |         public
 125 |     |         virtual
 126 |     |     {
 127 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 128 |     | 
 129 |     |         address recoveredAddress = ecrecover(
 130 |     |             keccak256(
 131 |     |                 abi.encodePacked(
 132 |     |                     "\x19\x01",
 133 |     |                     DOMAIN_SEPARATOR(),
 134 |     |                     keccak256(
 135 |     |                         abi.encode(
 136 |     |                             keccak256(
 137 |     |                                 "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 138 |     |                             ),
 139 |     |                             owner,
 140 |     |                             spender,
 141 |     |                             value,
 142 |     |                             nonces[owner]++,
 143 |     |                             deadline
 144 |     |                         )
 145 |     |                     )
 146 |     |                 )
 147 |     |             ),
 148 |     |             v,
 149 |     |             r,
 150 |     |             s
 151 |     |         );
 152 |     | 
 153 |     |         require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 154 |     | 
 155 |     |         _allowance[recoveredAddress][spender] = value;
 156 |     | 
 157 |     |         emit Approval(owner, spender, value);
 158 |     |     }
 159 |     | 
 160 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 161 |     |         return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 162 |     |     }
 163 |     | 
 164 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 165 |     |         return keccak256(
 166 |     |             abi.encode(
 167 |     |                 keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 168 |     |                 keccak256(bytes(_name)),
 169 |     |                 keccak256("1"),
 170 |     |                 _pureChainId(),
 171 |     |                 address(this)
 172 |     |             )
 173 |     |         );
 174 |     |     }
 175 |     | 
 176 |     |     /*//////////////////////////////////////////////////////////////
 177 |     |                         INTERNAL MINT/BURN LOGIC
 178 |     |     //////////////////////////////////////////////////////////////*/
 179 |     | 
 180 |     |     function _mint(address to, uint256 amount) internal virtual {
 181 |     |         _totalSupply = _add(_totalSupply, amount);
 182 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 183 |     | 
 184 |     |         emit Transfer(address(0), to, amount);
 185 |     |     }
 186 |     | 
 187 |     |     function _burn(address from, uint256 amount) internal virtual {
 188 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 189 |     |         _totalSupply = _sub(_totalSupply, amount);
 190 |     | 
 191 |     |         emit Transfer(from, address(0), amount);
 192 |     |     }
 193 |     | 
 194 |     |     /*//////////////////////////////////////////////////////////////
 195 |     |                         INTERNAL SAFE MATH LOGIC
 196 |     |     //////////////////////////////////////////////////////////////*/
 197 |     | 
 198 |     |     function _add(uint256 a, uint256 b) internal pure returns (uint256) {
 199 |     |         uint256 c = a + b;
 200 |     |         require(c >= a, "ERC20: addition overflow");
 201 |     |         return c;
 202 |     |     }
 203 |     | 
 204 |     |     function _sub(uint256 a, uint256 b) internal pure returns (uint256) {
 205 |     |         require(a >= b, "ERC20: subtraction underflow");
 206 |     |         return a - b;
 207 |     |     }
 208 |     | 
 209 |     |     /*//////////////////////////////////////////////////////////////
 210 |     |                                 HELPERS
 211 |     |     //////////////////////////////////////////////////////////////*/
 212 |     | 
 213 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 214 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 215 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 216 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 217 |     |     function _viewChainId() private view returns (uint256 chainId) {
 218 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 219 |     |         assembly {
 220 |     |             chainId := chainid()
 221 |     |         }
 222 |     | 
 223 |     |         address(this); // Silence warnings in older Solc versions.
 224 |     |     }
 225 |     | 
 226 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 227 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 228 |     |         function() internal pure returns (uint256) pureChainId;
 229 |     |         assembly {
 230 |     |             pureChainId := fnIn
 231 |     |         }
 232 |     |         chainId = pureChainId();
 233 |     |     }
 234 |     | }
 235 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/mocks/MockERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC721Metadata, IERC721TokenReceiver} from "../interfaces/IERC721.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol
   8 |     | contract MockERC721 is IERC721Metadata {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                          METADATA STORAGE/LOGIC
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     function name() external view override returns (string memory) {
  18 |     |         return _name;
  19 |     |     }
  20 |     | 
  21 |     |     function symbol() external view override returns (string memory) {
  22 |     |         return _symbol;
  23 |     |     }
  24 |     | 
  25 |     |     function tokenURI(uint256 id) public view virtual override returns (string memory) {}
  26 |     | 
  27 |     |     /*//////////////////////////////////////////////////////////////
  28 |     |                       ERC721 BALANCE/OWNER STORAGE
  29 |     |     //////////////////////////////////////////////////////////////*/
  30 |     | 
  31 |     |     mapping(uint256 => address) internal _ownerOf;
  32 |     | 
  33 |     |     mapping(address => uint256) internal _balanceOf;
  34 |     | 
  35 |     |     function ownerOf(uint256 id) public view virtual override returns (address owner) {
  36 |     |         require((owner = _ownerOf[id]) != address(0), "NOT_MINTED");
  37 |     |     }
  38 |     | 
  39 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  40 |     |         require(owner != address(0), "ZERO_ADDRESS");
  41 |     | 
  42 |     |         return _balanceOf[owner];
  43 |     |     }
  44 |     | 
  45 |     |     /*//////////////////////////////////////////////////////////////
  46 |     |                          ERC721 APPROVAL STORAGE
  47 |     |     //////////////////////////////////////////////////////////////*/
  48 |     | 
  49 |     |     mapping(uint256 => address) internal _getApproved;
  50 |     | 
  51 |     |     mapping(address => mapping(address => bool)) internal _isApprovedForAll;
  52 |     | 
  53 |     |     function getApproved(uint256 id) public view virtual override returns (address) {
  54 |     |         return _getApproved[id];
  55 |     |     }
  56 |     | 
  57 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
  58 |     |         return _isApprovedForAll[owner][operator];
  59 |     |     }
  60 |     | 
  61 |     |     /*//////////////////////////////////////////////////////////////
  62 |     |                                INITIALIZE
  63 |     |     //////////////////////////////////////////////////////////////*/
  64 |     | 
  65 |     |     /// @dev A bool to track whether the contract has been initialized.
  66 |     |     bool private initialized;
  67 |     | 
  68 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  69 |     |     /// syntaxes, we add an initialization function that can be called only once.
  70 |     |     function initialize(string memory name_, string memory symbol_) public {
  71 |     |         require(!initialized, "ALREADY_INITIALIZED");
  72 |     | 
  73 |     |         _name = name_;
  74 |     |         _symbol = symbol_;
  75 |     | 
  76 |     |         initialized = true;
  77 |     |     }
  78 |     | 
  79 |     |     /*//////////////////////////////////////////////////////////////
  80 |     |                               ERC721 LOGIC
  81 |     |     //////////////////////////////////////////////////////////////*/
  82 |     | 
  83 |     |     function approve(address spender, uint256 id) public payable virtual override {
  84 |     |         address owner = _ownerOf[id];
  85 |     | 
  86 |     |         require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], "NOT_AUTHORIZED");
  87 |     | 
  88 |     |         _getApproved[id] = spender;
  89 |     | 
  90 |     |         emit Approval(owner, spender, id);
  91 |     |     }
  92 |     | 
  93 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
  94 |     |         _isApprovedForAll[msg.sender][operator] = approved;
  95 |     | 
  96 |     |         emit ApprovalForAll(msg.sender, operator, approved);
  97 |     |     }
  98 |     | 
  99 |     |     function transferFrom(address from, address to, uint256 id) public payable virtual override {
 100 |     |         require(from == _ownerOf[id], "WRONG_FROM");
 101 |     | 
 102 |     |         require(to != address(0), "INVALID_RECIPIENT");
 103 |     | 
 104 |     |         require(
 105 |     |             msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],
 106 |     |             "NOT_AUTHORIZED"
 107 |     |         );
 108 |     | 
 109 |     |         // Underflow of the sender's balance is impossible because we check for
 110 |     |         // ownership above and the recipient's balance can't realistically overflow.
 111 |     |         _balanceOf[from]--;
 112 |     | 
 113 |     |         _balanceOf[to]++;
 114 |     | 
 115 |     |         _ownerOf[id] = to;
 116 |     | 
 117 |     |         delete _getApproved[id];
 118 |     | 
 119 |     |         emit Transfer(from, to, id);
 120 |     |     }
 121 |     | 
 122 |     |     function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {
 123 |     |         transferFrom(from, to, id);
 124 |     | 
 125 |     |         require(
 126 |     |             !_isContract(to)
 127 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, "")
 128 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 129 |     |             "UNSAFE_RECIPIENT"
 130 |     |         );
 131 |     |     }
 132 |     | 
 133 |     |     function safeTransferFrom(address from, address to, uint256 id, bytes memory data)
 134 |     |         public
 135 |     |         payable
 136 |     |         virtual
 137 |     |         override
 138 |     |     {
 139 |     |         transferFrom(from, to, id);
 140 |     | 
 141 |     |         require(
 142 |     |             !_isContract(to)
 143 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)
 144 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 145 |     |             "UNSAFE_RECIPIENT"
 146 |     |         );
 147 |     |     }
 148 |     | 
 149 |     |     /*//////////////////////////////////////////////////////////////
 150 |     |                               ERC165 LOGIC
 151 |     |     //////////////////////////////////////////////////////////////*/
 152 |     | 
 153 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 154 |     |         return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165
 155 |     |             || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721
 156 |     |             || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata
 157 |     |     }
 158 |     | 
 159 |     |     /*//////////////////////////////////////////////////////////////
 160 |     |                         INTERNAL MINT/BURN LOGIC
 161 |     |     //////////////////////////////////////////////////////////////*/
 162 |     | 
 163 |     |     function _mint(address to, uint256 id) internal virtual {
 164 |     |         require(to != address(0), "INVALID_RECIPIENT");
 165 |     | 
 166 |     |         require(_ownerOf[id] == address(0), "ALREADY_MINTED");
 167 |     | 
 168 |     |         // Counter overflow is incredibly unrealistic.
 169 |     | 
 170 |     |         _balanceOf[to]++;
 171 |     | 
 172 |     |         _ownerOf[id] = to;
 173 |     | 
 174 |     |         emit Transfer(address(0), to, id);
 175 |     |     }
 176 |     | 
 177 |     |     function _burn(uint256 id) internal virtual {
 178 |     |         address owner = _ownerOf[id];
 179 |     | 
 180 |     |         require(owner != address(0), "NOT_MINTED");
 181 |     | 
 182 |     |         _balanceOf[owner]--;
 183 |     | 
 184 |     |         delete _ownerOf[id];
 185 |     | 
 186 |     |         delete _getApproved[id];
 187 |     | 
 188 |     |         emit Transfer(owner, address(0), id);
 189 |     |     }
 190 |     | 
 191 |     |     /*//////////////////////////////////////////////////////////////
 192 |     |                         INTERNAL SAFE MINT LOGIC
 193 |     |     //////////////////////////////////////////////////////////////*/
 194 |     | 
 195 |     |     function _safeMint(address to, uint256 id) internal virtual {
 196 |     |         _mint(to, id);
 197 |     | 
 198 |     |         require(
 199 |     |             !_isContract(to)
 200 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, "")
 201 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 202 |     |             "UNSAFE_RECIPIENT"
 203 |     |         );
 204 |     |     }
 205 |     | 
 206 |     |     function _safeMint(address to, uint256 id, bytes memory data) internal virtual {
 207 |     |         _mint(to, id);
 208 |     | 
 209 |     |         require(
 210 |     |             !_isContract(to)
 211 |     |                 || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)
 212 |     |                     == IERC721TokenReceiver.onERC721Received.selector,
 213 |     |             "UNSAFE_RECIPIENT"
 214 |     |         );
 215 |     |     }
 216 |     | 
 217 |     |     /*//////////////////////////////////////////////////////////////
 218 |     |                                 HELPERS
 219 |     |     //////////////////////////////////////////////////////////////*/
 220 |     | 
 221 |     |     function _isContract(address _addr) private view returns (bool) {
 222 |     |         uint256 codeLength;
 223 |     | 
 224 |     |         // Assembly required for versions < 0.8.0 to check extcodesize.
 225 |     |         assembly {
 226 |     |             codeLength := extcodesize(_addr)
 227 |     |         }
 228 |     | 
 229 |     |         return codeLength > 0;
 230 |     |     }
 231 |     | }
 232 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/safeconsole.sol
     1 |     | // SPDX-License-Identifier: MIT
     2 |     | pragma solidity >=0.6.2 <0.9.0;
     3 |     | 
     4 |     | /// @author philogy <https://github.com/philogy>
     5 |     | /// @dev Code generated automatically by script.
     6 |     | library safeconsole {
     7 |     |     uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;
     8 |     | 
     9 |     |     // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)
    10 |     |     // for the view-to-pure log trick.
    11 |     |     function _sendLogPayload(uint256 offset, uint256 size) private pure {
    12 |     |         function(uint256, uint256) internal view fnIn = _sendLogPayloadView;
    13 |     |         function(uint256, uint256) internal pure pureSendLogPayload;
    14 |     |         assembly {
    15 |     |             pureSendLogPayload := fnIn
    16 |     |         }
    17 |     |         pureSendLogPayload(offset, size);
    18 |     |     }
    19 |     | 
    20 |     |     function _sendLogPayloadView(uint256 offset, uint256 size) private view {
    21 |     |         assembly {
    22 |     |             pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))
    23 |     |         }
    24 |     |     }
    25 |     | 
    26 |     |     function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {
    27 |     |         function(uint256, uint256, uint256) internal view fnIn = _memcopyView;
    28 |     |         function(uint256, uint256, uint256) internal pure pureMemcopy;
    29 |     |         assembly {
    30 |     |             pureMemcopy := fnIn
    31 |     |         }
    32 |     |         pureMemcopy(fromOffset, toOffset, length);
    33 |     |     }
    34 |     | 
    35 |     |     function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {
    36 |     |         assembly {
    37 |     |             pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))
    38 |     |         }
    39 |     |     }
    40 |     | 
    41 |     |     function logMemory(uint256 offset, uint256 length) internal pure {
    42 |     |         if (offset >= 0x60) {
    43 |     |             // Sufficient memory before slice to prepare call header.
    44 |     |             bytes32 m0;
    45 |     |             bytes32 m1;
    46 |     |             bytes32 m2;
    47 |     |             assembly {
    48 |     |                 m0 := mload(sub(offset, 0x60))
    49 |     |                 m1 := mload(sub(offset, 0x40))
    50 |     |                 m2 := mload(sub(offset, 0x20))
    51 |     |                 // Selector of `logBytes(bytes)`.
    52 |     |                 mstore(sub(offset, 0x60), 0xe17bf956)
    53 |     |                 mstore(sub(offset, 0x40), 0x20)
    54 |     |                 mstore(sub(offset, 0x20), length)
    55 |     |             }
    56 |     |             _sendLogPayload(offset - 0x44, length + 0x44);
    57 |     |             assembly {
    58 |     |                 mstore(sub(offset, 0x60), m0)
    59 |     |                 mstore(sub(offset, 0x40), m1)
    60 |     |                 mstore(sub(offset, 0x20), m2)
    61 |     |             }
    62 |     |         } else {
    63 |     |             // Insufficient space, so copy slice forward, add header and reverse.
    64 |     |             bytes32 m0;
    65 |     |             bytes32 m1;
    66 |     |             bytes32 m2;
    67 |     |             uint256 endOffset = offset + length;
    68 |     |             assembly {
    69 |     |                 m0 := mload(add(endOffset, 0x00))
    70 |     |                 m1 := mload(add(endOffset, 0x20))
    71 |     |                 m2 := mload(add(endOffset, 0x40))
    72 |     |             }
    73 |     |             _memcopy(offset, offset + 0x60, length);
    74 |     |             assembly {
    75 |     |                 // Selector of `logBytes(bytes)`.
    76 |     |                 mstore(add(offset, 0x00), 0xe17bf956)
    77 |     |                 mstore(add(offset, 0x20), 0x20)
    78 |     |                 mstore(add(offset, 0x40), length)
    79 |     |             }
    80 |     |             _sendLogPayload(offset + 0x1c, length + 0x44);
    81 |     |             _memcopy(offset + 0x60, offset, length);
    82 |     |             assembly {
    83 |     |                 mstore(add(endOffset, 0x00), m0)
    84 |     |                 mstore(add(endOffset, 0x20), m1)
    85 |     |                 mstore(add(endOffset, 0x40), m2)
    86 |     |             }
    87 |     |         }
    88 |     |     }
    89 |     | 
    90 |     |     function log(address p0) internal pure {
    91 |     |         bytes32 m0;
    92 |     |         bytes32 m1;
    93 |     |         assembly {
    94 |     |             m0 := mload(0x00)
    95 |     |             m1 := mload(0x20)
    96 |     |             // Selector of `log(address)`.
    97 |     |             mstore(0x00, 0x2c2ecbc2)
    98 |     |             mstore(0x20, p0)
    99 |     |         }
   100 |     |         _sendLogPayload(0x1c, 0x24);
   101 |     |         assembly {
   102 |     |             mstore(0x00, m0)
   103 |     |             mstore(0x20, m1)
   104 |     |         }
   105 |     |     }
   106 |     | 
   107 |     |     function log(bool p0) internal pure {
   108 |     |         bytes32 m0;
   109 |     |         bytes32 m1;
   110 |     |         assembly {
   111 |     |             m0 := mload(0x00)
   112 |     |             m1 := mload(0x20)
   113 |     |             // Selector of `log(bool)`.
   114 |     |             mstore(0x00, 0x32458eed)
   115 |     |             mstore(0x20, p0)
   116 |     |         }
   117 |     |         _sendLogPayload(0x1c, 0x24);
   118 |     |         assembly {
   119 |     |             mstore(0x00, m0)
   120 |     |             mstore(0x20, m1)
   121 |     |         }
   122 |     |     }
   123 |     | 
   124 |     |     function log(uint256 p0) internal pure {
   125 |     |         bytes32 m0;
   126 |     |         bytes32 m1;
   127 |     |         assembly {
   128 |     |             m0 := mload(0x00)
   129 |     |             m1 := mload(0x20)
   130 |     |             // Selector of `log(uint256)`.
   131 |     |             mstore(0x00, 0xf82c50f1)
   132 |     |             mstore(0x20, p0)
   133 |     |         }
   134 |     |         _sendLogPayload(0x1c, 0x24);
   135 |     |         assembly {
   136 |     |             mstore(0x00, m0)
   137 |     |             mstore(0x20, m1)
   138 |     |         }
   139 |     |     }
   140 |     | 
   141 |     |     function log(bytes32 p0) internal pure {
   142 |     |         bytes32 m0;
   143 |     |         bytes32 m1;
   144 |     |         bytes32 m2;
   145 |     |         bytes32 m3;
   146 |     |         assembly {
   147 |     |             function writeString(pos, w) {
   148 |     |                 let length := 0
   149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   150 |     |                 mstore(pos, length)
   151 |     |                 let shift := sub(256, shl(3, length))
   152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   153 |     |             }
   154 |     |             m0 := mload(0x00)
   155 |     |             m1 := mload(0x20)
   156 |     |             m2 := mload(0x40)
   157 |     |             m3 := mload(0x60)
   158 |     |             // Selector of `log(string)`.
   159 |     |             mstore(0x00, 0x41304fac)
   160 |     |             mstore(0x20, 0x20)
   161 |     |             writeString(0x40, p0)
   162 |     |         }
   163 |     |         _sendLogPayload(0x1c, 0x64);
   164 |     |         assembly {
   165 |     |             mstore(0x00, m0)
   166 |     |             mstore(0x20, m1)
   167 |     |             mstore(0x40, m2)
   168 |     |             mstore(0x60, m3)
   169 |     |         }
   170 |     |     }
   171 |     | 
   172 |     |     function log(address p0, address p1) internal pure {
   173 |     |         bytes32 m0;
   174 |     |         bytes32 m1;
   175 |     |         bytes32 m2;
   176 |     |         assembly {
   177 |     |             m0 := mload(0x00)
   178 |     |             m1 := mload(0x20)
   179 |     |             m2 := mload(0x40)
   180 |     |             // Selector of `log(address,address)`.
   181 |     |             mstore(0x00, 0xdaf0d4aa)
   182 |     |             mstore(0x20, p0)
   183 |     |             mstore(0x40, p1)
   184 |     |         }
   185 |     |         _sendLogPayload(0x1c, 0x44);
   186 |     |         assembly {
   187 |     |             mstore(0x00, m0)
   188 |     |             mstore(0x20, m1)
   189 |     |             mstore(0x40, m2)
   190 |     |         }
   191 |     |     }
   192 |     | 
   193 |     |     function log(address p0, bool p1) internal pure {
   194 |     |         bytes32 m0;
   195 |     |         bytes32 m1;
   196 |     |         bytes32 m2;
   197 |     |         assembly {
   198 |     |             m0 := mload(0x00)
   199 |     |             m1 := mload(0x20)
   200 |     |             m2 := mload(0x40)
   201 |     |             // Selector of `log(address,bool)`.
   202 |     |             mstore(0x00, 0x75b605d3)
   203 |     |             mstore(0x20, p0)
   204 |     |             mstore(0x40, p1)
   205 |     |         }
   206 |     |         _sendLogPayload(0x1c, 0x44);
   207 |     |         assembly {
   208 |     |             mstore(0x00, m0)
   209 |     |             mstore(0x20, m1)
   210 |     |             mstore(0x40, m2)
   211 |     |         }
   212 |     |     }
   213 |     | 
   214 |     |     function log(address p0, uint256 p1) internal pure {
   215 |     |         bytes32 m0;
   216 |     |         bytes32 m1;
   217 |     |         bytes32 m2;
   218 |     |         assembly {
   219 |     |             m0 := mload(0x00)
   220 |     |             m1 := mload(0x20)
   221 |     |             m2 := mload(0x40)
   222 |     |             // Selector of `log(address,uint256)`.
   223 |     |             mstore(0x00, 0x8309e8a8)
   224 |     |             mstore(0x20, p0)
   225 |     |             mstore(0x40, p1)
   226 |     |         }
   227 |     |         _sendLogPayload(0x1c, 0x44);
   228 |     |         assembly {
   229 |     |             mstore(0x00, m0)
   230 |     |             mstore(0x20, m1)
   231 |     |             mstore(0x40, m2)
   232 |     |         }
   233 |     |     }
   234 |     | 
   235 |     |     function log(address p0, bytes32 p1) internal pure {
   236 |     |         bytes32 m0;
   237 |     |         bytes32 m1;
   238 |     |         bytes32 m2;
   239 |     |         bytes32 m3;
   240 |     |         bytes32 m4;
   241 |     |         assembly {
   242 |     |             function writeString(pos, w) {
   243 |     |                 let length := 0
   244 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   245 |     |                 mstore(pos, length)
   246 |     |                 let shift := sub(256, shl(3, length))
   247 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   248 |     |             }
   249 |     |             m0 := mload(0x00)
   250 |     |             m1 := mload(0x20)
   251 |     |             m2 := mload(0x40)
   252 |     |             m3 := mload(0x60)
   253 |     |             m4 := mload(0x80)
   254 |     |             // Selector of `log(address,string)`.
   255 |     |             mstore(0x00, 0x759f86bb)
   256 |     |             mstore(0x20, p0)
   257 |     |             mstore(0x40, 0x40)
   258 |     |             writeString(0x60, p1)
   259 |     |         }
   260 |     |         _sendLogPayload(0x1c, 0x84);
   261 |     |         assembly {
   262 |     |             mstore(0x00, m0)
   263 |     |             mstore(0x20, m1)
   264 |     |             mstore(0x40, m2)
   265 |     |             mstore(0x60, m3)
   266 |     |             mstore(0x80, m4)
   267 |     |         }
   268 |     |     }
   269 |     | 
   270 |     |     function log(bool p0, address p1) internal pure {
   271 |     |         bytes32 m0;
   272 |     |         bytes32 m1;
   273 |     |         bytes32 m2;
   274 |     |         assembly {
   275 |     |             m0 := mload(0x00)
   276 |     |             m1 := mload(0x20)
   277 |     |             m2 := mload(0x40)
   278 |     |             // Selector of `log(bool,address)`.
   279 |     |             mstore(0x00, 0x853c4849)
   280 |     |             mstore(0x20, p0)
   281 |     |             mstore(0x40, p1)
   282 |     |         }
   283 |     |         _sendLogPayload(0x1c, 0x44);
   284 |     |         assembly {
   285 |     |             mstore(0x00, m0)
   286 |     |             mstore(0x20, m1)
   287 |     |             mstore(0x40, m2)
   288 |     |         }
   289 |     |     }
   290 |     | 
   291 |     |     function log(bool p0, bool p1) internal pure {
   292 |     |         bytes32 m0;
   293 |     |         bytes32 m1;
   294 |     |         bytes32 m2;
   295 |     |         assembly {
   296 |     |             m0 := mload(0x00)
   297 |     |             m1 := mload(0x20)
   298 |     |             m2 := mload(0x40)
   299 |     |             // Selector of `log(bool,bool)`.
   300 |     |             mstore(0x00, 0x2a110e83)
   301 |     |             mstore(0x20, p0)
   302 |     |             mstore(0x40, p1)
   303 |     |         }
   304 |     |         _sendLogPayload(0x1c, 0x44);
   305 |     |         assembly {
   306 |     |             mstore(0x00, m0)
   307 |     |             mstore(0x20, m1)
   308 |     |             mstore(0x40, m2)
   309 |     |         }
   310 |     |     }
   311 |     | 
   312 |     |     function log(bool p0, uint256 p1) internal pure {
   313 |     |         bytes32 m0;
   314 |     |         bytes32 m1;
   315 |     |         bytes32 m2;
   316 |     |         assembly {
   317 |     |             m0 := mload(0x00)
   318 |     |             m1 := mload(0x20)
   319 |     |             m2 := mload(0x40)
   320 |     |             // Selector of `log(bool,uint256)`.
   321 |     |             mstore(0x00, 0x399174d3)
   322 |     |             mstore(0x20, p0)
   323 |     |             mstore(0x40, p1)
   324 |     |         }
   325 |     |         _sendLogPayload(0x1c, 0x44);
   326 |     |         assembly {
   327 |     |             mstore(0x00, m0)
   328 |     |             mstore(0x20, m1)
   329 |     |             mstore(0x40, m2)
   330 |     |         }
   331 |     |     }
   332 |     | 
   333 |     |     function log(bool p0, bytes32 p1) internal pure {
   334 |     |         bytes32 m0;
   335 |     |         bytes32 m1;
   336 |     |         bytes32 m2;
   337 |     |         bytes32 m3;
   338 |     |         bytes32 m4;
   339 |     |         assembly {
   340 |     |             function writeString(pos, w) {
   341 |     |                 let length := 0
   342 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   343 |     |                 mstore(pos, length)
   344 |     |                 let shift := sub(256, shl(3, length))
   345 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   346 |     |             }
   347 |     |             m0 := mload(0x00)
   348 |     |             m1 := mload(0x20)
   349 |     |             m2 := mload(0x40)
   350 |     |             m3 := mload(0x60)
   351 |     |             m4 := mload(0x80)
   352 |     |             // Selector of `log(bool,string)`.
   353 |     |             mstore(0x00, 0x8feac525)
   354 |     |             mstore(0x20, p0)
   355 |     |             mstore(0x40, 0x40)
   356 |     |             writeString(0x60, p1)
   357 |     |         }
   358 |     |         _sendLogPayload(0x1c, 0x84);
   359 |     |         assembly {
   360 |     |             mstore(0x00, m0)
   361 |     |             mstore(0x20, m1)
   362 |     |             mstore(0x40, m2)
   363 |     |             mstore(0x60, m3)
   364 |     |             mstore(0x80, m4)
   365 |     |         }
   366 |     |     }
   367 |     | 
   368 |     |     function log(uint256 p0, address p1) internal pure {
   369 |     |         bytes32 m0;
   370 |     |         bytes32 m1;
   371 |     |         bytes32 m2;
   372 |     |         assembly {
   373 |     |             m0 := mload(0x00)
   374 |     |             m1 := mload(0x20)
   375 |     |             m2 := mload(0x40)
   376 |     |             // Selector of `log(uint256,address)`.
   377 |     |             mstore(0x00, 0x69276c86)
   378 |     |             mstore(0x20, p0)
   379 |     |             mstore(0x40, p1)
   380 |     |         }
   381 |     |         _sendLogPayload(0x1c, 0x44);
   382 |     |         assembly {
   383 |     |             mstore(0x00, m0)
   384 |     |             mstore(0x20, m1)
   385 |     |             mstore(0x40, m2)
   386 |     |         }
   387 |     |     }
   388 |     | 
   389 |     |     function log(uint256 p0, bool p1) internal pure {
   390 |     |         bytes32 m0;
   391 |     |         bytes32 m1;
   392 |     |         bytes32 m2;
   393 |     |         assembly {
   394 |     |             m0 := mload(0x00)
   395 |     |             m1 := mload(0x20)
   396 |     |             m2 := mload(0x40)
   397 |     |             // Selector of `log(uint256,bool)`.
   398 |     |             mstore(0x00, 0x1c9d7eb3)
   399 |     |             mstore(0x20, p0)
   400 |     |             mstore(0x40, p1)
   401 |     |         }
   402 |     |         _sendLogPayload(0x1c, 0x44);
   403 |     |         assembly {
   404 |     |             mstore(0x00, m0)
   405 |     |             mstore(0x20, m1)
   406 |     |             mstore(0x40, m2)
   407 |     |         }
   408 |     |     }
   409 |     | 
   410 |     |     function log(uint256 p0, uint256 p1) internal pure {
   411 |     |         bytes32 m0;
   412 |     |         bytes32 m1;
   413 |     |         bytes32 m2;
   414 |     |         assembly {
   415 |     |             m0 := mload(0x00)
   416 |     |             m1 := mload(0x20)
   417 |     |             m2 := mload(0x40)
   418 |     |             // Selector of `log(uint256,uint256)`.
   419 |     |             mstore(0x00, 0xf666715a)
   420 |     |             mstore(0x20, p0)
   421 |     |             mstore(0x40, p1)
   422 |     |         }
   423 |     |         _sendLogPayload(0x1c, 0x44);
   424 |     |         assembly {
   425 |     |             mstore(0x00, m0)
   426 |     |             mstore(0x20, m1)
   427 |     |             mstore(0x40, m2)
   428 |     |         }
   429 |     |     }
   430 |     | 
   431 |     |     function log(uint256 p0, bytes32 p1) internal pure {
   432 |     |         bytes32 m0;
   433 |     |         bytes32 m1;
   434 |     |         bytes32 m2;
   435 |     |         bytes32 m3;
   436 |     |         bytes32 m4;
   437 |     |         assembly {
   438 |     |             function writeString(pos, w) {
   439 |     |                 let length := 0
   440 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   441 |     |                 mstore(pos, length)
   442 |     |                 let shift := sub(256, shl(3, length))
   443 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   444 |     |             }
   445 |     |             m0 := mload(0x00)
   446 |     |             m1 := mload(0x20)
   447 |     |             m2 := mload(0x40)
   448 |     |             m3 := mload(0x60)
   449 |     |             m4 := mload(0x80)
   450 |     |             // Selector of `log(uint256,string)`.
   451 |     |             mstore(0x00, 0x643fd0df)
   452 |     |             mstore(0x20, p0)
   453 |     |             mstore(0x40, 0x40)
   454 |     |             writeString(0x60, p1)
   455 |     |         }
   456 |     |         _sendLogPayload(0x1c, 0x84);
   457 |     |         assembly {
   458 |     |             mstore(0x00, m0)
   459 |     |             mstore(0x20, m1)
   460 |     |             mstore(0x40, m2)
   461 |     |             mstore(0x60, m3)
   462 |     |             mstore(0x80, m4)
   463 |     |         }
   464 |     |     }
   465 |     | 
   466 |     |     function log(bytes32 p0, address p1) internal pure {
   467 |     |         bytes32 m0;
   468 |     |         bytes32 m1;
   469 |     |         bytes32 m2;
   470 |     |         bytes32 m3;
   471 |     |         bytes32 m4;
   472 |     |         assembly {
   473 |     |             function writeString(pos, w) {
   474 |     |                 let length := 0
   475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   476 |     |                 mstore(pos, length)
   477 |     |                 let shift := sub(256, shl(3, length))
   478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   479 |     |             }
   480 |     |             m0 := mload(0x00)
   481 |     |             m1 := mload(0x20)
   482 |     |             m2 := mload(0x40)
   483 |     |             m3 := mload(0x60)
   484 |     |             m4 := mload(0x80)
   485 |     |             // Selector of `log(string,address)`.
   486 |     |             mstore(0x00, 0x319af333)
   487 |     |             mstore(0x20, 0x40)
   488 |     |             mstore(0x40, p1)
   489 |     |             writeString(0x60, p0)
   490 |     |         }
   491 |     |         _sendLogPayload(0x1c, 0x84);
   492 |     |         assembly {
   493 |     |             mstore(0x00, m0)
   494 |     |             mstore(0x20, m1)
   495 |     |             mstore(0x40, m2)
   496 |     |             mstore(0x60, m3)
   497 |     |             mstore(0x80, m4)
   498 |     |         }
   499 |     |     }
   500 |     | 
   501 |     |     function log(bytes32 p0, bool p1) internal pure {
   502 |     |         bytes32 m0;
   503 |     |         bytes32 m1;
   504 |     |         bytes32 m2;
   505 |     |         bytes32 m3;
   506 |     |         bytes32 m4;
   507 |     |         assembly {
   508 |     |             function writeString(pos, w) {
   509 |     |                 let length := 0
   510 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   511 |     |                 mstore(pos, length)
   512 |     |                 let shift := sub(256, shl(3, length))
   513 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   514 |     |             }
   515 |     |             m0 := mload(0x00)
   516 |     |             m1 := mload(0x20)
   517 |     |             m2 := mload(0x40)
   518 |     |             m3 := mload(0x60)
   519 |     |             m4 := mload(0x80)
   520 |     |             // Selector of `log(string,bool)`.
   521 |     |             mstore(0x00, 0xc3b55635)
   522 |     |             mstore(0x20, 0x40)
   523 |     |             mstore(0x40, p1)
   524 |     |             writeString(0x60, p0)
   525 |     |         }
   526 |     |         _sendLogPayload(0x1c, 0x84);
   527 |     |         assembly {
   528 |     |             mstore(0x00, m0)
   529 |     |             mstore(0x20, m1)
   530 |     |             mstore(0x40, m2)
   531 |     |             mstore(0x60, m3)
   532 |     |             mstore(0x80, m4)
   533 |     |         }
   534 |     |     }
   535 |     | 
   536 |     |     function log(bytes32 p0, uint256 p1) internal pure {
   537 |     |         bytes32 m0;
   538 |     |         bytes32 m1;
   539 |     |         bytes32 m2;
   540 |     |         bytes32 m3;
   541 |     |         bytes32 m4;
   542 |     |         assembly {
   543 |     |             function writeString(pos, w) {
   544 |     |                 let length := 0
   545 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   546 |     |                 mstore(pos, length)
   547 |     |                 let shift := sub(256, shl(3, length))
   548 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   549 |     |             }
   550 |     |             m0 := mload(0x00)
   551 |     |             m1 := mload(0x20)
   552 |     |             m2 := mload(0x40)
   553 |     |             m3 := mload(0x60)
   554 |     |             m4 := mload(0x80)
   555 |     |             // Selector of `log(string,uint256)`.
   556 |     |             mstore(0x00, 0xb60e72cc)
   557 |     |             mstore(0x20, 0x40)
   558 |     |             mstore(0x40, p1)
   559 |     |             writeString(0x60, p0)
   560 |     |         }
   561 |     |         _sendLogPayload(0x1c, 0x84);
   562 |     |         assembly {
   563 |     |             mstore(0x00, m0)
   564 |     |             mstore(0x20, m1)
   565 |     |             mstore(0x40, m2)
   566 |     |             mstore(0x60, m3)
   567 |     |             mstore(0x80, m4)
   568 |     |         }
   569 |     |     }
   570 |     | 
   571 |     |     function log(bytes32 p0, bytes32 p1) internal pure {
   572 |     |         bytes32 m0;
   573 |     |         bytes32 m1;
   574 |     |         bytes32 m2;
   575 |     |         bytes32 m3;
   576 |     |         bytes32 m4;
   577 |     |         bytes32 m5;
   578 |     |         bytes32 m6;
   579 |     |         assembly {
   580 |     |             function writeString(pos, w) {
   581 |     |                 let length := 0
   582 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   583 |     |                 mstore(pos, length)
   584 |     |                 let shift := sub(256, shl(3, length))
   585 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   586 |     |             }
   587 |     |             m0 := mload(0x00)
   588 |     |             m1 := mload(0x20)
   589 |     |             m2 := mload(0x40)
   590 |     |             m3 := mload(0x60)
   591 |     |             m4 := mload(0x80)
   592 |     |             m5 := mload(0xa0)
   593 |     |             m6 := mload(0xc0)
   594 |     |             // Selector of `log(string,string)`.
   595 |     |             mstore(0x00, 0x4b5c4277)
   596 |     |             mstore(0x20, 0x40)
   597 |     |             mstore(0x40, 0x80)
   598 |     |             writeString(0x60, p0)
   599 |     |             writeString(0xa0, p1)
   600 |     |         }
   601 |     |         _sendLogPayload(0x1c, 0xc4);
   602 |     |         assembly {
   603 |     |             mstore(0x00, m0)
   604 |     |             mstore(0x20, m1)
   605 |     |             mstore(0x40, m2)
   606 |     |             mstore(0x60, m3)
   607 |     |             mstore(0x80, m4)
   608 |     |             mstore(0xa0, m5)
   609 |     |             mstore(0xc0, m6)
   610 |     |         }
   611 |     |     }
   612 |     | 
   613 |     |     function log(address p0, address p1, address p2) internal pure {
   614 |     |         bytes32 m0;
   615 |     |         bytes32 m1;
   616 |     |         bytes32 m2;
   617 |     |         bytes32 m3;
   618 |     |         assembly {
   619 |     |             m0 := mload(0x00)
   620 |     |             m1 := mload(0x20)
   621 |     |             m2 := mload(0x40)
   622 |     |             m3 := mload(0x60)
   623 |     |             // Selector of `log(address,address,address)`.
   624 |     |             mstore(0x00, 0x018c84c2)
   625 |     |             mstore(0x20, p0)
   626 |     |             mstore(0x40, p1)
   627 |     |             mstore(0x60, p2)
   628 |     |         }
   629 |     |         _sendLogPayload(0x1c, 0x64);
   630 |     |         assembly {
   631 |     |             mstore(0x00, m0)
   632 |     |             mstore(0x20, m1)
   633 |     |             mstore(0x40, m2)
   634 |     |             mstore(0x60, m3)
   635 |     |         }
   636 |     |     }
   637 |     | 
   638 |     |     function log(address p0, address p1, bool p2) internal pure {
   639 |     |         bytes32 m0;
   640 |     |         bytes32 m1;
   641 |     |         bytes32 m2;
   642 |     |         bytes32 m3;
   643 |     |         assembly {
   644 |     |             m0 := mload(0x00)
   645 |     |             m1 := mload(0x20)
   646 |     |             m2 := mload(0x40)
   647 |     |             m3 := mload(0x60)
   648 |     |             // Selector of `log(address,address,bool)`.
   649 |     |             mstore(0x00, 0xf2a66286)
   650 |     |             mstore(0x20, p0)
   651 |     |             mstore(0x40, p1)
   652 |     |             mstore(0x60, p2)
   653 |     |         }
   654 |     |         _sendLogPayload(0x1c, 0x64);
   655 |     |         assembly {
   656 |     |             mstore(0x00, m0)
   657 |     |             mstore(0x20, m1)
   658 |     |             mstore(0x40, m2)
   659 |     |             mstore(0x60, m3)
   660 |     |         }
   661 |     |     }
   662 |     | 
   663 |     |     function log(address p0, address p1, uint256 p2) internal pure {
   664 |     |         bytes32 m0;
   665 |     |         bytes32 m1;
   666 |     |         bytes32 m2;
   667 |     |         bytes32 m3;
   668 |     |         assembly {
   669 |     |             m0 := mload(0x00)
   670 |     |             m1 := mload(0x20)
   671 |     |             m2 := mload(0x40)
   672 |     |             m3 := mload(0x60)
   673 |     |             // Selector of `log(address,address,uint256)`.
   674 |     |             mstore(0x00, 0x17fe6185)
   675 |     |             mstore(0x20, p0)
   676 |     |             mstore(0x40, p1)
   677 |     |             mstore(0x60, p2)
   678 |     |         }
   679 |     |         _sendLogPayload(0x1c, 0x64);
   680 |     |         assembly {
   681 |     |             mstore(0x00, m0)
   682 |     |             mstore(0x20, m1)
   683 |     |             mstore(0x40, m2)
   684 |     |             mstore(0x60, m3)
   685 |     |         }
   686 |     |     }
   687 |     | 
   688 |     |     function log(address p0, address p1, bytes32 p2) internal pure {
   689 |     |         bytes32 m0;
   690 |     |         bytes32 m1;
   691 |     |         bytes32 m2;
   692 |     |         bytes32 m3;
   693 |     |         bytes32 m4;
   694 |     |         bytes32 m5;
   695 |     |         assembly {
   696 |     |             function writeString(pos, w) {
   697 |     |                 let length := 0
   698 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   699 |     |                 mstore(pos, length)
   700 |     |                 let shift := sub(256, shl(3, length))
   701 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   702 |     |             }
   703 |     |             m0 := mload(0x00)
   704 |     |             m1 := mload(0x20)
   705 |     |             m2 := mload(0x40)
   706 |     |             m3 := mload(0x60)
   707 |     |             m4 := mload(0x80)
   708 |     |             m5 := mload(0xa0)
   709 |     |             // Selector of `log(address,address,string)`.
   710 |     |             mstore(0x00, 0x007150be)
   711 |     |             mstore(0x20, p0)
   712 |     |             mstore(0x40, p1)
   713 |     |             mstore(0x60, 0x60)
   714 |     |             writeString(0x80, p2)
   715 |     |         }
   716 |     |         _sendLogPayload(0x1c, 0xa4);
   717 |     |         assembly {
   718 |     |             mstore(0x00, m0)
   719 |     |             mstore(0x20, m1)
   720 |     |             mstore(0x40, m2)
   721 |     |             mstore(0x60, m3)
   722 |     |             mstore(0x80, m4)
   723 |     |             mstore(0xa0, m5)
   724 |     |         }
   725 |     |     }
   726 |     | 
   727 |     |     function log(address p0, bool p1, address p2) internal pure {
   728 |     |         bytes32 m0;
   729 |     |         bytes32 m1;
   730 |     |         bytes32 m2;
   731 |     |         bytes32 m3;
   732 |     |         assembly {
   733 |     |             m0 := mload(0x00)
   734 |     |             m1 := mload(0x20)
   735 |     |             m2 := mload(0x40)
   736 |     |             m3 := mload(0x60)
   737 |     |             // Selector of `log(address,bool,address)`.
   738 |     |             mstore(0x00, 0xf11699ed)
   739 |     |             mstore(0x20, p0)
   740 |     |             mstore(0x40, p1)
   741 |     |             mstore(0x60, p2)
   742 |     |         }
   743 |     |         _sendLogPayload(0x1c, 0x64);
   744 |     |         assembly {
   745 |     |             mstore(0x00, m0)
   746 |     |             mstore(0x20, m1)
   747 |     |             mstore(0x40, m2)
   748 |     |             mstore(0x60, m3)
   749 |     |         }
   750 |     |     }
   751 |     | 
   752 |     |     function log(address p0, bool p1, bool p2) internal pure {
   753 |     |         bytes32 m0;
   754 |     |         bytes32 m1;
   755 |     |         bytes32 m2;
   756 |     |         bytes32 m3;
   757 |     |         assembly {
   758 |     |             m0 := mload(0x00)
   759 |     |             m1 := mload(0x20)
   760 |     |             m2 := mload(0x40)
   761 |     |             m3 := mload(0x60)
   762 |     |             // Selector of `log(address,bool,bool)`.
   763 |     |             mstore(0x00, 0xeb830c92)
   764 |     |             mstore(0x20, p0)
   765 |     |             mstore(0x40, p1)
   766 |     |             mstore(0x60, p2)
   767 |     |         }
   768 |     |         _sendLogPayload(0x1c, 0x64);
   769 |     |         assembly {
   770 |     |             mstore(0x00, m0)
   771 |     |             mstore(0x20, m1)
   772 |     |             mstore(0x40, m2)
   773 |     |             mstore(0x60, m3)
   774 |     |         }
   775 |     |     }
   776 |     | 
   777 |     |     function log(address p0, bool p1, uint256 p2) internal pure {
   778 |     |         bytes32 m0;
   779 |     |         bytes32 m1;
   780 |     |         bytes32 m2;
   781 |     |         bytes32 m3;
   782 |     |         assembly {
   783 |     |             m0 := mload(0x00)
   784 |     |             m1 := mload(0x20)
   785 |     |             m2 := mload(0x40)
   786 |     |             m3 := mload(0x60)
   787 |     |             // Selector of `log(address,bool,uint256)`.
   788 |     |             mstore(0x00, 0x9c4f99fb)
   789 |     |             mstore(0x20, p0)
   790 |     |             mstore(0x40, p1)
   791 |     |             mstore(0x60, p2)
   792 |     |         }
   793 |     |         _sendLogPayload(0x1c, 0x64);
   794 |     |         assembly {
   795 |     |             mstore(0x00, m0)
   796 |     |             mstore(0x20, m1)
   797 |     |             mstore(0x40, m2)
   798 |     |             mstore(0x60, m3)
   799 |     |         }
   800 |     |     }
   801 |     | 
   802 |     |     function log(address p0, bool p1, bytes32 p2) internal pure {
   803 |     |         bytes32 m0;
   804 |     |         bytes32 m1;
   805 |     |         bytes32 m2;
   806 |     |         bytes32 m3;
   807 |     |         bytes32 m4;
   808 |     |         bytes32 m5;
   809 |     |         assembly {
   810 |     |             function writeString(pos, w) {
   811 |     |                 let length := 0
   812 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   813 |     |                 mstore(pos, length)
   814 |     |                 let shift := sub(256, shl(3, length))
   815 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   816 |     |             }
   817 |     |             m0 := mload(0x00)
   818 |     |             m1 := mload(0x20)
   819 |     |             m2 := mload(0x40)
   820 |     |             m3 := mload(0x60)
   821 |     |             m4 := mload(0x80)
   822 |     |             m5 := mload(0xa0)
   823 |     |             // Selector of `log(address,bool,string)`.
   824 |     |             mstore(0x00, 0x212255cc)
   825 |     |             mstore(0x20, p0)
   826 |     |             mstore(0x40, p1)
   827 |     |             mstore(0x60, 0x60)
   828 |     |             writeString(0x80, p2)
   829 |     |         }
   830 |     |         _sendLogPayload(0x1c, 0xa4);
   831 |     |         assembly {
   832 |     |             mstore(0x00, m0)
   833 |     |             mstore(0x20, m1)
   834 |     |             mstore(0x40, m2)
   835 |     |             mstore(0x60, m3)
   836 |     |             mstore(0x80, m4)
   837 |     |             mstore(0xa0, m5)
   838 |     |         }
   839 |     |     }
   840 |     | 
   841 |     |     function log(address p0, uint256 p1, address p2) internal pure {
   842 |     |         bytes32 m0;
   843 |     |         bytes32 m1;
   844 |     |         bytes32 m2;
   845 |     |         bytes32 m3;
   846 |     |         assembly {
   847 |     |             m0 := mload(0x00)
   848 |     |             m1 := mload(0x20)
   849 |     |             m2 := mload(0x40)
   850 |     |             m3 := mload(0x60)
   851 |     |             // Selector of `log(address,uint256,address)`.
   852 |     |             mstore(0x00, 0x7bc0d848)
   853 |     |             mstore(0x20, p0)
   854 |     |             mstore(0x40, p1)
   855 |     |             mstore(0x60, p2)
   856 |     |         }
   857 |     |         _sendLogPayload(0x1c, 0x64);
   858 |     |         assembly {
   859 |     |             mstore(0x00, m0)
   860 |     |             mstore(0x20, m1)
   861 |     |             mstore(0x40, m2)
   862 |     |             mstore(0x60, m3)
   863 |     |         }
   864 |     |     }
   865 |     | 
   866 |     |     function log(address p0, uint256 p1, bool p2) internal pure {
   867 |     |         bytes32 m0;
   868 |     |         bytes32 m1;
   869 |     |         bytes32 m2;
   870 |     |         bytes32 m3;
   871 |     |         assembly {
   872 |     |             m0 := mload(0x00)
   873 |     |             m1 := mload(0x20)
   874 |     |             m2 := mload(0x40)
   875 |     |             m3 := mload(0x60)
   876 |     |             // Selector of `log(address,uint256,bool)`.
   877 |     |             mstore(0x00, 0x678209a8)
   878 |     |             mstore(0x20, p0)
   879 |     |             mstore(0x40, p1)
   880 |     |             mstore(0x60, p2)
   881 |     |         }
   882 |     |         _sendLogPayload(0x1c, 0x64);
   883 |     |         assembly {
   884 |     |             mstore(0x00, m0)
   885 |     |             mstore(0x20, m1)
   886 |     |             mstore(0x40, m2)
   887 |     |             mstore(0x60, m3)
   888 |     |         }
   889 |     |     }
   890 |     | 
   891 |     |     function log(address p0, uint256 p1, uint256 p2) internal pure {
   892 |     |         bytes32 m0;
   893 |     |         bytes32 m1;
   894 |     |         bytes32 m2;
   895 |     |         bytes32 m3;
   896 |     |         assembly {
   897 |     |             m0 := mload(0x00)
   898 |     |             m1 := mload(0x20)
   899 |     |             m2 := mload(0x40)
   900 |     |             m3 := mload(0x60)
   901 |     |             // Selector of `log(address,uint256,uint256)`.
   902 |     |             mstore(0x00, 0xb69bcaf6)
   903 |     |             mstore(0x20, p0)
   904 |     |             mstore(0x40, p1)
   905 |     |             mstore(0x60, p2)
   906 |     |         }
   907 |     |         _sendLogPayload(0x1c, 0x64);
   908 |     |         assembly {
   909 |     |             mstore(0x00, m0)
   910 |     |             mstore(0x20, m1)
   911 |     |             mstore(0x40, m2)
   912 |     |             mstore(0x60, m3)
   913 |     |         }
   914 |     |     }
   915 |     | 
   916 |     |     function log(address p0, uint256 p1, bytes32 p2) internal pure {
   917 |     |         bytes32 m0;
   918 |     |         bytes32 m1;
   919 |     |         bytes32 m2;
   920 |     |         bytes32 m3;
   921 |     |         bytes32 m4;
   922 |     |         bytes32 m5;
   923 |     |         assembly {
   924 |     |             function writeString(pos, w) {
   925 |     |                 let length := 0
   926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   927 |     |                 mstore(pos, length)
   928 |     |                 let shift := sub(256, shl(3, length))
   929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   930 |     |             }
   931 |     |             m0 := mload(0x00)
   932 |     |             m1 := mload(0x20)
   933 |     |             m2 := mload(0x40)
   934 |     |             m3 := mload(0x60)
   935 |     |             m4 := mload(0x80)
   936 |     |             m5 := mload(0xa0)
   937 |     |             // Selector of `log(address,uint256,string)`.
   938 |     |             mstore(0x00, 0xa1f2e8aa)
   939 |     |             mstore(0x20, p0)
   940 |     |             mstore(0x40, p1)
   941 |     |             mstore(0x60, 0x60)
   942 |     |             writeString(0x80, p2)
   943 |     |         }
   944 |     |         _sendLogPayload(0x1c, 0xa4);
   945 |     |         assembly {
   946 |     |             mstore(0x00, m0)
   947 |     |             mstore(0x20, m1)
   948 |     |             mstore(0x40, m2)
   949 |     |             mstore(0x60, m3)
   950 |     |             mstore(0x80, m4)
   951 |     |             mstore(0xa0, m5)
   952 |     |         }
   953 |     |     }
   954 |     | 
   955 |     |     function log(address p0, bytes32 p1, address p2) internal pure {
   956 |     |         bytes32 m0;
   957 |     |         bytes32 m1;
   958 |     |         bytes32 m2;
   959 |     |         bytes32 m3;
   960 |     |         bytes32 m4;
   961 |     |         bytes32 m5;
   962 |     |         assembly {
   963 |     |             function writeString(pos, w) {
   964 |     |                 let length := 0
   965 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
   966 |     |                 mstore(pos, length)
   967 |     |                 let shift := sub(256, shl(3, length))
   968 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
   969 |     |             }
   970 |     |             m0 := mload(0x00)
   971 |     |             m1 := mload(0x20)
   972 |     |             m2 := mload(0x40)
   973 |     |             m3 := mload(0x60)
   974 |     |             m4 := mload(0x80)
   975 |     |             m5 := mload(0xa0)
   976 |     |             // Selector of `log(address,string,address)`.
   977 |     |             mstore(0x00, 0xf08744e8)
   978 |     |             mstore(0x20, p0)
   979 |     |             mstore(0x40, 0x60)
   980 |     |             mstore(0x60, p2)
   981 |     |             writeString(0x80, p1)
   982 |     |         }
   983 |     |         _sendLogPayload(0x1c, 0xa4);
   984 |     |         assembly {
   985 |     |             mstore(0x00, m0)
   986 |     |             mstore(0x20, m1)
   987 |     |             mstore(0x40, m2)
   988 |     |             mstore(0x60, m3)
   989 |     |             mstore(0x80, m4)
   990 |     |             mstore(0xa0, m5)
   991 |     |         }
   992 |     |     }
   993 |     | 
   994 |     |     function log(address p0, bytes32 p1, bool p2) internal pure {
   995 |     |         bytes32 m0;
   996 |     |         bytes32 m1;
   997 |     |         bytes32 m2;
   998 |     |         bytes32 m3;
   999 |     |         bytes32 m4;
  1000 |     |         bytes32 m5;
  1001 |     |         assembly {
  1002 |     |             function writeString(pos, w) {
  1003 |     |                 let length := 0
  1004 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1005 |     |                 mstore(pos, length)
  1006 |     |                 let shift := sub(256, shl(3, length))
  1007 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1008 |     |             }
  1009 |     |             m0 := mload(0x00)
  1010 |     |             m1 := mload(0x20)
  1011 |     |             m2 := mload(0x40)
  1012 |     |             m3 := mload(0x60)
  1013 |     |             m4 := mload(0x80)
  1014 |     |             m5 := mload(0xa0)
  1015 |     |             // Selector of `log(address,string,bool)`.
  1016 |     |             mstore(0x00, 0xcf020fb1)
  1017 |     |             mstore(0x20, p0)
  1018 |     |             mstore(0x40, 0x60)
  1019 |     |             mstore(0x60, p2)
  1020 |     |             writeString(0x80, p1)
  1021 |     |         }
  1022 |     |         _sendLogPayload(0x1c, 0xa4);
  1023 |     |         assembly {
  1024 |     |             mstore(0x00, m0)
  1025 |     |             mstore(0x20, m1)
  1026 |     |             mstore(0x40, m2)
  1027 |     |             mstore(0x60, m3)
  1028 |     |             mstore(0x80, m4)
  1029 |     |             mstore(0xa0, m5)
  1030 |     |         }
  1031 |     |     }
  1032 |     | 
  1033 |     |     function log(address p0, bytes32 p1, uint256 p2) internal pure {
  1034 |     |         bytes32 m0;
  1035 |     |         bytes32 m1;
  1036 |     |         bytes32 m2;
  1037 |     |         bytes32 m3;
  1038 |     |         bytes32 m4;
  1039 |     |         bytes32 m5;
  1040 |     |         assembly {
  1041 |     |             function writeString(pos, w) {
  1042 |     |                 let length := 0
  1043 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1044 |     |                 mstore(pos, length)
  1045 |     |                 let shift := sub(256, shl(3, length))
  1046 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1047 |     |             }
  1048 |     |             m0 := mload(0x00)
  1049 |     |             m1 := mload(0x20)
  1050 |     |             m2 := mload(0x40)
  1051 |     |             m3 := mload(0x60)
  1052 |     |             m4 := mload(0x80)
  1053 |     |             m5 := mload(0xa0)
  1054 |     |             // Selector of `log(address,string,uint256)`.
  1055 |     |             mstore(0x00, 0x67dd6ff1)
  1056 |     |             mstore(0x20, p0)
  1057 |     |             mstore(0x40, 0x60)
  1058 |     |             mstore(0x60, p2)
  1059 |     |             writeString(0x80, p1)
  1060 |     |         }
  1061 |     |         _sendLogPayload(0x1c, 0xa4);
  1062 |     |         assembly {
  1063 |     |             mstore(0x00, m0)
  1064 |     |             mstore(0x20, m1)
  1065 |     |             mstore(0x40, m2)
  1066 |     |             mstore(0x60, m3)
  1067 |     |             mstore(0x80, m4)
  1068 |     |             mstore(0xa0, m5)
  1069 |     |         }
  1070 |     |     }
  1071 |     | 
  1072 |     |     function log(address p0, bytes32 p1, bytes32 p2) internal pure {
  1073 |     |         bytes32 m0;
  1074 |     |         bytes32 m1;
  1075 |     |         bytes32 m2;
  1076 |     |         bytes32 m3;
  1077 |     |         bytes32 m4;
  1078 |     |         bytes32 m5;
  1079 |     |         bytes32 m6;
  1080 |     |         bytes32 m7;
  1081 |     |         assembly {
  1082 |     |             function writeString(pos, w) {
  1083 |     |                 let length := 0
  1084 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1085 |     |                 mstore(pos, length)
  1086 |     |                 let shift := sub(256, shl(3, length))
  1087 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1088 |     |             }
  1089 |     |             m0 := mload(0x00)
  1090 |     |             m1 := mload(0x20)
  1091 |     |             m2 := mload(0x40)
  1092 |     |             m3 := mload(0x60)
  1093 |     |             m4 := mload(0x80)
  1094 |     |             m5 := mload(0xa0)
  1095 |     |             m6 := mload(0xc0)
  1096 |     |             m7 := mload(0xe0)
  1097 |     |             // Selector of `log(address,string,string)`.
  1098 |     |             mstore(0x00, 0xfb772265)
  1099 |     |             mstore(0x20, p0)
  1100 |     |             mstore(0x40, 0x60)
  1101 |     |             mstore(0x60, 0xa0)
  1102 |     |             writeString(0x80, p1)
  1103 |     |             writeString(0xc0, p2)
  1104 |     |         }
  1105 |     |         _sendLogPayload(0x1c, 0xe4);
  1106 |     |         assembly {
  1107 |     |             mstore(0x00, m0)
  1108 |     |             mstore(0x20, m1)
  1109 |     |             mstore(0x40, m2)
  1110 |     |             mstore(0x60, m3)
  1111 |     |             mstore(0x80, m4)
  1112 |     |             mstore(0xa0, m5)
  1113 |     |             mstore(0xc0, m6)
  1114 |     |             mstore(0xe0, m7)
  1115 |     |         }
  1116 |     |     }
  1117 |     | 
  1118 |     |     function log(bool p0, address p1, address p2) internal pure {
  1119 |     |         bytes32 m0;
  1120 |     |         bytes32 m1;
  1121 |     |         bytes32 m2;
  1122 |     |         bytes32 m3;
  1123 |     |         assembly {
  1124 |     |             m0 := mload(0x00)
  1125 |     |             m1 := mload(0x20)
  1126 |     |             m2 := mload(0x40)
  1127 |     |             m3 := mload(0x60)
  1128 |     |             // Selector of `log(bool,address,address)`.
  1129 |     |             mstore(0x00, 0xd2763667)
  1130 |     |             mstore(0x20, p0)
  1131 |     |             mstore(0x40, p1)
  1132 |     |             mstore(0x60, p2)
  1133 |     |         }
  1134 |     |         _sendLogPayload(0x1c, 0x64);
  1135 |     |         assembly {
  1136 |     |             mstore(0x00, m0)
  1137 |     |             mstore(0x20, m1)
  1138 |     |             mstore(0x40, m2)
  1139 |     |             mstore(0x60, m3)
  1140 |     |         }
  1141 |     |     }
  1142 |     | 
  1143 |     |     function log(bool p0, address p1, bool p2) internal pure {
  1144 |     |         bytes32 m0;
  1145 |     |         bytes32 m1;
  1146 |     |         bytes32 m2;
  1147 |     |         bytes32 m3;
  1148 |     |         assembly {
  1149 |     |             m0 := mload(0x00)
  1150 |     |             m1 := mload(0x20)
  1151 |     |             m2 := mload(0x40)
  1152 |     |             m3 := mload(0x60)
  1153 |     |             // Selector of `log(bool,address,bool)`.
  1154 |     |             mstore(0x00, 0x18c9c746)
  1155 |     |             mstore(0x20, p0)
  1156 |     |             mstore(0x40, p1)
  1157 |     |             mstore(0x60, p2)
  1158 |     |         }
  1159 |     |         _sendLogPayload(0x1c, 0x64);
  1160 |     |         assembly {
  1161 |     |             mstore(0x00, m0)
  1162 |     |             mstore(0x20, m1)
  1163 |     |             mstore(0x40, m2)
  1164 |     |             mstore(0x60, m3)
  1165 |     |         }
  1166 |     |     }
  1167 |     | 
  1168 |     |     function log(bool p0, address p1, uint256 p2) internal pure {
  1169 |     |         bytes32 m0;
  1170 |     |         bytes32 m1;
  1171 |     |         bytes32 m2;
  1172 |     |         bytes32 m3;
  1173 |     |         assembly {
  1174 |     |             m0 := mload(0x00)
  1175 |     |             m1 := mload(0x20)
  1176 |     |             m2 := mload(0x40)
  1177 |     |             m3 := mload(0x60)
  1178 |     |             // Selector of `log(bool,address,uint256)`.
  1179 |     |             mstore(0x00, 0x5f7b9afb)
  1180 |     |             mstore(0x20, p0)
  1181 |     |             mstore(0x40, p1)
  1182 |     |             mstore(0x60, p2)
  1183 |     |         }
  1184 |     |         _sendLogPayload(0x1c, 0x64);
  1185 |     |         assembly {
  1186 |     |             mstore(0x00, m0)
  1187 |     |             mstore(0x20, m1)
  1188 |     |             mstore(0x40, m2)
  1189 |     |             mstore(0x60, m3)
  1190 |     |         }
  1191 |     |     }
  1192 |     | 
  1193 |     |     function log(bool p0, address p1, bytes32 p2) internal pure {
  1194 |     |         bytes32 m0;
  1195 |     |         bytes32 m1;
  1196 |     |         bytes32 m2;
  1197 |     |         bytes32 m3;
  1198 |     |         bytes32 m4;
  1199 |     |         bytes32 m5;
  1200 |     |         assembly {
  1201 |     |             function writeString(pos, w) {
  1202 |     |                 let length := 0
  1203 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1204 |     |                 mstore(pos, length)
  1205 |     |                 let shift := sub(256, shl(3, length))
  1206 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1207 |     |             }
  1208 |     |             m0 := mload(0x00)
  1209 |     |             m1 := mload(0x20)
  1210 |     |             m2 := mload(0x40)
  1211 |     |             m3 := mload(0x60)
  1212 |     |             m4 := mload(0x80)
  1213 |     |             m5 := mload(0xa0)
  1214 |     |             // Selector of `log(bool,address,string)`.
  1215 |     |             mstore(0x00, 0xde9a9270)
  1216 |     |             mstore(0x20, p0)
  1217 |     |             mstore(0x40, p1)
  1218 |     |             mstore(0x60, 0x60)
  1219 |     |             writeString(0x80, p2)
  1220 |     |         }
  1221 |     |         _sendLogPayload(0x1c, 0xa4);
  1222 |     |         assembly {
  1223 |     |             mstore(0x00, m0)
  1224 |     |             mstore(0x20, m1)
  1225 |     |             mstore(0x40, m2)
  1226 |     |             mstore(0x60, m3)
  1227 |     |             mstore(0x80, m4)
  1228 |     |             mstore(0xa0, m5)
  1229 |     |         }
  1230 |     |     }
  1231 |     | 
  1232 |     |     function log(bool p0, bool p1, address p2) internal pure {
  1233 |     |         bytes32 m0;
  1234 |     |         bytes32 m1;
  1235 |     |         bytes32 m2;
  1236 |     |         bytes32 m3;
  1237 |     |         assembly {
  1238 |     |             m0 := mload(0x00)
  1239 |     |             m1 := mload(0x20)
  1240 |     |             m2 := mload(0x40)
  1241 |     |             m3 := mload(0x60)
  1242 |     |             // Selector of `log(bool,bool,address)`.
  1243 |     |             mstore(0x00, 0x1078f68d)
  1244 |     |             mstore(0x20, p0)
  1245 |     |             mstore(0x40, p1)
  1246 |     |             mstore(0x60, p2)
  1247 |     |         }
  1248 |     |         _sendLogPayload(0x1c, 0x64);
  1249 |     |         assembly {
  1250 |     |             mstore(0x00, m0)
  1251 |     |             mstore(0x20, m1)
  1252 |     |             mstore(0x40, m2)
  1253 |     |             mstore(0x60, m3)
  1254 |     |         }
  1255 |     |     }
  1256 |     | 
  1257 |     |     function log(bool p0, bool p1, bool p2) internal pure {
  1258 |     |         bytes32 m0;
  1259 |     |         bytes32 m1;
  1260 |     |         bytes32 m2;
  1261 |     |         bytes32 m3;
  1262 |     |         assembly {
  1263 |     |             m0 := mload(0x00)
  1264 |     |             m1 := mload(0x20)
  1265 |     |             m2 := mload(0x40)
  1266 |     |             m3 := mload(0x60)
  1267 |     |             // Selector of `log(bool,bool,bool)`.
  1268 |     |             mstore(0x00, 0x50709698)
  1269 |     |             mstore(0x20, p0)
  1270 |     |             mstore(0x40, p1)
  1271 |     |             mstore(0x60, p2)
  1272 |     |         }
  1273 |     |         _sendLogPayload(0x1c, 0x64);
  1274 |     |         assembly {
  1275 |     |             mstore(0x00, m0)
  1276 |     |             mstore(0x20, m1)
  1277 |     |             mstore(0x40, m2)
  1278 |     |             mstore(0x60, m3)
  1279 |     |         }
  1280 |     |     }
  1281 |     | 
  1282 |     |     function log(bool p0, bool p1, uint256 p2) internal pure {
  1283 |     |         bytes32 m0;
  1284 |     |         bytes32 m1;
  1285 |     |         bytes32 m2;
  1286 |     |         bytes32 m3;
  1287 |     |         assembly {
  1288 |     |             m0 := mload(0x00)
  1289 |     |             m1 := mload(0x20)
  1290 |     |             m2 := mload(0x40)
  1291 |     |             m3 := mload(0x60)
  1292 |     |             // Selector of `log(bool,bool,uint256)`.
  1293 |     |             mstore(0x00, 0x12f21602)
  1294 |     |             mstore(0x20, p0)
  1295 |     |             mstore(0x40, p1)
  1296 |     |             mstore(0x60, p2)
  1297 |     |         }
  1298 |     |         _sendLogPayload(0x1c, 0x64);
  1299 |     |         assembly {
  1300 |     |             mstore(0x00, m0)
  1301 |     |             mstore(0x20, m1)
  1302 |     |             mstore(0x40, m2)
  1303 |     |             mstore(0x60, m3)
  1304 |     |         }
  1305 |     |     }
  1306 |     | 
  1307 |     |     function log(bool p0, bool p1, bytes32 p2) internal pure {
  1308 |     |         bytes32 m0;
  1309 |     |         bytes32 m1;
  1310 |     |         bytes32 m2;
  1311 |     |         bytes32 m3;
  1312 |     |         bytes32 m4;
  1313 |     |         bytes32 m5;
  1314 |     |         assembly {
  1315 |     |             function writeString(pos, w) {
  1316 |     |                 let length := 0
  1317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1318 |     |                 mstore(pos, length)
  1319 |     |                 let shift := sub(256, shl(3, length))
  1320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1321 |     |             }
  1322 |     |             m0 := mload(0x00)
  1323 |     |             m1 := mload(0x20)
  1324 |     |             m2 := mload(0x40)
  1325 |     |             m3 := mload(0x60)
  1326 |     |             m4 := mload(0x80)
  1327 |     |             m5 := mload(0xa0)
  1328 |     |             // Selector of `log(bool,bool,string)`.
  1329 |     |             mstore(0x00, 0x2555fa46)
  1330 |     |             mstore(0x20, p0)
  1331 |     |             mstore(0x40, p1)
  1332 |     |             mstore(0x60, 0x60)
  1333 |     |             writeString(0x80, p2)
  1334 |     |         }
  1335 |     |         _sendLogPayload(0x1c, 0xa4);
  1336 |     |         assembly {
  1337 |     |             mstore(0x00, m0)
  1338 |     |             mstore(0x20, m1)
  1339 |     |             mstore(0x40, m2)
  1340 |     |             mstore(0x60, m3)
  1341 |     |             mstore(0x80, m4)
  1342 |     |             mstore(0xa0, m5)
  1343 |     |         }
  1344 |     |     }
  1345 |     | 
  1346 |     |     function log(bool p0, uint256 p1, address p2) internal pure {
  1347 |     |         bytes32 m0;
  1348 |     |         bytes32 m1;
  1349 |     |         bytes32 m2;
  1350 |     |         bytes32 m3;
  1351 |     |         assembly {
  1352 |     |             m0 := mload(0x00)
  1353 |     |             m1 := mload(0x20)
  1354 |     |             m2 := mload(0x40)
  1355 |     |             m3 := mload(0x60)
  1356 |     |             // Selector of `log(bool,uint256,address)`.
  1357 |     |             mstore(0x00, 0x088ef9d2)
  1358 |     |             mstore(0x20, p0)
  1359 |     |             mstore(0x40, p1)
  1360 |     |             mstore(0x60, p2)
  1361 |     |         }
  1362 |     |         _sendLogPayload(0x1c, 0x64);
  1363 |     |         assembly {
  1364 |     |             mstore(0x00, m0)
  1365 |     |             mstore(0x20, m1)
  1366 |     |             mstore(0x40, m2)
  1367 |     |             mstore(0x60, m3)
  1368 |     |         }
  1369 |     |     }
  1370 |     | 
  1371 |     |     function log(bool p0, uint256 p1, bool p2) internal pure {
  1372 |     |         bytes32 m0;
  1373 |     |         bytes32 m1;
  1374 |     |         bytes32 m2;
  1375 |     |         bytes32 m3;
  1376 |     |         assembly {
  1377 |     |             m0 := mload(0x00)
  1378 |     |             m1 := mload(0x20)
  1379 |     |             m2 := mload(0x40)
  1380 |     |             m3 := mload(0x60)
  1381 |     |             // Selector of `log(bool,uint256,bool)`.
  1382 |     |             mstore(0x00, 0xe8defba9)
  1383 |     |             mstore(0x20, p0)
  1384 |     |             mstore(0x40, p1)
  1385 |     |             mstore(0x60, p2)
  1386 |     |         }
  1387 |     |         _sendLogPayload(0x1c, 0x64);
  1388 |     |         assembly {
  1389 |     |             mstore(0x00, m0)
  1390 |     |             mstore(0x20, m1)
  1391 |     |             mstore(0x40, m2)
  1392 |     |             mstore(0x60, m3)
  1393 |     |         }
  1394 |     |     }
  1395 |     | 
  1396 |     |     function log(bool p0, uint256 p1, uint256 p2) internal pure {
  1397 |     |         bytes32 m0;
  1398 |     |         bytes32 m1;
  1399 |     |         bytes32 m2;
  1400 |     |         bytes32 m3;
  1401 |     |         assembly {
  1402 |     |             m0 := mload(0x00)
  1403 |     |             m1 := mload(0x20)
  1404 |     |             m2 := mload(0x40)
  1405 |     |             m3 := mload(0x60)
  1406 |     |             // Selector of `log(bool,uint256,uint256)`.
  1407 |     |             mstore(0x00, 0x37103367)
  1408 |     |             mstore(0x20, p0)
  1409 |     |             mstore(0x40, p1)
  1410 |     |             mstore(0x60, p2)
  1411 |     |         }
  1412 |     |         _sendLogPayload(0x1c, 0x64);
  1413 |     |         assembly {
  1414 |     |             mstore(0x00, m0)
  1415 |     |             mstore(0x20, m1)
  1416 |     |             mstore(0x40, m2)
  1417 |     |             mstore(0x60, m3)
  1418 |     |         }
  1419 |     |     }
  1420 |     | 
  1421 |     |     function log(bool p0, uint256 p1, bytes32 p2) internal pure {
  1422 |     |         bytes32 m0;
  1423 |     |         bytes32 m1;
  1424 |     |         bytes32 m2;
  1425 |     |         bytes32 m3;
  1426 |     |         bytes32 m4;
  1427 |     |         bytes32 m5;
  1428 |     |         assembly {
  1429 |     |             function writeString(pos, w) {
  1430 |     |                 let length := 0
  1431 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1432 |     |                 mstore(pos, length)
  1433 |     |                 let shift := sub(256, shl(3, length))
  1434 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1435 |     |             }
  1436 |     |             m0 := mload(0x00)
  1437 |     |             m1 := mload(0x20)
  1438 |     |             m2 := mload(0x40)
  1439 |     |             m3 := mload(0x60)
  1440 |     |             m4 := mload(0x80)
  1441 |     |             m5 := mload(0xa0)
  1442 |     |             // Selector of `log(bool,uint256,string)`.
  1443 |     |             mstore(0x00, 0xc3fc3970)
  1444 |     |             mstore(0x20, p0)
  1445 |     |             mstore(0x40, p1)
  1446 |     |             mstore(0x60, 0x60)
  1447 |     |             writeString(0x80, p2)
  1448 |     |         }
  1449 |     |         _sendLogPayload(0x1c, 0xa4);
  1450 |     |         assembly {
  1451 |     |             mstore(0x00, m0)
  1452 |     |             mstore(0x20, m1)
  1453 |     |             mstore(0x40, m2)
  1454 |     |             mstore(0x60, m3)
  1455 |     |             mstore(0x80, m4)
  1456 |     |             mstore(0xa0, m5)
  1457 |     |         }
  1458 |     |     }
  1459 |     | 
  1460 |     |     function log(bool p0, bytes32 p1, address p2) internal pure {
  1461 |     |         bytes32 m0;
  1462 |     |         bytes32 m1;
  1463 |     |         bytes32 m2;
  1464 |     |         bytes32 m3;
  1465 |     |         bytes32 m4;
  1466 |     |         bytes32 m5;
  1467 |     |         assembly {
  1468 |     |             function writeString(pos, w) {
  1469 |     |                 let length := 0
  1470 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1471 |     |                 mstore(pos, length)
  1472 |     |                 let shift := sub(256, shl(3, length))
  1473 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1474 |     |             }
  1475 |     |             m0 := mload(0x00)
  1476 |     |             m1 := mload(0x20)
  1477 |     |             m2 := mload(0x40)
  1478 |     |             m3 := mload(0x60)
  1479 |     |             m4 := mload(0x80)
  1480 |     |             m5 := mload(0xa0)
  1481 |     |             // Selector of `log(bool,string,address)`.
  1482 |     |             mstore(0x00, 0x9591b953)
  1483 |     |             mstore(0x20, p0)
  1484 |     |             mstore(0x40, 0x60)
  1485 |     |             mstore(0x60, p2)
  1486 |     |             writeString(0x80, p1)
  1487 |     |         }
  1488 |     |         _sendLogPayload(0x1c, 0xa4);
  1489 |     |         assembly {
  1490 |     |             mstore(0x00, m0)
  1491 |     |             mstore(0x20, m1)
  1492 |     |             mstore(0x40, m2)
  1493 |     |             mstore(0x60, m3)
  1494 |     |             mstore(0x80, m4)
  1495 |     |             mstore(0xa0, m5)
  1496 |     |         }
  1497 |     |     }
  1498 |     | 
  1499 |     |     function log(bool p0, bytes32 p1, bool p2) internal pure {
  1500 |     |         bytes32 m0;
  1501 |     |         bytes32 m1;
  1502 |     |         bytes32 m2;
  1503 |     |         bytes32 m3;
  1504 |     |         bytes32 m4;
  1505 |     |         bytes32 m5;
  1506 |     |         assembly {
  1507 |     |             function writeString(pos, w) {
  1508 |     |                 let length := 0
  1509 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1510 |     |                 mstore(pos, length)
  1511 |     |                 let shift := sub(256, shl(3, length))
  1512 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1513 |     |             }
  1514 |     |             m0 := mload(0x00)
  1515 |     |             m1 := mload(0x20)
  1516 |     |             m2 := mload(0x40)
  1517 |     |             m3 := mload(0x60)
  1518 |     |             m4 := mload(0x80)
  1519 |     |             m5 := mload(0xa0)
  1520 |     |             // Selector of `log(bool,string,bool)`.
  1521 |     |             mstore(0x00, 0xdbb4c247)
  1522 |     |             mstore(0x20, p0)
  1523 |     |             mstore(0x40, 0x60)
  1524 |     |             mstore(0x60, p2)
  1525 |     |             writeString(0x80, p1)
  1526 |     |         }
  1527 |     |         _sendLogPayload(0x1c, 0xa4);
  1528 |     |         assembly {
  1529 |     |             mstore(0x00, m0)
  1530 |     |             mstore(0x20, m1)
  1531 |     |             mstore(0x40, m2)
  1532 |     |             mstore(0x60, m3)
  1533 |     |             mstore(0x80, m4)
  1534 |     |             mstore(0xa0, m5)
  1535 |     |         }
  1536 |     |     }
  1537 |     | 
  1538 |     |     function log(bool p0, bytes32 p1, uint256 p2) internal pure {
  1539 |     |         bytes32 m0;
  1540 |     |         bytes32 m1;
  1541 |     |         bytes32 m2;
  1542 |     |         bytes32 m3;
  1543 |     |         bytes32 m4;
  1544 |     |         bytes32 m5;
  1545 |     |         assembly {
  1546 |     |             function writeString(pos, w) {
  1547 |     |                 let length := 0
  1548 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1549 |     |                 mstore(pos, length)
  1550 |     |                 let shift := sub(256, shl(3, length))
  1551 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1552 |     |             }
  1553 |     |             m0 := mload(0x00)
  1554 |     |             m1 := mload(0x20)
  1555 |     |             m2 := mload(0x40)
  1556 |     |             m3 := mload(0x60)
  1557 |     |             m4 := mload(0x80)
  1558 |     |             m5 := mload(0xa0)
  1559 |     |             // Selector of `log(bool,string,uint256)`.
  1560 |     |             mstore(0x00, 0x1093ee11)
  1561 |     |             mstore(0x20, p0)
  1562 |     |             mstore(0x40, 0x60)
  1563 |     |             mstore(0x60, p2)
  1564 |     |             writeString(0x80, p1)
  1565 |     |         }
  1566 |     |         _sendLogPayload(0x1c, 0xa4);
  1567 |     |         assembly {
  1568 |     |             mstore(0x00, m0)
  1569 |     |             mstore(0x20, m1)
  1570 |     |             mstore(0x40, m2)
  1571 |     |             mstore(0x60, m3)
  1572 |     |             mstore(0x80, m4)
  1573 |     |             mstore(0xa0, m5)
  1574 |     |         }
  1575 |     |     }
  1576 |     | 
  1577 |     |     function log(bool p0, bytes32 p1, bytes32 p2) internal pure {
  1578 |     |         bytes32 m0;
  1579 |     |         bytes32 m1;
  1580 |     |         bytes32 m2;
  1581 |     |         bytes32 m3;
  1582 |     |         bytes32 m4;
  1583 |     |         bytes32 m5;
  1584 |     |         bytes32 m6;
  1585 |     |         bytes32 m7;
  1586 |     |         assembly {
  1587 |     |             function writeString(pos, w) {
  1588 |     |                 let length := 0
  1589 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1590 |     |                 mstore(pos, length)
  1591 |     |                 let shift := sub(256, shl(3, length))
  1592 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1593 |     |             }
  1594 |     |             m0 := mload(0x00)
  1595 |     |             m1 := mload(0x20)
  1596 |     |             m2 := mload(0x40)
  1597 |     |             m3 := mload(0x60)
  1598 |     |             m4 := mload(0x80)
  1599 |     |             m5 := mload(0xa0)
  1600 |     |             m6 := mload(0xc0)
  1601 |     |             m7 := mload(0xe0)
  1602 |     |             // Selector of `log(bool,string,string)`.
  1603 |     |             mstore(0x00, 0xb076847f)
  1604 |     |             mstore(0x20, p0)
  1605 |     |             mstore(0x40, 0x60)
  1606 |     |             mstore(0x60, 0xa0)
  1607 |     |             writeString(0x80, p1)
  1608 |     |             writeString(0xc0, p2)
  1609 |     |         }
  1610 |     |         _sendLogPayload(0x1c, 0xe4);
  1611 |     |         assembly {
  1612 |     |             mstore(0x00, m0)
  1613 |     |             mstore(0x20, m1)
  1614 |     |             mstore(0x40, m2)
  1615 |     |             mstore(0x60, m3)
  1616 |     |             mstore(0x80, m4)
  1617 |     |             mstore(0xa0, m5)
  1618 |     |             mstore(0xc0, m6)
  1619 |     |             mstore(0xe0, m7)
  1620 |     |         }
  1621 |     |     }
  1622 |     | 
  1623 |     |     function log(uint256 p0, address p1, address p2) internal pure {
  1624 |     |         bytes32 m0;
  1625 |     |         bytes32 m1;
  1626 |     |         bytes32 m2;
  1627 |     |         bytes32 m3;
  1628 |     |         assembly {
  1629 |     |             m0 := mload(0x00)
  1630 |     |             m1 := mload(0x20)
  1631 |     |             m2 := mload(0x40)
  1632 |     |             m3 := mload(0x60)
  1633 |     |             // Selector of `log(uint256,address,address)`.
  1634 |     |             mstore(0x00, 0xbcfd9be0)
  1635 |     |             mstore(0x20, p0)
  1636 |     |             mstore(0x40, p1)
  1637 |     |             mstore(0x60, p2)
  1638 |     |         }
  1639 |     |         _sendLogPayload(0x1c, 0x64);
  1640 |     |         assembly {
  1641 |     |             mstore(0x00, m0)
  1642 |     |             mstore(0x20, m1)
  1643 |     |             mstore(0x40, m2)
  1644 |     |             mstore(0x60, m3)
  1645 |     |         }
  1646 |     |     }
  1647 |     | 
  1648 |     |     function log(uint256 p0, address p1, bool p2) internal pure {
  1649 |     |         bytes32 m0;
  1650 |     |         bytes32 m1;
  1651 |     |         bytes32 m2;
  1652 |     |         bytes32 m3;
  1653 |     |         assembly {
  1654 |     |             m0 := mload(0x00)
  1655 |     |             m1 := mload(0x20)
  1656 |     |             m2 := mload(0x40)
  1657 |     |             m3 := mload(0x60)
  1658 |     |             // Selector of `log(uint256,address,bool)`.
  1659 |     |             mstore(0x00, 0x9b6ec042)
  1660 |     |             mstore(0x20, p0)
  1661 |     |             mstore(0x40, p1)
  1662 |     |             mstore(0x60, p2)
  1663 |     |         }
  1664 |     |         _sendLogPayload(0x1c, 0x64);
  1665 |     |         assembly {
  1666 |     |             mstore(0x00, m0)
  1667 |     |             mstore(0x20, m1)
  1668 |     |             mstore(0x40, m2)
  1669 |     |             mstore(0x60, m3)
  1670 |     |         }
  1671 |     |     }
  1672 |     | 
  1673 |     |     function log(uint256 p0, address p1, uint256 p2) internal pure {
  1674 |     |         bytes32 m0;
  1675 |     |         bytes32 m1;
  1676 |     |         bytes32 m2;
  1677 |     |         bytes32 m3;
  1678 |     |         assembly {
  1679 |     |             m0 := mload(0x00)
  1680 |     |             m1 := mload(0x20)
  1681 |     |             m2 := mload(0x40)
  1682 |     |             m3 := mload(0x60)
  1683 |     |             // Selector of `log(uint256,address,uint256)`.
  1684 |     |             mstore(0x00, 0x5a9b5ed5)
  1685 |     |             mstore(0x20, p0)
  1686 |     |             mstore(0x40, p1)
  1687 |     |             mstore(0x60, p2)
  1688 |     |         }
  1689 |     |         _sendLogPayload(0x1c, 0x64);
  1690 |     |         assembly {
  1691 |     |             mstore(0x00, m0)
  1692 |     |             mstore(0x20, m1)
  1693 |     |             mstore(0x40, m2)
  1694 |     |             mstore(0x60, m3)
  1695 |     |         }
  1696 |     |     }
  1697 |     | 
  1698 |     |     function log(uint256 p0, address p1, bytes32 p2) internal pure {
  1699 |     |         bytes32 m0;
  1700 |     |         bytes32 m1;
  1701 |     |         bytes32 m2;
  1702 |     |         bytes32 m3;
  1703 |     |         bytes32 m4;
  1704 |     |         bytes32 m5;
  1705 |     |         assembly {
  1706 |     |             function writeString(pos, w) {
  1707 |     |                 let length := 0
  1708 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1709 |     |                 mstore(pos, length)
  1710 |     |                 let shift := sub(256, shl(3, length))
  1711 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1712 |     |             }
  1713 |     |             m0 := mload(0x00)
  1714 |     |             m1 := mload(0x20)
  1715 |     |             m2 := mload(0x40)
  1716 |     |             m3 := mload(0x60)
  1717 |     |             m4 := mload(0x80)
  1718 |     |             m5 := mload(0xa0)
  1719 |     |             // Selector of `log(uint256,address,string)`.
  1720 |     |             mstore(0x00, 0x63cb41f9)
  1721 |     |             mstore(0x20, p0)
  1722 |     |             mstore(0x40, p1)
  1723 |     |             mstore(0x60, 0x60)
  1724 |     |             writeString(0x80, p2)
  1725 |     |         }
  1726 |     |         _sendLogPayload(0x1c, 0xa4);
  1727 |     |         assembly {
  1728 |     |             mstore(0x00, m0)
  1729 |     |             mstore(0x20, m1)
  1730 |     |             mstore(0x40, m2)
  1731 |     |             mstore(0x60, m3)
  1732 |     |             mstore(0x80, m4)
  1733 |     |             mstore(0xa0, m5)
  1734 |     |         }
  1735 |     |     }
  1736 |     | 
  1737 |     |     function log(uint256 p0, bool p1, address p2) internal pure {
  1738 |     |         bytes32 m0;
  1739 |     |         bytes32 m1;
  1740 |     |         bytes32 m2;
  1741 |     |         bytes32 m3;
  1742 |     |         assembly {
  1743 |     |             m0 := mload(0x00)
  1744 |     |             m1 := mload(0x20)
  1745 |     |             m2 := mload(0x40)
  1746 |     |             m3 := mload(0x60)
  1747 |     |             // Selector of `log(uint256,bool,address)`.
  1748 |     |             mstore(0x00, 0x35085f7b)
  1749 |     |             mstore(0x20, p0)
  1750 |     |             mstore(0x40, p1)
  1751 |     |             mstore(0x60, p2)
  1752 |     |         }
  1753 |     |         _sendLogPayload(0x1c, 0x64);
  1754 |     |         assembly {
  1755 |     |             mstore(0x00, m0)
  1756 |     |             mstore(0x20, m1)
  1757 |     |             mstore(0x40, m2)
  1758 |     |             mstore(0x60, m3)
  1759 |     |         }
  1760 |     |     }
  1761 |     | 
  1762 |     |     function log(uint256 p0, bool p1, bool p2) internal pure {
  1763 |     |         bytes32 m0;
  1764 |     |         bytes32 m1;
  1765 |     |         bytes32 m2;
  1766 |     |         bytes32 m3;
  1767 |     |         assembly {
  1768 |     |             m0 := mload(0x00)
  1769 |     |             m1 := mload(0x20)
  1770 |     |             m2 := mload(0x40)
  1771 |     |             m3 := mload(0x60)
  1772 |     |             // Selector of `log(uint256,bool,bool)`.
  1773 |     |             mstore(0x00, 0x20718650)
  1774 |     |             mstore(0x20, p0)
  1775 |     |             mstore(0x40, p1)
  1776 |     |             mstore(0x60, p2)
  1777 |     |         }
  1778 |     |         _sendLogPayload(0x1c, 0x64);
  1779 |     |         assembly {
  1780 |     |             mstore(0x00, m0)
  1781 |     |             mstore(0x20, m1)
  1782 |     |             mstore(0x40, m2)
  1783 |     |             mstore(0x60, m3)
  1784 |     |         }
  1785 |     |     }
  1786 |     | 
  1787 |     |     function log(uint256 p0, bool p1, uint256 p2) internal pure {
  1788 |     |         bytes32 m0;
  1789 |     |         bytes32 m1;
  1790 |     |         bytes32 m2;
  1791 |     |         bytes32 m3;
  1792 |     |         assembly {
  1793 |     |             m0 := mload(0x00)
  1794 |     |             m1 := mload(0x20)
  1795 |     |             m2 := mload(0x40)
  1796 |     |             m3 := mload(0x60)
  1797 |     |             // Selector of `log(uint256,bool,uint256)`.
  1798 |     |             mstore(0x00, 0x20098014)
  1799 |     |             mstore(0x20, p0)
  1800 |     |             mstore(0x40, p1)
  1801 |     |             mstore(0x60, p2)
  1802 |     |         }
  1803 |     |         _sendLogPayload(0x1c, 0x64);
  1804 |     |         assembly {
  1805 |     |             mstore(0x00, m0)
  1806 |     |             mstore(0x20, m1)
  1807 |     |             mstore(0x40, m2)
  1808 |     |             mstore(0x60, m3)
  1809 |     |         }
  1810 |     |     }
  1811 |     | 
  1812 |     |     function log(uint256 p0, bool p1, bytes32 p2) internal pure {
  1813 |     |         bytes32 m0;
  1814 |     |         bytes32 m1;
  1815 |     |         bytes32 m2;
  1816 |     |         bytes32 m3;
  1817 |     |         bytes32 m4;
  1818 |     |         bytes32 m5;
  1819 |     |         assembly {
  1820 |     |             function writeString(pos, w) {
  1821 |     |                 let length := 0
  1822 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1823 |     |                 mstore(pos, length)
  1824 |     |                 let shift := sub(256, shl(3, length))
  1825 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1826 |     |             }
  1827 |     |             m0 := mload(0x00)
  1828 |     |             m1 := mload(0x20)
  1829 |     |             m2 := mload(0x40)
  1830 |     |             m3 := mload(0x60)
  1831 |     |             m4 := mload(0x80)
  1832 |     |             m5 := mload(0xa0)
  1833 |     |             // Selector of `log(uint256,bool,string)`.
  1834 |     |             mstore(0x00, 0x85775021)
  1835 |     |             mstore(0x20, p0)
  1836 |     |             mstore(0x40, p1)
  1837 |     |             mstore(0x60, 0x60)
  1838 |     |             writeString(0x80, p2)
  1839 |     |         }
  1840 |     |         _sendLogPayload(0x1c, 0xa4);
  1841 |     |         assembly {
  1842 |     |             mstore(0x00, m0)
  1843 |     |             mstore(0x20, m1)
  1844 |     |             mstore(0x40, m2)
  1845 |     |             mstore(0x60, m3)
  1846 |     |             mstore(0x80, m4)
  1847 |     |             mstore(0xa0, m5)
  1848 |     |         }
  1849 |     |     }
  1850 |     | 
  1851 |     |     function log(uint256 p0, uint256 p1, address p2) internal pure {
  1852 |     |         bytes32 m0;
  1853 |     |         bytes32 m1;
  1854 |     |         bytes32 m2;
  1855 |     |         bytes32 m3;
  1856 |     |         assembly {
  1857 |     |             m0 := mload(0x00)
  1858 |     |             m1 := mload(0x20)
  1859 |     |             m2 := mload(0x40)
  1860 |     |             m3 := mload(0x60)
  1861 |     |             // Selector of `log(uint256,uint256,address)`.
  1862 |     |             mstore(0x00, 0x5c96b331)
  1863 |     |             mstore(0x20, p0)
  1864 |     |             mstore(0x40, p1)
  1865 |     |             mstore(0x60, p2)
  1866 |     |         }
  1867 |     |         _sendLogPayload(0x1c, 0x64);
  1868 |     |         assembly {
  1869 |     |             mstore(0x00, m0)
  1870 |     |             mstore(0x20, m1)
  1871 |     |             mstore(0x40, m2)
  1872 |     |             mstore(0x60, m3)
  1873 |     |         }
  1874 |     |     }
  1875 |     | 
  1876 |     |     function log(uint256 p0, uint256 p1, bool p2) internal pure {
  1877 |     |         bytes32 m0;
  1878 |     |         bytes32 m1;
  1879 |     |         bytes32 m2;
  1880 |     |         bytes32 m3;
  1881 |     |         assembly {
  1882 |     |             m0 := mload(0x00)
  1883 |     |             m1 := mload(0x20)
  1884 |     |             m2 := mload(0x40)
  1885 |     |             m3 := mload(0x60)
  1886 |     |             // Selector of `log(uint256,uint256,bool)`.
  1887 |     |             mstore(0x00, 0x4766da72)
  1888 |     |             mstore(0x20, p0)
  1889 |     |             mstore(0x40, p1)
  1890 |     |             mstore(0x60, p2)
  1891 |     |         }
  1892 |     |         _sendLogPayload(0x1c, 0x64);
  1893 |     |         assembly {
  1894 |     |             mstore(0x00, m0)
  1895 |     |             mstore(0x20, m1)
  1896 |     |             mstore(0x40, m2)
  1897 |     |             mstore(0x60, m3)
  1898 |     |         }
  1899 |     |     }
  1900 |     | 
  1901 |     |     function log(uint256 p0, uint256 p1, uint256 p2) internal pure {
  1902 |     |         bytes32 m0;
  1903 |     |         bytes32 m1;
  1904 |     |         bytes32 m2;
  1905 |     |         bytes32 m3;
  1906 |     |         assembly {
  1907 |     |             m0 := mload(0x00)
  1908 |     |             m1 := mload(0x20)
  1909 |     |             m2 := mload(0x40)
  1910 |     |             m3 := mload(0x60)
  1911 |     |             // Selector of `log(uint256,uint256,uint256)`.
  1912 |     |             mstore(0x00, 0xd1ed7a3c)
  1913 |     |             mstore(0x20, p0)
  1914 |     |             mstore(0x40, p1)
  1915 |     |             mstore(0x60, p2)
  1916 |     |         }
  1917 |     |         _sendLogPayload(0x1c, 0x64);
  1918 |     |         assembly {
  1919 |     |             mstore(0x00, m0)
  1920 |     |             mstore(0x20, m1)
  1921 |     |             mstore(0x40, m2)
  1922 |     |             mstore(0x60, m3)
  1923 |     |         }
  1924 |     |     }
  1925 |     | 
  1926 |     |     function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {
  1927 |     |         bytes32 m0;
  1928 |     |         bytes32 m1;
  1929 |     |         bytes32 m2;
  1930 |     |         bytes32 m3;
  1931 |     |         bytes32 m4;
  1932 |     |         bytes32 m5;
  1933 |     |         assembly {
  1934 |     |             function writeString(pos, w) {
  1935 |     |                 let length := 0
  1936 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1937 |     |                 mstore(pos, length)
  1938 |     |                 let shift := sub(256, shl(3, length))
  1939 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1940 |     |             }
  1941 |     |             m0 := mload(0x00)
  1942 |     |             m1 := mload(0x20)
  1943 |     |             m2 := mload(0x40)
  1944 |     |             m3 := mload(0x60)
  1945 |     |             m4 := mload(0x80)
  1946 |     |             m5 := mload(0xa0)
  1947 |     |             // Selector of `log(uint256,uint256,string)`.
  1948 |     |             mstore(0x00, 0x71d04af2)
  1949 |     |             mstore(0x20, p0)
  1950 |     |             mstore(0x40, p1)
  1951 |     |             mstore(0x60, 0x60)
  1952 |     |             writeString(0x80, p2)
  1953 |     |         }
  1954 |     |         _sendLogPayload(0x1c, 0xa4);
  1955 |     |         assembly {
  1956 |     |             mstore(0x00, m0)
  1957 |     |             mstore(0x20, m1)
  1958 |     |             mstore(0x40, m2)
  1959 |     |             mstore(0x60, m3)
  1960 |     |             mstore(0x80, m4)
  1961 |     |             mstore(0xa0, m5)
  1962 |     |         }
  1963 |     |     }
  1964 |     | 
  1965 |     |     function log(uint256 p0, bytes32 p1, address p2) internal pure {
  1966 |     |         bytes32 m0;
  1967 |     |         bytes32 m1;
  1968 |     |         bytes32 m2;
  1969 |     |         bytes32 m3;
  1970 |     |         bytes32 m4;
  1971 |     |         bytes32 m5;
  1972 |     |         assembly {
  1973 |     |             function writeString(pos, w) {
  1974 |     |                 let length := 0
  1975 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  1976 |     |                 mstore(pos, length)
  1977 |     |                 let shift := sub(256, shl(3, length))
  1978 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  1979 |     |             }
  1980 |     |             m0 := mload(0x00)
  1981 |     |             m1 := mload(0x20)
  1982 |     |             m2 := mload(0x40)
  1983 |     |             m3 := mload(0x60)
  1984 |     |             m4 := mload(0x80)
  1985 |     |             m5 := mload(0xa0)
  1986 |     |             // Selector of `log(uint256,string,address)`.
  1987 |     |             mstore(0x00, 0x7afac959)
  1988 |     |             mstore(0x20, p0)
  1989 |     |             mstore(0x40, 0x60)
  1990 |     |             mstore(0x60, p2)
  1991 |     |             writeString(0x80, p1)
  1992 |     |         }
  1993 |     |         _sendLogPayload(0x1c, 0xa4);
  1994 |     |         assembly {
  1995 |     |             mstore(0x00, m0)
  1996 |     |             mstore(0x20, m1)
  1997 |     |             mstore(0x40, m2)
  1998 |     |             mstore(0x60, m3)
  1999 |     |             mstore(0x80, m4)
  2000 |     |             mstore(0xa0, m5)
  2001 |     |         }
  2002 |     |     }
  2003 |     | 
  2004 |     |     function log(uint256 p0, bytes32 p1, bool p2) internal pure {
  2005 |     |         bytes32 m0;
  2006 |     |         bytes32 m1;
  2007 |     |         bytes32 m2;
  2008 |     |         bytes32 m3;
  2009 |     |         bytes32 m4;
  2010 |     |         bytes32 m5;
  2011 |     |         assembly {
  2012 |     |             function writeString(pos, w) {
  2013 |     |                 let length := 0
  2014 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2015 |     |                 mstore(pos, length)
  2016 |     |                 let shift := sub(256, shl(3, length))
  2017 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2018 |     |             }
  2019 |     |             m0 := mload(0x00)
  2020 |     |             m1 := mload(0x20)
  2021 |     |             m2 := mload(0x40)
  2022 |     |             m3 := mload(0x60)
  2023 |     |             m4 := mload(0x80)
  2024 |     |             m5 := mload(0xa0)
  2025 |     |             // Selector of `log(uint256,string,bool)`.
  2026 |     |             mstore(0x00, 0x4ceda75a)
  2027 |     |             mstore(0x20, p0)
  2028 |     |             mstore(0x40, 0x60)
  2029 |     |             mstore(0x60, p2)
  2030 |     |             writeString(0x80, p1)
  2031 |     |         }
  2032 |     |         _sendLogPayload(0x1c, 0xa4);
  2033 |     |         assembly {
  2034 |     |             mstore(0x00, m0)
  2035 |     |             mstore(0x20, m1)
  2036 |     |             mstore(0x40, m2)
  2037 |     |             mstore(0x60, m3)
  2038 |     |             mstore(0x80, m4)
  2039 |     |             mstore(0xa0, m5)
  2040 |     |         }
  2041 |     |     }
  2042 |     | 
  2043 |     |     function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {
  2044 |     |         bytes32 m0;
  2045 |     |         bytes32 m1;
  2046 |     |         bytes32 m2;
  2047 |     |         bytes32 m3;
  2048 |     |         bytes32 m4;
  2049 |     |         bytes32 m5;
  2050 |     |         assembly {
  2051 |     |             function writeString(pos, w) {
  2052 |     |                 let length := 0
  2053 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2054 |     |                 mstore(pos, length)
  2055 |     |                 let shift := sub(256, shl(3, length))
  2056 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2057 |     |             }
  2058 |     |             m0 := mload(0x00)
  2059 |     |             m1 := mload(0x20)
  2060 |     |             m2 := mload(0x40)
  2061 |     |             m3 := mload(0x60)
  2062 |     |             m4 := mload(0x80)
  2063 |     |             m5 := mload(0xa0)
  2064 |     |             // Selector of `log(uint256,string,uint256)`.
  2065 |     |             mstore(0x00, 0x37aa7d4c)
  2066 |     |             mstore(0x20, p0)
  2067 |     |             mstore(0x40, 0x60)
  2068 |     |             mstore(0x60, p2)
  2069 |     |             writeString(0x80, p1)
  2070 |     |         }
  2071 |     |         _sendLogPayload(0x1c, 0xa4);
  2072 |     |         assembly {
  2073 |     |             mstore(0x00, m0)
  2074 |     |             mstore(0x20, m1)
  2075 |     |             mstore(0x40, m2)
  2076 |     |             mstore(0x60, m3)
  2077 |     |             mstore(0x80, m4)
  2078 |     |             mstore(0xa0, m5)
  2079 |     |         }
  2080 |     |     }
  2081 |     | 
  2082 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {
  2083 |     |         bytes32 m0;
  2084 |     |         bytes32 m1;
  2085 |     |         bytes32 m2;
  2086 |     |         bytes32 m3;
  2087 |     |         bytes32 m4;
  2088 |     |         bytes32 m5;
  2089 |     |         bytes32 m6;
  2090 |     |         bytes32 m7;
  2091 |     |         assembly {
  2092 |     |             function writeString(pos, w) {
  2093 |     |                 let length := 0
  2094 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2095 |     |                 mstore(pos, length)
  2096 |     |                 let shift := sub(256, shl(3, length))
  2097 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2098 |     |             }
  2099 |     |             m0 := mload(0x00)
  2100 |     |             m1 := mload(0x20)
  2101 |     |             m2 := mload(0x40)
  2102 |     |             m3 := mload(0x60)
  2103 |     |             m4 := mload(0x80)
  2104 |     |             m5 := mload(0xa0)
  2105 |     |             m6 := mload(0xc0)
  2106 |     |             m7 := mload(0xe0)
  2107 |     |             // Selector of `log(uint256,string,string)`.
  2108 |     |             mstore(0x00, 0xb115611f)
  2109 |     |             mstore(0x20, p0)
  2110 |     |             mstore(0x40, 0x60)
  2111 |     |             mstore(0x60, 0xa0)
  2112 |     |             writeString(0x80, p1)
  2113 |     |             writeString(0xc0, p2)
  2114 |     |         }
  2115 |     |         _sendLogPayload(0x1c, 0xe4);
  2116 |     |         assembly {
  2117 |     |             mstore(0x00, m0)
  2118 |     |             mstore(0x20, m1)
  2119 |     |             mstore(0x40, m2)
  2120 |     |             mstore(0x60, m3)
  2121 |     |             mstore(0x80, m4)
  2122 |     |             mstore(0xa0, m5)
  2123 |     |             mstore(0xc0, m6)
  2124 |     |             mstore(0xe0, m7)
  2125 |     |         }
  2126 |     |     }
  2127 |     | 
  2128 |     |     function log(bytes32 p0, address p1, address p2) internal pure {
  2129 |     |         bytes32 m0;
  2130 |     |         bytes32 m1;
  2131 |     |         bytes32 m2;
  2132 |     |         bytes32 m3;
  2133 |     |         bytes32 m4;
  2134 |     |         bytes32 m5;
  2135 |     |         assembly {
  2136 |     |             function writeString(pos, w) {
  2137 |     |                 let length := 0
  2138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2139 |     |                 mstore(pos, length)
  2140 |     |                 let shift := sub(256, shl(3, length))
  2141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2142 |     |             }
  2143 |     |             m0 := mload(0x00)
  2144 |     |             m1 := mload(0x20)
  2145 |     |             m2 := mload(0x40)
  2146 |     |             m3 := mload(0x60)
  2147 |     |             m4 := mload(0x80)
  2148 |     |             m5 := mload(0xa0)
  2149 |     |             // Selector of `log(string,address,address)`.
  2150 |     |             mstore(0x00, 0xfcec75e0)
  2151 |     |             mstore(0x20, 0x60)
  2152 |     |             mstore(0x40, p1)
  2153 |     |             mstore(0x60, p2)
  2154 |     |             writeString(0x80, p0)
  2155 |     |         }
  2156 |     |         _sendLogPayload(0x1c, 0xa4);
  2157 |     |         assembly {
  2158 |     |             mstore(0x00, m0)
  2159 |     |             mstore(0x20, m1)
  2160 |     |             mstore(0x40, m2)
  2161 |     |             mstore(0x60, m3)
  2162 |     |             mstore(0x80, m4)
  2163 |     |             mstore(0xa0, m5)
  2164 |     |         }
  2165 |     |     }
  2166 |     | 
  2167 |     |     function log(bytes32 p0, address p1, bool p2) internal pure {
  2168 |     |         bytes32 m0;
  2169 |     |         bytes32 m1;
  2170 |     |         bytes32 m2;
  2171 |     |         bytes32 m3;
  2172 |     |         bytes32 m4;
  2173 |     |         bytes32 m5;
  2174 |     |         assembly {
  2175 |     |             function writeString(pos, w) {
  2176 |     |                 let length := 0
  2177 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2178 |     |                 mstore(pos, length)
  2179 |     |                 let shift := sub(256, shl(3, length))
  2180 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2181 |     |             }
  2182 |     |             m0 := mload(0x00)
  2183 |     |             m1 := mload(0x20)
  2184 |     |             m2 := mload(0x40)
  2185 |     |             m3 := mload(0x60)
  2186 |     |             m4 := mload(0x80)
  2187 |     |             m5 := mload(0xa0)
  2188 |     |             // Selector of `log(string,address,bool)`.
  2189 |     |             mstore(0x00, 0xc91d5ed4)
  2190 |     |             mstore(0x20, 0x60)
  2191 |     |             mstore(0x40, p1)
  2192 |     |             mstore(0x60, p2)
  2193 |     |             writeString(0x80, p0)
  2194 |     |         }
  2195 |     |         _sendLogPayload(0x1c, 0xa4);
  2196 |     |         assembly {
  2197 |     |             mstore(0x00, m0)
  2198 |     |             mstore(0x20, m1)
  2199 |     |             mstore(0x40, m2)
  2200 |     |             mstore(0x60, m3)
  2201 |     |             mstore(0x80, m4)
  2202 |     |             mstore(0xa0, m5)
  2203 |     |         }
  2204 |     |     }
  2205 |     | 
  2206 |     |     function log(bytes32 p0, address p1, uint256 p2) internal pure {
  2207 |     |         bytes32 m0;
  2208 |     |         bytes32 m1;
  2209 |     |         bytes32 m2;
  2210 |     |         bytes32 m3;
  2211 |     |         bytes32 m4;
  2212 |     |         bytes32 m5;
  2213 |     |         assembly {
  2214 |     |             function writeString(pos, w) {
  2215 |     |                 let length := 0
  2216 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2217 |     |                 mstore(pos, length)
  2218 |     |                 let shift := sub(256, shl(3, length))
  2219 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2220 |     |             }
  2221 |     |             m0 := mload(0x00)
  2222 |     |             m1 := mload(0x20)
  2223 |     |             m2 := mload(0x40)
  2224 |     |             m3 := mload(0x60)
  2225 |     |             m4 := mload(0x80)
  2226 |     |             m5 := mload(0xa0)
  2227 |     |             // Selector of `log(string,address,uint256)`.
  2228 |     |             mstore(0x00, 0x0d26b925)
  2229 |     |             mstore(0x20, 0x60)
  2230 |     |             mstore(0x40, p1)
  2231 |     |             mstore(0x60, p2)
  2232 |     |             writeString(0x80, p0)
  2233 |     |         }
  2234 |     |         _sendLogPayload(0x1c, 0xa4);
  2235 |     |         assembly {
  2236 |     |             mstore(0x00, m0)
  2237 |     |             mstore(0x20, m1)
  2238 |     |             mstore(0x40, m2)
  2239 |     |             mstore(0x60, m3)
  2240 |     |             mstore(0x80, m4)
  2241 |     |             mstore(0xa0, m5)
  2242 |     |         }
  2243 |     |     }
  2244 |     | 
  2245 |     |     function log(bytes32 p0, address p1, bytes32 p2) internal pure {
  2246 |     |         bytes32 m0;
  2247 |     |         bytes32 m1;
  2248 |     |         bytes32 m2;
  2249 |     |         bytes32 m3;
  2250 |     |         bytes32 m4;
  2251 |     |         bytes32 m5;
  2252 |     |         bytes32 m6;
  2253 |     |         bytes32 m7;
  2254 |     |         assembly {
  2255 |     |             function writeString(pos, w) {
  2256 |     |                 let length := 0
  2257 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2258 |     |                 mstore(pos, length)
  2259 |     |                 let shift := sub(256, shl(3, length))
  2260 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2261 |     |             }
  2262 |     |             m0 := mload(0x00)
  2263 |     |             m1 := mload(0x20)
  2264 |     |             m2 := mload(0x40)
  2265 |     |             m3 := mload(0x60)
  2266 |     |             m4 := mload(0x80)
  2267 |     |             m5 := mload(0xa0)
  2268 |     |             m6 := mload(0xc0)
  2269 |     |             m7 := mload(0xe0)
  2270 |     |             // Selector of `log(string,address,string)`.
  2271 |     |             mstore(0x00, 0xe0e9ad4f)
  2272 |     |             mstore(0x20, 0x60)
  2273 |     |             mstore(0x40, p1)
  2274 |     |             mstore(0x60, 0xa0)
  2275 |     |             writeString(0x80, p0)
  2276 |     |             writeString(0xc0, p2)
  2277 |     |         }
  2278 |     |         _sendLogPayload(0x1c, 0xe4);
  2279 |     |         assembly {
  2280 |     |             mstore(0x00, m0)
  2281 |     |             mstore(0x20, m1)
  2282 |     |             mstore(0x40, m2)
  2283 |     |             mstore(0x60, m3)
  2284 |     |             mstore(0x80, m4)
  2285 |     |             mstore(0xa0, m5)
  2286 |     |             mstore(0xc0, m6)
  2287 |     |             mstore(0xe0, m7)
  2288 |     |         }
  2289 |     |     }
  2290 |     | 
  2291 |     |     function log(bytes32 p0, bool p1, address p2) internal pure {
  2292 |     |         bytes32 m0;
  2293 |     |         bytes32 m1;
  2294 |     |         bytes32 m2;
  2295 |     |         bytes32 m3;
  2296 |     |         bytes32 m4;
  2297 |     |         bytes32 m5;
  2298 |     |         assembly {
  2299 |     |             function writeString(pos, w) {
  2300 |     |                 let length := 0
  2301 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2302 |     |                 mstore(pos, length)
  2303 |     |                 let shift := sub(256, shl(3, length))
  2304 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2305 |     |             }
  2306 |     |             m0 := mload(0x00)
  2307 |     |             m1 := mload(0x20)
  2308 |     |             m2 := mload(0x40)
  2309 |     |             m3 := mload(0x60)
  2310 |     |             m4 := mload(0x80)
  2311 |     |             m5 := mload(0xa0)
  2312 |     |             // Selector of `log(string,bool,address)`.
  2313 |     |             mstore(0x00, 0x932bbb38)
  2314 |     |             mstore(0x20, 0x60)
  2315 |     |             mstore(0x40, p1)
  2316 |     |             mstore(0x60, p2)
  2317 |     |             writeString(0x80, p0)
  2318 |     |         }
  2319 |     |         _sendLogPayload(0x1c, 0xa4);
  2320 |     |         assembly {
  2321 |     |             mstore(0x00, m0)
  2322 |     |             mstore(0x20, m1)
  2323 |     |             mstore(0x40, m2)
  2324 |     |             mstore(0x60, m3)
  2325 |     |             mstore(0x80, m4)
  2326 |     |             mstore(0xa0, m5)
  2327 |     |         }
  2328 |     |     }
  2329 |     | 
  2330 |     |     function log(bytes32 p0, bool p1, bool p2) internal pure {
  2331 |     |         bytes32 m0;
  2332 |     |         bytes32 m1;
  2333 |     |         bytes32 m2;
  2334 |     |         bytes32 m3;
  2335 |     |         bytes32 m4;
  2336 |     |         bytes32 m5;
  2337 |     |         assembly {
  2338 |     |             function writeString(pos, w) {
  2339 |     |                 let length := 0
  2340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2341 |     |                 mstore(pos, length)
  2342 |     |                 let shift := sub(256, shl(3, length))
  2343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2344 |     |             }
  2345 |     |             m0 := mload(0x00)
  2346 |     |             m1 := mload(0x20)
  2347 |     |             m2 := mload(0x40)
  2348 |     |             m3 := mload(0x60)
  2349 |     |             m4 := mload(0x80)
  2350 |     |             m5 := mload(0xa0)
  2351 |     |             // Selector of `log(string,bool,bool)`.
  2352 |     |             mstore(0x00, 0x850b7ad6)
  2353 |     |             mstore(0x20, 0x60)
  2354 |     |             mstore(0x40, p1)
  2355 |     |             mstore(0x60, p2)
  2356 |     |             writeString(0x80, p0)
  2357 |     |         }
  2358 |     |         _sendLogPayload(0x1c, 0xa4);
  2359 |     |         assembly {
  2360 |     |             mstore(0x00, m0)
  2361 |     |             mstore(0x20, m1)
  2362 |     |             mstore(0x40, m2)
  2363 |     |             mstore(0x60, m3)
  2364 |     |             mstore(0x80, m4)
  2365 |     |             mstore(0xa0, m5)
  2366 |     |         }
  2367 |     |     }
  2368 |     | 
  2369 |     |     function log(bytes32 p0, bool p1, uint256 p2) internal pure {
  2370 |     |         bytes32 m0;
  2371 |     |         bytes32 m1;
  2372 |     |         bytes32 m2;
  2373 |     |         bytes32 m3;
  2374 |     |         bytes32 m4;
  2375 |     |         bytes32 m5;
  2376 |     |         assembly {
  2377 |     |             function writeString(pos, w) {
  2378 |     |                 let length := 0
  2379 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2380 |     |                 mstore(pos, length)
  2381 |     |                 let shift := sub(256, shl(3, length))
  2382 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2383 |     |             }
  2384 |     |             m0 := mload(0x00)
  2385 |     |             m1 := mload(0x20)
  2386 |     |             m2 := mload(0x40)
  2387 |     |             m3 := mload(0x60)
  2388 |     |             m4 := mload(0x80)
  2389 |     |             m5 := mload(0xa0)
  2390 |     |             // Selector of `log(string,bool,uint256)`.
  2391 |     |             mstore(0x00, 0xc95958d6)
  2392 |     |             mstore(0x20, 0x60)
  2393 |     |             mstore(0x40, p1)
  2394 |     |             mstore(0x60, p2)
  2395 |     |             writeString(0x80, p0)
  2396 |     |         }
  2397 |     |         _sendLogPayload(0x1c, 0xa4);
  2398 |     |         assembly {
  2399 |     |             mstore(0x00, m0)
  2400 |     |             mstore(0x20, m1)
  2401 |     |             mstore(0x40, m2)
  2402 |     |             mstore(0x60, m3)
  2403 |     |             mstore(0x80, m4)
  2404 |     |             mstore(0xa0, m5)
  2405 |     |         }
  2406 |     |     }
  2407 |     | 
  2408 |     |     function log(bytes32 p0, bool p1, bytes32 p2) internal pure {
  2409 |     |         bytes32 m0;
  2410 |     |         bytes32 m1;
  2411 |     |         bytes32 m2;
  2412 |     |         bytes32 m3;
  2413 |     |         bytes32 m4;
  2414 |     |         bytes32 m5;
  2415 |     |         bytes32 m6;
  2416 |     |         bytes32 m7;
  2417 |     |         assembly {
  2418 |     |             function writeString(pos, w) {
  2419 |     |                 let length := 0
  2420 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2421 |     |                 mstore(pos, length)
  2422 |     |                 let shift := sub(256, shl(3, length))
  2423 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2424 |     |             }
  2425 |     |             m0 := mload(0x00)
  2426 |     |             m1 := mload(0x20)
  2427 |     |             m2 := mload(0x40)
  2428 |     |             m3 := mload(0x60)
  2429 |     |             m4 := mload(0x80)
  2430 |     |             m5 := mload(0xa0)
  2431 |     |             m6 := mload(0xc0)
  2432 |     |             m7 := mload(0xe0)
  2433 |     |             // Selector of `log(string,bool,string)`.
  2434 |     |             mstore(0x00, 0xe298f47d)
  2435 |     |             mstore(0x20, 0x60)
  2436 |     |             mstore(0x40, p1)
  2437 |     |             mstore(0x60, 0xa0)
  2438 |     |             writeString(0x80, p0)
  2439 |     |             writeString(0xc0, p2)
  2440 |     |         }
  2441 |     |         _sendLogPayload(0x1c, 0xe4);
  2442 |     |         assembly {
  2443 |     |             mstore(0x00, m0)
  2444 |     |             mstore(0x20, m1)
  2445 |     |             mstore(0x40, m2)
  2446 |     |             mstore(0x60, m3)
  2447 |     |             mstore(0x80, m4)
  2448 |     |             mstore(0xa0, m5)
  2449 |     |             mstore(0xc0, m6)
  2450 |     |             mstore(0xe0, m7)
  2451 |     |         }
  2452 |     |     }
  2453 |     | 
  2454 |     |     function log(bytes32 p0, uint256 p1, address p2) internal pure {
  2455 |     |         bytes32 m0;
  2456 |     |         bytes32 m1;
  2457 |     |         bytes32 m2;
  2458 |     |         bytes32 m3;
  2459 |     |         bytes32 m4;
  2460 |     |         bytes32 m5;
  2461 |     |         assembly {
  2462 |     |             function writeString(pos, w) {
  2463 |     |                 let length := 0
  2464 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2465 |     |                 mstore(pos, length)
  2466 |     |                 let shift := sub(256, shl(3, length))
  2467 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2468 |     |             }
  2469 |     |             m0 := mload(0x00)
  2470 |     |             m1 := mload(0x20)
  2471 |     |             m2 := mload(0x40)
  2472 |     |             m3 := mload(0x60)
  2473 |     |             m4 := mload(0x80)
  2474 |     |             m5 := mload(0xa0)
  2475 |     |             // Selector of `log(string,uint256,address)`.
  2476 |     |             mstore(0x00, 0x1c7ec448)
  2477 |     |             mstore(0x20, 0x60)
  2478 |     |             mstore(0x40, p1)
  2479 |     |             mstore(0x60, p2)
  2480 |     |             writeString(0x80, p0)
  2481 |     |         }
  2482 |     |         _sendLogPayload(0x1c, 0xa4);
  2483 |     |         assembly {
  2484 |     |             mstore(0x00, m0)
  2485 |     |             mstore(0x20, m1)
  2486 |     |             mstore(0x40, m2)
  2487 |     |             mstore(0x60, m3)
  2488 |     |             mstore(0x80, m4)
  2489 |     |             mstore(0xa0, m5)
  2490 |     |         }
  2491 |     |     }
  2492 |     | 
  2493 |     |     function log(bytes32 p0, uint256 p1, bool p2) internal pure {
  2494 |     |         bytes32 m0;
  2495 |     |         bytes32 m1;
  2496 |     |         bytes32 m2;
  2497 |     |         bytes32 m3;
  2498 |     |         bytes32 m4;
  2499 |     |         bytes32 m5;
  2500 |     |         assembly {
  2501 |     |             function writeString(pos, w) {
  2502 |     |                 let length := 0
  2503 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2504 |     |                 mstore(pos, length)
  2505 |     |                 let shift := sub(256, shl(3, length))
  2506 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2507 |     |             }
  2508 |     |             m0 := mload(0x00)
  2509 |     |             m1 := mload(0x20)
  2510 |     |             m2 := mload(0x40)
  2511 |     |             m3 := mload(0x60)
  2512 |     |             m4 := mload(0x80)
  2513 |     |             m5 := mload(0xa0)
  2514 |     |             // Selector of `log(string,uint256,bool)`.
  2515 |     |             mstore(0x00, 0xca7733b1)
  2516 |     |             mstore(0x20, 0x60)
  2517 |     |             mstore(0x40, p1)
  2518 |     |             mstore(0x60, p2)
  2519 |     |             writeString(0x80, p0)
  2520 |     |         }
  2521 |     |         _sendLogPayload(0x1c, 0xa4);
  2522 |     |         assembly {
  2523 |     |             mstore(0x00, m0)
  2524 |     |             mstore(0x20, m1)
  2525 |     |             mstore(0x40, m2)
  2526 |     |             mstore(0x60, m3)
  2527 |     |             mstore(0x80, m4)
  2528 |     |             mstore(0xa0, m5)
  2529 |     |         }
  2530 |     |     }
  2531 |     | 
  2532 |     |     function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {
  2533 |     |         bytes32 m0;
  2534 |     |         bytes32 m1;
  2535 |     |         bytes32 m2;
  2536 |     |         bytes32 m3;
  2537 |     |         bytes32 m4;
  2538 |     |         bytes32 m5;
  2539 |     |         assembly {
  2540 |     |             function writeString(pos, w) {
  2541 |     |                 let length := 0
  2542 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2543 |     |                 mstore(pos, length)
  2544 |     |                 let shift := sub(256, shl(3, length))
  2545 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2546 |     |             }
  2547 |     |             m0 := mload(0x00)
  2548 |     |             m1 := mload(0x20)
  2549 |     |             m2 := mload(0x40)
  2550 |     |             m3 := mload(0x60)
  2551 |     |             m4 := mload(0x80)
  2552 |     |             m5 := mload(0xa0)
  2553 |     |             // Selector of `log(string,uint256,uint256)`.
  2554 |     |             mstore(0x00, 0xca47c4eb)
  2555 |     |             mstore(0x20, 0x60)
  2556 |     |             mstore(0x40, p1)
  2557 |     |             mstore(0x60, p2)
  2558 |     |             writeString(0x80, p0)
  2559 |     |         }
  2560 |     |         _sendLogPayload(0x1c, 0xa4);
  2561 |     |         assembly {
  2562 |     |             mstore(0x00, m0)
  2563 |     |             mstore(0x20, m1)
  2564 |     |             mstore(0x40, m2)
  2565 |     |             mstore(0x60, m3)
  2566 |     |             mstore(0x80, m4)
  2567 |     |             mstore(0xa0, m5)
  2568 |     |         }
  2569 |     |     }
  2570 |     | 
  2571 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {
  2572 |     |         bytes32 m0;
  2573 |     |         bytes32 m1;
  2574 |     |         bytes32 m2;
  2575 |     |         bytes32 m3;
  2576 |     |         bytes32 m4;
  2577 |     |         bytes32 m5;
  2578 |     |         bytes32 m6;
  2579 |     |         bytes32 m7;
  2580 |     |         assembly {
  2581 |     |             function writeString(pos, w) {
  2582 |     |                 let length := 0
  2583 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2584 |     |                 mstore(pos, length)
  2585 |     |                 let shift := sub(256, shl(3, length))
  2586 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2587 |     |             }
  2588 |     |             m0 := mload(0x00)
  2589 |     |             m1 := mload(0x20)
  2590 |     |             m2 := mload(0x40)
  2591 |     |             m3 := mload(0x60)
  2592 |     |             m4 := mload(0x80)
  2593 |     |             m5 := mload(0xa0)
  2594 |     |             m6 := mload(0xc0)
  2595 |     |             m7 := mload(0xe0)
  2596 |     |             // Selector of `log(string,uint256,string)`.
  2597 |     |             mstore(0x00, 0x5970e089)
  2598 |     |             mstore(0x20, 0x60)
  2599 |     |             mstore(0x40, p1)
  2600 |     |             mstore(0x60, 0xa0)
  2601 |     |             writeString(0x80, p0)
  2602 |     |             writeString(0xc0, p2)
  2603 |     |         }
  2604 |     |         _sendLogPayload(0x1c, 0xe4);
  2605 |     |         assembly {
  2606 |     |             mstore(0x00, m0)
  2607 |     |             mstore(0x20, m1)
  2608 |     |             mstore(0x40, m2)
  2609 |     |             mstore(0x60, m3)
  2610 |     |             mstore(0x80, m4)
  2611 |     |             mstore(0xa0, m5)
  2612 |     |             mstore(0xc0, m6)
  2613 |     |             mstore(0xe0, m7)
  2614 |     |         }
  2615 |     |     }
  2616 |     | 
  2617 |     |     function log(bytes32 p0, bytes32 p1, address p2) internal pure {
  2618 |     |         bytes32 m0;
  2619 |     |         bytes32 m1;
  2620 |     |         bytes32 m2;
  2621 |     |         bytes32 m3;
  2622 |     |         bytes32 m4;
  2623 |     |         bytes32 m5;
  2624 |     |         bytes32 m6;
  2625 |     |         bytes32 m7;
  2626 |     |         assembly {
  2627 |     |             function writeString(pos, w) {
  2628 |     |                 let length := 0
  2629 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2630 |     |                 mstore(pos, length)
  2631 |     |                 let shift := sub(256, shl(3, length))
  2632 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2633 |     |             }
  2634 |     |             m0 := mload(0x00)
  2635 |     |             m1 := mload(0x20)
  2636 |     |             m2 := mload(0x40)
  2637 |     |             m3 := mload(0x60)
  2638 |     |             m4 := mload(0x80)
  2639 |     |             m5 := mload(0xa0)
  2640 |     |             m6 := mload(0xc0)
  2641 |     |             m7 := mload(0xe0)
  2642 |     |             // Selector of `log(string,string,address)`.
  2643 |     |             mstore(0x00, 0x95ed0195)
  2644 |     |             mstore(0x20, 0x60)
  2645 |     |             mstore(0x40, 0xa0)
  2646 |     |             mstore(0x60, p2)
  2647 |     |             writeString(0x80, p0)
  2648 |     |             writeString(0xc0, p1)
  2649 |     |         }
  2650 |     |         _sendLogPayload(0x1c, 0xe4);
  2651 |     |         assembly {
  2652 |     |             mstore(0x00, m0)
  2653 |     |             mstore(0x20, m1)
  2654 |     |             mstore(0x40, m2)
  2655 |     |             mstore(0x60, m3)
  2656 |     |             mstore(0x80, m4)
  2657 |     |             mstore(0xa0, m5)
  2658 |     |             mstore(0xc0, m6)
  2659 |     |             mstore(0xe0, m7)
  2660 |     |         }
  2661 |     |     }
  2662 |     | 
  2663 |     |     function log(bytes32 p0, bytes32 p1, bool p2) internal pure {
  2664 |     |         bytes32 m0;
  2665 |     |         bytes32 m1;
  2666 |     |         bytes32 m2;
  2667 |     |         bytes32 m3;
  2668 |     |         bytes32 m4;
  2669 |     |         bytes32 m5;
  2670 |     |         bytes32 m6;
  2671 |     |         bytes32 m7;
  2672 |     |         assembly {
  2673 |     |             function writeString(pos, w) {
  2674 |     |                 let length := 0
  2675 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2676 |     |                 mstore(pos, length)
  2677 |     |                 let shift := sub(256, shl(3, length))
  2678 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2679 |     |             }
  2680 |     |             m0 := mload(0x00)
  2681 |     |             m1 := mload(0x20)
  2682 |     |             m2 := mload(0x40)
  2683 |     |             m3 := mload(0x60)
  2684 |     |             m4 := mload(0x80)
  2685 |     |             m5 := mload(0xa0)
  2686 |     |             m6 := mload(0xc0)
  2687 |     |             m7 := mload(0xe0)
  2688 |     |             // Selector of `log(string,string,bool)`.
  2689 |     |             mstore(0x00, 0xb0e0f9b5)
  2690 |     |             mstore(0x20, 0x60)
  2691 |     |             mstore(0x40, 0xa0)
  2692 |     |             mstore(0x60, p2)
  2693 |     |             writeString(0x80, p0)
  2694 |     |             writeString(0xc0, p1)
  2695 |     |         }
  2696 |     |         _sendLogPayload(0x1c, 0xe4);
  2697 |     |         assembly {
  2698 |     |             mstore(0x00, m0)
  2699 |     |             mstore(0x20, m1)
  2700 |     |             mstore(0x40, m2)
  2701 |     |             mstore(0x60, m3)
  2702 |     |             mstore(0x80, m4)
  2703 |     |             mstore(0xa0, m5)
  2704 |     |             mstore(0xc0, m6)
  2705 |     |             mstore(0xe0, m7)
  2706 |     |         }
  2707 |     |     }
  2708 |     | 
  2709 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {
  2710 |     |         bytes32 m0;
  2711 |     |         bytes32 m1;
  2712 |     |         bytes32 m2;
  2713 |     |         bytes32 m3;
  2714 |     |         bytes32 m4;
  2715 |     |         bytes32 m5;
  2716 |     |         bytes32 m6;
  2717 |     |         bytes32 m7;
  2718 |     |         assembly {
  2719 |     |             function writeString(pos, w) {
  2720 |     |                 let length := 0
  2721 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2722 |     |                 mstore(pos, length)
  2723 |     |                 let shift := sub(256, shl(3, length))
  2724 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2725 |     |             }
  2726 |     |             m0 := mload(0x00)
  2727 |     |             m1 := mload(0x20)
  2728 |     |             m2 := mload(0x40)
  2729 |     |             m3 := mload(0x60)
  2730 |     |             m4 := mload(0x80)
  2731 |     |             m5 := mload(0xa0)
  2732 |     |             m6 := mload(0xc0)
  2733 |     |             m7 := mload(0xe0)
  2734 |     |             // Selector of `log(string,string,uint256)`.
  2735 |     |             mstore(0x00, 0x5821efa1)
  2736 |     |             mstore(0x20, 0x60)
  2737 |     |             mstore(0x40, 0xa0)
  2738 |     |             mstore(0x60, p2)
  2739 |     |             writeString(0x80, p0)
  2740 |     |             writeString(0xc0, p1)
  2741 |     |         }
  2742 |     |         _sendLogPayload(0x1c, 0xe4);
  2743 |     |         assembly {
  2744 |     |             mstore(0x00, m0)
  2745 |     |             mstore(0x20, m1)
  2746 |     |             mstore(0x40, m2)
  2747 |     |             mstore(0x60, m3)
  2748 |     |             mstore(0x80, m4)
  2749 |     |             mstore(0xa0, m5)
  2750 |     |             mstore(0xc0, m6)
  2751 |     |             mstore(0xe0, m7)
  2752 |     |         }
  2753 |     |     }
  2754 |     | 
  2755 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {
  2756 |     |         bytes32 m0;
  2757 |     |         bytes32 m1;
  2758 |     |         bytes32 m2;
  2759 |     |         bytes32 m3;
  2760 |     |         bytes32 m4;
  2761 |     |         bytes32 m5;
  2762 |     |         bytes32 m6;
  2763 |     |         bytes32 m7;
  2764 |     |         bytes32 m8;
  2765 |     |         bytes32 m9;
  2766 |     |         assembly {
  2767 |     |             function writeString(pos, w) {
  2768 |     |                 let length := 0
  2769 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2770 |     |                 mstore(pos, length)
  2771 |     |                 let shift := sub(256, shl(3, length))
  2772 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2773 |     |             }
  2774 |     |             m0 := mload(0x00)
  2775 |     |             m1 := mload(0x20)
  2776 |     |             m2 := mload(0x40)
  2777 |     |             m3 := mload(0x60)
  2778 |     |             m4 := mload(0x80)
  2779 |     |             m5 := mload(0xa0)
  2780 |     |             m6 := mload(0xc0)
  2781 |     |             m7 := mload(0xe0)
  2782 |     |             m8 := mload(0x100)
  2783 |     |             m9 := mload(0x120)
  2784 |     |             // Selector of `log(string,string,string)`.
  2785 |     |             mstore(0x00, 0x2ced7cef)
  2786 |     |             mstore(0x20, 0x60)
  2787 |     |             mstore(0x40, 0xa0)
  2788 |     |             mstore(0x60, 0xe0)
  2789 |     |             writeString(0x80, p0)
  2790 |     |             writeString(0xc0, p1)
  2791 |     |             writeString(0x100, p2)
  2792 |     |         }
  2793 |     |         _sendLogPayload(0x1c, 0x124);
  2794 |     |         assembly {
  2795 |     |             mstore(0x00, m0)
  2796 |     |             mstore(0x20, m1)
  2797 |     |             mstore(0x40, m2)
  2798 |     |             mstore(0x60, m3)
  2799 |     |             mstore(0x80, m4)
  2800 |     |             mstore(0xa0, m5)
  2801 |     |             mstore(0xc0, m6)
  2802 |     |             mstore(0xe0, m7)
  2803 |     |             mstore(0x100, m8)
  2804 |     |             mstore(0x120, m9)
  2805 |     |         }
  2806 |     |     }
  2807 |     | 
  2808 |     |     function log(address p0, address p1, address p2, address p3) internal pure {
  2809 |     |         bytes32 m0;
  2810 |     |         bytes32 m1;
  2811 |     |         bytes32 m2;
  2812 |     |         bytes32 m3;
  2813 |     |         bytes32 m4;
  2814 |     |         assembly {
  2815 |     |             m0 := mload(0x00)
  2816 |     |             m1 := mload(0x20)
  2817 |     |             m2 := mload(0x40)
  2818 |     |             m3 := mload(0x60)
  2819 |     |             m4 := mload(0x80)
  2820 |     |             // Selector of `log(address,address,address,address)`.
  2821 |     |             mstore(0x00, 0x665bf134)
  2822 |     |             mstore(0x20, p0)
  2823 |     |             mstore(0x40, p1)
  2824 |     |             mstore(0x60, p2)
  2825 |     |             mstore(0x80, p3)
  2826 |     |         }
  2827 |     |         _sendLogPayload(0x1c, 0x84);
  2828 |     |         assembly {
  2829 |     |             mstore(0x00, m0)
  2830 |     |             mstore(0x20, m1)
  2831 |     |             mstore(0x40, m2)
  2832 |     |             mstore(0x60, m3)
  2833 |     |             mstore(0x80, m4)
  2834 |     |         }
  2835 |     |     }
  2836 |     | 
  2837 |     |     function log(address p0, address p1, address p2, bool p3) internal pure {
  2838 |     |         bytes32 m0;
  2839 |     |         bytes32 m1;
  2840 |     |         bytes32 m2;
  2841 |     |         bytes32 m3;
  2842 |     |         bytes32 m4;
  2843 |     |         assembly {
  2844 |     |             m0 := mload(0x00)
  2845 |     |             m1 := mload(0x20)
  2846 |     |             m2 := mload(0x40)
  2847 |     |             m3 := mload(0x60)
  2848 |     |             m4 := mload(0x80)
  2849 |     |             // Selector of `log(address,address,address,bool)`.
  2850 |     |             mstore(0x00, 0x0e378994)
  2851 |     |             mstore(0x20, p0)
  2852 |     |             mstore(0x40, p1)
  2853 |     |             mstore(0x60, p2)
  2854 |     |             mstore(0x80, p3)
  2855 |     |         }
  2856 |     |         _sendLogPayload(0x1c, 0x84);
  2857 |     |         assembly {
  2858 |     |             mstore(0x00, m0)
  2859 |     |             mstore(0x20, m1)
  2860 |     |             mstore(0x40, m2)
  2861 |     |             mstore(0x60, m3)
  2862 |     |             mstore(0x80, m4)
  2863 |     |         }
  2864 |     |     }
  2865 |     | 
  2866 |     |     function log(address p0, address p1, address p2, uint256 p3) internal pure {
  2867 |     |         bytes32 m0;
  2868 |     |         bytes32 m1;
  2869 |     |         bytes32 m2;
  2870 |     |         bytes32 m3;
  2871 |     |         bytes32 m4;
  2872 |     |         assembly {
  2873 |     |             m0 := mload(0x00)
  2874 |     |             m1 := mload(0x20)
  2875 |     |             m2 := mload(0x40)
  2876 |     |             m3 := mload(0x60)
  2877 |     |             m4 := mload(0x80)
  2878 |     |             // Selector of `log(address,address,address,uint256)`.
  2879 |     |             mstore(0x00, 0x94250d77)
  2880 |     |             mstore(0x20, p0)
  2881 |     |             mstore(0x40, p1)
  2882 |     |             mstore(0x60, p2)
  2883 |     |             mstore(0x80, p3)
  2884 |     |         }
  2885 |     |         _sendLogPayload(0x1c, 0x84);
  2886 |     |         assembly {
  2887 |     |             mstore(0x00, m0)
  2888 |     |             mstore(0x20, m1)
  2889 |     |             mstore(0x40, m2)
  2890 |     |             mstore(0x60, m3)
  2891 |     |             mstore(0x80, m4)
  2892 |     |         }
  2893 |     |     }
  2894 |     | 
  2895 |     |     function log(address p0, address p1, address p2, bytes32 p3) internal pure {
  2896 |     |         bytes32 m0;
  2897 |     |         bytes32 m1;
  2898 |     |         bytes32 m2;
  2899 |     |         bytes32 m3;
  2900 |     |         bytes32 m4;
  2901 |     |         bytes32 m5;
  2902 |     |         bytes32 m6;
  2903 |     |         assembly {
  2904 |     |             function writeString(pos, w) {
  2905 |     |                 let length := 0
  2906 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  2907 |     |                 mstore(pos, length)
  2908 |     |                 let shift := sub(256, shl(3, length))
  2909 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  2910 |     |             }
  2911 |     |             m0 := mload(0x00)
  2912 |     |             m1 := mload(0x20)
  2913 |     |             m2 := mload(0x40)
  2914 |     |             m3 := mload(0x60)
  2915 |     |             m4 := mload(0x80)
  2916 |     |             m5 := mload(0xa0)
  2917 |     |             m6 := mload(0xc0)
  2918 |     |             // Selector of `log(address,address,address,string)`.
  2919 |     |             mstore(0x00, 0xf808da20)
  2920 |     |             mstore(0x20, p0)
  2921 |     |             mstore(0x40, p1)
  2922 |     |             mstore(0x60, p2)
  2923 |     |             mstore(0x80, 0x80)
  2924 |     |             writeString(0xa0, p3)
  2925 |     |         }
  2926 |     |         _sendLogPayload(0x1c, 0xc4);
  2927 |     |         assembly {
  2928 |     |             mstore(0x00, m0)
  2929 |     |             mstore(0x20, m1)
  2930 |     |             mstore(0x40, m2)
  2931 |     |             mstore(0x60, m3)
  2932 |     |             mstore(0x80, m4)
  2933 |     |             mstore(0xa0, m5)
  2934 |     |             mstore(0xc0, m6)
  2935 |     |         }
  2936 |     |     }
  2937 |     | 
  2938 |     |     function log(address p0, address p1, bool p2, address p3) internal pure {
  2939 |     |         bytes32 m0;
  2940 |     |         bytes32 m1;
  2941 |     |         bytes32 m2;
  2942 |     |         bytes32 m3;
  2943 |     |         bytes32 m4;
  2944 |     |         assembly {
  2945 |     |             m0 := mload(0x00)
  2946 |     |             m1 := mload(0x20)
  2947 |     |             m2 := mload(0x40)
  2948 |     |             m3 := mload(0x60)
  2949 |     |             m4 := mload(0x80)
  2950 |     |             // Selector of `log(address,address,bool,address)`.
  2951 |     |             mstore(0x00, 0x9f1bc36e)
  2952 |     |             mstore(0x20, p0)
  2953 |     |             mstore(0x40, p1)
  2954 |     |             mstore(0x60, p2)
  2955 |     |             mstore(0x80, p3)
  2956 |     |         }
  2957 |     |         _sendLogPayload(0x1c, 0x84);
  2958 |     |         assembly {
  2959 |     |             mstore(0x00, m0)
  2960 |     |             mstore(0x20, m1)
  2961 |     |             mstore(0x40, m2)
  2962 |     |             mstore(0x60, m3)
  2963 |     |             mstore(0x80, m4)
  2964 |     |         }
  2965 |     |     }
  2966 |     | 
  2967 |     |     function log(address p0, address p1, bool p2, bool p3) internal pure {
  2968 |     |         bytes32 m0;
  2969 |     |         bytes32 m1;
  2970 |     |         bytes32 m2;
  2971 |     |         bytes32 m3;
  2972 |     |         bytes32 m4;
  2973 |     |         assembly {
  2974 |     |             m0 := mload(0x00)
  2975 |     |             m1 := mload(0x20)
  2976 |     |             m2 := mload(0x40)
  2977 |     |             m3 := mload(0x60)
  2978 |     |             m4 := mload(0x80)
  2979 |     |             // Selector of `log(address,address,bool,bool)`.
  2980 |     |             mstore(0x00, 0x2cd4134a)
  2981 |     |             mstore(0x20, p0)
  2982 |     |             mstore(0x40, p1)
  2983 |     |             mstore(0x60, p2)
  2984 |     |             mstore(0x80, p3)
  2985 |     |         }
  2986 |     |         _sendLogPayload(0x1c, 0x84);
  2987 |     |         assembly {
  2988 |     |             mstore(0x00, m0)
  2989 |     |             mstore(0x20, m1)
  2990 |     |             mstore(0x40, m2)
  2991 |     |             mstore(0x60, m3)
  2992 |     |             mstore(0x80, m4)
  2993 |     |         }
  2994 |     |     }
  2995 |     | 
  2996 |     |     function log(address p0, address p1, bool p2, uint256 p3) internal pure {
  2997 |     |         bytes32 m0;
  2998 |     |         bytes32 m1;
  2999 |     |         bytes32 m2;
  3000 |     |         bytes32 m3;
  3001 |     |         bytes32 m4;
  3002 |     |         assembly {
  3003 |     |             m0 := mload(0x00)
  3004 |     |             m1 := mload(0x20)
  3005 |     |             m2 := mload(0x40)
  3006 |     |             m3 := mload(0x60)
  3007 |     |             m4 := mload(0x80)
  3008 |     |             // Selector of `log(address,address,bool,uint256)`.
  3009 |     |             mstore(0x00, 0x3971e78c)
  3010 |     |             mstore(0x20, p0)
  3011 |     |             mstore(0x40, p1)
  3012 |     |             mstore(0x60, p2)
  3013 |     |             mstore(0x80, p3)
  3014 |     |         }
  3015 |     |         _sendLogPayload(0x1c, 0x84);
  3016 |     |         assembly {
  3017 |     |             mstore(0x00, m0)
  3018 |     |             mstore(0x20, m1)
  3019 |     |             mstore(0x40, m2)
  3020 |     |             mstore(0x60, m3)
  3021 |     |             mstore(0x80, m4)
  3022 |     |         }
  3023 |     |     }
  3024 |     | 
  3025 |     |     function log(address p0, address p1, bool p2, bytes32 p3) internal pure {
  3026 |     |         bytes32 m0;
  3027 |     |         bytes32 m1;
  3028 |     |         bytes32 m2;
  3029 |     |         bytes32 m3;
  3030 |     |         bytes32 m4;
  3031 |     |         bytes32 m5;
  3032 |     |         bytes32 m6;
  3033 |     |         assembly {
  3034 |     |             function writeString(pos, w) {
  3035 |     |                 let length := 0
  3036 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3037 |     |                 mstore(pos, length)
  3038 |     |                 let shift := sub(256, shl(3, length))
  3039 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3040 |     |             }
  3041 |     |             m0 := mload(0x00)
  3042 |     |             m1 := mload(0x20)
  3043 |     |             m2 := mload(0x40)
  3044 |     |             m3 := mload(0x60)
  3045 |     |             m4 := mload(0x80)
  3046 |     |             m5 := mload(0xa0)
  3047 |     |             m6 := mload(0xc0)
  3048 |     |             // Selector of `log(address,address,bool,string)`.
  3049 |     |             mstore(0x00, 0xaa6540c8)
  3050 |     |             mstore(0x20, p0)
  3051 |     |             mstore(0x40, p1)
  3052 |     |             mstore(0x60, p2)
  3053 |     |             mstore(0x80, 0x80)
  3054 |     |             writeString(0xa0, p3)
  3055 |     |         }
  3056 |     |         _sendLogPayload(0x1c, 0xc4);
  3057 |     |         assembly {
  3058 |     |             mstore(0x00, m0)
  3059 |     |             mstore(0x20, m1)
  3060 |     |             mstore(0x40, m2)
  3061 |     |             mstore(0x60, m3)
  3062 |     |             mstore(0x80, m4)
  3063 |     |             mstore(0xa0, m5)
  3064 |     |             mstore(0xc0, m6)
  3065 |     |         }
  3066 |     |     }
  3067 |     | 
  3068 |     |     function log(address p0, address p1, uint256 p2, address p3) internal pure {
  3069 |     |         bytes32 m0;
  3070 |     |         bytes32 m1;
  3071 |     |         bytes32 m2;
  3072 |     |         bytes32 m3;
  3073 |     |         bytes32 m4;
  3074 |     |         assembly {
  3075 |     |             m0 := mload(0x00)
  3076 |     |             m1 := mload(0x20)
  3077 |     |             m2 := mload(0x40)
  3078 |     |             m3 := mload(0x60)
  3079 |     |             m4 := mload(0x80)
  3080 |     |             // Selector of `log(address,address,uint256,address)`.
  3081 |     |             mstore(0x00, 0x8da6def5)
  3082 |     |             mstore(0x20, p0)
  3083 |     |             mstore(0x40, p1)
  3084 |     |             mstore(0x60, p2)
  3085 |     |             mstore(0x80, p3)
  3086 |     |         }
  3087 |     |         _sendLogPayload(0x1c, 0x84);
  3088 |     |         assembly {
  3089 |     |             mstore(0x00, m0)
  3090 |     |             mstore(0x20, m1)
  3091 |     |             mstore(0x40, m2)
  3092 |     |             mstore(0x60, m3)
  3093 |     |             mstore(0x80, m4)
  3094 |     |         }
  3095 |     |     }
  3096 |     | 
  3097 |     |     function log(address p0, address p1, uint256 p2, bool p3) internal pure {
  3098 |     |         bytes32 m0;
  3099 |     |         bytes32 m1;
  3100 |     |         bytes32 m2;
  3101 |     |         bytes32 m3;
  3102 |     |         bytes32 m4;
  3103 |     |         assembly {
  3104 |     |             m0 := mload(0x00)
  3105 |     |             m1 := mload(0x20)
  3106 |     |             m2 := mload(0x40)
  3107 |     |             m3 := mload(0x60)
  3108 |     |             m4 := mload(0x80)
  3109 |     |             // Selector of `log(address,address,uint256,bool)`.
  3110 |     |             mstore(0x00, 0x9b4254e2)
  3111 |     |             mstore(0x20, p0)
  3112 |     |             mstore(0x40, p1)
  3113 |     |             mstore(0x60, p2)
  3114 |     |             mstore(0x80, p3)
  3115 |     |         }
  3116 |     |         _sendLogPayload(0x1c, 0x84);
  3117 |     |         assembly {
  3118 |     |             mstore(0x00, m0)
  3119 |     |             mstore(0x20, m1)
  3120 |     |             mstore(0x40, m2)
  3121 |     |             mstore(0x60, m3)
  3122 |     |             mstore(0x80, m4)
  3123 |     |         }
  3124 |     |     }
  3125 |     | 
  3126 |     |     function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {
  3127 |     |         bytes32 m0;
  3128 |     |         bytes32 m1;
  3129 |     |         bytes32 m2;
  3130 |     |         bytes32 m3;
  3131 |     |         bytes32 m4;
  3132 |     |         assembly {
  3133 |     |             m0 := mload(0x00)
  3134 |     |             m1 := mload(0x20)
  3135 |     |             m2 := mload(0x40)
  3136 |     |             m3 := mload(0x60)
  3137 |     |             m4 := mload(0x80)
  3138 |     |             // Selector of `log(address,address,uint256,uint256)`.
  3139 |     |             mstore(0x00, 0xbe553481)
  3140 |     |             mstore(0x20, p0)
  3141 |     |             mstore(0x40, p1)
  3142 |     |             mstore(0x60, p2)
  3143 |     |             mstore(0x80, p3)
  3144 |     |         }
  3145 |     |         _sendLogPayload(0x1c, 0x84);
  3146 |     |         assembly {
  3147 |     |             mstore(0x00, m0)
  3148 |     |             mstore(0x20, m1)
  3149 |     |             mstore(0x40, m2)
  3150 |     |             mstore(0x60, m3)
  3151 |     |             mstore(0x80, m4)
  3152 |     |         }
  3153 |     |     }
  3154 |     | 
  3155 |     |     function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {
  3156 |     |         bytes32 m0;
  3157 |     |         bytes32 m1;
  3158 |     |         bytes32 m2;
  3159 |     |         bytes32 m3;
  3160 |     |         bytes32 m4;
  3161 |     |         bytes32 m5;
  3162 |     |         bytes32 m6;
  3163 |     |         assembly {
  3164 |     |             function writeString(pos, w) {
  3165 |     |                 let length := 0
  3166 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3167 |     |                 mstore(pos, length)
  3168 |     |                 let shift := sub(256, shl(3, length))
  3169 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3170 |     |             }
  3171 |     |             m0 := mload(0x00)
  3172 |     |             m1 := mload(0x20)
  3173 |     |             m2 := mload(0x40)
  3174 |     |             m3 := mload(0x60)
  3175 |     |             m4 := mload(0x80)
  3176 |     |             m5 := mload(0xa0)
  3177 |     |             m6 := mload(0xc0)
  3178 |     |             // Selector of `log(address,address,uint256,string)`.
  3179 |     |             mstore(0x00, 0xfdb4f990)
  3180 |     |             mstore(0x20, p0)
  3181 |     |             mstore(0x40, p1)
  3182 |     |             mstore(0x60, p2)
  3183 |     |             mstore(0x80, 0x80)
  3184 |     |             writeString(0xa0, p3)
  3185 |     |         }
  3186 |     |         _sendLogPayload(0x1c, 0xc4);
  3187 |     |         assembly {
  3188 |     |             mstore(0x00, m0)
  3189 |     |             mstore(0x20, m1)
  3190 |     |             mstore(0x40, m2)
  3191 |     |             mstore(0x60, m3)
  3192 |     |             mstore(0x80, m4)
  3193 |     |             mstore(0xa0, m5)
  3194 |     |             mstore(0xc0, m6)
  3195 |     |         }
  3196 |     |     }
  3197 |     | 
  3198 |     |     function log(address p0, address p1, bytes32 p2, address p3) internal pure {
  3199 |     |         bytes32 m0;
  3200 |     |         bytes32 m1;
  3201 |     |         bytes32 m2;
  3202 |     |         bytes32 m3;
  3203 |     |         bytes32 m4;
  3204 |     |         bytes32 m5;
  3205 |     |         bytes32 m6;
  3206 |     |         assembly {
  3207 |     |             function writeString(pos, w) {
  3208 |     |                 let length := 0
  3209 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3210 |     |                 mstore(pos, length)
  3211 |     |                 let shift := sub(256, shl(3, length))
  3212 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3213 |     |             }
  3214 |     |             m0 := mload(0x00)
  3215 |     |             m1 := mload(0x20)
  3216 |     |             m2 := mload(0x40)
  3217 |     |             m3 := mload(0x60)
  3218 |     |             m4 := mload(0x80)
  3219 |     |             m5 := mload(0xa0)
  3220 |     |             m6 := mload(0xc0)
  3221 |     |             // Selector of `log(address,address,string,address)`.
  3222 |     |             mstore(0x00, 0x8f736d16)
  3223 |     |             mstore(0x20, p0)
  3224 |     |             mstore(0x40, p1)
  3225 |     |             mstore(0x60, 0x80)
  3226 |     |             mstore(0x80, p3)
  3227 |     |             writeString(0xa0, p2)
  3228 |     |         }
  3229 |     |         _sendLogPayload(0x1c, 0xc4);
  3230 |     |         assembly {
  3231 |     |             mstore(0x00, m0)
  3232 |     |             mstore(0x20, m1)
  3233 |     |             mstore(0x40, m2)
  3234 |     |             mstore(0x60, m3)
  3235 |     |             mstore(0x80, m4)
  3236 |     |             mstore(0xa0, m5)
  3237 |     |             mstore(0xc0, m6)
  3238 |     |         }
  3239 |     |     }
  3240 |     | 
  3241 |     |     function log(address p0, address p1, bytes32 p2, bool p3) internal pure {
  3242 |     |         bytes32 m0;
  3243 |     |         bytes32 m1;
  3244 |     |         bytes32 m2;
  3245 |     |         bytes32 m3;
  3246 |     |         bytes32 m4;
  3247 |     |         bytes32 m5;
  3248 |     |         bytes32 m6;
  3249 |     |         assembly {
  3250 |     |             function writeString(pos, w) {
  3251 |     |                 let length := 0
  3252 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3253 |     |                 mstore(pos, length)
  3254 |     |                 let shift := sub(256, shl(3, length))
  3255 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3256 |     |             }
  3257 |     |             m0 := mload(0x00)
  3258 |     |             m1 := mload(0x20)
  3259 |     |             m2 := mload(0x40)
  3260 |     |             m3 := mload(0x60)
  3261 |     |             m4 := mload(0x80)
  3262 |     |             m5 := mload(0xa0)
  3263 |     |             m6 := mload(0xc0)
  3264 |     |             // Selector of `log(address,address,string,bool)`.
  3265 |     |             mstore(0x00, 0x6f1a594e)
  3266 |     |             mstore(0x20, p0)
  3267 |     |             mstore(0x40, p1)
  3268 |     |             mstore(0x60, 0x80)
  3269 |     |             mstore(0x80, p3)
  3270 |     |             writeString(0xa0, p2)
  3271 |     |         }
  3272 |     |         _sendLogPayload(0x1c, 0xc4);
  3273 |     |         assembly {
  3274 |     |             mstore(0x00, m0)
  3275 |     |             mstore(0x20, m1)
  3276 |     |             mstore(0x40, m2)
  3277 |     |             mstore(0x60, m3)
  3278 |     |             mstore(0x80, m4)
  3279 |     |             mstore(0xa0, m5)
  3280 |     |             mstore(0xc0, m6)
  3281 |     |         }
  3282 |     |     }
  3283 |     | 
  3284 |     |     function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {
  3285 |     |         bytes32 m0;
  3286 |     |         bytes32 m1;
  3287 |     |         bytes32 m2;
  3288 |     |         bytes32 m3;
  3289 |     |         bytes32 m4;
  3290 |     |         bytes32 m5;
  3291 |     |         bytes32 m6;
  3292 |     |         assembly {
  3293 |     |             function writeString(pos, w) {
  3294 |     |                 let length := 0
  3295 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3296 |     |                 mstore(pos, length)
  3297 |     |                 let shift := sub(256, shl(3, length))
  3298 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3299 |     |             }
  3300 |     |             m0 := mload(0x00)
  3301 |     |             m1 := mload(0x20)
  3302 |     |             m2 := mload(0x40)
  3303 |     |             m3 := mload(0x60)
  3304 |     |             m4 := mload(0x80)
  3305 |     |             m5 := mload(0xa0)
  3306 |     |             m6 := mload(0xc0)
  3307 |     |             // Selector of `log(address,address,string,uint256)`.
  3308 |     |             mstore(0x00, 0xef1cefe7)
  3309 |     |             mstore(0x20, p0)
  3310 |     |             mstore(0x40, p1)
  3311 |     |             mstore(0x60, 0x80)
  3312 |     |             mstore(0x80, p3)
  3313 |     |             writeString(0xa0, p2)
  3314 |     |         }
  3315 |     |         _sendLogPayload(0x1c, 0xc4);
  3316 |     |         assembly {
  3317 |     |             mstore(0x00, m0)
  3318 |     |             mstore(0x20, m1)
  3319 |     |             mstore(0x40, m2)
  3320 |     |             mstore(0x60, m3)
  3321 |     |             mstore(0x80, m4)
  3322 |     |             mstore(0xa0, m5)
  3323 |     |             mstore(0xc0, m6)
  3324 |     |         }
  3325 |     |     }
  3326 |     | 
  3327 |     |     function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  3328 |     |         bytes32 m0;
  3329 |     |         bytes32 m1;
  3330 |     |         bytes32 m2;
  3331 |     |         bytes32 m3;
  3332 |     |         bytes32 m4;
  3333 |     |         bytes32 m5;
  3334 |     |         bytes32 m6;
  3335 |     |         bytes32 m7;
  3336 |     |         bytes32 m8;
  3337 |     |         assembly {
  3338 |     |             function writeString(pos, w) {
  3339 |     |                 let length := 0
  3340 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3341 |     |                 mstore(pos, length)
  3342 |     |                 let shift := sub(256, shl(3, length))
  3343 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3344 |     |             }
  3345 |     |             m0 := mload(0x00)
  3346 |     |             m1 := mload(0x20)
  3347 |     |             m2 := mload(0x40)
  3348 |     |             m3 := mload(0x60)
  3349 |     |             m4 := mload(0x80)
  3350 |     |             m5 := mload(0xa0)
  3351 |     |             m6 := mload(0xc0)
  3352 |     |             m7 := mload(0xe0)
  3353 |     |             m8 := mload(0x100)
  3354 |     |             // Selector of `log(address,address,string,string)`.
  3355 |     |             mstore(0x00, 0x21bdaf25)
  3356 |     |             mstore(0x20, p0)
  3357 |     |             mstore(0x40, p1)
  3358 |     |             mstore(0x60, 0x80)
  3359 |     |             mstore(0x80, 0xc0)
  3360 |     |             writeString(0xa0, p2)
  3361 |     |             writeString(0xe0, p3)
  3362 |     |         }
  3363 |     |         _sendLogPayload(0x1c, 0x104);
  3364 |     |         assembly {
  3365 |     |             mstore(0x00, m0)
  3366 |     |             mstore(0x20, m1)
  3367 |     |             mstore(0x40, m2)
  3368 |     |             mstore(0x60, m3)
  3369 |     |             mstore(0x80, m4)
  3370 |     |             mstore(0xa0, m5)
  3371 |     |             mstore(0xc0, m6)
  3372 |     |             mstore(0xe0, m7)
  3373 |     |             mstore(0x100, m8)
  3374 |     |         }
  3375 |     |     }
  3376 |     | 
  3377 |     |     function log(address p0, bool p1, address p2, address p3) internal pure {
  3378 |     |         bytes32 m0;
  3379 |     |         bytes32 m1;
  3380 |     |         bytes32 m2;
  3381 |     |         bytes32 m3;
  3382 |     |         bytes32 m4;
  3383 |     |         assembly {
  3384 |     |             m0 := mload(0x00)
  3385 |     |             m1 := mload(0x20)
  3386 |     |             m2 := mload(0x40)
  3387 |     |             m3 := mload(0x60)
  3388 |     |             m4 := mload(0x80)
  3389 |     |             // Selector of `log(address,bool,address,address)`.
  3390 |     |             mstore(0x00, 0x660375dd)
  3391 |     |             mstore(0x20, p0)
  3392 |     |             mstore(0x40, p1)
  3393 |     |             mstore(0x60, p2)
  3394 |     |             mstore(0x80, p3)
  3395 |     |         }
  3396 |     |         _sendLogPayload(0x1c, 0x84);
  3397 |     |         assembly {
  3398 |     |             mstore(0x00, m0)
  3399 |     |             mstore(0x20, m1)
  3400 |     |             mstore(0x40, m2)
  3401 |     |             mstore(0x60, m3)
  3402 |     |             mstore(0x80, m4)
  3403 |     |         }
  3404 |     |     }
  3405 |     | 
  3406 |     |     function log(address p0, bool p1, address p2, bool p3) internal pure {
  3407 |     |         bytes32 m0;
  3408 |     |         bytes32 m1;
  3409 |     |         bytes32 m2;
  3410 |     |         bytes32 m3;
  3411 |     |         bytes32 m4;
  3412 |     |         assembly {
  3413 |     |             m0 := mload(0x00)
  3414 |     |             m1 := mload(0x20)
  3415 |     |             m2 := mload(0x40)
  3416 |     |             m3 := mload(0x60)
  3417 |     |             m4 := mload(0x80)
  3418 |     |             // Selector of `log(address,bool,address,bool)`.
  3419 |     |             mstore(0x00, 0xa6f50b0f)
  3420 |     |             mstore(0x20, p0)
  3421 |     |             mstore(0x40, p1)
  3422 |     |             mstore(0x60, p2)
  3423 |     |             mstore(0x80, p3)
  3424 |     |         }
  3425 |     |         _sendLogPayload(0x1c, 0x84);
  3426 |     |         assembly {
  3427 |     |             mstore(0x00, m0)
  3428 |     |             mstore(0x20, m1)
  3429 |     |             mstore(0x40, m2)
  3430 |     |             mstore(0x60, m3)
  3431 |     |             mstore(0x80, m4)
  3432 |     |         }
  3433 |     |     }
  3434 |     | 
  3435 |     |     function log(address p0, bool p1, address p2, uint256 p3) internal pure {
  3436 |     |         bytes32 m0;
  3437 |     |         bytes32 m1;
  3438 |     |         bytes32 m2;
  3439 |     |         bytes32 m3;
  3440 |     |         bytes32 m4;
  3441 |     |         assembly {
  3442 |     |             m0 := mload(0x00)
  3443 |     |             m1 := mload(0x20)
  3444 |     |             m2 := mload(0x40)
  3445 |     |             m3 := mload(0x60)
  3446 |     |             m4 := mload(0x80)
  3447 |     |             // Selector of `log(address,bool,address,uint256)`.
  3448 |     |             mstore(0x00, 0xa75c59de)
  3449 |     |             mstore(0x20, p0)
  3450 |     |             mstore(0x40, p1)
  3451 |     |             mstore(0x60, p2)
  3452 |     |             mstore(0x80, p3)
  3453 |     |         }
  3454 |     |         _sendLogPayload(0x1c, 0x84);
  3455 |     |         assembly {
  3456 |     |             mstore(0x00, m0)
  3457 |     |             mstore(0x20, m1)
  3458 |     |             mstore(0x40, m2)
  3459 |     |             mstore(0x60, m3)
  3460 |     |             mstore(0x80, m4)
  3461 |     |         }
  3462 |     |     }
  3463 |     | 
  3464 |     |     function log(address p0, bool p1, address p2, bytes32 p3) internal pure {
  3465 |     |         bytes32 m0;
  3466 |     |         bytes32 m1;
  3467 |     |         bytes32 m2;
  3468 |     |         bytes32 m3;
  3469 |     |         bytes32 m4;
  3470 |     |         bytes32 m5;
  3471 |     |         bytes32 m6;
  3472 |     |         assembly {
  3473 |     |             function writeString(pos, w) {
  3474 |     |                 let length := 0
  3475 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3476 |     |                 mstore(pos, length)
  3477 |     |                 let shift := sub(256, shl(3, length))
  3478 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3479 |     |             }
  3480 |     |             m0 := mload(0x00)
  3481 |     |             m1 := mload(0x20)
  3482 |     |             m2 := mload(0x40)
  3483 |     |             m3 := mload(0x60)
  3484 |     |             m4 := mload(0x80)
  3485 |     |             m5 := mload(0xa0)
  3486 |     |             m6 := mload(0xc0)
  3487 |     |             // Selector of `log(address,bool,address,string)`.
  3488 |     |             mstore(0x00, 0x2dd778e6)
  3489 |     |             mstore(0x20, p0)
  3490 |     |             mstore(0x40, p1)
  3491 |     |             mstore(0x60, p2)
  3492 |     |             mstore(0x80, 0x80)
  3493 |     |             writeString(0xa0, p3)
  3494 |     |         }
  3495 |     |         _sendLogPayload(0x1c, 0xc4);
  3496 |     |         assembly {
  3497 |     |             mstore(0x00, m0)
  3498 |     |             mstore(0x20, m1)
  3499 |     |             mstore(0x40, m2)
  3500 |     |             mstore(0x60, m3)
  3501 |     |             mstore(0x80, m4)
  3502 |     |             mstore(0xa0, m5)
  3503 |     |             mstore(0xc0, m6)
  3504 |     |         }
  3505 |     |     }
  3506 |     | 
  3507 |     |     function log(address p0, bool p1, bool p2, address p3) internal pure {
  3508 |     |         bytes32 m0;
  3509 |     |         bytes32 m1;
  3510 |     |         bytes32 m2;
  3511 |     |         bytes32 m3;
  3512 |     |         bytes32 m4;
  3513 |     |         assembly {
  3514 |     |             m0 := mload(0x00)
  3515 |     |             m1 := mload(0x20)
  3516 |     |             m2 := mload(0x40)
  3517 |     |             m3 := mload(0x60)
  3518 |     |             m4 := mload(0x80)
  3519 |     |             // Selector of `log(address,bool,bool,address)`.
  3520 |     |             mstore(0x00, 0xcf394485)
  3521 |     |             mstore(0x20, p0)
  3522 |     |             mstore(0x40, p1)
  3523 |     |             mstore(0x60, p2)
  3524 |     |             mstore(0x80, p3)
  3525 |     |         }
  3526 |     |         _sendLogPayload(0x1c, 0x84);
  3527 |     |         assembly {
  3528 |     |             mstore(0x00, m0)
  3529 |     |             mstore(0x20, m1)
  3530 |     |             mstore(0x40, m2)
  3531 |     |             mstore(0x60, m3)
  3532 |     |             mstore(0x80, m4)
  3533 |     |         }
  3534 |     |     }
  3535 |     | 
  3536 |     |     function log(address p0, bool p1, bool p2, bool p3) internal pure {
  3537 |     |         bytes32 m0;
  3538 |     |         bytes32 m1;
  3539 |     |         bytes32 m2;
  3540 |     |         bytes32 m3;
  3541 |     |         bytes32 m4;
  3542 |     |         assembly {
  3543 |     |             m0 := mload(0x00)
  3544 |     |             m1 := mload(0x20)
  3545 |     |             m2 := mload(0x40)
  3546 |     |             m3 := mload(0x60)
  3547 |     |             m4 := mload(0x80)
  3548 |     |             // Selector of `log(address,bool,bool,bool)`.
  3549 |     |             mstore(0x00, 0xcac43479)
  3550 |     |             mstore(0x20, p0)
  3551 |     |             mstore(0x40, p1)
  3552 |     |             mstore(0x60, p2)
  3553 |     |             mstore(0x80, p3)
  3554 |     |         }
  3555 |     |         _sendLogPayload(0x1c, 0x84);
  3556 |     |         assembly {
  3557 |     |             mstore(0x00, m0)
  3558 |     |             mstore(0x20, m1)
  3559 |     |             mstore(0x40, m2)
  3560 |     |             mstore(0x60, m3)
  3561 |     |             mstore(0x80, m4)
  3562 |     |         }
  3563 |     |     }
  3564 |     | 
  3565 |     |     function log(address p0, bool p1, bool p2, uint256 p3) internal pure {
  3566 |     |         bytes32 m0;
  3567 |     |         bytes32 m1;
  3568 |     |         bytes32 m2;
  3569 |     |         bytes32 m3;
  3570 |     |         bytes32 m4;
  3571 |     |         assembly {
  3572 |     |             m0 := mload(0x00)
  3573 |     |             m1 := mload(0x20)
  3574 |     |             m2 := mload(0x40)
  3575 |     |             m3 := mload(0x60)
  3576 |     |             m4 := mload(0x80)
  3577 |     |             // Selector of `log(address,bool,bool,uint256)`.
  3578 |     |             mstore(0x00, 0x8c4e5de6)
  3579 |     |             mstore(0x20, p0)
  3580 |     |             mstore(0x40, p1)
  3581 |     |             mstore(0x60, p2)
  3582 |     |             mstore(0x80, p3)
  3583 |     |         }
  3584 |     |         _sendLogPayload(0x1c, 0x84);
  3585 |     |         assembly {
  3586 |     |             mstore(0x00, m0)
  3587 |     |             mstore(0x20, m1)
  3588 |     |             mstore(0x40, m2)
  3589 |     |             mstore(0x60, m3)
  3590 |     |             mstore(0x80, m4)
  3591 |     |         }
  3592 |     |     }
  3593 |     | 
  3594 |     |     function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {
  3595 |     |         bytes32 m0;
  3596 |     |         bytes32 m1;
  3597 |     |         bytes32 m2;
  3598 |     |         bytes32 m3;
  3599 |     |         bytes32 m4;
  3600 |     |         bytes32 m5;
  3601 |     |         bytes32 m6;
  3602 |     |         assembly {
  3603 |     |             function writeString(pos, w) {
  3604 |     |                 let length := 0
  3605 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3606 |     |                 mstore(pos, length)
  3607 |     |                 let shift := sub(256, shl(3, length))
  3608 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3609 |     |             }
  3610 |     |             m0 := mload(0x00)
  3611 |     |             m1 := mload(0x20)
  3612 |     |             m2 := mload(0x40)
  3613 |     |             m3 := mload(0x60)
  3614 |     |             m4 := mload(0x80)
  3615 |     |             m5 := mload(0xa0)
  3616 |     |             m6 := mload(0xc0)
  3617 |     |             // Selector of `log(address,bool,bool,string)`.
  3618 |     |             mstore(0x00, 0xdfc4a2e8)
  3619 |     |             mstore(0x20, p0)
  3620 |     |             mstore(0x40, p1)
  3621 |     |             mstore(0x60, p2)
  3622 |     |             mstore(0x80, 0x80)
  3623 |     |             writeString(0xa0, p3)
  3624 |     |         }
  3625 |     |         _sendLogPayload(0x1c, 0xc4);
  3626 |     |         assembly {
  3627 |     |             mstore(0x00, m0)
  3628 |     |             mstore(0x20, m1)
  3629 |     |             mstore(0x40, m2)
  3630 |     |             mstore(0x60, m3)
  3631 |     |             mstore(0x80, m4)
  3632 |     |             mstore(0xa0, m5)
  3633 |     |             mstore(0xc0, m6)
  3634 |     |         }
  3635 |     |     }
  3636 |     | 
  3637 |     |     function log(address p0, bool p1, uint256 p2, address p3) internal pure {
  3638 |     |         bytes32 m0;
  3639 |     |         bytes32 m1;
  3640 |     |         bytes32 m2;
  3641 |     |         bytes32 m3;
  3642 |     |         bytes32 m4;
  3643 |     |         assembly {
  3644 |     |             m0 := mload(0x00)
  3645 |     |             m1 := mload(0x20)
  3646 |     |             m2 := mload(0x40)
  3647 |     |             m3 := mload(0x60)
  3648 |     |             m4 := mload(0x80)
  3649 |     |             // Selector of `log(address,bool,uint256,address)`.
  3650 |     |             mstore(0x00, 0xccf790a1)
  3651 |     |             mstore(0x20, p0)
  3652 |     |             mstore(0x40, p1)
  3653 |     |             mstore(0x60, p2)
  3654 |     |             mstore(0x80, p3)
  3655 |     |         }
  3656 |     |         _sendLogPayload(0x1c, 0x84);
  3657 |     |         assembly {
  3658 |     |             mstore(0x00, m0)
  3659 |     |             mstore(0x20, m1)
  3660 |     |             mstore(0x40, m2)
  3661 |     |             mstore(0x60, m3)
  3662 |     |             mstore(0x80, m4)
  3663 |     |         }
  3664 |     |     }
  3665 |     | 
  3666 |     |     function log(address p0, bool p1, uint256 p2, bool p3) internal pure {
  3667 |     |         bytes32 m0;
  3668 |     |         bytes32 m1;
  3669 |     |         bytes32 m2;
  3670 |     |         bytes32 m3;
  3671 |     |         bytes32 m4;
  3672 |     |         assembly {
  3673 |     |             m0 := mload(0x00)
  3674 |     |             m1 := mload(0x20)
  3675 |     |             m2 := mload(0x40)
  3676 |     |             m3 := mload(0x60)
  3677 |     |             m4 := mload(0x80)
  3678 |     |             // Selector of `log(address,bool,uint256,bool)`.
  3679 |     |             mstore(0x00, 0xc4643e20)
  3680 |     |             mstore(0x20, p0)
  3681 |     |             mstore(0x40, p1)
  3682 |     |             mstore(0x60, p2)
  3683 |     |             mstore(0x80, p3)
  3684 |     |         }
  3685 |     |         _sendLogPayload(0x1c, 0x84);
  3686 |     |         assembly {
  3687 |     |             mstore(0x00, m0)
  3688 |     |             mstore(0x20, m1)
  3689 |     |             mstore(0x40, m2)
  3690 |     |             mstore(0x60, m3)
  3691 |     |             mstore(0x80, m4)
  3692 |     |         }
  3693 |     |     }
  3694 |     | 
  3695 |     |     function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {
  3696 |     |         bytes32 m0;
  3697 |     |         bytes32 m1;
  3698 |     |         bytes32 m2;
  3699 |     |         bytes32 m3;
  3700 |     |         bytes32 m4;
  3701 |     |         assembly {
  3702 |     |             m0 := mload(0x00)
  3703 |     |             m1 := mload(0x20)
  3704 |     |             m2 := mload(0x40)
  3705 |     |             m3 := mload(0x60)
  3706 |     |             m4 := mload(0x80)
  3707 |     |             // Selector of `log(address,bool,uint256,uint256)`.
  3708 |     |             mstore(0x00, 0x386ff5f4)
  3709 |     |             mstore(0x20, p0)
  3710 |     |             mstore(0x40, p1)
  3711 |     |             mstore(0x60, p2)
  3712 |     |             mstore(0x80, p3)
  3713 |     |         }
  3714 |     |         _sendLogPayload(0x1c, 0x84);
  3715 |     |         assembly {
  3716 |     |             mstore(0x00, m0)
  3717 |     |             mstore(0x20, m1)
  3718 |     |             mstore(0x40, m2)
  3719 |     |             mstore(0x60, m3)
  3720 |     |             mstore(0x80, m4)
  3721 |     |         }
  3722 |     |     }
  3723 |     | 
  3724 |     |     function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  3725 |     |         bytes32 m0;
  3726 |     |         bytes32 m1;
  3727 |     |         bytes32 m2;
  3728 |     |         bytes32 m3;
  3729 |     |         bytes32 m4;
  3730 |     |         bytes32 m5;
  3731 |     |         bytes32 m6;
  3732 |     |         assembly {
  3733 |     |             function writeString(pos, w) {
  3734 |     |                 let length := 0
  3735 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3736 |     |                 mstore(pos, length)
  3737 |     |                 let shift := sub(256, shl(3, length))
  3738 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3739 |     |             }
  3740 |     |             m0 := mload(0x00)
  3741 |     |             m1 := mload(0x20)
  3742 |     |             m2 := mload(0x40)
  3743 |     |             m3 := mload(0x60)
  3744 |     |             m4 := mload(0x80)
  3745 |     |             m5 := mload(0xa0)
  3746 |     |             m6 := mload(0xc0)
  3747 |     |             // Selector of `log(address,bool,uint256,string)`.
  3748 |     |             mstore(0x00, 0x0aa6cfad)
  3749 |     |             mstore(0x20, p0)
  3750 |     |             mstore(0x40, p1)
  3751 |     |             mstore(0x60, p2)
  3752 |     |             mstore(0x80, 0x80)
  3753 |     |             writeString(0xa0, p3)
  3754 |     |         }
  3755 |     |         _sendLogPayload(0x1c, 0xc4);
  3756 |     |         assembly {
  3757 |     |             mstore(0x00, m0)
  3758 |     |             mstore(0x20, m1)
  3759 |     |             mstore(0x40, m2)
  3760 |     |             mstore(0x60, m3)
  3761 |     |             mstore(0x80, m4)
  3762 |     |             mstore(0xa0, m5)
  3763 |     |             mstore(0xc0, m6)
  3764 |     |         }
  3765 |     |     }
  3766 |     | 
  3767 |     |     function log(address p0, bool p1, bytes32 p2, address p3) internal pure {
  3768 |     |         bytes32 m0;
  3769 |     |         bytes32 m1;
  3770 |     |         bytes32 m2;
  3771 |     |         bytes32 m3;
  3772 |     |         bytes32 m4;
  3773 |     |         bytes32 m5;
  3774 |     |         bytes32 m6;
  3775 |     |         assembly {
  3776 |     |             function writeString(pos, w) {
  3777 |     |                 let length := 0
  3778 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3779 |     |                 mstore(pos, length)
  3780 |     |                 let shift := sub(256, shl(3, length))
  3781 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3782 |     |             }
  3783 |     |             m0 := mload(0x00)
  3784 |     |             m1 := mload(0x20)
  3785 |     |             m2 := mload(0x40)
  3786 |     |             m3 := mload(0x60)
  3787 |     |             m4 := mload(0x80)
  3788 |     |             m5 := mload(0xa0)
  3789 |     |             m6 := mload(0xc0)
  3790 |     |             // Selector of `log(address,bool,string,address)`.
  3791 |     |             mstore(0x00, 0x19fd4956)
  3792 |     |             mstore(0x20, p0)
  3793 |     |             mstore(0x40, p1)
  3794 |     |             mstore(0x60, 0x80)
  3795 |     |             mstore(0x80, p3)
  3796 |     |             writeString(0xa0, p2)
  3797 |     |         }
  3798 |     |         _sendLogPayload(0x1c, 0xc4);
  3799 |     |         assembly {
  3800 |     |             mstore(0x00, m0)
  3801 |     |             mstore(0x20, m1)
  3802 |     |             mstore(0x40, m2)
  3803 |     |             mstore(0x60, m3)
  3804 |     |             mstore(0x80, m4)
  3805 |     |             mstore(0xa0, m5)
  3806 |     |             mstore(0xc0, m6)
  3807 |     |         }
  3808 |     |     }
  3809 |     | 
  3810 |     |     function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {
  3811 |     |         bytes32 m0;
  3812 |     |         bytes32 m1;
  3813 |     |         bytes32 m2;
  3814 |     |         bytes32 m3;
  3815 |     |         bytes32 m4;
  3816 |     |         bytes32 m5;
  3817 |     |         bytes32 m6;
  3818 |     |         assembly {
  3819 |     |             function writeString(pos, w) {
  3820 |     |                 let length := 0
  3821 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3822 |     |                 mstore(pos, length)
  3823 |     |                 let shift := sub(256, shl(3, length))
  3824 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3825 |     |             }
  3826 |     |             m0 := mload(0x00)
  3827 |     |             m1 := mload(0x20)
  3828 |     |             m2 := mload(0x40)
  3829 |     |             m3 := mload(0x60)
  3830 |     |             m4 := mload(0x80)
  3831 |     |             m5 := mload(0xa0)
  3832 |     |             m6 := mload(0xc0)
  3833 |     |             // Selector of `log(address,bool,string,bool)`.
  3834 |     |             mstore(0x00, 0x50ad461d)
  3835 |     |             mstore(0x20, p0)
  3836 |     |             mstore(0x40, p1)
  3837 |     |             mstore(0x60, 0x80)
  3838 |     |             mstore(0x80, p3)
  3839 |     |             writeString(0xa0, p2)
  3840 |     |         }
  3841 |     |         _sendLogPayload(0x1c, 0xc4);
  3842 |     |         assembly {
  3843 |     |             mstore(0x00, m0)
  3844 |     |             mstore(0x20, m1)
  3845 |     |             mstore(0x40, m2)
  3846 |     |             mstore(0x60, m3)
  3847 |     |             mstore(0x80, m4)
  3848 |     |             mstore(0xa0, m5)
  3849 |     |             mstore(0xc0, m6)
  3850 |     |         }
  3851 |     |     }
  3852 |     | 
  3853 |     |     function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  3854 |     |         bytes32 m0;
  3855 |     |         bytes32 m1;
  3856 |     |         bytes32 m2;
  3857 |     |         bytes32 m3;
  3858 |     |         bytes32 m4;
  3859 |     |         bytes32 m5;
  3860 |     |         bytes32 m6;
  3861 |     |         assembly {
  3862 |     |             function writeString(pos, w) {
  3863 |     |                 let length := 0
  3864 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3865 |     |                 mstore(pos, length)
  3866 |     |                 let shift := sub(256, shl(3, length))
  3867 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3868 |     |             }
  3869 |     |             m0 := mload(0x00)
  3870 |     |             m1 := mload(0x20)
  3871 |     |             m2 := mload(0x40)
  3872 |     |             m3 := mload(0x60)
  3873 |     |             m4 := mload(0x80)
  3874 |     |             m5 := mload(0xa0)
  3875 |     |             m6 := mload(0xc0)
  3876 |     |             // Selector of `log(address,bool,string,uint256)`.
  3877 |     |             mstore(0x00, 0x80e6a20b)
  3878 |     |             mstore(0x20, p0)
  3879 |     |             mstore(0x40, p1)
  3880 |     |             mstore(0x60, 0x80)
  3881 |     |             mstore(0x80, p3)
  3882 |     |             writeString(0xa0, p2)
  3883 |     |         }
  3884 |     |         _sendLogPayload(0x1c, 0xc4);
  3885 |     |         assembly {
  3886 |     |             mstore(0x00, m0)
  3887 |     |             mstore(0x20, m1)
  3888 |     |             mstore(0x40, m2)
  3889 |     |             mstore(0x60, m3)
  3890 |     |             mstore(0x80, m4)
  3891 |     |             mstore(0xa0, m5)
  3892 |     |             mstore(0xc0, m6)
  3893 |     |         }
  3894 |     |     }
  3895 |     | 
  3896 |     |     function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  3897 |     |         bytes32 m0;
  3898 |     |         bytes32 m1;
  3899 |     |         bytes32 m2;
  3900 |     |         bytes32 m3;
  3901 |     |         bytes32 m4;
  3902 |     |         bytes32 m5;
  3903 |     |         bytes32 m6;
  3904 |     |         bytes32 m7;
  3905 |     |         bytes32 m8;
  3906 |     |         assembly {
  3907 |     |             function writeString(pos, w) {
  3908 |     |                 let length := 0
  3909 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  3910 |     |                 mstore(pos, length)
  3911 |     |                 let shift := sub(256, shl(3, length))
  3912 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  3913 |     |             }
  3914 |     |             m0 := mload(0x00)
  3915 |     |             m1 := mload(0x20)
  3916 |     |             m2 := mload(0x40)
  3917 |     |             m3 := mload(0x60)
  3918 |     |             m4 := mload(0x80)
  3919 |     |             m5 := mload(0xa0)
  3920 |     |             m6 := mload(0xc0)
  3921 |     |             m7 := mload(0xe0)
  3922 |     |             m8 := mload(0x100)
  3923 |     |             // Selector of `log(address,bool,string,string)`.
  3924 |     |             mstore(0x00, 0x475c5c33)
  3925 |     |             mstore(0x20, p0)
  3926 |     |             mstore(0x40, p1)
  3927 |     |             mstore(0x60, 0x80)
  3928 |     |             mstore(0x80, 0xc0)
  3929 |     |             writeString(0xa0, p2)
  3930 |     |             writeString(0xe0, p3)
  3931 |     |         }
  3932 |     |         _sendLogPayload(0x1c, 0x104);
  3933 |     |         assembly {
  3934 |     |             mstore(0x00, m0)
  3935 |     |             mstore(0x20, m1)
  3936 |     |             mstore(0x40, m2)
  3937 |     |             mstore(0x60, m3)
  3938 |     |             mstore(0x80, m4)
  3939 |     |             mstore(0xa0, m5)
  3940 |     |             mstore(0xc0, m6)
  3941 |     |             mstore(0xe0, m7)
  3942 |     |             mstore(0x100, m8)
  3943 |     |         }
  3944 |     |     }
  3945 |     | 
  3946 |     |     function log(address p0, uint256 p1, address p2, address p3) internal pure {
  3947 |     |         bytes32 m0;
  3948 |     |         bytes32 m1;
  3949 |     |         bytes32 m2;
  3950 |     |         bytes32 m3;
  3951 |     |         bytes32 m4;
  3952 |     |         assembly {
  3953 |     |             m0 := mload(0x00)
  3954 |     |             m1 := mload(0x20)
  3955 |     |             m2 := mload(0x40)
  3956 |     |             m3 := mload(0x60)
  3957 |     |             m4 := mload(0x80)
  3958 |     |             // Selector of `log(address,uint256,address,address)`.
  3959 |     |             mstore(0x00, 0x478d1c62)
  3960 |     |             mstore(0x20, p0)
  3961 |     |             mstore(0x40, p1)
  3962 |     |             mstore(0x60, p2)
  3963 |     |             mstore(0x80, p3)
  3964 |     |         }
  3965 |     |         _sendLogPayload(0x1c, 0x84);
  3966 |     |         assembly {
  3967 |     |             mstore(0x00, m0)
  3968 |     |             mstore(0x20, m1)
  3969 |     |             mstore(0x40, m2)
  3970 |     |             mstore(0x60, m3)
  3971 |     |             mstore(0x80, m4)
  3972 |     |         }
  3973 |     |     }
  3974 |     | 
  3975 |     |     function log(address p0, uint256 p1, address p2, bool p3) internal pure {
  3976 |     |         bytes32 m0;
  3977 |     |         bytes32 m1;
  3978 |     |         bytes32 m2;
  3979 |     |         bytes32 m3;
  3980 |     |         bytes32 m4;
  3981 |     |         assembly {
  3982 |     |             m0 := mload(0x00)
  3983 |     |             m1 := mload(0x20)
  3984 |     |             m2 := mload(0x40)
  3985 |     |             m3 := mload(0x60)
  3986 |     |             m4 := mload(0x80)
  3987 |     |             // Selector of `log(address,uint256,address,bool)`.
  3988 |     |             mstore(0x00, 0xa1bcc9b3)
  3989 |     |             mstore(0x20, p0)
  3990 |     |             mstore(0x40, p1)
  3991 |     |             mstore(0x60, p2)
  3992 |     |             mstore(0x80, p3)
  3993 |     |         }
  3994 |     |         _sendLogPayload(0x1c, 0x84);
  3995 |     |         assembly {
  3996 |     |             mstore(0x00, m0)
  3997 |     |             mstore(0x20, m1)
  3998 |     |             mstore(0x40, m2)
  3999 |     |             mstore(0x60, m3)
  4000 |     |             mstore(0x80, m4)
  4001 |     |         }
  4002 |     |     }
  4003 |     | 
  4004 |     |     function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {
  4005 |     |         bytes32 m0;
  4006 |     |         bytes32 m1;
  4007 |     |         bytes32 m2;
  4008 |     |         bytes32 m3;
  4009 |     |         bytes32 m4;
  4010 |     |         assembly {
  4011 |     |             m0 := mload(0x00)
  4012 |     |             m1 := mload(0x20)
  4013 |     |             m2 := mload(0x40)
  4014 |     |             m3 := mload(0x60)
  4015 |     |             m4 := mload(0x80)
  4016 |     |             // Selector of `log(address,uint256,address,uint256)`.
  4017 |     |             mstore(0x00, 0x100f650e)
  4018 |     |             mstore(0x20, p0)
  4019 |     |             mstore(0x40, p1)
  4020 |     |             mstore(0x60, p2)
  4021 |     |             mstore(0x80, p3)
  4022 |     |         }
  4023 |     |         _sendLogPayload(0x1c, 0x84);
  4024 |     |         assembly {
  4025 |     |             mstore(0x00, m0)
  4026 |     |             mstore(0x20, m1)
  4027 |     |             mstore(0x40, m2)
  4028 |     |             mstore(0x60, m3)
  4029 |     |             mstore(0x80, m4)
  4030 |     |         }
  4031 |     |     }
  4032 |     | 
  4033 |     |     function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {
  4034 |     |         bytes32 m0;
  4035 |     |         bytes32 m1;
  4036 |     |         bytes32 m2;
  4037 |     |         bytes32 m3;
  4038 |     |         bytes32 m4;
  4039 |     |         bytes32 m5;
  4040 |     |         bytes32 m6;
  4041 |     |         assembly {
  4042 |     |             function writeString(pos, w) {
  4043 |     |                 let length := 0
  4044 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4045 |     |                 mstore(pos, length)
  4046 |     |                 let shift := sub(256, shl(3, length))
  4047 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4048 |     |             }
  4049 |     |             m0 := mload(0x00)
  4050 |     |             m1 := mload(0x20)
  4051 |     |             m2 := mload(0x40)
  4052 |     |             m3 := mload(0x60)
  4053 |     |             m4 := mload(0x80)
  4054 |     |             m5 := mload(0xa0)
  4055 |     |             m6 := mload(0xc0)
  4056 |     |             // Selector of `log(address,uint256,address,string)`.
  4057 |     |             mstore(0x00, 0x1da986ea)
  4058 |     |             mstore(0x20, p0)
  4059 |     |             mstore(0x40, p1)
  4060 |     |             mstore(0x60, p2)
  4061 |     |             mstore(0x80, 0x80)
  4062 |     |             writeString(0xa0, p3)
  4063 |     |         }
  4064 |     |         _sendLogPayload(0x1c, 0xc4);
  4065 |     |         assembly {
  4066 |     |             mstore(0x00, m0)
  4067 |     |             mstore(0x20, m1)
  4068 |     |             mstore(0x40, m2)
  4069 |     |             mstore(0x60, m3)
  4070 |     |             mstore(0x80, m4)
  4071 |     |             mstore(0xa0, m5)
  4072 |     |             mstore(0xc0, m6)
  4073 |     |         }
  4074 |     |     }
  4075 |     | 
  4076 |     |     function log(address p0, uint256 p1, bool p2, address p3) internal pure {
  4077 |     |         bytes32 m0;
  4078 |     |         bytes32 m1;
  4079 |     |         bytes32 m2;
  4080 |     |         bytes32 m3;
  4081 |     |         bytes32 m4;
  4082 |     |         assembly {
  4083 |     |             m0 := mload(0x00)
  4084 |     |             m1 := mload(0x20)
  4085 |     |             m2 := mload(0x40)
  4086 |     |             m3 := mload(0x60)
  4087 |     |             m4 := mload(0x80)
  4088 |     |             // Selector of `log(address,uint256,bool,address)`.
  4089 |     |             mstore(0x00, 0xa31bfdcc)
  4090 |     |             mstore(0x20, p0)
  4091 |     |             mstore(0x40, p1)
  4092 |     |             mstore(0x60, p2)
  4093 |     |             mstore(0x80, p3)
  4094 |     |         }
  4095 |     |         _sendLogPayload(0x1c, 0x84);
  4096 |     |         assembly {
  4097 |     |             mstore(0x00, m0)
  4098 |     |             mstore(0x20, m1)
  4099 |     |             mstore(0x40, m2)
  4100 |     |             mstore(0x60, m3)
  4101 |     |             mstore(0x80, m4)
  4102 |     |         }
  4103 |     |     }
  4104 |     | 
  4105 |     |     function log(address p0, uint256 p1, bool p2, bool p3) internal pure {
  4106 |     |         bytes32 m0;
  4107 |     |         bytes32 m1;
  4108 |     |         bytes32 m2;
  4109 |     |         bytes32 m3;
  4110 |     |         bytes32 m4;
  4111 |     |         assembly {
  4112 |     |             m0 := mload(0x00)
  4113 |     |             m1 := mload(0x20)
  4114 |     |             m2 := mload(0x40)
  4115 |     |             m3 := mload(0x60)
  4116 |     |             m4 := mload(0x80)
  4117 |     |             // Selector of `log(address,uint256,bool,bool)`.
  4118 |     |             mstore(0x00, 0x3bf5e537)
  4119 |     |             mstore(0x20, p0)
  4120 |     |             mstore(0x40, p1)
  4121 |     |             mstore(0x60, p2)
  4122 |     |             mstore(0x80, p3)
  4123 |     |         }
  4124 |     |         _sendLogPayload(0x1c, 0x84);
  4125 |     |         assembly {
  4126 |     |             mstore(0x00, m0)
  4127 |     |             mstore(0x20, m1)
  4128 |     |             mstore(0x40, m2)
  4129 |     |             mstore(0x60, m3)
  4130 |     |             mstore(0x80, m4)
  4131 |     |         }
  4132 |     |     }
  4133 |     | 
  4134 |     |     function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {
  4135 |     |         bytes32 m0;
  4136 |     |         bytes32 m1;
  4137 |     |         bytes32 m2;
  4138 |     |         bytes32 m3;
  4139 |     |         bytes32 m4;
  4140 |     |         assembly {
  4141 |     |             m0 := mload(0x00)
  4142 |     |             m1 := mload(0x20)
  4143 |     |             m2 := mload(0x40)
  4144 |     |             m3 := mload(0x60)
  4145 |     |             m4 := mload(0x80)
  4146 |     |             // Selector of `log(address,uint256,bool,uint256)`.
  4147 |     |             mstore(0x00, 0x22f6b999)
  4148 |     |             mstore(0x20, p0)
  4149 |     |             mstore(0x40, p1)
  4150 |     |             mstore(0x60, p2)
  4151 |     |             mstore(0x80, p3)
  4152 |     |         }
  4153 |     |         _sendLogPayload(0x1c, 0x84);
  4154 |     |         assembly {
  4155 |     |             mstore(0x00, m0)
  4156 |     |             mstore(0x20, m1)
  4157 |     |             mstore(0x40, m2)
  4158 |     |             mstore(0x60, m3)
  4159 |     |             mstore(0x80, m4)
  4160 |     |         }
  4161 |     |     }
  4162 |     | 
  4163 |     |     function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  4164 |     |         bytes32 m0;
  4165 |     |         bytes32 m1;
  4166 |     |         bytes32 m2;
  4167 |     |         bytes32 m3;
  4168 |     |         bytes32 m4;
  4169 |     |         bytes32 m5;
  4170 |     |         bytes32 m6;
  4171 |     |         assembly {
  4172 |     |             function writeString(pos, w) {
  4173 |     |                 let length := 0
  4174 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4175 |     |                 mstore(pos, length)
  4176 |     |                 let shift := sub(256, shl(3, length))
  4177 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4178 |     |             }
  4179 |     |             m0 := mload(0x00)
  4180 |     |             m1 := mload(0x20)
  4181 |     |             m2 := mload(0x40)
  4182 |     |             m3 := mload(0x60)
  4183 |     |             m4 := mload(0x80)
  4184 |     |             m5 := mload(0xa0)
  4185 |     |             m6 := mload(0xc0)
  4186 |     |             // Selector of `log(address,uint256,bool,string)`.
  4187 |     |             mstore(0x00, 0xc5ad85f9)
  4188 |     |             mstore(0x20, p0)
  4189 |     |             mstore(0x40, p1)
  4190 |     |             mstore(0x60, p2)
  4191 |     |             mstore(0x80, 0x80)
  4192 |     |             writeString(0xa0, p3)
  4193 |     |         }
  4194 |     |         _sendLogPayload(0x1c, 0xc4);
  4195 |     |         assembly {
  4196 |     |             mstore(0x00, m0)
  4197 |     |             mstore(0x20, m1)
  4198 |     |             mstore(0x40, m2)
  4199 |     |             mstore(0x60, m3)
  4200 |     |             mstore(0x80, m4)
  4201 |     |             mstore(0xa0, m5)
  4202 |     |             mstore(0xc0, m6)
  4203 |     |         }
  4204 |     |     }
  4205 |     | 
  4206 |     |     function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {
  4207 |     |         bytes32 m0;
  4208 |     |         bytes32 m1;
  4209 |     |         bytes32 m2;
  4210 |     |         bytes32 m3;
  4211 |     |         bytes32 m4;
  4212 |     |         assembly {
  4213 |     |             m0 := mload(0x00)
  4214 |     |             m1 := mload(0x20)
  4215 |     |             m2 := mload(0x40)
  4216 |     |             m3 := mload(0x60)
  4217 |     |             m4 := mload(0x80)
  4218 |     |             // Selector of `log(address,uint256,uint256,address)`.
  4219 |     |             mstore(0x00, 0x20e3984d)
  4220 |     |             mstore(0x20, p0)
  4221 |     |             mstore(0x40, p1)
  4222 |     |             mstore(0x60, p2)
  4223 |     |             mstore(0x80, p3)
  4224 |     |         }
  4225 |     |         _sendLogPayload(0x1c, 0x84);
  4226 |     |         assembly {
  4227 |     |             mstore(0x00, m0)
  4228 |     |             mstore(0x20, m1)
  4229 |     |             mstore(0x40, m2)
  4230 |     |             mstore(0x60, m3)
  4231 |     |             mstore(0x80, m4)
  4232 |     |         }
  4233 |     |     }
  4234 |     | 
  4235 |     |     function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {
  4236 |     |         bytes32 m0;
  4237 |     |         bytes32 m1;
  4238 |     |         bytes32 m2;
  4239 |     |         bytes32 m3;
  4240 |     |         bytes32 m4;
  4241 |     |         assembly {
  4242 |     |             m0 := mload(0x00)
  4243 |     |             m1 := mload(0x20)
  4244 |     |             m2 := mload(0x40)
  4245 |     |             m3 := mload(0x60)
  4246 |     |             m4 := mload(0x80)
  4247 |     |             // Selector of `log(address,uint256,uint256,bool)`.
  4248 |     |             mstore(0x00, 0x66f1bc67)
  4249 |     |             mstore(0x20, p0)
  4250 |     |             mstore(0x40, p1)
  4251 |     |             mstore(0x60, p2)
  4252 |     |             mstore(0x80, p3)
  4253 |     |         }
  4254 |     |         _sendLogPayload(0x1c, 0x84);
  4255 |     |         assembly {
  4256 |     |             mstore(0x00, m0)
  4257 |     |             mstore(0x20, m1)
  4258 |     |             mstore(0x40, m2)
  4259 |     |             mstore(0x60, m3)
  4260 |     |             mstore(0x80, m4)
  4261 |     |         }
  4262 |     |     }
  4263 |     | 
  4264 |     |     function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  4265 |     |         bytes32 m0;
  4266 |     |         bytes32 m1;
  4267 |     |         bytes32 m2;
  4268 |     |         bytes32 m3;
  4269 |     |         bytes32 m4;
  4270 |     |         assembly {
  4271 |     |             m0 := mload(0x00)
  4272 |     |             m1 := mload(0x20)
  4273 |     |             m2 := mload(0x40)
  4274 |     |             m3 := mload(0x60)
  4275 |     |             m4 := mload(0x80)
  4276 |     |             // Selector of `log(address,uint256,uint256,uint256)`.
  4277 |     |             mstore(0x00, 0x34f0e636)
  4278 |     |             mstore(0x20, p0)
  4279 |     |             mstore(0x40, p1)
  4280 |     |             mstore(0x60, p2)
  4281 |     |             mstore(0x80, p3)
  4282 |     |         }
  4283 |     |         _sendLogPayload(0x1c, 0x84);
  4284 |     |         assembly {
  4285 |     |             mstore(0x00, m0)
  4286 |     |             mstore(0x20, m1)
  4287 |     |             mstore(0x40, m2)
  4288 |     |             mstore(0x60, m3)
  4289 |     |             mstore(0x80, m4)
  4290 |     |         }
  4291 |     |     }
  4292 |     | 
  4293 |     |     function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  4294 |     |         bytes32 m0;
  4295 |     |         bytes32 m1;
  4296 |     |         bytes32 m2;
  4297 |     |         bytes32 m3;
  4298 |     |         bytes32 m4;
  4299 |     |         bytes32 m5;
  4300 |     |         bytes32 m6;
  4301 |     |         assembly {
  4302 |     |             function writeString(pos, w) {
  4303 |     |                 let length := 0
  4304 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4305 |     |                 mstore(pos, length)
  4306 |     |                 let shift := sub(256, shl(3, length))
  4307 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4308 |     |             }
  4309 |     |             m0 := mload(0x00)
  4310 |     |             m1 := mload(0x20)
  4311 |     |             m2 := mload(0x40)
  4312 |     |             m3 := mload(0x60)
  4313 |     |             m4 := mload(0x80)
  4314 |     |             m5 := mload(0xa0)
  4315 |     |             m6 := mload(0xc0)
  4316 |     |             // Selector of `log(address,uint256,uint256,string)`.
  4317 |     |             mstore(0x00, 0x4a28c017)
  4318 |     |             mstore(0x20, p0)
  4319 |     |             mstore(0x40, p1)
  4320 |     |             mstore(0x60, p2)
  4321 |     |             mstore(0x80, 0x80)
  4322 |     |             writeString(0xa0, p3)
  4323 |     |         }
  4324 |     |         _sendLogPayload(0x1c, 0xc4);
  4325 |     |         assembly {
  4326 |     |             mstore(0x00, m0)
  4327 |     |             mstore(0x20, m1)
  4328 |     |             mstore(0x40, m2)
  4329 |     |             mstore(0x60, m3)
  4330 |     |             mstore(0x80, m4)
  4331 |     |             mstore(0xa0, m5)
  4332 |     |             mstore(0xc0, m6)
  4333 |     |         }
  4334 |     |     }
  4335 |     | 
  4336 |     |     function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {
  4337 |     |         bytes32 m0;
  4338 |     |         bytes32 m1;
  4339 |     |         bytes32 m2;
  4340 |     |         bytes32 m3;
  4341 |     |         bytes32 m4;
  4342 |     |         bytes32 m5;
  4343 |     |         bytes32 m6;
  4344 |     |         assembly {
  4345 |     |             function writeString(pos, w) {
  4346 |     |                 let length := 0
  4347 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4348 |     |                 mstore(pos, length)
  4349 |     |                 let shift := sub(256, shl(3, length))
  4350 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4351 |     |             }
  4352 |     |             m0 := mload(0x00)
  4353 |     |             m1 := mload(0x20)
  4354 |     |             m2 := mload(0x40)
  4355 |     |             m3 := mload(0x60)
  4356 |     |             m4 := mload(0x80)
  4357 |     |             m5 := mload(0xa0)
  4358 |     |             m6 := mload(0xc0)
  4359 |     |             // Selector of `log(address,uint256,string,address)`.
  4360 |     |             mstore(0x00, 0x5c430d47)
  4361 |     |             mstore(0x20, p0)
  4362 |     |             mstore(0x40, p1)
  4363 |     |             mstore(0x60, 0x80)
  4364 |     |             mstore(0x80, p3)
  4365 |     |             writeString(0xa0, p2)
  4366 |     |         }
  4367 |     |         _sendLogPayload(0x1c, 0xc4);
  4368 |     |         assembly {
  4369 |     |             mstore(0x00, m0)
  4370 |     |             mstore(0x20, m1)
  4371 |     |             mstore(0x40, m2)
  4372 |     |             mstore(0x60, m3)
  4373 |     |             mstore(0x80, m4)
  4374 |     |             mstore(0xa0, m5)
  4375 |     |             mstore(0xc0, m6)
  4376 |     |         }
  4377 |     |     }
  4378 |     | 
  4379 |     |     function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  4380 |     |         bytes32 m0;
  4381 |     |         bytes32 m1;
  4382 |     |         bytes32 m2;
  4383 |     |         bytes32 m3;
  4384 |     |         bytes32 m4;
  4385 |     |         bytes32 m5;
  4386 |     |         bytes32 m6;
  4387 |     |         assembly {
  4388 |     |             function writeString(pos, w) {
  4389 |     |                 let length := 0
  4390 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4391 |     |                 mstore(pos, length)
  4392 |     |                 let shift := sub(256, shl(3, length))
  4393 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4394 |     |             }
  4395 |     |             m0 := mload(0x00)
  4396 |     |             m1 := mload(0x20)
  4397 |     |             m2 := mload(0x40)
  4398 |     |             m3 := mload(0x60)
  4399 |     |             m4 := mload(0x80)
  4400 |     |             m5 := mload(0xa0)
  4401 |     |             m6 := mload(0xc0)
  4402 |     |             // Selector of `log(address,uint256,string,bool)`.
  4403 |     |             mstore(0x00, 0xcf18105c)
  4404 |     |             mstore(0x20, p0)
  4405 |     |             mstore(0x40, p1)
  4406 |     |             mstore(0x60, 0x80)
  4407 |     |             mstore(0x80, p3)
  4408 |     |             writeString(0xa0, p2)
  4409 |     |         }
  4410 |     |         _sendLogPayload(0x1c, 0xc4);
  4411 |     |         assembly {
  4412 |     |             mstore(0x00, m0)
  4413 |     |             mstore(0x20, m1)
  4414 |     |             mstore(0x40, m2)
  4415 |     |             mstore(0x60, m3)
  4416 |     |             mstore(0x80, m4)
  4417 |     |             mstore(0xa0, m5)
  4418 |     |             mstore(0xc0, m6)
  4419 |     |         }
  4420 |     |     }
  4421 |     | 
  4422 |     |     function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  4423 |     |         bytes32 m0;
  4424 |     |         bytes32 m1;
  4425 |     |         bytes32 m2;
  4426 |     |         bytes32 m3;
  4427 |     |         bytes32 m4;
  4428 |     |         bytes32 m5;
  4429 |     |         bytes32 m6;
  4430 |     |         assembly {
  4431 |     |             function writeString(pos, w) {
  4432 |     |                 let length := 0
  4433 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4434 |     |                 mstore(pos, length)
  4435 |     |                 let shift := sub(256, shl(3, length))
  4436 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4437 |     |             }
  4438 |     |             m0 := mload(0x00)
  4439 |     |             m1 := mload(0x20)
  4440 |     |             m2 := mload(0x40)
  4441 |     |             m3 := mload(0x60)
  4442 |     |             m4 := mload(0x80)
  4443 |     |             m5 := mload(0xa0)
  4444 |     |             m6 := mload(0xc0)
  4445 |     |             // Selector of `log(address,uint256,string,uint256)`.
  4446 |     |             mstore(0x00, 0xbf01f891)
  4447 |     |             mstore(0x20, p0)
  4448 |     |             mstore(0x40, p1)
  4449 |     |             mstore(0x60, 0x80)
  4450 |     |             mstore(0x80, p3)
  4451 |     |             writeString(0xa0, p2)
  4452 |     |         }
  4453 |     |         _sendLogPayload(0x1c, 0xc4);
  4454 |     |         assembly {
  4455 |     |             mstore(0x00, m0)
  4456 |     |             mstore(0x20, m1)
  4457 |     |             mstore(0x40, m2)
  4458 |     |             mstore(0x60, m3)
  4459 |     |             mstore(0x80, m4)
  4460 |     |             mstore(0xa0, m5)
  4461 |     |             mstore(0xc0, m6)
  4462 |     |         }
  4463 |     |     }
  4464 |     | 
  4465 |     |     function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  4466 |     |         bytes32 m0;
  4467 |     |         bytes32 m1;
  4468 |     |         bytes32 m2;
  4469 |     |         bytes32 m3;
  4470 |     |         bytes32 m4;
  4471 |     |         bytes32 m5;
  4472 |     |         bytes32 m6;
  4473 |     |         bytes32 m7;
  4474 |     |         bytes32 m8;
  4475 |     |         assembly {
  4476 |     |             function writeString(pos, w) {
  4477 |     |                 let length := 0
  4478 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4479 |     |                 mstore(pos, length)
  4480 |     |                 let shift := sub(256, shl(3, length))
  4481 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4482 |     |             }
  4483 |     |             m0 := mload(0x00)
  4484 |     |             m1 := mload(0x20)
  4485 |     |             m2 := mload(0x40)
  4486 |     |             m3 := mload(0x60)
  4487 |     |             m4 := mload(0x80)
  4488 |     |             m5 := mload(0xa0)
  4489 |     |             m6 := mload(0xc0)
  4490 |     |             m7 := mload(0xe0)
  4491 |     |             m8 := mload(0x100)
  4492 |     |             // Selector of `log(address,uint256,string,string)`.
  4493 |     |             mstore(0x00, 0x88a8c406)
  4494 |     |             mstore(0x20, p0)
  4495 |     |             mstore(0x40, p1)
  4496 |     |             mstore(0x60, 0x80)
  4497 |     |             mstore(0x80, 0xc0)
  4498 |     |             writeString(0xa0, p2)
  4499 |     |             writeString(0xe0, p3)
  4500 |     |         }
  4501 |     |         _sendLogPayload(0x1c, 0x104);
  4502 |     |         assembly {
  4503 |     |             mstore(0x00, m0)
  4504 |     |             mstore(0x20, m1)
  4505 |     |             mstore(0x40, m2)
  4506 |     |             mstore(0x60, m3)
  4507 |     |             mstore(0x80, m4)
  4508 |     |             mstore(0xa0, m5)
  4509 |     |             mstore(0xc0, m6)
  4510 |     |             mstore(0xe0, m7)
  4511 |     |             mstore(0x100, m8)
  4512 |     |         }
  4513 |     |     }
  4514 |     | 
  4515 |     |     function log(address p0, bytes32 p1, address p2, address p3) internal pure {
  4516 |     |         bytes32 m0;
  4517 |     |         bytes32 m1;
  4518 |     |         bytes32 m2;
  4519 |     |         bytes32 m3;
  4520 |     |         bytes32 m4;
  4521 |     |         bytes32 m5;
  4522 |     |         bytes32 m6;
  4523 |     |         assembly {
  4524 |     |             function writeString(pos, w) {
  4525 |     |                 let length := 0
  4526 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4527 |     |                 mstore(pos, length)
  4528 |     |                 let shift := sub(256, shl(3, length))
  4529 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4530 |     |             }
  4531 |     |             m0 := mload(0x00)
  4532 |     |             m1 := mload(0x20)
  4533 |     |             m2 := mload(0x40)
  4534 |     |             m3 := mload(0x60)
  4535 |     |             m4 := mload(0x80)
  4536 |     |             m5 := mload(0xa0)
  4537 |     |             m6 := mload(0xc0)
  4538 |     |             // Selector of `log(address,string,address,address)`.
  4539 |     |             mstore(0x00, 0x0d36fa20)
  4540 |     |             mstore(0x20, p0)
  4541 |     |             mstore(0x40, 0x80)
  4542 |     |             mstore(0x60, p2)
  4543 |     |             mstore(0x80, p3)
  4544 |     |             writeString(0xa0, p1)
  4545 |     |         }
  4546 |     |         _sendLogPayload(0x1c, 0xc4);
  4547 |     |         assembly {
  4548 |     |             mstore(0x00, m0)
  4549 |     |             mstore(0x20, m1)
  4550 |     |             mstore(0x40, m2)
  4551 |     |             mstore(0x60, m3)
  4552 |     |             mstore(0x80, m4)
  4553 |     |             mstore(0xa0, m5)
  4554 |     |             mstore(0xc0, m6)
  4555 |     |         }
  4556 |     |     }
  4557 |     | 
  4558 |     |     function log(address p0, bytes32 p1, address p2, bool p3) internal pure {
  4559 |     |         bytes32 m0;
  4560 |     |         bytes32 m1;
  4561 |     |         bytes32 m2;
  4562 |     |         bytes32 m3;
  4563 |     |         bytes32 m4;
  4564 |     |         bytes32 m5;
  4565 |     |         bytes32 m6;
  4566 |     |         assembly {
  4567 |     |             function writeString(pos, w) {
  4568 |     |                 let length := 0
  4569 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4570 |     |                 mstore(pos, length)
  4571 |     |                 let shift := sub(256, shl(3, length))
  4572 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4573 |     |             }
  4574 |     |             m0 := mload(0x00)
  4575 |     |             m1 := mload(0x20)
  4576 |     |             m2 := mload(0x40)
  4577 |     |             m3 := mload(0x60)
  4578 |     |             m4 := mload(0x80)
  4579 |     |             m5 := mload(0xa0)
  4580 |     |             m6 := mload(0xc0)
  4581 |     |             // Selector of `log(address,string,address,bool)`.
  4582 |     |             mstore(0x00, 0x0df12b76)
  4583 |     |             mstore(0x20, p0)
  4584 |     |             mstore(0x40, 0x80)
  4585 |     |             mstore(0x60, p2)
  4586 |     |             mstore(0x80, p3)
  4587 |     |             writeString(0xa0, p1)
  4588 |     |         }
  4589 |     |         _sendLogPayload(0x1c, 0xc4);
  4590 |     |         assembly {
  4591 |     |             mstore(0x00, m0)
  4592 |     |             mstore(0x20, m1)
  4593 |     |             mstore(0x40, m2)
  4594 |     |             mstore(0x60, m3)
  4595 |     |             mstore(0x80, m4)
  4596 |     |             mstore(0xa0, m5)
  4597 |     |             mstore(0xc0, m6)
  4598 |     |         }
  4599 |     |     }
  4600 |     | 
  4601 |     |     function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {
  4602 |     |         bytes32 m0;
  4603 |     |         bytes32 m1;
  4604 |     |         bytes32 m2;
  4605 |     |         bytes32 m3;
  4606 |     |         bytes32 m4;
  4607 |     |         bytes32 m5;
  4608 |     |         bytes32 m6;
  4609 |     |         assembly {
  4610 |     |             function writeString(pos, w) {
  4611 |     |                 let length := 0
  4612 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4613 |     |                 mstore(pos, length)
  4614 |     |                 let shift := sub(256, shl(3, length))
  4615 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4616 |     |             }
  4617 |     |             m0 := mload(0x00)
  4618 |     |             m1 := mload(0x20)
  4619 |     |             m2 := mload(0x40)
  4620 |     |             m3 := mload(0x60)
  4621 |     |             m4 := mload(0x80)
  4622 |     |             m5 := mload(0xa0)
  4623 |     |             m6 := mload(0xc0)
  4624 |     |             // Selector of `log(address,string,address,uint256)`.
  4625 |     |             mstore(0x00, 0x457fe3cf)
  4626 |     |             mstore(0x20, p0)
  4627 |     |             mstore(0x40, 0x80)
  4628 |     |             mstore(0x60, p2)
  4629 |     |             mstore(0x80, p3)
  4630 |     |             writeString(0xa0, p1)
  4631 |     |         }
  4632 |     |         _sendLogPayload(0x1c, 0xc4);
  4633 |     |         assembly {
  4634 |     |             mstore(0x00, m0)
  4635 |     |             mstore(0x20, m1)
  4636 |     |             mstore(0x40, m2)
  4637 |     |             mstore(0x60, m3)
  4638 |     |             mstore(0x80, m4)
  4639 |     |             mstore(0xa0, m5)
  4640 |     |             mstore(0xc0, m6)
  4641 |     |         }
  4642 |     |     }
  4643 |     | 
  4644 |     |     function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  4645 |     |         bytes32 m0;
  4646 |     |         bytes32 m1;
  4647 |     |         bytes32 m2;
  4648 |     |         bytes32 m3;
  4649 |     |         bytes32 m4;
  4650 |     |         bytes32 m5;
  4651 |     |         bytes32 m6;
  4652 |     |         bytes32 m7;
  4653 |     |         bytes32 m8;
  4654 |     |         assembly {
  4655 |     |             function writeString(pos, w) {
  4656 |     |                 let length := 0
  4657 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4658 |     |                 mstore(pos, length)
  4659 |     |                 let shift := sub(256, shl(3, length))
  4660 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4661 |     |             }
  4662 |     |             m0 := mload(0x00)
  4663 |     |             m1 := mload(0x20)
  4664 |     |             m2 := mload(0x40)
  4665 |     |             m3 := mload(0x60)
  4666 |     |             m4 := mload(0x80)
  4667 |     |             m5 := mload(0xa0)
  4668 |     |             m6 := mload(0xc0)
  4669 |     |             m7 := mload(0xe0)
  4670 |     |             m8 := mload(0x100)
  4671 |     |             // Selector of `log(address,string,address,string)`.
  4672 |     |             mstore(0x00, 0xf7e36245)
  4673 |     |             mstore(0x20, p0)
  4674 |     |             mstore(0x40, 0x80)
  4675 |     |             mstore(0x60, p2)
  4676 |     |             mstore(0x80, 0xc0)
  4677 |     |             writeString(0xa0, p1)
  4678 |     |             writeString(0xe0, p3)
  4679 |     |         }
  4680 |     |         _sendLogPayload(0x1c, 0x104);
  4681 |     |         assembly {
  4682 |     |             mstore(0x00, m0)
  4683 |     |             mstore(0x20, m1)
  4684 |     |             mstore(0x40, m2)
  4685 |     |             mstore(0x60, m3)
  4686 |     |             mstore(0x80, m4)
  4687 |     |             mstore(0xa0, m5)
  4688 |     |             mstore(0xc0, m6)
  4689 |     |             mstore(0xe0, m7)
  4690 |     |             mstore(0x100, m8)
  4691 |     |         }
  4692 |     |     }
  4693 |     | 
  4694 |     |     function log(address p0, bytes32 p1, bool p2, address p3) internal pure {
  4695 |     |         bytes32 m0;
  4696 |     |         bytes32 m1;
  4697 |     |         bytes32 m2;
  4698 |     |         bytes32 m3;
  4699 |     |         bytes32 m4;
  4700 |     |         bytes32 m5;
  4701 |     |         bytes32 m6;
  4702 |     |         assembly {
  4703 |     |             function writeString(pos, w) {
  4704 |     |                 let length := 0
  4705 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4706 |     |                 mstore(pos, length)
  4707 |     |                 let shift := sub(256, shl(3, length))
  4708 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4709 |     |             }
  4710 |     |             m0 := mload(0x00)
  4711 |     |             m1 := mload(0x20)
  4712 |     |             m2 := mload(0x40)
  4713 |     |             m3 := mload(0x60)
  4714 |     |             m4 := mload(0x80)
  4715 |     |             m5 := mload(0xa0)
  4716 |     |             m6 := mload(0xc0)
  4717 |     |             // Selector of `log(address,string,bool,address)`.
  4718 |     |             mstore(0x00, 0x205871c2)
  4719 |     |             mstore(0x20, p0)
  4720 |     |             mstore(0x40, 0x80)
  4721 |     |             mstore(0x60, p2)
  4722 |     |             mstore(0x80, p3)
  4723 |     |             writeString(0xa0, p1)
  4724 |     |         }
  4725 |     |         _sendLogPayload(0x1c, 0xc4);
  4726 |     |         assembly {
  4727 |     |             mstore(0x00, m0)
  4728 |     |             mstore(0x20, m1)
  4729 |     |             mstore(0x40, m2)
  4730 |     |             mstore(0x60, m3)
  4731 |     |             mstore(0x80, m4)
  4732 |     |             mstore(0xa0, m5)
  4733 |     |             mstore(0xc0, m6)
  4734 |     |         }
  4735 |     |     }
  4736 |     | 
  4737 |     |     function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {
  4738 |     |         bytes32 m0;
  4739 |     |         bytes32 m1;
  4740 |     |         bytes32 m2;
  4741 |     |         bytes32 m3;
  4742 |     |         bytes32 m4;
  4743 |     |         bytes32 m5;
  4744 |     |         bytes32 m6;
  4745 |     |         assembly {
  4746 |     |             function writeString(pos, w) {
  4747 |     |                 let length := 0
  4748 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4749 |     |                 mstore(pos, length)
  4750 |     |                 let shift := sub(256, shl(3, length))
  4751 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4752 |     |             }
  4753 |     |             m0 := mload(0x00)
  4754 |     |             m1 := mload(0x20)
  4755 |     |             m2 := mload(0x40)
  4756 |     |             m3 := mload(0x60)
  4757 |     |             m4 := mload(0x80)
  4758 |     |             m5 := mload(0xa0)
  4759 |     |             m6 := mload(0xc0)
  4760 |     |             // Selector of `log(address,string,bool,bool)`.
  4761 |     |             mstore(0x00, 0x5f1d5c9f)
  4762 |     |             mstore(0x20, p0)
  4763 |     |             mstore(0x40, 0x80)
  4764 |     |             mstore(0x60, p2)
  4765 |     |             mstore(0x80, p3)
  4766 |     |             writeString(0xa0, p1)
  4767 |     |         }
  4768 |     |         _sendLogPayload(0x1c, 0xc4);
  4769 |     |         assembly {
  4770 |     |             mstore(0x00, m0)
  4771 |     |             mstore(0x20, m1)
  4772 |     |             mstore(0x40, m2)
  4773 |     |             mstore(0x60, m3)
  4774 |     |             mstore(0x80, m4)
  4775 |     |             mstore(0xa0, m5)
  4776 |     |             mstore(0xc0, m6)
  4777 |     |         }
  4778 |     |     }
  4779 |     | 
  4780 |     |     function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  4781 |     |         bytes32 m0;
  4782 |     |         bytes32 m1;
  4783 |     |         bytes32 m2;
  4784 |     |         bytes32 m3;
  4785 |     |         bytes32 m4;
  4786 |     |         bytes32 m5;
  4787 |     |         bytes32 m6;
  4788 |     |         assembly {
  4789 |     |             function writeString(pos, w) {
  4790 |     |                 let length := 0
  4791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4792 |     |                 mstore(pos, length)
  4793 |     |                 let shift := sub(256, shl(3, length))
  4794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4795 |     |             }
  4796 |     |             m0 := mload(0x00)
  4797 |     |             m1 := mload(0x20)
  4798 |     |             m2 := mload(0x40)
  4799 |     |             m3 := mload(0x60)
  4800 |     |             m4 := mload(0x80)
  4801 |     |             m5 := mload(0xa0)
  4802 |     |             m6 := mload(0xc0)
  4803 |     |             // Selector of `log(address,string,bool,uint256)`.
  4804 |     |             mstore(0x00, 0x515e38b6)
  4805 |     |             mstore(0x20, p0)
  4806 |     |             mstore(0x40, 0x80)
  4807 |     |             mstore(0x60, p2)
  4808 |     |             mstore(0x80, p3)
  4809 |     |             writeString(0xa0, p1)
  4810 |     |         }
  4811 |     |         _sendLogPayload(0x1c, 0xc4);
  4812 |     |         assembly {
  4813 |     |             mstore(0x00, m0)
  4814 |     |             mstore(0x20, m1)
  4815 |     |             mstore(0x40, m2)
  4816 |     |             mstore(0x60, m3)
  4817 |     |             mstore(0x80, m4)
  4818 |     |             mstore(0xa0, m5)
  4819 |     |             mstore(0xc0, m6)
  4820 |     |         }
  4821 |     |     }
  4822 |     | 
  4823 |     |     function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  4824 |     |         bytes32 m0;
  4825 |     |         bytes32 m1;
  4826 |     |         bytes32 m2;
  4827 |     |         bytes32 m3;
  4828 |     |         bytes32 m4;
  4829 |     |         bytes32 m5;
  4830 |     |         bytes32 m6;
  4831 |     |         bytes32 m7;
  4832 |     |         bytes32 m8;
  4833 |     |         assembly {
  4834 |     |             function writeString(pos, w) {
  4835 |     |                 let length := 0
  4836 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4837 |     |                 mstore(pos, length)
  4838 |     |                 let shift := sub(256, shl(3, length))
  4839 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4840 |     |             }
  4841 |     |             m0 := mload(0x00)
  4842 |     |             m1 := mload(0x20)
  4843 |     |             m2 := mload(0x40)
  4844 |     |             m3 := mload(0x60)
  4845 |     |             m4 := mload(0x80)
  4846 |     |             m5 := mload(0xa0)
  4847 |     |             m6 := mload(0xc0)
  4848 |     |             m7 := mload(0xe0)
  4849 |     |             m8 := mload(0x100)
  4850 |     |             // Selector of `log(address,string,bool,string)`.
  4851 |     |             mstore(0x00, 0xbc0b61fe)
  4852 |     |             mstore(0x20, p0)
  4853 |     |             mstore(0x40, 0x80)
  4854 |     |             mstore(0x60, p2)
  4855 |     |             mstore(0x80, 0xc0)
  4856 |     |             writeString(0xa0, p1)
  4857 |     |             writeString(0xe0, p3)
  4858 |     |         }
  4859 |     |         _sendLogPayload(0x1c, 0x104);
  4860 |     |         assembly {
  4861 |     |             mstore(0x00, m0)
  4862 |     |             mstore(0x20, m1)
  4863 |     |             mstore(0x40, m2)
  4864 |     |             mstore(0x60, m3)
  4865 |     |             mstore(0x80, m4)
  4866 |     |             mstore(0xa0, m5)
  4867 |     |             mstore(0xc0, m6)
  4868 |     |             mstore(0xe0, m7)
  4869 |     |             mstore(0x100, m8)
  4870 |     |         }
  4871 |     |     }
  4872 |     | 
  4873 |     |     function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {
  4874 |     |         bytes32 m0;
  4875 |     |         bytes32 m1;
  4876 |     |         bytes32 m2;
  4877 |     |         bytes32 m3;
  4878 |     |         bytes32 m4;
  4879 |     |         bytes32 m5;
  4880 |     |         bytes32 m6;
  4881 |     |         assembly {
  4882 |     |             function writeString(pos, w) {
  4883 |     |                 let length := 0
  4884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4885 |     |                 mstore(pos, length)
  4886 |     |                 let shift := sub(256, shl(3, length))
  4887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4888 |     |             }
  4889 |     |             m0 := mload(0x00)
  4890 |     |             m1 := mload(0x20)
  4891 |     |             m2 := mload(0x40)
  4892 |     |             m3 := mload(0x60)
  4893 |     |             m4 := mload(0x80)
  4894 |     |             m5 := mload(0xa0)
  4895 |     |             m6 := mload(0xc0)
  4896 |     |             // Selector of `log(address,string,uint256,address)`.
  4897 |     |             mstore(0x00, 0x63183678)
  4898 |     |             mstore(0x20, p0)
  4899 |     |             mstore(0x40, 0x80)
  4900 |     |             mstore(0x60, p2)
  4901 |     |             mstore(0x80, p3)
  4902 |     |             writeString(0xa0, p1)
  4903 |     |         }
  4904 |     |         _sendLogPayload(0x1c, 0xc4);
  4905 |     |         assembly {
  4906 |     |             mstore(0x00, m0)
  4907 |     |             mstore(0x20, m1)
  4908 |     |             mstore(0x40, m2)
  4909 |     |             mstore(0x60, m3)
  4910 |     |             mstore(0x80, m4)
  4911 |     |             mstore(0xa0, m5)
  4912 |     |             mstore(0xc0, m6)
  4913 |     |         }
  4914 |     |     }
  4915 |     | 
  4916 |     |     function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  4917 |     |         bytes32 m0;
  4918 |     |         bytes32 m1;
  4919 |     |         bytes32 m2;
  4920 |     |         bytes32 m3;
  4921 |     |         bytes32 m4;
  4922 |     |         bytes32 m5;
  4923 |     |         bytes32 m6;
  4924 |     |         assembly {
  4925 |     |             function writeString(pos, w) {
  4926 |     |                 let length := 0
  4927 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4928 |     |                 mstore(pos, length)
  4929 |     |                 let shift := sub(256, shl(3, length))
  4930 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4931 |     |             }
  4932 |     |             m0 := mload(0x00)
  4933 |     |             m1 := mload(0x20)
  4934 |     |             m2 := mload(0x40)
  4935 |     |             m3 := mload(0x60)
  4936 |     |             m4 := mload(0x80)
  4937 |     |             m5 := mload(0xa0)
  4938 |     |             m6 := mload(0xc0)
  4939 |     |             // Selector of `log(address,string,uint256,bool)`.
  4940 |     |             mstore(0x00, 0x0ef7e050)
  4941 |     |             mstore(0x20, p0)
  4942 |     |             mstore(0x40, 0x80)
  4943 |     |             mstore(0x60, p2)
  4944 |     |             mstore(0x80, p3)
  4945 |     |             writeString(0xa0, p1)
  4946 |     |         }
  4947 |     |         _sendLogPayload(0x1c, 0xc4);
  4948 |     |         assembly {
  4949 |     |             mstore(0x00, m0)
  4950 |     |             mstore(0x20, m1)
  4951 |     |             mstore(0x40, m2)
  4952 |     |             mstore(0x60, m3)
  4953 |     |             mstore(0x80, m4)
  4954 |     |             mstore(0xa0, m5)
  4955 |     |             mstore(0xc0, m6)
  4956 |     |         }
  4957 |     |     }
  4958 |     | 
  4959 |     |     function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  4960 |     |         bytes32 m0;
  4961 |     |         bytes32 m1;
  4962 |     |         bytes32 m2;
  4963 |     |         bytes32 m3;
  4964 |     |         bytes32 m4;
  4965 |     |         bytes32 m5;
  4966 |     |         bytes32 m6;
  4967 |     |         assembly {
  4968 |     |             function writeString(pos, w) {
  4969 |     |                 let length := 0
  4970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  4971 |     |                 mstore(pos, length)
  4972 |     |                 let shift := sub(256, shl(3, length))
  4973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  4974 |     |             }
  4975 |     |             m0 := mload(0x00)
  4976 |     |             m1 := mload(0x20)
  4977 |     |             m2 := mload(0x40)
  4978 |     |             m3 := mload(0x60)
  4979 |     |             m4 := mload(0x80)
  4980 |     |             m5 := mload(0xa0)
  4981 |     |             m6 := mload(0xc0)
  4982 |     |             // Selector of `log(address,string,uint256,uint256)`.
  4983 |     |             mstore(0x00, 0x1dc8e1b8)
  4984 |     |             mstore(0x20, p0)
  4985 |     |             mstore(0x40, 0x80)
  4986 |     |             mstore(0x60, p2)
  4987 |     |             mstore(0x80, p3)
  4988 |     |             writeString(0xa0, p1)
  4989 |     |         }
  4990 |     |         _sendLogPayload(0x1c, 0xc4);
  4991 |     |         assembly {
  4992 |     |             mstore(0x00, m0)
  4993 |     |             mstore(0x20, m1)
  4994 |     |             mstore(0x40, m2)
  4995 |     |             mstore(0x60, m3)
  4996 |     |             mstore(0x80, m4)
  4997 |     |             mstore(0xa0, m5)
  4998 |     |             mstore(0xc0, m6)
  4999 |     |         }
  5000 |     |     }
  5001 |     | 
  5002 |     |     function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  5003 |     |         bytes32 m0;
  5004 |     |         bytes32 m1;
  5005 |     |         bytes32 m2;
  5006 |     |         bytes32 m3;
  5007 |     |         bytes32 m4;
  5008 |     |         bytes32 m5;
  5009 |     |         bytes32 m6;
  5010 |     |         bytes32 m7;
  5011 |     |         bytes32 m8;
  5012 |     |         assembly {
  5013 |     |             function writeString(pos, w) {
  5014 |     |                 let length := 0
  5015 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5016 |     |                 mstore(pos, length)
  5017 |     |                 let shift := sub(256, shl(3, length))
  5018 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5019 |     |             }
  5020 |     |             m0 := mload(0x00)
  5021 |     |             m1 := mload(0x20)
  5022 |     |             m2 := mload(0x40)
  5023 |     |             m3 := mload(0x60)
  5024 |     |             m4 := mload(0x80)
  5025 |     |             m5 := mload(0xa0)
  5026 |     |             m6 := mload(0xc0)
  5027 |     |             m7 := mload(0xe0)
  5028 |     |             m8 := mload(0x100)
  5029 |     |             // Selector of `log(address,string,uint256,string)`.
  5030 |     |             mstore(0x00, 0x448830a8)
  5031 |     |             mstore(0x20, p0)
  5032 |     |             mstore(0x40, 0x80)
  5033 |     |             mstore(0x60, p2)
  5034 |     |             mstore(0x80, 0xc0)
  5035 |     |             writeString(0xa0, p1)
  5036 |     |             writeString(0xe0, p3)
  5037 |     |         }
  5038 |     |         _sendLogPayload(0x1c, 0x104);
  5039 |     |         assembly {
  5040 |     |             mstore(0x00, m0)
  5041 |     |             mstore(0x20, m1)
  5042 |     |             mstore(0x40, m2)
  5043 |     |             mstore(0x60, m3)
  5044 |     |             mstore(0x80, m4)
  5045 |     |             mstore(0xa0, m5)
  5046 |     |             mstore(0xc0, m6)
  5047 |     |             mstore(0xe0, m7)
  5048 |     |             mstore(0x100, m8)
  5049 |     |         }
  5050 |     |     }
  5051 |     | 
  5052 |     |     function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  5053 |     |         bytes32 m0;
  5054 |     |         bytes32 m1;
  5055 |     |         bytes32 m2;
  5056 |     |         bytes32 m3;
  5057 |     |         bytes32 m4;
  5058 |     |         bytes32 m5;
  5059 |     |         bytes32 m6;
  5060 |     |         bytes32 m7;
  5061 |     |         bytes32 m8;
  5062 |     |         assembly {
  5063 |     |             function writeString(pos, w) {
  5064 |     |                 let length := 0
  5065 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5066 |     |                 mstore(pos, length)
  5067 |     |                 let shift := sub(256, shl(3, length))
  5068 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5069 |     |             }
  5070 |     |             m0 := mload(0x00)
  5071 |     |             m1 := mload(0x20)
  5072 |     |             m2 := mload(0x40)
  5073 |     |             m3 := mload(0x60)
  5074 |     |             m4 := mload(0x80)
  5075 |     |             m5 := mload(0xa0)
  5076 |     |             m6 := mload(0xc0)
  5077 |     |             m7 := mload(0xe0)
  5078 |     |             m8 := mload(0x100)
  5079 |     |             // Selector of `log(address,string,string,address)`.
  5080 |     |             mstore(0x00, 0xa04e2f87)
  5081 |     |             mstore(0x20, p0)
  5082 |     |             mstore(0x40, 0x80)
  5083 |     |             mstore(0x60, 0xc0)
  5084 |     |             mstore(0x80, p3)
  5085 |     |             writeString(0xa0, p1)
  5086 |     |             writeString(0xe0, p2)
  5087 |     |         }
  5088 |     |         _sendLogPayload(0x1c, 0x104);
  5089 |     |         assembly {
  5090 |     |             mstore(0x00, m0)
  5091 |     |             mstore(0x20, m1)
  5092 |     |             mstore(0x40, m2)
  5093 |     |             mstore(0x60, m3)
  5094 |     |             mstore(0x80, m4)
  5095 |     |             mstore(0xa0, m5)
  5096 |     |             mstore(0xc0, m6)
  5097 |     |             mstore(0xe0, m7)
  5098 |     |             mstore(0x100, m8)
  5099 |     |         }
  5100 |     |     }
  5101 |     | 
  5102 |     |     function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  5103 |     |         bytes32 m0;
  5104 |     |         bytes32 m1;
  5105 |     |         bytes32 m2;
  5106 |     |         bytes32 m3;
  5107 |     |         bytes32 m4;
  5108 |     |         bytes32 m5;
  5109 |     |         bytes32 m6;
  5110 |     |         bytes32 m7;
  5111 |     |         bytes32 m8;
  5112 |     |         assembly {
  5113 |     |             function writeString(pos, w) {
  5114 |     |                 let length := 0
  5115 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5116 |     |                 mstore(pos, length)
  5117 |     |                 let shift := sub(256, shl(3, length))
  5118 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5119 |     |             }
  5120 |     |             m0 := mload(0x00)
  5121 |     |             m1 := mload(0x20)
  5122 |     |             m2 := mload(0x40)
  5123 |     |             m3 := mload(0x60)
  5124 |     |             m4 := mload(0x80)
  5125 |     |             m5 := mload(0xa0)
  5126 |     |             m6 := mload(0xc0)
  5127 |     |             m7 := mload(0xe0)
  5128 |     |             m8 := mload(0x100)
  5129 |     |             // Selector of `log(address,string,string,bool)`.
  5130 |     |             mstore(0x00, 0x35a5071f)
  5131 |     |             mstore(0x20, p0)
  5132 |     |             mstore(0x40, 0x80)
  5133 |     |             mstore(0x60, 0xc0)
  5134 |     |             mstore(0x80, p3)
  5135 |     |             writeString(0xa0, p1)
  5136 |     |             writeString(0xe0, p2)
  5137 |     |         }
  5138 |     |         _sendLogPayload(0x1c, 0x104);
  5139 |     |         assembly {
  5140 |     |             mstore(0x00, m0)
  5141 |     |             mstore(0x20, m1)
  5142 |     |             mstore(0x40, m2)
  5143 |     |             mstore(0x60, m3)
  5144 |     |             mstore(0x80, m4)
  5145 |     |             mstore(0xa0, m5)
  5146 |     |             mstore(0xc0, m6)
  5147 |     |             mstore(0xe0, m7)
  5148 |     |             mstore(0x100, m8)
  5149 |     |         }
  5150 |     |     }
  5151 |     | 
  5152 |     |     function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  5153 |     |         bytes32 m0;
  5154 |     |         bytes32 m1;
  5155 |     |         bytes32 m2;
  5156 |     |         bytes32 m3;
  5157 |     |         bytes32 m4;
  5158 |     |         bytes32 m5;
  5159 |     |         bytes32 m6;
  5160 |     |         bytes32 m7;
  5161 |     |         bytes32 m8;
  5162 |     |         assembly {
  5163 |     |             function writeString(pos, w) {
  5164 |     |                 let length := 0
  5165 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5166 |     |                 mstore(pos, length)
  5167 |     |                 let shift := sub(256, shl(3, length))
  5168 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5169 |     |             }
  5170 |     |             m0 := mload(0x00)
  5171 |     |             m1 := mload(0x20)
  5172 |     |             m2 := mload(0x40)
  5173 |     |             m3 := mload(0x60)
  5174 |     |             m4 := mload(0x80)
  5175 |     |             m5 := mload(0xa0)
  5176 |     |             m6 := mload(0xc0)
  5177 |     |             m7 := mload(0xe0)
  5178 |     |             m8 := mload(0x100)
  5179 |     |             // Selector of `log(address,string,string,uint256)`.
  5180 |     |             mstore(0x00, 0x159f8927)
  5181 |     |             mstore(0x20, p0)
  5182 |     |             mstore(0x40, 0x80)
  5183 |     |             mstore(0x60, 0xc0)
  5184 |     |             mstore(0x80, p3)
  5185 |     |             writeString(0xa0, p1)
  5186 |     |             writeString(0xe0, p2)
  5187 |     |         }
  5188 |     |         _sendLogPayload(0x1c, 0x104);
  5189 |     |         assembly {
  5190 |     |             mstore(0x00, m0)
  5191 |     |             mstore(0x20, m1)
  5192 |     |             mstore(0x40, m2)
  5193 |     |             mstore(0x60, m3)
  5194 |     |             mstore(0x80, m4)
  5195 |     |             mstore(0xa0, m5)
  5196 |     |             mstore(0xc0, m6)
  5197 |     |             mstore(0xe0, m7)
  5198 |     |             mstore(0x100, m8)
  5199 |     |         }
  5200 |     |     }
  5201 |     | 
  5202 |     |     function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  5203 |     |         bytes32 m0;
  5204 |     |         bytes32 m1;
  5205 |     |         bytes32 m2;
  5206 |     |         bytes32 m3;
  5207 |     |         bytes32 m4;
  5208 |     |         bytes32 m5;
  5209 |     |         bytes32 m6;
  5210 |     |         bytes32 m7;
  5211 |     |         bytes32 m8;
  5212 |     |         bytes32 m9;
  5213 |     |         bytes32 m10;
  5214 |     |         assembly {
  5215 |     |             function writeString(pos, w) {
  5216 |     |                 let length := 0
  5217 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5218 |     |                 mstore(pos, length)
  5219 |     |                 let shift := sub(256, shl(3, length))
  5220 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5221 |     |             }
  5222 |     |             m0 := mload(0x00)
  5223 |     |             m1 := mload(0x20)
  5224 |     |             m2 := mload(0x40)
  5225 |     |             m3 := mload(0x60)
  5226 |     |             m4 := mload(0x80)
  5227 |     |             m5 := mload(0xa0)
  5228 |     |             m6 := mload(0xc0)
  5229 |     |             m7 := mload(0xe0)
  5230 |     |             m8 := mload(0x100)
  5231 |     |             m9 := mload(0x120)
  5232 |     |             m10 := mload(0x140)
  5233 |     |             // Selector of `log(address,string,string,string)`.
  5234 |     |             mstore(0x00, 0x5d02c50b)
  5235 |     |             mstore(0x20, p0)
  5236 |     |             mstore(0x40, 0x80)
  5237 |     |             mstore(0x60, 0xc0)
  5238 |     |             mstore(0x80, 0x100)
  5239 |     |             writeString(0xa0, p1)
  5240 |     |             writeString(0xe0, p2)
  5241 |     |             writeString(0x120, p3)
  5242 |     |         }
  5243 |     |         _sendLogPayload(0x1c, 0x144);
  5244 |     |         assembly {
  5245 |     |             mstore(0x00, m0)
  5246 |     |             mstore(0x20, m1)
  5247 |     |             mstore(0x40, m2)
  5248 |     |             mstore(0x60, m3)
  5249 |     |             mstore(0x80, m4)
  5250 |     |             mstore(0xa0, m5)
  5251 |     |             mstore(0xc0, m6)
  5252 |     |             mstore(0xe0, m7)
  5253 |     |             mstore(0x100, m8)
  5254 |     |             mstore(0x120, m9)
  5255 |     |             mstore(0x140, m10)
  5256 |     |         }
  5257 |     |     }
  5258 |     | 
  5259 |     |     function log(bool p0, address p1, address p2, address p3) internal pure {
  5260 |     |         bytes32 m0;
  5261 |     |         bytes32 m1;
  5262 |     |         bytes32 m2;
  5263 |     |         bytes32 m3;
  5264 |     |         bytes32 m4;
  5265 |     |         assembly {
  5266 |     |             m0 := mload(0x00)
  5267 |     |             m1 := mload(0x20)
  5268 |     |             m2 := mload(0x40)
  5269 |     |             m3 := mload(0x60)
  5270 |     |             m4 := mload(0x80)
  5271 |     |             // Selector of `log(bool,address,address,address)`.
  5272 |     |             mstore(0x00, 0x1d14d001)
  5273 |     |             mstore(0x20, p0)
  5274 |     |             mstore(0x40, p1)
  5275 |     |             mstore(0x60, p2)
  5276 |     |             mstore(0x80, p3)
  5277 |     |         }
  5278 |     |         _sendLogPayload(0x1c, 0x84);
  5279 |     |         assembly {
  5280 |     |             mstore(0x00, m0)
  5281 |     |             mstore(0x20, m1)
  5282 |     |             mstore(0x40, m2)
  5283 |     |             mstore(0x60, m3)
  5284 |     |             mstore(0x80, m4)
  5285 |     |         }
  5286 |     |     }
  5287 |     | 
  5288 |     |     function log(bool p0, address p1, address p2, bool p3) internal pure {
  5289 |     |         bytes32 m0;
  5290 |     |         bytes32 m1;
  5291 |     |         bytes32 m2;
  5292 |     |         bytes32 m3;
  5293 |     |         bytes32 m4;
  5294 |     |         assembly {
  5295 |     |             m0 := mload(0x00)
  5296 |     |             m1 := mload(0x20)
  5297 |     |             m2 := mload(0x40)
  5298 |     |             m3 := mload(0x60)
  5299 |     |             m4 := mload(0x80)
  5300 |     |             // Selector of `log(bool,address,address,bool)`.
  5301 |     |             mstore(0x00, 0x46600be0)
  5302 |     |             mstore(0x20, p0)
  5303 |     |             mstore(0x40, p1)
  5304 |     |             mstore(0x60, p2)
  5305 |     |             mstore(0x80, p3)
  5306 |     |         }
  5307 |     |         _sendLogPayload(0x1c, 0x84);
  5308 |     |         assembly {
  5309 |     |             mstore(0x00, m0)
  5310 |     |             mstore(0x20, m1)
  5311 |     |             mstore(0x40, m2)
  5312 |     |             mstore(0x60, m3)
  5313 |     |             mstore(0x80, m4)
  5314 |     |         }
  5315 |     |     }
  5316 |     | 
  5317 |     |     function log(bool p0, address p1, address p2, uint256 p3) internal pure {
  5318 |     |         bytes32 m0;
  5319 |     |         bytes32 m1;
  5320 |     |         bytes32 m2;
  5321 |     |         bytes32 m3;
  5322 |     |         bytes32 m4;
  5323 |     |         assembly {
  5324 |     |             m0 := mload(0x00)
  5325 |     |             m1 := mload(0x20)
  5326 |     |             m2 := mload(0x40)
  5327 |     |             m3 := mload(0x60)
  5328 |     |             m4 := mload(0x80)
  5329 |     |             // Selector of `log(bool,address,address,uint256)`.
  5330 |     |             mstore(0x00, 0x0c66d1be)
  5331 |     |             mstore(0x20, p0)
  5332 |     |             mstore(0x40, p1)
  5333 |     |             mstore(0x60, p2)
  5334 |     |             mstore(0x80, p3)
  5335 |     |         }
  5336 |     |         _sendLogPayload(0x1c, 0x84);
  5337 |     |         assembly {
  5338 |     |             mstore(0x00, m0)
  5339 |     |             mstore(0x20, m1)
  5340 |     |             mstore(0x40, m2)
  5341 |     |             mstore(0x60, m3)
  5342 |     |             mstore(0x80, m4)
  5343 |     |         }
  5344 |     |     }
  5345 |     | 
  5346 |     |     function log(bool p0, address p1, address p2, bytes32 p3) internal pure {
  5347 |     |         bytes32 m0;
  5348 |     |         bytes32 m1;
  5349 |     |         bytes32 m2;
  5350 |     |         bytes32 m3;
  5351 |     |         bytes32 m4;
  5352 |     |         bytes32 m5;
  5353 |     |         bytes32 m6;
  5354 |     |         assembly {
  5355 |     |             function writeString(pos, w) {
  5356 |     |                 let length := 0
  5357 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5358 |     |                 mstore(pos, length)
  5359 |     |                 let shift := sub(256, shl(3, length))
  5360 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5361 |     |             }
  5362 |     |             m0 := mload(0x00)
  5363 |     |             m1 := mload(0x20)
  5364 |     |             m2 := mload(0x40)
  5365 |     |             m3 := mload(0x60)
  5366 |     |             m4 := mload(0x80)
  5367 |     |             m5 := mload(0xa0)
  5368 |     |             m6 := mload(0xc0)
  5369 |     |             // Selector of `log(bool,address,address,string)`.
  5370 |     |             mstore(0x00, 0xd812a167)
  5371 |     |             mstore(0x20, p0)
  5372 |     |             mstore(0x40, p1)
  5373 |     |             mstore(0x60, p2)
  5374 |     |             mstore(0x80, 0x80)
  5375 |     |             writeString(0xa0, p3)
  5376 |     |         }
  5377 |     |         _sendLogPayload(0x1c, 0xc4);
  5378 |     |         assembly {
  5379 |     |             mstore(0x00, m0)
  5380 |     |             mstore(0x20, m1)
  5381 |     |             mstore(0x40, m2)
  5382 |     |             mstore(0x60, m3)
  5383 |     |             mstore(0x80, m4)
  5384 |     |             mstore(0xa0, m5)
  5385 |     |             mstore(0xc0, m6)
  5386 |     |         }
  5387 |     |     }
  5388 |     | 
  5389 |     |     function log(bool p0, address p1, bool p2, address p3) internal pure {
  5390 |     |         bytes32 m0;
  5391 |     |         bytes32 m1;
  5392 |     |         bytes32 m2;
  5393 |     |         bytes32 m3;
  5394 |     |         bytes32 m4;
  5395 |     |         assembly {
  5396 |     |             m0 := mload(0x00)
  5397 |     |             m1 := mload(0x20)
  5398 |     |             m2 := mload(0x40)
  5399 |     |             m3 := mload(0x60)
  5400 |     |             m4 := mload(0x80)
  5401 |     |             // Selector of `log(bool,address,bool,address)`.
  5402 |     |             mstore(0x00, 0x1c41a336)
  5403 |     |             mstore(0x20, p0)
  5404 |     |             mstore(0x40, p1)
  5405 |     |             mstore(0x60, p2)
  5406 |     |             mstore(0x80, p3)
  5407 |     |         }
  5408 |     |         _sendLogPayload(0x1c, 0x84);
  5409 |     |         assembly {
  5410 |     |             mstore(0x00, m0)
  5411 |     |             mstore(0x20, m1)
  5412 |     |             mstore(0x40, m2)
  5413 |     |             mstore(0x60, m3)
  5414 |     |             mstore(0x80, m4)
  5415 |     |         }
  5416 |     |     }
  5417 |     | 
  5418 |     |     function log(bool p0, address p1, bool p2, bool p3) internal pure {
  5419 |     |         bytes32 m0;
  5420 |     |         bytes32 m1;
  5421 |     |         bytes32 m2;
  5422 |     |         bytes32 m3;
  5423 |     |         bytes32 m4;
  5424 |     |         assembly {
  5425 |     |             m0 := mload(0x00)
  5426 |     |             m1 := mload(0x20)
  5427 |     |             m2 := mload(0x40)
  5428 |     |             m3 := mload(0x60)
  5429 |     |             m4 := mload(0x80)
  5430 |     |             // Selector of `log(bool,address,bool,bool)`.
  5431 |     |             mstore(0x00, 0x6a9c478b)
  5432 |     |             mstore(0x20, p0)
  5433 |     |             mstore(0x40, p1)
  5434 |     |             mstore(0x60, p2)
  5435 |     |             mstore(0x80, p3)
  5436 |     |         }
  5437 |     |         _sendLogPayload(0x1c, 0x84);
  5438 |     |         assembly {
  5439 |     |             mstore(0x00, m0)
  5440 |     |             mstore(0x20, m1)
  5441 |     |             mstore(0x40, m2)
  5442 |     |             mstore(0x60, m3)
  5443 |     |             mstore(0x80, m4)
  5444 |     |         }
  5445 |     |     }
  5446 |     | 
  5447 |     |     function log(bool p0, address p1, bool p2, uint256 p3) internal pure {
  5448 |     |         bytes32 m0;
  5449 |     |         bytes32 m1;
  5450 |     |         bytes32 m2;
  5451 |     |         bytes32 m3;
  5452 |     |         bytes32 m4;
  5453 |     |         assembly {
  5454 |     |             m0 := mload(0x00)
  5455 |     |             m1 := mload(0x20)
  5456 |     |             m2 := mload(0x40)
  5457 |     |             m3 := mload(0x60)
  5458 |     |             m4 := mload(0x80)
  5459 |     |             // Selector of `log(bool,address,bool,uint256)`.
  5460 |     |             mstore(0x00, 0x07831502)
  5461 |     |             mstore(0x20, p0)
  5462 |     |             mstore(0x40, p1)
  5463 |     |             mstore(0x60, p2)
  5464 |     |             mstore(0x80, p3)
  5465 |     |         }
  5466 |     |         _sendLogPayload(0x1c, 0x84);
  5467 |     |         assembly {
  5468 |     |             mstore(0x00, m0)
  5469 |     |             mstore(0x20, m1)
  5470 |     |             mstore(0x40, m2)
  5471 |     |             mstore(0x60, m3)
  5472 |     |             mstore(0x80, m4)
  5473 |     |         }
  5474 |     |     }
  5475 |     | 
  5476 |     |     function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {
  5477 |     |         bytes32 m0;
  5478 |     |         bytes32 m1;
  5479 |     |         bytes32 m2;
  5480 |     |         bytes32 m3;
  5481 |     |         bytes32 m4;
  5482 |     |         bytes32 m5;
  5483 |     |         bytes32 m6;
  5484 |     |         assembly {
  5485 |     |             function writeString(pos, w) {
  5486 |     |                 let length := 0
  5487 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5488 |     |                 mstore(pos, length)
  5489 |     |                 let shift := sub(256, shl(3, length))
  5490 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5491 |     |             }
  5492 |     |             m0 := mload(0x00)
  5493 |     |             m1 := mload(0x20)
  5494 |     |             m2 := mload(0x40)
  5495 |     |             m3 := mload(0x60)
  5496 |     |             m4 := mload(0x80)
  5497 |     |             m5 := mload(0xa0)
  5498 |     |             m6 := mload(0xc0)
  5499 |     |             // Selector of `log(bool,address,bool,string)`.
  5500 |     |             mstore(0x00, 0x4a66cb34)
  5501 |     |             mstore(0x20, p0)
  5502 |     |             mstore(0x40, p1)
  5503 |     |             mstore(0x60, p2)
  5504 |     |             mstore(0x80, 0x80)
  5505 |     |             writeString(0xa0, p3)
  5506 |     |         }
  5507 |     |         _sendLogPayload(0x1c, 0xc4);
  5508 |     |         assembly {
  5509 |     |             mstore(0x00, m0)
  5510 |     |             mstore(0x20, m1)
  5511 |     |             mstore(0x40, m2)
  5512 |     |             mstore(0x60, m3)
  5513 |     |             mstore(0x80, m4)
  5514 |     |             mstore(0xa0, m5)
  5515 |     |             mstore(0xc0, m6)
  5516 |     |         }
  5517 |     |     }
  5518 |     | 
  5519 |     |     function log(bool p0, address p1, uint256 p2, address p3) internal pure {
  5520 |     |         bytes32 m0;
  5521 |     |         bytes32 m1;
  5522 |     |         bytes32 m2;
  5523 |     |         bytes32 m3;
  5524 |     |         bytes32 m4;
  5525 |     |         assembly {
  5526 |     |             m0 := mload(0x00)
  5527 |     |             m1 := mload(0x20)
  5528 |     |             m2 := mload(0x40)
  5529 |     |             m3 := mload(0x60)
  5530 |     |             m4 := mload(0x80)
  5531 |     |             // Selector of `log(bool,address,uint256,address)`.
  5532 |     |             mstore(0x00, 0x136b05dd)
  5533 |     |             mstore(0x20, p0)
  5534 |     |             mstore(0x40, p1)
  5535 |     |             mstore(0x60, p2)
  5536 |     |             mstore(0x80, p3)
  5537 |     |         }
  5538 |     |         _sendLogPayload(0x1c, 0x84);
  5539 |     |         assembly {
  5540 |     |             mstore(0x00, m0)
  5541 |     |             mstore(0x20, m1)
  5542 |     |             mstore(0x40, m2)
  5543 |     |             mstore(0x60, m3)
  5544 |     |             mstore(0x80, m4)
  5545 |     |         }
  5546 |     |     }
  5547 |     | 
  5548 |     |     function log(bool p0, address p1, uint256 p2, bool p3) internal pure {
  5549 |     |         bytes32 m0;
  5550 |     |         bytes32 m1;
  5551 |     |         bytes32 m2;
  5552 |     |         bytes32 m3;
  5553 |     |         bytes32 m4;
  5554 |     |         assembly {
  5555 |     |             m0 := mload(0x00)
  5556 |     |             m1 := mload(0x20)
  5557 |     |             m2 := mload(0x40)
  5558 |     |             m3 := mload(0x60)
  5559 |     |             m4 := mload(0x80)
  5560 |     |             // Selector of `log(bool,address,uint256,bool)`.
  5561 |     |             mstore(0x00, 0xd6019f1c)
  5562 |     |             mstore(0x20, p0)
  5563 |     |             mstore(0x40, p1)
  5564 |     |             mstore(0x60, p2)
  5565 |     |             mstore(0x80, p3)
  5566 |     |         }
  5567 |     |         _sendLogPayload(0x1c, 0x84);
  5568 |     |         assembly {
  5569 |     |             mstore(0x00, m0)
  5570 |     |             mstore(0x20, m1)
  5571 |     |             mstore(0x40, m2)
  5572 |     |             mstore(0x60, m3)
  5573 |     |             mstore(0x80, m4)
  5574 |     |         }
  5575 |     |     }
  5576 |     | 
  5577 |     |     function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {
  5578 |     |         bytes32 m0;
  5579 |     |         bytes32 m1;
  5580 |     |         bytes32 m2;
  5581 |     |         bytes32 m3;
  5582 |     |         bytes32 m4;
  5583 |     |         assembly {
  5584 |     |             m0 := mload(0x00)
  5585 |     |             m1 := mload(0x20)
  5586 |     |             m2 := mload(0x40)
  5587 |     |             m3 := mload(0x60)
  5588 |     |             m4 := mload(0x80)
  5589 |     |             // Selector of `log(bool,address,uint256,uint256)`.
  5590 |     |             mstore(0x00, 0x7bf181a1)
  5591 |     |             mstore(0x20, p0)
  5592 |     |             mstore(0x40, p1)
  5593 |     |             mstore(0x60, p2)
  5594 |     |             mstore(0x80, p3)
  5595 |     |         }
  5596 |     |         _sendLogPayload(0x1c, 0x84);
  5597 |     |         assembly {
  5598 |     |             mstore(0x00, m0)
  5599 |     |             mstore(0x20, m1)
  5600 |     |             mstore(0x40, m2)
  5601 |     |             mstore(0x60, m3)
  5602 |     |             mstore(0x80, m4)
  5603 |     |         }
  5604 |     |     }
  5605 |     | 
  5606 |     |     function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {
  5607 |     |         bytes32 m0;
  5608 |     |         bytes32 m1;
  5609 |     |         bytes32 m2;
  5610 |     |         bytes32 m3;
  5611 |     |         bytes32 m4;
  5612 |     |         bytes32 m5;
  5613 |     |         bytes32 m6;
  5614 |     |         assembly {
  5615 |     |             function writeString(pos, w) {
  5616 |     |                 let length := 0
  5617 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5618 |     |                 mstore(pos, length)
  5619 |     |                 let shift := sub(256, shl(3, length))
  5620 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5621 |     |             }
  5622 |     |             m0 := mload(0x00)
  5623 |     |             m1 := mload(0x20)
  5624 |     |             m2 := mload(0x40)
  5625 |     |             m3 := mload(0x60)
  5626 |     |             m4 := mload(0x80)
  5627 |     |             m5 := mload(0xa0)
  5628 |     |             m6 := mload(0xc0)
  5629 |     |             // Selector of `log(bool,address,uint256,string)`.
  5630 |     |             mstore(0x00, 0x51f09ff8)
  5631 |     |             mstore(0x20, p0)
  5632 |     |             mstore(0x40, p1)
  5633 |     |             mstore(0x60, p2)
  5634 |     |             mstore(0x80, 0x80)
  5635 |     |             writeString(0xa0, p3)
  5636 |     |         }
  5637 |     |         _sendLogPayload(0x1c, 0xc4);
  5638 |     |         assembly {
  5639 |     |             mstore(0x00, m0)
  5640 |     |             mstore(0x20, m1)
  5641 |     |             mstore(0x40, m2)
  5642 |     |             mstore(0x60, m3)
  5643 |     |             mstore(0x80, m4)
  5644 |     |             mstore(0xa0, m5)
  5645 |     |             mstore(0xc0, m6)
  5646 |     |         }
  5647 |     |     }
  5648 |     | 
  5649 |     |     function log(bool p0, address p1, bytes32 p2, address p3) internal pure {
  5650 |     |         bytes32 m0;
  5651 |     |         bytes32 m1;
  5652 |     |         bytes32 m2;
  5653 |     |         bytes32 m3;
  5654 |     |         bytes32 m4;
  5655 |     |         bytes32 m5;
  5656 |     |         bytes32 m6;
  5657 |     |         assembly {
  5658 |     |             function writeString(pos, w) {
  5659 |     |                 let length := 0
  5660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5661 |     |                 mstore(pos, length)
  5662 |     |                 let shift := sub(256, shl(3, length))
  5663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5664 |     |             }
  5665 |     |             m0 := mload(0x00)
  5666 |     |             m1 := mload(0x20)
  5667 |     |             m2 := mload(0x40)
  5668 |     |             m3 := mload(0x60)
  5669 |     |             m4 := mload(0x80)
  5670 |     |             m5 := mload(0xa0)
  5671 |     |             m6 := mload(0xc0)
  5672 |     |             // Selector of `log(bool,address,string,address)`.
  5673 |     |             mstore(0x00, 0x6f7c603e)
  5674 |     |             mstore(0x20, p0)
  5675 |     |             mstore(0x40, p1)
  5676 |     |             mstore(0x60, 0x80)
  5677 |     |             mstore(0x80, p3)
  5678 |     |             writeString(0xa0, p2)
  5679 |     |         }
  5680 |     |         _sendLogPayload(0x1c, 0xc4);
  5681 |     |         assembly {
  5682 |     |             mstore(0x00, m0)
  5683 |     |             mstore(0x20, m1)
  5684 |     |             mstore(0x40, m2)
  5685 |     |             mstore(0x60, m3)
  5686 |     |             mstore(0x80, m4)
  5687 |     |             mstore(0xa0, m5)
  5688 |     |             mstore(0xc0, m6)
  5689 |     |         }
  5690 |     |     }
  5691 |     | 
  5692 |     |     function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {
  5693 |     |         bytes32 m0;
  5694 |     |         bytes32 m1;
  5695 |     |         bytes32 m2;
  5696 |     |         bytes32 m3;
  5697 |     |         bytes32 m4;
  5698 |     |         bytes32 m5;
  5699 |     |         bytes32 m6;
  5700 |     |         assembly {
  5701 |     |             function writeString(pos, w) {
  5702 |     |                 let length := 0
  5703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5704 |     |                 mstore(pos, length)
  5705 |     |                 let shift := sub(256, shl(3, length))
  5706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5707 |     |             }
  5708 |     |             m0 := mload(0x00)
  5709 |     |             m1 := mload(0x20)
  5710 |     |             m2 := mload(0x40)
  5711 |     |             m3 := mload(0x60)
  5712 |     |             m4 := mload(0x80)
  5713 |     |             m5 := mload(0xa0)
  5714 |     |             m6 := mload(0xc0)
  5715 |     |             // Selector of `log(bool,address,string,bool)`.
  5716 |     |             mstore(0x00, 0xe2bfd60b)
  5717 |     |             mstore(0x20, p0)
  5718 |     |             mstore(0x40, p1)
  5719 |     |             mstore(0x60, 0x80)
  5720 |     |             mstore(0x80, p3)
  5721 |     |             writeString(0xa0, p2)
  5722 |     |         }
  5723 |     |         _sendLogPayload(0x1c, 0xc4);
  5724 |     |         assembly {
  5725 |     |             mstore(0x00, m0)
  5726 |     |             mstore(0x20, m1)
  5727 |     |             mstore(0x40, m2)
  5728 |     |             mstore(0x60, m3)
  5729 |     |             mstore(0x80, m4)
  5730 |     |             mstore(0xa0, m5)
  5731 |     |             mstore(0xc0, m6)
  5732 |     |         }
  5733 |     |     }
  5734 |     | 
  5735 |     |     function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {
  5736 |     |         bytes32 m0;
  5737 |     |         bytes32 m1;
  5738 |     |         bytes32 m2;
  5739 |     |         bytes32 m3;
  5740 |     |         bytes32 m4;
  5741 |     |         bytes32 m5;
  5742 |     |         bytes32 m6;
  5743 |     |         assembly {
  5744 |     |             function writeString(pos, w) {
  5745 |     |                 let length := 0
  5746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5747 |     |                 mstore(pos, length)
  5748 |     |                 let shift := sub(256, shl(3, length))
  5749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5750 |     |             }
  5751 |     |             m0 := mload(0x00)
  5752 |     |             m1 := mload(0x20)
  5753 |     |             m2 := mload(0x40)
  5754 |     |             m3 := mload(0x60)
  5755 |     |             m4 := mload(0x80)
  5756 |     |             m5 := mload(0xa0)
  5757 |     |             m6 := mload(0xc0)
  5758 |     |             // Selector of `log(bool,address,string,uint256)`.
  5759 |     |             mstore(0x00, 0xc21f64c7)
  5760 |     |             mstore(0x20, p0)
  5761 |     |             mstore(0x40, p1)
  5762 |     |             mstore(0x60, 0x80)
  5763 |     |             mstore(0x80, p3)
  5764 |     |             writeString(0xa0, p2)
  5765 |     |         }
  5766 |     |         _sendLogPayload(0x1c, 0xc4);
  5767 |     |         assembly {
  5768 |     |             mstore(0x00, m0)
  5769 |     |             mstore(0x20, m1)
  5770 |     |             mstore(0x40, m2)
  5771 |     |             mstore(0x60, m3)
  5772 |     |             mstore(0x80, m4)
  5773 |     |             mstore(0xa0, m5)
  5774 |     |             mstore(0xc0, m6)
  5775 |     |         }
  5776 |     |     }
  5777 |     | 
  5778 |     |     function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  5779 |     |         bytes32 m0;
  5780 |     |         bytes32 m1;
  5781 |     |         bytes32 m2;
  5782 |     |         bytes32 m3;
  5783 |     |         bytes32 m4;
  5784 |     |         bytes32 m5;
  5785 |     |         bytes32 m6;
  5786 |     |         bytes32 m7;
  5787 |     |         bytes32 m8;
  5788 |     |         assembly {
  5789 |     |             function writeString(pos, w) {
  5790 |     |                 let length := 0
  5791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5792 |     |                 mstore(pos, length)
  5793 |     |                 let shift := sub(256, shl(3, length))
  5794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5795 |     |             }
  5796 |     |             m0 := mload(0x00)
  5797 |     |             m1 := mload(0x20)
  5798 |     |             m2 := mload(0x40)
  5799 |     |             m3 := mload(0x60)
  5800 |     |             m4 := mload(0x80)
  5801 |     |             m5 := mload(0xa0)
  5802 |     |             m6 := mload(0xc0)
  5803 |     |             m7 := mload(0xe0)
  5804 |     |             m8 := mload(0x100)
  5805 |     |             // Selector of `log(bool,address,string,string)`.
  5806 |     |             mstore(0x00, 0xa73c1db6)
  5807 |     |             mstore(0x20, p0)
  5808 |     |             mstore(0x40, p1)
  5809 |     |             mstore(0x60, 0x80)
  5810 |     |             mstore(0x80, 0xc0)
  5811 |     |             writeString(0xa0, p2)
  5812 |     |             writeString(0xe0, p3)
  5813 |     |         }
  5814 |     |         _sendLogPayload(0x1c, 0x104);
  5815 |     |         assembly {
  5816 |     |             mstore(0x00, m0)
  5817 |     |             mstore(0x20, m1)
  5818 |     |             mstore(0x40, m2)
  5819 |     |             mstore(0x60, m3)
  5820 |     |             mstore(0x80, m4)
  5821 |     |             mstore(0xa0, m5)
  5822 |     |             mstore(0xc0, m6)
  5823 |     |             mstore(0xe0, m7)
  5824 |     |             mstore(0x100, m8)
  5825 |     |         }
  5826 |     |     }
  5827 |     | 
  5828 |     |     function log(bool p0, bool p1, address p2, address p3) internal pure {
  5829 |     |         bytes32 m0;
  5830 |     |         bytes32 m1;
  5831 |     |         bytes32 m2;
  5832 |     |         bytes32 m3;
  5833 |     |         bytes32 m4;
  5834 |     |         assembly {
  5835 |     |             m0 := mload(0x00)
  5836 |     |             m1 := mload(0x20)
  5837 |     |             m2 := mload(0x40)
  5838 |     |             m3 := mload(0x60)
  5839 |     |             m4 := mload(0x80)
  5840 |     |             // Selector of `log(bool,bool,address,address)`.
  5841 |     |             mstore(0x00, 0xf4880ea4)
  5842 |     |             mstore(0x20, p0)
  5843 |     |             mstore(0x40, p1)
  5844 |     |             mstore(0x60, p2)
  5845 |     |             mstore(0x80, p3)
  5846 |     |         }
  5847 |     |         _sendLogPayload(0x1c, 0x84);
  5848 |     |         assembly {
  5849 |     |             mstore(0x00, m0)
  5850 |     |             mstore(0x20, m1)
  5851 |     |             mstore(0x40, m2)
  5852 |     |             mstore(0x60, m3)
  5853 |     |             mstore(0x80, m4)
  5854 |     |         }
  5855 |     |     }
  5856 |     | 
  5857 |     |     function log(bool p0, bool p1, address p2, bool p3) internal pure {
  5858 |     |         bytes32 m0;
  5859 |     |         bytes32 m1;
  5860 |     |         bytes32 m2;
  5861 |     |         bytes32 m3;
  5862 |     |         bytes32 m4;
  5863 |     |         assembly {
  5864 |     |             m0 := mload(0x00)
  5865 |     |             m1 := mload(0x20)
  5866 |     |             m2 := mload(0x40)
  5867 |     |             m3 := mload(0x60)
  5868 |     |             m4 := mload(0x80)
  5869 |     |             // Selector of `log(bool,bool,address,bool)`.
  5870 |     |             mstore(0x00, 0xc0a302d8)
  5871 |     |             mstore(0x20, p0)
  5872 |     |             mstore(0x40, p1)
  5873 |     |             mstore(0x60, p2)
  5874 |     |             mstore(0x80, p3)
  5875 |     |         }
  5876 |     |         _sendLogPayload(0x1c, 0x84);
  5877 |     |         assembly {
  5878 |     |             mstore(0x00, m0)
  5879 |     |             mstore(0x20, m1)
  5880 |     |             mstore(0x40, m2)
  5881 |     |             mstore(0x60, m3)
  5882 |     |             mstore(0x80, m4)
  5883 |     |         }
  5884 |     |     }
  5885 |     | 
  5886 |     |     function log(bool p0, bool p1, address p2, uint256 p3) internal pure {
  5887 |     |         bytes32 m0;
  5888 |     |         bytes32 m1;
  5889 |     |         bytes32 m2;
  5890 |     |         bytes32 m3;
  5891 |     |         bytes32 m4;
  5892 |     |         assembly {
  5893 |     |             m0 := mload(0x00)
  5894 |     |             m1 := mload(0x20)
  5895 |     |             m2 := mload(0x40)
  5896 |     |             m3 := mload(0x60)
  5897 |     |             m4 := mload(0x80)
  5898 |     |             // Selector of `log(bool,bool,address,uint256)`.
  5899 |     |             mstore(0x00, 0x4c123d57)
  5900 |     |             mstore(0x20, p0)
  5901 |     |             mstore(0x40, p1)
  5902 |     |             mstore(0x60, p2)
  5903 |     |             mstore(0x80, p3)
  5904 |     |         }
  5905 |     |         _sendLogPayload(0x1c, 0x84);
  5906 |     |         assembly {
  5907 |     |             mstore(0x00, m0)
  5908 |     |             mstore(0x20, m1)
  5909 |     |             mstore(0x40, m2)
  5910 |     |             mstore(0x60, m3)
  5911 |     |             mstore(0x80, m4)
  5912 |     |         }
  5913 |     |     }
  5914 |     | 
  5915 |     |     function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {
  5916 |     |         bytes32 m0;
  5917 |     |         bytes32 m1;
  5918 |     |         bytes32 m2;
  5919 |     |         bytes32 m3;
  5920 |     |         bytes32 m4;
  5921 |     |         bytes32 m5;
  5922 |     |         bytes32 m6;
  5923 |     |         assembly {
  5924 |     |             function writeString(pos, w) {
  5925 |     |                 let length := 0
  5926 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  5927 |     |                 mstore(pos, length)
  5928 |     |                 let shift := sub(256, shl(3, length))
  5929 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  5930 |     |             }
  5931 |     |             m0 := mload(0x00)
  5932 |     |             m1 := mload(0x20)
  5933 |     |             m2 := mload(0x40)
  5934 |     |             m3 := mload(0x60)
  5935 |     |             m4 := mload(0x80)
  5936 |     |             m5 := mload(0xa0)
  5937 |     |             m6 := mload(0xc0)
  5938 |     |             // Selector of `log(bool,bool,address,string)`.
  5939 |     |             mstore(0x00, 0xa0a47963)
  5940 |     |             mstore(0x20, p0)
  5941 |     |             mstore(0x40, p1)
  5942 |     |             mstore(0x60, p2)
  5943 |     |             mstore(0x80, 0x80)
  5944 |     |             writeString(0xa0, p3)
  5945 |     |         }
  5946 |     |         _sendLogPayload(0x1c, 0xc4);
  5947 |     |         assembly {
  5948 |     |             mstore(0x00, m0)
  5949 |     |             mstore(0x20, m1)
  5950 |     |             mstore(0x40, m2)
  5951 |     |             mstore(0x60, m3)
  5952 |     |             mstore(0x80, m4)
  5953 |     |             mstore(0xa0, m5)
  5954 |     |             mstore(0xc0, m6)
  5955 |     |         }
  5956 |     |     }
  5957 |     | 
  5958 |     |     function log(bool p0, bool p1, bool p2, address p3) internal pure {
  5959 |     |         bytes32 m0;
  5960 |     |         bytes32 m1;
  5961 |     |         bytes32 m2;
  5962 |     |         bytes32 m3;
  5963 |     |         bytes32 m4;
  5964 |     |         assembly {
  5965 |     |             m0 := mload(0x00)
  5966 |     |             m1 := mload(0x20)
  5967 |     |             m2 := mload(0x40)
  5968 |     |             m3 := mload(0x60)
  5969 |     |             m4 := mload(0x80)
  5970 |     |             // Selector of `log(bool,bool,bool,address)`.
  5971 |     |             mstore(0x00, 0x8c329b1a)
  5972 |     |             mstore(0x20, p0)
  5973 |     |             mstore(0x40, p1)
  5974 |     |             mstore(0x60, p2)
  5975 |     |             mstore(0x80, p3)
  5976 |     |         }
  5977 |     |         _sendLogPayload(0x1c, 0x84);
  5978 |     |         assembly {
  5979 |     |             mstore(0x00, m0)
  5980 |     |             mstore(0x20, m1)
  5981 |     |             mstore(0x40, m2)
  5982 |     |             mstore(0x60, m3)
  5983 |     |             mstore(0x80, m4)
  5984 |     |         }
  5985 |     |     }
  5986 |     | 
  5987 |     |     function log(bool p0, bool p1, bool p2, bool p3) internal pure {
  5988 |     |         bytes32 m0;
  5989 |     |         bytes32 m1;
  5990 |     |         bytes32 m2;
  5991 |     |         bytes32 m3;
  5992 |     |         bytes32 m4;
  5993 |     |         assembly {
  5994 |     |             m0 := mload(0x00)
  5995 |     |             m1 := mload(0x20)
  5996 |     |             m2 := mload(0x40)
  5997 |     |             m3 := mload(0x60)
  5998 |     |             m4 := mload(0x80)
  5999 |     |             // Selector of `log(bool,bool,bool,bool)`.
  6000 |     |             mstore(0x00, 0x3b2a5ce0)
  6001 |     |             mstore(0x20, p0)
  6002 |     |             mstore(0x40, p1)
  6003 |     |             mstore(0x60, p2)
  6004 |     |             mstore(0x80, p3)
  6005 |     |         }
  6006 |     |         _sendLogPayload(0x1c, 0x84);
  6007 |     |         assembly {
  6008 |     |             mstore(0x00, m0)
  6009 |     |             mstore(0x20, m1)
  6010 |     |             mstore(0x40, m2)
  6011 |     |             mstore(0x60, m3)
  6012 |     |             mstore(0x80, m4)
  6013 |     |         }
  6014 |     |     }
  6015 |     | 
  6016 |     |     function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {
  6017 |     |         bytes32 m0;
  6018 |     |         bytes32 m1;
  6019 |     |         bytes32 m2;
  6020 |     |         bytes32 m3;
  6021 |     |         bytes32 m4;
  6022 |     |         assembly {
  6023 |     |             m0 := mload(0x00)
  6024 |     |             m1 := mload(0x20)
  6025 |     |             m2 := mload(0x40)
  6026 |     |             m3 := mload(0x60)
  6027 |     |             m4 := mload(0x80)
  6028 |     |             // Selector of `log(bool,bool,bool,uint256)`.
  6029 |     |             mstore(0x00, 0x6d7045c1)
  6030 |     |             mstore(0x20, p0)
  6031 |     |             mstore(0x40, p1)
  6032 |     |             mstore(0x60, p2)
  6033 |     |             mstore(0x80, p3)
  6034 |     |         }
  6035 |     |         _sendLogPayload(0x1c, 0x84);
  6036 |     |         assembly {
  6037 |     |             mstore(0x00, m0)
  6038 |     |             mstore(0x20, m1)
  6039 |     |             mstore(0x40, m2)
  6040 |     |             mstore(0x60, m3)
  6041 |     |             mstore(0x80, m4)
  6042 |     |         }
  6043 |     |     }
  6044 |     | 
  6045 |     |     function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {
  6046 |     |         bytes32 m0;
  6047 |     |         bytes32 m1;
  6048 |     |         bytes32 m2;
  6049 |     |         bytes32 m3;
  6050 |     |         bytes32 m4;
  6051 |     |         bytes32 m5;
  6052 |     |         bytes32 m6;
  6053 |     |         assembly {
  6054 |     |             function writeString(pos, w) {
  6055 |     |                 let length := 0
  6056 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6057 |     |                 mstore(pos, length)
  6058 |     |                 let shift := sub(256, shl(3, length))
  6059 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6060 |     |             }
  6061 |     |             m0 := mload(0x00)
  6062 |     |             m1 := mload(0x20)
  6063 |     |             m2 := mload(0x40)
  6064 |     |             m3 := mload(0x60)
  6065 |     |             m4 := mload(0x80)
  6066 |     |             m5 := mload(0xa0)
  6067 |     |             m6 := mload(0xc0)
  6068 |     |             // Selector of `log(bool,bool,bool,string)`.
  6069 |     |             mstore(0x00, 0x2ae408d4)
  6070 |     |             mstore(0x20, p0)
  6071 |     |             mstore(0x40, p1)
  6072 |     |             mstore(0x60, p2)
  6073 |     |             mstore(0x80, 0x80)
  6074 |     |             writeString(0xa0, p3)
  6075 |     |         }
  6076 |     |         _sendLogPayload(0x1c, 0xc4);
  6077 |     |         assembly {
  6078 |     |             mstore(0x00, m0)
  6079 |     |             mstore(0x20, m1)
  6080 |     |             mstore(0x40, m2)
  6081 |     |             mstore(0x60, m3)
  6082 |     |             mstore(0x80, m4)
  6083 |     |             mstore(0xa0, m5)
  6084 |     |             mstore(0xc0, m6)
  6085 |     |         }
  6086 |     |     }
  6087 |     | 
  6088 |     |     function log(bool p0, bool p1, uint256 p2, address p3) internal pure {
  6089 |     |         bytes32 m0;
  6090 |     |         bytes32 m1;
  6091 |     |         bytes32 m2;
  6092 |     |         bytes32 m3;
  6093 |     |         bytes32 m4;
  6094 |     |         assembly {
  6095 |     |             m0 := mload(0x00)
  6096 |     |             m1 := mload(0x20)
  6097 |     |             m2 := mload(0x40)
  6098 |     |             m3 := mload(0x60)
  6099 |     |             m4 := mload(0x80)
  6100 |     |             // Selector of `log(bool,bool,uint256,address)`.
  6101 |     |             mstore(0x00, 0x54a7a9a0)
  6102 |     |             mstore(0x20, p0)
  6103 |     |             mstore(0x40, p1)
  6104 |     |             mstore(0x60, p2)
  6105 |     |             mstore(0x80, p3)
  6106 |     |         }
  6107 |     |         _sendLogPayload(0x1c, 0x84);
  6108 |     |         assembly {
  6109 |     |             mstore(0x00, m0)
  6110 |     |             mstore(0x20, m1)
  6111 |     |             mstore(0x40, m2)
  6112 |     |             mstore(0x60, m3)
  6113 |     |             mstore(0x80, m4)
  6114 |     |         }
  6115 |     |     }
  6116 |     | 
  6117 |     |     function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {
  6118 |     |         bytes32 m0;
  6119 |     |         bytes32 m1;
  6120 |     |         bytes32 m2;
  6121 |     |         bytes32 m3;
  6122 |     |         bytes32 m4;
  6123 |     |         assembly {
  6124 |     |             m0 := mload(0x00)
  6125 |     |             m1 := mload(0x20)
  6126 |     |             m2 := mload(0x40)
  6127 |     |             m3 := mload(0x60)
  6128 |     |             m4 := mload(0x80)
  6129 |     |             // Selector of `log(bool,bool,uint256,bool)`.
  6130 |     |             mstore(0x00, 0x619e4d0e)
  6131 |     |             mstore(0x20, p0)
  6132 |     |             mstore(0x40, p1)
  6133 |     |             mstore(0x60, p2)
  6134 |     |             mstore(0x80, p3)
  6135 |     |         }
  6136 |     |         _sendLogPayload(0x1c, 0x84);
  6137 |     |         assembly {
  6138 |     |             mstore(0x00, m0)
  6139 |     |             mstore(0x20, m1)
  6140 |     |             mstore(0x40, m2)
  6141 |     |             mstore(0x60, m3)
  6142 |     |             mstore(0x80, m4)
  6143 |     |         }
  6144 |     |     }
  6145 |     | 
  6146 |     |     function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {
  6147 |     |         bytes32 m0;
  6148 |     |         bytes32 m1;
  6149 |     |         bytes32 m2;
  6150 |     |         bytes32 m3;
  6151 |     |         bytes32 m4;
  6152 |     |         assembly {
  6153 |     |             m0 := mload(0x00)
  6154 |     |             m1 := mload(0x20)
  6155 |     |             m2 := mload(0x40)
  6156 |     |             m3 := mload(0x60)
  6157 |     |             m4 := mload(0x80)
  6158 |     |             // Selector of `log(bool,bool,uint256,uint256)`.
  6159 |     |             mstore(0x00, 0x0bb00eab)
  6160 |     |             mstore(0x20, p0)
  6161 |     |             mstore(0x40, p1)
  6162 |     |             mstore(0x60, p2)
  6163 |     |             mstore(0x80, p3)
  6164 |     |         }
  6165 |     |         _sendLogPayload(0x1c, 0x84);
  6166 |     |         assembly {
  6167 |     |             mstore(0x00, m0)
  6168 |     |             mstore(0x20, m1)
  6169 |     |             mstore(0x40, m2)
  6170 |     |             mstore(0x60, m3)
  6171 |     |             mstore(0x80, m4)
  6172 |     |         }
  6173 |     |     }
  6174 |     | 
  6175 |     |     function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  6176 |     |         bytes32 m0;
  6177 |     |         bytes32 m1;
  6178 |     |         bytes32 m2;
  6179 |     |         bytes32 m3;
  6180 |     |         bytes32 m4;
  6181 |     |         bytes32 m5;
  6182 |     |         bytes32 m6;
  6183 |     |         assembly {
  6184 |     |             function writeString(pos, w) {
  6185 |     |                 let length := 0
  6186 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6187 |     |                 mstore(pos, length)
  6188 |     |                 let shift := sub(256, shl(3, length))
  6189 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6190 |     |             }
  6191 |     |             m0 := mload(0x00)
  6192 |     |             m1 := mload(0x20)
  6193 |     |             m2 := mload(0x40)
  6194 |     |             m3 := mload(0x60)
  6195 |     |             m4 := mload(0x80)
  6196 |     |             m5 := mload(0xa0)
  6197 |     |             m6 := mload(0xc0)
  6198 |     |             // Selector of `log(bool,bool,uint256,string)`.
  6199 |     |             mstore(0x00, 0x7dd4d0e0)
  6200 |     |             mstore(0x20, p0)
  6201 |     |             mstore(0x40, p1)
  6202 |     |             mstore(0x60, p2)
  6203 |     |             mstore(0x80, 0x80)
  6204 |     |             writeString(0xa0, p3)
  6205 |     |         }
  6206 |     |         _sendLogPayload(0x1c, 0xc4);
  6207 |     |         assembly {
  6208 |     |             mstore(0x00, m0)
  6209 |     |             mstore(0x20, m1)
  6210 |     |             mstore(0x40, m2)
  6211 |     |             mstore(0x60, m3)
  6212 |     |             mstore(0x80, m4)
  6213 |     |             mstore(0xa0, m5)
  6214 |     |             mstore(0xc0, m6)
  6215 |     |         }
  6216 |     |     }
  6217 |     | 
  6218 |     |     function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {
  6219 |     |         bytes32 m0;
  6220 |     |         bytes32 m1;
  6221 |     |         bytes32 m2;
  6222 |     |         bytes32 m3;
  6223 |     |         bytes32 m4;
  6224 |     |         bytes32 m5;
  6225 |     |         bytes32 m6;
  6226 |     |         assembly {
  6227 |     |             function writeString(pos, w) {
  6228 |     |                 let length := 0
  6229 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6230 |     |                 mstore(pos, length)
  6231 |     |                 let shift := sub(256, shl(3, length))
  6232 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6233 |     |             }
  6234 |     |             m0 := mload(0x00)
  6235 |     |             m1 := mload(0x20)
  6236 |     |             m2 := mload(0x40)
  6237 |     |             m3 := mload(0x60)
  6238 |     |             m4 := mload(0x80)
  6239 |     |             m5 := mload(0xa0)
  6240 |     |             m6 := mload(0xc0)
  6241 |     |             // Selector of `log(bool,bool,string,address)`.
  6242 |     |             mstore(0x00, 0xf9ad2b89)
  6243 |     |             mstore(0x20, p0)
  6244 |     |             mstore(0x40, p1)
  6245 |     |             mstore(0x60, 0x80)
  6246 |     |             mstore(0x80, p3)
  6247 |     |             writeString(0xa0, p2)
  6248 |     |         }
  6249 |     |         _sendLogPayload(0x1c, 0xc4);
  6250 |     |         assembly {
  6251 |     |             mstore(0x00, m0)
  6252 |     |             mstore(0x20, m1)
  6253 |     |             mstore(0x40, m2)
  6254 |     |             mstore(0x60, m3)
  6255 |     |             mstore(0x80, m4)
  6256 |     |             mstore(0xa0, m5)
  6257 |     |             mstore(0xc0, m6)
  6258 |     |         }
  6259 |     |     }
  6260 |     | 
  6261 |     |     function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {
  6262 |     |         bytes32 m0;
  6263 |     |         bytes32 m1;
  6264 |     |         bytes32 m2;
  6265 |     |         bytes32 m3;
  6266 |     |         bytes32 m4;
  6267 |     |         bytes32 m5;
  6268 |     |         bytes32 m6;
  6269 |     |         assembly {
  6270 |     |             function writeString(pos, w) {
  6271 |     |                 let length := 0
  6272 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6273 |     |                 mstore(pos, length)
  6274 |     |                 let shift := sub(256, shl(3, length))
  6275 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6276 |     |             }
  6277 |     |             m0 := mload(0x00)
  6278 |     |             m1 := mload(0x20)
  6279 |     |             m2 := mload(0x40)
  6280 |     |             m3 := mload(0x60)
  6281 |     |             m4 := mload(0x80)
  6282 |     |             m5 := mload(0xa0)
  6283 |     |             m6 := mload(0xc0)
  6284 |     |             // Selector of `log(bool,bool,string,bool)`.
  6285 |     |             mstore(0x00, 0xb857163a)
  6286 |     |             mstore(0x20, p0)
  6287 |     |             mstore(0x40, p1)
  6288 |     |             mstore(0x60, 0x80)
  6289 |     |             mstore(0x80, p3)
  6290 |     |             writeString(0xa0, p2)
  6291 |     |         }
  6292 |     |         _sendLogPayload(0x1c, 0xc4);
  6293 |     |         assembly {
  6294 |     |             mstore(0x00, m0)
  6295 |     |             mstore(0x20, m1)
  6296 |     |             mstore(0x40, m2)
  6297 |     |             mstore(0x60, m3)
  6298 |     |             mstore(0x80, m4)
  6299 |     |             mstore(0xa0, m5)
  6300 |     |             mstore(0xc0, m6)
  6301 |     |         }
  6302 |     |     }
  6303 |     | 
  6304 |     |     function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  6305 |     |         bytes32 m0;
  6306 |     |         bytes32 m1;
  6307 |     |         bytes32 m2;
  6308 |     |         bytes32 m3;
  6309 |     |         bytes32 m4;
  6310 |     |         bytes32 m5;
  6311 |     |         bytes32 m6;
  6312 |     |         assembly {
  6313 |     |             function writeString(pos, w) {
  6314 |     |                 let length := 0
  6315 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6316 |     |                 mstore(pos, length)
  6317 |     |                 let shift := sub(256, shl(3, length))
  6318 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6319 |     |             }
  6320 |     |             m0 := mload(0x00)
  6321 |     |             m1 := mload(0x20)
  6322 |     |             m2 := mload(0x40)
  6323 |     |             m3 := mload(0x60)
  6324 |     |             m4 := mload(0x80)
  6325 |     |             m5 := mload(0xa0)
  6326 |     |             m6 := mload(0xc0)
  6327 |     |             // Selector of `log(bool,bool,string,uint256)`.
  6328 |     |             mstore(0x00, 0xe3a9ca2f)
  6329 |     |             mstore(0x20, p0)
  6330 |     |             mstore(0x40, p1)
  6331 |     |             mstore(0x60, 0x80)
  6332 |     |             mstore(0x80, p3)
  6333 |     |             writeString(0xa0, p2)
  6334 |     |         }
  6335 |     |         _sendLogPayload(0x1c, 0xc4);
  6336 |     |         assembly {
  6337 |     |             mstore(0x00, m0)
  6338 |     |             mstore(0x20, m1)
  6339 |     |             mstore(0x40, m2)
  6340 |     |             mstore(0x60, m3)
  6341 |     |             mstore(0x80, m4)
  6342 |     |             mstore(0xa0, m5)
  6343 |     |             mstore(0xc0, m6)
  6344 |     |         }
  6345 |     |     }
  6346 |     | 
  6347 |     |     function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  6348 |     |         bytes32 m0;
  6349 |     |         bytes32 m1;
  6350 |     |         bytes32 m2;
  6351 |     |         bytes32 m3;
  6352 |     |         bytes32 m4;
  6353 |     |         bytes32 m5;
  6354 |     |         bytes32 m6;
  6355 |     |         bytes32 m7;
  6356 |     |         bytes32 m8;
  6357 |     |         assembly {
  6358 |     |             function writeString(pos, w) {
  6359 |     |                 let length := 0
  6360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6361 |     |                 mstore(pos, length)
  6362 |     |                 let shift := sub(256, shl(3, length))
  6363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6364 |     |             }
  6365 |     |             m0 := mload(0x00)
  6366 |     |             m1 := mload(0x20)
  6367 |     |             m2 := mload(0x40)
  6368 |     |             m3 := mload(0x60)
  6369 |     |             m4 := mload(0x80)
  6370 |     |             m5 := mload(0xa0)
  6371 |     |             m6 := mload(0xc0)
  6372 |     |             m7 := mload(0xe0)
  6373 |     |             m8 := mload(0x100)
  6374 |     |             // Selector of `log(bool,bool,string,string)`.
  6375 |     |             mstore(0x00, 0x6d1e8751)
  6376 |     |             mstore(0x20, p0)
  6377 |     |             mstore(0x40, p1)
  6378 |     |             mstore(0x60, 0x80)
  6379 |     |             mstore(0x80, 0xc0)
  6380 |     |             writeString(0xa0, p2)
  6381 |     |             writeString(0xe0, p3)
  6382 |     |         }
  6383 |     |         _sendLogPayload(0x1c, 0x104);
  6384 |     |         assembly {
  6385 |     |             mstore(0x00, m0)
  6386 |     |             mstore(0x20, m1)
  6387 |     |             mstore(0x40, m2)
  6388 |     |             mstore(0x60, m3)
  6389 |     |             mstore(0x80, m4)
  6390 |     |             mstore(0xa0, m5)
  6391 |     |             mstore(0xc0, m6)
  6392 |     |             mstore(0xe0, m7)
  6393 |     |             mstore(0x100, m8)
  6394 |     |         }
  6395 |     |     }
  6396 |     | 
  6397 |     |     function log(bool p0, uint256 p1, address p2, address p3) internal pure {
  6398 |     |         bytes32 m0;
  6399 |     |         bytes32 m1;
  6400 |     |         bytes32 m2;
  6401 |     |         bytes32 m3;
  6402 |     |         bytes32 m4;
  6403 |     |         assembly {
  6404 |     |             m0 := mload(0x00)
  6405 |     |             m1 := mload(0x20)
  6406 |     |             m2 := mload(0x40)
  6407 |     |             m3 := mload(0x60)
  6408 |     |             m4 := mload(0x80)
  6409 |     |             // Selector of `log(bool,uint256,address,address)`.
  6410 |     |             mstore(0x00, 0x26f560a8)
  6411 |     |             mstore(0x20, p0)
  6412 |     |             mstore(0x40, p1)
  6413 |     |             mstore(0x60, p2)
  6414 |     |             mstore(0x80, p3)
  6415 |     |         }
  6416 |     |         _sendLogPayload(0x1c, 0x84);
  6417 |     |         assembly {
  6418 |     |             mstore(0x00, m0)
  6419 |     |             mstore(0x20, m1)
  6420 |     |             mstore(0x40, m2)
  6421 |     |             mstore(0x60, m3)
  6422 |     |             mstore(0x80, m4)
  6423 |     |         }
  6424 |     |     }
  6425 |     | 
  6426 |     |     function log(bool p0, uint256 p1, address p2, bool p3) internal pure {
  6427 |     |         bytes32 m0;
  6428 |     |         bytes32 m1;
  6429 |     |         bytes32 m2;
  6430 |     |         bytes32 m3;
  6431 |     |         bytes32 m4;
  6432 |     |         assembly {
  6433 |     |             m0 := mload(0x00)
  6434 |     |             m1 := mload(0x20)
  6435 |     |             m2 := mload(0x40)
  6436 |     |             m3 := mload(0x60)
  6437 |     |             m4 := mload(0x80)
  6438 |     |             // Selector of `log(bool,uint256,address,bool)`.
  6439 |     |             mstore(0x00, 0xb4c314ff)
  6440 |     |             mstore(0x20, p0)
  6441 |     |             mstore(0x40, p1)
  6442 |     |             mstore(0x60, p2)
  6443 |     |             mstore(0x80, p3)
  6444 |     |         }
  6445 |     |         _sendLogPayload(0x1c, 0x84);
  6446 |     |         assembly {
  6447 |     |             mstore(0x00, m0)
  6448 |     |             mstore(0x20, m1)
  6449 |     |             mstore(0x40, m2)
  6450 |     |             mstore(0x60, m3)
  6451 |     |             mstore(0x80, m4)
  6452 |     |         }
  6453 |     |     }
  6454 |     | 
  6455 |     |     function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {
  6456 |     |         bytes32 m0;
  6457 |     |         bytes32 m1;
  6458 |     |         bytes32 m2;
  6459 |     |         bytes32 m3;
  6460 |     |         bytes32 m4;
  6461 |     |         assembly {
  6462 |     |             m0 := mload(0x00)
  6463 |     |             m1 := mload(0x20)
  6464 |     |             m2 := mload(0x40)
  6465 |     |             m3 := mload(0x60)
  6466 |     |             m4 := mload(0x80)
  6467 |     |             // Selector of `log(bool,uint256,address,uint256)`.
  6468 |     |             mstore(0x00, 0x1537dc87)
  6469 |     |             mstore(0x20, p0)
  6470 |     |             mstore(0x40, p1)
  6471 |     |             mstore(0x60, p2)
  6472 |     |             mstore(0x80, p3)
  6473 |     |         }
  6474 |     |         _sendLogPayload(0x1c, 0x84);
  6475 |     |         assembly {
  6476 |     |             mstore(0x00, m0)
  6477 |     |             mstore(0x20, m1)
  6478 |     |             mstore(0x40, m2)
  6479 |     |             mstore(0x60, m3)
  6480 |     |             mstore(0x80, m4)
  6481 |     |         }
  6482 |     |     }
  6483 |     | 
  6484 |     |     function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {
  6485 |     |         bytes32 m0;
  6486 |     |         bytes32 m1;
  6487 |     |         bytes32 m2;
  6488 |     |         bytes32 m3;
  6489 |     |         bytes32 m4;
  6490 |     |         bytes32 m5;
  6491 |     |         bytes32 m6;
  6492 |     |         assembly {
  6493 |     |             function writeString(pos, w) {
  6494 |     |                 let length := 0
  6495 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6496 |     |                 mstore(pos, length)
  6497 |     |                 let shift := sub(256, shl(3, length))
  6498 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6499 |     |             }
  6500 |     |             m0 := mload(0x00)
  6501 |     |             m1 := mload(0x20)
  6502 |     |             m2 := mload(0x40)
  6503 |     |             m3 := mload(0x60)
  6504 |     |             m4 := mload(0x80)
  6505 |     |             m5 := mload(0xa0)
  6506 |     |             m6 := mload(0xc0)
  6507 |     |             // Selector of `log(bool,uint256,address,string)`.
  6508 |     |             mstore(0x00, 0x1bb3b09a)
  6509 |     |             mstore(0x20, p0)
  6510 |     |             mstore(0x40, p1)
  6511 |     |             mstore(0x60, p2)
  6512 |     |             mstore(0x80, 0x80)
  6513 |     |             writeString(0xa0, p3)
  6514 |     |         }
  6515 |     |         _sendLogPayload(0x1c, 0xc4);
  6516 |     |         assembly {
  6517 |     |             mstore(0x00, m0)
  6518 |     |             mstore(0x20, m1)
  6519 |     |             mstore(0x40, m2)
  6520 |     |             mstore(0x60, m3)
  6521 |     |             mstore(0x80, m4)
  6522 |     |             mstore(0xa0, m5)
  6523 |     |             mstore(0xc0, m6)
  6524 |     |         }
  6525 |     |     }
  6526 |     | 
  6527 |     |     function log(bool p0, uint256 p1, bool p2, address p3) internal pure {
  6528 |     |         bytes32 m0;
  6529 |     |         bytes32 m1;
  6530 |     |         bytes32 m2;
  6531 |     |         bytes32 m3;
  6532 |     |         bytes32 m4;
  6533 |     |         assembly {
  6534 |     |             m0 := mload(0x00)
  6535 |     |             m1 := mload(0x20)
  6536 |     |             m2 := mload(0x40)
  6537 |     |             m3 := mload(0x60)
  6538 |     |             m4 := mload(0x80)
  6539 |     |             // Selector of `log(bool,uint256,bool,address)`.
  6540 |     |             mstore(0x00, 0x9acd3616)
  6541 |     |             mstore(0x20, p0)
  6542 |     |             mstore(0x40, p1)
  6543 |     |             mstore(0x60, p2)
  6544 |     |             mstore(0x80, p3)
  6545 |     |         }
  6546 |     |         _sendLogPayload(0x1c, 0x84);
  6547 |     |         assembly {
  6548 |     |             mstore(0x00, m0)
  6549 |     |             mstore(0x20, m1)
  6550 |     |             mstore(0x40, m2)
  6551 |     |             mstore(0x60, m3)
  6552 |     |             mstore(0x80, m4)
  6553 |     |         }
  6554 |     |     }
  6555 |     | 
  6556 |     |     function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {
  6557 |     |         bytes32 m0;
  6558 |     |         bytes32 m1;
  6559 |     |         bytes32 m2;
  6560 |     |         bytes32 m3;
  6561 |     |         bytes32 m4;
  6562 |     |         assembly {
  6563 |     |             m0 := mload(0x00)
  6564 |     |             m1 := mload(0x20)
  6565 |     |             m2 := mload(0x40)
  6566 |     |             m3 := mload(0x60)
  6567 |     |             m4 := mload(0x80)
  6568 |     |             // Selector of `log(bool,uint256,bool,bool)`.
  6569 |     |             mstore(0x00, 0xceb5f4d7)
  6570 |     |             mstore(0x20, p0)
  6571 |     |             mstore(0x40, p1)
  6572 |     |             mstore(0x60, p2)
  6573 |     |             mstore(0x80, p3)
  6574 |     |         }
  6575 |     |         _sendLogPayload(0x1c, 0x84);
  6576 |     |         assembly {
  6577 |     |             mstore(0x00, m0)
  6578 |     |             mstore(0x20, m1)
  6579 |     |             mstore(0x40, m2)
  6580 |     |             mstore(0x60, m3)
  6581 |     |             mstore(0x80, m4)
  6582 |     |         }
  6583 |     |     }
  6584 |     | 
  6585 |     |     function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {
  6586 |     |         bytes32 m0;
  6587 |     |         bytes32 m1;
  6588 |     |         bytes32 m2;
  6589 |     |         bytes32 m3;
  6590 |     |         bytes32 m4;
  6591 |     |         assembly {
  6592 |     |             m0 := mload(0x00)
  6593 |     |             m1 := mload(0x20)
  6594 |     |             m2 := mload(0x40)
  6595 |     |             m3 := mload(0x60)
  6596 |     |             m4 := mload(0x80)
  6597 |     |             // Selector of `log(bool,uint256,bool,uint256)`.
  6598 |     |             mstore(0x00, 0x7f9bbca2)
  6599 |     |             mstore(0x20, p0)
  6600 |     |             mstore(0x40, p1)
  6601 |     |             mstore(0x60, p2)
  6602 |     |             mstore(0x80, p3)
  6603 |     |         }
  6604 |     |         _sendLogPayload(0x1c, 0x84);
  6605 |     |         assembly {
  6606 |     |             mstore(0x00, m0)
  6607 |     |             mstore(0x20, m1)
  6608 |     |             mstore(0x40, m2)
  6609 |     |             mstore(0x60, m3)
  6610 |     |             mstore(0x80, m4)
  6611 |     |         }
  6612 |     |     }
  6613 |     | 
  6614 |     |     function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  6615 |     |         bytes32 m0;
  6616 |     |         bytes32 m1;
  6617 |     |         bytes32 m2;
  6618 |     |         bytes32 m3;
  6619 |     |         bytes32 m4;
  6620 |     |         bytes32 m5;
  6621 |     |         bytes32 m6;
  6622 |     |         assembly {
  6623 |     |             function writeString(pos, w) {
  6624 |     |                 let length := 0
  6625 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6626 |     |                 mstore(pos, length)
  6627 |     |                 let shift := sub(256, shl(3, length))
  6628 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6629 |     |             }
  6630 |     |             m0 := mload(0x00)
  6631 |     |             m1 := mload(0x20)
  6632 |     |             m2 := mload(0x40)
  6633 |     |             m3 := mload(0x60)
  6634 |     |             m4 := mload(0x80)
  6635 |     |             m5 := mload(0xa0)
  6636 |     |             m6 := mload(0xc0)
  6637 |     |             // Selector of `log(bool,uint256,bool,string)`.
  6638 |     |             mstore(0x00, 0x9143dbb1)
  6639 |     |             mstore(0x20, p0)
  6640 |     |             mstore(0x40, p1)
  6641 |     |             mstore(0x60, p2)
  6642 |     |             mstore(0x80, 0x80)
  6643 |     |             writeString(0xa0, p3)
  6644 |     |         }
  6645 |     |         _sendLogPayload(0x1c, 0xc4);
  6646 |     |         assembly {
  6647 |     |             mstore(0x00, m0)
  6648 |     |             mstore(0x20, m1)
  6649 |     |             mstore(0x40, m2)
  6650 |     |             mstore(0x60, m3)
  6651 |     |             mstore(0x80, m4)
  6652 |     |             mstore(0xa0, m5)
  6653 |     |             mstore(0xc0, m6)
  6654 |     |         }
  6655 |     |     }
  6656 |     | 
  6657 |     |     function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {
  6658 |     |         bytes32 m0;
  6659 |     |         bytes32 m1;
  6660 |     |         bytes32 m2;
  6661 |     |         bytes32 m3;
  6662 |     |         bytes32 m4;
  6663 |     |         assembly {
  6664 |     |             m0 := mload(0x00)
  6665 |     |             m1 := mload(0x20)
  6666 |     |             m2 := mload(0x40)
  6667 |     |             m3 := mload(0x60)
  6668 |     |             m4 := mload(0x80)
  6669 |     |             // Selector of `log(bool,uint256,uint256,address)`.
  6670 |     |             mstore(0x00, 0x00dd87b9)
  6671 |     |             mstore(0x20, p0)
  6672 |     |             mstore(0x40, p1)
  6673 |     |             mstore(0x60, p2)
  6674 |     |             mstore(0x80, p3)
  6675 |     |         }
  6676 |     |         _sendLogPayload(0x1c, 0x84);
  6677 |     |         assembly {
  6678 |     |             mstore(0x00, m0)
  6679 |     |             mstore(0x20, m1)
  6680 |     |             mstore(0x40, m2)
  6681 |     |             mstore(0x60, m3)
  6682 |     |             mstore(0x80, m4)
  6683 |     |         }
  6684 |     |     }
  6685 |     | 
  6686 |     |     function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {
  6687 |     |         bytes32 m0;
  6688 |     |         bytes32 m1;
  6689 |     |         bytes32 m2;
  6690 |     |         bytes32 m3;
  6691 |     |         bytes32 m4;
  6692 |     |         assembly {
  6693 |     |             m0 := mload(0x00)
  6694 |     |             m1 := mload(0x20)
  6695 |     |             m2 := mload(0x40)
  6696 |     |             m3 := mload(0x60)
  6697 |     |             m4 := mload(0x80)
  6698 |     |             // Selector of `log(bool,uint256,uint256,bool)`.
  6699 |     |             mstore(0x00, 0xbe984353)
  6700 |     |             mstore(0x20, p0)
  6701 |     |             mstore(0x40, p1)
  6702 |     |             mstore(0x60, p2)
  6703 |     |             mstore(0x80, p3)
  6704 |     |         }
  6705 |     |         _sendLogPayload(0x1c, 0x84);
  6706 |     |         assembly {
  6707 |     |             mstore(0x00, m0)
  6708 |     |             mstore(0x20, m1)
  6709 |     |             mstore(0x40, m2)
  6710 |     |             mstore(0x60, m3)
  6711 |     |             mstore(0x80, m4)
  6712 |     |         }
  6713 |     |     }
  6714 |     | 
  6715 |     |     function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  6716 |     |         bytes32 m0;
  6717 |     |         bytes32 m1;
  6718 |     |         bytes32 m2;
  6719 |     |         bytes32 m3;
  6720 |     |         bytes32 m4;
  6721 |     |         assembly {
  6722 |     |             m0 := mload(0x00)
  6723 |     |             m1 := mload(0x20)
  6724 |     |             m2 := mload(0x40)
  6725 |     |             m3 := mload(0x60)
  6726 |     |             m4 := mload(0x80)
  6727 |     |             // Selector of `log(bool,uint256,uint256,uint256)`.
  6728 |     |             mstore(0x00, 0x374bb4b2)
  6729 |     |             mstore(0x20, p0)
  6730 |     |             mstore(0x40, p1)
  6731 |     |             mstore(0x60, p2)
  6732 |     |             mstore(0x80, p3)
  6733 |     |         }
  6734 |     |         _sendLogPayload(0x1c, 0x84);
  6735 |     |         assembly {
  6736 |     |             mstore(0x00, m0)
  6737 |     |             mstore(0x20, m1)
  6738 |     |             mstore(0x40, m2)
  6739 |     |             mstore(0x60, m3)
  6740 |     |             mstore(0x80, m4)
  6741 |     |         }
  6742 |     |     }
  6743 |     | 
  6744 |     |     function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  6745 |     |         bytes32 m0;
  6746 |     |         bytes32 m1;
  6747 |     |         bytes32 m2;
  6748 |     |         bytes32 m3;
  6749 |     |         bytes32 m4;
  6750 |     |         bytes32 m5;
  6751 |     |         bytes32 m6;
  6752 |     |         assembly {
  6753 |     |             function writeString(pos, w) {
  6754 |     |                 let length := 0
  6755 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6756 |     |                 mstore(pos, length)
  6757 |     |                 let shift := sub(256, shl(3, length))
  6758 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6759 |     |             }
  6760 |     |             m0 := mload(0x00)
  6761 |     |             m1 := mload(0x20)
  6762 |     |             m2 := mload(0x40)
  6763 |     |             m3 := mload(0x60)
  6764 |     |             m4 := mload(0x80)
  6765 |     |             m5 := mload(0xa0)
  6766 |     |             m6 := mload(0xc0)
  6767 |     |             // Selector of `log(bool,uint256,uint256,string)`.
  6768 |     |             mstore(0x00, 0x8e69fb5d)
  6769 |     |             mstore(0x20, p0)
  6770 |     |             mstore(0x40, p1)
  6771 |     |             mstore(0x60, p2)
  6772 |     |             mstore(0x80, 0x80)
  6773 |     |             writeString(0xa0, p3)
  6774 |     |         }
  6775 |     |         _sendLogPayload(0x1c, 0xc4);
  6776 |     |         assembly {
  6777 |     |             mstore(0x00, m0)
  6778 |     |             mstore(0x20, m1)
  6779 |     |             mstore(0x40, m2)
  6780 |     |             mstore(0x60, m3)
  6781 |     |             mstore(0x80, m4)
  6782 |     |             mstore(0xa0, m5)
  6783 |     |             mstore(0xc0, m6)
  6784 |     |         }
  6785 |     |     }
  6786 |     | 
  6787 |     |     function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {
  6788 |     |         bytes32 m0;
  6789 |     |         bytes32 m1;
  6790 |     |         bytes32 m2;
  6791 |     |         bytes32 m3;
  6792 |     |         bytes32 m4;
  6793 |     |         bytes32 m5;
  6794 |     |         bytes32 m6;
  6795 |     |         assembly {
  6796 |     |             function writeString(pos, w) {
  6797 |     |                 let length := 0
  6798 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6799 |     |                 mstore(pos, length)
  6800 |     |                 let shift := sub(256, shl(3, length))
  6801 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6802 |     |             }
  6803 |     |             m0 := mload(0x00)
  6804 |     |             m1 := mload(0x20)
  6805 |     |             m2 := mload(0x40)
  6806 |     |             m3 := mload(0x60)
  6807 |     |             m4 := mload(0x80)
  6808 |     |             m5 := mload(0xa0)
  6809 |     |             m6 := mload(0xc0)
  6810 |     |             // Selector of `log(bool,uint256,string,address)`.
  6811 |     |             mstore(0x00, 0xfedd1fff)
  6812 |     |             mstore(0x20, p0)
  6813 |     |             mstore(0x40, p1)
  6814 |     |             mstore(0x60, 0x80)
  6815 |     |             mstore(0x80, p3)
  6816 |     |             writeString(0xa0, p2)
  6817 |     |         }
  6818 |     |         _sendLogPayload(0x1c, 0xc4);
  6819 |     |         assembly {
  6820 |     |             mstore(0x00, m0)
  6821 |     |             mstore(0x20, m1)
  6822 |     |             mstore(0x40, m2)
  6823 |     |             mstore(0x60, m3)
  6824 |     |             mstore(0x80, m4)
  6825 |     |             mstore(0xa0, m5)
  6826 |     |             mstore(0xc0, m6)
  6827 |     |         }
  6828 |     |     }
  6829 |     | 
  6830 |     |     function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  6831 |     |         bytes32 m0;
  6832 |     |         bytes32 m1;
  6833 |     |         bytes32 m2;
  6834 |     |         bytes32 m3;
  6835 |     |         bytes32 m4;
  6836 |     |         bytes32 m5;
  6837 |     |         bytes32 m6;
  6838 |     |         assembly {
  6839 |     |             function writeString(pos, w) {
  6840 |     |                 let length := 0
  6841 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6842 |     |                 mstore(pos, length)
  6843 |     |                 let shift := sub(256, shl(3, length))
  6844 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6845 |     |             }
  6846 |     |             m0 := mload(0x00)
  6847 |     |             m1 := mload(0x20)
  6848 |     |             m2 := mload(0x40)
  6849 |     |             m3 := mload(0x60)
  6850 |     |             m4 := mload(0x80)
  6851 |     |             m5 := mload(0xa0)
  6852 |     |             m6 := mload(0xc0)
  6853 |     |             // Selector of `log(bool,uint256,string,bool)`.
  6854 |     |             mstore(0x00, 0xe5e70b2b)
  6855 |     |             mstore(0x20, p0)
  6856 |     |             mstore(0x40, p1)
  6857 |     |             mstore(0x60, 0x80)
  6858 |     |             mstore(0x80, p3)
  6859 |     |             writeString(0xa0, p2)
  6860 |     |         }
  6861 |     |         _sendLogPayload(0x1c, 0xc4);
  6862 |     |         assembly {
  6863 |     |             mstore(0x00, m0)
  6864 |     |             mstore(0x20, m1)
  6865 |     |             mstore(0x40, m2)
  6866 |     |             mstore(0x60, m3)
  6867 |     |             mstore(0x80, m4)
  6868 |     |             mstore(0xa0, m5)
  6869 |     |             mstore(0xc0, m6)
  6870 |     |         }
  6871 |     |     }
  6872 |     | 
  6873 |     |     function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  6874 |     |         bytes32 m0;
  6875 |     |         bytes32 m1;
  6876 |     |         bytes32 m2;
  6877 |     |         bytes32 m3;
  6878 |     |         bytes32 m4;
  6879 |     |         bytes32 m5;
  6880 |     |         bytes32 m6;
  6881 |     |         assembly {
  6882 |     |             function writeString(pos, w) {
  6883 |     |                 let length := 0
  6884 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6885 |     |                 mstore(pos, length)
  6886 |     |                 let shift := sub(256, shl(3, length))
  6887 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6888 |     |             }
  6889 |     |             m0 := mload(0x00)
  6890 |     |             m1 := mload(0x20)
  6891 |     |             m2 := mload(0x40)
  6892 |     |             m3 := mload(0x60)
  6893 |     |             m4 := mload(0x80)
  6894 |     |             m5 := mload(0xa0)
  6895 |     |             m6 := mload(0xc0)
  6896 |     |             // Selector of `log(bool,uint256,string,uint256)`.
  6897 |     |             mstore(0x00, 0x6a1199e2)
  6898 |     |             mstore(0x20, p0)
  6899 |     |             mstore(0x40, p1)
  6900 |     |             mstore(0x60, 0x80)
  6901 |     |             mstore(0x80, p3)
  6902 |     |             writeString(0xa0, p2)
  6903 |     |         }
  6904 |     |         _sendLogPayload(0x1c, 0xc4);
  6905 |     |         assembly {
  6906 |     |             mstore(0x00, m0)
  6907 |     |             mstore(0x20, m1)
  6908 |     |             mstore(0x40, m2)
  6909 |     |             mstore(0x60, m3)
  6910 |     |             mstore(0x80, m4)
  6911 |     |             mstore(0xa0, m5)
  6912 |     |             mstore(0xc0, m6)
  6913 |     |         }
  6914 |     |     }
  6915 |     | 
  6916 |     |     function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  6917 |     |         bytes32 m0;
  6918 |     |         bytes32 m1;
  6919 |     |         bytes32 m2;
  6920 |     |         bytes32 m3;
  6921 |     |         bytes32 m4;
  6922 |     |         bytes32 m5;
  6923 |     |         bytes32 m6;
  6924 |     |         bytes32 m7;
  6925 |     |         bytes32 m8;
  6926 |     |         assembly {
  6927 |     |             function writeString(pos, w) {
  6928 |     |                 let length := 0
  6929 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6930 |     |                 mstore(pos, length)
  6931 |     |                 let shift := sub(256, shl(3, length))
  6932 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6933 |     |             }
  6934 |     |             m0 := mload(0x00)
  6935 |     |             m1 := mload(0x20)
  6936 |     |             m2 := mload(0x40)
  6937 |     |             m3 := mload(0x60)
  6938 |     |             m4 := mload(0x80)
  6939 |     |             m5 := mload(0xa0)
  6940 |     |             m6 := mload(0xc0)
  6941 |     |             m7 := mload(0xe0)
  6942 |     |             m8 := mload(0x100)
  6943 |     |             // Selector of `log(bool,uint256,string,string)`.
  6944 |     |             mstore(0x00, 0xf5bc2249)
  6945 |     |             mstore(0x20, p0)
  6946 |     |             mstore(0x40, p1)
  6947 |     |             mstore(0x60, 0x80)
  6948 |     |             mstore(0x80, 0xc0)
  6949 |     |             writeString(0xa0, p2)
  6950 |     |             writeString(0xe0, p3)
  6951 |     |         }
  6952 |     |         _sendLogPayload(0x1c, 0x104);
  6953 |     |         assembly {
  6954 |     |             mstore(0x00, m0)
  6955 |     |             mstore(0x20, m1)
  6956 |     |             mstore(0x40, m2)
  6957 |     |             mstore(0x60, m3)
  6958 |     |             mstore(0x80, m4)
  6959 |     |             mstore(0xa0, m5)
  6960 |     |             mstore(0xc0, m6)
  6961 |     |             mstore(0xe0, m7)
  6962 |     |             mstore(0x100, m8)
  6963 |     |         }
  6964 |     |     }
  6965 |     | 
  6966 |     |     function log(bool p0, bytes32 p1, address p2, address p3) internal pure {
  6967 |     |         bytes32 m0;
  6968 |     |         bytes32 m1;
  6969 |     |         bytes32 m2;
  6970 |     |         bytes32 m3;
  6971 |     |         bytes32 m4;
  6972 |     |         bytes32 m5;
  6973 |     |         bytes32 m6;
  6974 |     |         assembly {
  6975 |     |             function writeString(pos, w) {
  6976 |     |                 let length := 0
  6977 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  6978 |     |                 mstore(pos, length)
  6979 |     |                 let shift := sub(256, shl(3, length))
  6980 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  6981 |     |             }
  6982 |     |             m0 := mload(0x00)
  6983 |     |             m1 := mload(0x20)
  6984 |     |             m2 := mload(0x40)
  6985 |     |             m3 := mload(0x60)
  6986 |     |             m4 := mload(0x80)
  6987 |     |             m5 := mload(0xa0)
  6988 |     |             m6 := mload(0xc0)
  6989 |     |             // Selector of `log(bool,string,address,address)`.
  6990 |     |             mstore(0x00, 0x2b2b18dc)
  6991 |     |             mstore(0x20, p0)
  6992 |     |             mstore(0x40, 0x80)
  6993 |     |             mstore(0x60, p2)
  6994 |     |             mstore(0x80, p3)
  6995 |     |             writeString(0xa0, p1)
  6996 |     |         }
  6997 |     |         _sendLogPayload(0x1c, 0xc4);
  6998 |     |         assembly {
  6999 |     |             mstore(0x00, m0)
  7000 |     |             mstore(0x20, m1)
  7001 |     |             mstore(0x40, m2)
  7002 |     |             mstore(0x60, m3)
  7003 |     |             mstore(0x80, m4)
  7004 |     |             mstore(0xa0, m5)
  7005 |     |             mstore(0xc0, m6)
  7006 |     |         }
  7007 |     |     }
  7008 |     | 
  7009 |     |     function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {
  7010 |     |         bytes32 m0;
  7011 |     |         bytes32 m1;
  7012 |     |         bytes32 m2;
  7013 |     |         bytes32 m3;
  7014 |     |         bytes32 m4;
  7015 |     |         bytes32 m5;
  7016 |     |         bytes32 m6;
  7017 |     |         assembly {
  7018 |     |             function writeString(pos, w) {
  7019 |     |                 let length := 0
  7020 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7021 |     |                 mstore(pos, length)
  7022 |     |                 let shift := sub(256, shl(3, length))
  7023 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7024 |     |             }
  7025 |     |             m0 := mload(0x00)
  7026 |     |             m1 := mload(0x20)
  7027 |     |             m2 := mload(0x40)
  7028 |     |             m3 := mload(0x60)
  7029 |     |             m4 := mload(0x80)
  7030 |     |             m5 := mload(0xa0)
  7031 |     |             m6 := mload(0xc0)
  7032 |     |             // Selector of `log(bool,string,address,bool)`.
  7033 |     |             mstore(0x00, 0x6dd434ca)
  7034 |     |             mstore(0x20, p0)
  7035 |     |             mstore(0x40, 0x80)
  7036 |     |             mstore(0x60, p2)
  7037 |     |             mstore(0x80, p3)
  7038 |     |             writeString(0xa0, p1)
  7039 |     |         }
  7040 |     |         _sendLogPayload(0x1c, 0xc4);
  7041 |     |         assembly {
  7042 |     |             mstore(0x00, m0)
  7043 |     |             mstore(0x20, m1)
  7044 |     |             mstore(0x40, m2)
  7045 |     |             mstore(0x60, m3)
  7046 |     |             mstore(0x80, m4)
  7047 |     |             mstore(0xa0, m5)
  7048 |     |             mstore(0xc0, m6)
  7049 |     |         }
  7050 |     |     }
  7051 |     | 
  7052 |     |     function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {
  7053 |     |         bytes32 m0;
  7054 |     |         bytes32 m1;
  7055 |     |         bytes32 m2;
  7056 |     |         bytes32 m3;
  7057 |     |         bytes32 m4;
  7058 |     |         bytes32 m5;
  7059 |     |         bytes32 m6;
  7060 |     |         assembly {
  7061 |     |             function writeString(pos, w) {
  7062 |     |                 let length := 0
  7063 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7064 |     |                 mstore(pos, length)
  7065 |     |                 let shift := sub(256, shl(3, length))
  7066 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7067 |     |             }
  7068 |     |             m0 := mload(0x00)
  7069 |     |             m1 := mload(0x20)
  7070 |     |             m2 := mload(0x40)
  7071 |     |             m3 := mload(0x60)
  7072 |     |             m4 := mload(0x80)
  7073 |     |             m5 := mload(0xa0)
  7074 |     |             m6 := mload(0xc0)
  7075 |     |             // Selector of `log(bool,string,address,uint256)`.
  7076 |     |             mstore(0x00, 0xa5cada94)
  7077 |     |             mstore(0x20, p0)
  7078 |     |             mstore(0x40, 0x80)
  7079 |     |             mstore(0x60, p2)
  7080 |     |             mstore(0x80, p3)
  7081 |     |             writeString(0xa0, p1)
  7082 |     |         }
  7083 |     |         _sendLogPayload(0x1c, 0xc4);
  7084 |     |         assembly {
  7085 |     |             mstore(0x00, m0)
  7086 |     |             mstore(0x20, m1)
  7087 |     |             mstore(0x40, m2)
  7088 |     |             mstore(0x60, m3)
  7089 |     |             mstore(0x80, m4)
  7090 |     |             mstore(0xa0, m5)
  7091 |     |             mstore(0xc0, m6)
  7092 |     |         }
  7093 |     |     }
  7094 |     | 
  7095 |     |     function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  7096 |     |         bytes32 m0;
  7097 |     |         bytes32 m1;
  7098 |     |         bytes32 m2;
  7099 |     |         bytes32 m3;
  7100 |     |         bytes32 m4;
  7101 |     |         bytes32 m5;
  7102 |     |         bytes32 m6;
  7103 |     |         bytes32 m7;
  7104 |     |         bytes32 m8;
  7105 |     |         assembly {
  7106 |     |             function writeString(pos, w) {
  7107 |     |                 let length := 0
  7108 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7109 |     |                 mstore(pos, length)
  7110 |     |                 let shift := sub(256, shl(3, length))
  7111 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7112 |     |             }
  7113 |     |             m0 := mload(0x00)
  7114 |     |             m1 := mload(0x20)
  7115 |     |             m2 := mload(0x40)
  7116 |     |             m3 := mload(0x60)
  7117 |     |             m4 := mload(0x80)
  7118 |     |             m5 := mload(0xa0)
  7119 |     |             m6 := mload(0xc0)
  7120 |     |             m7 := mload(0xe0)
  7121 |     |             m8 := mload(0x100)
  7122 |     |             // Selector of `log(bool,string,address,string)`.
  7123 |     |             mstore(0x00, 0x12d6c788)
  7124 |     |             mstore(0x20, p0)
  7125 |     |             mstore(0x40, 0x80)
  7126 |     |             mstore(0x60, p2)
  7127 |     |             mstore(0x80, 0xc0)
  7128 |     |             writeString(0xa0, p1)
  7129 |     |             writeString(0xe0, p3)
  7130 |     |         }
  7131 |     |         _sendLogPayload(0x1c, 0x104);
  7132 |     |         assembly {
  7133 |     |             mstore(0x00, m0)
  7134 |     |             mstore(0x20, m1)
  7135 |     |             mstore(0x40, m2)
  7136 |     |             mstore(0x60, m3)
  7137 |     |             mstore(0x80, m4)
  7138 |     |             mstore(0xa0, m5)
  7139 |     |             mstore(0xc0, m6)
  7140 |     |             mstore(0xe0, m7)
  7141 |     |             mstore(0x100, m8)
  7142 |     |         }
  7143 |     |     }
  7144 |     | 
  7145 |     |     function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {
  7146 |     |         bytes32 m0;
  7147 |     |         bytes32 m1;
  7148 |     |         bytes32 m2;
  7149 |     |         bytes32 m3;
  7150 |     |         bytes32 m4;
  7151 |     |         bytes32 m5;
  7152 |     |         bytes32 m6;
  7153 |     |         assembly {
  7154 |     |             function writeString(pos, w) {
  7155 |     |                 let length := 0
  7156 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7157 |     |                 mstore(pos, length)
  7158 |     |                 let shift := sub(256, shl(3, length))
  7159 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7160 |     |             }
  7161 |     |             m0 := mload(0x00)
  7162 |     |             m1 := mload(0x20)
  7163 |     |             m2 := mload(0x40)
  7164 |     |             m3 := mload(0x60)
  7165 |     |             m4 := mload(0x80)
  7166 |     |             m5 := mload(0xa0)
  7167 |     |             m6 := mload(0xc0)
  7168 |     |             // Selector of `log(bool,string,bool,address)`.
  7169 |     |             mstore(0x00, 0x538e06ab)
  7170 |     |             mstore(0x20, p0)
  7171 |     |             mstore(0x40, 0x80)
  7172 |     |             mstore(0x60, p2)
  7173 |     |             mstore(0x80, p3)
  7174 |     |             writeString(0xa0, p1)
  7175 |     |         }
  7176 |     |         _sendLogPayload(0x1c, 0xc4);
  7177 |     |         assembly {
  7178 |     |             mstore(0x00, m0)
  7179 |     |             mstore(0x20, m1)
  7180 |     |             mstore(0x40, m2)
  7181 |     |             mstore(0x60, m3)
  7182 |     |             mstore(0x80, m4)
  7183 |     |             mstore(0xa0, m5)
  7184 |     |             mstore(0xc0, m6)
  7185 |     |         }
  7186 |     |     }
  7187 |     | 
  7188 |     |     function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {
  7189 |     |         bytes32 m0;
  7190 |     |         bytes32 m1;
  7191 |     |         bytes32 m2;
  7192 |     |         bytes32 m3;
  7193 |     |         bytes32 m4;
  7194 |     |         bytes32 m5;
  7195 |     |         bytes32 m6;
  7196 |     |         assembly {
  7197 |     |             function writeString(pos, w) {
  7198 |     |                 let length := 0
  7199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7200 |     |                 mstore(pos, length)
  7201 |     |                 let shift := sub(256, shl(3, length))
  7202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7203 |     |             }
  7204 |     |             m0 := mload(0x00)
  7205 |     |             m1 := mload(0x20)
  7206 |     |             m2 := mload(0x40)
  7207 |     |             m3 := mload(0x60)
  7208 |     |             m4 := mload(0x80)
  7209 |     |             m5 := mload(0xa0)
  7210 |     |             m6 := mload(0xc0)
  7211 |     |             // Selector of `log(bool,string,bool,bool)`.
  7212 |     |             mstore(0x00, 0xdc5e935b)
  7213 |     |             mstore(0x20, p0)
  7214 |     |             mstore(0x40, 0x80)
  7215 |     |             mstore(0x60, p2)
  7216 |     |             mstore(0x80, p3)
  7217 |     |             writeString(0xa0, p1)
  7218 |     |         }
  7219 |     |         _sendLogPayload(0x1c, 0xc4);
  7220 |     |         assembly {
  7221 |     |             mstore(0x00, m0)
  7222 |     |             mstore(0x20, m1)
  7223 |     |             mstore(0x40, m2)
  7224 |     |             mstore(0x60, m3)
  7225 |     |             mstore(0x80, m4)
  7226 |     |             mstore(0xa0, m5)
  7227 |     |             mstore(0xc0, m6)
  7228 |     |         }
  7229 |     |     }
  7230 |     | 
  7231 |     |     function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  7232 |     |         bytes32 m0;
  7233 |     |         bytes32 m1;
  7234 |     |         bytes32 m2;
  7235 |     |         bytes32 m3;
  7236 |     |         bytes32 m4;
  7237 |     |         bytes32 m5;
  7238 |     |         bytes32 m6;
  7239 |     |         assembly {
  7240 |     |             function writeString(pos, w) {
  7241 |     |                 let length := 0
  7242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7243 |     |                 mstore(pos, length)
  7244 |     |                 let shift := sub(256, shl(3, length))
  7245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7246 |     |             }
  7247 |     |             m0 := mload(0x00)
  7248 |     |             m1 := mload(0x20)
  7249 |     |             m2 := mload(0x40)
  7250 |     |             m3 := mload(0x60)
  7251 |     |             m4 := mload(0x80)
  7252 |     |             m5 := mload(0xa0)
  7253 |     |             m6 := mload(0xc0)
  7254 |     |             // Selector of `log(bool,string,bool,uint256)`.
  7255 |     |             mstore(0x00, 0x1606a393)
  7256 |     |             mstore(0x20, p0)
  7257 |     |             mstore(0x40, 0x80)
  7258 |     |             mstore(0x60, p2)
  7259 |     |             mstore(0x80, p3)
  7260 |     |             writeString(0xa0, p1)
  7261 |     |         }
  7262 |     |         _sendLogPayload(0x1c, 0xc4);
  7263 |     |         assembly {
  7264 |     |             mstore(0x00, m0)
  7265 |     |             mstore(0x20, m1)
  7266 |     |             mstore(0x40, m2)
  7267 |     |             mstore(0x60, m3)
  7268 |     |             mstore(0x80, m4)
  7269 |     |             mstore(0xa0, m5)
  7270 |     |             mstore(0xc0, m6)
  7271 |     |         }
  7272 |     |     }
  7273 |     | 
  7274 |     |     function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  7275 |     |         bytes32 m0;
  7276 |     |         bytes32 m1;
  7277 |     |         bytes32 m2;
  7278 |     |         bytes32 m3;
  7279 |     |         bytes32 m4;
  7280 |     |         bytes32 m5;
  7281 |     |         bytes32 m6;
  7282 |     |         bytes32 m7;
  7283 |     |         bytes32 m8;
  7284 |     |         assembly {
  7285 |     |             function writeString(pos, w) {
  7286 |     |                 let length := 0
  7287 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7288 |     |                 mstore(pos, length)
  7289 |     |                 let shift := sub(256, shl(3, length))
  7290 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7291 |     |             }
  7292 |     |             m0 := mload(0x00)
  7293 |     |             m1 := mload(0x20)
  7294 |     |             m2 := mload(0x40)
  7295 |     |             m3 := mload(0x60)
  7296 |     |             m4 := mload(0x80)
  7297 |     |             m5 := mload(0xa0)
  7298 |     |             m6 := mload(0xc0)
  7299 |     |             m7 := mload(0xe0)
  7300 |     |             m8 := mload(0x100)
  7301 |     |             // Selector of `log(bool,string,bool,string)`.
  7302 |     |             mstore(0x00, 0x483d0416)
  7303 |     |             mstore(0x20, p0)
  7304 |     |             mstore(0x40, 0x80)
  7305 |     |             mstore(0x60, p2)
  7306 |     |             mstore(0x80, 0xc0)
  7307 |     |             writeString(0xa0, p1)
  7308 |     |             writeString(0xe0, p3)
  7309 |     |         }
  7310 |     |         _sendLogPayload(0x1c, 0x104);
  7311 |     |         assembly {
  7312 |     |             mstore(0x00, m0)
  7313 |     |             mstore(0x20, m1)
  7314 |     |             mstore(0x40, m2)
  7315 |     |             mstore(0x60, m3)
  7316 |     |             mstore(0x80, m4)
  7317 |     |             mstore(0xa0, m5)
  7318 |     |             mstore(0xc0, m6)
  7319 |     |             mstore(0xe0, m7)
  7320 |     |             mstore(0x100, m8)
  7321 |     |         }
  7322 |     |     }
  7323 |     | 
  7324 |     |     function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {
  7325 |     |         bytes32 m0;
  7326 |     |         bytes32 m1;
  7327 |     |         bytes32 m2;
  7328 |     |         bytes32 m3;
  7329 |     |         bytes32 m4;
  7330 |     |         bytes32 m5;
  7331 |     |         bytes32 m6;
  7332 |     |         assembly {
  7333 |     |             function writeString(pos, w) {
  7334 |     |                 let length := 0
  7335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7336 |     |                 mstore(pos, length)
  7337 |     |                 let shift := sub(256, shl(3, length))
  7338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7339 |     |             }
  7340 |     |             m0 := mload(0x00)
  7341 |     |             m1 := mload(0x20)
  7342 |     |             m2 := mload(0x40)
  7343 |     |             m3 := mload(0x60)
  7344 |     |             m4 := mload(0x80)
  7345 |     |             m5 := mload(0xa0)
  7346 |     |             m6 := mload(0xc0)
  7347 |     |             // Selector of `log(bool,string,uint256,address)`.
  7348 |     |             mstore(0x00, 0x1596a1ce)
  7349 |     |             mstore(0x20, p0)
  7350 |     |             mstore(0x40, 0x80)
  7351 |     |             mstore(0x60, p2)
  7352 |     |             mstore(0x80, p3)
  7353 |     |             writeString(0xa0, p1)
  7354 |     |         }
  7355 |     |         _sendLogPayload(0x1c, 0xc4);
  7356 |     |         assembly {
  7357 |     |             mstore(0x00, m0)
  7358 |     |             mstore(0x20, m1)
  7359 |     |             mstore(0x40, m2)
  7360 |     |             mstore(0x60, m3)
  7361 |     |             mstore(0x80, m4)
  7362 |     |             mstore(0xa0, m5)
  7363 |     |             mstore(0xc0, m6)
  7364 |     |         }
  7365 |     |     }
  7366 |     | 
  7367 |     |     function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  7368 |     |         bytes32 m0;
  7369 |     |         bytes32 m1;
  7370 |     |         bytes32 m2;
  7371 |     |         bytes32 m3;
  7372 |     |         bytes32 m4;
  7373 |     |         bytes32 m5;
  7374 |     |         bytes32 m6;
  7375 |     |         assembly {
  7376 |     |             function writeString(pos, w) {
  7377 |     |                 let length := 0
  7378 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7379 |     |                 mstore(pos, length)
  7380 |     |                 let shift := sub(256, shl(3, length))
  7381 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7382 |     |             }
  7383 |     |             m0 := mload(0x00)
  7384 |     |             m1 := mload(0x20)
  7385 |     |             m2 := mload(0x40)
  7386 |     |             m3 := mload(0x60)
  7387 |     |             m4 := mload(0x80)
  7388 |     |             m5 := mload(0xa0)
  7389 |     |             m6 := mload(0xc0)
  7390 |     |             // Selector of `log(bool,string,uint256,bool)`.
  7391 |     |             mstore(0x00, 0x6b0e5d53)
  7392 |     |             mstore(0x20, p0)
  7393 |     |             mstore(0x40, 0x80)
  7394 |     |             mstore(0x60, p2)
  7395 |     |             mstore(0x80, p3)
  7396 |     |             writeString(0xa0, p1)
  7397 |     |         }
  7398 |     |         _sendLogPayload(0x1c, 0xc4);
  7399 |     |         assembly {
  7400 |     |             mstore(0x00, m0)
  7401 |     |             mstore(0x20, m1)
  7402 |     |             mstore(0x40, m2)
  7403 |     |             mstore(0x60, m3)
  7404 |     |             mstore(0x80, m4)
  7405 |     |             mstore(0xa0, m5)
  7406 |     |             mstore(0xc0, m6)
  7407 |     |         }
  7408 |     |     }
  7409 |     | 
  7410 |     |     function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  7411 |     |         bytes32 m0;
  7412 |     |         bytes32 m1;
  7413 |     |         bytes32 m2;
  7414 |     |         bytes32 m3;
  7415 |     |         bytes32 m4;
  7416 |     |         bytes32 m5;
  7417 |     |         bytes32 m6;
  7418 |     |         assembly {
  7419 |     |             function writeString(pos, w) {
  7420 |     |                 let length := 0
  7421 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7422 |     |                 mstore(pos, length)
  7423 |     |                 let shift := sub(256, shl(3, length))
  7424 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7425 |     |             }
  7426 |     |             m0 := mload(0x00)
  7427 |     |             m1 := mload(0x20)
  7428 |     |             m2 := mload(0x40)
  7429 |     |             m3 := mload(0x60)
  7430 |     |             m4 := mload(0x80)
  7431 |     |             m5 := mload(0xa0)
  7432 |     |             m6 := mload(0xc0)
  7433 |     |             // Selector of `log(bool,string,uint256,uint256)`.
  7434 |     |             mstore(0x00, 0x28863fcb)
  7435 |     |             mstore(0x20, p0)
  7436 |     |             mstore(0x40, 0x80)
  7437 |     |             mstore(0x60, p2)
  7438 |     |             mstore(0x80, p3)
  7439 |     |             writeString(0xa0, p1)
  7440 |     |         }
  7441 |     |         _sendLogPayload(0x1c, 0xc4);
  7442 |     |         assembly {
  7443 |     |             mstore(0x00, m0)
  7444 |     |             mstore(0x20, m1)
  7445 |     |             mstore(0x40, m2)
  7446 |     |             mstore(0x60, m3)
  7447 |     |             mstore(0x80, m4)
  7448 |     |             mstore(0xa0, m5)
  7449 |     |             mstore(0xc0, m6)
  7450 |     |         }
  7451 |     |     }
  7452 |     | 
  7453 |     |     function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  7454 |     |         bytes32 m0;
  7455 |     |         bytes32 m1;
  7456 |     |         bytes32 m2;
  7457 |     |         bytes32 m3;
  7458 |     |         bytes32 m4;
  7459 |     |         bytes32 m5;
  7460 |     |         bytes32 m6;
  7461 |     |         bytes32 m7;
  7462 |     |         bytes32 m8;
  7463 |     |         assembly {
  7464 |     |             function writeString(pos, w) {
  7465 |     |                 let length := 0
  7466 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7467 |     |                 mstore(pos, length)
  7468 |     |                 let shift := sub(256, shl(3, length))
  7469 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7470 |     |             }
  7471 |     |             m0 := mload(0x00)
  7472 |     |             m1 := mload(0x20)
  7473 |     |             m2 := mload(0x40)
  7474 |     |             m3 := mload(0x60)
  7475 |     |             m4 := mload(0x80)
  7476 |     |             m5 := mload(0xa0)
  7477 |     |             m6 := mload(0xc0)
  7478 |     |             m7 := mload(0xe0)
  7479 |     |             m8 := mload(0x100)
  7480 |     |             // Selector of `log(bool,string,uint256,string)`.
  7481 |     |             mstore(0x00, 0x1ad96de6)
  7482 |     |             mstore(0x20, p0)
  7483 |     |             mstore(0x40, 0x80)
  7484 |     |             mstore(0x60, p2)
  7485 |     |             mstore(0x80, 0xc0)
  7486 |     |             writeString(0xa0, p1)
  7487 |     |             writeString(0xe0, p3)
  7488 |     |         }
  7489 |     |         _sendLogPayload(0x1c, 0x104);
  7490 |     |         assembly {
  7491 |     |             mstore(0x00, m0)
  7492 |     |             mstore(0x20, m1)
  7493 |     |             mstore(0x40, m2)
  7494 |     |             mstore(0x60, m3)
  7495 |     |             mstore(0x80, m4)
  7496 |     |             mstore(0xa0, m5)
  7497 |     |             mstore(0xc0, m6)
  7498 |     |             mstore(0xe0, m7)
  7499 |     |             mstore(0x100, m8)
  7500 |     |         }
  7501 |     |     }
  7502 |     | 
  7503 |     |     function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  7504 |     |         bytes32 m0;
  7505 |     |         bytes32 m1;
  7506 |     |         bytes32 m2;
  7507 |     |         bytes32 m3;
  7508 |     |         bytes32 m4;
  7509 |     |         bytes32 m5;
  7510 |     |         bytes32 m6;
  7511 |     |         bytes32 m7;
  7512 |     |         bytes32 m8;
  7513 |     |         assembly {
  7514 |     |             function writeString(pos, w) {
  7515 |     |                 let length := 0
  7516 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7517 |     |                 mstore(pos, length)
  7518 |     |                 let shift := sub(256, shl(3, length))
  7519 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7520 |     |             }
  7521 |     |             m0 := mload(0x00)
  7522 |     |             m1 := mload(0x20)
  7523 |     |             m2 := mload(0x40)
  7524 |     |             m3 := mload(0x60)
  7525 |     |             m4 := mload(0x80)
  7526 |     |             m5 := mload(0xa0)
  7527 |     |             m6 := mload(0xc0)
  7528 |     |             m7 := mload(0xe0)
  7529 |     |             m8 := mload(0x100)
  7530 |     |             // Selector of `log(bool,string,string,address)`.
  7531 |     |             mstore(0x00, 0x97d394d8)
  7532 |     |             mstore(0x20, p0)
  7533 |     |             mstore(0x40, 0x80)
  7534 |     |             mstore(0x60, 0xc0)
  7535 |     |             mstore(0x80, p3)
  7536 |     |             writeString(0xa0, p1)
  7537 |     |             writeString(0xe0, p2)
  7538 |     |         }
  7539 |     |         _sendLogPayload(0x1c, 0x104);
  7540 |     |         assembly {
  7541 |     |             mstore(0x00, m0)
  7542 |     |             mstore(0x20, m1)
  7543 |     |             mstore(0x40, m2)
  7544 |     |             mstore(0x60, m3)
  7545 |     |             mstore(0x80, m4)
  7546 |     |             mstore(0xa0, m5)
  7547 |     |             mstore(0xc0, m6)
  7548 |     |             mstore(0xe0, m7)
  7549 |     |             mstore(0x100, m8)
  7550 |     |         }
  7551 |     |     }
  7552 |     | 
  7553 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
  7554 |     |         bytes32 m0;
  7555 |     |         bytes32 m1;
  7556 |     |         bytes32 m2;
  7557 |     |         bytes32 m3;
  7558 |     |         bytes32 m4;
  7559 |     |         bytes32 m5;
  7560 |     |         bytes32 m6;
  7561 |     |         bytes32 m7;
  7562 |     |         bytes32 m8;
  7563 |     |         assembly {
  7564 |     |             function writeString(pos, w) {
  7565 |     |                 let length := 0
  7566 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7567 |     |                 mstore(pos, length)
  7568 |     |                 let shift := sub(256, shl(3, length))
  7569 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7570 |     |             }
  7571 |     |             m0 := mload(0x00)
  7572 |     |             m1 := mload(0x20)
  7573 |     |             m2 := mload(0x40)
  7574 |     |             m3 := mload(0x60)
  7575 |     |             m4 := mload(0x80)
  7576 |     |             m5 := mload(0xa0)
  7577 |     |             m6 := mload(0xc0)
  7578 |     |             m7 := mload(0xe0)
  7579 |     |             m8 := mload(0x100)
  7580 |     |             // Selector of `log(bool,string,string,bool)`.
  7581 |     |             mstore(0x00, 0x1e4b87e5)
  7582 |     |             mstore(0x20, p0)
  7583 |     |             mstore(0x40, 0x80)
  7584 |     |             mstore(0x60, 0xc0)
  7585 |     |             mstore(0x80, p3)
  7586 |     |             writeString(0xa0, p1)
  7587 |     |             writeString(0xe0, p2)
  7588 |     |         }
  7589 |     |         _sendLogPayload(0x1c, 0x104);
  7590 |     |         assembly {
  7591 |     |             mstore(0x00, m0)
  7592 |     |             mstore(0x20, m1)
  7593 |     |             mstore(0x40, m2)
  7594 |     |             mstore(0x60, m3)
  7595 |     |             mstore(0x80, m4)
  7596 |     |             mstore(0xa0, m5)
  7597 |     |             mstore(0xc0, m6)
  7598 |     |             mstore(0xe0, m7)
  7599 |     |             mstore(0x100, m8)
  7600 |     |         }
  7601 |     |     }
  7602 |     | 
  7603 |     |     function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
  7604 |     |         bytes32 m0;
  7605 |     |         bytes32 m1;
  7606 |     |         bytes32 m2;
  7607 |     |         bytes32 m3;
  7608 |     |         bytes32 m4;
  7609 |     |         bytes32 m5;
  7610 |     |         bytes32 m6;
  7611 |     |         bytes32 m7;
  7612 |     |         bytes32 m8;
  7613 |     |         assembly {
  7614 |     |             function writeString(pos, w) {
  7615 |     |                 let length := 0
  7616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7617 |     |                 mstore(pos, length)
  7618 |     |                 let shift := sub(256, shl(3, length))
  7619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7620 |     |             }
  7621 |     |             m0 := mload(0x00)
  7622 |     |             m1 := mload(0x20)
  7623 |     |             m2 := mload(0x40)
  7624 |     |             m3 := mload(0x60)
  7625 |     |             m4 := mload(0x80)
  7626 |     |             m5 := mload(0xa0)
  7627 |     |             m6 := mload(0xc0)
  7628 |     |             m7 := mload(0xe0)
  7629 |     |             m8 := mload(0x100)
  7630 |     |             // Selector of `log(bool,string,string,uint256)`.
  7631 |     |             mstore(0x00, 0x7be0c3eb)
  7632 |     |             mstore(0x20, p0)
  7633 |     |             mstore(0x40, 0x80)
  7634 |     |             mstore(0x60, 0xc0)
  7635 |     |             mstore(0x80, p3)
  7636 |     |             writeString(0xa0, p1)
  7637 |     |             writeString(0xe0, p2)
  7638 |     |         }
  7639 |     |         _sendLogPayload(0x1c, 0x104);
  7640 |     |         assembly {
  7641 |     |             mstore(0x00, m0)
  7642 |     |             mstore(0x20, m1)
  7643 |     |             mstore(0x40, m2)
  7644 |     |             mstore(0x60, m3)
  7645 |     |             mstore(0x80, m4)
  7646 |     |             mstore(0xa0, m5)
  7647 |     |             mstore(0xc0, m6)
  7648 |     |             mstore(0xe0, m7)
  7649 |     |             mstore(0x100, m8)
  7650 |     |         }
  7651 |     |     }
  7652 |     | 
  7653 |     |     function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
  7654 |     |         bytes32 m0;
  7655 |     |         bytes32 m1;
  7656 |     |         bytes32 m2;
  7657 |     |         bytes32 m3;
  7658 |     |         bytes32 m4;
  7659 |     |         bytes32 m5;
  7660 |     |         bytes32 m6;
  7661 |     |         bytes32 m7;
  7662 |     |         bytes32 m8;
  7663 |     |         bytes32 m9;
  7664 |     |         bytes32 m10;
  7665 |     |         assembly {
  7666 |     |             function writeString(pos, w) {
  7667 |     |                 let length := 0
  7668 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7669 |     |                 mstore(pos, length)
  7670 |     |                 let shift := sub(256, shl(3, length))
  7671 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7672 |     |             }
  7673 |     |             m0 := mload(0x00)
  7674 |     |             m1 := mload(0x20)
  7675 |     |             m2 := mload(0x40)
  7676 |     |             m3 := mload(0x60)
  7677 |     |             m4 := mload(0x80)
  7678 |     |             m5 := mload(0xa0)
  7679 |     |             m6 := mload(0xc0)
  7680 |     |             m7 := mload(0xe0)
  7681 |     |             m8 := mload(0x100)
  7682 |     |             m9 := mload(0x120)
  7683 |     |             m10 := mload(0x140)
  7684 |     |             // Selector of `log(bool,string,string,string)`.
  7685 |     |             mstore(0x00, 0x1762e32a)
  7686 |     |             mstore(0x20, p0)
  7687 |     |             mstore(0x40, 0x80)
  7688 |     |             mstore(0x60, 0xc0)
  7689 |     |             mstore(0x80, 0x100)
  7690 |     |             writeString(0xa0, p1)
  7691 |     |             writeString(0xe0, p2)
  7692 |     |             writeString(0x120, p3)
  7693 |     |         }
  7694 |     |         _sendLogPayload(0x1c, 0x144);
  7695 |     |         assembly {
  7696 |     |             mstore(0x00, m0)
  7697 |     |             mstore(0x20, m1)
  7698 |     |             mstore(0x40, m2)
  7699 |     |             mstore(0x60, m3)
  7700 |     |             mstore(0x80, m4)
  7701 |     |             mstore(0xa0, m5)
  7702 |     |             mstore(0xc0, m6)
  7703 |     |             mstore(0xe0, m7)
  7704 |     |             mstore(0x100, m8)
  7705 |     |             mstore(0x120, m9)
  7706 |     |             mstore(0x140, m10)
  7707 |     |         }
  7708 |     |     }
  7709 |     | 
  7710 |     |     function log(uint256 p0, address p1, address p2, address p3) internal pure {
  7711 |     |         bytes32 m0;
  7712 |     |         bytes32 m1;
  7713 |     |         bytes32 m2;
  7714 |     |         bytes32 m3;
  7715 |     |         bytes32 m4;
  7716 |     |         assembly {
  7717 |     |             m0 := mload(0x00)
  7718 |     |             m1 := mload(0x20)
  7719 |     |             m2 := mload(0x40)
  7720 |     |             m3 := mload(0x60)
  7721 |     |             m4 := mload(0x80)
  7722 |     |             // Selector of `log(uint256,address,address,address)`.
  7723 |     |             mstore(0x00, 0x2488b414)
  7724 |     |             mstore(0x20, p0)
  7725 |     |             mstore(0x40, p1)
  7726 |     |             mstore(0x60, p2)
  7727 |     |             mstore(0x80, p3)
  7728 |     |         }
  7729 |     |         _sendLogPayload(0x1c, 0x84);
  7730 |     |         assembly {
  7731 |     |             mstore(0x00, m0)
  7732 |     |             mstore(0x20, m1)
  7733 |     |             mstore(0x40, m2)
  7734 |     |             mstore(0x60, m3)
  7735 |     |             mstore(0x80, m4)
  7736 |     |         }
  7737 |     |     }
  7738 |     | 
  7739 |     |     function log(uint256 p0, address p1, address p2, bool p3) internal pure {
  7740 |     |         bytes32 m0;
  7741 |     |         bytes32 m1;
  7742 |     |         bytes32 m2;
  7743 |     |         bytes32 m3;
  7744 |     |         bytes32 m4;
  7745 |     |         assembly {
  7746 |     |             m0 := mload(0x00)
  7747 |     |             m1 := mload(0x20)
  7748 |     |             m2 := mload(0x40)
  7749 |     |             m3 := mload(0x60)
  7750 |     |             m4 := mload(0x80)
  7751 |     |             // Selector of `log(uint256,address,address,bool)`.
  7752 |     |             mstore(0x00, 0x091ffaf5)
  7753 |     |             mstore(0x20, p0)
  7754 |     |             mstore(0x40, p1)
  7755 |     |             mstore(0x60, p2)
  7756 |     |             mstore(0x80, p3)
  7757 |     |         }
  7758 |     |         _sendLogPayload(0x1c, 0x84);
  7759 |     |         assembly {
  7760 |     |             mstore(0x00, m0)
  7761 |     |             mstore(0x20, m1)
  7762 |     |             mstore(0x40, m2)
  7763 |     |             mstore(0x60, m3)
  7764 |     |             mstore(0x80, m4)
  7765 |     |         }
  7766 |     |     }
  7767 |     | 
  7768 |     |     function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {
  7769 |     |         bytes32 m0;
  7770 |     |         bytes32 m1;
  7771 |     |         bytes32 m2;
  7772 |     |         bytes32 m3;
  7773 |     |         bytes32 m4;
  7774 |     |         assembly {
  7775 |     |             m0 := mload(0x00)
  7776 |     |             m1 := mload(0x20)
  7777 |     |             m2 := mload(0x40)
  7778 |     |             m3 := mload(0x60)
  7779 |     |             m4 := mload(0x80)
  7780 |     |             // Selector of `log(uint256,address,address,uint256)`.
  7781 |     |             mstore(0x00, 0x736efbb6)
  7782 |     |             mstore(0x20, p0)
  7783 |     |             mstore(0x40, p1)
  7784 |     |             mstore(0x60, p2)
  7785 |     |             mstore(0x80, p3)
  7786 |     |         }
  7787 |     |         _sendLogPayload(0x1c, 0x84);
  7788 |     |         assembly {
  7789 |     |             mstore(0x00, m0)
  7790 |     |             mstore(0x20, m1)
  7791 |     |             mstore(0x40, m2)
  7792 |     |             mstore(0x60, m3)
  7793 |     |             mstore(0x80, m4)
  7794 |     |         }
  7795 |     |     }
  7796 |     | 
  7797 |     |     function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {
  7798 |     |         bytes32 m0;
  7799 |     |         bytes32 m1;
  7800 |     |         bytes32 m2;
  7801 |     |         bytes32 m3;
  7802 |     |         bytes32 m4;
  7803 |     |         bytes32 m5;
  7804 |     |         bytes32 m6;
  7805 |     |         assembly {
  7806 |     |             function writeString(pos, w) {
  7807 |     |                 let length := 0
  7808 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7809 |     |                 mstore(pos, length)
  7810 |     |                 let shift := sub(256, shl(3, length))
  7811 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7812 |     |             }
  7813 |     |             m0 := mload(0x00)
  7814 |     |             m1 := mload(0x20)
  7815 |     |             m2 := mload(0x40)
  7816 |     |             m3 := mload(0x60)
  7817 |     |             m4 := mload(0x80)
  7818 |     |             m5 := mload(0xa0)
  7819 |     |             m6 := mload(0xc0)
  7820 |     |             // Selector of `log(uint256,address,address,string)`.
  7821 |     |             mstore(0x00, 0x031c6f73)
  7822 |     |             mstore(0x20, p0)
  7823 |     |             mstore(0x40, p1)
  7824 |     |             mstore(0x60, p2)
  7825 |     |             mstore(0x80, 0x80)
  7826 |     |             writeString(0xa0, p3)
  7827 |     |         }
  7828 |     |         _sendLogPayload(0x1c, 0xc4);
  7829 |     |         assembly {
  7830 |     |             mstore(0x00, m0)
  7831 |     |             mstore(0x20, m1)
  7832 |     |             mstore(0x40, m2)
  7833 |     |             mstore(0x60, m3)
  7834 |     |             mstore(0x80, m4)
  7835 |     |             mstore(0xa0, m5)
  7836 |     |             mstore(0xc0, m6)
  7837 |     |         }
  7838 |     |     }
  7839 |     | 
  7840 |     |     function log(uint256 p0, address p1, bool p2, address p3) internal pure {
  7841 |     |         bytes32 m0;
  7842 |     |         bytes32 m1;
  7843 |     |         bytes32 m2;
  7844 |     |         bytes32 m3;
  7845 |     |         bytes32 m4;
  7846 |     |         assembly {
  7847 |     |             m0 := mload(0x00)
  7848 |     |             m1 := mload(0x20)
  7849 |     |             m2 := mload(0x40)
  7850 |     |             m3 := mload(0x60)
  7851 |     |             m4 := mload(0x80)
  7852 |     |             // Selector of `log(uint256,address,bool,address)`.
  7853 |     |             mstore(0x00, 0xef72c513)
  7854 |     |             mstore(0x20, p0)
  7855 |     |             mstore(0x40, p1)
  7856 |     |             mstore(0x60, p2)
  7857 |     |             mstore(0x80, p3)
  7858 |     |         }
  7859 |     |         _sendLogPayload(0x1c, 0x84);
  7860 |     |         assembly {
  7861 |     |             mstore(0x00, m0)
  7862 |     |             mstore(0x20, m1)
  7863 |     |             mstore(0x40, m2)
  7864 |     |             mstore(0x60, m3)
  7865 |     |             mstore(0x80, m4)
  7866 |     |         }
  7867 |     |     }
  7868 |     | 
  7869 |     |     function log(uint256 p0, address p1, bool p2, bool p3) internal pure {
  7870 |     |         bytes32 m0;
  7871 |     |         bytes32 m1;
  7872 |     |         bytes32 m2;
  7873 |     |         bytes32 m3;
  7874 |     |         bytes32 m4;
  7875 |     |         assembly {
  7876 |     |             m0 := mload(0x00)
  7877 |     |             m1 := mload(0x20)
  7878 |     |             m2 := mload(0x40)
  7879 |     |             m3 := mload(0x60)
  7880 |     |             m4 := mload(0x80)
  7881 |     |             // Selector of `log(uint256,address,bool,bool)`.
  7882 |     |             mstore(0x00, 0xe351140f)
  7883 |     |             mstore(0x20, p0)
  7884 |     |             mstore(0x40, p1)
  7885 |     |             mstore(0x60, p2)
  7886 |     |             mstore(0x80, p3)
  7887 |     |         }
  7888 |     |         _sendLogPayload(0x1c, 0x84);
  7889 |     |         assembly {
  7890 |     |             mstore(0x00, m0)
  7891 |     |             mstore(0x20, m1)
  7892 |     |             mstore(0x40, m2)
  7893 |     |             mstore(0x60, m3)
  7894 |     |             mstore(0x80, m4)
  7895 |     |         }
  7896 |     |     }
  7897 |     | 
  7898 |     |     function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {
  7899 |     |         bytes32 m0;
  7900 |     |         bytes32 m1;
  7901 |     |         bytes32 m2;
  7902 |     |         bytes32 m3;
  7903 |     |         bytes32 m4;
  7904 |     |         assembly {
  7905 |     |             m0 := mload(0x00)
  7906 |     |             m1 := mload(0x20)
  7907 |     |             m2 := mload(0x40)
  7908 |     |             m3 := mload(0x60)
  7909 |     |             m4 := mload(0x80)
  7910 |     |             // Selector of `log(uint256,address,bool,uint256)`.
  7911 |     |             mstore(0x00, 0x5abd992a)
  7912 |     |             mstore(0x20, p0)
  7913 |     |             mstore(0x40, p1)
  7914 |     |             mstore(0x60, p2)
  7915 |     |             mstore(0x80, p3)
  7916 |     |         }
  7917 |     |         _sendLogPayload(0x1c, 0x84);
  7918 |     |         assembly {
  7919 |     |             mstore(0x00, m0)
  7920 |     |             mstore(0x20, m1)
  7921 |     |             mstore(0x40, m2)
  7922 |     |             mstore(0x60, m3)
  7923 |     |             mstore(0x80, m4)
  7924 |     |         }
  7925 |     |     }
  7926 |     | 
  7927 |     |     function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {
  7928 |     |         bytes32 m0;
  7929 |     |         bytes32 m1;
  7930 |     |         bytes32 m2;
  7931 |     |         bytes32 m3;
  7932 |     |         bytes32 m4;
  7933 |     |         bytes32 m5;
  7934 |     |         bytes32 m6;
  7935 |     |         assembly {
  7936 |     |             function writeString(pos, w) {
  7937 |     |                 let length := 0
  7938 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  7939 |     |                 mstore(pos, length)
  7940 |     |                 let shift := sub(256, shl(3, length))
  7941 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  7942 |     |             }
  7943 |     |             m0 := mload(0x00)
  7944 |     |             m1 := mload(0x20)
  7945 |     |             m2 := mload(0x40)
  7946 |     |             m3 := mload(0x60)
  7947 |     |             m4 := mload(0x80)
  7948 |     |             m5 := mload(0xa0)
  7949 |     |             m6 := mload(0xc0)
  7950 |     |             // Selector of `log(uint256,address,bool,string)`.
  7951 |     |             mstore(0x00, 0x90fb06aa)
  7952 |     |             mstore(0x20, p0)
  7953 |     |             mstore(0x40, p1)
  7954 |     |             mstore(0x60, p2)
  7955 |     |             mstore(0x80, 0x80)
  7956 |     |             writeString(0xa0, p3)
  7957 |     |         }
  7958 |     |         _sendLogPayload(0x1c, 0xc4);
  7959 |     |         assembly {
  7960 |     |             mstore(0x00, m0)
  7961 |     |             mstore(0x20, m1)
  7962 |     |             mstore(0x40, m2)
  7963 |     |             mstore(0x60, m3)
  7964 |     |             mstore(0x80, m4)
  7965 |     |             mstore(0xa0, m5)
  7966 |     |             mstore(0xc0, m6)
  7967 |     |         }
  7968 |     |     }
  7969 |     | 
  7970 |     |     function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {
  7971 |     |         bytes32 m0;
  7972 |     |         bytes32 m1;
  7973 |     |         bytes32 m2;
  7974 |     |         bytes32 m3;
  7975 |     |         bytes32 m4;
  7976 |     |         assembly {
  7977 |     |             m0 := mload(0x00)
  7978 |     |             m1 := mload(0x20)
  7979 |     |             m2 := mload(0x40)
  7980 |     |             m3 := mload(0x60)
  7981 |     |             m4 := mload(0x80)
  7982 |     |             // Selector of `log(uint256,address,uint256,address)`.
  7983 |     |             mstore(0x00, 0x15c127b5)
  7984 |     |             mstore(0x20, p0)
  7985 |     |             mstore(0x40, p1)
  7986 |     |             mstore(0x60, p2)
  7987 |     |             mstore(0x80, p3)
  7988 |     |         }
  7989 |     |         _sendLogPayload(0x1c, 0x84);
  7990 |     |         assembly {
  7991 |     |             mstore(0x00, m0)
  7992 |     |             mstore(0x20, m1)
  7993 |     |             mstore(0x40, m2)
  7994 |     |             mstore(0x60, m3)
  7995 |     |             mstore(0x80, m4)
  7996 |     |         }
  7997 |     |     }
  7998 |     | 
  7999 |     |     function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {
  8000 |     |         bytes32 m0;
  8001 |     |         bytes32 m1;
  8002 |     |         bytes32 m2;
  8003 |     |         bytes32 m3;
  8004 |     |         bytes32 m4;
  8005 |     |         assembly {
  8006 |     |             m0 := mload(0x00)
  8007 |     |             m1 := mload(0x20)
  8008 |     |             m2 := mload(0x40)
  8009 |     |             m3 := mload(0x60)
  8010 |     |             m4 := mload(0x80)
  8011 |     |             // Selector of `log(uint256,address,uint256,bool)`.
  8012 |     |             mstore(0x00, 0x5f743a7c)
  8013 |     |             mstore(0x20, p0)
  8014 |     |             mstore(0x40, p1)
  8015 |     |             mstore(0x60, p2)
  8016 |     |             mstore(0x80, p3)
  8017 |     |         }
  8018 |     |         _sendLogPayload(0x1c, 0x84);
  8019 |     |         assembly {
  8020 |     |             mstore(0x00, m0)
  8021 |     |             mstore(0x20, m1)
  8022 |     |             mstore(0x40, m2)
  8023 |     |             mstore(0x60, m3)
  8024 |     |             mstore(0x80, m4)
  8025 |     |         }
  8026 |     |     }
  8027 |     | 
  8028 |     |     function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {
  8029 |     |         bytes32 m0;
  8030 |     |         bytes32 m1;
  8031 |     |         bytes32 m2;
  8032 |     |         bytes32 m3;
  8033 |     |         bytes32 m4;
  8034 |     |         assembly {
  8035 |     |             m0 := mload(0x00)
  8036 |     |             m1 := mload(0x20)
  8037 |     |             m2 := mload(0x40)
  8038 |     |             m3 := mload(0x60)
  8039 |     |             m4 := mload(0x80)
  8040 |     |             // Selector of `log(uint256,address,uint256,uint256)`.
  8041 |     |             mstore(0x00, 0x0c9cd9c1)
  8042 |     |             mstore(0x20, p0)
  8043 |     |             mstore(0x40, p1)
  8044 |     |             mstore(0x60, p2)
  8045 |     |             mstore(0x80, p3)
  8046 |     |         }
  8047 |     |         _sendLogPayload(0x1c, 0x84);
  8048 |     |         assembly {
  8049 |     |             mstore(0x00, m0)
  8050 |     |             mstore(0x20, m1)
  8051 |     |             mstore(0x40, m2)
  8052 |     |             mstore(0x60, m3)
  8053 |     |             mstore(0x80, m4)
  8054 |     |         }
  8055 |     |     }
  8056 |     | 
  8057 |     |     function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {
  8058 |     |         bytes32 m0;
  8059 |     |         bytes32 m1;
  8060 |     |         bytes32 m2;
  8061 |     |         bytes32 m3;
  8062 |     |         bytes32 m4;
  8063 |     |         bytes32 m5;
  8064 |     |         bytes32 m6;
  8065 |     |         assembly {
  8066 |     |             function writeString(pos, w) {
  8067 |     |                 let length := 0
  8068 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8069 |     |                 mstore(pos, length)
  8070 |     |                 let shift := sub(256, shl(3, length))
  8071 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8072 |     |             }
  8073 |     |             m0 := mload(0x00)
  8074 |     |             m1 := mload(0x20)
  8075 |     |             m2 := mload(0x40)
  8076 |     |             m3 := mload(0x60)
  8077 |     |             m4 := mload(0x80)
  8078 |     |             m5 := mload(0xa0)
  8079 |     |             m6 := mload(0xc0)
  8080 |     |             // Selector of `log(uint256,address,uint256,string)`.
  8081 |     |             mstore(0x00, 0xddb06521)
  8082 |     |             mstore(0x20, p0)
  8083 |     |             mstore(0x40, p1)
  8084 |     |             mstore(0x60, p2)
  8085 |     |             mstore(0x80, 0x80)
  8086 |     |             writeString(0xa0, p3)
  8087 |     |         }
  8088 |     |         _sendLogPayload(0x1c, 0xc4);
  8089 |     |         assembly {
  8090 |     |             mstore(0x00, m0)
  8091 |     |             mstore(0x20, m1)
  8092 |     |             mstore(0x40, m2)
  8093 |     |             mstore(0x60, m3)
  8094 |     |             mstore(0x80, m4)
  8095 |     |             mstore(0xa0, m5)
  8096 |     |             mstore(0xc0, m6)
  8097 |     |         }
  8098 |     |     }
  8099 |     | 
  8100 |     |     function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {
  8101 |     |         bytes32 m0;
  8102 |     |         bytes32 m1;
  8103 |     |         bytes32 m2;
  8104 |     |         bytes32 m3;
  8105 |     |         bytes32 m4;
  8106 |     |         bytes32 m5;
  8107 |     |         bytes32 m6;
  8108 |     |         assembly {
  8109 |     |             function writeString(pos, w) {
  8110 |     |                 let length := 0
  8111 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8112 |     |                 mstore(pos, length)
  8113 |     |                 let shift := sub(256, shl(3, length))
  8114 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8115 |     |             }
  8116 |     |             m0 := mload(0x00)
  8117 |     |             m1 := mload(0x20)
  8118 |     |             m2 := mload(0x40)
  8119 |     |             m3 := mload(0x60)
  8120 |     |             m4 := mload(0x80)
  8121 |     |             m5 := mload(0xa0)
  8122 |     |             m6 := mload(0xc0)
  8123 |     |             // Selector of `log(uint256,address,string,address)`.
  8124 |     |             mstore(0x00, 0x9cba8fff)
  8125 |     |             mstore(0x20, p0)
  8126 |     |             mstore(0x40, p1)
  8127 |     |             mstore(0x60, 0x80)
  8128 |     |             mstore(0x80, p3)
  8129 |     |             writeString(0xa0, p2)
  8130 |     |         }
  8131 |     |         _sendLogPayload(0x1c, 0xc4);
  8132 |     |         assembly {
  8133 |     |             mstore(0x00, m0)
  8134 |     |             mstore(0x20, m1)
  8135 |     |             mstore(0x40, m2)
  8136 |     |             mstore(0x60, m3)
  8137 |     |             mstore(0x80, m4)
  8138 |     |             mstore(0xa0, m5)
  8139 |     |             mstore(0xc0, m6)
  8140 |     |         }
  8141 |     |     }
  8142 |     | 
  8143 |     |     function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {
  8144 |     |         bytes32 m0;
  8145 |     |         bytes32 m1;
  8146 |     |         bytes32 m2;
  8147 |     |         bytes32 m3;
  8148 |     |         bytes32 m4;
  8149 |     |         bytes32 m5;
  8150 |     |         bytes32 m6;
  8151 |     |         assembly {
  8152 |     |             function writeString(pos, w) {
  8153 |     |                 let length := 0
  8154 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8155 |     |                 mstore(pos, length)
  8156 |     |                 let shift := sub(256, shl(3, length))
  8157 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8158 |     |             }
  8159 |     |             m0 := mload(0x00)
  8160 |     |             m1 := mload(0x20)
  8161 |     |             m2 := mload(0x40)
  8162 |     |             m3 := mload(0x60)
  8163 |     |             m4 := mload(0x80)
  8164 |     |             m5 := mload(0xa0)
  8165 |     |             m6 := mload(0xc0)
  8166 |     |             // Selector of `log(uint256,address,string,bool)`.
  8167 |     |             mstore(0x00, 0xcc32ab07)
  8168 |     |             mstore(0x20, p0)
  8169 |     |             mstore(0x40, p1)
  8170 |     |             mstore(0x60, 0x80)
  8171 |     |             mstore(0x80, p3)
  8172 |     |             writeString(0xa0, p2)
  8173 |     |         }
  8174 |     |         _sendLogPayload(0x1c, 0xc4);
  8175 |     |         assembly {
  8176 |     |             mstore(0x00, m0)
  8177 |     |             mstore(0x20, m1)
  8178 |     |             mstore(0x40, m2)
  8179 |     |             mstore(0x60, m3)
  8180 |     |             mstore(0x80, m4)
  8181 |     |             mstore(0xa0, m5)
  8182 |     |             mstore(0xc0, m6)
  8183 |     |         }
  8184 |     |     }
  8185 |     | 
  8186 |     |     function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {
  8187 |     |         bytes32 m0;
  8188 |     |         bytes32 m1;
  8189 |     |         bytes32 m2;
  8190 |     |         bytes32 m3;
  8191 |     |         bytes32 m4;
  8192 |     |         bytes32 m5;
  8193 |     |         bytes32 m6;
  8194 |     |         assembly {
  8195 |     |             function writeString(pos, w) {
  8196 |     |                 let length := 0
  8197 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8198 |     |                 mstore(pos, length)
  8199 |     |                 let shift := sub(256, shl(3, length))
  8200 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8201 |     |             }
  8202 |     |             m0 := mload(0x00)
  8203 |     |             m1 := mload(0x20)
  8204 |     |             m2 := mload(0x40)
  8205 |     |             m3 := mload(0x60)
  8206 |     |             m4 := mload(0x80)
  8207 |     |             m5 := mload(0xa0)
  8208 |     |             m6 := mload(0xc0)
  8209 |     |             // Selector of `log(uint256,address,string,uint256)`.
  8210 |     |             mstore(0x00, 0x46826b5d)
  8211 |     |             mstore(0x20, p0)
  8212 |     |             mstore(0x40, p1)
  8213 |     |             mstore(0x60, 0x80)
  8214 |     |             mstore(0x80, p3)
  8215 |     |             writeString(0xa0, p2)
  8216 |     |         }
  8217 |     |         _sendLogPayload(0x1c, 0xc4);
  8218 |     |         assembly {
  8219 |     |             mstore(0x00, m0)
  8220 |     |             mstore(0x20, m1)
  8221 |     |             mstore(0x40, m2)
  8222 |     |             mstore(0x60, m3)
  8223 |     |             mstore(0x80, m4)
  8224 |     |             mstore(0xa0, m5)
  8225 |     |             mstore(0xc0, m6)
  8226 |     |         }
  8227 |     |     }
  8228 |     | 
  8229 |     |     function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
  8230 |     |         bytes32 m0;
  8231 |     |         bytes32 m1;
  8232 |     |         bytes32 m2;
  8233 |     |         bytes32 m3;
  8234 |     |         bytes32 m4;
  8235 |     |         bytes32 m5;
  8236 |     |         bytes32 m6;
  8237 |     |         bytes32 m7;
  8238 |     |         bytes32 m8;
  8239 |     |         assembly {
  8240 |     |             function writeString(pos, w) {
  8241 |     |                 let length := 0
  8242 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8243 |     |                 mstore(pos, length)
  8244 |     |                 let shift := sub(256, shl(3, length))
  8245 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8246 |     |             }
  8247 |     |             m0 := mload(0x00)
  8248 |     |             m1 := mload(0x20)
  8249 |     |             m2 := mload(0x40)
  8250 |     |             m3 := mload(0x60)
  8251 |     |             m4 := mload(0x80)
  8252 |     |             m5 := mload(0xa0)
  8253 |     |             m6 := mload(0xc0)
  8254 |     |             m7 := mload(0xe0)
  8255 |     |             m8 := mload(0x100)
  8256 |     |             // Selector of `log(uint256,address,string,string)`.
  8257 |     |             mstore(0x00, 0x3e128ca3)
  8258 |     |             mstore(0x20, p0)
  8259 |     |             mstore(0x40, p1)
  8260 |     |             mstore(0x60, 0x80)
  8261 |     |             mstore(0x80, 0xc0)
  8262 |     |             writeString(0xa0, p2)
  8263 |     |             writeString(0xe0, p3)
  8264 |     |         }
  8265 |     |         _sendLogPayload(0x1c, 0x104);
  8266 |     |         assembly {
  8267 |     |             mstore(0x00, m0)
  8268 |     |             mstore(0x20, m1)
  8269 |     |             mstore(0x40, m2)
  8270 |     |             mstore(0x60, m3)
  8271 |     |             mstore(0x80, m4)
  8272 |     |             mstore(0xa0, m5)
  8273 |     |             mstore(0xc0, m6)
  8274 |     |             mstore(0xe0, m7)
  8275 |     |             mstore(0x100, m8)
  8276 |     |         }
  8277 |     |     }
  8278 |     | 
  8279 |     |     function log(uint256 p0, bool p1, address p2, address p3) internal pure {
  8280 |     |         bytes32 m0;
  8281 |     |         bytes32 m1;
  8282 |     |         bytes32 m2;
  8283 |     |         bytes32 m3;
  8284 |     |         bytes32 m4;
  8285 |     |         assembly {
  8286 |     |             m0 := mload(0x00)
  8287 |     |             m1 := mload(0x20)
  8288 |     |             m2 := mload(0x40)
  8289 |     |             m3 := mload(0x60)
  8290 |     |             m4 := mload(0x80)
  8291 |     |             // Selector of `log(uint256,bool,address,address)`.
  8292 |     |             mstore(0x00, 0xa1ef4cbb)
  8293 |     |             mstore(0x20, p0)
  8294 |     |             mstore(0x40, p1)
  8295 |     |             mstore(0x60, p2)
  8296 |     |             mstore(0x80, p3)
  8297 |     |         }
  8298 |     |         _sendLogPayload(0x1c, 0x84);
  8299 |     |         assembly {
  8300 |     |             mstore(0x00, m0)
  8301 |     |             mstore(0x20, m1)
  8302 |     |             mstore(0x40, m2)
  8303 |     |             mstore(0x60, m3)
  8304 |     |             mstore(0x80, m4)
  8305 |     |         }
  8306 |     |     }
  8307 |     | 
  8308 |     |     function log(uint256 p0, bool p1, address p2, bool p3) internal pure {
  8309 |     |         bytes32 m0;
  8310 |     |         bytes32 m1;
  8311 |     |         bytes32 m2;
  8312 |     |         bytes32 m3;
  8313 |     |         bytes32 m4;
  8314 |     |         assembly {
  8315 |     |             m0 := mload(0x00)
  8316 |     |             m1 := mload(0x20)
  8317 |     |             m2 := mload(0x40)
  8318 |     |             m3 := mload(0x60)
  8319 |     |             m4 := mload(0x80)
  8320 |     |             // Selector of `log(uint256,bool,address,bool)`.
  8321 |     |             mstore(0x00, 0x454d54a5)
  8322 |     |             mstore(0x20, p0)
  8323 |     |             mstore(0x40, p1)
  8324 |     |             mstore(0x60, p2)
  8325 |     |             mstore(0x80, p3)
  8326 |     |         }
  8327 |     |         _sendLogPayload(0x1c, 0x84);
  8328 |     |         assembly {
  8329 |     |             mstore(0x00, m0)
  8330 |     |             mstore(0x20, m1)
  8331 |     |             mstore(0x40, m2)
  8332 |     |             mstore(0x60, m3)
  8333 |     |             mstore(0x80, m4)
  8334 |     |         }
  8335 |     |     }
  8336 |     | 
  8337 |     |     function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {
  8338 |     |         bytes32 m0;
  8339 |     |         bytes32 m1;
  8340 |     |         bytes32 m2;
  8341 |     |         bytes32 m3;
  8342 |     |         bytes32 m4;
  8343 |     |         assembly {
  8344 |     |             m0 := mload(0x00)
  8345 |     |             m1 := mload(0x20)
  8346 |     |             m2 := mload(0x40)
  8347 |     |             m3 := mload(0x60)
  8348 |     |             m4 := mload(0x80)
  8349 |     |             // Selector of `log(uint256,bool,address,uint256)`.
  8350 |     |             mstore(0x00, 0x078287f5)
  8351 |     |             mstore(0x20, p0)
  8352 |     |             mstore(0x40, p1)
  8353 |     |             mstore(0x60, p2)
  8354 |     |             mstore(0x80, p3)
  8355 |     |         }
  8356 |     |         _sendLogPayload(0x1c, 0x84);
  8357 |     |         assembly {
  8358 |     |             mstore(0x00, m0)
  8359 |     |             mstore(0x20, m1)
  8360 |     |             mstore(0x40, m2)
  8361 |     |             mstore(0x60, m3)
  8362 |     |             mstore(0x80, m4)
  8363 |     |         }
  8364 |     |     }
  8365 |     | 
  8366 |     |     function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {
  8367 |     |         bytes32 m0;
  8368 |     |         bytes32 m1;
  8369 |     |         bytes32 m2;
  8370 |     |         bytes32 m3;
  8371 |     |         bytes32 m4;
  8372 |     |         bytes32 m5;
  8373 |     |         bytes32 m6;
  8374 |     |         assembly {
  8375 |     |             function writeString(pos, w) {
  8376 |     |                 let length := 0
  8377 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8378 |     |                 mstore(pos, length)
  8379 |     |                 let shift := sub(256, shl(3, length))
  8380 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8381 |     |             }
  8382 |     |             m0 := mload(0x00)
  8383 |     |             m1 := mload(0x20)
  8384 |     |             m2 := mload(0x40)
  8385 |     |             m3 := mload(0x60)
  8386 |     |             m4 := mload(0x80)
  8387 |     |             m5 := mload(0xa0)
  8388 |     |             m6 := mload(0xc0)
  8389 |     |             // Selector of `log(uint256,bool,address,string)`.
  8390 |     |             mstore(0x00, 0xade052c7)
  8391 |     |             mstore(0x20, p0)
  8392 |     |             mstore(0x40, p1)
  8393 |     |             mstore(0x60, p2)
  8394 |     |             mstore(0x80, 0x80)
  8395 |     |             writeString(0xa0, p3)
  8396 |     |         }
  8397 |     |         _sendLogPayload(0x1c, 0xc4);
  8398 |     |         assembly {
  8399 |     |             mstore(0x00, m0)
  8400 |     |             mstore(0x20, m1)
  8401 |     |             mstore(0x40, m2)
  8402 |     |             mstore(0x60, m3)
  8403 |     |             mstore(0x80, m4)
  8404 |     |             mstore(0xa0, m5)
  8405 |     |             mstore(0xc0, m6)
  8406 |     |         }
  8407 |     |     }
  8408 |     | 
  8409 |     |     function log(uint256 p0, bool p1, bool p2, address p3) internal pure {
  8410 |     |         bytes32 m0;
  8411 |     |         bytes32 m1;
  8412 |     |         bytes32 m2;
  8413 |     |         bytes32 m3;
  8414 |     |         bytes32 m4;
  8415 |     |         assembly {
  8416 |     |             m0 := mload(0x00)
  8417 |     |             m1 := mload(0x20)
  8418 |     |             m2 := mload(0x40)
  8419 |     |             m3 := mload(0x60)
  8420 |     |             m4 := mload(0x80)
  8421 |     |             // Selector of `log(uint256,bool,bool,address)`.
  8422 |     |             mstore(0x00, 0x69640b59)
  8423 |     |             mstore(0x20, p0)
  8424 |     |             mstore(0x40, p1)
  8425 |     |             mstore(0x60, p2)
  8426 |     |             mstore(0x80, p3)
  8427 |     |         }
  8428 |     |         _sendLogPayload(0x1c, 0x84);
  8429 |     |         assembly {
  8430 |     |             mstore(0x00, m0)
  8431 |     |             mstore(0x20, m1)
  8432 |     |             mstore(0x40, m2)
  8433 |     |             mstore(0x60, m3)
  8434 |     |             mstore(0x80, m4)
  8435 |     |         }
  8436 |     |     }
  8437 |     | 
  8438 |     |     function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {
  8439 |     |         bytes32 m0;
  8440 |     |         bytes32 m1;
  8441 |     |         bytes32 m2;
  8442 |     |         bytes32 m3;
  8443 |     |         bytes32 m4;
  8444 |     |         assembly {
  8445 |     |             m0 := mload(0x00)
  8446 |     |             m1 := mload(0x20)
  8447 |     |             m2 := mload(0x40)
  8448 |     |             m3 := mload(0x60)
  8449 |     |             m4 := mload(0x80)
  8450 |     |             // Selector of `log(uint256,bool,bool,bool)`.
  8451 |     |             mstore(0x00, 0xb6f577a1)
  8452 |     |             mstore(0x20, p0)
  8453 |     |             mstore(0x40, p1)
  8454 |     |             mstore(0x60, p2)
  8455 |     |             mstore(0x80, p3)
  8456 |     |         }
  8457 |     |         _sendLogPayload(0x1c, 0x84);
  8458 |     |         assembly {
  8459 |     |             mstore(0x00, m0)
  8460 |     |             mstore(0x20, m1)
  8461 |     |             mstore(0x40, m2)
  8462 |     |             mstore(0x60, m3)
  8463 |     |             mstore(0x80, m4)
  8464 |     |         }
  8465 |     |     }
  8466 |     | 
  8467 |     |     function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {
  8468 |     |         bytes32 m0;
  8469 |     |         bytes32 m1;
  8470 |     |         bytes32 m2;
  8471 |     |         bytes32 m3;
  8472 |     |         bytes32 m4;
  8473 |     |         assembly {
  8474 |     |             m0 := mload(0x00)
  8475 |     |             m1 := mload(0x20)
  8476 |     |             m2 := mload(0x40)
  8477 |     |             m3 := mload(0x60)
  8478 |     |             m4 := mload(0x80)
  8479 |     |             // Selector of `log(uint256,bool,bool,uint256)`.
  8480 |     |             mstore(0x00, 0x7464ce23)
  8481 |     |             mstore(0x20, p0)
  8482 |     |             mstore(0x40, p1)
  8483 |     |             mstore(0x60, p2)
  8484 |     |             mstore(0x80, p3)
  8485 |     |         }
  8486 |     |         _sendLogPayload(0x1c, 0x84);
  8487 |     |         assembly {
  8488 |     |             mstore(0x00, m0)
  8489 |     |             mstore(0x20, m1)
  8490 |     |             mstore(0x40, m2)
  8491 |     |             mstore(0x60, m3)
  8492 |     |             mstore(0x80, m4)
  8493 |     |         }
  8494 |     |     }
  8495 |     | 
  8496 |     |     function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {
  8497 |     |         bytes32 m0;
  8498 |     |         bytes32 m1;
  8499 |     |         bytes32 m2;
  8500 |     |         bytes32 m3;
  8501 |     |         bytes32 m4;
  8502 |     |         bytes32 m5;
  8503 |     |         bytes32 m6;
  8504 |     |         assembly {
  8505 |     |             function writeString(pos, w) {
  8506 |     |                 let length := 0
  8507 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8508 |     |                 mstore(pos, length)
  8509 |     |                 let shift := sub(256, shl(3, length))
  8510 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8511 |     |             }
  8512 |     |             m0 := mload(0x00)
  8513 |     |             m1 := mload(0x20)
  8514 |     |             m2 := mload(0x40)
  8515 |     |             m3 := mload(0x60)
  8516 |     |             m4 := mload(0x80)
  8517 |     |             m5 := mload(0xa0)
  8518 |     |             m6 := mload(0xc0)
  8519 |     |             // Selector of `log(uint256,bool,bool,string)`.
  8520 |     |             mstore(0x00, 0xdddb9561)
  8521 |     |             mstore(0x20, p0)
  8522 |     |             mstore(0x40, p1)
  8523 |     |             mstore(0x60, p2)
  8524 |     |             mstore(0x80, 0x80)
  8525 |     |             writeString(0xa0, p3)
  8526 |     |         }
  8527 |     |         _sendLogPayload(0x1c, 0xc4);
  8528 |     |         assembly {
  8529 |     |             mstore(0x00, m0)
  8530 |     |             mstore(0x20, m1)
  8531 |     |             mstore(0x40, m2)
  8532 |     |             mstore(0x60, m3)
  8533 |     |             mstore(0x80, m4)
  8534 |     |             mstore(0xa0, m5)
  8535 |     |             mstore(0xc0, m6)
  8536 |     |         }
  8537 |     |     }
  8538 |     | 
  8539 |     |     function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {
  8540 |     |         bytes32 m0;
  8541 |     |         bytes32 m1;
  8542 |     |         bytes32 m2;
  8543 |     |         bytes32 m3;
  8544 |     |         bytes32 m4;
  8545 |     |         assembly {
  8546 |     |             m0 := mload(0x00)
  8547 |     |             m1 := mload(0x20)
  8548 |     |             m2 := mload(0x40)
  8549 |     |             m3 := mload(0x60)
  8550 |     |             m4 := mload(0x80)
  8551 |     |             // Selector of `log(uint256,bool,uint256,address)`.
  8552 |     |             mstore(0x00, 0x88cb6041)
  8553 |     |             mstore(0x20, p0)
  8554 |     |             mstore(0x40, p1)
  8555 |     |             mstore(0x60, p2)
  8556 |     |             mstore(0x80, p3)
  8557 |     |         }
  8558 |     |         _sendLogPayload(0x1c, 0x84);
  8559 |     |         assembly {
  8560 |     |             mstore(0x00, m0)
  8561 |     |             mstore(0x20, m1)
  8562 |     |             mstore(0x40, m2)
  8563 |     |             mstore(0x60, m3)
  8564 |     |             mstore(0x80, m4)
  8565 |     |         }
  8566 |     |     }
  8567 |     | 
  8568 |     |     function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {
  8569 |     |         bytes32 m0;
  8570 |     |         bytes32 m1;
  8571 |     |         bytes32 m2;
  8572 |     |         bytes32 m3;
  8573 |     |         bytes32 m4;
  8574 |     |         assembly {
  8575 |     |             m0 := mload(0x00)
  8576 |     |             m1 := mload(0x20)
  8577 |     |             m2 := mload(0x40)
  8578 |     |             m3 := mload(0x60)
  8579 |     |             m4 := mload(0x80)
  8580 |     |             // Selector of `log(uint256,bool,uint256,bool)`.
  8581 |     |             mstore(0x00, 0x91a02e2a)
  8582 |     |             mstore(0x20, p0)
  8583 |     |             mstore(0x40, p1)
  8584 |     |             mstore(0x60, p2)
  8585 |     |             mstore(0x80, p3)
  8586 |     |         }
  8587 |     |         _sendLogPayload(0x1c, 0x84);
  8588 |     |         assembly {
  8589 |     |             mstore(0x00, m0)
  8590 |     |             mstore(0x20, m1)
  8591 |     |             mstore(0x40, m2)
  8592 |     |             mstore(0x60, m3)
  8593 |     |             mstore(0x80, m4)
  8594 |     |         }
  8595 |     |     }
  8596 |     | 
  8597 |     |     function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {
  8598 |     |         bytes32 m0;
  8599 |     |         bytes32 m1;
  8600 |     |         bytes32 m2;
  8601 |     |         bytes32 m3;
  8602 |     |         bytes32 m4;
  8603 |     |         assembly {
  8604 |     |             m0 := mload(0x00)
  8605 |     |             m1 := mload(0x20)
  8606 |     |             m2 := mload(0x40)
  8607 |     |             m3 := mload(0x60)
  8608 |     |             m4 := mload(0x80)
  8609 |     |             // Selector of `log(uint256,bool,uint256,uint256)`.
  8610 |     |             mstore(0x00, 0xc6acc7a8)
  8611 |     |             mstore(0x20, p0)
  8612 |     |             mstore(0x40, p1)
  8613 |     |             mstore(0x60, p2)
  8614 |     |             mstore(0x80, p3)
  8615 |     |         }
  8616 |     |         _sendLogPayload(0x1c, 0x84);
  8617 |     |         assembly {
  8618 |     |             mstore(0x00, m0)
  8619 |     |             mstore(0x20, m1)
  8620 |     |             mstore(0x40, m2)
  8621 |     |             mstore(0x60, m3)
  8622 |     |             mstore(0x80, m4)
  8623 |     |         }
  8624 |     |     }
  8625 |     | 
  8626 |     |     function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
  8627 |     |         bytes32 m0;
  8628 |     |         bytes32 m1;
  8629 |     |         bytes32 m2;
  8630 |     |         bytes32 m3;
  8631 |     |         bytes32 m4;
  8632 |     |         bytes32 m5;
  8633 |     |         bytes32 m6;
  8634 |     |         assembly {
  8635 |     |             function writeString(pos, w) {
  8636 |     |                 let length := 0
  8637 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8638 |     |                 mstore(pos, length)
  8639 |     |                 let shift := sub(256, shl(3, length))
  8640 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8641 |     |             }
  8642 |     |             m0 := mload(0x00)
  8643 |     |             m1 := mload(0x20)
  8644 |     |             m2 := mload(0x40)
  8645 |     |             m3 := mload(0x60)
  8646 |     |             m4 := mload(0x80)
  8647 |     |             m5 := mload(0xa0)
  8648 |     |             m6 := mload(0xc0)
  8649 |     |             // Selector of `log(uint256,bool,uint256,string)`.
  8650 |     |             mstore(0x00, 0xde03e774)
  8651 |     |             mstore(0x20, p0)
  8652 |     |             mstore(0x40, p1)
  8653 |     |             mstore(0x60, p2)
  8654 |     |             mstore(0x80, 0x80)
  8655 |     |             writeString(0xa0, p3)
  8656 |     |         }
  8657 |     |         _sendLogPayload(0x1c, 0xc4);
  8658 |     |         assembly {
  8659 |     |             mstore(0x00, m0)
  8660 |     |             mstore(0x20, m1)
  8661 |     |             mstore(0x40, m2)
  8662 |     |             mstore(0x60, m3)
  8663 |     |             mstore(0x80, m4)
  8664 |     |             mstore(0xa0, m5)
  8665 |     |             mstore(0xc0, m6)
  8666 |     |         }
  8667 |     |     }
  8668 |     | 
  8669 |     |     function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {
  8670 |     |         bytes32 m0;
  8671 |     |         bytes32 m1;
  8672 |     |         bytes32 m2;
  8673 |     |         bytes32 m3;
  8674 |     |         bytes32 m4;
  8675 |     |         bytes32 m5;
  8676 |     |         bytes32 m6;
  8677 |     |         assembly {
  8678 |     |             function writeString(pos, w) {
  8679 |     |                 let length := 0
  8680 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8681 |     |                 mstore(pos, length)
  8682 |     |                 let shift := sub(256, shl(3, length))
  8683 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8684 |     |             }
  8685 |     |             m0 := mload(0x00)
  8686 |     |             m1 := mload(0x20)
  8687 |     |             m2 := mload(0x40)
  8688 |     |             m3 := mload(0x60)
  8689 |     |             m4 := mload(0x80)
  8690 |     |             m5 := mload(0xa0)
  8691 |     |             m6 := mload(0xc0)
  8692 |     |             // Selector of `log(uint256,bool,string,address)`.
  8693 |     |             mstore(0x00, 0xef529018)
  8694 |     |             mstore(0x20, p0)
  8695 |     |             mstore(0x40, p1)
  8696 |     |             mstore(0x60, 0x80)
  8697 |     |             mstore(0x80, p3)
  8698 |     |             writeString(0xa0, p2)
  8699 |     |         }
  8700 |     |         _sendLogPayload(0x1c, 0xc4);
  8701 |     |         assembly {
  8702 |     |             mstore(0x00, m0)
  8703 |     |             mstore(0x20, m1)
  8704 |     |             mstore(0x40, m2)
  8705 |     |             mstore(0x60, m3)
  8706 |     |             mstore(0x80, m4)
  8707 |     |             mstore(0xa0, m5)
  8708 |     |             mstore(0xc0, m6)
  8709 |     |         }
  8710 |     |     }
  8711 |     | 
  8712 |     |     function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {
  8713 |     |         bytes32 m0;
  8714 |     |         bytes32 m1;
  8715 |     |         bytes32 m2;
  8716 |     |         bytes32 m3;
  8717 |     |         bytes32 m4;
  8718 |     |         bytes32 m5;
  8719 |     |         bytes32 m6;
  8720 |     |         assembly {
  8721 |     |             function writeString(pos, w) {
  8722 |     |                 let length := 0
  8723 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8724 |     |                 mstore(pos, length)
  8725 |     |                 let shift := sub(256, shl(3, length))
  8726 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8727 |     |             }
  8728 |     |             m0 := mload(0x00)
  8729 |     |             m1 := mload(0x20)
  8730 |     |             m2 := mload(0x40)
  8731 |     |             m3 := mload(0x60)
  8732 |     |             m4 := mload(0x80)
  8733 |     |             m5 := mload(0xa0)
  8734 |     |             m6 := mload(0xc0)
  8735 |     |             // Selector of `log(uint256,bool,string,bool)`.
  8736 |     |             mstore(0x00, 0xeb928d7f)
  8737 |     |             mstore(0x20, p0)
  8738 |     |             mstore(0x40, p1)
  8739 |     |             mstore(0x60, 0x80)
  8740 |     |             mstore(0x80, p3)
  8741 |     |             writeString(0xa0, p2)
  8742 |     |         }
  8743 |     |         _sendLogPayload(0x1c, 0xc4);
  8744 |     |         assembly {
  8745 |     |             mstore(0x00, m0)
  8746 |     |             mstore(0x20, m1)
  8747 |     |             mstore(0x40, m2)
  8748 |     |             mstore(0x60, m3)
  8749 |     |             mstore(0x80, m4)
  8750 |     |             mstore(0xa0, m5)
  8751 |     |             mstore(0xc0, m6)
  8752 |     |         }
  8753 |     |     }
  8754 |     | 
  8755 |     |     function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
  8756 |     |         bytes32 m0;
  8757 |     |         bytes32 m1;
  8758 |     |         bytes32 m2;
  8759 |     |         bytes32 m3;
  8760 |     |         bytes32 m4;
  8761 |     |         bytes32 m5;
  8762 |     |         bytes32 m6;
  8763 |     |         assembly {
  8764 |     |             function writeString(pos, w) {
  8765 |     |                 let length := 0
  8766 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8767 |     |                 mstore(pos, length)
  8768 |     |                 let shift := sub(256, shl(3, length))
  8769 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8770 |     |             }
  8771 |     |             m0 := mload(0x00)
  8772 |     |             m1 := mload(0x20)
  8773 |     |             m2 := mload(0x40)
  8774 |     |             m3 := mload(0x60)
  8775 |     |             m4 := mload(0x80)
  8776 |     |             m5 := mload(0xa0)
  8777 |     |             m6 := mload(0xc0)
  8778 |     |             // Selector of `log(uint256,bool,string,uint256)`.
  8779 |     |             mstore(0x00, 0x2c1d0746)
  8780 |     |             mstore(0x20, p0)
  8781 |     |             mstore(0x40, p1)
  8782 |     |             mstore(0x60, 0x80)
  8783 |     |             mstore(0x80, p3)
  8784 |     |             writeString(0xa0, p2)
  8785 |     |         }
  8786 |     |         _sendLogPayload(0x1c, 0xc4);
  8787 |     |         assembly {
  8788 |     |             mstore(0x00, m0)
  8789 |     |             mstore(0x20, m1)
  8790 |     |             mstore(0x40, m2)
  8791 |     |             mstore(0x60, m3)
  8792 |     |             mstore(0x80, m4)
  8793 |     |             mstore(0xa0, m5)
  8794 |     |             mstore(0xc0, m6)
  8795 |     |         }
  8796 |     |     }
  8797 |     | 
  8798 |     |     function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
  8799 |     |         bytes32 m0;
  8800 |     |         bytes32 m1;
  8801 |     |         bytes32 m2;
  8802 |     |         bytes32 m3;
  8803 |     |         bytes32 m4;
  8804 |     |         bytes32 m5;
  8805 |     |         bytes32 m6;
  8806 |     |         bytes32 m7;
  8807 |     |         bytes32 m8;
  8808 |     |         assembly {
  8809 |     |             function writeString(pos, w) {
  8810 |     |                 let length := 0
  8811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8812 |     |                 mstore(pos, length)
  8813 |     |                 let shift := sub(256, shl(3, length))
  8814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8815 |     |             }
  8816 |     |             m0 := mload(0x00)
  8817 |     |             m1 := mload(0x20)
  8818 |     |             m2 := mload(0x40)
  8819 |     |             m3 := mload(0x60)
  8820 |     |             m4 := mload(0x80)
  8821 |     |             m5 := mload(0xa0)
  8822 |     |             m6 := mload(0xc0)
  8823 |     |             m7 := mload(0xe0)
  8824 |     |             m8 := mload(0x100)
  8825 |     |             // Selector of `log(uint256,bool,string,string)`.
  8826 |     |             mstore(0x00, 0x68c8b8bd)
  8827 |     |             mstore(0x20, p0)
  8828 |     |             mstore(0x40, p1)
  8829 |     |             mstore(0x60, 0x80)
  8830 |     |             mstore(0x80, 0xc0)
  8831 |     |             writeString(0xa0, p2)
  8832 |     |             writeString(0xe0, p3)
  8833 |     |         }
  8834 |     |         _sendLogPayload(0x1c, 0x104);
  8835 |     |         assembly {
  8836 |     |             mstore(0x00, m0)
  8837 |     |             mstore(0x20, m1)
  8838 |     |             mstore(0x40, m2)
  8839 |     |             mstore(0x60, m3)
  8840 |     |             mstore(0x80, m4)
  8841 |     |             mstore(0xa0, m5)
  8842 |     |             mstore(0xc0, m6)
  8843 |     |             mstore(0xe0, m7)
  8844 |     |             mstore(0x100, m8)
  8845 |     |         }
  8846 |     |     }
  8847 |     | 
  8848 |     |     function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {
  8849 |     |         bytes32 m0;
  8850 |     |         bytes32 m1;
  8851 |     |         bytes32 m2;
  8852 |     |         bytes32 m3;
  8853 |     |         bytes32 m4;
  8854 |     |         assembly {
  8855 |     |             m0 := mload(0x00)
  8856 |     |             m1 := mload(0x20)
  8857 |     |             m2 := mload(0x40)
  8858 |     |             m3 := mload(0x60)
  8859 |     |             m4 := mload(0x80)
  8860 |     |             // Selector of `log(uint256,uint256,address,address)`.
  8861 |     |             mstore(0x00, 0x56a5d1b1)
  8862 |     |             mstore(0x20, p0)
  8863 |     |             mstore(0x40, p1)
  8864 |     |             mstore(0x60, p2)
  8865 |     |             mstore(0x80, p3)
  8866 |     |         }
  8867 |     |         _sendLogPayload(0x1c, 0x84);
  8868 |     |         assembly {
  8869 |     |             mstore(0x00, m0)
  8870 |     |             mstore(0x20, m1)
  8871 |     |             mstore(0x40, m2)
  8872 |     |             mstore(0x60, m3)
  8873 |     |             mstore(0x80, m4)
  8874 |     |         }
  8875 |     |     }
  8876 |     | 
  8877 |     |     function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {
  8878 |     |         bytes32 m0;
  8879 |     |         bytes32 m1;
  8880 |     |         bytes32 m2;
  8881 |     |         bytes32 m3;
  8882 |     |         bytes32 m4;
  8883 |     |         assembly {
  8884 |     |             m0 := mload(0x00)
  8885 |     |             m1 := mload(0x20)
  8886 |     |             m2 := mload(0x40)
  8887 |     |             m3 := mload(0x60)
  8888 |     |             m4 := mload(0x80)
  8889 |     |             // Selector of `log(uint256,uint256,address,bool)`.
  8890 |     |             mstore(0x00, 0x15cac476)
  8891 |     |             mstore(0x20, p0)
  8892 |     |             mstore(0x40, p1)
  8893 |     |             mstore(0x60, p2)
  8894 |     |             mstore(0x80, p3)
  8895 |     |         }
  8896 |     |         _sendLogPayload(0x1c, 0x84);
  8897 |     |         assembly {
  8898 |     |             mstore(0x00, m0)
  8899 |     |             mstore(0x20, m1)
  8900 |     |             mstore(0x40, m2)
  8901 |     |             mstore(0x60, m3)
  8902 |     |             mstore(0x80, m4)
  8903 |     |         }
  8904 |     |     }
  8905 |     | 
  8906 |     |     function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {
  8907 |     |         bytes32 m0;
  8908 |     |         bytes32 m1;
  8909 |     |         bytes32 m2;
  8910 |     |         bytes32 m3;
  8911 |     |         bytes32 m4;
  8912 |     |         assembly {
  8913 |     |             m0 := mload(0x00)
  8914 |     |             m1 := mload(0x20)
  8915 |     |             m2 := mload(0x40)
  8916 |     |             m3 := mload(0x60)
  8917 |     |             m4 := mload(0x80)
  8918 |     |             // Selector of `log(uint256,uint256,address,uint256)`.
  8919 |     |             mstore(0x00, 0x88f6e4b2)
  8920 |     |             mstore(0x20, p0)
  8921 |     |             mstore(0x40, p1)
  8922 |     |             mstore(0x60, p2)
  8923 |     |             mstore(0x80, p3)
  8924 |     |         }
  8925 |     |         _sendLogPayload(0x1c, 0x84);
  8926 |     |         assembly {
  8927 |     |             mstore(0x00, m0)
  8928 |     |             mstore(0x20, m1)
  8929 |     |             mstore(0x40, m2)
  8930 |     |             mstore(0x60, m3)
  8931 |     |             mstore(0x80, m4)
  8932 |     |         }
  8933 |     |     }
  8934 |     | 
  8935 |     |     function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {
  8936 |     |         bytes32 m0;
  8937 |     |         bytes32 m1;
  8938 |     |         bytes32 m2;
  8939 |     |         bytes32 m3;
  8940 |     |         bytes32 m4;
  8941 |     |         bytes32 m5;
  8942 |     |         bytes32 m6;
  8943 |     |         assembly {
  8944 |     |             function writeString(pos, w) {
  8945 |     |                 let length := 0
  8946 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  8947 |     |                 mstore(pos, length)
  8948 |     |                 let shift := sub(256, shl(3, length))
  8949 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  8950 |     |             }
  8951 |     |             m0 := mload(0x00)
  8952 |     |             m1 := mload(0x20)
  8953 |     |             m2 := mload(0x40)
  8954 |     |             m3 := mload(0x60)
  8955 |     |             m4 := mload(0x80)
  8956 |     |             m5 := mload(0xa0)
  8957 |     |             m6 := mload(0xc0)
  8958 |     |             // Selector of `log(uint256,uint256,address,string)`.
  8959 |     |             mstore(0x00, 0x6cde40b8)
  8960 |     |             mstore(0x20, p0)
  8961 |     |             mstore(0x40, p1)
  8962 |     |             mstore(0x60, p2)
  8963 |     |             mstore(0x80, 0x80)
  8964 |     |             writeString(0xa0, p3)
  8965 |     |         }
  8966 |     |         _sendLogPayload(0x1c, 0xc4);
  8967 |     |         assembly {
  8968 |     |             mstore(0x00, m0)
  8969 |     |             mstore(0x20, m1)
  8970 |     |             mstore(0x40, m2)
  8971 |     |             mstore(0x60, m3)
  8972 |     |             mstore(0x80, m4)
  8973 |     |             mstore(0xa0, m5)
  8974 |     |             mstore(0xc0, m6)
  8975 |     |         }
  8976 |     |     }
  8977 |     | 
  8978 |     |     function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {
  8979 |     |         bytes32 m0;
  8980 |     |         bytes32 m1;
  8981 |     |         bytes32 m2;
  8982 |     |         bytes32 m3;
  8983 |     |         bytes32 m4;
  8984 |     |         assembly {
  8985 |     |             m0 := mload(0x00)
  8986 |     |             m1 := mload(0x20)
  8987 |     |             m2 := mload(0x40)
  8988 |     |             m3 := mload(0x60)
  8989 |     |             m4 := mload(0x80)
  8990 |     |             // Selector of `log(uint256,uint256,bool,address)`.
  8991 |     |             mstore(0x00, 0x9a816a83)
  8992 |     |             mstore(0x20, p0)
  8993 |     |             mstore(0x40, p1)
  8994 |     |             mstore(0x60, p2)
  8995 |     |             mstore(0x80, p3)
  8996 |     |         }
  8997 |     |         _sendLogPayload(0x1c, 0x84);
  8998 |     |         assembly {
  8999 |     |             mstore(0x00, m0)
  9000 |     |             mstore(0x20, m1)
  9001 |     |             mstore(0x40, m2)
  9002 |     |             mstore(0x60, m3)
  9003 |     |             mstore(0x80, m4)
  9004 |     |         }
  9005 |     |     }
  9006 |     | 
  9007 |     |     function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {
  9008 |     |         bytes32 m0;
  9009 |     |         bytes32 m1;
  9010 |     |         bytes32 m2;
  9011 |     |         bytes32 m3;
  9012 |     |         bytes32 m4;
  9013 |     |         assembly {
  9014 |     |             m0 := mload(0x00)
  9015 |     |             m1 := mload(0x20)
  9016 |     |             m2 := mload(0x40)
  9017 |     |             m3 := mload(0x60)
  9018 |     |             m4 := mload(0x80)
  9019 |     |             // Selector of `log(uint256,uint256,bool,bool)`.
  9020 |     |             mstore(0x00, 0xab085ae6)
  9021 |     |             mstore(0x20, p0)
  9022 |     |             mstore(0x40, p1)
  9023 |     |             mstore(0x60, p2)
  9024 |     |             mstore(0x80, p3)
  9025 |     |         }
  9026 |     |         _sendLogPayload(0x1c, 0x84);
  9027 |     |         assembly {
  9028 |     |             mstore(0x00, m0)
  9029 |     |             mstore(0x20, m1)
  9030 |     |             mstore(0x40, m2)
  9031 |     |             mstore(0x60, m3)
  9032 |     |             mstore(0x80, m4)
  9033 |     |         }
  9034 |     |     }
  9035 |     | 
  9036 |     |     function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {
  9037 |     |         bytes32 m0;
  9038 |     |         bytes32 m1;
  9039 |     |         bytes32 m2;
  9040 |     |         bytes32 m3;
  9041 |     |         bytes32 m4;
  9042 |     |         assembly {
  9043 |     |             m0 := mload(0x00)
  9044 |     |             m1 := mload(0x20)
  9045 |     |             m2 := mload(0x40)
  9046 |     |             m3 := mload(0x60)
  9047 |     |             m4 := mload(0x80)
  9048 |     |             // Selector of `log(uint256,uint256,bool,uint256)`.
  9049 |     |             mstore(0x00, 0xeb7f6fd2)
  9050 |     |             mstore(0x20, p0)
  9051 |     |             mstore(0x40, p1)
  9052 |     |             mstore(0x60, p2)
  9053 |     |             mstore(0x80, p3)
  9054 |     |         }
  9055 |     |         _sendLogPayload(0x1c, 0x84);
  9056 |     |         assembly {
  9057 |     |             mstore(0x00, m0)
  9058 |     |             mstore(0x20, m1)
  9059 |     |             mstore(0x40, m2)
  9060 |     |             mstore(0x60, m3)
  9061 |     |             mstore(0x80, m4)
  9062 |     |         }
  9063 |     |     }
  9064 |     | 
  9065 |     |     function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
  9066 |     |         bytes32 m0;
  9067 |     |         bytes32 m1;
  9068 |     |         bytes32 m2;
  9069 |     |         bytes32 m3;
  9070 |     |         bytes32 m4;
  9071 |     |         bytes32 m5;
  9072 |     |         bytes32 m6;
  9073 |     |         assembly {
  9074 |     |             function writeString(pos, w) {
  9075 |     |                 let length := 0
  9076 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9077 |     |                 mstore(pos, length)
  9078 |     |                 let shift := sub(256, shl(3, length))
  9079 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9080 |     |             }
  9081 |     |             m0 := mload(0x00)
  9082 |     |             m1 := mload(0x20)
  9083 |     |             m2 := mload(0x40)
  9084 |     |             m3 := mload(0x60)
  9085 |     |             m4 := mload(0x80)
  9086 |     |             m5 := mload(0xa0)
  9087 |     |             m6 := mload(0xc0)
  9088 |     |             // Selector of `log(uint256,uint256,bool,string)`.
  9089 |     |             mstore(0x00, 0xa5b4fc99)
  9090 |     |             mstore(0x20, p0)
  9091 |     |             mstore(0x40, p1)
  9092 |     |             mstore(0x60, p2)
  9093 |     |             mstore(0x80, 0x80)
  9094 |     |             writeString(0xa0, p3)
  9095 |     |         }
  9096 |     |         _sendLogPayload(0x1c, 0xc4);
  9097 |     |         assembly {
  9098 |     |             mstore(0x00, m0)
  9099 |     |             mstore(0x20, m1)
  9100 |     |             mstore(0x40, m2)
  9101 |     |             mstore(0x60, m3)
  9102 |     |             mstore(0x80, m4)
  9103 |     |             mstore(0xa0, m5)
  9104 |     |             mstore(0xc0, m6)
  9105 |     |         }
  9106 |     |     }
  9107 |     | 
  9108 |     |     function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {
  9109 |     |         bytes32 m0;
  9110 |     |         bytes32 m1;
  9111 |     |         bytes32 m2;
  9112 |     |         bytes32 m3;
  9113 |     |         bytes32 m4;
  9114 |     |         assembly {
  9115 |     |             m0 := mload(0x00)
  9116 |     |             m1 := mload(0x20)
  9117 |     |             m2 := mload(0x40)
  9118 |     |             m3 := mload(0x60)
  9119 |     |             m4 := mload(0x80)
  9120 |     |             // Selector of `log(uint256,uint256,uint256,address)`.
  9121 |     |             mstore(0x00, 0xfa8185af)
  9122 |     |             mstore(0x20, p0)
  9123 |     |             mstore(0x40, p1)
  9124 |     |             mstore(0x60, p2)
  9125 |     |             mstore(0x80, p3)
  9126 |     |         }
  9127 |     |         _sendLogPayload(0x1c, 0x84);
  9128 |     |         assembly {
  9129 |     |             mstore(0x00, m0)
  9130 |     |             mstore(0x20, m1)
  9131 |     |             mstore(0x40, m2)
  9132 |     |             mstore(0x60, m3)
  9133 |     |             mstore(0x80, m4)
  9134 |     |         }
  9135 |     |     }
  9136 |     | 
  9137 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {
  9138 |     |         bytes32 m0;
  9139 |     |         bytes32 m1;
  9140 |     |         bytes32 m2;
  9141 |     |         bytes32 m3;
  9142 |     |         bytes32 m4;
  9143 |     |         assembly {
  9144 |     |             m0 := mload(0x00)
  9145 |     |             m1 := mload(0x20)
  9146 |     |             m2 := mload(0x40)
  9147 |     |             m3 := mload(0x60)
  9148 |     |             m4 := mload(0x80)
  9149 |     |             // Selector of `log(uint256,uint256,uint256,bool)`.
  9150 |     |             mstore(0x00, 0xc598d185)
  9151 |     |             mstore(0x20, p0)
  9152 |     |             mstore(0x40, p1)
  9153 |     |             mstore(0x60, p2)
  9154 |     |             mstore(0x80, p3)
  9155 |     |         }
  9156 |     |         _sendLogPayload(0x1c, 0x84);
  9157 |     |         assembly {
  9158 |     |             mstore(0x00, m0)
  9159 |     |             mstore(0x20, m1)
  9160 |     |             mstore(0x40, m2)
  9161 |     |             mstore(0x60, m3)
  9162 |     |             mstore(0x80, m4)
  9163 |     |         }
  9164 |     |     }
  9165 |     | 
  9166 |     |     function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
  9167 |     |         bytes32 m0;
  9168 |     |         bytes32 m1;
  9169 |     |         bytes32 m2;
  9170 |     |         bytes32 m3;
  9171 |     |         bytes32 m4;
  9172 |     |         assembly {
  9173 |     |             m0 := mload(0x00)
  9174 |     |             m1 := mload(0x20)
  9175 |     |             m2 := mload(0x40)
  9176 |     |             m3 := mload(0x60)
  9177 |     |             m4 := mload(0x80)
  9178 |     |             // Selector of `log(uint256,uint256,uint256,uint256)`.
  9179 |     |             mstore(0x00, 0x193fb800)
  9180 |     |             mstore(0x20, p0)
  9181 |     |             mstore(0x40, p1)
  9182 |     |             mstore(0x60, p2)
  9183 |     |             mstore(0x80, p3)
  9184 |     |         }
  9185 |     |         _sendLogPayload(0x1c, 0x84);
  9186 |     |         assembly {
  9187 |     |             mstore(0x00, m0)
  9188 |     |             mstore(0x20, m1)
  9189 |     |             mstore(0x40, m2)
  9190 |     |             mstore(0x60, m3)
  9191 |     |             mstore(0x80, m4)
  9192 |     |         }
  9193 |     |     }
  9194 |     | 
  9195 |     |     function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
  9196 |     |         bytes32 m0;
  9197 |     |         bytes32 m1;
  9198 |     |         bytes32 m2;
  9199 |     |         bytes32 m3;
  9200 |     |         bytes32 m4;
  9201 |     |         bytes32 m5;
  9202 |     |         bytes32 m6;
  9203 |     |         assembly {
  9204 |     |             function writeString(pos, w) {
  9205 |     |                 let length := 0
  9206 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9207 |     |                 mstore(pos, length)
  9208 |     |                 let shift := sub(256, shl(3, length))
  9209 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9210 |     |             }
  9211 |     |             m0 := mload(0x00)
  9212 |     |             m1 := mload(0x20)
  9213 |     |             m2 := mload(0x40)
  9214 |     |             m3 := mload(0x60)
  9215 |     |             m4 := mload(0x80)
  9216 |     |             m5 := mload(0xa0)
  9217 |     |             m6 := mload(0xc0)
  9218 |     |             // Selector of `log(uint256,uint256,uint256,string)`.
  9219 |     |             mstore(0x00, 0x59cfcbe3)
  9220 |     |             mstore(0x20, p0)
  9221 |     |             mstore(0x40, p1)
  9222 |     |             mstore(0x60, p2)
  9223 |     |             mstore(0x80, 0x80)
  9224 |     |             writeString(0xa0, p3)
  9225 |     |         }
  9226 |     |         _sendLogPayload(0x1c, 0xc4);
  9227 |     |         assembly {
  9228 |     |             mstore(0x00, m0)
  9229 |     |             mstore(0x20, m1)
  9230 |     |             mstore(0x40, m2)
  9231 |     |             mstore(0x60, m3)
  9232 |     |             mstore(0x80, m4)
  9233 |     |             mstore(0xa0, m5)
  9234 |     |             mstore(0xc0, m6)
  9235 |     |         }
  9236 |     |     }
  9237 |     | 
  9238 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {
  9239 |     |         bytes32 m0;
  9240 |     |         bytes32 m1;
  9241 |     |         bytes32 m2;
  9242 |     |         bytes32 m3;
  9243 |     |         bytes32 m4;
  9244 |     |         bytes32 m5;
  9245 |     |         bytes32 m6;
  9246 |     |         assembly {
  9247 |     |             function writeString(pos, w) {
  9248 |     |                 let length := 0
  9249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9250 |     |                 mstore(pos, length)
  9251 |     |                 let shift := sub(256, shl(3, length))
  9252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9253 |     |             }
  9254 |     |             m0 := mload(0x00)
  9255 |     |             m1 := mload(0x20)
  9256 |     |             m2 := mload(0x40)
  9257 |     |             m3 := mload(0x60)
  9258 |     |             m4 := mload(0x80)
  9259 |     |             m5 := mload(0xa0)
  9260 |     |             m6 := mload(0xc0)
  9261 |     |             // Selector of `log(uint256,uint256,string,address)`.
  9262 |     |             mstore(0x00, 0x42d21db7)
  9263 |     |             mstore(0x20, p0)
  9264 |     |             mstore(0x40, p1)
  9265 |     |             mstore(0x60, 0x80)
  9266 |     |             mstore(0x80, p3)
  9267 |     |             writeString(0xa0, p2)
  9268 |     |         }
  9269 |     |         _sendLogPayload(0x1c, 0xc4);
  9270 |     |         assembly {
  9271 |     |             mstore(0x00, m0)
  9272 |     |             mstore(0x20, m1)
  9273 |     |             mstore(0x40, m2)
  9274 |     |             mstore(0x60, m3)
  9275 |     |             mstore(0x80, m4)
  9276 |     |             mstore(0xa0, m5)
  9277 |     |             mstore(0xc0, m6)
  9278 |     |         }
  9279 |     |     }
  9280 |     | 
  9281 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
  9282 |     |         bytes32 m0;
  9283 |     |         bytes32 m1;
  9284 |     |         bytes32 m2;
  9285 |     |         bytes32 m3;
  9286 |     |         bytes32 m4;
  9287 |     |         bytes32 m5;
  9288 |     |         bytes32 m6;
  9289 |     |         assembly {
  9290 |     |             function writeString(pos, w) {
  9291 |     |                 let length := 0
  9292 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9293 |     |                 mstore(pos, length)
  9294 |     |                 let shift := sub(256, shl(3, length))
  9295 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9296 |     |             }
  9297 |     |             m0 := mload(0x00)
  9298 |     |             m1 := mload(0x20)
  9299 |     |             m2 := mload(0x40)
  9300 |     |             m3 := mload(0x60)
  9301 |     |             m4 := mload(0x80)
  9302 |     |             m5 := mload(0xa0)
  9303 |     |             m6 := mload(0xc0)
  9304 |     |             // Selector of `log(uint256,uint256,string,bool)`.
  9305 |     |             mstore(0x00, 0x7af6ab25)
  9306 |     |             mstore(0x20, p0)
  9307 |     |             mstore(0x40, p1)
  9308 |     |             mstore(0x60, 0x80)
  9309 |     |             mstore(0x80, p3)
  9310 |     |             writeString(0xa0, p2)
  9311 |     |         }
  9312 |     |         _sendLogPayload(0x1c, 0xc4);
  9313 |     |         assembly {
  9314 |     |             mstore(0x00, m0)
  9315 |     |             mstore(0x20, m1)
  9316 |     |             mstore(0x40, m2)
  9317 |     |             mstore(0x60, m3)
  9318 |     |             mstore(0x80, m4)
  9319 |     |             mstore(0xa0, m5)
  9320 |     |             mstore(0xc0, m6)
  9321 |     |         }
  9322 |     |     }
  9323 |     | 
  9324 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
  9325 |     |         bytes32 m0;
  9326 |     |         bytes32 m1;
  9327 |     |         bytes32 m2;
  9328 |     |         bytes32 m3;
  9329 |     |         bytes32 m4;
  9330 |     |         bytes32 m5;
  9331 |     |         bytes32 m6;
  9332 |     |         assembly {
  9333 |     |             function writeString(pos, w) {
  9334 |     |                 let length := 0
  9335 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9336 |     |                 mstore(pos, length)
  9337 |     |                 let shift := sub(256, shl(3, length))
  9338 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9339 |     |             }
  9340 |     |             m0 := mload(0x00)
  9341 |     |             m1 := mload(0x20)
  9342 |     |             m2 := mload(0x40)
  9343 |     |             m3 := mload(0x60)
  9344 |     |             m4 := mload(0x80)
  9345 |     |             m5 := mload(0xa0)
  9346 |     |             m6 := mload(0xc0)
  9347 |     |             // Selector of `log(uint256,uint256,string,uint256)`.
  9348 |     |             mstore(0x00, 0x5da297eb)
  9349 |     |             mstore(0x20, p0)
  9350 |     |             mstore(0x40, p1)
  9351 |     |             mstore(0x60, 0x80)
  9352 |     |             mstore(0x80, p3)
  9353 |     |             writeString(0xa0, p2)
  9354 |     |         }
  9355 |     |         _sendLogPayload(0x1c, 0xc4);
  9356 |     |         assembly {
  9357 |     |             mstore(0x00, m0)
  9358 |     |             mstore(0x20, m1)
  9359 |     |             mstore(0x40, m2)
  9360 |     |             mstore(0x60, m3)
  9361 |     |             mstore(0x80, m4)
  9362 |     |             mstore(0xa0, m5)
  9363 |     |             mstore(0xc0, m6)
  9364 |     |         }
  9365 |     |     }
  9366 |     | 
  9367 |     |     function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
  9368 |     |         bytes32 m0;
  9369 |     |         bytes32 m1;
  9370 |     |         bytes32 m2;
  9371 |     |         bytes32 m3;
  9372 |     |         bytes32 m4;
  9373 |     |         bytes32 m5;
  9374 |     |         bytes32 m6;
  9375 |     |         bytes32 m7;
  9376 |     |         bytes32 m8;
  9377 |     |         assembly {
  9378 |     |             function writeString(pos, w) {
  9379 |     |                 let length := 0
  9380 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9381 |     |                 mstore(pos, length)
  9382 |     |                 let shift := sub(256, shl(3, length))
  9383 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9384 |     |             }
  9385 |     |             m0 := mload(0x00)
  9386 |     |             m1 := mload(0x20)
  9387 |     |             m2 := mload(0x40)
  9388 |     |             m3 := mload(0x60)
  9389 |     |             m4 := mload(0x80)
  9390 |     |             m5 := mload(0xa0)
  9391 |     |             m6 := mload(0xc0)
  9392 |     |             m7 := mload(0xe0)
  9393 |     |             m8 := mload(0x100)
  9394 |     |             // Selector of `log(uint256,uint256,string,string)`.
  9395 |     |             mstore(0x00, 0x27d8afd2)
  9396 |     |             mstore(0x20, p0)
  9397 |     |             mstore(0x40, p1)
  9398 |     |             mstore(0x60, 0x80)
  9399 |     |             mstore(0x80, 0xc0)
  9400 |     |             writeString(0xa0, p2)
  9401 |     |             writeString(0xe0, p3)
  9402 |     |         }
  9403 |     |         _sendLogPayload(0x1c, 0x104);
  9404 |     |         assembly {
  9405 |     |             mstore(0x00, m0)
  9406 |     |             mstore(0x20, m1)
  9407 |     |             mstore(0x40, m2)
  9408 |     |             mstore(0x60, m3)
  9409 |     |             mstore(0x80, m4)
  9410 |     |             mstore(0xa0, m5)
  9411 |     |             mstore(0xc0, m6)
  9412 |     |             mstore(0xe0, m7)
  9413 |     |             mstore(0x100, m8)
  9414 |     |         }
  9415 |     |     }
  9416 |     | 
  9417 |     |     function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {
  9418 |     |         bytes32 m0;
  9419 |     |         bytes32 m1;
  9420 |     |         bytes32 m2;
  9421 |     |         bytes32 m3;
  9422 |     |         bytes32 m4;
  9423 |     |         bytes32 m5;
  9424 |     |         bytes32 m6;
  9425 |     |         assembly {
  9426 |     |             function writeString(pos, w) {
  9427 |     |                 let length := 0
  9428 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9429 |     |                 mstore(pos, length)
  9430 |     |                 let shift := sub(256, shl(3, length))
  9431 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9432 |     |             }
  9433 |     |             m0 := mload(0x00)
  9434 |     |             m1 := mload(0x20)
  9435 |     |             m2 := mload(0x40)
  9436 |     |             m3 := mload(0x60)
  9437 |     |             m4 := mload(0x80)
  9438 |     |             m5 := mload(0xa0)
  9439 |     |             m6 := mload(0xc0)
  9440 |     |             // Selector of `log(uint256,string,address,address)`.
  9441 |     |             mstore(0x00, 0x6168ed61)
  9442 |     |             mstore(0x20, p0)
  9443 |     |             mstore(0x40, 0x80)
  9444 |     |             mstore(0x60, p2)
  9445 |     |             mstore(0x80, p3)
  9446 |     |             writeString(0xa0, p1)
  9447 |     |         }
  9448 |     |         _sendLogPayload(0x1c, 0xc4);
  9449 |     |         assembly {
  9450 |     |             mstore(0x00, m0)
  9451 |     |             mstore(0x20, m1)
  9452 |     |             mstore(0x40, m2)
  9453 |     |             mstore(0x60, m3)
  9454 |     |             mstore(0x80, m4)
  9455 |     |             mstore(0xa0, m5)
  9456 |     |             mstore(0xc0, m6)
  9457 |     |         }
  9458 |     |     }
  9459 |     | 
  9460 |     |     function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {
  9461 |     |         bytes32 m0;
  9462 |     |         bytes32 m1;
  9463 |     |         bytes32 m2;
  9464 |     |         bytes32 m3;
  9465 |     |         bytes32 m4;
  9466 |     |         bytes32 m5;
  9467 |     |         bytes32 m6;
  9468 |     |         assembly {
  9469 |     |             function writeString(pos, w) {
  9470 |     |                 let length := 0
  9471 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9472 |     |                 mstore(pos, length)
  9473 |     |                 let shift := sub(256, shl(3, length))
  9474 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9475 |     |             }
  9476 |     |             m0 := mload(0x00)
  9477 |     |             m1 := mload(0x20)
  9478 |     |             m2 := mload(0x40)
  9479 |     |             m3 := mload(0x60)
  9480 |     |             m4 := mload(0x80)
  9481 |     |             m5 := mload(0xa0)
  9482 |     |             m6 := mload(0xc0)
  9483 |     |             // Selector of `log(uint256,string,address,bool)`.
  9484 |     |             mstore(0x00, 0x90c30a56)
  9485 |     |             mstore(0x20, p0)
  9486 |     |             mstore(0x40, 0x80)
  9487 |     |             mstore(0x60, p2)
  9488 |     |             mstore(0x80, p3)
  9489 |     |             writeString(0xa0, p1)
  9490 |     |         }
  9491 |     |         _sendLogPayload(0x1c, 0xc4);
  9492 |     |         assembly {
  9493 |     |             mstore(0x00, m0)
  9494 |     |             mstore(0x20, m1)
  9495 |     |             mstore(0x40, m2)
  9496 |     |             mstore(0x60, m3)
  9497 |     |             mstore(0x80, m4)
  9498 |     |             mstore(0xa0, m5)
  9499 |     |             mstore(0xc0, m6)
  9500 |     |         }
  9501 |     |     }
  9502 |     | 
  9503 |     |     function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {
  9504 |     |         bytes32 m0;
  9505 |     |         bytes32 m1;
  9506 |     |         bytes32 m2;
  9507 |     |         bytes32 m3;
  9508 |     |         bytes32 m4;
  9509 |     |         bytes32 m5;
  9510 |     |         bytes32 m6;
  9511 |     |         assembly {
  9512 |     |             function writeString(pos, w) {
  9513 |     |                 let length := 0
  9514 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9515 |     |                 mstore(pos, length)
  9516 |     |                 let shift := sub(256, shl(3, length))
  9517 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9518 |     |             }
  9519 |     |             m0 := mload(0x00)
  9520 |     |             m1 := mload(0x20)
  9521 |     |             m2 := mload(0x40)
  9522 |     |             m3 := mload(0x60)
  9523 |     |             m4 := mload(0x80)
  9524 |     |             m5 := mload(0xa0)
  9525 |     |             m6 := mload(0xc0)
  9526 |     |             // Selector of `log(uint256,string,address,uint256)`.
  9527 |     |             mstore(0x00, 0xe8d3018d)
  9528 |     |             mstore(0x20, p0)
  9529 |     |             mstore(0x40, 0x80)
  9530 |     |             mstore(0x60, p2)
  9531 |     |             mstore(0x80, p3)
  9532 |     |             writeString(0xa0, p1)
  9533 |     |         }
  9534 |     |         _sendLogPayload(0x1c, 0xc4);
  9535 |     |         assembly {
  9536 |     |             mstore(0x00, m0)
  9537 |     |             mstore(0x20, m1)
  9538 |     |             mstore(0x40, m2)
  9539 |     |             mstore(0x60, m3)
  9540 |     |             mstore(0x80, m4)
  9541 |     |             mstore(0xa0, m5)
  9542 |     |             mstore(0xc0, m6)
  9543 |     |         }
  9544 |     |     }
  9545 |     | 
  9546 |     |     function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
  9547 |     |         bytes32 m0;
  9548 |     |         bytes32 m1;
  9549 |     |         bytes32 m2;
  9550 |     |         bytes32 m3;
  9551 |     |         bytes32 m4;
  9552 |     |         bytes32 m5;
  9553 |     |         bytes32 m6;
  9554 |     |         bytes32 m7;
  9555 |     |         bytes32 m8;
  9556 |     |         assembly {
  9557 |     |             function writeString(pos, w) {
  9558 |     |                 let length := 0
  9559 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9560 |     |                 mstore(pos, length)
  9561 |     |                 let shift := sub(256, shl(3, length))
  9562 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9563 |     |             }
  9564 |     |             m0 := mload(0x00)
  9565 |     |             m1 := mload(0x20)
  9566 |     |             m2 := mload(0x40)
  9567 |     |             m3 := mload(0x60)
  9568 |     |             m4 := mload(0x80)
  9569 |     |             m5 := mload(0xa0)
  9570 |     |             m6 := mload(0xc0)
  9571 |     |             m7 := mload(0xe0)
  9572 |     |             m8 := mload(0x100)
  9573 |     |             // Selector of `log(uint256,string,address,string)`.
  9574 |     |             mstore(0x00, 0x9c3adfa1)
  9575 |     |             mstore(0x20, p0)
  9576 |     |             mstore(0x40, 0x80)
  9577 |     |             mstore(0x60, p2)
  9578 |     |             mstore(0x80, 0xc0)
  9579 |     |             writeString(0xa0, p1)
  9580 |     |             writeString(0xe0, p3)
  9581 |     |         }
  9582 |     |         _sendLogPayload(0x1c, 0x104);
  9583 |     |         assembly {
  9584 |     |             mstore(0x00, m0)
  9585 |     |             mstore(0x20, m1)
  9586 |     |             mstore(0x40, m2)
  9587 |     |             mstore(0x60, m3)
  9588 |     |             mstore(0x80, m4)
  9589 |     |             mstore(0xa0, m5)
  9590 |     |             mstore(0xc0, m6)
  9591 |     |             mstore(0xe0, m7)
  9592 |     |             mstore(0x100, m8)
  9593 |     |         }
  9594 |     |     }
  9595 |     | 
  9596 |     |     function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {
  9597 |     |         bytes32 m0;
  9598 |     |         bytes32 m1;
  9599 |     |         bytes32 m2;
  9600 |     |         bytes32 m3;
  9601 |     |         bytes32 m4;
  9602 |     |         bytes32 m5;
  9603 |     |         bytes32 m6;
  9604 |     |         assembly {
  9605 |     |             function writeString(pos, w) {
  9606 |     |                 let length := 0
  9607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9608 |     |                 mstore(pos, length)
  9609 |     |                 let shift := sub(256, shl(3, length))
  9610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9611 |     |             }
  9612 |     |             m0 := mload(0x00)
  9613 |     |             m1 := mload(0x20)
  9614 |     |             m2 := mload(0x40)
  9615 |     |             m3 := mload(0x60)
  9616 |     |             m4 := mload(0x80)
  9617 |     |             m5 := mload(0xa0)
  9618 |     |             m6 := mload(0xc0)
  9619 |     |             // Selector of `log(uint256,string,bool,address)`.
  9620 |     |             mstore(0x00, 0xae2ec581)
  9621 |     |             mstore(0x20, p0)
  9622 |     |             mstore(0x40, 0x80)
  9623 |     |             mstore(0x60, p2)
  9624 |     |             mstore(0x80, p3)
  9625 |     |             writeString(0xa0, p1)
  9626 |     |         }
  9627 |     |         _sendLogPayload(0x1c, 0xc4);
  9628 |     |         assembly {
  9629 |     |             mstore(0x00, m0)
  9630 |     |             mstore(0x20, m1)
  9631 |     |             mstore(0x40, m2)
  9632 |     |             mstore(0x60, m3)
  9633 |     |             mstore(0x80, m4)
  9634 |     |             mstore(0xa0, m5)
  9635 |     |             mstore(0xc0, m6)
  9636 |     |         }
  9637 |     |     }
  9638 |     | 
  9639 |     |     function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {
  9640 |     |         bytes32 m0;
  9641 |     |         bytes32 m1;
  9642 |     |         bytes32 m2;
  9643 |     |         bytes32 m3;
  9644 |     |         bytes32 m4;
  9645 |     |         bytes32 m5;
  9646 |     |         bytes32 m6;
  9647 |     |         assembly {
  9648 |     |             function writeString(pos, w) {
  9649 |     |                 let length := 0
  9650 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9651 |     |                 mstore(pos, length)
  9652 |     |                 let shift := sub(256, shl(3, length))
  9653 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9654 |     |             }
  9655 |     |             m0 := mload(0x00)
  9656 |     |             m1 := mload(0x20)
  9657 |     |             m2 := mload(0x40)
  9658 |     |             m3 := mload(0x60)
  9659 |     |             m4 := mload(0x80)
  9660 |     |             m5 := mload(0xa0)
  9661 |     |             m6 := mload(0xc0)
  9662 |     |             // Selector of `log(uint256,string,bool,bool)`.
  9663 |     |             mstore(0x00, 0xba535d9c)
  9664 |     |             mstore(0x20, p0)
  9665 |     |             mstore(0x40, 0x80)
  9666 |     |             mstore(0x60, p2)
  9667 |     |             mstore(0x80, p3)
  9668 |     |             writeString(0xa0, p1)
  9669 |     |         }
  9670 |     |         _sendLogPayload(0x1c, 0xc4);
  9671 |     |         assembly {
  9672 |     |             mstore(0x00, m0)
  9673 |     |             mstore(0x20, m1)
  9674 |     |             mstore(0x40, m2)
  9675 |     |             mstore(0x60, m3)
  9676 |     |             mstore(0x80, m4)
  9677 |     |             mstore(0xa0, m5)
  9678 |     |             mstore(0xc0, m6)
  9679 |     |         }
  9680 |     |     }
  9681 |     | 
  9682 |     |     function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
  9683 |     |         bytes32 m0;
  9684 |     |         bytes32 m1;
  9685 |     |         bytes32 m2;
  9686 |     |         bytes32 m3;
  9687 |     |         bytes32 m4;
  9688 |     |         bytes32 m5;
  9689 |     |         bytes32 m6;
  9690 |     |         assembly {
  9691 |     |             function writeString(pos, w) {
  9692 |     |                 let length := 0
  9693 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9694 |     |                 mstore(pos, length)
  9695 |     |                 let shift := sub(256, shl(3, length))
  9696 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9697 |     |             }
  9698 |     |             m0 := mload(0x00)
  9699 |     |             m1 := mload(0x20)
  9700 |     |             m2 := mload(0x40)
  9701 |     |             m3 := mload(0x60)
  9702 |     |             m4 := mload(0x80)
  9703 |     |             m5 := mload(0xa0)
  9704 |     |             m6 := mload(0xc0)
  9705 |     |             // Selector of `log(uint256,string,bool,uint256)`.
  9706 |     |             mstore(0x00, 0xcf009880)
  9707 |     |             mstore(0x20, p0)
  9708 |     |             mstore(0x40, 0x80)
  9709 |     |             mstore(0x60, p2)
  9710 |     |             mstore(0x80, p3)
  9711 |     |             writeString(0xa0, p1)
  9712 |     |         }
  9713 |     |         _sendLogPayload(0x1c, 0xc4);
  9714 |     |         assembly {
  9715 |     |             mstore(0x00, m0)
  9716 |     |             mstore(0x20, m1)
  9717 |     |             mstore(0x40, m2)
  9718 |     |             mstore(0x60, m3)
  9719 |     |             mstore(0x80, m4)
  9720 |     |             mstore(0xa0, m5)
  9721 |     |             mstore(0xc0, m6)
  9722 |     |         }
  9723 |     |     }
  9724 |     | 
  9725 |     |     function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
  9726 |     |         bytes32 m0;
  9727 |     |         bytes32 m1;
  9728 |     |         bytes32 m2;
  9729 |     |         bytes32 m3;
  9730 |     |         bytes32 m4;
  9731 |     |         bytes32 m5;
  9732 |     |         bytes32 m6;
  9733 |     |         bytes32 m7;
  9734 |     |         bytes32 m8;
  9735 |     |         assembly {
  9736 |     |             function writeString(pos, w) {
  9737 |     |                 let length := 0
  9738 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9739 |     |                 mstore(pos, length)
  9740 |     |                 let shift := sub(256, shl(3, length))
  9741 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9742 |     |             }
  9743 |     |             m0 := mload(0x00)
  9744 |     |             m1 := mload(0x20)
  9745 |     |             m2 := mload(0x40)
  9746 |     |             m3 := mload(0x60)
  9747 |     |             m4 := mload(0x80)
  9748 |     |             m5 := mload(0xa0)
  9749 |     |             m6 := mload(0xc0)
  9750 |     |             m7 := mload(0xe0)
  9751 |     |             m8 := mload(0x100)
  9752 |     |             // Selector of `log(uint256,string,bool,string)`.
  9753 |     |             mstore(0x00, 0xd2d423cd)
  9754 |     |             mstore(0x20, p0)
  9755 |     |             mstore(0x40, 0x80)
  9756 |     |             mstore(0x60, p2)
  9757 |     |             mstore(0x80, 0xc0)
  9758 |     |             writeString(0xa0, p1)
  9759 |     |             writeString(0xe0, p3)
  9760 |     |         }
  9761 |     |         _sendLogPayload(0x1c, 0x104);
  9762 |     |         assembly {
  9763 |     |             mstore(0x00, m0)
  9764 |     |             mstore(0x20, m1)
  9765 |     |             mstore(0x40, m2)
  9766 |     |             mstore(0x60, m3)
  9767 |     |             mstore(0x80, m4)
  9768 |     |             mstore(0xa0, m5)
  9769 |     |             mstore(0xc0, m6)
  9770 |     |             mstore(0xe0, m7)
  9771 |     |             mstore(0x100, m8)
  9772 |     |         }
  9773 |     |     }
  9774 |     | 
  9775 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {
  9776 |     |         bytes32 m0;
  9777 |     |         bytes32 m1;
  9778 |     |         bytes32 m2;
  9779 |     |         bytes32 m3;
  9780 |     |         bytes32 m4;
  9781 |     |         bytes32 m5;
  9782 |     |         bytes32 m6;
  9783 |     |         assembly {
  9784 |     |             function writeString(pos, w) {
  9785 |     |                 let length := 0
  9786 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9787 |     |                 mstore(pos, length)
  9788 |     |                 let shift := sub(256, shl(3, length))
  9789 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9790 |     |             }
  9791 |     |             m0 := mload(0x00)
  9792 |     |             m1 := mload(0x20)
  9793 |     |             m2 := mload(0x40)
  9794 |     |             m3 := mload(0x60)
  9795 |     |             m4 := mload(0x80)
  9796 |     |             m5 := mload(0xa0)
  9797 |     |             m6 := mload(0xc0)
  9798 |     |             // Selector of `log(uint256,string,uint256,address)`.
  9799 |     |             mstore(0x00, 0x3b2279b4)
  9800 |     |             mstore(0x20, p0)
  9801 |     |             mstore(0x40, 0x80)
  9802 |     |             mstore(0x60, p2)
  9803 |     |             mstore(0x80, p3)
  9804 |     |             writeString(0xa0, p1)
  9805 |     |         }
  9806 |     |         _sendLogPayload(0x1c, 0xc4);
  9807 |     |         assembly {
  9808 |     |             mstore(0x00, m0)
  9809 |     |             mstore(0x20, m1)
  9810 |     |             mstore(0x40, m2)
  9811 |     |             mstore(0x60, m3)
  9812 |     |             mstore(0x80, m4)
  9813 |     |             mstore(0xa0, m5)
  9814 |     |             mstore(0xc0, m6)
  9815 |     |         }
  9816 |     |     }
  9817 |     | 
  9818 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
  9819 |     |         bytes32 m0;
  9820 |     |         bytes32 m1;
  9821 |     |         bytes32 m2;
  9822 |     |         bytes32 m3;
  9823 |     |         bytes32 m4;
  9824 |     |         bytes32 m5;
  9825 |     |         bytes32 m6;
  9826 |     |         assembly {
  9827 |     |             function writeString(pos, w) {
  9828 |     |                 let length := 0
  9829 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9830 |     |                 mstore(pos, length)
  9831 |     |                 let shift := sub(256, shl(3, length))
  9832 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9833 |     |             }
  9834 |     |             m0 := mload(0x00)
  9835 |     |             m1 := mload(0x20)
  9836 |     |             m2 := mload(0x40)
  9837 |     |             m3 := mload(0x60)
  9838 |     |             m4 := mload(0x80)
  9839 |     |             m5 := mload(0xa0)
  9840 |     |             m6 := mload(0xc0)
  9841 |     |             // Selector of `log(uint256,string,uint256,bool)`.
  9842 |     |             mstore(0x00, 0x691a8f74)
  9843 |     |             mstore(0x20, p0)
  9844 |     |             mstore(0x40, 0x80)
  9845 |     |             mstore(0x60, p2)
  9846 |     |             mstore(0x80, p3)
  9847 |     |             writeString(0xa0, p1)
  9848 |     |         }
  9849 |     |         _sendLogPayload(0x1c, 0xc4);
  9850 |     |         assembly {
  9851 |     |             mstore(0x00, m0)
  9852 |     |             mstore(0x20, m1)
  9853 |     |             mstore(0x40, m2)
  9854 |     |             mstore(0x60, m3)
  9855 |     |             mstore(0x80, m4)
  9856 |     |             mstore(0xa0, m5)
  9857 |     |             mstore(0xc0, m6)
  9858 |     |         }
  9859 |     |     }
  9860 |     | 
  9861 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
  9862 |     |         bytes32 m0;
  9863 |     |         bytes32 m1;
  9864 |     |         bytes32 m2;
  9865 |     |         bytes32 m3;
  9866 |     |         bytes32 m4;
  9867 |     |         bytes32 m5;
  9868 |     |         bytes32 m6;
  9869 |     |         assembly {
  9870 |     |             function writeString(pos, w) {
  9871 |     |                 let length := 0
  9872 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9873 |     |                 mstore(pos, length)
  9874 |     |                 let shift := sub(256, shl(3, length))
  9875 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9876 |     |             }
  9877 |     |             m0 := mload(0x00)
  9878 |     |             m1 := mload(0x20)
  9879 |     |             m2 := mload(0x40)
  9880 |     |             m3 := mload(0x60)
  9881 |     |             m4 := mload(0x80)
  9882 |     |             m5 := mload(0xa0)
  9883 |     |             m6 := mload(0xc0)
  9884 |     |             // Selector of `log(uint256,string,uint256,uint256)`.
  9885 |     |             mstore(0x00, 0x82c25b74)
  9886 |     |             mstore(0x20, p0)
  9887 |     |             mstore(0x40, 0x80)
  9888 |     |             mstore(0x60, p2)
  9889 |     |             mstore(0x80, p3)
  9890 |     |             writeString(0xa0, p1)
  9891 |     |         }
  9892 |     |         _sendLogPayload(0x1c, 0xc4);
  9893 |     |         assembly {
  9894 |     |             mstore(0x00, m0)
  9895 |     |             mstore(0x20, m1)
  9896 |     |             mstore(0x40, m2)
  9897 |     |             mstore(0x60, m3)
  9898 |     |             mstore(0x80, m4)
  9899 |     |             mstore(0xa0, m5)
  9900 |     |             mstore(0xc0, m6)
  9901 |     |         }
  9902 |     |     }
  9903 |     | 
  9904 |     |     function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
  9905 |     |         bytes32 m0;
  9906 |     |         bytes32 m1;
  9907 |     |         bytes32 m2;
  9908 |     |         bytes32 m3;
  9909 |     |         bytes32 m4;
  9910 |     |         bytes32 m5;
  9911 |     |         bytes32 m6;
  9912 |     |         bytes32 m7;
  9913 |     |         bytes32 m8;
  9914 |     |         assembly {
  9915 |     |             function writeString(pos, w) {
  9916 |     |                 let length := 0
  9917 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9918 |     |                 mstore(pos, length)
  9919 |     |                 let shift := sub(256, shl(3, length))
  9920 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9921 |     |             }
  9922 |     |             m0 := mload(0x00)
  9923 |     |             m1 := mload(0x20)
  9924 |     |             m2 := mload(0x40)
  9925 |     |             m3 := mload(0x60)
  9926 |     |             m4 := mload(0x80)
  9927 |     |             m5 := mload(0xa0)
  9928 |     |             m6 := mload(0xc0)
  9929 |     |             m7 := mload(0xe0)
  9930 |     |             m8 := mload(0x100)
  9931 |     |             // Selector of `log(uint256,string,uint256,string)`.
  9932 |     |             mstore(0x00, 0xb7b914ca)
  9933 |     |             mstore(0x20, p0)
  9934 |     |             mstore(0x40, 0x80)
  9935 |     |             mstore(0x60, p2)
  9936 |     |             mstore(0x80, 0xc0)
  9937 |     |             writeString(0xa0, p1)
  9938 |     |             writeString(0xe0, p3)
  9939 |     |         }
  9940 |     |         _sendLogPayload(0x1c, 0x104);
  9941 |     |         assembly {
  9942 |     |             mstore(0x00, m0)
  9943 |     |             mstore(0x20, m1)
  9944 |     |             mstore(0x40, m2)
  9945 |     |             mstore(0x60, m3)
  9946 |     |             mstore(0x80, m4)
  9947 |     |             mstore(0xa0, m5)
  9948 |     |             mstore(0xc0, m6)
  9949 |     |             mstore(0xe0, m7)
  9950 |     |             mstore(0x100, m8)
  9951 |     |         }
  9952 |     |     }
  9953 |     | 
  9954 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
  9955 |     |         bytes32 m0;
  9956 |     |         bytes32 m1;
  9957 |     |         bytes32 m2;
  9958 |     |         bytes32 m3;
  9959 |     |         bytes32 m4;
  9960 |     |         bytes32 m5;
  9961 |     |         bytes32 m6;
  9962 |     |         bytes32 m7;
  9963 |     |         bytes32 m8;
  9964 |     |         assembly {
  9965 |     |             function writeString(pos, w) {
  9966 |     |                 let length := 0
  9967 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
  9968 |     |                 mstore(pos, length)
  9969 |     |                 let shift := sub(256, shl(3, length))
  9970 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
  9971 |     |             }
  9972 |     |             m0 := mload(0x00)
  9973 |     |             m1 := mload(0x20)
  9974 |     |             m2 := mload(0x40)
  9975 |     |             m3 := mload(0x60)
  9976 |     |             m4 := mload(0x80)
  9977 |     |             m5 := mload(0xa0)
  9978 |     |             m6 := mload(0xc0)
  9979 |     |             m7 := mload(0xe0)
  9980 |     |             m8 := mload(0x100)
  9981 |     |             // Selector of `log(uint256,string,string,address)`.
  9982 |     |             mstore(0x00, 0xd583c602)
  9983 |     |             mstore(0x20, p0)
  9984 |     |             mstore(0x40, 0x80)
  9985 |     |             mstore(0x60, 0xc0)
  9986 |     |             mstore(0x80, p3)
  9987 |     |             writeString(0xa0, p1)
  9988 |     |             writeString(0xe0, p2)
  9989 |     |         }
  9990 |     |         _sendLogPayload(0x1c, 0x104);
  9991 |     |         assembly {
  9992 |     |             mstore(0x00, m0)
  9993 |     |             mstore(0x20, m1)
  9994 |     |             mstore(0x40, m2)
  9995 |     |             mstore(0x60, m3)
  9996 |     |             mstore(0x80, m4)
  9997 |     |             mstore(0xa0, m5)
  9998 |     |             mstore(0xc0, m6)
  9999 |     |             mstore(0xe0, m7)
 10000 |     |             mstore(0x100, m8)
 10001 |     |         }
 10002 |     |     }
 10003 |     | 
 10004 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 10005 |     |         bytes32 m0;
 10006 |     |         bytes32 m1;
 10007 |     |         bytes32 m2;
 10008 |     |         bytes32 m3;
 10009 |     |         bytes32 m4;
 10010 |     |         bytes32 m5;
 10011 |     |         bytes32 m6;
 10012 |     |         bytes32 m7;
 10013 |     |         bytes32 m8;
 10014 |     |         assembly {
 10015 |     |             function writeString(pos, w) {
 10016 |     |                 let length := 0
 10017 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10018 |     |                 mstore(pos, length)
 10019 |     |                 let shift := sub(256, shl(3, length))
 10020 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10021 |     |             }
 10022 |     |             m0 := mload(0x00)
 10023 |     |             m1 := mload(0x20)
 10024 |     |             m2 := mload(0x40)
 10025 |     |             m3 := mload(0x60)
 10026 |     |             m4 := mload(0x80)
 10027 |     |             m5 := mload(0xa0)
 10028 |     |             m6 := mload(0xc0)
 10029 |     |             m7 := mload(0xe0)
 10030 |     |             m8 := mload(0x100)
 10031 |     |             // Selector of `log(uint256,string,string,bool)`.
 10032 |     |             mstore(0x00, 0xb3a6b6bd)
 10033 |     |             mstore(0x20, p0)
 10034 |     |             mstore(0x40, 0x80)
 10035 |     |             mstore(0x60, 0xc0)
 10036 |     |             mstore(0x80, p3)
 10037 |     |             writeString(0xa0, p1)
 10038 |     |             writeString(0xe0, p2)
 10039 |     |         }
 10040 |     |         _sendLogPayload(0x1c, 0x104);
 10041 |     |         assembly {
 10042 |     |             mstore(0x00, m0)
 10043 |     |             mstore(0x20, m1)
 10044 |     |             mstore(0x40, m2)
 10045 |     |             mstore(0x60, m3)
 10046 |     |             mstore(0x80, m4)
 10047 |     |             mstore(0xa0, m5)
 10048 |     |             mstore(0xc0, m6)
 10049 |     |             mstore(0xe0, m7)
 10050 |     |             mstore(0x100, m8)
 10051 |     |         }
 10052 |     |     }
 10053 |     | 
 10054 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 10055 |     |         bytes32 m0;
 10056 |     |         bytes32 m1;
 10057 |     |         bytes32 m2;
 10058 |     |         bytes32 m3;
 10059 |     |         bytes32 m4;
 10060 |     |         bytes32 m5;
 10061 |     |         bytes32 m6;
 10062 |     |         bytes32 m7;
 10063 |     |         bytes32 m8;
 10064 |     |         assembly {
 10065 |     |             function writeString(pos, w) {
 10066 |     |                 let length := 0
 10067 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10068 |     |                 mstore(pos, length)
 10069 |     |                 let shift := sub(256, shl(3, length))
 10070 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10071 |     |             }
 10072 |     |             m0 := mload(0x00)
 10073 |     |             m1 := mload(0x20)
 10074 |     |             m2 := mload(0x40)
 10075 |     |             m3 := mload(0x60)
 10076 |     |             m4 := mload(0x80)
 10077 |     |             m5 := mload(0xa0)
 10078 |     |             m6 := mload(0xc0)
 10079 |     |             m7 := mload(0xe0)
 10080 |     |             m8 := mload(0x100)
 10081 |     |             // Selector of `log(uint256,string,string,uint256)`.
 10082 |     |             mstore(0x00, 0xb028c9bd)
 10083 |     |             mstore(0x20, p0)
 10084 |     |             mstore(0x40, 0x80)
 10085 |     |             mstore(0x60, 0xc0)
 10086 |     |             mstore(0x80, p3)
 10087 |     |             writeString(0xa0, p1)
 10088 |     |             writeString(0xe0, p2)
 10089 |     |         }
 10090 |     |         _sendLogPayload(0x1c, 0x104);
 10091 |     |         assembly {
 10092 |     |             mstore(0x00, m0)
 10093 |     |             mstore(0x20, m1)
 10094 |     |             mstore(0x40, m2)
 10095 |     |             mstore(0x60, m3)
 10096 |     |             mstore(0x80, m4)
 10097 |     |             mstore(0xa0, m5)
 10098 |     |             mstore(0xc0, m6)
 10099 |     |             mstore(0xe0, m7)
 10100 |     |             mstore(0x100, m8)
 10101 |     |         }
 10102 |     |     }
 10103 |     | 
 10104 |     |     function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 10105 |     |         bytes32 m0;
 10106 |     |         bytes32 m1;
 10107 |     |         bytes32 m2;
 10108 |     |         bytes32 m3;
 10109 |     |         bytes32 m4;
 10110 |     |         bytes32 m5;
 10111 |     |         bytes32 m6;
 10112 |     |         bytes32 m7;
 10113 |     |         bytes32 m8;
 10114 |     |         bytes32 m9;
 10115 |     |         bytes32 m10;
 10116 |     |         assembly {
 10117 |     |             function writeString(pos, w) {
 10118 |     |                 let length := 0
 10119 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10120 |     |                 mstore(pos, length)
 10121 |     |                 let shift := sub(256, shl(3, length))
 10122 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10123 |     |             }
 10124 |     |             m0 := mload(0x00)
 10125 |     |             m1 := mload(0x20)
 10126 |     |             m2 := mload(0x40)
 10127 |     |             m3 := mload(0x60)
 10128 |     |             m4 := mload(0x80)
 10129 |     |             m5 := mload(0xa0)
 10130 |     |             m6 := mload(0xc0)
 10131 |     |             m7 := mload(0xe0)
 10132 |     |             m8 := mload(0x100)
 10133 |     |             m9 := mload(0x120)
 10134 |     |             m10 := mload(0x140)
 10135 |     |             // Selector of `log(uint256,string,string,string)`.
 10136 |     |             mstore(0x00, 0x21ad0683)
 10137 |     |             mstore(0x20, p0)
 10138 |     |             mstore(0x40, 0x80)
 10139 |     |             mstore(0x60, 0xc0)
 10140 |     |             mstore(0x80, 0x100)
 10141 |     |             writeString(0xa0, p1)
 10142 |     |             writeString(0xe0, p2)
 10143 |     |             writeString(0x120, p3)
 10144 |     |         }
 10145 |     |         _sendLogPayload(0x1c, 0x144);
 10146 |     |         assembly {
 10147 |     |             mstore(0x00, m0)
 10148 |     |             mstore(0x20, m1)
 10149 |     |             mstore(0x40, m2)
 10150 |     |             mstore(0x60, m3)
 10151 |     |             mstore(0x80, m4)
 10152 |     |             mstore(0xa0, m5)
 10153 |     |             mstore(0xc0, m6)
 10154 |     |             mstore(0xe0, m7)
 10155 |     |             mstore(0x100, m8)
 10156 |     |             mstore(0x120, m9)
 10157 |     |             mstore(0x140, m10)
 10158 |     |         }
 10159 |     |     }
 10160 |     | 
 10161 |     |     function log(bytes32 p0, address p1, address p2, address p3) internal pure {
 10162 |     |         bytes32 m0;
 10163 |     |         bytes32 m1;
 10164 |     |         bytes32 m2;
 10165 |     |         bytes32 m3;
 10166 |     |         bytes32 m4;
 10167 |     |         bytes32 m5;
 10168 |     |         bytes32 m6;
 10169 |     |         assembly {
 10170 |     |             function writeString(pos, w) {
 10171 |     |                 let length := 0
 10172 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10173 |     |                 mstore(pos, length)
 10174 |     |                 let shift := sub(256, shl(3, length))
 10175 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10176 |     |             }
 10177 |     |             m0 := mload(0x00)
 10178 |     |             m1 := mload(0x20)
 10179 |     |             m2 := mload(0x40)
 10180 |     |             m3 := mload(0x60)
 10181 |     |             m4 := mload(0x80)
 10182 |     |             m5 := mload(0xa0)
 10183 |     |             m6 := mload(0xc0)
 10184 |     |             // Selector of `log(string,address,address,address)`.
 10185 |     |             mstore(0x00, 0xed8f28f6)
 10186 |     |             mstore(0x20, 0x80)
 10187 |     |             mstore(0x40, p1)
 10188 |     |             mstore(0x60, p2)
 10189 |     |             mstore(0x80, p3)
 10190 |     |             writeString(0xa0, p0)
 10191 |     |         }
 10192 |     |         _sendLogPayload(0x1c, 0xc4);
 10193 |     |         assembly {
 10194 |     |             mstore(0x00, m0)
 10195 |     |             mstore(0x20, m1)
 10196 |     |             mstore(0x40, m2)
 10197 |     |             mstore(0x60, m3)
 10198 |     |             mstore(0x80, m4)
 10199 |     |             mstore(0xa0, m5)
 10200 |     |             mstore(0xc0, m6)
 10201 |     |         }
 10202 |     |     }
 10203 |     | 
 10204 |     |     function log(bytes32 p0, address p1, address p2, bool p3) internal pure {
 10205 |     |         bytes32 m0;
 10206 |     |         bytes32 m1;
 10207 |     |         bytes32 m2;
 10208 |     |         bytes32 m3;
 10209 |     |         bytes32 m4;
 10210 |     |         bytes32 m5;
 10211 |     |         bytes32 m6;
 10212 |     |         assembly {
 10213 |     |             function writeString(pos, w) {
 10214 |     |                 let length := 0
 10215 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10216 |     |                 mstore(pos, length)
 10217 |     |                 let shift := sub(256, shl(3, length))
 10218 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10219 |     |             }
 10220 |     |             m0 := mload(0x00)
 10221 |     |             m1 := mload(0x20)
 10222 |     |             m2 := mload(0x40)
 10223 |     |             m3 := mload(0x60)
 10224 |     |             m4 := mload(0x80)
 10225 |     |             m5 := mload(0xa0)
 10226 |     |             m6 := mload(0xc0)
 10227 |     |             // Selector of `log(string,address,address,bool)`.
 10228 |     |             mstore(0x00, 0xb59dbd60)
 10229 |     |             mstore(0x20, 0x80)
 10230 |     |             mstore(0x40, p1)
 10231 |     |             mstore(0x60, p2)
 10232 |     |             mstore(0x80, p3)
 10233 |     |             writeString(0xa0, p0)
 10234 |     |         }
 10235 |     |         _sendLogPayload(0x1c, 0xc4);
 10236 |     |         assembly {
 10237 |     |             mstore(0x00, m0)
 10238 |     |             mstore(0x20, m1)
 10239 |     |             mstore(0x40, m2)
 10240 |     |             mstore(0x60, m3)
 10241 |     |             mstore(0x80, m4)
 10242 |     |             mstore(0xa0, m5)
 10243 |     |             mstore(0xc0, m6)
 10244 |     |         }
 10245 |     |     }
 10246 |     | 
 10247 |     |     function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {
 10248 |     |         bytes32 m0;
 10249 |     |         bytes32 m1;
 10250 |     |         bytes32 m2;
 10251 |     |         bytes32 m3;
 10252 |     |         bytes32 m4;
 10253 |     |         bytes32 m5;
 10254 |     |         bytes32 m6;
 10255 |     |         assembly {
 10256 |     |             function writeString(pos, w) {
 10257 |     |                 let length := 0
 10258 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10259 |     |                 mstore(pos, length)
 10260 |     |                 let shift := sub(256, shl(3, length))
 10261 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10262 |     |             }
 10263 |     |             m0 := mload(0x00)
 10264 |     |             m1 := mload(0x20)
 10265 |     |             m2 := mload(0x40)
 10266 |     |             m3 := mload(0x60)
 10267 |     |             m4 := mload(0x80)
 10268 |     |             m5 := mload(0xa0)
 10269 |     |             m6 := mload(0xc0)
 10270 |     |             // Selector of `log(string,address,address,uint256)`.
 10271 |     |             mstore(0x00, 0x8ef3f399)
 10272 |     |             mstore(0x20, 0x80)
 10273 |     |             mstore(0x40, p1)
 10274 |     |             mstore(0x60, p2)
 10275 |     |             mstore(0x80, p3)
 10276 |     |             writeString(0xa0, p0)
 10277 |     |         }
 10278 |     |         _sendLogPayload(0x1c, 0xc4);
 10279 |     |         assembly {
 10280 |     |             mstore(0x00, m0)
 10281 |     |             mstore(0x20, m1)
 10282 |     |             mstore(0x40, m2)
 10283 |     |             mstore(0x60, m3)
 10284 |     |             mstore(0x80, m4)
 10285 |     |             mstore(0xa0, m5)
 10286 |     |             mstore(0xc0, m6)
 10287 |     |         }
 10288 |     |     }
 10289 |     | 
 10290 |     |     function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {
 10291 |     |         bytes32 m0;
 10292 |     |         bytes32 m1;
 10293 |     |         bytes32 m2;
 10294 |     |         bytes32 m3;
 10295 |     |         bytes32 m4;
 10296 |     |         bytes32 m5;
 10297 |     |         bytes32 m6;
 10298 |     |         bytes32 m7;
 10299 |     |         bytes32 m8;
 10300 |     |         assembly {
 10301 |     |             function writeString(pos, w) {
 10302 |     |                 let length := 0
 10303 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10304 |     |                 mstore(pos, length)
 10305 |     |                 let shift := sub(256, shl(3, length))
 10306 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10307 |     |             }
 10308 |     |             m0 := mload(0x00)
 10309 |     |             m1 := mload(0x20)
 10310 |     |             m2 := mload(0x40)
 10311 |     |             m3 := mload(0x60)
 10312 |     |             m4 := mload(0x80)
 10313 |     |             m5 := mload(0xa0)
 10314 |     |             m6 := mload(0xc0)
 10315 |     |             m7 := mload(0xe0)
 10316 |     |             m8 := mload(0x100)
 10317 |     |             // Selector of `log(string,address,address,string)`.
 10318 |     |             mstore(0x00, 0x800a1c67)
 10319 |     |             mstore(0x20, 0x80)
 10320 |     |             mstore(0x40, p1)
 10321 |     |             mstore(0x60, p2)
 10322 |     |             mstore(0x80, 0xc0)
 10323 |     |             writeString(0xa0, p0)
 10324 |     |             writeString(0xe0, p3)
 10325 |     |         }
 10326 |     |         _sendLogPayload(0x1c, 0x104);
 10327 |     |         assembly {
 10328 |     |             mstore(0x00, m0)
 10329 |     |             mstore(0x20, m1)
 10330 |     |             mstore(0x40, m2)
 10331 |     |             mstore(0x60, m3)
 10332 |     |             mstore(0x80, m4)
 10333 |     |             mstore(0xa0, m5)
 10334 |     |             mstore(0xc0, m6)
 10335 |     |             mstore(0xe0, m7)
 10336 |     |             mstore(0x100, m8)
 10337 |     |         }
 10338 |     |     }
 10339 |     | 
 10340 |     |     function log(bytes32 p0, address p1, bool p2, address p3) internal pure {
 10341 |     |         bytes32 m0;
 10342 |     |         bytes32 m1;
 10343 |     |         bytes32 m2;
 10344 |     |         bytes32 m3;
 10345 |     |         bytes32 m4;
 10346 |     |         bytes32 m5;
 10347 |     |         bytes32 m6;
 10348 |     |         assembly {
 10349 |     |             function writeString(pos, w) {
 10350 |     |                 let length := 0
 10351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10352 |     |                 mstore(pos, length)
 10353 |     |                 let shift := sub(256, shl(3, length))
 10354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10355 |     |             }
 10356 |     |             m0 := mload(0x00)
 10357 |     |             m1 := mload(0x20)
 10358 |     |             m2 := mload(0x40)
 10359 |     |             m3 := mload(0x60)
 10360 |     |             m4 := mload(0x80)
 10361 |     |             m5 := mload(0xa0)
 10362 |     |             m6 := mload(0xc0)
 10363 |     |             // Selector of `log(string,address,bool,address)`.
 10364 |     |             mstore(0x00, 0x223603bd)
 10365 |     |             mstore(0x20, 0x80)
 10366 |     |             mstore(0x40, p1)
 10367 |     |             mstore(0x60, p2)
 10368 |     |             mstore(0x80, p3)
 10369 |     |             writeString(0xa0, p0)
 10370 |     |         }
 10371 |     |         _sendLogPayload(0x1c, 0xc4);
 10372 |     |         assembly {
 10373 |     |             mstore(0x00, m0)
 10374 |     |             mstore(0x20, m1)
 10375 |     |             mstore(0x40, m2)
 10376 |     |             mstore(0x60, m3)
 10377 |     |             mstore(0x80, m4)
 10378 |     |             mstore(0xa0, m5)
 10379 |     |             mstore(0xc0, m6)
 10380 |     |         }
 10381 |     |     }
 10382 |     | 
 10383 |     |     function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {
 10384 |     |         bytes32 m0;
 10385 |     |         bytes32 m1;
 10386 |     |         bytes32 m2;
 10387 |     |         bytes32 m3;
 10388 |     |         bytes32 m4;
 10389 |     |         bytes32 m5;
 10390 |     |         bytes32 m6;
 10391 |     |         assembly {
 10392 |     |             function writeString(pos, w) {
 10393 |     |                 let length := 0
 10394 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10395 |     |                 mstore(pos, length)
 10396 |     |                 let shift := sub(256, shl(3, length))
 10397 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10398 |     |             }
 10399 |     |             m0 := mload(0x00)
 10400 |     |             m1 := mload(0x20)
 10401 |     |             m2 := mload(0x40)
 10402 |     |             m3 := mload(0x60)
 10403 |     |             m4 := mload(0x80)
 10404 |     |             m5 := mload(0xa0)
 10405 |     |             m6 := mload(0xc0)
 10406 |     |             // Selector of `log(string,address,bool,bool)`.
 10407 |     |             mstore(0x00, 0x79884c2b)
 10408 |     |             mstore(0x20, 0x80)
 10409 |     |             mstore(0x40, p1)
 10410 |     |             mstore(0x60, p2)
 10411 |     |             mstore(0x80, p3)
 10412 |     |             writeString(0xa0, p0)
 10413 |     |         }
 10414 |     |         _sendLogPayload(0x1c, 0xc4);
 10415 |     |         assembly {
 10416 |     |             mstore(0x00, m0)
 10417 |     |             mstore(0x20, m1)
 10418 |     |             mstore(0x40, m2)
 10419 |     |             mstore(0x60, m3)
 10420 |     |             mstore(0x80, m4)
 10421 |     |             mstore(0xa0, m5)
 10422 |     |             mstore(0xc0, m6)
 10423 |     |         }
 10424 |     |     }
 10425 |     | 
 10426 |     |     function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {
 10427 |     |         bytes32 m0;
 10428 |     |         bytes32 m1;
 10429 |     |         bytes32 m2;
 10430 |     |         bytes32 m3;
 10431 |     |         bytes32 m4;
 10432 |     |         bytes32 m5;
 10433 |     |         bytes32 m6;
 10434 |     |         assembly {
 10435 |     |             function writeString(pos, w) {
 10436 |     |                 let length := 0
 10437 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10438 |     |                 mstore(pos, length)
 10439 |     |                 let shift := sub(256, shl(3, length))
 10440 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10441 |     |             }
 10442 |     |             m0 := mload(0x00)
 10443 |     |             m1 := mload(0x20)
 10444 |     |             m2 := mload(0x40)
 10445 |     |             m3 := mload(0x60)
 10446 |     |             m4 := mload(0x80)
 10447 |     |             m5 := mload(0xa0)
 10448 |     |             m6 := mload(0xc0)
 10449 |     |             // Selector of `log(string,address,bool,uint256)`.
 10450 |     |             mstore(0x00, 0x3e9f866a)
 10451 |     |             mstore(0x20, 0x80)
 10452 |     |             mstore(0x40, p1)
 10453 |     |             mstore(0x60, p2)
 10454 |     |             mstore(0x80, p3)
 10455 |     |             writeString(0xa0, p0)
 10456 |     |         }
 10457 |     |         _sendLogPayload(0x1c, 0xc4);
 10458 |     |         assembly {
 10459 |     |             mstore(0x00, m0)
 10460 |     |             mstore(0x20, m1)
 10461 |     |             mstore(0x40, m2)
 10462 |     |             mstore(0x60, m3)
 10463 |     |             mstore(0x80, m4)
 10464 |     |             mstore(0xa0, m5)
 10465 |     |             mstore(0xc0, m6)
 10466 |     |         }
 10467 |     |     }
 10468 |     | 
 10469 |     |     function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {
 10470 |     |         bytes32 m0;
 10471 |     |         bytes32 m1;
 10472 |     |         bytes32 m2;
 10473 |     |         bytes32 m3;
 10474 |     |         bytes32 m4;
 10475 |     |         bytes32 m5;
 10476 |     |         bytes32 m6;
 10477 |     |         bytes32 m7;
 10478 |     |         bytes32 m8;
 10479 |     |         assembly {
 10480 |     |             function writeString(pos, w) {
 10481 |     |                 let length := 0
 10482 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10483 |     |                 mstore(pos, length)
 10484 |     |                 let shift := sub(256, shl(3, length))
 10485 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10486 |     |             }
 10487 |     |             m0 := mload(0x00)
 10488 |     |             m1 := mload(0x20)
 10489 |     |             m2 := mload(0x40)
 10490 |     |             m3 := mload(0x60)
 10491 |     |             m4 := mload(0x80)
 10492 |     |             m5 := mload(0xa0)
 10493 |     |             m6 := mload(0xc0)
 10494 |     |             m7 := mload(0xe0)
 10495 |     |             m8 := mload(0x100)
 10496 |     |             // Selector of `log(string,address,bool,string)`.
 10497 |     |             mstore(0x00, 0x0454c079)
 10498 |     |             mstore(0x20, 0x80)
 10499 |     |             mstore(0x40, p1)
 10500 |     |             mstore(0x60, p2)
 10501 |     |             mstore(0x80, 0xc0)
 10502 |     |             writeString(0xa0, p0)
 10503 |     |             writeString(0xe0, p3)
 10504 |     |         }
 10505 |     |         _sendLogPayload(0x1c, 0x104);
 10506 |     |         assembly {
 10507 |     |             mstore(0x00, m0)
 10508 |     |             mstore(0x20, m1)
 10509 |     |             mstore(0x40, m2)
 10510 |     |             mstore(0x60, m3)
 10511 |     |             mstore(0x80, m4)
 10512 |     |             mstore(0xa0, m5)
 10513 |     |             mstore(0xc0, m6)
 10514 |     |             mstore(0xe0, m7)
 10515 |     |             mstore(0x100, m8)
 10516 |     |         }
 10517 |     |     }
 10518 |     | 
 10519 |     |     function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {
 10520 |     |         bytes32 m0;
 10521 |     |         bytes32 m1;
 10522 |     |         bytes32 m2;
 10523 |     |         bytes32 m3;
 10524 |     |         bytes32 m4;
 10525 |     |         bytes32 m5;
 10526 |     |         bytes32 m6;
 10527 |     |         assembly {
 10528 |     |             function writeString(pos, w) {
 10529 |     |                 let length := 0
 10530 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10531 |     |                 mstore(pos, length)
 10532 |     |                 let shift := sub(256, shl(3, length))
 10533 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10534 |     |             }
 10535 |     |             m0 := mload(0x00)
 10536 |     |             m1 := mload(0x20)
 10537 |     |             m2 := mload(0x40)
 10538 |     |             m3 := mload(0x60)
 10539 |     |             m4 := mload(0x80)
 10540 |     |             m5 := mload(0xa0)
 10541 |     |             m6 := mload(0xc0)
 10542 |     |             // Selector of `log(string,address,uint256,address)`.
 10543 |     |             mstore(0x00, 0x63fb8bc5)
 10544 |     |             mstore(0x20, 0x80)
 10545 |     |             mstore(0x40, p1)
 10546 |     |             mstore(0x60, p2)
 10547 |     |             mstore(0x80, p3)
 10548 |     |             writeString(0xa0, p0)
 10549 |     |         }
 10550 |     |         _sendLogPayload(0x1c, 0xc4);
 10551 |     |         assembly {
 10552 |     |             mstore(0x00, m0)
 10553 |     |             mstore(0x20, m1)
 10554 |     |             mstore(0x40, m2)
 10555 |     |             mstore(0x60, m3)
 10556 |     |             mstore(0x80, m4)
 10557 |     |             mstore(0xa0, m5)
 10558 |     |             mstore(0xc0, m6)
 10559 |     |         }
 10560 |     |     }
 10561 |     | 
 10562 |     |     function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {
 10563 |     |         bytes32 m0;
 10564 |     |         bytes32 m1;
 10565 |     |         bytes32 m2;
 10566 |     |         bytes32 m3;
 10567 |     |         bytes32 m4;
 10568 |     |         bytes32 m5;
 10569 |     |         bytes32 m6;
 10570 |     |         assembly {
 10571 |     |             function writeString(pos, w) {
 10572 |     |                 let length := 0
 10573 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10574 |     |                 mstore(pos, length)
 10575 |     |                 let shift := sub(256, shl(3, length))
 10576 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10577 |     |             }
 10578 |     |             m0 := mload(0x00)
 10579 |     |             m1 := mload(0x20)
 10580 |     |             m2 := mload(0x40)
 10581 |     |             m3 := mload(0x60)
 10582 |     |             m4 := mload(0x80)
 10583 |     |             m5 := mload(0xa0)
 10584 |     |             m6 := mload(0xc0)
 10585 |     |             // Selector of `log(string,address,uint256,bool)`.
 10586 |     |             mstore(0x00, 0xfc4845f0)
 10587 |     |             mstore(0x20, 0x80)
 10588 |     |             mstore(0x40, p1)
 10589 |     |             mstore(0x60, p2)
 10590 |     |             mstore(0x80, p3)
 10591 |     |             writeString(0xa0, p0)
 10592 |     |         }
 10593 |     |         _sendLogPayload(0x1c, 0xc4);
 10594 |     |         assembly {
 10595 |     |             mstore(0x00, m0)
 10596 |     |             mstore(0x20, m1)
 10597 |     |             mstore(0x40, m2)
 10598 |     |             mstore(0x60, m3)
 10599 |     |             mstore(0x80, m4)
 10600 |     |             mstore(0xa0, m5)
 10601 |     |             mstore(0xc0, m6)
 10602 |     |         }
 10603 |     |     }
 10604 |     | 
 10605 |     |     function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {
 10606 |     |         bytes32 m0;
 10607 |     |         bytes32 m1;
 10608 |     |         bytes32 m2;
 10609 |     |         bytes32 m3;
 10610 |     |         bytes32 m4;
 10611 |     |         bytes32 m5;
 10612 |     |         bytes32 m6;
 10613 |     |         assembly {
 10614 |     |             function writeString(pos, w) {
 10615 |     |                 let length := 0
 10616 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10617 |     |                 mstore(pos, length)
 10618 |     |                 let shift := sub(256, shl(3, length))
 10619 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10620 |     |             }
 10621 |     |             m0 := mload(0x00)
 10622 |     |             m1 := mload(0x20)
 10623 |     |             m2 := mload(0x40)
 10624 |     |             m3 := mload(0x60)
 10625 |     |             m4 := mload(0x80)
 10626 |     |             m5 := mload(0xa0)
 10627 |     |             m6 := mload(0xc0)
 10628 |     |             // Selector of `log(string,address,uint256,uint256)`.
 10629 |     |             mstore(0x00, 0xf8f51b1e)
 10630 |     |             mstore(0x20, 0x80)
 10631 |     |             mstore(0x40, p1)
 10632 |     |             mstore(0x60, p2)
 10633 |     |             mstore(0x80, p3)
 10634 |     |             writeString(0xa0, p0)
 10635 |     |         }
 10636 |     |         _sendLogPayload(0x1c, 0xc4);
 10637 |     |         assembly {
 10638 |     |             mstore(0x00, m0)
 10639 |     |             mstore(0x20, m1)
 10640 |     |             mstore(0x40, m2)
 10641 |     |             mstore(0x60, m3)
 10642 |     |             mstore(0x80, m4)
 10643 |     |             mstore(0xa0, m5)
 10644 |     |             mstore(0xc0, m6)
 10645 |     |         }
 10646 |     |     }
 10647 |     | 
 10648 |     |     function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {
 10649 |     |         bytes32 m0;
 10650 |     |         bytes32 m1;
 10651 |     |         bytes32 m2;
 10652 |     |         bytes32 m3;
 10653 |     |         bytes32 m4;
 10654 |     |         bytes32 m5;
 10655 |     |         bytes32 m6;
 10656 |     |         bytes32 m7;
 10657 |     |         bytes32 m8;
 10658 |     |         assembly {
 10659 |     |             function writeString(pos, w) {
 10660 |     |                 let length := 0
 10661 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10662 |     |                 mstore(pos, length)
 10663 |     |                 let shift := sub(256, shl(3, length))
 10664 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10665 |     |             }
 10666 |     |             m0 := mload(0x00)
 10667 |     |             m1 := mload(0x20)
 10668 |     |             m2 := mload(0x40)
 10669 |     |             m3 := mload(0x60)
 10670 |     |             m4 := mload(0x80)
 10671 |     |             m5 := mload(0xa0)
 10672 |     |             m6 := mload(0xc0)
 10673 |     |             m7 := mload(0xe0)
 10674 |     |             m8 := mload(0x100)
 10675 |     |             // Selector of `log(string,address,uint256,string)`.
 10676 |     |             mstore(0x00, 0x5a477632)
 10677 |     |             mstore(0x20, 0x80)
 10678 |     |             mstore(0x40, p1)
 10679 |     |             mstore(0x60, p2)
 10680 |     |             mstore(0x80, 0xc0)
 10681 |     |             writeString(0xa0, p0)
 10682 |     |             writeString(0xe0, p3)
 10683 |     |         }
 10684 |     |         _sendLogPayload(0x1c, 0x104);
 10685 |     |         assembly {
 10686 |     |             mstore(0x00, m0)
 10687 |     |             mstore(0x20, m1)
 10688 |     |             mstore(0x40, m2)
 10689 |     |             mstore(0x60, m3)
 10690 |     |             mstore(0x80, m4)
 10691 |     |             mstore(0xa0, m5)
 10692 |     |             mstore(0xc0, m6)
 10693 |     |             mstore(0xe0, m7)
 10694 |     |             mstore(0x100, m8)
 10695 |     |         }
 10696 |     |     }
 10697 |     | 
 10698 |     |     function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {
 10699 |     |         bytes32 m0;
 10700 |     |         bytes32 m1;
 10701 |     |         bytes32 m2;
 10702 |     |         bytes32 m3;
 10703 |     |         bytes32 m4;
 10704 |     |         bytes32 m5;
 10705 |     |         bytes32 m6;
 10706 |     |         bytes32 m7;
 10707 |     |         bytes32 m8;
 10708 |     |         assembly {
 10709 |     |             function writeString(pos, w) {
 10710 |     |                 let length := 0
 10711 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10712 |     |                 mstore(pos, length)
 10713 |     |                 let shift := sub(256, shl(3, length))
 10714 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10715 |     |             }
 10716 |     |             m0 := mload(0x00)
 10717 |     |             m1 := mload(0x20)
 10718 |     |             m2 := mload(0x40)
 10719 |     |             m3 := mload(0x60)
 10720 |     |             m4 := mload(0x80)
 10721 |     |             m5 := mload(0xa0)
 10722 |     |             m6 := mload(0xc0)
 10723 |     |             m7 := mload(0xe0)
 10724 |     |             m8 := mload(0x100)
 10725 |     |             // Selector of `log(string,address,string,address)`.
 10726 |     |             mstore(0x00, 0xaabc9a31)
 10727 |     |             mstore(0x20, 0x80)
 10728 |     |             mstore(0x40, p1)
 10729 |     |             mstore(0x60, 0xc0)
 10730 |     |             mstore(0x80, p3)
 10731 |     |             writeString(0xa0, p0)
 10732 |     |             writeString(0xe0, p2)
 10733 |     |         }
 10734 |     |         _sendLogPayload(0x1c, 0x104);
 10735 |     |         assembly {
 10736 |     |             mstore(0x00, m0)
 10737 |     |             mstore(0x20, m1)
 10738 |     |             mstore(0x40, m2)
 10739 |     |             mstore(0x60, m3)
 10740 |     |             mstore(0x80, m4)
 10741 |     |             mstore(0xa0, m5)
 10742 |     |             mstore(0xc0, m6)
 10743 |     |             mstore(0xe0, m7)
 10744 |     |             mstore(0x100, m8)
 10745 |     |         }
 10746 |     |     }
 10747 |     | 
 10748 |     |     function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {
 10749 |     |         bytes32 m0;
 10750 |     |         bytes32 m1;
 10751 |     |         bytes32 m2;
 10752 |     |         bytes32 m3;
 10753 |     |         bytes32 m4;
 10754 |     |         bytes32 m5;
 10755 |     |         bytes32 m6;
 10756 |     |         bytes32 m7;
 10757 |     |         bytes32 m8;
 10758 |     |         assembly {
 10759 |     |             function writeString(pos, w) {
 10760 |     |                 let length := 0
 10761 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10762 |     |                 mstore(pos, length)
 10763 |     |                 let shift := sub(256, shl(3, length))
 10764 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10765 |     |             }
 10766 |     |             m0 := mload(0x00)
 10767 |     |             m1 := mload(0x20)
 10768 |     |             m2 := mload(0x40)
 10769 |     |             m3 := mload(0x60)
 10770 |     |             m4 := mload(0x80)
 10771 |     |             m5 := mload(0xa0)
 10772 |     |             m6 := mload(0xc0)
 10773 |     |             m7 := mload(0xe0)
 10774 |     |             m8 := mload(0x100)
 10775 |     |             // Selector of `log(string,address,string,bool)`.
 10776 |     |             mstore(0x00, 0x5f15d28c)
 10777 |     |             mstore(0x20, 0x80)
 10778 |     |             mstore(0x40, p1)
 10779 |     |             mstore(0x60, 0xc0)
 10780 |     |             mstore(0x80, p3)
 10781 |     |             writeString(0xa0, p0)
 10782 |     |             writeString(0xe0, p2)
 10783 |     |         }
 10784 |     |         _sendLogPayload(0x1c, 0x104);
 10785 |     |         assembly {
 10786 |     |             mstore(0x00, m0)
 10787 |     |             mstore(0x20, m1)
 10788 |     |             mstore(0x40, m2)
 10789 |     |             mstore(0x60, m3)
 10790 |     |             mstore(0x80, m4)
 10791 |     |             mstore(0xa0, m5)
 10792 |     |             mstore(0xc0, m6)
 10793 |     |             mstore(0xe0, m7)
 10794 |     |             mstore(0x100, m8)
 10795 |     |         }
 10796 |     |     }
 10797 |     | 
 10798 |     |     function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {
 10799 |     |         bytes32 m0;
 10800 |     |         bytes32 m1;
 10801 |     |         bytes32 m2;
 10802 |     |         bytes32 m3;
 10803 |     |         bytes32 m4;
 10804 |     |         bytes32 m5;
 10805 |     |         bytes32 m6;
 10806 |     |         bytes32 m7;
 10807 |     |         bytes32 m8;
 10808 |     |         assembly {
 10809 |     |             function writeString(pos, w) {
 10810 |     |                 let length := 0
 10811 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10812 |     |                 mstore(pos, length)
 10813 |     |                 let shift := sub(256, shl(3, length))
 10814 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10815 |     |             }
 10816 |     |             m0 := mload(0x00)
 10817 |     |             m1 := mload(0x20)
 10818 |     |             m2 := mload(0x40)
 10819 |     |             m3 := mload(0x60)
 10820 |     |             m4 := mload(0x80)
 10821 |     |             m5 := mload(0xa0)
 10822 |     |             m6 := mload(0xc0)
 10823 |     |             m7 := mload(0xe0)
 10824 |     |             m8 := mload(0x100)
 10825 |     |             // Selector of `log(string,address,string,uint256)`.
 10826 |     |             mstore(0x00, 0x91d1112e)
 10827 |     |             mstore(0x20, 0x80)
 10828 |     |             mstore(0x40, p1)
 10829 |     |             mstore(0x60, 0xc0)
 10830 |     |             mstore(0x80, p3)
 10831 |     |             writeString(0xa0, p0)
 10832 |     |             writeString(0xe0, p2)
 10833 |     |         }
 10834 |     |         _sendLogPayload(0x1c, 0x104);
 10835 |     |         assembly {
 10836 |     |             mstore(0x00, m0)
 10837 |     |             mstore(0x20, m1)
 10838 |     |             mstore(0x40, m2)
 10839 |     |             mstore(0x60, m3)
 10840 |     |             mstore(0x80, m4)
 10841 |     |             mstore(0xa0, m5)
 10842 |     |             mstore(0xc0, m6)
 10843 |     |             mstore(0xe0, m7)
 10844 |     |             mstore(0x100, m8)
 10845 |     |         }
 10846 |     |     }
 10847 |     | 
 10848 |     |     function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {
 10849 |     |         bytes32 m0;
 10850 |     |         bytes32 m1;
 10851 |     |         bytes32 m2;
 10852 |     |         bytes32 m3;
 10853 |     |         bytes32 m4;
 10854 |     |         bytes32 m5;
 10855 |     |         bytes32 m6;
 10856 |     |         bytes32 m7;
 10857 |     |         bytes32 m8;
 10858 |     |         bytes32 m9;
 10859 |     |         bytes32 m10;
 10860 |     |         assembly {
 10861 |     |             function writeString(pos, w) {
 10862 |     |                 let length := 0
 10863 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10864 |     |                 mstore(pos, length)
 10865 |     |                 let shift := sub(256, shl(3, length))
 10866 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10867 |     |             }
 10868 |     |             m0 := mload(0x00)
 10869 |     |             m1 := mload(0x20)
 10870 |     |             m2 := mload(0x40)
 10871 |     |             m3 := mload(0x60)
 10872 |     |             m4 := mload(0x80)
 10873 |     |             m5 := mload(0xa0)
 10874 |     |             m6 := mload(0xc0)
 10875 |     |             m7 := mload(0xe0)
 10876 |     |             m8 := mload(0x100)
 10877 |     |             m9 := mload(0x120)
 10878 |     |             m10 := mload(0x140)
 10879 |     |             // Selector of `log(string,address,string,string)`.
 10880 |     |             mstore(0x00, 0x245986f2)
 10881 |     |             mstore(0x20, 0x80)
 10882 |     |             mstore(0x40, p1)
 10883 |     |             mstore(0x60, 0xc0)
 10884 |     |             mstore(0x80, 0x100)
 10885 |     |             writeString(0xa0, p0)
 10886 |     |             writeString(0xe0, p2)
 10887 |     |             writeString(0x120, p3)
 10888 |     |         }
 10889 |     |         _sendLogPayload(0x1c, 0x144);
 10890 |     |         assembly {
 10891 |     |             mstore(0x00, m0)
 10892 |     |             mstore(0x20, m1)
 10893 |     |             mstore(0x40, m2)
 10894 |     |             mstore(0x60, m3)
 10895 |     |             mstore(0x80, m4)
 10896 |     |             mstore(0xa0, m5)
 10897 |     |             mstore(0xc0, m6)
 10898 |     |             mstore(0xe0, m7)
 10899 |     |             mstore(0x100, m8)
 10900 |     |             mstore(0x120, m9)
 10901 |     |             mstore(0x140, m10)
 10902 |     |         }
 10903 |     |     }
 10904 |     | 
 10905 |     |     function log(bytes32 p0, bool p1, address p2, address p3) internal pure {
 10906 |     |         bytes32 m0;
 10907 |     |         bytes32 m1;
 10908 |     |         bytes32 m2;
 10909 |     |         bytes32 m3;
 10910 |     |         bytes32 m4;
 10911 |     |         bytes32 m5;
 10912 |     |         bytes32 m6;
 10913 |     |         assembly {
 10914 |     |             function writeString(pos, w) {
 10915 |     |                 let length := 0
 10916 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10917 |     |                 mstore(pos, length)
 10918 |     |                 let shift := sub(256, shl(3, length))
 10919 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10920 |     |             }
 10921 |     |             m0 := mload(0x00)
 10922 |     |             m1 := mload(0x20)
 10923 |     |             m2 := mload(0x40)
 10924 |     |             m3 := mload(0x60)
 10925 |     |             m4 := mload(0x80)
 10926 |     |             m5 := mload(0xa0)
 10927 |     |             m6 := mload(0xc0)
 10928 |     |             // Selector of `log(string,bool,address,address)`.
 10929 |     |             mstore(0x00, 0x33e9dd1d)
 10930 |     |             mstore(0x20, 0x80)
 10931 |     |             mstore(0x40, p1)
 10932 |     |             mstore(0x60, p2)
 10933 |     |             mstore(0x80, p3)
 10934 |     |             writeString(0xa0, p0)
 10935 |     |         }
 10936 |     |         _sendLogPayload(0x1c, 0xc4);
 10937 |     |         assembly {
 10938 |     |             mstore(0x00, m0)
 10939 |     |             mstore(0x20, m1)
 10940 |     |             mstore(0x40, m2)
 10941 |     |             mstore(0x60, m3)
 10942 |     |             mstore(0x80, m4)
 10943 |     |             mstore(0xa0, m5)
 10944 |     |             mstore(0xc0, m6)
 10945 |     |         }
 10946 |     |     }
 10947 |     | 
 10948 |     |     function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {
 10949 |     |         bytes32 m0;
 10950 |     |         bytes32 m1;
 10951 |     |         bytes32 m2;
 10952 |     |         bytes32 m3;
 10953 |     |         bytes32 m4;
 10954 |     |         bytes32 m5;
 10955 |     |         bytes32 m6;
 10956 |     |         assembly {
 10957 |     |             function writeString(pos, w) {
 10958 |     |                 let length := 0
 10959 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 10960 |     |                 mstore(pos, length)
 10961 |     |                 let shift := sub(256, shl(3, length))
 10962 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 10963 |     |             }
 10964 |     |             m0 := mload(0x00)
 10965 |     |             m1 := mload(0x20)
 10966 |     |             m2 := mload(0x40)
 10967 |     |             m3 := mload(0x60)
 10968 |     |             m4 := mload(0x80)
 10969 |     |             m5 := mload(0xa0)
 10970 |     |             m6 := mload(0xc0)
 10971 |     |             // Selector of `log(string,bool,address,bool)`.
 10972 |     |             mstore(0x00, 0x958c28c6)
 10973 |     |             mstore(0x20, 0x80)
 10974 |     |             mstore(0x40, p1)
 10975 |     |             mstore(0x60, p2)
 10976 |     |             mstore(0x80, p3)
 10977 |     |             writeString(0xa0, p0)
 10978 |     |         }
 10979 |     |         _sendLogPayload(0x1c, 0xc4);
 10980 |     |         assembly {
 10981 |     |             mstore(0x00, m0)
 10982 |     |             mstore(0x20, m1)
 10983 |     |             mstore(0x40, m2)
 10984 |     |             mstore(0x60, m3)
 10985 |     |             mstore(0x80, m4)
 10986 |     |             mstore(0xa0, m5)
 10987 |     |             mstore(0xc0, m6)
 10988 |     |         }
 10989 |     |     }
 10990 |     | 
 10991 |     |     function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {
 10992 |     |         bytes32 m0;
 10993 |     |         bytes32 m1;
 10994 |     |         bytes32 m2;
 10995 |     |         bytes32 m3;
 10996 |     |         bytes32 m4;
 10997 |     |         bytes32 m5;
 10998 |     |         bytes32 m6;
 10999 |     |         assembly {
 11000 |     |             function writeString(pos, w) {
 11001 |     |                 let length := 0
 11002 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11003 |     |                 mstore(pos, length)
 11004 |     |                 let shift := sub(256, shl(3, length))
 11005 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11006 |     |             }
 11007 |     |             m0 := mload(0x00)
 11008 |     |             m1 := mload(0x20)
 11009 |     |             m2 := mload(0x40)
 11010 |     |             m3 := mload(0x60)
 11011 |     |             m4 := mload(0x80)
 11012 |     |             m5 := mload(0xa0)
 11013 |     |             m6 := mload(0xc0)
 11014 |     |             // Selector of `log(string,bool,address,uint256)`.
 11015 |     |             mstore(0x00, 0x5d08bb05)
 11016 |     |             mstore(0x20, 0x80)
 11017 |     |             mstore(0x40, p1)
 11018 |     |             mstore(0x60, p2)
 11019 |     |             mstore(0x80, p3)
 11020 |     |             writeString(0xa0, p0)
 11021 |     |         }
 11022 |     |         _sendLogPayload(0x1c, 0xc4);
 11023 |     |         assembly {
 11024 |     |             mstore(0x00, m0)
 11025 |     |             mstore(0x20, m1)
 11026 |     |             mstore(0x40, m2)
 11027 |     |             mstore(0x60, m3)
 11028 |     |             mstore(0x80, m4)
 11029 |     |             mstore(0xa0, m5)
 11030 |     |             mstore(0xc0, m6)
 11031 |     |         }
 11032 |     |     }
 11033 |     | 
 11034 |     |     function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {
 11035 |     |         bytes32 m0;
 11036 |     |         bytes32 m1;
 11037 |     |         bytes32 m2;
 11038 |     |         bytes32 m3;
 11039 |     |         bytes32 m4;
 11040 |     |         bytes32 m5;
 11041 |     |         bytes32 m6;
 11042 |     |         bytes32 m7;
 11043 |     |         bytes32 m8;
 11044 |     |         assembly {
 11045 |     |             function writeString(pos, w) {
 11046 |     |                 let length := 0
 11047 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11048 |     |                 mstore(pos, length)
 11049 |     |                 let shift := sub(256, shl(3, length))
 11050 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11051 |     |             }
 11052 |     |             m0 := mload(0x00)
 11053 |     |             m1 := mload(0x20)
 11054 |     |             m2 := mload(0x40)
 11055 |     |             m3 := mload(0x60)
 11056 |     |             m4 := mload(0x80)
 11057 |     |             m5 := mload(0xa0)
 11058 |     |             m6 := mload(0xc0)
 11059 |     |             m7 := mload(0xe0)
 11060 |     |             m8 := mload(0x100)
 11061 |     |             // Selector of `log(string,bool,address,string)`.
 11062 |     |             mstore(0x00, 0x2d8e33a4)
 11063 |     |             mstore(0x20, 0x80)
 11064 |     |             mstore(0x40, p1)
 11065 |     |             mstore(0x60, p2)
 11066 |     |             mstore(0x80, 0xc0)
 11067 |     |             writeString(0xa0, p0)
 11068 |     |             writeString(0xe0, p3)
 11069 |     |         }
 11070 |     |         _sendLogPayload(0x1c, 0x104);
 11071 |     |         assembly {
 11072 |     |             mstore(0x00, m0)
 11073 |     |             mstore(0x20, m1)
 11074 |     |             mstore(0x40, m2)
 11075 |     |             mstore(0x60, m3)
 11076 |     |             mstore(0x80, m4)
 11077 |     |             mstore(0xa0, m5)
 11078 |     |             mstore(0xc0, m6)
 11079 |     |             mstore(0xe0, m7)
 11080 |     |             mstore(0x100, m8)
 11081 |     |         }
 11082 |     |     }
 11083 |     | 
 11084 |     |     function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {
 11085 |     |         bytes32 m0;
 11086 |     |         bytes32 m1;
 11087 |     |         bytes32 m2;
 11088 |     |         bytes32 m3;
 11089 |     |         bytes32 m4;
 11090 |     |         bytes32 m5;
 11091 |     |         bytes32 m6;
 11092 |     |         assembly {
 11093 |     |             function writeString(pos, w) {
 11094 |     |                 let length := 0
 11095 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11096 |     |                 mstore(pos, length)
 11097 |     |                 let shift := sub(256, shl(3, length))
 11098 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11099 |     |             }
 11100 |     |             m0 := mload(0x00)
 11101 |     |             m1 := mload(0x20)
 11102 |     |             m2 := mload(0x40)
 11103 |     |             m3 := mload(0x60)
 11104 |     |             m4 := mload(0x80)
 11105 |     |             m5 := mload(0xa0)
 11106 |     |             m6 := mload(0xc0)
 11107 |     |             // Selector of `log(string,bool,bool,address)`.
 11108 |     |             mstore(0x00, 0x7190a529)
 11109 |     |             mstore(0x20, 0x80)
 11110 |     |             mstore(0x40, p1)
 11111 |     |             mstore(0x60, p2)
 11112 |     |             mstore(0x80, p3)
 11113 |     |             writeString(0xa0, p0)
 11114 |     |         }
 11115 |     |         _sendLogPayload(0x1c, 0xc4);
 11116 |     |         assembly {
 11117 |     |             mstore(0x00, m0)
 11118 |     |             mstore(0x20, m1)
 11119 |     |             mstore(0x40, m2)
 11120 |     |             mstore(0x60, m3)
 11121 |     |             mstore(0x80, m4)
 11122 |     |             mstore(0xa0, m5)
 11123 |     |             mstore(0xc0, m6)
 11124 |     |         }
 11125 |     |     }
 11126 |     | 
 11127 |     |     function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {
 11128 |     |         bytes32 m0;
 11129 |     |         bytes32 m1;
 11130 |     |         bytes32 m2;
 11131 |     |         bytes32 m3;
 11132 |     |         bytes32 m4;
 11133 |     |         bytes32 m5;
 11134 |     |         bytes32 m6;
 11135 |     |         assembly {
 11136 |     |             function writeString(pos, w) {
 11137 |     |                 let length := 0
 11138 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11139 |     |                 mstore(pos, length)
 11140 |     |                 let shift := sub(256, shl(3, length))
 11141 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11142 |     |             }
 11143 |     |             m0 := mload(0x00)
 11144 |     |             m1 := mload(0x20)
 11145 |     |             m2 := mload(0x40)
 11146 |     |             m3 := mload(0x60)
 11147 |     |             m4 := mload(0x80)
 11148 |     |             m5 := mload(0xa0)
 11149 |     |             m6 := mload(0xc0)
 11150 |     |             // Selector of `log(string,bool,bool,bool)`.
 11151 |     |             mstore(0x00, 0x895af8c5)
 11152 |     |             mstore(0x20, 0x80)
 11153 |     |             mstore(0x40, p1)
 11154 |     |             mstore(0x60, p2)
 11155 |     |             mstore(0x80, p3)
 11156 |     |             writeString(0xa0, p0)
 11157 |     |         }
 11158 |     |         _sendLogPayload(0x1c, 0xc4);
 11159 |     |         assembly {
 11160 |     |             mstore(0x00, m0)
 11161 |     |             mstore(0x20, m1)
 11162 |     |             mstore(0x40, m2)
 11163 |     |             mstore(0x60, m3)
 11164 |     |             mstore(0x80, m4)
 11165 |     |             mstore(0xa0, m5)
 11166 |     |             mstore(0xc0, m6)
 11167 |     |         }
 11168 |     |     }
 11169 |     | 
 11170 |     |     function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {
 11171 |     |         bytes32 m0;
 11172 |     |         bytes32 m1;
 11173 |     |         bytes32 m2;
 11174 |     |         bytes32 m3;
 11175 |     |         bytes32 m4;
 11176 |     |         bytes32 m5;
 11177 |     |         bytes32 m6;
 11178 |     |         assembly {
 11179 |     |             function writeString(pos, w) {
 11180 |     |                 let length := 0
 11181 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11182 |     |                 mstore(pos, length)
 11183 |     |                 let shift := sub(256, shl(3, length))
 11184 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11185 |     |             }
 11186 |     |             m0 := mload(0x00)
 11187 |     |             m1 := mload(0x20)
 11188 |     |             m2 := mload(0x40)
 11189 |     |             m3 := mload(0x60)
 11190 |     |             m4 := mload(0x80)
 11191 |     |             m5 := mload(0xa0)
 11192 |     |             m6 := mload(0xc0)
 11193 |     |             // Selector of `log(string,bool,bool,uint256)`.
 11194 |     |             mstore(0x00, 0x8e3f78a9)
 11195 |     |             mstore(0x20, 0x80)
 11196 |     |             mstore(0x40, p1)
 11197 |     |             mstore(0x60, p2)
 11198 |     |             mstore(0x80, p3)
 11199 |     |             writeString(0xa0, p0)
 11200 |     |         }
 11201 |     |         _sendLogPayload(0x1c, 0xc4);
 11202 |     |         assembly {
 11203 |     |             mstore(0x00, m0)
 11204 |     |             mstore(0x20, m1)
 11205 |     |             mstore(0x40, m2)
 11206 |     |             mstore(0x60, m3)
 11207 |     |             mstore(0x80, m4)
 11208 |     |             mstore(0xa0, m5)
 11209 |     |             mstore(0xc0, m6)
 11210 |     |         }
 11211 |     |     }
 11212 |     | 
 11213 |     |     function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {
 11214 |     |         bytes32 m0;
 11215 |     |         bytes32 m1;
 11216 |     |         bytes32 m2;
 11217 |     |         bytes32 m3;
 11218 |     |         bytes32 m4;
 11219 |     |         bytes32 m5;
 11220 |     |         bytes32 m6;
 11221 |     |         bytes32 m7;
 11222 |     |         bytes32 m8;
 11223 |     |         assembly {
 11224 |     |             function writeString(pos, w) {
 11225 |     |                 let length := 0
 11226 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11227 |     |                 mstore(pos, length)
 11228 |     |                 let shift := sub(256, shl(3, length))
 11229 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11230 |     |             }
 11231 |     |             m0 := mload(0x00)
 11232 |     |             m1 := mload(0x20)
 11233 |     |             m2 := mload(0x40)
 11234 |     |             m3 := mload(0x60)
 11235 |     |             m4 := mload(0x80)
 11236 |     |             m5 := mload(0xa0)
 11237 |     |             m6 := mload(0xc0)
 11238 |     |             m7 := mload(0xe0)
 11239 |     |             m8 := mload(0x100)
 11240 |     |             // Selector of `log(string,bool,bool,string)`.
 11241 |     |             mstore(0x00, 0x9d22d5dd)
 11242 |     |             mstore(0x20, 0x80)
 11243 |     |             mstore(0x40, p1)
 11244 |     |             mstore(0x60, p2)
 11245 |     |             mstore(0x80, 0xc0)
 11246 |     |             writeString(0xa0, p0)
 11247 |     |             writeString(0xe0, p3)
 11248 |     |         }
 11249 |     |         _sendLogPayload(0x1c, 0x104);
 11250 |     |         assembly {
 11251 |     |             mstore(0x00, m0)
 11252 |     |             mstore(0x20, m1)
 11253 |     |             mstore(0x40, m2)
 11254 |     |             mstore(0x60, m3)
 11255 |     |             mstore(0x80, m4)
 11256 |     |             mstore(0xa0, m5)
 11257 |     |             mstore(0xc0, m6)
 11258 |     |             mstore(0xe0, m7)
 11259 |     |             mstore(0x100, m8)
 11260 |     |         }
 11261 |     |     }
 11262 |     | 
 11263 |     |     function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {
 11264 |     |         bytes32 m0;
 11265 |     |         bytes32 m1;
 11266 |     |         bytes32 m2;
 11267 |     |         bytes32 m3;
 11268 |     |         bytes32 m4;
 11269 |     |         bytes32 m5;
 11270 |     |         bytes32 m6;
 11271 |     |         assembly {
 11272 |     |             function writeString(pos, w) {
 11273 |     |                 let length := 0
 11274 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11275 |     |                 mstore(pos, length)
 11276 |     |                 let shift := sub(256, shl(3, length))
 11277 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11278 |     |             }
 11279 |     |             m0 := mload(0x00)
 11280 |     |             m1 := mload(0x20)
 11281 |     |             m2 := mload(0x40)
 11282 |     |             m3 := mload(0x60)
 11283 |     |             m4 := mload(0x80)
 11284 |     |             m5 := mload(0xa0)
 11285 |     |             m6 := mload(0xc0)
 11286 |     |             // Selector of `log(string,bool,uint256,address)`.
 11287 |     |             mstore(0x00, 0x935e09bf)
 11288 |     |             mstore(0x20, 0x80)
 11289 |     |             mstore(0x40, p1)
 11290 |     |             mstore(0x60, p2)
 11291 |     |             mstore(0x80, p3)
 11292 |     |             writeString(0xa0, p0)
 11293 |     |         }
 11294 |     |         _sendLogPayload(0x1c, 0xc4);
 11295 |     |         assembly {
 11296 |     |             mstore(0x00, m0)
 11297 |     |             mstore(0x20, m1)
 11298 |     |             mstore(0x40, m2)
 11299 |     |             mstore(0x60, m3)
 11300 |     |             mstore(0x80, m4)
 11301 |     |             mstore(0xa0, m5)
 11302 |     |             mstore(0xc0, m6)
 11303 |     |         }
 11304 |     |     }
 11305 |     | 
 11306 |     |     function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {
 11307 |     |         bytes32 m0;
 11308 |     |         bytes32 m1;
 11309 |     |         bytes32 m2;
 11310 |     |         bytes32 m3;
 11311 |     |         bytes32 m4;
 11312 |     |         bytes32 m5;
 11313 |     |         bytes32 m6;
 11314 |     |         assembly {
 11315 |     |             function writeString(pos, w) {
 11316 |     |                 let length := 0
 11317 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11318 |     |                 mstore(pos, length)
 11319 |     |                 let shift := sub(256, shl(3, length))
 11320 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11321 |     |             }
 11322 |     |             m0 := mload(0x00)
 11323 |     |             m1 := mload(0x20)
 11324 |     |             m2 := mload(0x40)
 11325 |     |             m3 := mload(0x60)
 11326 |     |             m4 := mload(0x80)
 11327 |     |             m5 := mload(0xa0)
 11328 |     |             m6 := mload(0xc0)
 11329 |     |             // Selector of `log(string,bool,uint256,bool)`.
 11330 |     |             mstore(0x00, 0x8af7cf8a)
 11331 |     |             mstore(0x20, 0x80)
 11332 |     |             mstore(0x40, p1)
 11333 |     |             mstore(0x60, p2)
 11334 |     |             mstore(0x80, p3)
 11335 |     |             writeString(0xa0, p0)
 11336 |     |         }
 11337 |     |         _sendLogPayload(0x1c, 0xc4);
 11338 |     |         assembly {
 11339 |     |             mstore(0x00, m0)
 11340 |     |             mstore(0x20, m1)
 11341 |     |             mstore(0x40, m2)
 11342 |     |             mstore(0x60, m3)
 11343 |     |             mstore(0x80, m4)
 11344 |     |             mstore(0xa0, m5)
 11345 |     |             mstore(0xc0, m6)
 11346 |     |         }
 11347 |     |     }
 11348 |     | 
 11349 |     |     function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {
 11350 |     |         bytes32 m0;
 11351 |     |         bytes32 m1;
 11352 |     |         bytes32 m2;
 11353 |     |         bytes32 m3;
 11354 |     |         bytes32 m4;
 11355 |     |         bytes32 m5;
 11356 |     |         bytes32 m6;
 11357 |     |         assembly {
 11358 |     |             function writeString(pos, w) {
 11359 |     |                 let length := 0
 11360 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11361 |     |                 mstore(pos, length)
 11362 |     |                 let shift := sub(256, shl(3, length))
 11363 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11364 |     |             }
 11365 |     |             m0 := mload(0x00)
 11366 |     |             m1 := mload(0x20)
 11367 |     |             m2 := mload(0x40)
 11368 |     |             m3 := mload(0x60)
 11369 |     |             m4 := mload(0x80)
 11370 |     |             m5 := mload(0xa0)
 11371 |     |             m6 := mload(0xc0)
 11372 |     |             // Selector of `log(string,bool,uint256,uint256)`.
 11373 |     |             mstore(0x00, 0x64b5bb67)
 11374 |     |             mstore(0x20, 0x80)
 11375 |     |             mstore(0x40, p1)
 11376 |     |             mstore(0x60, p2)
 11377 |     |             mstore(0x80, p3)
 11378 |     |             writeString(0xa0, p0)
 11379 |     |         }
 11380 |     |         _sendLogPayload(0x1c, 0xc4);
 11381 |     |         assembly {
 11382 |     |             mstore(0x00, m0)
 11383 |     |             mstore(0x20, m1)
 11384 |     |             mstore(0x40, m2)
 11385 |     |             mstore(0x60, m3)
 11386 |     |             mstore(0x80, m4)
 11387 |     |             mstore(0xa0, m5)
 11388 |     |             mstore(0xc0, m6)
 11389 |     |         }
 11390 |     |     }
 11391 |     | 
 11392 |     |     function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {
 11393 |     |         bytes32 m0;
 11394 |     |         bytes32 m1;
 11395 |     |         bytes32 m2;
 11396 |     |         bytes32 m3;
 11397 |     |         bytes32 m4;
 11398 |     |         bytes32 m5;
 11399 |     |         bytes32 m6;
 11400 |     |         bytes32 m7;
 11401 |     |         bytes32 m8;
 11402 |     |         assembly {
 11403 |     |             function writeString(pos, w) {
 11404 |     |                 let length := 0
 11405 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11406 |     |                 mstore(pos, length)
 11407 |     |                 let shift := sub(256, shl(3, length))
 11408 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11409 |     |             }
 11410 |     |             m0 := mload(0x00)
 11411 |     |             m1 := mload(0x20)
 11412 |     |             m2 := mload(0x40)
 11413 |     |             m3 := mload(0x60)
 11414 |     |             m4 := mload(0x80)
 11415 |     |             m5 := mload(0xa0)
 11416 |     |             m6 := mload(0xc0)
 11417 |     |             m7 := mload(0xe0)
 11418 |     |             m8 := mload(0x100)
 11419 |     |             // Selector of `log(string,bool,uint256,string)`.
 11420 |     |             mstore(0x00, 0x742d6ee7)
 11421 |     |             mstore(0x20, 0x80)
 11422 |     |             mstore(0x40, p1)
 11423 |     |             mstore(0x60, p2)
 11424 |     |             mstore(0x80, 0xc0)
 11425 |     |             writeString(0xa0, p0)
 11426 |     |             writeString(0xe0, p3)
 11427 |     |         }
 11428 |     |         _sendLogPayload(0x1c, 0x104);
 11429 |     |         assembly {
 11430 |     |             mstore(0x00, m0)
 11431 |     |             mstore(0x20, m1)
 11432 |     |             mstore(0x40, m2)
 11433 |     |             mstore(0x60, m3)
 11434 |     |             mstore(0x80, m4)
 11435 |     |             mstore(0xa0, m5)
 11436 |     |             mstore(0xc0, m6)
 11437 |     |             mstore(0xe0, m7)
 11438 |     |             mstore(0x100, m8)
 11439 |     |         }
 11440 |     |     }
 11441 |     | 
 11442 |     |     function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {
 11443 |     |         bytes32 m0;
 11444 |     |         bytes32 m1;
 11445 |     |         bytes32 m2;
 11446 |     |         bytes32 m3;
 11447 |     |         bytes32 m4;
 11448 |     |         bytes32 m5;
 11449 |     |         bytes32 m6;
 11450 |     |         bytes32 m7;
 11451 |     |         bytes32 m8;
 11452 |     |         assembly {
 11453 |     |             function writeString(pos, w) {
 11454 |     |                 let length := 0
 11455 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11456 |     |                 mstore(pos, length)
 11457 |     |                 let shift := sub(256, shl(3, length))
 11458 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11459 |     |             }
 11460 |     |             m0 := mload(0x00)
 11461 |     |             m1 := mload(0x20)
 11462 |     |             m2 := mload(0x40)
 11463 |     |             m3 := mload(0x60)
 11464 |     |             m4 := mload(0x80)
 11465 |     |             m5 := mload(0xa0)
 11466 |     |             m6 := mload(0xc0)
 11467 |     |             m7 := mload(0xe0)
 11468 |     |             m8 := mload(0x100)
 11469 |     |             // Selector of `log(string,bool,string,address)`.
 11470 |     |             mstore(0x00, 0xe0625b29)
 11471 |     |             mstore(0x20, 0x80)
 11472 |     |             mstore(0x40, p1)
 11473 |     |             mstore(0x60, 0xc0)
 11474 |     |             mstore(0x80, p3)
 11475 |     |             writeString(0xa0, p0)
 11476 |     |             writeString(0xe0, p2)
 11477 |     |         }
 11478 |     |         _sendLogPayload(0x1c, 0x104);
 11479 |     |         assembly {
 11480 |     |             mstore(0x00, m0)
 11481 |     |             mstore(0x20, m1)
 11482 |     |             mstore(0x40, m2)
 11483 |     |             mstore(0x60, m3)
 11484 |     |             mstore(0x80, m4)
 11485 |     |             mstore(0xa0, m5)
 11486 |     |             mstore(0xc0, m6)
 11487 |     |             mstore(0xe0, m7)
 11488 |     |             mstore(0x100, m8)
 11489 |     |         }
 11490 |     |     }
 11491 |     | 
 11492 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {
 11493 |     |         bytes32 m0;
 11494 |     |         bytes32 m1;
 11495 |     |         bytes32 m2;
 11496 |     |         bytes32 m3;
 11497 |     |         bytes32 m4;
 11498 |     |         bytes32 m5;
 11499 |     |         bytes32 m6;
 11500 |     |         bytes32 m7;
 11501 |     |         bytes32 m8;
 11502 |     |         assembly {
 11503 |     |             function writeString(pos, w) {
 11504 |     |                 let length := 0
 11505 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11506 |     |                 mstore(pos, length)
 11507 |     |                 let shift := sub(256, shl(3, length))
 11508 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11509 |     |             }
 11510 |     |             m0 := mload(0x00)
 11511 |     |             m1 := mload(0x20)
 11512 |     |             m2 := mload(0x40)
 11513 |     |             m3 := mload(0x60)
 11514 |     |             m4 := mload(0x80)
 11515 |     |             m5 := mload(0xa0)
 11516 |     |             m6 := mload(0xc0)
 11517 |     |             m7 := mload(0xe0)
 11518 |     |             m8 := mload(0x100)
 11519 |     |             // Selector of `log(string,bool,string,bool)`.
 11520 |     |             mstore(0x00, 0x3f8a701d)
 11521 |     |             mstore(0x20, 0x80)
 11522 |     |             mstore(0x40, p1)
 11523 |     |             mstore(0x60, 0xc0)
 11524 |     |             mstore(0x80, p3)
 11525 |     |             writeString(0xa0, p0)
 11526 |     |             writeString(0xe0, p2)
 11527 |     |         }
 11528 |     |         _sendLogPayload(0x1c, 0x104);
 11529 |     |         assembly {
 11530 |     |             mstore(0x00, m0)
 11531 |     |             mstore(0x20, m1)
 11532 |     |             mstore(0x40, m2)
 11533 |     |             mstore(0x60, m3)
 11534 |     |             mstore(0x80, m4)
 11535 |     |             mstore(0xa0, m5)
 11536 |     |             mstore(0xc0, m6)
 11537 |     |             mstore(0xe0, m7)
 11538 |     |             mstore(0x100, m8)
 11539 |     |         }
 11540 |     |     }
 11541 |     | 
 11542 |     |     function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {
 11543 |     |         bytes32 m0;
 11544 |     |         bytes32 m1;
 11545 |     |         bytes32 m2;
 11546 |     |         bytes32 m3;
 11547 |     |         bytes32 m4;
 11548 |     |         bytes32 m5;
 11549 |     |         bytes32 m6;
 11550 |     |         bytes32 m7;
 11551 |     |         bytes32 m8;
 11552 |     |         assembly {
 11553 |     |             function writeString(pos, w) {
 11554 |     |                 let length := 0
 11555 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11556 |     |                 mstore(pos, length)
 11557 |     |                 let shift := sub(256, shl(3, length))
 11558 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11559 |     |             }
 11560 |     |             m0 := mload(0x00)
 11561 |     |             m1 := mload(0x20)
 11562 |     |             m2 := mload(0x40)
 11563 |     |             m3 := mload(0x60)
 11564 |     |             m4 := mload(0x80)
 11565 |     |             m5 := mload(0xa0)
 11566 |     |             m6 := mload(0xc0)
 11567 |     |             m7 := mload(0xe0)
 11568 |     |             m8 := mload(0x100)
 11569 |     |             // Selector of `log(string,bool,string,uint256)`.
 11570 |     |             mstore(0x00, 0x24f91465)
 11571 |     |             mstore(0x20, 0x80)
 11572 |     |             mstore(0x40, p1)
 11573 |     |             mstore(0x60, 0xc0)
 11574 |     |             mstore(0x80, p3)
 11575 |     |             writeString(0xa0, p0)
 11576 |     |             writeString(0xe0, p2)
 11577 |     |         }
 11578 |     |         _sendLogPayload(0x1c, 0x104);
 11579 |     |         assembly {
 11580 |     |             mstore(0x00, m0)
 11581 |     |             mstore(0x20, m1)
 11582 |     |             mstore(0x40, m2)
 11583 |     |             mstore(0x60, m3)
 11584 |     |             mstore(0x80, m4)
 11585 |     |             mstore(0xa0, m5)
 11586 |     |             mstore(0xc0, m6)
 11587 |     |             mstore(0xe0, m7)
 11588 |     |             mstore(0x100, m8)
 11589 |     |         }
 11590 |     |     }
 11591 |     | 
 11592 |     |     function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {
 11593 |     |         bytes32 m0;
 11594 |     |         bytes32 m1;
 11595 |     |         bytes32 m2;
 11596 |     |         bytes32 m3;
 11597 |     |         bytes32 m4;
 11598 |     |         bytes32 m5;
 11599 |     |         bytes32 m6;
 11600 |     |         bytes32 m7;
 11601 |     |         bytes32 m8;
 11602 |     |         bytes32 m9;
 11603 |     |         bytes32 m10;
 11604 |     |         assembly {
 11605 |     |             function writeString(pos, w) {
 11606 |     |                 let length := 0
 11607 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11608 |     |                 mstore(pos, length)
 11609 |     |                 let shift := sub(256, shl(3, length))
 11610 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11611 |     |             }
 11612 |     |             m0 := mload(0x00)
 11613 |     |             m1 := mload(0x20)
 11614 |     |             m2 := mload(0x40)
 11615 |     |             m3 := mload(0x60)
 11616 |     |             m4 := mload(0x80)
 11617 |     |             m5 := mload(0xa0)
 11618 |     |             m6 := mload(0xc0)
 11619 |     |             m7 := mload(0xe0)
 11620 |     |             m8 := mload(0x100)
 11621 |     |             m9 := mload(0x120)
 11622 |     |             m10 := mload(0x140)
 11623 |     |             // Selector of `log(string,bool,string,string)`.
 11624 |     |             mstore(0x00, 0xa826caeb)
 11625 |     |             mstore(0x20, 0x80)
 11626 |     |             mstore(0x40, p1)
 11627 |     |             mstore(0x60, 0xc0)
 11628 |     |             mstore(0x80, 0x100)
 11629 |     |             writeString(0xa0, p0)
 11630 |     |             writeString(0xe0, p2)
 11631 |     |             writeString(0x120, p3)
 11632 |     |         }
 11633 |     |         _sendLogPayload(0x1c, 0x144);
 11634 |     |         assembly {
 11635 |     |             mstore(0x00, m0)
 11636 |     |             mstore(0x20, m1)
 11637 |     |             mstore(0x40, m2)
 11638 |     |             mstore(0x60, m3)
 11639 |     |             mstore(0x80, m4)
 11640 |     |             mstore(0xa0, m5)
 11641 |     |             mstore(0xc0, m6)
 11642 |     |             mstore(0xe0, m7)
 11643 |     |             mstore(0x100, m8)
 11644 |     |             mstore(0x120, m9)
 11645 |     |             mstore(0x140, m10)
 11646 |     |         }
 11647 |     |     }
 11648 |     | 
 11649 |     |     function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {
 11650 |     |         bytes32 m0;
 11651 |     |         bytes32 m1;
 11652 |     |         bytes32 m2;
 11653 |     |         bytes32 m3;
 11654 |     |         bytes32 m4;
 11655 |     |         bytes32 m5;
 11656 |     |         bytes32 m6;
 11657 |     |         assembly {
 11658 |     |             function writeString(pos, w) {
 11659 |     |                 let length := 0
 11660 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11661 |     |                 mstore(pos, length)
 11662 |     |                 let shift := sub(256, shl(3, length))
 11663 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11664 |     |             }
 11665 |     |             m0 := mload(0x00)
 11666 |     |             m1 := mload(0x20)
 11667 |     |             m2 := mload(0x40)
 11668 |     |             m3 := mload(0x60)
 11669 |     |             m4 := mload(0x80)
 11670 |     |             m5 := mload(0xa0)
 11671 |     |             m6 := mload(0xc0)
 11672 |     |             // Selector of `log(string,uint256,address,address)`.
 11673 |     |             mstore(0x00, 0x5ea2b7ae)
 11674 |     |             mstore(0x20, 0x80)
 11675 |     |             mstore(0x40, p1)
 11676 |     |             mstore(0x60, p2)
 11677 |     |             mstore(0x80, p3)
 11678 |     |             writeString(0xa0, p0)
 11679 |     |         }
 11680 |     |         _sendLogPayload(0x1c, 0xc4);
 11681 |     |         assembly {
 11682 |     |             mstore(0x00, m0)
 11683 |     |             mstore(0x20, m1)
 11684 |     |             mstore(0x40, m2)
 11685 |     |             mstore(0x60, m3)
 11686 |     |             mstore(0x80, m4)
 11687 |     |             mstore(0xa0, m5)
 11688 |     |             mstore(0xc0, m6)
 11689 |     |         }
 11690 |     |     }
 11691 |     | 
 11692 |     |     function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {
 11693 |     |         bytes32 m0;
 11694 |     |         bytes32 m1;
 11695 |     |         bytes32 m2;
 11696 |     |         bytes32 m3;
 11697 |     |         bytes32 m4;
 11698 |     |         bytes32 m5;
 11699 |     |         bytes32 m6;
 11700 |     |         assembly {
 11701 |     |             function writeString(pos, w) {
 11702 |     |                 let length := 0
 11703 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11704 |     |                 mstore(pos, length)
 11705 |     |                 let shift := sub(256, shl(3, length))
 11706 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11707 |     |             }
 11708 |     |             m0 := mload(0x00)
 11709 |     |             m1 := mload(0x20)
 11710 |     |             m2 := mload(0x40)
 11711 |     |             m3 := mload(0x60)
 11712 |     |             m4 := mload(0x80)
 11713 |     |             m5 := mload(0xa0)
 11714 |     |             m6 := mload(0xc0)
 11715 |     |             // Selector of `log(string,uint256,address,bool)`.
 11716 |     |             mstore(0x00, 0x82112a42)
 11717 |     |             mstore(0x20, 0x80)
 11718 |     |             mstore(0x40, p1)
 11719 |     |             mstore(0x60, p2)
 11720 |     |             mstore(0x80, p3)
 11721 |     |             writeString(0xa0, p0)
 11722 |     |         }
 11723 |     |         _sendLogPayload(0x1c, 0xc4);
 11724 |     |         assembly {
 11725 |     |             mstore(0x00, m0)
 11726 |     |             mstore(0x20, m1)
 11727 |     |             mstore(0x40, m2)
 11728 |     |             mstore(0x60, m3)
 11729 |     |             mstore(0x80, m4)
 11730 |     |             mstore(0xa0, m5)
 11731 |     |             mstore(0xc0, m6)
 11732 |     |         }
 11733 |     |     }
 11734 |     | 
 11735 |     |     function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {
 11736 |     |         bytes32 m0;
 11737 |     |         bytes32 m1;
 11738 |     |         bytes32 m2;
 11739 |     |         bytes32 m3;
 11740 |     |         bytes32 m4;
 11741 |     |         bytes32 m5;
 11742 |     |         bytes32 m6;
 11743 |     |         assembly {
 11744 |     |             function writeString(pos, w) {
 11745 |     |                 let length := 0
 11746 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11747 |     |                 mstore(pos, length)
 11748 |     |                 let shift := sub(256, shl(3, length))
 11749 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11750 |     |             }
 11751 |     |             m0 := mload(0x00)
 11752 |     |             m1 := mload(0x20)
 11753 |     |             m2 := mload(0x40)
 11754 |     |             m3 := mload(0x60)
 11755 |     |             m4 := mload(0x80)
 11756 |     |             m5 := mload(0xa0)
 11757 |     |             m6 := mload(0xc0)
 11758 |     |             // Selector of `log(string,uint256,address,uint256)`.
 11759 |     |             mstore(0x00, 0x4f04fdc6)
 11760 |     |             mstore(0x20, 0x80)
 11761 |     |             mstore(0x40, p1)
 11762 |     |             mstore(0x60, p2)
 11763 |     |             mstore(0x80, p3)
 11764 |     |             writeString(0xa0, p0)
 11765 |     |         }
 11766 |     |         _sendLogPayload(0x1c, 0xc4);
 11767 |     |         assembly {
 11768 |     |             mstore(0x00, m0)
 11769 |     |             mstore(0x20, m1)
 11770 |     |             mstore(0x40, m2)
 11771 |     |             mstore(0x60, m3)
 11772 |     |             mstore(0x80, m4)
 11773 |     |             mstore(0xa0, m5)
 11774 |     |             mstore(0xc0, m6)
 11775 |     |         }
 11776 |     |     }
 11777 |     | 
 11778 |     |     function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {
 11779 |     |         bytes32 m0;
 11780 |     |         bytes32 m1;
 11781 |     |         bytes32 m2;
 11782 |     |         bytes32 m3;
 11783 |     |         bytes32 m4;
 11784 |     |         bytes32 m5;
 11785 |     |         bytes32 m6;
 11786 |     |         bytes32 m7;
 11787 |     |         bytes32 m8;
 11788 |     |         assembly {
 11789 |     |             function writeString(pos, w) {
 11790 |     |                 let length := 0
 11791 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11792 |     |                 mstore(pos, length)
 11793 |     |                 let shift := sub(256, shl(3, length))
 11794 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11795 |     |             }
 11796 |     |             m0 := mload(0x00)
 11797 |     |             m1 := mload(0x20)
 11798 |     |             m2 := mload(0x40)
 11799 |     |             m3 := mload(0x60)
 11800 |     |             m4 := mload(0x80)
 11801 |     |             m5 := mload(0xa0)
 11802 |     |             m6 := mload(0xc0)
 11803 |     |             m7 := mload(0xe0)
 11804 |     |             m8 := mload(0x100)
 11805 |     |             // Selector of `log(string,uint256,address,string)`.
 11806 |     |             mstore(0x00, 0x9ffb2f93)
 11807 |     |             mstore(0x20, 0x80)
 11808 |     |             mstore(0x40, p1)
 11809 |     |             mstore(0x60, p2)
 11810 |     |             mstore(0x80, 0xc0)
 11811 |     |             writeString(0xa0, p0)
 11812 |     |             writeString(0xe0, p3)
 11813 |     |         }
 11814 |     |         _sendLogPayload(0x1c, 0x104);
 11815 |     |         assembly {
 11816 |     |             mstore(0x00, m0)
 11817 |     |             mstore(0x20, m1)
 11818 |     |             mstore(0x40, m2)
 11819 |     |             mstore(0x60, m3)
 11820 |     |             mstore(0x80, m4)
 11821 |     |             mstore(0xa0, m5)
 11822 |     |             mstore(0xc0, m6)
 11823 |     |             mstore(0xe0, m7)
 11824 |     |             mstore(0x100, m8)
 11825 |     |         }
 11826 |     |     }
 11827 |     | 
 11828 |     |     function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {
 11829 |     |         bytes32 m0;
 11830 |     |         bytes32 m1;
 11831 |     |         bytes32 m2;
 11832 |     |         bytes32 m3;
 11833 |     |         bytes32 m4;
 11834 |     |         bytes32 m5;
 11835 |     |         bytes32 m6;
 11836 |     |         assembly {
 11837 |     |             function writeString(pos, w) {
 11838 |     |                 let length := 0
 11839 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11840 |     |                 mstore(pos, length)
 11841 |     |                 let shift := sub(256, shl(3, length))
 11842 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11843 |     |             }
 11844 |     |             m0 := mload(0x00)
 11845 |     |             m1 := mload(0x20)
 11846 |     |             m2 := mload(0x40)
 11847 |     |             m3 := mload(0x60)
 11848 |     |             m4 := mload(0x80)
 11849 |     |             m5 := mload(0xa0)
 11850 |     |             m6 := mload(0xc0)
 11851 |     |             // Selector of `log(string,uint256,bool,address)`.
 11852 |     |             mstore(0x00, 0xe0e95b98)
 11853 |     |             mstore(0x20, 0x80)
 11854 |     |             mstore(0x40, p1)
 11855 |     |             mstore(0x60, p2)
 11856 |     |             mstore(0x80, p3)
 11857 |     |             writeString(0xa0, p0)
 11858 |     |         }
 11859 |     |         _sendLogPayload(0x1c, 0xc4);
 11860 |     |         assembly {
 11861 |     |             mstore(0x00, m0)
 11862 |     |             mstore(0x20, m1)
 11863 |     |             mstore(0x40, m2)
 11864 |     |             mstore(0x60, m3)
 11865 |     |             mstore(0x80, m4)
 11866 |     |             mstore(0xa0, m5)
 11867 |     |             mstore(0xc0, m6)
 11868 |     |         }
 11869 |     |     }
 11870 |     | 
 11871 |     |     function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {
 11872 |     |         bytes32 m0;
 11873 |     |         bytes32 m1;
 11874 |     |         bytes32 m2;
 11875 |     |         bytes32 m3;
 11876 |     |         bytes32 m4;
 11877 |     |         bytes32 m5;
 11878 |     |         bytes32 m6;
 11879 |     |         assembly {
 11880 |     |             function writeString(pos, w) {
 11881 |     |                 let length := 0
 11882 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11883 |     |                 mstore(pos, length)
 11884 |     |                 let shift := sub(256, shl(3, length))
 11885 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11886 |     |             }
 11887 |     |             m0 := mload(0x00)
 11888 |     |             m1 := mload(0x20)
 11889 |     |             m2 := mload(0x40)
 11890 |     |             m3 := mload(0x60)
 11891 |     |             m4 := mload(0x80)
 11892 |     |             m5 := mload(0xa0)
 11893 |     |             m6 := mload(0xc0)
 11894 |     |             // Selector of `log(string,uint256,bool,bool)`.
 11895 |     |             mstore(0x00, 0x354c36d6)
 11896 |     |             mstore(0x20, 0x80)
 11897 |     |             mstore(0x40, p1)
 11898 |     |             mstore(0x60, p2)
 11899 |     |             mstore(0x80, p3)
 11900 |     |             writeString(0xa0, p0)
 11901 |     |         }
 11902 |     |         _sendLogPayload(0x1c, 0xc4);
 11903 |     |         assembly {
 11904 |     |             mstore(0x00, m0)
 11905 |     |             mstore(0x20, m1)
 11906 |     |             mstore(0x40, m2)
 11907 |     |             mstore(0x60, m3)
 11908 |     |             mstore(0x80, m4)
 11909 |     |             mstore(0xa0, m5)
 11910 |     |             mstore(0xc0, m6)
 11911 |     |         }
 11912 |     |     }
 11913 |     | 
 11914 |     |     function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {
 11915 |     |         bytes32 m0;
 11916 |     |         bytes32 m1;
 11917 |     |         bytes32 m2;
 11918 |     |         bytes32 m3;
 11919 |     |         bytes32 m4;
 11920 |     |         bytes32 m5;
 11921 |     |         bytes32 m6;
 11922 |     |         assembly {
 11923 |     |             function writeString(pos, w) {
 11924 |     |                 let length := 0
 11925 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11926 |     |                 mstore(pos, length)
 11927 |     |                 let shift := sub(256, shl(3, length))
 11928 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11929 |     |             }
 11930 |     |             m0 := mload(0x00)
 11931 |     |             m1 := mload(0x20)
 11932 |     |             m2 := mload(0x40)
 11933 |     |             m3 := mload(0x60)
 11934 |     |             m4 := mload(0x80)
 11935 |     |             m5 := mload(0xa0)
 11936 |     |             m6 := mload(0xc0)
 11937 |     |             // Selector of `log(string,uint256,bool,uint256)`.
 11938 |     |             mstore(0x00, 0xe41b6f6f)
 11939 |     |             mstore(0x20, 0x80)
 11940 |     |             mstore(0x40, p1)
 11941 |     |             mstore(0x60, p2)
 11942 |     |             mstore(0x80, p3)
 11943 |     |             writeString(0xa0, p0)
 11944 |     |         }
 11945 |     |         _sendLogPayload(0x1c, 0xc4);
 11946 |     |         assembly {
 11947 |     |             mstore(0x00, m0)
 11948 |     |             mstore(0x20, m1)
 11949 |     |             mstore(0x40, m2)
 11950 |     |             mstore(0x60, m3)
 11951 |     |             mstore(0x80, m4)
 11952 |     |             mstore(0xa0, m5)
 11953 |     |             mstore(0xc0, m6)
 11954 |     |         }
 11955 |     |     }
 11956 |     | 
 11957 |     |     function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {
 11958 |     |         bytes32 m0;
 11959 |     |         bytes32 m1;
 11960 |     |         bytes32 m2;
 11961 |     |         bytes32 m3;
 11962 |     |         bytes32 m4;
 11963 |     |         bytes32 m5;
 11964 |     |         bytes32 m6;
 11965 |     |         bytes32 m7;
 11966 |     |         bytes32 m8;
 11967 |     |         assembly {
 11968 |     |             function writeString(pos, w) {
 11969 |     |                 let length := 0
 11970 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 11971 |     |                 mstore(pos, length)
 11972 |     |                 let shift := sub(256, shl(3, length))
 11973 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 11974 |     |             }
 11975 |     |             m0 := mload(0x00)
 11976 |     |             m1 := mload(0x20)
 11977 |     |             m2 := mload(0x40)
 11978 |     |             m3 := mload(0x60)
 11979 |     |             m4 := mload(0x80)
 11980 |     |             m5 := mload(0xa0)
 11981 |     |             m6 := mload(0xc0)
 11982 |     |             m7 := mload(0xe0)
 11983 |     |             m8 := mload(0x100)
 11984 |     |             // Selector of `log(string,uint256,bool,string)`.
 11985 |     |             mstore(0x00, 0xabf73a98)
 11986 |     |             mstore(0x20, 0x80)
 11987 |     |             mstore(0x40, p1)
 11988 |     |             mstore(0x60, p2)
 11989 |     |             mstore(0x80, 0xc0)
 11990 |     |             writeString(0xa0, p0)
 11991 |     |             writeString(0xe0, p3)
 11992 |     |         }
 11993 |     |         _sendLogPayload(0x1c, 0x104);
 11994 |     |         assembly {
 11995 |     |             mstore(0x00, m0)
 11996 |     |             mstore(0x20, m1)
 11997 |     |             mstore(0x40, m2)
 11998 |     |             mstore(0x60, m3)
 11999 |     |             mstore(0x80, m4)
 12000 |     |             mstore(0xa0, m5)
 12001 |     |             mstore(0xc0, m6)
 12002 |     |             mstore(0xe0, m7)
 12003 |     |             mstore(0x100, m8)
 12004 |     |         }
 12005 |     |     }
 12006 |     | 
 12007 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {
 12008 |     |         bytes32 m0;
 12009 |     |         bytes32 m1;
 12010 |     |         bytes32 m2;
 12011 |     |         bytes32 m3;
 12012 |     |         bytes32 m4;
 12013 |     |         bytes32 m5;
 12014 |     |         bytes32 m6;
 12015 |     |         assembly {
 12016 |     |             function writeString(pos, w) {
 12017 |     |                 let length := 0
 12018 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12019 |     |                 mstore(pos, length)
 12020 |     |                 let shift := sub(256, shl(3, length))
 12021 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12022 |     |             }
 12023 |     |             m0 := mload(0x00)
 12024 |     |             m1 := mload(0x20)
 12025 |     |             m2 := mload(0x40)
 12026 |     |             m3 := mload(0x60)
 12027 |     |             m4 := mload(0x80)
 12028 |     |             m5 := mload(0xa0)
 12029 |     |             m6 := mload(0xc0)
 12030 |     |             // Selector of `log(string,uint256,uint256,address)`.
 12031 |     |             mstore(0x00, 0xe21de278)
 12032 |     |             mstore(0x20, 0x80)
 12033 |     |             mstore(0x40, p1)
 12034 |     |             mstore(0x60, p2)
 12035 |     |             mstore(0x80, p3)
 12036 |     |             writeString(0xa0, p0)
 12037 |     |         }
 12038 |     |         _sendLogPayload(0x1c, 0xc4);
 12039 |     |         assembly {
 12040 |     |             mstore(0x00, m0)
 12041 |     |             mstore(0x20, m1)
 12042 |     |             mstore(0x40, m2)
 12043 |     |             mstore(0x60, m3)
 12044 |     |             mstore(0x80, m4)
 12045 |     |             mstore(0xa0, m5)
 12046 |     |             mstore(0xc0, m6)
 12047 |     |         }
 12048 |     |     }
 12049 |     | 
 12050 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {
 12051 |     |         bytes32 m0;
 12052 |     |         bytes32 m1;
 12053 |     |         bytes32 m2;
 12054 |     |         bytes32 m3;
 12055 |     |         bytes32 m4;
 12056 |     |         bytes32 m5;
 12057 |     |         bytes32 m6;
 12058 |     |         assembly {
 12059 |     |             function writeString(pos, w) {
 12060 |     |                 let length := 0
 12061 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12062 |     |                 mstore(pos, length)
 12063 |     |                 let shift := sub(256, shl(3, length))
 12064 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12065 |     |             }
 12066 |     |             m0 := mload(0x00)
 12067 |     |             m1 := mload(0x20)
 12068 |     |             m2 := mload(0x40)
 12069 |     |             m3 := mload(0x60)
 12070 |     |             m4 := mload(0x80)
 12071 |     |             m5 := mload(0xa0)
 12072 |     |             m6 := mload(0xc0)
 12073 |     |             // Selector of `log(string,uint256,uint256,bool)`.
 12074 |     |             mstore(0x00, 0x7626db92)
 12075 |     |             mstore(0x20, 0x80)
 12076 |     |             mstore(0x40, p1)
 12077 |     |             mstore(0x60, p2)
 12078 |     |             mstore(0x80, p3)
 12079 |     |             writeString(0xa0, p0)
 12080 |     |         }
 12081 |     |         _sendLogPayload(0x1c, 0xc4);
 12082 |     |         assembly {
 12083 |     |             mstore(0x00, m0)
 12084 |     |             mstore(0x20, m1)
 12085 |     |             mstore(0x40, m2)
 12086 |     |             mstore(0x60, m3)
 12087 |     |             mstore(0x80, m4)
 12088 |     |             mstore(0xa0, m5)
 12089 |     |             mstore(0xc0, m6)
 12090 |     |         }
 12091 |     |     }
 12092 |     | 
 12093 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {
 12094 |     |         bytes32 m0;
 12095 |     |         bytes32 m1;
 12096 |     |         bytes32 m2;
 12097 |     |         bytes32 m3;
 12098 |     |         bytes32 m4;
 12099 |     |         bytes32 m5;
 12100 |     |         bytes32 m6;
 12101 |     |         assembly {
 12102 |     |             function writeString(pos, w) {
 12103 |     |                 let length := 0
 12104 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12105 |     |                 mstore(pos, length)
 12106 |     |                 let shift := sub(256, shl(3, length))
 12107 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12108 |     |             }
 12109 |     |             m0 := mload(0x00)
 12110 |     |             m1 := mload(0x20)
 12111 |     |             m2 := mload(0x40)
 12112 |     |             m3 := mload(0x60)
 12113 |     |             m4 := mload(0x80)
 12114 |     |             m5 := mload(0xa0)
 12115 |     |             m6 := mload(0xc0)
 12116 |     |             // Selector of `log(string,uint256,uint256,uint256)`.
 12117 |     |             mstore(0x00, 0xa7a87853)
 12118 |     |             mstore(0x20, 0x80)
 12119 |     |             mstore(0x40, p1)
 12120 |     |             mstore(0x60, p2)
 12121 |     |             mstore(0x80, p3)
 12122 |     |             writeString(0xa0, p0)
 12123 |     |         }
 12124 |     |         _sendLogPayload(0x1c, 0xc4);
 12125 |     |         assembly {
 12126 |     |             mstore(0x00, m0)
 12127 |     |             mstore(0x20, m1)
 12128 |     |             mstore(0x40, m2)
 12129 |     |             mstore(0x60, m3)
 12130 |     |             mstore(0x80, m4)
 12131 |     |             mstore(0xa0, m5)
 12132 |     |             mstore(0xc0, m6)
 12133 |     |         }
 12134 |     |     }
 12135 |     | 
 12136 |     |     function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {
 12137 |     |         bytes32 m0;
 12138 |     |         bytes32 m1;
 12139 |     |         bytes32 m2;
 12140 |     |         bytes32 m3;
 12141 |     |         bytes32 m4;
 12142 |     |         bytes32 m5;
 12143 |     |         bytes32 m6;
 12144 |     |         bytes32 m7;
 12145 |     |         bytes32 m8;
 12146 |     |         assembly {
 12147 |     |             function writeString(pos, w) {
 12148 |     |                 let length := 0
 12149 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12150 |     |                 mstore(pos, length)
 12151 |     |                 let shift := sub(256, shl(3, length))
 12152 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12153 |     |             }
 12154 |     |             m0 := mload(0x00)
 12155 |     |             m1 := mload(0x20)
 12156 |     |             m2 := mload(0x40)
 12157 |     |             m3 := mload(0x60)
 12158 |     |             m4 := mload(0x80)
 12159 |     |             m5 := mload(0xa0)
 12160 |     |             m6 := mload(0xc0)
 12161 |     |             m7 := mload(0xe0)
 12162 |     |             m8 := mload(0x100)
 12163 |     |             // Selector of `log(string,uint256,uint256,string)`.
 12164 |     |             mstore(0x00, 0x854b3496)
 12165 |     |             mstore(0x20, 0x80)
 12166 |     |             mstore(0x40, p1)
 12167 |     |             mstore(0x60, p2)
 12168 |     |             mstore(0x80, 0xc0)
 12169 |     |             writeString(0xa0, p0)
 12170 |     |             writeString(0xe0, p3)
 12171 |     |         }
 12172 |     |         _sendLogPayload(0x1c, 0x104);
 12173 |     |         assembly {
 12174 |     |             mstore(0x00, m0)
 12175 |     |             mstore(0x20, m1)
 12176 |     |             mstore(0x40, m2)
 12177 |     |             mstore(0x60, m3)
 12178 |     |             mstore(0x80, m4)
 12179 |     |             mstore(0xa0, m5)
 12180 |     |             mstore(0xc0, m6)
 12181 |     |             mstore(0xe0, m7)
 12182 |     |             mstore(0x100, m8)
 12183 |     |         }
 12184 |     |     }
 12185 |     | 
 12186 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {
 12187 |     |         bytes32 m0;
 12188 |     |         bytes32 m1;
 12189 |     |         bytes32 m2;
 12190 |     |         bytes32 m3;
 12191 |     |         bytes32 m4;
 12192 |     |         bytes32 m5;
 12193 |     |         bytes32 m6;
 12194 |     |         bytes32 m7;
 12195 |     |         bytes32 m8;
 12196 |     |         assembly {
 12197 |     |             function writeString(pos, w) {
 12198 |     |                 let length := 0
 12199 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12200 |     |                 mstore(pos, length)
 12201 |     |                 let shift := sub(256, shl(3, length))
 12202 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12203 |     |             }
 12204 |     |             m0 := mload(0x00)
 12205 |     |             m1 := mload(0x20)
 12206 |     |             m2 := mload(0x40)
 12207 |     |             m3 := mload(0x60)
 12208 |     |             m4 := mload(0x80)
 12209 |     |             m5 := mload(0xa0)
 12210 |     |             m6 := mload(0xc0)
 12211 |     |             m7 := mload(0xe0)
 12212 |     |             m8 := mload(0x100)
 12213 |     |             // Selector of `log(string,uint256,string,address)`.
 12214 |     |             mstore(0x00, 0x7c4632a4)
 12215 |     |             mstore(0x20, 0x80)
 12216 |     |             mstore(0x40, p1)
 12217 |     |             mstore(0x60, 0xc0)
 12218 |     |             mstore(0x80, p3)
 12219 |     |             writeString(0xa0, p0)
 12220 |     |             writeString(0xe0, p2)
 12221 |     |         }
 12222 |     |         _sendLogPayload(0x1c, 0x104);
 12223 |     |         assembly {
 12224 |     |             mstore(0x00, m0)
 12225 |     |             mstore(0x20, m1)
 12226 |     |             mstore(0x40, m2)
 12227 |     |             mstore(0x60, m3)
 12228 |     |             mstore(0x80, m4)
 12229 |     |             mstore(0xa0, m5)
 12230 |     |             mstore(0xc0, m6)
 12231 |     |             mstore(0xe0, m7)
 12232 |     |             mstore(0x100, m8)
 12233 |     |         }
 12234 |     |     }
 12235 |     | 
 12236 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {
 12237 |     |         bytes32 m0;
 12238 |     |         bytes32 m1;
 12239 |     |         bytes32 m2;
 12240 |     |         bytes32 m3;
 12241 |     |         bytes32 m4;
 12242 |     |         bytes32 m5;
 12243 |     |         bytes32 m6;
 12244 |     |         bytes32 m7;
 12245 |     |         bytes32 m8;
 12246 |     |         assembly {
 12247 |     |             function writeString(pos, w) {
 12248 |     |                 let length := 0
 12249 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12250 |     |                 mstore(pos, length)
 12251 |     |                 let shift := sub(256, shl(3, length))
 12252 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12253 |     |             }
 12254 |     |             m0 := mload(0x00)
 12255 |     |             m1 := mload(0x20)
 12256 |     |             m2 := mload(0x40)
 12257 |     |             m3 := mload(0x60)
 12258 |     |             m4 := mload(0x80)
 12259 |     |             m5 := mload(0xa0)
 12260 |     |             m6 := mload(0xc0)
 12261 |     |             m7 := mload(0xe0)
 12262 |     |             m8 := mload(0x100)
 12263 |     |             // Selector of `log(string,uint256,string,bool)`.
 12264 |     |             mstore(0x00, 0x7d24491d)
 12265 |     |             mstore(0x20, 0x80)
 12266 |     |             mstore(0x40, p1)
 12267 |     |             mstore(0x60, 0xc0)
 12268 |     |             mstore(0x80, p3)
 12269 |     |             writeString(0xa0, p0)
 12270 |     |             writeString(0xe0, p2)
 12271 |     |         }
 12272 |     |         _sendLogPayload(0x1c, 0x104);
 12273 |     |         assembly {
 12274 |     |             mstore(0x00, m0)
 12275 |     |             mstore(0x20, m1)
 12276 |     |             mstore(0x40, m2)
 12277 |     |             mstore(0x60, m3)
 12278 |     |             mstore(0x80, m4)
 12279 |     |             mstore(0xa0, m5)
 12280 |     |             mstore(0xc0, m6)
 12281 |     |             mstore(0xe0, m7)
 12282 |     |             mstore(0x100, m8)
 12283 |     |         }
 12284 |     |     }
 12285 |     | 
 12286 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {
 12287 |     |         bytes32 m0;
 12288 |     |         bytes32 m1;
 12289 |     |         bytes32 m2;
 12290 |     |         bytes32 m3;
 12291 |     |         bytes32 m4;
 12292 |     |         bytes32 m5;
 12293 |     |         bytes32 m6;
 12294 |     |         bytes32 m7;
 12295 |     |         bytes32 m8;
 12296 |     |         assembly {
 12297 |     |             function writeString(pos, w) {
 12298 |     |                 let length := 0
 12299 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12300 |     |                 mstore(pos, length)
 12301 |     |                 let shift := sub(256, shl(3, length))
 12302 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12303 |     |             }
 12304 |     |             m0 := mload(0x00)
 12305 |     |             m1 := mload(0x20)
 12306 |     |             m2 := mload(0x40)
 12307 |     |             m3 := mload(0x60)
 12308 |     |             m4 := mload(0x80)
 12309 |     |             m5 := mload(0xa0)
 12310 |     |             m6 := mload(0xc0)
 12311 |     |             m7 := mload(0xe0)
 12312 |     |             m8 := mload(0x100)
 12313 |     |             // Selector of `log(string,uint256,string,uint256)`.
 12314 |     |             mstore(0x00, 0xc67ea9d1)
 12315 |     |             mstore(0x20, 0x80)
 12316 |     |             mstore(0x40, p1)
 12317 |     |             mstore(0x60, 0xc0)
 12318 |     |             mstore(0x80, p3)
 12319 |     |             writeString(0xa0, p0)
 12320 |     |             writeString(0xe0, p2)
 12321 |     |         }
 12322 |     |         _sendLogPayload(0x1c, 0x104);
 12323 |     |         assembly {
 12324 |     |             mstore(0x00, m0)
 12325 |     |             mstore(0x20, m1)
 12326 |     |             mstore(0x40, m2)
 12327 |     |             mstore(0x60, m3)
 12328 |     |             mstore(0x80, m4)
 12329 |     |             mstore(0xa0, m5)
 12330 |     |             mstore(0xc0, m6)
 12331 |     |             mstore(0xe0, m7)
 12332 |     |             mstore(0x100, m8)
 12333 |     |         }
 12334 |     |     }
 12335 |     | 
 12336 |     |     function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {
 12337 |     |         bytes32 m0;
 12338 |     |         bytes32 m1;
 12339 |     |         bytes32 m2;
 12340 |     |         bytes32 m3;
 12341 |     |         bytes32 m4;
 12342 |     |         bytes32 m5;
 12343 |     |         bytes32 m6;
 12344 |     |         bytes32 m7;
 12345 |     |         bytes32 m8;
 12346 |     |         bytes32 m9;
 12347 |     |         bytes32 m10;
 12348 |     |         assembly {
 12349 |     |             function writeString(pos, w) {
 12350 |     |                 let length := 0
 12351 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12352 |     |                 mstore(pos, length)
 12353 |     |                 let shift := sub(256, shl(3, length))
 12354 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12355 |     |             }
 12356 |     |             m0 := mload(0x00)
 12357 |     |             m1 := mload(0x20)
 12358 |     |             m2 := mload(0x40)
 12359 |     |             m3 := mload(0x60)
 12360 |     |             m4 := mload(0x80)
 12361 |     |             m5 := mload(0xa0)
 12362 |     |             m6 := mload(0xc0)
 12363 |     |             m7 := mload(0xe0)
 12364 |     |             m8 := mload(0x100)
 12365 |     |             m9 := mload(0x120)
 12366 |     |             m10 := mload(0x140)
 12367 |     |             // Selector of `log(string,uint256,string,string)`.
 12368 |     |             mstore(0x00, 0x5ab84e1f)
 12369 |     |             mstore(0x20, 0x80)
 12370 |     |             mstore(0x40, p1)
 12371 |     |             mstore(0x60, 0xc0)
 12372 |     |             mstore(0x80, 0x100)
 12373 |     |             writeString(0xa0, p0)
 12374 |     |             writeString(0xe0, p2)
 12375 |     |             writeString(0x120, p3)
 12376 |     |         }
 12377 |     |         _sendLogPayload(0x1c, 0x144);
 12378 |     |         assembly {
 12379 |     |             mstore(0x00, m0)
 12380 |     |             mstore(0x20, m1)
 12381 |     |             mstore(0x40, m2)
 12382 |     |             mstore(0x60, m3)
 12383 |     |             mstore(0x80, m4)
 12384 |     |             mstore(0xa0, m5)
 12385 |     |             mstore(0xc0, m6)
 12386 |     |             mstore(0xe0, m7)
 12387 |     |             mstore(0x100, m8)
 12388 |     |             mstore(0x120, m9)
 12389 |     |             mstore(0x140, m10)
 12390 |     |         }
 12391 |     |     }
 12392 |     | 
 12393 |     |     function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {
 12394 |     |         bytes32 m0;
 12395 |     |         bytes32 m1;
 12396 |     |         bytes32 m2;
 12397 |     |         bytes32 m3;
 12398 |     |         bytes32 m4;
 12399 |     |         bytes32 m5;
 12400 |     |         bytes32 m6;
 12401 |     |         bytes32 m7;
 12402 |     |         bytes32 m8;
 12403 |     |         assembly {
 12404 |     |             function writeString(pos, w) {
 12405 |     |                 let length := 0
 12406 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12407 |     |                 mstore(pos, length)
 12408 |     |                 let shift := sub(256, shl(3, length))
 12409 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12410 |     |             }
 12411 |     |             m0 := mload(0x00)
 12412 |     |             m1 := mload(0x20)
 12413 |     |             m2 := mload(0x40)
 12414 |     |             m3 := mload(0x60)
 12415 |     |             m4 := mload(0x80)
 12416 |     |             m5 := mload(0xa0)
 12417 |     |             m6 := mload(0xc0)
 12418 |     |             m7 := mload(0xe0)
 12419 |     |             m8 := mload(0x100)
 12420 |     |             // Selector of `log(string,string,address,address)`.
 12421 |     |             mstore(0x00, 0x439c7bef)
 12422 |     |             mstore(0x20, 0x80)
 12423 |     |             mstore(0x40, 0xc0)
 12424 |     |             mstore(0x60, p2)
 12425 |     |             mstore(0x80, p3)
 12426 |     |             writeString(0xa0, p0)
 12427 |     |             writeString(0xe0, p1)
 12428 |     |         }
 12429 |     |         _sendLogPayload(0x1c, 0x104);
 12430 |     |         assembly {
 12431 |     |             mstore(0x00, m0)
 12432 |     |             mstore(0x20, m1)
 12433 |     |             mstore(0x40, m2)
 12434 |     |             mstore(0x60, m3)
 12435 |     |             mstore(0x80, m4)
 12436 |     |             mstore(0xa0, m5)
 12437 |     |             mstore(0xc0, m6)
 12438 |     |             mstore(0xe0, m7)
 12439 |     |             mstore(0x100, m8)
 12440 |     |         }
 12441 |     |     }
 12442 |     | 
 12443 |     |     function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {
 12444 |     |         bytes32 m0;
 12445 |     |         bytes32 m1;
 12446 |     |         bytes32 m2;
 12447 |     |         bytes32 m3;
 12448 |     |         bytes32 m4;
 12449 |     |         bytes32 m5;
 12450 |     |         bytes32 m6;
 12451 |     |         bytes32 m7;
 12452 |     |         bytes32 m8;
 12453 |     |         assembly {
 12454 |     |             function writeString(pos, w) {
 12455 |     |                 let length := 0
 12456 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12457 |     |                 mstore(pos, length)
 12458 |     |                 let shift := sub(256, shl(3, length))
 12459 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12460 |     |             }
 12461 |     |             m0 := mload(0x00)
 12462 |     |             m1 := mload(0x20)
 12463 |     |             m2 := mload(0x40)
 12464 |     |             m3 := mload(0x60)
 12465 |     |             m4 := mload(0x80)
 12466 |     |             m5 := mload(0xa0)
 12467 |     |             m6 := mload(0xc0)
 12468 |     |             m7 := mload(0xe0)
 12469 |     |             m8 := mload(0x100)
 12470 |     |             // Selector of `log(string,string,address,bool)`.
 12471 |     |             mstore(0x00, 0x5ccd4e37)
 12472 |     |             mstore(0x20, 0x80)
 12473 |     |             mstore(0x40, 0xc0)
 12474 |     |             mstore(0x60, p2)
 12475 |     |             mstore(0x80, p3)
 12476 |     |             writeString(0xa0, p0)
 12477 |     |             writeString(0xe0, p1)
 12478 |     |         }
 12479 |     |         _sendLogPayload(0x1c, 0x104);
 12480 |     |         assembly {
 12481 |     |             mstore(0x00, m0)
 12482 |     |             mstore(0x20, m1)
 12483 |     |             mstore(0x40, m2)
 12484 |     |             mstore(0x60, m3)
 12485 |     |             mstore(0x80, m4)
 12486 |     |             mstore(0xa0, m5)
 12487 |     |             mstore(0xc0, m6)
 12488 |     |             mstore(0xe0, m7)
 12489 |     |             mstore(0x100, m8)
 12490 |     |         }
 12491 |     |     }
 12492 |     | 
 12493 |     |     function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {
 12494 |     |         bytes32 m0;
 12495 |     |         bytes32 m1;
 12496 |     |         bytes32 m2;
 12497 |     |         bytes32 m3;
 12498 |     |         bytes32 m4;
 12499 |     |         bytes32 m5;
 12500 |     |         bytes32 m6;
 12501 |     |         bytes32 m7;
 12502 |     |         bytes32 m8;
 12503 |     |         assembly {
 12504 |     |             function writeString(pos, w) {
 12505 |     |                 let length := 0
 12506 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12507 |     |                 mstore(pos, length)
 12508 |     |                 let shift := sub(256, shl(3, length))
 12509 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12510 |     |             }
 12511 |     |             m0 := mload(0x00)
 12512 |     |             m1 := mload(0x20)
 12513 |     |             m2 := mload(0x40)
 12514 |     |             m3 := mload(0x60)
 12515 |     |             m4 := mload(0x80)
 12516 |     |             m5 := mload(0xa0)
 12517 |     |             m6 := mload(0xc0)
 12518 |     |             m7 := mload(0xe0)
 12519 |     |             m8 := mload(0x100)
 12520 |     |             // Selector of `log(string,string,address,uint256)`.
 12521 |     |             mstore(0x00, 0x7cc3c607)
 12522 |     |             mstore(0x20, 0x80)
 12523 |     |             mstore(0x40, 0xc0)
 12524 |     |             mstore(0x60, p2)
 12525 |     |             mstore(0x80, p3)
 12526 |     |             writeString(0xa0, p0)
 12527 |     |             writeString(0xe0, p1)
 12528 |     |         }
 12529 |     |         _sendLogPayload(0x1c, 0x104);
 12530 |     |         assembly {
 12531 |     |             mstore(0x00, m0)
 12532 |     |             mstore(0x20, m1)
 12533 |     |             mstore(0x40, m2)
 12534 |     |             mstore(0x60, m3)
 12535 |     |             mstore(0x80, m4)
 12536 |     |             mstore(0xa0, m5)
 12537 |     |             mstore(0xc0, m6)
 12538 |     |             mstore(0xe0, m7)
 12539 |     |             mstore(0x100, m8)
 12540 |     |         }
 12541 |     |     }
 12542 |     | 
 12543 |     |     function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {
 12544 |     |         bytes32 m0;
 12545 |     |         bytes32 m1;
 12546 |     |         bytes32 m2;
 12547 |     |         bytes32 m3;
 12548 |     |         bytes32 m4;
 12549 |     |         bytes32 m5;
 12550 |     |         bytes32 m6;
 12551 |     |         bytes32 m7;
 12552 |     |         bytes32 m8;
 12553 |     |         bytes32 m9;
 12554 |     |         bytes32 m10;
 12555 |     |         assembly {
 12556 |     |             function writeString(pos, w) {
 12557 |     |                 let length := 0
 12558 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12559 |     |                 mstore(pos, length)
 12560 |     |                 let shift := sub(256, shl(3, length))
 12561 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12562 |     |             }
 12563 |     |             m0 := mload(0x00)
 12564 |     |             m1 := mload(0x20)
 12565 |     |             m2 := mload(0x40)
 12566 |     |             m3 := mload(0x60)
 12567 |     |             m4 := mload(0x80)
 12568 |     |             m5 := mload(0xa0)
 12569 |     |             m6 := mload(0xc0)
 12570 |     |             m7 := mload(0xe0)
 12571 |     |             m8 := mload(0x100)
 12572 |     |             m9 := mload(0x120)
 12573 |     |             m10 := mload(0x140)
 12574 |     |             // Selector of `log(string,string,address,string)`.
 12575 |     |             mstore(0x00, 0xeb1bff80)
 12576 |     |             mstore(0x20, 0x80)
 12577 |     |             mstore(0x40, 0xc0)
 12578 |     |             mstore(0x60, p2)
 12579 |     |             mstore(0x80, 0x100)
 12580 |     |             writeString(0xa0, p0)
 12581 |     |             writeString(0xe0, p1)
 12582 |     |             writeString(0x120, p3)
 12583 |     |         }
 12584 |     |         _sendLogPayload(0x1c, 0x144);
 12585 |     |         assembly {
 12586 |     |             mstore(0x00, m0)
 12587 |     |             mstore(0x20, m1)
 12588 |     |             mstore(0x40, m2)
 12589 |     |             mstore(0x60, m3)
 12590 |     |             mstore(0x80, m4)
 12591 |     |             mstore(0xa0, m5)
 12592 |     |             mstore(0xc0, m6)
 12593 |     |             mstore(0xe0, m7)
 12594 |     |             mstore(0x100, m8)
 12595 |     |             mstore(0x120, m9)
 12596 |     |             mstore(0x140, m10)
 12597 |     |         }
 12598 |     |     }
 12599 |     | 
 12600 |     |     function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {
 12601 |     |         bytes32 m0;
 12602 |     |         bytes32 m1;
 12603 |     |         bytes32 m2;
 12604 |     |         bytes32 m3;
 12605 |     |         bytes32 m4;
 12606 |     |         bytes32 m5;
 12607 |     |         bytes32 m6;
 12608 |     |         bytes32 m7;
 12609 |     |         bytes32 m8;
 12610 |     |         assembly {
 12611 |     |             function writeString(pos, w) {
 12612 |     |                 let length := 0
 12613 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12614 |     |                 mstore(pos, length)
 12615 |     |                 let shift := sub(256, shl(3, length))
 12616 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12617 |     |             }
 12618 |     |             m0 := mload(0x00)
 12619 |     |             m1 := mload(0x20)
 12620 |     |             m2 := mload(0x40)
 12621 |     |             m3 := mload(0x60)
 12622 |     |             m4 := mload(0x80)
 12623 |     |             m5 := mload(0xa0)
 12624 |     |             m6 := mload(0xc0)
 12625 |     |             m7 := mload(0xe0)
 12626 |     |             m8 := mload(0x100)
 12627 |     |             // Selector of `log(string,string,bool,address)`.
 12628 |     |             mstore(0x00, 0xc371c7db)
 12629 |     |             mstore(0x20, 0x80)
 12630 |     |             mstore(0x40, 0xc0)
 12631 |     |             mstore(0x60, p2)
 12632 |     |             mstore(0x80, p3)
 12633 |     |             writeString(0xa0, p0)
 12634 |     |             writeString(0xe0, p1)
 12635 |     |         }
 12636 |     |         _sendLogPayload(0x1c, 0x104);
 12637 |     |         assembly {
 12638 |     |             mstore(0x00, m0)
 12639 |     |             mstore(0x20, m1)
 12640 |     |             mstore(0x40, m2)
 12641 |     |             mstore(0x60, m3)
 12642 |     |             mstore(0x80, m4)
 12643 |     |             mstore(0xa0, m5)
 12644 |     |             mstore(0xc0, m6)
 12645 |     |             mstore(0xe0, m7)
 12646 |     |             mstore(0x100, m8)
 12647 |     |         }
 12648 |     |     }
 12649 |     | 
 12650 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {
 12651 |     |         bytes32 m0;
 12652 |     |         bytes32 m1;
 12653 |     |         bytes32 m2;
 12654 |     |         bytes32 m3;
 12655 |     |         bytes32 m4;
 12656 |     |         bytes32 m5;
 12657 |     |         bytes32 m6;
 12658 |     |         bytes32 m7;
 12659 |     |         bytes32 m8;
 12660 |     |         assembly {
 12661 |     |             function writeString(pos, w) {
 12662 |     |                 let length := 0
 12663 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12664 |     |                 mstore(pos, length)
 12665 |     |                 let shift := sub(256, shl(3, length))
 12666 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12667 |     |             }
 12668 |     |             m0 := mload(0x00)
 12669 |     |             m1 := mload(0x20)
 12670 |     |             m2 := mload(0x40)
 12671 |     |             m3 := mload(0x60)
 12672 |     |             m4 := mload(0x80)
 12673 |     |             m5 := mload(0xa0)
 12674 |     |             m6 := mload(0xc0)
 12675 |     |             m7 := mload(0xe0)
 12676 |     |             m8 := mload(0x100)
 12677 |     |             // Selector of `log(string,string,bool,bool)`.
 12678 |     |             mstore(0x00, 0x40785869)
 12679 |     |             mstore(0x20, 0x80)
 12680 |     |             mstore(0x40, 0xc0)
 12681 |     |             mstore(0x60, p2)
 12682 |     |             mstore(0x80, p3)
 12683 |     |             writeString(0xa0, p0)
 12684 |     |             writeString(0xe0, p1)
 12685 |     |         }
 12686 |     |         _sendLogPayload(0x1c, 0x104);
 12687 |     |         assembly {
 12688 |     |             mstore(0x00, m0)
 12689 |     |             mstore(0x20, m1)
 12690 |     |             mstore(0x40, m2)
 12691 |     |             mstore(0x60, m3)
 12692 |     |             mstore(0x80, m4)
 12693 |     |             mstore(0xa0, m5)
 12694 |     |             mstore(0xc0, m6)
 12695 |     |             mstore(0xe0, m7)
 12696 |     |             mstore(0x100, m8)
 12697 |     |         }
 12698 |     |     }
 12699 |     | 
 12700 |     |     function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {
 12701 |     |         bytes32 m0;
 12702 |     |         bytes32 m1;
 12703 |     |         bytes32 m2;
 12704 |     |         bytes32 m3;
 12705 |     |         bytes32 m4;
 12706 |     |         bytes32 m5;
 12707 |     |         bytes32 m6;
 12708 |     |         bytes32 m7;
 12709 |     |         bytes32 m8;
 12710 |     |         assembly {
 12711 |     |             function writeString(pos, w) {
 12712 |     |                 let length := 0
 12713 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12714 |     |                 mstore(pos, length)
 12715 |     |                 let shift := sub(256, shl(3, length))
 12716 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12717 |     |             }
 12718 |     |             m0 := mload(0x00)
 12719 |     |             m1 := mload(0x20)
 12720 |     |             m2 := mload(0x40)
 12721 |     |             m3 := mload(0x60)
 12722 |     |             m4 := mload(0x80)
 12723 |     |             m5 := mload(0xa0)
 12724 |     |             m6 := mload(0xc0)
 12725 |     |             m7 := mload(0xe0)
 12726 |     |             m8 := mload(0x100)
 12727 |     |             // Selector of `log(string,string,bool,uint256)`.
 12728 |     |             mstore(0x00, 0xd6aefad2)
 12729 |     |             mstore(0x20, 0x80)
 12730 |     |             mstore(0x40, 0xc0)
 12731 |     |             mstore(0x60, p2)
 12732 |     |             mstore(0x80, p3)
 12733 |     |             writeString(0xa0, p0)
 12734 |     |             writeString(0xe0, p1)
 12735 |     |         }
 12736 |     |         _sendLogPayload(0x1c, 0x104);
 12737 |     |         assembly {
 12738 |     |             mstore(0x00, m0)
 12739 |     |             mstore(0x20, m1)
 12740 |     |             mstore(0x40, m2)
 12741 |     |             mstore(0x60, m3)
 12742 |     |             mstore(0x80, m4)
 12743 |     |             mstore(0xa0, m5)
 12744 |     |             mstore(0xc0, m6)
 12745 |     |             mstore(0xe0, m7)
 12746 |     |             mstore(0x100, m8)
 12747 |     |         }
 12748 |     |     }
 12749 |     | 
 12750 |     |     function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {
 12751 |     |         bytes32 m0;
 12752 |     |         bytes32 m1;
 12753 |     |         bytes32 m2;
 12754 |     |         bytes32 m3;
 12755 |     |         bytes32 m4;
 12756 |     |         bytes32 m5;
 12757 |     |         bytes32 m6;
 12758 |     |         bytes32 m7;
 12759 |     |         bytes32 m8;
 12760 |     |         bytes32 m9;
 12761 |     |         bytes32 m10;
 12762 |     |         assembly {
 12763 |     |             function writeString(pos, w) {
 12764 |     |                 let length := 0
 12765 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12766 |     |                 mstore(pos, length)
 12767 |     |                 let shift := sub(256, shl(3, length))
 12768 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12769 |     |             }
 12770 |     |             m0 := mload(0x00)
 12771 |     |             m1 := mload(0x20)
 12772 |     |             m2 := mload(0x40)
 12773 |     |             m3 := mload(0x60)
 12774 |     |             m4 := mload(0x80)
 12775 |     |             m5 := mload(0xa0)
 12776 |     |             m6 := mload(0xc0)
 12777 |     |             m7 := mload(0xe0)
 12778 |     |             m8 := mload(0x100)
 12779 |     |             m9 := mload(0x120)
 12780 |     |             m10 := mload(0x140)
 12781 |     |             // Selector of `log(string,string,bool,string)`.
 12782 |     |             mstore(0x00, 0x5e84b0ea)
 12783 |     |             mstore(0x20, 0x80)
 12784 |     |             mstore(0x40, 0xc0)
 12785 |     |             mstore(0x60, p2)
 12786 |     |             mstore(0x80, 0x100)
 12787 |     |             writeString(0xa0, p0)
 12788 |     |             writeString(0xe0, p1)
 12789 |     |             writeString(0x120, p3)
 12790 |     |         }
 12791 |     |         _sendLogPayload(0x1c, 0x144);
 12792 |     |         assembly {
 12793 |     |             mstore(0x00, m0)
 12794 |     |             mstore(0x20, m1)
 12795 |     |             mstore(0x40, m2)
 12796 |     |             mstore(0x60, m3)
 12797 |     |             mstore(0x80, m4)
 12798 |     |             mstore(0xa0, m5)
 12799 |     |             mstore(0xc0, m6)
 12800 |     |             mstore(0xe0, m7)
 12801 |     |             mstore(0x100, m8)
 12802 |     |             mstore(0x120, m9)
 12803 |     |             mstore(0x140, m10)
 12804 |     |         }
 12805 |     |     }
 12806 |     | 
 12807 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {
 12808 |     |         bytes32 m0;
 12809 |     |         bytes32 m1;
 12810 |     |         bytes32 m2;
 12811 |     |         bytes32 m3;
 12812 |     |         bytes32 m4;
 12813 |     |         bytes32 m5;
 12814 |     |         bytes32 m6;
 12815 |     |         bytes32 m7;
 12816 |     |         bytes32 m8;
 12817 |     |         assembly {
 12818 |     |             function writeString(pos, w) {
 12819 |     |                 let length := 0
 12820 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12821 |     |                 mstore(pos, length)
 12822 |     |                 let shift := sub(256, shl(3, length))
 12823 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12824 |     |             }
 12825 |     |             m0 := mload(0x00)
 12826 |     |             m1 := mload(0x20)
 12827 |     |             m2 := mload(0x40)
 12828 |     |             m3 := mload(0x60)
 12829 |     |             m4 := mload(0x80)
 12830 |     |             m5 := mload(0xa0)
 12831 |     |             m6 := mload(0xc0)
 12832 |     |             m7 := mload(0xe0)
 12833 |     |             m8 := mload(0x100)
 12834 |     |             // Selector of `log(string,string,uint256,address)`.
 12835 |     |             mstore(0x00, 0x1023f7b2)
 12836 |     |             mstore(0x20, 0x80)
 12837 |     |             mstore(0x40, 0xc0)
 12838 |     |             mstore(0x60, p2)
 12839 |     |             mstore(0x80, p3)
 12840 |     |             writeString(0xa0, p0)
 12841 |     |             writeString(0xe0, p1)
 12842 |     |         }
 12843 |     |         _sendLogPayload(0x1c, 0x104);
 12844 |     |         assembly {
 12845 |     |             mstore(0x00, m0)
 12846 |     |             mstore(0x20, m1)
 12847 |     |             mstore(0x40, m2)
 12848 |     |             mstore(0x60, m3)
 12849 |     |             mstore(0x80, m4)
 12850 |     |             mstore(0xa0, m5)
 12851 |     |             mstore(0xc0, m6)
 12852 |     |             mstore(0xe0, m7)
 12853 |     |             mstore(0x100, m8)
 12854 |     |         }
 12855 |     |     }
 12856 |     | 
 12857 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {
 12858 |     |         bytes32 m0;
 12859 |     |         bytes32 m1;
 12860 |     |         bytes32 m2;
 12861 |     |         bytes32 m3;
 12862 |     |         bytes32 m4;
 12863 |     |         bytes32 m5;
 12864 |     |         bytes32 m6;
 12865 |     |         bytes32 m7;
 12866 |     |         bytes32 m8;
 12867 |     |         assembly {
 12868 |     |             function writeString(pos, w) {
 12869 |     |                 let length := 0
 12870 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12871 |     |                 mstore(pos, length)
 12872 |     |                 let shift := sub(256, shl(3, length))
 12873 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12874 |     |             }
 12875 |     |             m0 := mload(0x00)
 12876 |     |             m1 := mload(0x20)
 12877 |     |             m2 := mload(0x40)
 12878 |     |             m3 := mload(0x60)
 12879 |     |             m4 := mload(0x80)
 12880 |     |             m5 := mload(0xa0)
 12881 |     |             m6 := mload(0xc0)
 12882 |     |             m7 := mload(0xe0)
 12883 |     |             m8 := mload(0x100)
 12884 |     |             // Selector of `log(string,string,uint256,bool)`.
 12885 |     |             mstore(0x00, 0xc3a8a654)
 12886 |     |             mstore(0x20, 0x80)
 12887 |     |             mstore(0x40, 0xc0)
 12888 |     |             mstore(0x60, p2)
 12889 |     |             mstore(0x80, p3)
 12890 |     |             writeString(0xa0, p0)
 12891 |     |             writeString(0xe0, p1)
 12892 |     |         }
 12893 |     |         _sendLogPayload(0x1c, 0x104);
 12894 |     |         assembly {
 12895 |     |             mstore(0x00, m0)
 12896 |     |             mstore(0x20, m1)
 12897 |     |             mstore(0x40, m2)
 12898 |     |             mstore(0x60, m3)
 12899 |     |             mstore(0x80, m4)
 12900 |     |             mstore(0xa0, m5)
 12901 |     |             mstore(0xc0, m6)
 12902 |     |             mstore(0xe0, m7)
 12903 |     |             mstore(0x100, m8)
 12904 |     |         }
 12905 |     |     }
 12906 |     | 
 12907 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {
 12908 |     |         bytes32 m0;
 12909 |     |         bytes32 m1;
 12910 |     |         bytes32 m2;
 12911 |     |         bytes32 m3;
 12912 |     |         bytes32 m4;
 12913 |     |         bytes32 m5;
 12914 |     |         bytes32 m6;
 12915 |     |         bytes32 m7;
 12916 |     |         bytes32 m8;
 12917 |     |         assembly {
 12918 |     |             function writeString(pos, w) {
 12919 |     |                 let length := 0
 12920 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12921 |     |                 mstore(pos, length)
 12922 |     |                 let shift := sub(256, shl(3, length))
 12923 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12924 |     |             }
 12925 |     |             m0 := mload(0x00)
 12926 |     |             m1 := mload(0x20)
 12927 |     |             m2 := mload(0x40)
 12928 |     |             m3 := mload(0x60)
 12929 |     |             m4 := mload(0x80)
 12930 |     |             m5 := mload(0xa0)
 12931 |     |             m6 := mload(0xc0)
 12932 |     |             m7 := mload(0xe0)
 12933 |     |             m8 := mload(0x100)
 12934 |     |             // Selector of `log(string,string,uint256,uint256)`.
 12935 |     |             mstore(0x00, 0xf45d7d2c)
 12936 |     |             mstore(0x20, 0x80)
 12937 |     |             mstore(0x40, 0xc0)
 12938 |     |             mstore(0x60, p2)
 12939 |     |             mstore(0x80, p3)
 12940 |     |             writeString(0xa0, p0)
 12941 |     |             writeString(0xe0, p1)
 12942 |     |         }
 12943 |     |         _sendLogPayload(0x1c, 0x104);
 12944 |     |         assembly {
 12945 |     |             mstore(0x00, m0)
 12946 |     |             mstore(0x20, m1)
 12947 |     |             mstore(0x40, m2)
 12948 |     |             mstore(0x60, m3)
 12949 |     |             mstore(0x80, m4)
 12950 |     |             mstore(0xa0, m5)
 12951 |     |             mstore(0xc0, m6)
 12952 |     |             mstore(0xe0, m7)
 12953 |     |             mstore(0x100, m8)
 12954 |     |         }
 12955 |     |     }
 12956 |     | 
 12957 |     |     function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {
 12958 |     |         bytes32 m0;
 12959 |     |         bytes32 m1;
 12960 |     |         bytes32 m2;
 12961 |     |         bytes32 m3;
 12962 |     |         bytes32 m4;
 12963 |     |         bytes32 m5;
 12964 |     |         bytes32 m6;
 12965 |     |         bytes32 m7;
 12966 |     |         bytes32 m8;
 12967 |     |         bytes32 m9;
 12968 |     |         bytes32 m10;
 12969 |     |         assembly {
 12970 |     |             function writeString(pos, w) {
 12971 |     |                 let length := 0
 12972 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 12973 |     |                 mstore(pos, length)
 12974 |     |                 let shift := sub(256, shl(3, length))
 12975 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 12976 |     |             }
 12977 |     |             m0 := mload(0x00)
 12978 |     |             m1 := mload(0x20)
 12979 |     |             m2 := mload(0x40)
 12980 |     |             m3 := mload(0x60)
 12981 |     |             m4 := mload(0x80)
 12982 |     |             m5 := mload(0xa0)
 12983 |     |             m6 := mload(0xc0)
 12984 |     |             m7 := mload(0xe0)
 12985 |     |             m8 := mload(0x100)
 12986 |     |             m9 := mload(0x120)
 12987 |     |             m10 := mload(0x140)
 12988 |     |             // Selector of `log(string,string,uint256,string)`.
 12989 |     |             mstore(0x00, 0x5d1a971a)
 12990 |     |             mstore(0x20, 0x80)
 12991 |     |             mstore(0x40, 0xc0)
 12992 |     |             mstore(0x60, p2)
 12993 |     |             mstore(0x80, 0x100)
 12994 |     |             writeString(0xa0, p0)
 12995 |     |             writeString(0xe0, p1)
 12996 |     |             writeString(0x120, p3)
 12997 |     |         }
 12998 |     |         _sendLogPayload(0x1c, 0x144);
 12999 |     |         assembly {
 13000 |     |             mstore(0x00, m0)
 13001 |     |             mstore(0x20, m1)
 13002 |     |             mstore(0x40, m2)
 13003 |     |             mstore(0x60, m3)
 13004 |     |             mstore(0x80, m4)
 13005 |     |             mstore(0xa0, m5)
 13006 |     |             mstore(0xc0, m6)
 13007 |     |             mstore(0xe0, m7)
 13008 |     |             mstore(0x100, m8)
 13009 |     |             mstore(0x120, m9)
 13010 |     |             mstore(0x140, m10)
 13011 |     |         }
 13012 |     |     }
 13013 |     | 
 13014 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {
 13015 |     |         bytes32 m0;
 13016 |     |         bytes32 m1;
 13017 |     |         bytes32 m2;
 13018 |     |         bytes32 m3;
 13019 |     |         bytes32 m4;
 13020 |     |         bytes32 m5;
 13021 |     |         bytes32 m6;
 13022 |     |         bytes32 m7;
 13023 |     |         bytes32 m8;
 13024 |     |         bytes32 m9;
 13025 |     |         bytes32 m10;
 13026 |     |         assembly {
 13027 |     |             function writeString(pos, w) {
 13028 |     |                 let length := 0
 13029 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13030 |     |                 mstore(pos, length)
 13031 |     |                 let shift := sub(256, shl(3, length))
 13032 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13033 |     |             }
 13034 |     |             m0 := mload(0x00)
 13035 |     |             m1 := mload(0x20)
 13036 |     |             m2 := mload(0x40)
 13037 |     |             m3 := mload(0x60)
 13038 |     |             m4 := mload(0x80)
 13039 |     |             m5 := mload(0xa0)
 13040 |     |             m6 := mload(0xc0)
 13041 |     |             m7 := mload(0xe0)
 13042 |     |             m8 := mload(0x100)
 13043 |     |             m9 := mload(0x120)
 13044 |     |             m10 := mload(0x140)
 13045 |     |             // Selector of `log(string,string,string,address)`.
 13046 |     |             mstore(0x00, 0x6d572f44)
 13047 |     |             mstore(0x20, 0x80)
 13048 |     |             mstore(0x40, 0xc0)
 13049 |     |             mstore(0x60, 0x100)
 13050 |     |             mstore(0x80, p3)
 13051 |     |             writeString(0xa0, p0)
 13052 |     |             writeString(0xe0, p1)
 13053 |     |             writeString(0x120, p2)
 13054 |     |         }
 13055 |     |         _sendLogPayload(0x1c, 0x144);
 13056 |     |         assembly {
 13057 |     |             mstore(0x00, m0)
 13058 |     |             mstore(0x20, m1)
 13059 |     |             mstore(0x40, m2)
 13060 |     |             mstore(0x60, m3)
 13061 |     |             mstore(0x80, m4)
 13062 |     |             mstore(0xa0, m5)
 13063 |     |             mstore(0xc0, m6)
 13064 |     |             mstore(0xe0, m7)
 13065 |     |             mstore(0x100, m8)
 13066 |     |             mstore(0x120, m9)
 13067 |     |             mstore(0x140, m10)
 13068 |     |         }
 13069 |     |     }
 13070 |     | 
 13071 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {
 13072 |     |         bytes32 m0;
 13073 |     |         bytes32 m1;
 13074 |     |         bytes32 m2;
 13075 |     |         bytes32 m3;
 13076 |     |         bytes32 m4;
 13077 |     |         bytes32 m5;
 13078 |     |         bytes32 m6;
 13079 |     |         bytes32 m7;
 13080 |     |         bytes32 m8;
 13081 |     |         bytes32 m9;
 13082 |     |         bytes32 m10;
 13083 |     |         assembly {
 13084 |     |             function writeString(pos, w) {
 13085 |     |                 let length := 0
 13086 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13087 |     |                 mstore(pos, length)
 13088 |     |                 let shift := sub(256, shl(3, length))
 13089 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13090 |     |             }
 13091 |     |             m0 := mload(0x00)
 13092 |     |             m1 := mload(0x20)
 13093 |     |             m2 := mload(0x40)
 13094 |     |             m3 := mload(0x60)
 13095 |     |             m4 := mload(0x80)
 13096 |     |             m5 := mload(0xa0)
 13097 |     |             m6 := mload(0xc0)
 13098 |     |             m7 := mload(0xe0)
 13099 |     |             m8 := mload(0x100)
 13100 |     |             m9 := mload(0x120)
 13101 |     |             m10 := mload(0x140)
 13102 |     |             // Selector of `log(string,string,string,bool)`.
 13103 |     |             mstore(0x00, 0x2c1754ed)
 13104 |     |             mstore(0x20, 0x80)
 13105 |     |             mstore(0x40, 0xc0)
 13106 |     |             mstore(0x60, 0x100)
 13107 |     |             mstore(0x80, p3)
 13108 |     |             writeString(0xa0, p0)
 13109 |     |             writeString(0xe0, p1)
 13110 |     |             writeString(0x120, p2)
 13111 |     |         }
 13112 |     |         _sendLogPayload(0x1c, 0x144);
 13113 |     |         assembly {
 13114 |     |             mstore(0x00, m0)
 13115 |     |             mstore(0x20, m1)
 13116 |     |             mstore(0x40, m2)
 13117 |     |             mstore(0x60, m3)
 13118 |     |             mstore(0x80, m4)
 13119 |     |             mstore(0xa0, m5)
 13120 |     |             mstore(0xc0, m6)
 13121 |     |             mstore(0xe0, m7)
 13122 |     |             mstore(0x100, m8)
 13123 |     |             mstore(0x120, m9)
 13124 |     |             mstore(0x140, m10)
 13125 |     |         }
 13126 |     |     }
 13127 |     | 
 13128 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {
 13129 |     |         bytes32 m0;
 13130 |     |         bytes32 m1;
 13131 |     |         bytes32 m2;
 13132 |     |         bytes32 m3;
 13133 |     |         bytes32 m4;
 13134 |     |         bytes32 m5;
 13135 |     |         bytes32 m6;
 13136 |     |         bytes32 m7;
 13137 |     |         bytes32 m8;
 13138 |     |         bytes32 m9;
 13139 |     |         bytes32 m10;
 13140 |     |         assembly {
 13141 |     |             function writeString(pos, w) {
 13142 |     |                 let length := 0
 13143 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13144 |     |                 mstore(pos, length)
 13145 |     |                 let shift := sub(256, shl(3, length))
 13146 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13147 |     |             }
 13148 |     |             m0 := mload(0x00)
 13149 |     |             m1 := mload(0x20)
 13150 |     |             m2 := mload(0x40)
 13151 |     |             m3 := mload(0x60)
 13152 |     |             m4 := mload(0x80)
 13153 |     |             m5 := mload(0xa0)
 13154 |     |             m6 := mload(0xc0)
 13155 |     |             m7 := mload(0xe0)
 13156 |     |             m8 := mload(0x100)
 13157 |     |             m9 := mload(0x120)
 13158 |     |             m10 := mload(0x140)
 13159 |     |             // Selector of `log(string,string,string,uint256)`.
 13160 |     |             mstore(0x00, 0x8eafb02b)
 13161 |     |             mstore(0x20, 0x80)
 13162 |     |             mstore(0x40, 0xc0)
 13163 |     |             mstore(0x60, 0x100)
 13164 |     |             mstore(0x80, p3)
 13165 |     |             writeString(0xa0, p0)
 13166 |     |             writeString(0xe0, p1)
 13167 |     |             writeString(0x120, p2)
 13168 |     |         }
 13169 |     |         _sendLogPayload(0x1c, 0x144);
 13170 |     |         assembly {
 13171 |     |             mstore(0x00, m0)
 13172 |     |             mstore(0x20, m1)
 13173 |     |             mstore(0x40, m2)
 13174 |     |             mstore(0x60, m3)
 13175 |     |             mstore(0x80, m4)
 13176 |     |             mstore(0xa0, m5)
 13177 |     |             mstore(0xc0, m6)
 13178 |     |             mstore(0xe0, m7)
 13179 |     |             mstore(0x100, m8)
 13180 |     |             mstore(0x120, m9)
 13181 |     |             mstore(0x140, m10)
 13182 |     |         }
 13183 |     |     }
 13184 |     | 
 13185 |     |     function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {
 13186 |     |         bytes32 m0;
 13187 |     |         bytes32 m1;
 13188 |     |         bytes32 m2;
 13189 |     |         bytes32 m3;
 13190 |     |         bytes32 m4;
 13191 |     |         bytes32 m5;
 13192 |     |         bytes32 m6;
 13193 |     |         bytes32 m7;
 13194 |     |         bytes32 m8;
 13195 |     |         bytes32 m9;
 13196 |     |         bytes32 m10;
 13197 |     |         bytes32 m11;
 13198 |     |         bytes32 m12;
 13199 |     |         assembly {
 13200 |     |             function writeString(pos, w) {
 13201 |     |                 let length := 0
 13202 |     |                 for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }
 13203 |     |                 mstore(pos, length)
 13204 |     |                 let shift := sub(256, shl(3, length))
 13205 |     |                 mstore(add(pos, 0x20), shl(shift, shr(shift, w)))
 13206 |     |             }
 13207 |     |             m0 := mload(0x00)
 13208 |     |             m1 := mload(0x20)
 13209 |     |             m2 := mload(0x40)
 13210 |     |             m3 := mload(0x60)
 13211 |     |             m4 := mload(0x80)
 13212 |     |             m5 := mload(0xa0)
 13213 |     |             m6 := mload(0xc0)
 13214 |     |             m7 := mload(0xe0)
 13215 |     |             m8 := mload(0x100)
 13216 |     |             m9 := mload(0x120)
 13217 |     |             m10 := mload(0x140)
 13218 |     |             m11 := mload(0x160)
 13219 |     |             m12 := mload(0x180)
 13220 |     |             // Selector of `log(string,string,string,string)`.
 13221 |     |             mstore(0x00, 0xde68f20a)
 13222 |     |             mstore(0x20, 0x80)
 13223 |     |             mstore(0x40, 0xc0)
 13224 |     |             mstore(0x60, 0x100)
 13225 |     |             mstore(0x80, 0x140)
 13226 |     |             writeString(0xa0, p0)
 13227 |     |             writeString(0xe0, p1)
 13228 |     |             writeString(0x120, p2)
 13229 |     |             writeString(0x160, p3)
 13230 |     |         }
 13231 |     |         _sendLogPayload(0x1c, 0x184);
 13232 |     |         assembly {
 13233 |     |             mstore(0x00, m0)
 13234 |     |             mstore(0x20, m1)
 13235 |     |             mstore(0x40, m2)
 13236 |     |             mstore(0x60, m3)
 13237 |     |             mstore(0x80, m4)
 13238 |     |             mstore(0xa0, m5)
 13239 |     |             mstore(0xc0, m6)
 13240 |     |             mstore(0xe0, m7)
 13241 |     |             mstore(0x100, m8)
 13242 |     |             mstore(0x120, m9)
 13243 |     |             mstore(0x140, m10)
 13244 |     |             mstore(0x160, m11)
 13245 |     |             mstore(0x180, m12)
 13246 |     |         }
 13247 |     |     }
 13248 |     | }
 13249 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/FuzzBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {Fuzzlib} from "./Fuzzlib.sol";
  5 |     | import {PlatformCrytic} from "./platform/PlatformCrytic.sol";
  6 |     | 
  7 |     | abstract contract FuzzBase {
  8 |     |     Fuzzlib internal fl = new Fuzzlib();
  9 |     | 
 10 |     |     constructor() {
 11 |     |         fl.setPlatform(address(new PlatformCrytic()));
 12 |     |     }
 13 |     | }
 14 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/FuzzLibString.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | /// @notice Efficient library for creating string representations of integers.
   5 |     | /// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)
   6 |     | /// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)
   7 |     | /// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | library FuzzLibString {
   9 |     |     bytes16 internal constant HEX_DIGITS = "0123456789abcdef";
  10 |     | 
  11 |     |     function toString(int256 value) internal pure returns (string memory str) {
  12 |     |         uint256 absValue = value >= 0 ? uint256(value) : uint256(-value);
  13 |     |         str = toString(absValue);
  14 |     | 
  15 |     |         if (value < 0) {
  16 |     |             str = string(abi.encodePacked("-", str));
  17 |     |         }
  18 |     |     }
  19 |     | 
  20 | *   |     function toString(uint256 value) internal pure returns (string memory str) {
  21 |     |         /// @solidity memory-safe-assembly
  22 |     |         assembly {
  23 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes
  24 |     |             // to keep the free memory pointer word aligned. We'll need 1 word for the length, 1 word for the
  25 |     |             // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.
  26 | *   |             let newFreeMemoryPointer := add(mload(0x40), 160)
  27 |     | 
  28 |     |             // Update the free memory pointer to avoid overriding our string.
  29 | *   |             mstore(0x40, newFreeMemoryPointer)
  30 |     | 
  31 |     |             // Assign str to the end of the zone of newly allocated memory.
  32 | *   |             str := sub(newFreeMemoryPointer, 32)
  33 |     | 
  34 |     |             // Clean the last word of memory it may not be overwritten.
  35 | *   |             mstore(str, 0)
  36 |     | 
  37 |     |             // Cache the end of the memory to calculate the length later.
  38 | *   |             let end := str
  39 |     | 
  40 |     |             // We write the string from rightmost digit to leftmost digit.
  41 |     |             // The following is essentially a do-while loop that also handles the zero case.
  42 |     |             // prettier-ignore
  43 | *   |             for { let temp := value } 1 {} {
  44 |     |                 // Move the pointer 1 byte to the left.
  45 | *   |                 str := sub(str, 1)
  46 |     | 
  47 |     |                 // Write the character to the pointer.
  48 |     |                 // The ASCII index of the '0' character is 48.
  49 | *   |                 mstore8(str, add(48, mod(temp, 10)))
  50 |     | 
  51 |     |                 // Keep dividing temp until zero.
  52 | *   |                 temp := div(temp, 10)
  53 |     | 
  54 |     |                  // prettier-ignore
  55 | *   |                 if iszero(temp) { break }
  56 |     |             }
  57 |     | 
  58 |     |             // Compute and cache the final total length of the string.
  59 | *   |             let length := sub(end, str)
  60 |     | 
  61 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
  62 | *   |             str := sub(str, 32)
  63 |     | 
  64 |     |             // Store the string's length at the start of memory allocated for our string.
  65 | *   |             mstore(str, length)
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     function toString(address value) internal pure returns (string memory str) {
  70 |     |         bytes memory s = new bytes(40);
  71 |     |         for (uint256 i = 0; i < 20; i++) {
  72 |     |             bytes1 b = bytes1(
  73 |     |                 uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))
  74 |     |             );
  75 |     |             bytes1 hi = bytes1(uint8(b) / 16);
  76 |     |             bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));
  77 |     |             s[2 * i] = char(hi);
  78 |     |             s[2 * i + 1] = char(lo);
  79 |     |         }
  80 |     |         return string(s);
  81 |     |     }
  82 |     | 
  83 | *   |     function char(bytes1 b) internal pure returns (bytes1 c) {
  84 | *   |         if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);
  85 |     |         else return bytes1(uint8(b) + 0x57);
  86 |     |     }
  87 |     | 
  88 |     |     // based on OZ's toHexString
  89 |     |     // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol
  90 |     |     function toHexString(bytes memory value)
  91 |     |         internal
  92 |     |         pure
  93 |     |         returns (string memory)
  94 |     |     {
  95 |     |         bytes memory buffer = new bytes(2 * value.length + 2);
  96 |     |         buffer[0] = "0";
  97 |     |         buffer[1] = "x";
  98 |     |         for (uint256 i = 0; i < value.length; i++) {
  99 |     |             uint8 valueByte = uint8(value[i]);
 100 |     |             buffer[2 * i + 2] = HEX_DIGITS[valueByte >> 4];
 101 |     |             buffer[2 * i + 3] = HEX_DIGITS[valueByte & 0xf];
 102 |     |         }
 103 |     |         return string(buffer);
 104 |     |     }
 105 |     | 
 106 |     |     // https://ethereum.stackexchange.com/a/83577
 107 |     |     function getRevertMsg(bytes memory returnData)
 108 |     |         internal
 109 |     |         pure
 110 |     |         returns (string memory)
 111 |     |     {
 112 |     |         // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code
 113 |     |         if (returnData.length == 4 + 32) {
 114 |     |             // Check that the data starts with the Panic signature
 115 |     |             bytes4 panicSignature = bytes4(keccak256(bytes("Panic(uint256)")));
 116 |     |             for (uint256 i = 0; i < 4; i++) {
 117 |     |                 if (returnData[i] != panicSignature[i])
 118 |     |                     return "Undefined signature";
 119 |     |             }
 120 |     | 
 121 |     |             uint256 panicCode;
 122 |     |             for (uint256 i = 4; i < 36; i++) {
 123 |     |                 panicCode = panicCode << 8;
 124 |     |                 panicCode |= uint8(returnData[i]);
 125 |     |             }
 126 |     | 
 127 |     |             // Now convert the panic code into its string representation
 128 |     |             if (panicCode == 17) {
 129 |     |                 return "Panic(17)";
 130 |     |             }
 131 |     | 
 132 |     |             // Add other panic codes as needed or return a generic "Unknown panic"
 133 |     |             return "Undefined panic code";
 134 |     |         }
 135 |     | 
 136 |     |         // If the returnData length is less than 68, then the transaction failed silently (without a revert message)
 137 |     |         if (returnData.length < 68) return "Transaction reverted silently";
 138 |     | 
 139 |     |         assembly {
 140 |     |             // Slice the sighash.
 141 |     |             returnData := add(returnData, 0x04)
 142 |     |         }
 143 |     |         return abi.decode(returnData, (string)); // All that remains is the revert string
 144 |     |     }
 145 |     | 
 146 |     |     function isRevertReasonEqual(bytes memory returnData, string memory reason)
 147 |     |         internal
 148 |     |         pure
 149 |     |         returns (bool)
 150 |     |     {
 151 |     |         return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==
 152 |     |             keccak256(abi.encodePacked(reason)));
 153 |     |     }
 154 |     | }
 155 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/Fuzzlib.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {HelperBase} from "./helpers/HelperBase.sol";
  5 |     | import {HelperAssert} from "./helpers/HelperAssert.sol";
  6 |     | import {HelperClamp} from "./helpers/HelperClamp.sol";
  7 |     | import {HelperLog} from "./helpers/HelperLog.sol";
  8 |     | import {HelperMath} from "./helpers/HelperMath.sol";
  9 |     | import {HelperRandom} from "./helpers/HelperRandom.sol";
 10 |     | 
 11 | *   | contract Fuzzlib is
 12 |     |     HelperBase,
 13 |     |     HelperAssert,
 14 |     |     HelperClamp,
 15 |     |     HelperLog,
 16 |     |     HelperMath,
 17 |     |     HelperRandom
 18 |     | {}
 19 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperAssert.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "./HelperBase.sol";
   5 |     | 
   6 |     | import "../FuzzLibString.sol";
   7 |     | 
   8 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   9 |     | abstract contract HelperAssert is HelperBase {
  10 |     |     event AssertFail(string);
  11 |     |     event AssertEqFail(string);
  12 |     |     event AssertNeqFail(string);
  13 |     |     event AssertGteFail(string);
  14 |     |     event AssertGtFail(string);
  15 |     |     event AssertLteFail(string);
  16 |     |     event AssertLtFail(string);
  17 |     | 
  18 |     |     function t(bool b, string memory reason) public {
  19 |     |         if (!b) {
  20 |     |             emit AssertFail(reason);
  21 |     |             platform.assertFail();
  22 |     |         }
  23 |     |     }
  24 |     | 
  25 |     |     /// @notice asserts that a is equal to b. Violations are logged using reason.
  26 |     |     function eq(
  27 |     |         uint256 a,
  28 |     |         uint256 b,
  29 |     |         string memory reason
  30 |     |     ) public {
  31 |     |         if (a != b) {
  32 |     |             string memory aStr = FuzzLibString.toString(a);
  33 |     |             string memory bStr = FuzzLibString.toString(b);
  34 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  35 |     |             emit AssertEqFail(assertMsg);
  36 |     |             platform.assertFail();
  37 |     |         }
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of eq
  41 |     |     function eq(
  42 |     |         int256 a,
  43 |     |         int256 b,
  44 |     |         string memory reason
  45 |     |     ) public {
  46 |     |         if (a != b) {
  47 |     |             string memory aStr = FuzzLibString.toString(a);
  48 |     |             string memory bStr = FuzzLibString.toString(b);
  49 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  50 |     |            emit AssertEqFail(assertMsg);
  51 |     |             platform.assertFail();
  52 |     |         }
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice bool version of eq
  56 |     |     function eq(
  57 |     |         bool a,
  58 |     |         bool b,
  59 |     |         string memory reason
  60 |     |     ) public {
  61 |     |         if (a != b) {
  62 |     |             string memory aStr = a ? "true" : "false";
  63 |     |             string memory bStr = b ? "true" : "false";
  64 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  65 |     |             emit AssertEqFail(assertMsg);
  66 |     |             platform.assertFail();
  67 |     |         }
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice address version of eq
  71 |     |     function eq(
  72 |     |         address a,
  73 |     |         address b,
  74 |     |         string memory reason
  75 |     |     ) public {
  76 |     |         if (a != b) {
  77 |     |             string memory aStr = FuzzLibString.toString(a);
  78 |     |             string memory bStr = FuzzLibString.toString(b);
  79 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  80 |     |             emit AssertEqFail(assertMsg);
  81 |     |             platform.assertFail();
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice bytes4 version of eq
  86 |     |     function eq(
  87 |     |         bytes4 a,
  88 |     |         bytes4 b,
  89 |     |         string memory reason
  90 |     |     ) public {
  91 |     |         if (a != b) {
  92 |     |             bytes memory aBytes = abi.encodePacked(a);
  93 |     |             bytes memory bBytes = abi.encodePacked(b);
  94 |     |             string memory aStr = FuzzLibString.toHexString(aBytes);
  95 |     |             string memory bStr = FuzzLibString.toHexString(bBytes);
  96 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "!=", reason);
  97 |     |             emit AssertEqFail(assertMsg);
  98 |     |             platform.assertFail();
  99 |     |         }
 100 |     |     }
 101 |     | 
 102 |     |     /// @notice asserts that a is not equal to b. Violations are logged using reason.
 103 |     |     function neq(
 104 |     |         uint256 a,
 105 |     |         uint256 b,
 106 |     |         string memory reason
 107 |     |     ) public {
 108 |     |         if (a == b) {
 109 |     |             string memory aStr = FuzzLibString.toString(a);
 110 |     |             string memory bStr = FuzzLibString.toString(b);
 111 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 112 |     |             emit AssertNeqFail(assertMsg);
 113 |     |             platform.assertFail();
 114 |     |         }
 115 |     |     }
 116 |     | 
 117 |     |     /// @notice int256 version of neq
 118 |     |     function neq(
 119 |     |         int256 a,
 120 |     |         int256 b,
 121 |     |         string memory reason
 122 |     |     ) public {
 123 |     |         if (a == b) {
 124 |     |             string memory aStr = FuzzLibString.toString(a);
 125 |     |             string memory bStr = FuzzLibString.toString(b);
 126 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "==", reason);
 127 |     |             emit AssertNeqFail(assertMsg);
 128 |     |             platform.assertFail();
 129 |     |         }
 130 |     |     }
 131 |     | 
 132 |     |     /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.
 133 |     |     function gte(
 134 |     |         uint256 a,
 135 |     |         uint256 b,
 136 |     |         string memory reason
 137 |     |     ) public {
 138 |     |         if (!(a >= b)) {
 139 |     |             string memory aStr = FuzzLibString.toString(a);
 140 |     |             string memory bStr = FuzzLibString.toString(b);
 141 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 142 |     |             emit AssertGteFail(assertMsg);
 143 |     |             platform.assertFail();
 144 |     |         }
 145 |     |     }
 146 |     | 
 147 |     |     /// @notice int256 version of gte
 148 |     |     function gte(
 149 |     |         int256 a,
 150 |     |         int256 b,
 151 |     |         string memory reason
 152 |     |     ) public {
 153 |     |         if (!(a >= b)) {
 154 |     |             string memory aStr = FuzzLibString.toString(a);
 155 |     |             string memory bStr = FuzzLibString.toString(b);
 156 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<", reason);
 157 |     |             emit AssertGteFail(assertMsg);
 158 |     |             platform.assertFail();
 159 |     |         }
 160 |     |     }
 161 |     | 
 162 |     |     /// @notice asserts that a is greater than b. Violations are logged using reason.
 163 |     |     function gt(
 164 |     |         uint256 a,
 165 |     |         uint256 b,
 166 |     |         string memory reason
 167 |     |     ) public {
 168 |     |         if (!(a > b)) {
 169 |     |             string memory aStr = FuzzLibString.toString(a);
 170 |     |             string memory bStr = FuzzLibString.toString(b);
 171 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 172 |     |             emit AssertGtFail(assertMsg);
 173 |     |             platform.assertFail();
 174 |     |         }
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice int256 version of gt
 178 |     |     function gt(
 179 |     |         int256 a,
 180 |     |         int256 b,
 181 |     |         string memory reason
 182 |     |     ) public {
 183 |     |         if (!(a > b)) {
 184 |     |             string memory aStr = FuzzLibString.toString(a);
 185 |     |             string memory bStr = FuzzLibString.toString(b);
 186 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, "<=", reason);
 187 |     |             emit AssertGtFail(assertMsg);
 188 |     |             platform.assertFail();
 189 |     |         }
 190 |     |     }
 191 |     | 
 192 |     |     /// @notice asserts that a is less than or equal to b. Violations are logged using reason.
 193 |     |     function lte(
 194 |     |         uint256 a,
 195 |     |         uint256 b,
 196 |     |         string memory reason
 197 |     |     ) public {
 198 |     |         if (!(a <= b)) {
 199 |     |             string memory aStr = FuzzLibString.toString(a);
 200 |     |             string memory bStr = FuzzLibString.toString(b);
 201 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 202 |     |             emit AssertLteFail(assertMsg);
 203 |     |             platform.assertFail();
 204 |     |         }
 205 |     |     }
 206 |     | 
 207 |     |     /// @notice int256 version of lte
 208 |     |     function lte(
 209 |     |         int256 a,
 210 |     |         int256 b,
 211 |     |         string memory reason
 212 |     |     ) public {
 213 |     |         if (!(a <= b)) {
 214 |     |             string memory aStr = FuzzLibString.toString(a);
 215 |     |             string memory bStr = FuzzLibString.toString(b);
 216 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">", reason);
 217 |     |             emit AssertLteFail(assertMsg);
 218 |     |             platform.assertFail();
 219 |     |         }
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice asserts that a is less than b. Violations are logged using reason.
 223 | *   |     function lt(
 224 |     |         uint256 a,
 225 |     |         uint256 b,
 226 |     |         string memory reason
 227 |     |     ) public {
 228 |     |         if (!(a < b)) {
 229 |     |             string memory aStr = FuzzLibString.toString(a);
 230 |     |             string memory bStr = FuzzLibString.toString(b);
 231 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 232 |     |             emit AssertLtFail(assertMsg);
 233 |     |             platform.assertFail();
 234 |     |         }
 235 |     |     }
 236 |     | 
 237 |     |     /// @notice int256 version of lt
 238 |     |     function lt(
 239 |     |         int256 a,
 240 |     |         int256 b,
 241 |     |         string memory reason
 242 |     |     ) public {
 243 |     |         if (!(a < b)) {
 244 |     |             string memory aStr = FuzzLibString.toString(a);
 245 |     |             string memory bStr = FuzzLibString.toString(b);
 246 |     |             string memory assertMsg = createAssertFailMessage(aStr, bStr, ">=", reason);
 247 |     |             emit AssertLtFail(assertMsg);
 248 |     |             platform.assertFail();
 249 |     |         }
 250 |     |     }
 251 |     | 
 252 |     |     function assertRevertReasonNotEqual(
 253 |     |         bytes memory returnData,
 254 |     |         string memory reason
 255 |     |     ) public {
 256 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 257 |     |         t(!isEqual, reason);
 258 |     |     }
 259 |     | 
 260 |     |     function assertRevertReasonEqual(
 261 |     |         bytes memory returnData,
 262 |     |         string memory reason
 263 |     |     ) public {
 264 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);
 265 |     |         t(isEqual, reason);
 266 |     |     }
 267 |     | 
 268 |     |     function assertRevertReasonEqual(
 269 |     |         bytes memory returnData,
 270 |     |         string memory reason1,
 271 |     |         string memory reason2
 272 |     |     ) public {
 273 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 274 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2);
 275 |     |         string memory assertMsg = string(
 276 |     |             abi.encodePacked(reason1, " OR ", reason2)
 277 |     |         );
 278 |     |         t(isEqual, assertMsg);
 279 |     |     }
 280 |     | 
 281 |     |     function assertRevertReasonEqual(
 282 |     |         bytes memory returnData,
 283 |     |         string memory reason1,
 284 |     |         string memory reason2,
 285 |     |         string memory reason3
 286 |     |     ) public {
 287 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 288 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 289 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3);
 290 |     |         string memory assertMsg = string(
 291 |     |             abi.encodePacked(reason1, " OR ", reason2, " OR ", reason3)
 292 |     |         );
 293 |     |         t(isEqual, assertMsg);
 294 |     |     }
 295 |     | 
 296 |     |     function assertRevertReasonEqual(
 297 |     |         bytes memory returnData,
 298 |     |         string memory reason1,
 299 |     |         string memory reason2,
 300 |     |         string memory reason3,
 301 |     |         string memory reason4
 302 |     |     ) public {
 303 |     |         bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||
 304 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason2) ||
 305 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason3) ||
 306 |     |             FuzzLibString.isRevertReasonEqual(returnData, reason4);
 307 |     |         string memory assertMsg = string(
 308 |     |             abi.encodePacked(
 309 |     |                 reason1,
 310 |     |                 " OR ",
 311 |     |                 reason2,
 312 |     |                 " OR ",
 313 |     |                 reason3,
 314 |     |                 " OR ",
 315 |     |                 reason4
 316 |     |             )
 317 |     |         );
 318 |     |         t(isEqual, assertMsg);
 319 |     |     }
 320 |     | 
 321 |     |     function errAllow(
 322 |     |         bytes4 errorSelector,
 323 |     |         bytes4[] memory allowedErrors,
 324 |     |         string memory message
 325 |     |     ) public {
 326 |     |         bool allowed = false;
 327 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 328 |     |             if (errorSelector == allowedErrors[i]) {
 329 |     |                 allowed = true;
 330 |     |                 break;
 331 |     |             }
 332 |     |         }
 333 |     |         t(allowed, message);
 334 |     |     }
 335 |     | 
 336 |     |     function errsAllow(
 337 |     |         bytes4 errorSelector,
 338 |     |         bytes4[] memory allowedErrors,
 339 |     |         string[] memory messages
 340 |     |     ) public {
 341 |     |         bool allowed = false;
 342 |     |         uint256 passIndex = 0;
 343 |     |         for (uint256 i = 0; i < allowedErrors.length; i++) {
 344 |     |             if (errorSelector == allowedErrors[i]) {
 345 |     |                 allowed = true;
 346 |     |                 passIndex = i;
 347 |     |                 break;
 348 |     |             }
 349 |     |         }
 350 |     |         t(allowed, messages[passIndex]);
 351 |     |     }
 352 |     | 
 353 |     |     function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {
 354 |     |         return string(abi.encodePacked("Invalid: ", aStr, operator, bStr, ", reason: ", reason));
 355 |     |     }
 356 |     | 
 357 |     | }
 358 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperBase.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {IPlatform} from "../platform/IPlatform.sol";
  5 |     | 
  6 |     | contract HelperBase {
  7 |     |     IPlatform public platform;
  8 |     | 
  9 |     |     function setPlatform(address _platform) public {
 10 |     |         platform = IPlatform(_platform);
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperClamp.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import "../FuzzLibString.sol";
   5 |     | import "./HelperAssert.sol";
   6 |     | 
   7 |     | /// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)
   8 |     | abstract contract HelperClamp is HelperAssert {
   9 |     |     event Clamped(string);
  10 |     | 
  11 |     |     /*
  12 |     |      **************************************************************************
  13 |     |      * Clamp functions with logging enabled
  14 |     |      **************************************************************************
  15 |     |      */
  16 |     | 
  17 |     |     /// @notice Clamps value to be between low and high, both inclusive
  18 | *   |     function clamp(
  19 |     |         uint256 value,
  20 |     |         uint256 low,
  21 |     |         uint256 high
  22 | *   |     ) public returns (uint256) {
  23 | *   |         return clamp(value, low, high, true);
  24 |     |     }
  25 |     | 
  26 |     |     /// @notice int256 version of clamp
  27 |     |     function clamp(
  28 |     |         int256 value,
  29 |     |         int256 low,
  30 |     |         int256 high
  31 |     |     ) public returns (int256) {
  32 |     |         return clamp(value, low, high, true);
  33 |     |     }
  34 |     | 
  35 |     |     /// @notice clamps a to be less than b
  36 |     |     function clampLt(uint256 a, uint256 b) public returns (uint256) {
  37 |     |         return clampLt(a, b);
  38 |     |     }
  39 |     | 
  40 |     |     /// @notice int256 version of clampLt
  41 |     |     function clampLt(int256 a, int256 b) public returns (int256) {
  42 |     |         return clampLt(a, b, true);
  43 |     |     }
  44 |     | 
  45 |     |     /// @notice clamps a to be less than or equal to b
  46 |     |     function clampLte(uint256 a, uint256 b) public returns (uint256) {
  47 |     |         return clampLte(a, b, true);
  48 |     |     }
  49 |     | 
  50 |     |     /// @notice int256 version of clampLte
  51 |     |     function clampLte(int256 a, int256 b) public returns (int256) {
  52 |     |         return clampLte(a, b, true);
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice clamps a to be greater than b
  56 |     |     function clampGt(uint256 a, uint256 b) public returns (uint256) {
  57 |     |         return clampGt(a, b, true);
  58 |     |     }
  59 |     | 
  60 |     |     /// @notice int256 version of clampGt
  61 |     |     function clampGt(int256 a, int256 b) public returns (int256) {
  62 |     |         return clampGt(a, b, true);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice clamps a to be greater than or equal to b
  66 |     |     function clampGte(uint256 a, uint256 b) public returns (uint256) {
  67 |     |         return clampGte(a, b, true);
  68 |     |     }
  69 |     | 
  70 |     |     /// @notice int256 version of clampGte
  71 |     |     function clampGte(int256 a, int256 b) public returns (int256) {
  72 |     |         return clampGte(a, b, true);
  73 |     |     }
  74 |     | 
  75 |     |     /*
  76 |     |      **************************************************************************
  77 |     |      * Clamp functions with optional logging
  78 |     |      **************************************************************************
  79 |     |      */
  80 |     | 
  81 |     |     /// @notice Clamps value to be between low and high, both inclusive
  82 | *   |     function clamp(
  83 |     |         uint256 value,
  84 |     |         uint256 low,
  85 |     |         uint256 high,
  86 |     |         bool enableLogs
  87 | *   |     ) public returns (uint256) {
  88 | *   |         if (value < low || value > high) {
  89 | *   |             uint256 ans = low + (value % (high - low + 1));
  90 | *   |             if (enableLogs) {
  91 | *   |                 string memory valueStr = FuzzLibString.toString(value);
  92 | *   |                 string memory ansStr = FuzzLibString.toString(ans);
  93 | *   |                 bytes memory message = abi.encodePacked(
  94 |     |                     "Clamping value ",
  95 | *   |                     valueStr,
  96 |     |                     " to ",
  97 | *   |                     ansStr
  98 |     |                 );
  99 | *   |                 emit Clamped(string(message));
 100 |     |             }
 101 | *   |             return ans;
 102 |     |         }
 103 | *   |         return value;
 104 |     |     }
 105 |     | 
 106 |     |     /// @notice int256 version of clamp
 107 |     |     function clamp(
 108 |     |         int256 value,
 109 |     |         int256 low,
 110 |     |         int256 high,
 111 |     |         bool enableLogs
 112 |     |     ) public returns (int256) {
 113 |     |         if (value < low || value > high) {
 114 |     |             int256 range = high - low + 1;
 115 |     |             int256 clamped = (value - low) % (range);
 116 |     |             if (clamped < 0) clamped += range;
 117 |     |             int256 ans = low + clamped;
 118 |     |             if (enableLogs) {
 119 |     |                 string memory valueStr = FuzzLibString.toString(value);
 120 |     |                 string memory ansStr = FuzzLibString.toString(ans);
 121 |     |                 bytes memory message = abi.encodePacked(
 122 |     |                     "Clamping value ",
 123 |     |                     valueStr,
 124 |     |                     " to ",
 125 |     |                     ansStr
 126 |     |                 );
 127 |     |                 emit Clamped(string(message));
 128 |     |             }
 129 |     |             return ans;
 130 |     |         }
 131 |     |         return value;
 132 |     |     }
 133 |     | 
 134 |     |     /// @notice clamps a to be less than b
 135 |     |     function clampLt(
 136 |     |         uint256 a,
 137 |     |         uint256 b,
 138 |     |         bool enableLogs
 139 |     |     ) public returns (uint256) {
 140 |     |         if (!(a < b)) {
 141 |     |             neq(
 142 |     |                 b,
 143 |     |                 0,
 144 |     |                 "clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions."
 145 |     |             );
 146 |     |             uint256 value = a % b;
 147 |     |             if (enableLogs) {
 148 |     |                 string memory aStr = FuzzLibString.toString(a);
 149 |     |                 string memory valueStr = FuzzLibString.toString(value);
 150 |     |                 bytes memory message = abi.encodePacked(
 151 |     |                     "Clamping value ",
 152 |     |                     aStr,
 153 |     |                     " to ",
 154 |     |                     valueStr
 155 |     |                 );
 156 |     |                 emit Clamped(string(message));
 157 |     |             }
 158 |     |             return value;
 159 |     |         }
 160 |     |         return a;
 161 |     |     }
 162 |     | 
 163 |     |     /// @notice int256 version of clampLt
 164 |     |     function clampLt(
 165 |     |         int256 a,
 166 |     |         int256 b,
 167 |     |         bool enableLogs
 168 |     |     ) public returns (int256) {
 169 |     |         if (!(a < b)) {
 170 |     |             int256 value = b - 1;
 171 |     |             if (enableLogs) {
 172 |     |                 string memory aStr = FuzzLibString.toString(a);
 173 |     |                 string memory valueStr = FuzzLibString.toString(value);
 174 |     |                 bytes memory message = abi.encodePacked(
 175 |     |                     "Clamping value ",
 176 |     |                     aStr,
 177 |     |                     " to ",
 178 |     |                     valueStr
 179 |     |                 );
 180 |     |                 emit Clamped(string(message));
 181 |     |             }
 182 |     |             return value;
 183 |     |         }
 184 |     |         return a;
 185 |     |     }
 186 |     | 
 187 |     |     /// @notice clamps a to be less than or equal to b
 188 |     |     function clampLte(
 189 |     |         uint256 a,
 190 |     |         uint256 b,
 191 |     |         bool enableLogs
 192 |     |     ) public returns (uint256) {
 193 |     |         if (!(a <= b)) {
 194 |     |             uint256 value = a % (b + 1);
 195 |     |             if (enableLogs) {
 196 |     |                 string memory aStr = FuzzLibString.toString(a);
 197 |     |                 string memory valueStr = FuzzLibString.toString(value);
 198 |     |                 bytes memory message = abi.encodePacked(
 199 |     |                     "Clamping value ",
 200 |     |                     aStr,
 201 |     |                     " to ",
 202 |     |                     valueStr
 203 |     |                 );
 204 |     |                 emit Clamped(string(message));
 205 |     |             }
 206 |     |             return value;
 207 |     |         }
 208 |     |         return a;
 209 |     |     }
 210 |     | 
 211 |     |     /// @notice int256 version of clampLte
 212 | *   |     function clampLte(
 213 |     |         int256 a,
 214 |     |         int256 b,
 215 |     |         bool enableLogs
 216 |     |     ) public returns (int256) {
 217 |     |         if (!(a <= b)) {
 218 |     |             int256 value = b;
 219 |     |             if (enableLogs) {
 220 |     |                 string memory aStr = FuzzLibString.toString(a);
 221 |     |                 string memory valueStr = FuzzLibString.toString(value);
 222 |     |                 bytes memory message = abi.encodePacked(
 223 |     |                     "Clamping value ",
 224 |     |                     aStr,
 225 |     |                     " to ",
 226 |     |                     valueStr
 227 |     |                 );
 228 |     |                 emit Clamped(string(message));
 229 |     |             }
 230 |     |             return value;
 231 |     |         }
 232 |     |         return a;
 233 |     |     }
 234 |     | 
 235 |     |     /// @notice clamps a to be greater than b
 236 |     |     function clampGt(
 237 |     |         uint256 a,
 238 |     |         uint256 b,
 239 |     |         bool enableLogs
 240 |     |     ) public returns (uint256) {
 241 |     |         if (!(a > b)) {
 242 |     |             neq(
 243 |     |                 b,
 244 |     |                 type(uint256).max,
 245 |     |                 "clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions."
 246 |     |             );
 247 |     |             uint256 value = b + 1;
 248 |     |             if (enableLogs) {
 249 |     |                 string memory aStr = FuzzLibString.toString(a);
 250 |     |                 string memory valueStr = FuzzLibString.toString(value);
 251 |     |                 bytes memory message = abi.encodePacked(
 252 |     |                     "Clamping value ",
 253 |     |                     aStr,
 254 |     |                     " to ",
 255 |     |                     valueStr
 256 |     |                 );
 257 |     |                 emit Clamped(string(message));
 258 |     |             }
 259 |     |             return value;
 260 |     |         } else {
 261 |     |             return a;
 262 |     |         }
 263 |     |     }
 264 |     | 
 265 |     |     /// @notice int256 version of clampGt
 266 |     |     function clampGt(
 267 |     |         int256 a,
 268 |     |         int256 b,
 269 |     |         bool enableLogs
 270 |     |     ) public returns (int256) {
 271 |     |         if (!(a > b)) {
 272 |     |             int256 value = b + 1;
 273 |     |             if (enableLogs) {
 274 |     |                 string memory aStr = FuzzLibString.toString(a);
 275 |     |                 string memory valueStr = FuzzLibString.toString(value);
 276 |     |                 bytes memory message = abi.encodePacked(
 277 |     |                     "Clamping value ",
 278 |     |                     aStr,
 279 |     |                     " to ",
 280 |     |                     valueStr
 281 |     |                 );
 282 |     |                 emit Clamped(string(message));
 283 |     |             }
 284 |     |             return value;
 285 |     |         } else {
 286 |     |             return a;
 287 |     |         }
 288 |     |     }
 289 |     | 
 290 |     |     /// @notice clamps a to be greater than or equal to b
 291 |     |     function clampGte(
 292 |     |         uint256 a,
 293 |     |         uint256 b,
 294 |     |         bool enableLogs
 295 |     |     ) public returns (uint256) {
 296 |     |         if (!(a > b)) {
 297 |     |             uint256 value = b;
 298 |     |             if (enableLogs) {
 299 |     |                 string memory aStr = FuzzLibString.toString(a);
 300 |     |                 string memory valueStr = FuzzLibString.toString(value);
 301 |     |                 bytes memory message = abi.encodePacked(
 302 |     |                     "Clamping value ",
 303 |     |                     aStr,
 304 |     |                     " to ",
 305 |     |                     valueStr
 306 |     |                 );
 307 |     |                 emit Clamped(string(message));
 308 |     |             }
 309 |     |             return value;
 310 |     |         }
 311 |     |         return a;
 312 |     |     }
 313 |     | 
 314 |     |     /// @notice int256 version of clampGte
 315 |     |     function clampGte(
 316 |     |         int256 a,
 317 |     |         int256 b,
 318 |     |         bool enableLogs
 319 |     |     ) public returns (int256) {
 320 |     |         if (!(a > b)) {
 321 |     |             int256 value = b;
 322 |     |             if (enableLogs) {
 323 |     |                 string memory aStr = FuzzLibString.toString(a);
 324 |     |                 string memory valueStr = FuzzLibString.toString(value);
 325 |     |                 bytes memory message = abi.encodePacked(
 326 |     |                     "Clamping value ",
 327 |     |                     aStr,
 328 |     |                     " to ",
 329 |     |                     valueStr
 330 |     |                 );
 331 |     |                 emit Clamped(string(message));
 332 |     |             }
 333 |     |             return value;
 334 |     |         }
 335 |     |         return a;
 336 |     |     }
 337 |     | }
 338 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import {LibLog} from "../libraries/LibLog.sol";
  5 |     | 
  6 |     | abstract contract HelperLog {
  7 |     |     function log(string memory message) public {
  8 |     |         LibLog.log(message);
  9 |     |     }
 10 |     | 
 11 |     |     function log(string memory message, string memory data) public {
 12 |     |         LibLog.log(message, data);
 13 |     |     }
 14 |     | 
 15 |     |     function log(string memory message, bytes memory data) public {
 16 |     |         LibLog.log(message, data);
 17 |     |     }
 18 |     | 
 19 |     |     function log(string memory message, uint256 data) public {
 20 |     |         LibLog.log(message, data);
 21 |     |     }
 22 |     | 
 23 |     |     function log(string memory message, int256 data) public {
 24 |     |         LibLog.log(message, data);
 25 |     |     }
 26 |     | 
 27 | *   |     function log(string memory message, address data) public {
 28 | *   |         LibLog.log(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bool data) public {
 32 |     |         LibLog.log(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, bytes32 data) public {
 36 |     |         LibLog.log(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function logFail() public {
 40 |     |         LibLog.logFail();
 41 |     |     }
 42 |     | 
 43 |     |     function logFail(string memory message) public {
 44 |     |         LibLog.logFail(message);
 45 |     |     }
 46 |     | 
 47 |     |     function logFail(string memory message, string memory data) public {
 48 |     |         LibLog.logFail(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function logFail(string memory message, bytes memory data) public {
 52 |     |         LibLog.logFail(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail(string memory message, uint256 data) public {
 56 |     |         LibLog.logFail(message, data);
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message, int256 data) public {
 60 |     |         LibLog.logFail(message, data);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, address data) public {
 64 |     |         LibLog.logFail(message, data);
 65 |     |     }
 66 |     | 
 67 | *   |     function logFail(string memory message, bool data) public {
 68 | *   |         LibLog.logFail(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, bytes32 data) public {
 72 |     |         LibLog.log(message, data);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperMath {
  5 |     |     function min(uint256 a, uint256 b) public pure returns (uint256) {
  6 |     |         return a < b ? a : b;
  7 |     |     }
  8 |     | 
  9 |     |     function max(uint256 a, uint256 b) public pure returns (uint256) {
 10 |     |         return a > b ? a : b;
 11 |     |     }
 12 |     | 
 13 |     |     // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol
 14 |     |     function max(int256 a, int256 b) public pure returns (int256) {
 15 |     |         return a > b ? a : b;
 16 |     |     }
 17 |     | 
 18 |     |     // Forked with modifications from https://ethereum.stackexchange.com/a/84391
 19 |     |     function abs(int128 n) public pure returns (int128) {
 20 |     |         return n >= 0 ? n : -n;
 21 |     |     }
 22 |     | 
 23 | *   |     function abs(int256 n) public pure returns (uint256) {
 24 | *   |         return n >= 0 ? uint256(n) : uint256(-n);
 25 |     |     }
 26 |     | 
 27 |     |     function diff(int256 a, int256 b) public pure returns (uint256) {
 28 |     |         return a >= b ? uint256(a - b) : uint256(b - a);
 29 |     |     }
 30 |     | 
 31 |     |     function diff(uint256 a, uint256 b) public pure returns (uint256) {
 32 |     |         return a >= b ? a - b : b - a;
 33 |     |     }
 34 |     | }
 35 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperRandom.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | abstract contract HelperRandom {
  5 |     |     /// @notice Shuffle an array using Fisher-Yates algorithm
  6 |     |     /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18
  7 |     |     function shuffleArray(
  8 |     |         uint256[] memory shuffle,
  9 |     |         uint256 entropy
 10 |     |     ) public pure {
 11 |     |         for (uint256 i = shuffle.length - 1; i > 0; i--) {
 12 |     |             uint256 swapIndex = entropy % (shuffle.length - i);
 13 |     | 
 14 |     |             uint256 currentIndex = shuffle[i];
 15 |     |             uint256 indexToSwap = shuffle[swapIndex];
 16 |     | 
 17 |     |             shuffle[i] = indexToSwap;
 18 |     |             shuffle[swapIndex] = currentIndex;
 19 |     |         }
 20 |     |     }
 21 |     | }
 22 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/libraries/LibLog.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | library LibLog {
  5 |     |     event Log(string message);
  6 |     |     event LogString(string message, string data);
  7 |     |     event LogBytes(string message, bytes data);
  8 |     |     event LogUint(string message, uint256 data);
  9 |     |     event LogInt(string message, int256 data);
 10 |     |     event LogAddress(string message, address data);
 11 |     |     event LogBool(string message, bool data);
 12 |     |     event LogBytes32(string message, bytes32 data);
 13 |     | 
 14 |     |     event AssertionFailed();
 15 |     |     event AssertionFailed(string message);
 16 |     |     event AssertionFailed(string message, string data);
 17 |     |     event AssertionFailed(string message, bytes data);
 18 |     |     event AssertionFailed(string message, uint256 data);
 19 |     |     event AssertionFailed(string message, int256 data);
 20 |     |     event AssertionFailed(string message, address data);
 21 |     |     event AssertionFailed(string message, bool data);
 22 |     | 
 23 |     |     function log(string memory message) internal {
 24 |     |         emit Log(message);
 25 |     |     }
 26 |     | 
 27 |     |     function log(string memory message, string memory data) internal {
 28 |     |         emit LogString(message, data);
 29 |     |     }
 30 |     | 
 31 |     |     function log(string memory message, bytes memory data) internal {
 32 |     |         emit LogBytes(message, data);
 33 |     |     }
 34 |     | 
 35 |     |     function log(string memory message, uint256 data) internal {
 36 |     |         emit LogUint(message, data);
 37 |     |     }
 38 |     | 
 39 |     |     function log(string memory message, int256 data) internal {
 40 |     |         emit LogInt(message, data);
 41 |     |     }
 42 |     | 
 43 | *   |     function log(string memory message, address data) internal {
 44 | *   |         emit LogAddress(message, data);
 45 |     |     }
 46 |     | 
 47 |     |     function log(string memory message, bool data) internal {
 48 |     |         emit LogBool(message, data);
 49 |     |     }
 50 |     | 
 51 |     |     function log(string memory message, bytes32 data) internal {
 52 |     |         emit LogBytes32(message, data);
 53 |     |     }
 54 |     | 
 55 |     |     function logFail() internal {
 56 |     |         emit AssertionFailed();
 57 |     |     }
 58 |     | 
 59 |     |     function logFail(string memory message) internal {
 60 |     |         emit AssertionFailed(message);
 61 |     |     }
 62 |     | 
 63 |     |     function logFail(string memory message, string memory data) internal {
 64 |     |         emit AssertionFailed(message, data);
 65 |     |     }
 66 |     | 
 67 |     |     function logFail(string memory message, bytes memory data) internal {
 68 |     |         emit AssertionFailed(message, data);
 69 |     |     }
 70 |     | 
 71 |     |     function logFail(string memory message, uint256 data) internal {
 72 |     |         emit AssertionFailed(message, data);
 73 |     |     }
 74 |     | 
 75 |     |     function logFail(string memory message, int256 data) internal {
 76 |     |         emit AssertionFailed(message, data);
 77 |     |     }
 78 |     | 
 79 |     |     function logFail(string memory message, address data) internal {
 80 |     |         emit AssertionFailed(message, data);
 81 |     |     }
 82 |     | 
 83 | *   |     function logFail(string memory message, bool data) internal {
 84 | *   |         emit AssertionFailed(message, data);
 85 |     |     }
 86 |     | 
 87 |     |     function logFail(string memory message, bytes32 data) internal {
 88 |     |         emit LogBytes32(message, data);
 89 |     |     }
 90 |     | }
 91 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/platform/IPlatform.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | pragma solidity ^0.8.0;
 3 |     | 
 4 |     | interface IPlatform {
 5 |     |     function assertFail() pure external;
 6 |     | }
 7 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/platform/PlatformCrytic.sol
  1 |     | 
  2 |     | // SPDX-License-Identifier: MIT
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | import {IPlatform} from "./IPlatform.sol";
  6 |     | 
  7 |     | contract PlatformCrytic is IPlatform {
  8 |     |     function assertFail() pure public override{
  9 |     |         assert(false);
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | // solhint-disable-next-line interface-starts-with-i
  5 |     | interface AggregatorV3Interface {
  6 |     |   function decimals() external view returns (uint8);
  7 |     | 
  8 |     |   function description() external view returns (string memory);
  9 |     | 
 10 |     |   function version() external view returns (uint256);
 11 |     | 
 12 |     |   function getRoundData(
 13 |     |     uint80 _roundId
 14 |     |   ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
 15 |     | 
 16 |     |   function latestRoundData()
 17 |     |     external
 18 |     |     view
 19 |     |     returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);
 20 |     | }
 21 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/access/Ownable.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../utils/Context.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides a basic access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available the modifier
 17 |     |  * `onlyOwner`, which can be applied to your functions to restrict their use to
 18 |     |  * the owner.
 19 |     |  */
 20 |     | abstract contract Ownable is Context {
 21 |     |     address private _owner;
 22 |     | 
 23 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
 24 |     | 
 25 |     |     /**
 26 |     |      * @dev Initializes the contract setting the deployer as the initial owner.
 27 |     |      */
 28 |     |     constructor() {
 29 |     |         _transferOwnership(_msgSender());
 30 |     |     }
 31 |     | 
 32 |     |     /**
 33 |     |      * @dev Throws if called by any account other than the owner.
 34 |     |      */
 35 |     |     modifier onlyOwner() {
 36 |     |         _checkOwner();
 37 |     |         _;
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Returns the address of the current owner.
 42 |     |      */
 43 |     |     function owner() public view virtual returns (address) {
 44 |     |         return _owner;
 45 |     |     }
 46 |     | 
 47 |     |     /**
 48 |     |      * @dev Throws if the sender is not the owner.
 49 |     |      */
 50 |     |     function _checkOwner() internal view virtual {
 51 |     |         require(owner() == _msgSender(), "Ownable: caller is not the owner");
 52 |     |     }
 53 |     | 
 54 |     |     /**
 55 |     |      * @dev Leaves the contract without owner. It will not be possible to call
 56 |     |      * `onlyOwner` functions. Can only be called by the current owner.
 57 |     |      *
 58 |     |      * NOTE: Renouncing ownership will leave the contract without an owner,
 59 |     |      * thereby disabling any functionality that is only available to the owner.
 60 |     |      */
 61 |     |     function renounceOwnership() public virtual onlyOwner {
 62 |     |         _transferOwnership(address(0));
 63 |     |     }
 64 |     | 
 65 |     |     /**
 66 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 67 |     |      * Can only be called by the current owner.
 68 |     |      */
 69 |     |     function transferOwnership(address newOwner) public virtual onlyOwner {
 70 |     |         require(newOwner != address(0), "Ownable: new owner is the zero address");
 71 |     |         _transferOwnership(newOwner);
 72 |     |     }
 73 |     | 
 74 |     |     /**
 75 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`).
 76 |     |      * Internal function without access restriction.
 77 |     |      */
 78 |     |     function _transferOwnership(address newOwner) internal virtual {
 79 |     |         address oldOwner = _owner;
 80 |     |         _owner = newOwner;
 81 |     |         emit OwnershipTransferred(oldOwner, newOwner);
 82 |     |     }
 83 |     | }
 84 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/access/Ownable2Step.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./Ownable.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Contract module which provides access control mechanism, where
 10 |     |  * there is an account (an owner) that can be granted exclusive access to
 11 |     |  * specific functions.
 12 |     |  *
 13 |     |  * By default, the owner account will be the one that deploys the contract. This
 14 |     |  * can later be changed with {transferOwnership} and {acceptOwnership}.
 15 |     |  *
 16 |     |  * This module is used through inheritance. It will make available all functions
 17 |     |  * from parent (Ownable).
 18 |     |  */
 19 |     | abstract contract Ownable2Step is Ownable {
 20 |     |     address private _pendingOwner;
 21 |     | 
 22 |     |     event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the address of the pending owner.
 26 |     |      */
 27 |     |     function pendingOwner() public view virtual returns (address) {
 28 |     |         return _pendingOwner;
 29 |     |     }
 30 |     | 
 31 |     |     /**
 32 |     |      * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
 33 |     |      * Can only be called by the current owner.
 34 |     |      */
 35 |     |     function transferOwnership(address newOwner) public virtual override onlyOwner {
 36 |     |         _pendingOwner = newOwner;
 37 |     |         emit OwnershipTransferStarted(owner(), newOwner);
 38 |     |     }
 39 |     | 
 40 |     |     /**
 41 |     |      * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
 42 |     |      * Internal function without access restriction.
 43 |     |      */
 44 |     |     function _transferOwnership(address newOwner) internal virtual override {
 45 |     |         delete _pendingOwner;
 46 |     |         super._transferOwnership(newOwner);
 47 |     |     }
 48 |     | 
 49 |     |     /**
 50 |     |      * @dev The new owner accepts the ownership transfer.
 51 |     |      */
 52 |     |     function acceptOwnership() public virtual {
 53 |     |         address sender = _msgSender();
 54 |     |         require(pendingOwner() == sender, "Ownable2Step: caller is not the new owner");
 55 |     |         _transferOwnership(sender);
 56 |     |     }
 57 |     | }
 58 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC20.sol
 1 |     | // SPDX-License-Identifier: MIT
 2 |     | // OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)
 3 |     | 
 4 |     | pragma solidity ^0.8.0;
 5 |     | 
 6 |     | import "../token/ERC20/IERC20.sol";
 7 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../token/ERC20/IERC20.sol";
   7 |     | import "../token/ERC20/extensions/IERC20Metadata.sol";
   8 |     | 
   9 |     | /**
  10 |     |  * @dev Interface of the ERC4626 "Tokenized Vault Standard", as defined in
  11 |     |  * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].
  12 |     |  *
  13 |     |  * _Available since v4.7._
  14 |     |  */
  15 |     | interface IERC4626 is IERC20, IERC20Metadata {
  16 |     |     event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);
  17 |     | 
  18 |     |     event Withdraw(
  19 |     |         address indexed sender,
  20 |     |         address indexed receiver,
  21 |     |         address indexed owner,
  22 |     |         uint256 assets,
  23 |     |         uint256 shares
  24 |     |     );
  25 |     | 
  26 |     |     /**
  27 |     |      * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.
  28 |     |      *
  29 |     |      * - MUST be an ERC-20 token contract.
  30 |     |      * - MUST NOT revert.
  31 |     |      */
  32 |     |     function asset() external view returns (address assetTokenAddress);
  33 |     | 
  34 |     |     /**
  35 |     |      * @dev Returns the total amount of the underlying asset that is managed by Vault.
  36 |     |      *
  37 |     |      * - SHOULD include any compounding that occurs from yield.
  38 |     |      * - MUST be inclusive of any fees that are charged against assets in the Vault.
  39 |     |      * - MUST NOT revert.
  40 |     |      */
  41 |     |     function totalAssets() external view returns (uint256 totalManagedAssets);
  42 |     | 
  43 |     |     /**
  44 |     |      * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal
  45 |     |      * scenario where all the conditions are met.
  46 |     |      *
  47 |     |      * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
  48 |     |      * - MUST NOT show any variations depending on the caller.
  49 |     |      * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
  50 |     |      * - MUST NOT revert.
  51 |     |      *
  52 |     |      * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the
  53 |     |      * average-users price-per-share, meaning what the average user should expect to see when exchanging to and
  54 |     |      * from.
  55 |     |      */
  56 |     |     function convertToShares(uint256 assets) external view returns (uint256 shares);
  57 |     | 
  58 |     |     /**
  59 |     |      * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal
  60 |     |      * scenario where all the conditions are met.
  61 |     |      *
  62 |     |      * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.
  63 |     |      * - MUST NOT show any variations depending on the caller.
  64 |     |      * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.
  65 |     |      * - MUST NOT revert.
  66 |     |      *
  67 |     |      * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the
  68 |     |      * average-users price-per-share, meaning what the average user should expect to see when exchanging to and
  69 |     |      * from.
  70 |     |      */
  71 |     |     function convertToAssets(uint256 shares) external view returns (uint256 assets);
  72 |     | 
  73 |     |     /**
  74 |     |      * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,
  75 |     |      * through a deposit call.
  76 |     |      *
  77 |     |      * - MUST return a limited value if receiver is subject to some deposit limit.
  78 |     |      * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.
  79 |     |      * - MUST NOT revert.
  80 |     |      */
  81 |     |     function maxDeposit(address receiver) external view returns (uint256 maxAssets);
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given
  85 |     |      * current on-chain conditions.
  86 |     |      *
  87 |     |      * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit
  88 |     |      *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called
  89 |     |      *   in the same transaction.
  90 |     |      * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the
  91 |     |      *   deposit would be accepted, regardless if the user has enough tokens approved, etc.
  92 |     |      * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
  93 |     |      * - MUST NOT revert.
  94 |     |      *
  95 |     |      * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in
  96 |     |      * share price or some other type of condition, meaning the depositor will lose assets by depositing.
  97 |     |      */
  98 |     |     function previewDeposit(uint256 assets) external view returns (uint256 shares);
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.
 102 |     |      *
 103 |     |      * - MUST emit the Deposit event.
 104 |     |      * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
 105 |     |      *   deposit execution, and are accounted for during deposit.
 106 |     |      * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not
 107 |     |      *   approving enough underlying tokens to the Vault contract, etc).
 108 |     |      *
 109 |     |      * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.
 110 |     |      */
 111 |     |     function deposit(uint256 assets, address receiver) external returns (uint256 shares);
 112 |     | 
 113 |     |     /**
 114 |     |      * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.
 115 |     |      * - MUST return a limited value if receiver is subject to some mint limit.
 116 |     |      * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.
 117 |     |      * - MUST NOT revert.
 118 |     |      */
 119 |     |     function maxMint(address receiver) external view returns (uint256 maxShares);
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given
 123 |     |      * current on-chain conditions.
 124 |     |      *
 125 |     |      * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call
 126 |     |      *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the
 127 |     |      *   same transaction.
 128 |     |      * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint
 129 |     |      *   would be accepted, regardless if the user has enough tokens approved, etc.
 130 |     |      * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.
 131 |     |      * - MUST NOT revert.
 132 |     |      *
 133 |     |      * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in
 134 |     |      * share price or some other type of condition, meaning the depositor will lose assets by minting.
 135 |     |      */
 136 |     |     function previewMint(uint256 shares) external view returns (uint256 assets);
 137 |     | 
 138 |     |     /**
 139 |     |      * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.
 140 |     |      *
 141 |     |      * - MUST emit the Deposit event.
 142 |     |      * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint
 143 |     |      *   execution, and are accounted for during mint.
 144 |     |      * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not
 145 |     |      *   approving enough underlying tokens to the Vault contract, etc).
 146 |     |      *
 147 |     |      * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.
 148 |     |      */
 149 |     |     function mint(uint256 shares, address receiver) external returns (uint256 assets);
 150 |     | 
 151 |     |     /**
 152 |     |      * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the
 153 |     |      * Vault, through a withdraw call.
 154 |     |      *
 155 |     |      * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
 156 |     |      * - MUST NOT revert.
 157 |     |      */
 158 |     |     function maxWithdraw(address owner) external view returns (uint256 maxAssets);
 159 |     | 
 160 |     |     /**
 161 |     |      * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,
 162 |     |      * given current on-chain conditions.
 163 |     |      *
 164 |     |      * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw
 165 |     |      *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if
 166 |     |      *   called
 167 |     |      *   in the same transaction.
 168 |     |      * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though
 169 |     |      *   the withdrawal would be accepted, regardless if the user has enough shares, etc.
 170 |     |      * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
 171 |     |      * - MUST NOT revert.
 172 |     |      *
 173 |     |      * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in
 174 |     |      * share price or some other type of condition, meaning the depositor will lose assets by depositing.
 175 |     |      */
 176 |     |     function previewWithdraw(uint256 assets) external view returns (uint256 shares);
 177 |     | 
 178 |     |     /**
 179 |     |      * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.
 180 |     |      *
 181 |     |      * - MUST emit the Withdraw event.
 182 |     |      * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
 183 |     |      *   withdraw execution, and are accounted for during withdraw.
 184 |     |      * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner
 185 |     |      *   not having enough shares, etc).
 186 |     |      *
 187 |     |      * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
 188 |     |      * Those methods should be performed separately.
 189 |     |      */
 190 |     |     function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);
 191 |     | 
 192 |     |     /**
 193 |     |      * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,
 194 |     |      * through a redeem call.
 195 |     |      *
 196 |     |      * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.
 197 |     |      * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.
 198 |     |      * - MUST NOT revert.
 199 |     |      */
 200 |     |     function maxRedeem(address owner) external view returns (uint256 maxShares);
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,
 204 |     |      * given current on-chain conditions.
 205 |     |      *
 206 |     |      * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call
 207 |     |      *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the
 208 |     |      *   same transaction.
 209 |     |      * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the
 210 |     |      *   redemption would be accepted, regardless if the user has enough shares, etc.
 211 |     |      * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.
 212 |     |      * - MUST NOT revert.
 213 |     |      *
 214 |     |      * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in
 215 |     |      * share price or some other type of condition, meaning the depositor will lose assets by redeeming.
 216 |     |      */
 217 |     |     function previewRedeem(uint256 shares) external view returns (uint256 assets);
 218 |     | 
 219 |     |     /**
 220 |     |      * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.
 221 |     |      *
 222 |     |      * - MUST emit the Withdraw event.
 223 |     |      * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the
 224 |     |      *   redeem execution, and are accounted for during redeem.
 225 |     |      * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner
 226 |     |      *   not having enough shares, etc).
 227 |     |      *
 228 |     |      * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.
 229 |     |      * Those methods should be performed separately.
 230 |     |      */
 231 |     |     function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);
 232 |     | }
 233 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | interface IERC5267 {
  7 |     |     /**
  8 |     |      * @dev MAY be emitted to signal that the domain could have changed.
  9 |     |      */
 10 |     |     event EIP712DomainChanged();
 11 |     | 
 12 |     |     /**
 13 |     |      * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712
 14 |     |      * signature.
 15 |     |      */
 16 |     |     function eip712Domain()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             bytes1 fields,
 21 |     |             string memory name,
 22 |     |             string memory version,
 23 |     |             uint256 chainId,
 24 |     |             address verifyingContract,
 25 |     |             bytes32 salt,
 26 |     |             uint256[] memory extensions
 27 |     |         );
 28 |     | }
 29 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Contract module that helps prevent reentrant calls to a function.
  8 |     |  *
  9 |     |  * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 10 |     |  * available, which can be applied to functions to make sure there are no nested
 11 |     |  * (reentrant) calls to them.
 12 |     |  *
 13 |     |  * Note that because there is a single `nonReentrant` guard, functions marked as
 14 |     |  * `nonReentrant` may not call one another. This can be worked around by making
 15 |     |  * those functions `private`, and then adding `external` `nonReentrant` entry
 16 |     |  * points to them.
 17 |     |  *
 18 |     |  * TIP: If you would like to learn more about reentrancy and alternative ways
 19 |     |  * to protect against it, check out our blog post
 20 |     |  * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 21 |     |  */
 22 |     | abstract contract ReentrancyGuard {
 23 |     |     // Booleans are more expensive than uint256 or any type that takes up a full
 24 |     |     // word because each write operation emits an extra SLOAD to first read the
 25 |     |     // slot's contents, replace the bits taken up by the boolean, and then write
 26 |     |     // back. This is the compiler's defense against contract upgrades and
 27 |     |     // pointer aliasing, and it cannot be disabled.
 28 |     | 
 29 |     |     // The values being non-zero value makes deployment a bit more expensive,
 30 |     |     // but in exchange the refund on every call to nonReentrant will be lower in
 31 |     |     // amount. Since refunds are capped to a percentage of the total
 32 |     |     // transaction's gas, it is best to keep them low in cases like this one, to
 33 |     |     // increase the likelihood of the full refund coming into effect.
 34 |     |     uint256 private constant _NOT_ENTERED = 1;
 35 |     |     uint256 private constant _ENTERED = 2;
 36 |     | 
 37 |     |     uint256 private _status;
 38 |     | 
 39 |     |     constructor() {
 40 |     |         _status = _NOT_ENTERED;
 41 |     |     }
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Prevents a contract from calling itself, directly or indirectly.
 45 |     |      * Calling a `nonReentrant` function from another `nonReentrant`
 46 |     |      * function is not supported. It is possible to prevent this from happening
 47 |     |      * by making the `nonReentrant` function external, and making it call a
 48 |     |      * `private` function that does the actual work.
 49 |     |      */
 50 |     |     modifier nonReentrant() {
 51 |     |         _nonReentrantBefore();
 52 |     |         _;
 53 |     |         _nonReentrantAfter();
 54 |     |     }
 55 |     | 
 56 |     |     function _nonReentrantBefore() private {
 57 |     |         // On the first call to nonReentrant, _status will be _NOT_ENTERED
 58 |     |         require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
 59 |     | 
 60 |     |         // Any calls to nonReentrant after this point will fail
 61 |     |         _status = _ENTERED;
 62 |     |     }
 63 |     | 
 64 |     |     function _nonReentrantAfter() private {
 65 |     |         // By storing the original value once again, a refund is triggered (see
 66 |     |         // https://eips.ethereum.org/EIPS/eip-2200)
 67 |     |         _status = _NOT_ENTERED;
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
 72 |     |      * `nonReentrant` function in the call stack.
 73 |     |      */
 74 |     |     function _reentrancyGuardEntered() internal view returns (bool) {
 75 |     |         return _status == _ENTERED;
 76 |     |     }
 77 |     | }
 78 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC20.sol";
   7 |     | import "./extensions/IERC20Metadata.sol";
   8 |     | import "../../utils/Context.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev Implementation of the {IERC20} interface.
  12 |     |  *
  13 |     |  * This implementation is agnostic to the way tokens are created. This means
  14 |     |  * that a supply mechanism has to be added in a derived contract using {_mint}.
  15 |     |  * For a generic mechanism see {ERC20PresetMinterPauser}.
  16 |     |  *
  17 |     |  * TIP: For a detailed writeup see our guide
  18 |     |  * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How
  19 |     |  * to implement supply mechanisms].
  20 |     |  *
  21 |     |  * The default value of {decimals} is 18. To change this, you should override
  22 |     |  * this function so it returns a different value.
  23 |     |  *
  24 |     |  * We have followed general OpenZeppelin Contracts guidelines: functions revert
  25 |     |  * instead returning `false` on failure. This behavior is nonetheless
  26 |     |  * conventional and does not conflict with the expectations of ERC20
  27 |     |  * applications.
  28 |     |  *
  29 |     |  * Additionally, an {Approval} event is emitted on calls to {transferFrom}.
  30 |     |  * This allows applications to reconstruct the allowance for all accounts just
  31 |     |  * by listening to said events. Other implementations of the EIP may not emit
  32 |     |  * these events, as it isn't required by the specification.
  33 |     |  *
  34 |     |  * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}
  35 |     |  * functions have been added to mitigate the well-known issues around setting
  36 |     |  * allowances. See {IERC20-approve}.
  37 |     |  */
  38 |     | contract ERC20 is Context, IERC20, IERC20Metadata {
  39 |     |     mapping(address => uint256) private _balances;
  40 |     | 
  41 |     |     mapping(address => mapping(address => uint256)) private _allowances;
  42 |     | 
  43 |     |     uint256 private _totalSupply;
  44 |     | 
  45 |     |     string private _name;
  46 |     |     string private _symbol;
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Sets the values for {name} and {symbol}.
  50 |     |      *
  51 |     |      * All two of these values are immutable: they can only be set once during
  52 |     |      * construction.
  53 |     |      */
  54 |     |     constructor(string memory name_, string memory symbol_) {
  55 |     |         _name = name_;
  56 |     |         _symbol = symbol_;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns the name of the token.
  61 |     |      */
  62 | *   |     function name() public view virtual override returns (string memory) {
  63 |     |         return _name;
  64 |     |     }
  65 |     | 
  66 |     |     /**
  67 |     |      * @dev Returns the symbol of the token, usually a shorter version of the
  68 |     |      * name.
  69 |     |      */
  70 |     |     function symbol() public view virtual override returns (string memory) {
  71 |     |         return _symbol;
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the number of decimals used to get its user representation.
  76 |     |      * For example, if `decimals` equals `2`, a balance of `505` tokens should
  77 |     |      * be displayed to a user as `5.05` (`505 / 10 ** 2`).
  78 |     |      *
  79 |     |      * Tokens usually opt for a value of 18, imitating the relationship between
  80 |     |      * Ether and Wei. This is the default value returned by this function, unless
  81 |     |      * it's overridden.
  82 |     |      *
  83 |     |      * NOTE: This information is only used for _display_ purposes: it in
  84 |     |      * no way affects any of the arithmetic of the contract, including
  85 |     |      * {IERC20-balanceOf} and {IERC20-transfer}.
  86 |     |      */
  87 | *   |     function decimals() public view virtual override returns (uint8) {
  88 | *   |         return 18;
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev See {IERC20-totalSupply}.
  93 |     |      */
  94 | *   |     function totalSupply() public view virtual override returns (uint256) {
  95 | *   |         return _totalSupply;
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev See {IERC20-balanceOf}.
 100 |     |      */
 101 | *   |     function balanceOf(address account) public view virtual override returns (uint256) {
 102 | *   |         return _balances[account];
 103 |     |     }
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev See {IERC20-transfer}.
 107 |     |      *
 108 |     |      * Requirements:
 109 |     |      *
 110 |     |      * - `to` cannot be the zero address.
 111 |     |      * - the caller must have a balance of at least `amount`.
 112 |     |      */
 113 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
 114 |     |         address owner = _msgSender();
 115 |     |         _transfer(owner, to, amount);
 116 |     |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev See {IERC20-allowance}.
 121 |     |      */
 122 | *   |     function allowance(address owner, address spender) public view virtual override returns (uint256) {
 123 | *   |         return _allowances[owner][spender];
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev See {IERC20-approve}.
 128 |     |      *
 129 |     |      * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on
 130 |     |      * `transferFrom`. This is semantically equivalent to an infinite approval.
 131 |     |      *
 132 |     |      * Requirements:
 133 |     |      *
 134 |     |      * - `spender` cannot be the zero address.
 135 |     |      */
 136 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
 137 |     |         address owner = _msgSender();
 138 | *   |         _approve(owner, spender, amount);
 139 | *   |         return true;
 140 |     |     }
 141 |     | 
 142 |     |     /**
 143 |     |      * @dev See {IERC20-transferFrom}.
 144 |     |      *
 145 |     |      * Emits an {Approval} event indicating the updated allowance. This is not
 146 |     |      * required by the EIP. See the note at the beginning of {ERC20}.
 147 |     |      *
 148 |     |      * NOTE: Does not update the allowance if the current allowance
 149 |     |      * is the maximum `uint256`.
 150 |     |      *
 151 |     |      * Requirements:
 152 |     |      *
 153 |     |      * - `from` and `to` cannot be the zero address.
 154 |     |      * - `from` must have a balance of at least `amount`.
 155 |     |      * - the caller must have allowance for ``from``'s tokens of at least
 156 |     |      * `amount`.
 157 |     |      */
 158 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 159 |     |         address spender = _msgSender();
 160 | *   |         _spendAllowance(from, spender, amount);
 161 | *   |         _transfer(from, to, amount);
 162 | *   |         return true;
 163 |     |     }
 164 |     | 
 165 |     |     /**
 166 |     |      * @dev Atomically increases the allowance granted to `spender` by the caller.
 167 |     |      *
 168 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 169 |     |      * problems described in {IERC20-approve}.
 170 |     |      *
 171 |     |      * Emits an {Approval} event indicating the updated allowance.
 172 |     |      *
 173 |     |      * Requirements:
 174 |     |      *
 175 |     |      * - `spender` cannot be the zero address.
 176 |     |      */
 177 |     |     function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {
 178 |     |         address owner = _msgSender();
 179 |     |         _approve(owner, spender, allowance(owner, spender) + addedValue);
 180 |     |         return true;
 181 |     |     }
 182 |     | 
 183 |     |     /**
 184 |     |      * @dev Atomically decreases the allowance granted to `spender` by the caller.
 185 |     |      *
 186 |     |      * This is an alternative to {approve} that can be used as a mitigation for
 187 |     |      * problems described in {IERC20-approve}.
 188 |     |      *
 189 |     |      * Emits an {Approval} event indicating the updated allowance.
 190 |     |      *
 191 |     |      * Requirements:
 192 |     |      *
 193 |     |      * - `spender` cannot be the zero address.
 194 |     |      * - `spender` must have allowance for the caller of at least
 195 |     |      * `subtractedValue`.
 196 |     |      */
 197 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {
 198 |     |         address owner = _msgSender();
 199 |     |         uint256 currentAllowance = allowance(owner, spender);
 200 |     |         require(currentAllowance >= subtractedValue, "ERC20: decreased allowance below zero");
 201 |     |         unchecked {
 202 |     |             _approve(owner, spender, currentAllowance - subtractedValue);
 203 |     |         }
 204 |     | 
 205 |     |         return true;
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Moves `amount` of tokens from `from` to `to`.
 210 |     |      *
 211 |     |      * This internal function is equivalent to {transfer}, and can be used to
 212 |     |      * e.g. implement automatic token fees, slashing mechanisms, etc.
 213 |     |      *
 214 |     |      * Emits a {Transfer} event.
 215 |     |      *
 216 |     |      * Requirements:
 217 |     |      *
 218 |     |      * - `from` cannot be the zero address.
 219 |     |      * - `to` cannot be the zero address.
 220 |     |      * - `from` must have a balance of at least `amount`.
 221 |     |      */
 222 | *   |     function _transfer(address from, address to, uint256 amount) internal virtual {
 223 | *   |         require(from != address(0), "ERC20: transfer from the zero address");
 224 | *   |         require(to != address(0), "ERC20: transfer to the zero address");
 225 |     | 
 226 |     |         _beforeTokenTransfer(from, to, amount);
 227 |     | 
 228 | *   |         uint256 fromBalance = _balances[from];
 229 | *   |         require(fromBalance >= amount, "ERC20: transfer amount exceeds balance");
 230 |     |         unchecked {
 231 | *   |             _balances[from] = fromBalance - amount;
 232 |     |             // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by
 233 |     |             // decrementing then incrementing.
 234 | *   |             _balances[to] += amount;
 235 |     |         }
 236 |     | 
 237 | *   |         emit Transfer(from, to, amount);
 238 |     | 
 239 | *   |         _afterTokenTransfer(from, to, amount);
 240 |     |     }
 241 |     | 
 242 |     |     /** @dev Creates `amount` tokens and assigns them to `account`, increasing
 243 |     |      * the total supply.
 244 |     |      *
 245 |     |      * Emits a {Transfer} event with `from` set to the zero address.
 246 |     |      *
 247 |     |      * Requirements:
 248 |     |      *
 249 |     |      * - `account` cannot be the zero address.
 250 |     |      */
 251 | *   |     function _mint(address account, uint256 amount) internal virtual {
 252 | *   |         require(account != address(0), "ERC20: mint to the zero address");
 253 |     | 
 254 |     |         _beforeTokenTransfer(address(0), account, amount);
 255 |     | 
 256 | *   |         _totalSupply += amount;
 257 |     |         unchecked {
 258 |     |             // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.
 259 | *   |             _balances[account] += amount;
 260 |     |         }
 261 | *   |         emit Transfer(address(0), account, amount);
 262 |     | 
 263 |     |         _afterTokenTransfer(address(0), account, amount);
 264 |     |     }
 265 |     | 
 266 |     |     /**
 267 |     |      * @dev Destroys `amount` tokens from `account`, reducing the
 268 |     |      * total supply.
 269 |     |      *
 270 |     |      * Emits a {Transfer} event with `to` set to the zero address.
 271 |     |      *
 272 |     |      * Requirements:
 273 |     |      *
 274 |     |      * - `account` cannot be the zero address.
 275 |     |      * - `account` must have at least `amount` tokens.
 276 |     |      */
 277 | *   |     function _burn(address account, uint256 amount) internal virtual {
 278 |     |         require(account != address(0), "ERC20: burn from the zero address");
 279 |     | 
 280 |     |         _beforeTokenTransfer(account, address(0), amount);
 281 |     | 
 282 |     |         uint256 accountBalance = _balances[account];
 283 |     |         require(accountBalance >= amount, "ERC20: burn amount exceeds balance");
 284 |     |         unchecked {
 285 |     |             _balances[account] = accountBalance - amount;
 286 |     |             // Overflow not possible: amount <= accountBalance <= totalSupply.
 287 |     |             _totalSupply -= amount;
 288 |     |         }
 289 |     | 
 290 |     |         emit Transfer(account, address(0), amount);
 291 |     | 
 292 | *   |         _afterTokenTransfer(account, address(0), amount);
 293 |     |     }
 294 |     | 
 295 |     |     /**
 296 |     |      * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.
 297 |     |      *
 298 |     |      * This internal function is equivalent to `approve`, and can be used to
 299 |     |      * e.g. set automatic allowances for certain subsystems, etc.
 300 |     |      *
 301 |     |      * Emits an {Approval} event.
 302 |     |      *
 303 |     |      * Requirements:
 304 |     |      *
 305 |     |      * - `owner` cannot be the zero address.
 306 |     |      * - `spender` cannot be the zero address.
 307 |     |      */
 308 | *   |     function _approve(address owner, address spender, uint256 amount) internal virtual {
 309 | *   |         require(owner != address(0), "ERC20: approve from the zero address");
 310 | *   |         require(spender != address(0), "ERC20: approve to the zero address");
 311 |     | 
 312 | *   |         _allowances[owner][spender] = amount;
 313 | *   |         emit Approval(owner, spender, amount);
 314 |     |     }
 315 |     | 
 316 |     |     /**
 317 |     |      * @dev Updates `owner` s allowance for `spender` based on spent `amount`.
 318 |     |      *
 319 |     |      * Does not update the allowance amount in case of infinite allowance.
 320 |     |      * Revert if not enough allowance is available.
 321 |     |      *
 322 |     |      * Might emit an {Approval} event.
 323 |     |      */
 324 | *   |     function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {
 325 | *   |         uint256 currentAllowance = allowance(owner, spender);
 326 | *   |         if (currentAllowance != type(uint256).max) {
 327 |     |             require(currentAllowance >= amount, "ERC20: insufficient allowance");
 328 |     |             unchecked {
 329 | *   |                 _approve(owner, spender, currentAllowance - amount);
 330 |     |             }
 331 |     |         }
 332 |     |     }
 333 |     | 
 334 |     |     /**
 335 |     |      * @dev Hook that is called before any transfer of tokens. This includes
 336 |     |      * minting and burning.
 337 |     |      *
 338 |     |      * Calling conditions:
 339 |     |      *
 340 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 341 |     |      * will be transferred to `to`.
 342 |     |      * - when `from` is zero, `amount` tokens will be minted for `to`.
 343 |     |      * - when `to` is zero, `amount` of ``from``'s tokens will be burned.
 344 |     |      * - `from` and `to` are never both zero.
 345 |     |      *
 346 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 347 |     |      */
 348 |     |     function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 349 |     | 
 350 |     |     /**
 351 |     |      * @dev Hook that is called after any transfer of tokens. This includes
 352 |     |      * minting and burning.
 353 |     |      *
 354 |     |      * Calling conditions:
 355 |     |      *
 356 |     |      * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens
 357 |     |      * has been transferred to `to`.
 358 |     |      * - when `from` is zero, `amount` tokens have been minted for `to`.
 359 |     |      * - when `to` is zero, `amount` of ``from``'s tokens have been burned.
 360 |     |      * - `from` and `to` are never both zero.
 361 |     |      *
 362 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 363 |     |      */
 364 |     |     function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}
 365 |     | }
 366 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 standard as defined in the EIP.
  8 |     |  */
  9 |     | interface IERC20 {
 10 |     |     /**
 11 |     |      * @dev Emitted when `value` tokens are moved from one account (`from`) to
 12 |     |      * another (`to`).
 13 |     |      *
 14 |     |      * Note that `value` may be zero.
 15 |     |      */
 16 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Emitted when the allowance of a `spender` for an `owner` is set by
 20 |     |      * a call to {approve}. `value` is the new allowance.
 21 |     |      */
 22 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the amount of tokens in existence.
 26 |     |      */
 27 |     |     function totalSupply() external view returns (uint256);
 28 |     | 
 29 |     |     /**
 30 |     |      * @dev Returns the amount of tokens owned by `account`.
 31 |     |      */
 32 |     |     function balanceOf(address account) external view returns (uint256);
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Moves `amount` tokens from the caller's account to `to`.
 36 |     |      *
 37 |     |      * Returns a boolean value indicating whether the operation succeeded.
 38 |     |      *
 39 |     |      * Emits a {Transfer} event.
 40 |     |      */
 41 |     |     function transfer(address to, uint256 amount) external returns (bool);
 42 |     | 
 43 |     |     /**
 44 |     |      * @dev Returns the remaining number of tokens that `spender` will be
 45 |     |      * allowed to spend on behalf of `owner` through {transferFrom}. This is
 46 |     |      * zero by default.
 47 |     |      *
 48 |     |      * This value changes when {approve} or {transferFrom} are called.
 49 |     |      */
 50 |     |     function allowance(address owner, address spender) external view returns (uint256);
 51 |     | 
 52 |     |     /**
 53 |     |      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.
 54 |     |      *
 55 |     |      * Returns a boolean value indicating whether the operation succeeded.
 56 |     |      *
 57 |     |      * IMPORTANT: Beware that changing an allowance with this method brings the risk
 58 |     |      * that someone may use both the old and the new allowance by unfortunate
 59 |     |      * transaction ordering. One possible solution to mitigate this race
 60 |     |      * condition is to first reduce the spender's allowance to 0 and set the
 61 |     |      * desired value afterwards:
 62 |     |      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 63 |     |      *
 64 |     |      * Emits an {Approval} event.
 65 |     |      */
 66 |     |     function approve(address spender, uint256 amount) external returns (bool);
 67 |     | 
 68 |     |     /**
 69 |     |      * @dev Moves `amount` tokens from `from` to `to` using the
 70 |     |      * allowance mechanism. `amount` is then deducted from the caller's
 71 |     |      * allowance.
 72 |     |      *
 73 |     |      * Returns a boolean value indicating whether the operation succeeded.
 74 |     |      *
 75 |     |      * Emits a {Transfer} event.
 76 |     |      */
 77 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 78 |     | }
 79 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC20Permit.sol";
  7 |     | import "../ERC20.sol";
  8 |     | import "../../../utils/cryptography/ECDSA.sol";
  9 |     | import "../../../utils/cryptography/EIP712.sol";
 10 |     | import "../../../utils/Counters.sol";
 11 |     | 
 12 |     | /**
 13 |     |  * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
 14 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
 15 |     |  *
 16 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 17 |     |  * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't
 18 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 19 |     |  *
 20 |     |  * _Available since v3.4._
 21 |     |  */
 22 |     | abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {
 23 |     |     using Counters for Counters.Counter;
 24 |     | 
 25 |     |     mapping(address => Counters.Counter) private _nonces;
 26 |     | 
 27 |     |     // solhint-disable-next-line var-name-mixedcase
 28 |     |     bytes32 private constant _PERMIT_TYPEHASH =
 29 |     |         keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
 30 |     |     /**
 31 |     |      * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.
 32 |     |      * However, to ensure consistency with the upgradeable transpiler, we will continue
 33 |     |      * to reserve a slot.
 34 |     |      * @custom:oz-renamed-from _PERMIT_TYPEHASH
 35 |     |      */
 36 |     |     // solhint-disable-next-line var-name-mixedcase
 37 |     |     bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;
 38 |     | 
 39 |     |     /**
 40 |     |      * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `"1"`.
 41 |     |      *
 42 |     |      * It's a good idea to use the same `name` that is defined as the ERC20 token name.
 43 |     |      */
 44 |     |     constructor(string memory name) EIP712(name, "1") {}
 45 |     | 
 46 |     |     /**
 47 |     |      * @inheritdoc IERC20Permit
 48 |     |      */
 49 |     |     function permit(
 50 |     |         address owner,
 51 |     |         address spender,
 52 |     |         uint256 value,
 53 |     |         uint256 deadline,
 54 |     |         uint8 v,
 55 |     |         bytes32 r,
 56 |     |         bytes32 s
 57 |     |     ) public virtual override {
 58 |     |         require(block.timestamp <= deadline, "ERC20Permit: expired deadline");
 59 |     | 
 60 |     |         bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));
 61 |     | 
 62 |     |         bytes32 hash = _hashTypedDataV4(structHash);
 63 |     | 
 64 |     |         address signer = ECDSA.recover(hash, v, r, s);
 65 |     |         require(signer == owner, "ERC20Permit: invalid signature");
 66 |     | 
 67 |     |         _approve(owner, spender, value);
 68 |     |     }
 69 |     | 
 70 |     |     /**
 71 |     |      * @inheritdoc IERC20Permit
 72 |     |      */
 73 |     |     function nonces(address owner) public view virtual override returns (uint256) {
 74 |     |         return _nonces[owner].current();
 75 |     |     }
 76 |     | 
 77 |     |     /**
 78 |     |      * @inheritdoc IERC20Permit
 79 |     |      */
 80 |     |     // solhint-disable-next-line func-name-mixedcase
 81 |     |     function DOMAIN_SEPARATOR() external view override returns (bytes32) {
 82 |     |         return _domainSeparatorV4();
 83 |     |     }
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev "Consume a nonce": return the current value and increment.
 87 |     |      *
 88 |     |      * _Available since v4.1._
 89 |     |      */
 90 |     |     function _useNonce(address owner) internal virtual returns (uint256 current) {
 91 |     |         Counters.Counter storage nonce = _nonces[owner];
 92 |     |         current = nonce.current();
 93 |     |         nonce.increment();
 94 |     |     }
 95 |     | }
 96 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC20.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Interface for the optional metadata functions from the ERC20 standard.
 10 |     |  *
 11 |     |  * _Available since v4.1._
 12 |     |  */
 13 |     | interface IERC20Metadata is IERC20 {
 14 |     |     /**
 15 |     |      * @dev Returns the name of the token.
 16 |     |      */
 17 |     |     function name() external view returns (string memory);
 18 |     | 
 19 |     |     /**
 20 |     |      * @dev Returns the symbol of the token.
 21 |     |      */
 22 |     |     function symbol() external view returns (string memory);
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the decimals places of the token.
 26 |     |      */
 27 |     |     function decimals() external view returns (uint8);
 28 |     | }
 29 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in
  8 |     |  * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].
  9 |     |  *
 10 |     |  * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by
 11 |     |  * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't
 12 |     |  * need to send a transaction, and thus is not required to hold Ether at all.
 13 |     |  *
 14 |     |  * ==== Security Considerations
 15 |     |  *
 16 |     |  * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature
 17 |     |  * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be
 18 |     |  * considered as an intention to spend the allowance in any specific way. The second is that because permits have
 19 |     |  * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should
 20 |     |  * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be
 21 |     |  * generally recommended is:
 22 |     |  *
 23 |     |  * ```solidity
 24 |     |  * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {
 25 |     |  *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}
 26 |     |  *     doThing(..., value);
 27 |     |  * }
 28 |     |  *
 29 |     |  * function doThing(..., uint256 value) public {
 30 |     |  *     token.safeTransferFrom(msg.sender, address(this), value);
 31 |     |  *     ...
 32 |     |  * }
 33 |     |  * ```
 34 |     |  *
 35 |     |  * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of
 36 |     |  * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also
 37 |     |  * {SafeERC20-safeTransferFrom}).
 38 |     |  *
 39 |     |  * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so
 40 |     |  * contracts should have entry points that don't rely on permit.
 41 |     |  */
 42 |     | interface IERC20Permit {
 43 |     |     /**
 44 |     |      * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,
 45 |     |      * given ``owner``'s signed approval.
 46 |     |      *
 47 |     |      * IMPORTANT: The same issues {IERC20-approve} has related to transaction
 48 |     |      * ordering also apply here.
 49 |     |      *
 50 |     |      * Emits an {Approval} event.
 51 |     |      *
 52 |     |      * Requirements:
 53 |     |      *
 54 |     |      * - `spender` cannot be the zero address.
 55 |     |      * - `deadline` must be a timestamp in the future.
 56 |     |      * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`
 57 |     |      * over the EIP712-formatted function arguments.
 58 |     |      * - the signature must use ``owner``'s current nonce (see {nonces}).
 59 |     |      *
 60 |     |      * For more information on the signature format, see the
 61 |     |      * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP
 62 |     |      * section].
 63 |     |      *
 64 |     |      * CAUTION: See Security Considerations above.
 65 |     |      */
 66 |     |     function permit(
 67 |     |         address owner,
 68 |     |         address spender,
 69 |     |         uint256 value,
 70 |     |         uint256 deadline,
 71 |     |         uint8 v,
 72 |     |         bytes32 r,
 73 |     |         bytes32 s
 74 |     |     ) external;
 75 |     | 
 76 |     |     /**
 77 |     |      * @dev Returns the current nonce for `owner`. This value must be
 78 |     |      * included whenever a signature is generated for {permit}.
 79 |     |      *
 80 |     |      * Every successful call to {permit} increases ``owner``'s nonce by one. This
 81 |     |      * prevents a signature from being used multiple times.
 82 |     |      */
 83 |     |     function nonces(address owner) external view returns (uint256);
 84 |     | 
 85 |     |     /**
 86 |     |      * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.
 87 |     |      */
 88 |     |     // solhint-disable-next-line func-name-mixedcase
 89 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 90 |     | }
 91 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../IERC20.sol";
   7 |     | import "../extensions/IERC20Permit.sol";
   8 |     | import "../../../utils/Address.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @title SafeERC20
  12 |     |  * @dev Wrappers around ERC20 operations that throw on failure (when the token
  13 |     |  * contract returns false). Tokens that return no value (and instead revert or
  14 |     |  * throw on failure) are also supported, non-reverting calls are assumed to be
  15 |     |  * successful.
  16 |     |  * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,
  17 |     |  * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.
  18 |     |  */
  19 |     | library SafeERC20 {
  20 |     |     using Address for address;
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,
  24 |     |      * non-reverting calls are assumed to be successful.
  25 |     |      */
  26 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
  27 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the
  32 |     |      * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.
  33 |     |      */
  34 | *   |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
  35 | *   |         _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));
  36 |     |     }
  37 |     | 
  38 |     |     /**
  39 |     |      * @dev Deprecated. This function has issues similar to the ones found in
  40 |     |      * {IERC20-approve}, and its usage is discouraged.
  41 |     |      *
  42 |     |      * Whenever possible, use {safeIncreaseAllowance} and
  43 |     |      * {safeDecreaseAllowance} instead.
  44 |     |      */
  45 |     |     function safeApprove(IERC20 token, address spender, uint256 value) internal {
  46 |     |         // safeApprove should only be called when setting an initial allowance,
  47 |     |         // or when resetting it to zero. To increase and decrease it, use
  48 |     |         // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  49 |     |         require(
  50 |     |             (value == 0) || (token.allowance(address(this), spender) == 0),
  51 |     |             "SafeERC20: approve from non-zero to non-zero allowance"
  52 |     |         );
  53 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
  54 |     |     }
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  58 |     |      * non-reverting calls are assumed to be successful.
  59 |     |      */
  60 |     |     function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  61 |     |         uint256 oldAllowance = token.allowance(address(this), spender);
  62 |     |         _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));
  63 |     |     }
  64 |     | 
  65 |     |     /**
  66 |     |      * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,
  67 |     |      * non-reverting calls are assumed to be successful.
  68 |     |      */
  69 |     |     function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {
  70 |     |         unchecked {
  71 |     |             uint256 oldAllowance = token.allowance(address(this), spender);
  72 |     |             require(oldAllowance >= value, "SafeERC20: decreased allowance below zero");
  73 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));
  74 |     |         }
  75 |     |     }
  76 |     | 
  77 |     |     /**
  78 |     |      * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,
  79 |     |      * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval
  80 |     |      * to be set to zero before setting it to a non-zero value, such as USDT.
  81 |     |      */
  82 |     |     function forceApprove(IERC20 token, address spender, uint256 value) internal {
  83 |     |         bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);
  84 |     | 
  85 |     |         if (!_callOptionalReturnBool(token, approvalCall)) {
  86 |     |             _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));
  87 |     |             _callOptionalReturn(token, approvalCall);
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     /**
  92 |     |      * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.
  93 |     |      * Revert on invalid signature.
  94 |     |      */
  95 |     |     function safePermit(
  96 |     |         IERC20Permit token,
  97 |     |         address owner,
  98 |     |         address spender,
  99 |     |         uint256 value,
 100 |     |         uint256 deadline,
 101 |     |         uint8 v,
 102 |     |         bytes32 r,
 103 |     |         bytes32 s
 104 |     |     ) internal {
 105 |     |         uint256 nonceBefore = token.nonces(owner);
 106 |     |         token.permit(owner, spender, value, deadline, v, r, s);
 107 |     |         uint256 nonceAfter = token.nonces(owner);
 108 |     |         require(nonceAfter == nonceBefore + 1, "SafeERC20: permit did not succeed");
 109 |     |     }
 110 |     | 
 111 |     |     /**
 112 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 113 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 114 |     |      * @param token The token targeted by the call.
 115 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 116 |     |      */
 117 | *   |     function _callOptionalReturn(IERC20 token, bytes memory data) private {
 118 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 119 |     |         // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that
 120 |     |         // the target address contains contract code and also asserts for success in the low-level call.
 121 |     | 
 122 | *   |         bytes memory returndata = address(token).functionCall(data, "SafeERC20: low-level call failed");
 123 | *   |         require(returndata.length == 0 || abi.decode(returndata, (bool)), "SafeERC20: ERC20 operation did not succeed");
 124 |     |     }
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
 128 |     |      * on the return value: the return value is optional (but if data is returned, it must not be false).
 129 |     |      * @param token The token targeted by the call.
 130 |     |      * @param data The call data (encoded using abi.encode or one of its variants).
 131 |     |      *
 132 |     |      * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.
 133 |     |      */
 134 |     |     function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
 135 |     |         // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since
 136 |     |         // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false
 137 |     |         // and not revert is the subcall reverts.
 138 |     | 
 139 |     |         (bool success, bytes memory returndata) = address(token).call(data);
 140 |     |         return
 141 |     |             success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));
 142 |     |     }
 143 |     | }
 144 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "./IERC721.sol";
   7 |     | import "./IERC721Receiver.sol";
   8 |     | import "./extensions/IERC721Metadata.sol";
   9 |     | import "../../utils/Address.sol";
  10 |     | import "../../utils/Context.sol";
  11 |     | import "../../utils/Strings.sol";
  12 |     | import "../../utils/introspection/ERC165.sol";
  13 |     | 
  14 |     | /**
  15 |     |  * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including
  16 |     |  * the Metadata extension, but not including the Enumerable extension, which is available separately as
  17 |     |  * {ERC721Enumerable}.
  18 |     |  */
  19 |     | contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {
  20 |     |     using Address for address;
  21 |     |     using Strings for uint256;
  22 |     | 
  23 |     |     // Token name
  24 |     |     string private _name;
  25 |     | 
  26 |     |     // Token symbol
  27 |     |     string private _symbol;
  28 |     | 
  29 |     |     // Mapping from token ID to owner address
  30 |     |     mapping(uint256 => address) private _owners;
  31 |     | 
  32 |     |     // Mapping owner address to token count
  33 |     |     mapping(address => uint256) private _balances;
  34 |     | 
  35 |     |     // Mapping from token ID to approved address
  36 |     |     mapping(uint256 => address) private _tokenApprovals;
  37 |     | 
  38 |     |     // Mapping from owner to operator approvals
  39 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.
  43 |     |      */
  44 |     |     constructor(string memory name_, string memory symbol_) {
  45 |     |         _name = name_;
  46 |     |         _symbol = symbol_;
  47 |     |     }
  48 |     | 
  49 |     |     /**
  50 |     |      * @dev See {IERC165-supportsInterface}.
  51 |     |      */
  52 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {
  53 |     |         return
  54 |     |             interfaceId == type(IERC721).interfaceId ||
  55 |     |             interfaceId == type(IERC721Metadata).interfaceId ||
  56 |     |             super.supportsInterface(interfaceId);
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev See {IERC721-balanceOf}.
  61 |     |      */
  62 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  63 |     |         require(owner != address(0), "ERC721: address zero is not a valid owner");
  64 |     |         return _balances[owner];
  65 |     |     }
  66 |     | 
  67 |     |     /**
  68 |     |      * @dev See {IERC721-ownerOf}.
  69 |     |      */
  70 |     |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  71 |     |         address owner = _ownerOf(tokenId);
  72 |     |         require(owner != address(0), "ERC721: invalid token ID");
  73 |     |         return owner;
  74 |     |     }
  75 |     | 
  76 |     |     /**
  77 |     |      * @dev See {IERC721Metadata-name}.
  78 |     |      */
  79 |     |     function name() public view virtual override returns (string memory) {
  80 |     |         return _name;
  81 |     |     }
  82 |     | 
  83 |     |     /**
  84 |     |      * @dev See {IERC721Metadata-symbol}.
  85 |     |      */
  86 |     |     function symbol() public view virtual override returns (string memory) {
  87 |     |         return _symbol;
  88 |     |     }
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev See {IERC721Metadata-tokenURI}.
  92 |     |      */
  93 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  94 |     |         _requireMinted(tokenId);
  95 |     | 
  96 |     |         string memory baseURI = _baseURI();
  97 |     |         return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : "";
  98 |     |     }
  99 |     | 
 100 |     |     /**
 101 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
 102 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
 103 |     |      * by default, can be overridden in child contracts.
 104 |     |      */
 105 |     |     function _baseURI() internal view virtual returns (string memory) {
 106 |     |         return "";
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev See {IERC721-approve}.
 111 |     |      */
 112 |     |     function approve(address to, uint256 tokenId) public virtual override {
 113 |     |         address owner = ERC721.ownerOf(tokenId);
 114 |     |         require(to != owner, "ERC721: approval to current owner");
 115 |     | 
 116 |     |         require(
 117 |     |             _msgSender() == owner || isApprovedForAll(owner, _msgSender()),
 118 |     |             "ERC721: approve caller is not token owner or approved for all"
 119 |     |         );
 120 |     | 
 121 |     |         _approve(to, tokenId);
 122 |     |     }
 123 |     | 
 124 |     |     /**
 125 |     |      * @dev See {IERC721-getApproved}.
 126 |     |      */
 127 |     |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
 128 |     |         _requireMinted(tokenId);
 129 |     | 
 130 |     |         return _tokenApprovals[tokenId];
 131 |     |     }
 132 |     | 
 133 |     |     /**
 134 |     |      * @dev See {IERC721-setApprovalForAll}.
 135 |     |      */
 136 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
 137 |     |         _setApprovalForAll(_msgSender(), operator, approved);
 138 |     |     }
 139 |     | 
 140 |     |     /**
 141 |     |      * @dev See {IERC721-isApprovedForAll}.
 142 |     |      */
 143 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
 144 |     |         return _operatorApprovals[owner][operator];
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev See {IERC721-transferFrom}.
 149 |     |      */
 150 |     |     function transferFrom(address from, address to, uint256 tokenId) public virtual override {
 151 |     |         //solhint-disable-next-line max-line-length
 152 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 153 |     | 
 154 |     |         _transfer(from, to, tokenId);
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev See {IERC721-safeTransferFrom}.
 159 |     |      */
 160 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {
 161 |     |         safeTransferFrom(from, to, tokenId, "");
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev See {IERC721-safeTransferFrom}.
 166 |     |      */
 167 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {
 168 |     |         require(_isApprovedOrOwner(_msgSender(), tokenId), "ERC721: caller is not token owner or approved");
 169 |     |         _safeTransfer(from, to, tokenId, data);
 170 |     |     }
 171 |     | 
 172 |     |     /**
 173 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
 174 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
 175 |     |      *
 176 |     |      * `data` is additional data, it has no specified format and it is sent in call to `to`.
 177 |     |      *
 178 |     |      * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.
 179 |     |      * implement alternative mechanisms to perform token transfer, such as signature-based.
 180 |     |      *
 181 |     |      * Requirements:
 182 |     |      *
 183 |     |      * - `from` cannot be the zero address.
 184 |     |      * - `to` cannot be the zero address.
 185 |     |      * - `tokenId` token must exist and be owned by `from`.
 186 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 187 |     |      *
 188 |     |      * Emits a {Transfer} event.
 189 |     |      */
 190 |     |     function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {
 191 |     |         _transfer(from, to, tokenId);
 192 |     |         require(_checkOnERC721Received(from, to, tokenId, data), "ERC721: transfer to non ERC721Receiver implementer");
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist
 197 |     |      */
 198 |     |     function _ownerOf(uint256 tokenId) internal view virtual returns (address) {
 199 |     |         return _owners[tokenId];
 200 |     |     }
 201 |     | 
 202 |     |     /**
 203 |     |      * @dev Returns whether `tokenId` exists.
 204 |     |      *
 205 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
 206 |     |      *
 207 |     |      * Tokens start existing when they are minted (`_mint`),
 208 |     |      * and stop existing when they are burned (`_burn`).
 209 |     |      */
 210 |     |     function _exists(uint256 tokenId) internal view virtual returns (bool) {
 211 |     |         return _ownerOf(tokenId) != address(0);
 212 |     |     }
 213 |     | 
 214 |     |     /**
 215 |     |      * @dev Returns whether `spender` is allowed to manage `tokenId`.
 216 |     |      *
 217 |     |      * Requirements:
 218 |     |      *
 219 |     |      * - `tokenId` must exist.
 220 |     |      */
 221 |     |     function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {
 222 |     |         address owner = ERC721.ownerOf(tokenId);
 223 |     |         return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);
 224 |     |     }
 225 |     | 
 226 |     |     /**
 227 |     |      * @dev Safely mints `tokenId` and transfers it to `to`.
 228 |     |      *
 229 |     |      * Requirements:
 230 |     |      *
 231 |     |      * - `tokenId` must not exist.
 232 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 233 |     |      *
 234 |     |      * Emits a {Transfer} event.
 235 |     |      */
 236 |     |     function _safeMint(address to, uint256 tokenId) internal virtual {
 237 |     |         _safeMint(to, tokenId, "");
 238 |     |     }
 239 |     | 
 240 |     |     /**
 241 |     |      * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is
 242 |     |      * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.
 243 |     |      */
 244 |     |     function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {
 245 |     |         _mint(to, tokenId);
 246 |     |         require(
 247 |     |             _checkOnERC721Received(address(0), to, tokenId, data),
 248 |     |             "ERC721: transfer to non ERC721Receiver implementer"
 249 |     |         );
 250 |     |     }
 251 |     | 
 252 |     |     /**
 253 |     |      * @dev Mints `tokenId` and transfers it to `to`.
 254 |     |      *
 255 |     |      * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible
 256 |     |      *
 257 |     |      * Requirements:
 258 |     |      *
 259 |     |      * - `tokenId` must not exist.
 260 |     |      * - `to` cannot be the zero address.
 261 |     |      *
 262 |     |      * Emits a {Transfer} event.
 263 |     |      */
 264 |     |     function _mint(address to, uint256 tokenId) internal virtual {
 265 |     |         require(to != address(0), "ERC721: mint to the zero address");
 266 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 267 |     | 
 268 |     |         _beforeTokenTransfer(address(0), to, tokenId, 1);
 269 |     | 
 270 |     |         // Check that tokenId was not minted by `_beforeTokenTransfer` hook
 271 |     |         require(!_exists(tokenId), "ERC721: token already minted");
 272 |     | 
 273 |     |         unchecked {
 274 |     |             // Will not overflow unless all 2**256 token ids are minted to the same owner.
 275 |     |             // Given that tokens are minted one by one, it is impossible in practice that
 276 |     |             // this ever happens. Might change if we allow batch minting.
 277 |     |             // The ERC fails to describe this case.
 278 |     |             _balances[to] += 1;
 279 |     |         }
 280 |     | 
 281 |     |         _owners[tokenId] = to;
 282 |     | 
 283 |     |         emit Transfer(address(0), to, tokenId);
 284 |     | 
 285 |     |         _afterTokenTransfer(address(0), to, tokenId, 1);
 286 |     |     }
 287 |     | 
 288 |     |     /**
 289 |     |      * @dev Destroys `tokenId`.
 290 |     |      * The approval is cleared when the token is burned.
 291 |     |      * This is an internal function that does not check if the sender is authorized to operate on the token.
 292 |     |      *
 293 |     |      * Requirements:
 294 |     |      *
 295 |     |      * - `tokenId` must exist.
 296 |     |      *
 297 |     |      * Emits a {Transfer} event.
 298 |     |      */
 299 |     |     function _burn(uint256 tokenId) internal virtual {
 300 |     |         address owner = ERC721.ownerOf(tokenId);
 301 |     | 
 302 |     |         _beforeTokenTransfer(owner, address(0), tokenId, 1);
 303 |     | 
 304 |     |         // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook
 305 |     |         owner = ERC721.ownerOf(tokenId);
 306 |     | 
 307 |     |         // Clear approvals
 308 |     |         delete _tokenApprovals[tokenId];
 309 |     | 
 310 |     |         unchecked {
 311 |     |             // Cannot overflow, as that would require more tokens to be burned/transferred
 312 |     |             // out than the owner initially received through minting and transferring in.
 313 |     |             _balances[owner] -= 1;
 314 |     |         }
 315 |     |         delete _owners[tokenId];
 316 |     | 
 317 |     |         emit Transfer(owner, address(0), tokenId);
 318 |     | 
 319 |     |         _afterTokenTransfer(owner, address(0), tokenId, 1);
 320 |     |     }
 321 |     | 
 322 |     |     /**
 323 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 324 |     |      *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.
 325 |     |      *
 326 |     |      * Requirements:
 327 |     |      *
 328 |     |      * - `to` cannot be the zero address.
 329 |     |      * - `tokenId` token must be owned by `from`.
 330 |     |      *
 331 |     |      * Emits a {Transfer} event.
 332 |     |      */
 333 |     |     function _transfer(address from, address to, uint256 tokenId) internal virtual {
 334 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 335 |     |         require(to != address(0), "ERC721: transfer to the zero address");
 336 |     | 
 337 |     |         _beforeTokenTransfer(from, to, tokenId, 1);
 338 |     | 
 339 |     |         // Check that tokenId was not transferred by `_beforeTokenTransfer` hook
 340 |     |         require(ERC721.ownerOf(tokenId) == from, "ERC721: transfer from incorrect owner");
 341 |     | 
 342 |     |         // Clear approvals from the previous owner
 343 |     |         delete _tokenApprovals[tokenId];
 344 |     | 
 345 |     |         unchecked {
 346 |     |             // `_balances[from]` cannot overflow for the same reason as described in `_burn`:
 347 |     |             // `from`'s balance is the number of token held, which is at least one before the current
 348 |     |             // transfer.
 349 |     |             // `_balances[to]` could overflow in the conditions described in `_mint`. That would require
 350 |     |             // all 2**256 token ids to be minted, which in practice is impossible.
 351 |     |             _balances[from] -= 1;
 352 |     |             _balances[to] += 1;
 353 |     |         }
 354 |     |         _owners[tokenId] = to;
 355 |     | 
 356 |     |         emit Transfer(from, to, tokenId);
 357 |     | 
 358 |     |         _afterTokenTransfer(from, to, tokenId, 1);
 359 |     |     }
 360 |     | 
 361 |     |     /**
 362 |     |      * @dev Approve `to` to operate on `tokenId`
 363 |     |      *
 364 |     |      * Emits an {Approval} event.
 365 |     |      */
 366 |     |     function _approve(address to, uint256 tokenId) internal virtual {
 367 |     |         _tokenApprovals[tokenId] = to;
 368 |     |         emit Approval(ERC721.ownerOf(tokenId), to, tokenId);
 369 |     |     }
 370 |     | 
 371 |     |     /**
 372 |     |      * @dev Approve `operator` to operate on all of `owner` tokens
 373 |     |      *
 374 |     |      * Emits an {ApprovalForAll} event.
 375 |     |      */
 376 |     |     function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {
 377 |     |         require(owner != operator, "ERC721: approve to caller");
 378 |     |         _operatorApprovals[owner][operator] = approved;
 379 |     |         emit ApprovalForAll(owner, operator, approved);
 380 |     |     }
 381 |     | 
 382 |     |     /**
 383 |     |      * @dev Reverts if the `tokenId` has not been minted yet.
 384 |     |      */
 385 |     |     function _requireMinted(uint256 tokenId) internal view virtual {
 386 |     |         require(_exists(tokenId), "ERC721: invalid token ID");
 387 |     |     }
 388 |     | 
 389 |     |     /**
 390 |     |      * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.
 391 |     |      * The call is not executed if the target address is not a contract.
 392 |     |      *
 393 |     |      * @param from address representing the previous owner of the given token ID
 394 |     |      * @param to target address that will receive the tokens
 395 |     |      * @param tokenId uint256 ID of the token to be transferred
 396 |     |      * @param data bytes optional data to send along with the call
 397 |     |      * @return bool whether the call correctly returned the expected magic value
 398 |     |      */
 399 |     |     function _checkOnERC721Received(
 400 |     |         address from,
 401 |     |         address to,
 402 |     |         uint256 tokenId,
 403 |     |         bytes memory data
 404 |     |     ) private returns (bool) {
 405 |     |         if (to.isContract()) {
 406 |     |             try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {
 407 |     |                 return retval == IERC721Receiver.onERC721Received.selector;
 408 |     |             } catch (bytes memory reason) {
 409 |     |                 if (reason.length == 0) {
 410 |     |                     revert("ERC721: transfer to non ERC721Receiver implementer");
 411 |     |                 } else {
 412 |     |                     /// @solidity memory-safe-assembly
 413 |     |                     assembly {
 414 |     |                         revert(add(32, reason), mload(reason))
 415 |     |                     }
 416 |     |                 }
 417 |     |             }
 418 |     |         } else {
 419 |     |             return true;
 420 |     |         }
 421 |     |     }
 422 |     | 
 423 |     |     /**
 424 |     |      * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 425 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 426 |     |      *
 427 |     |      * Calling conditions:
 428 |     |      *
 429 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens will be transferred to `to`.
 430 |     |      * - When `from` is zero, the tokens will be minted for `to`.
 431 |     |      * - When `to` is zero, ``from``'s tokens will be burned.
 432 |     |      * - `from` and `to` are never both zero.
 433 |     |      * - `batchSize` is non-zero.
 434 |     |      *
 435 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 436 |     |      */
 437 |     |     function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 438 |     | 
 439 |     |     /**
 440 |     |      * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is
 441 |     |      * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.
 442 |     |      *
 443 |     |      * Calling conditions:
 444 |     |      *
 445 |     |      * - When `from` and `to` are both non-zero, ``from``'s tokens were transferred to `to`.
 446 |     |      * - When `from` is zero, the tokens were minted for `to`.
 447 |     |      * - When `to` is zero, ``from``'s tokens were burned.
 448 |     |      * - `from` and `to` are never both zero.
 449 |     |      * - `batchSize` is non-zero.
 450 |     |      *
 451 |     |      * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].
 452 |     |      */
 453 |     |     function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}
 454 |     | 
 455 |     |     /**
 456 |     |      * @dev Unsafe write access to the balances, used by extensions that "mint" tokens using an {ownerOf} override.
 457 |     |      *
 458 |     |      * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant
 459 |     |      * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such
 460 |     |      * that `ownerOf(tokenId)` is `a`.
 461 |     |      */
 462 |     |     // solhint-disable-next-line func-name-mixedcase
 463 |     |     function __unsafe_increaseBalance(address account, uint256 amount) internal {
 464 |     |         _balances[account] += amount;
 465 |     |     }
 466 |     | }
 467 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../../utils/introspection/IERC165.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Required interface of an ERC721 compliant contract.
  10 |     |  */
  11 |     | interface IERC721 is IERC165 {
  12 |     |     /**
  13 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
  14 |     |      */
  15 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
  16 |     | 
  17 |     |     /**
  18 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
  19 |     |      */
  20 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
  21 |     | 
  22 |     |     /**
  23 |     |      * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.
  24 |     |      */
  25 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
  26 |     | 
  27 |     |     /**
  28 |     |      * @dev Returns the number of tokens in ``owner``'s account.
  29 |     |      */
  30 |     |     function balanceOf(address owner) external view returns (uint256 balance);
  31 |     | 
  32 |     |     /**
  33 |     |      * @dev Returns the owner of the `tokenId` token.
  34 |     |      *
  35 |     |      * Requirements:
  36 |     |      *
  37 |     |      * - `tokenId` must exist.
  38 |     |      */
  39 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
  40 |     | 
  41 |     |     /**
  42 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  43 |     |      *
  44 |     |      * Requirements:
  45 |     |      *
  46 |     |      * - `from` cannot be the zero address.
  47 |     |      * - `to` cannot be the zero address.
  48 |     |      * - `tokenId` token must exist and be owned by `from`.
  49 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  50 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  51 |     |      *
  52 |     |      * Emits a {Transfer} event.
  53 |     |      */
  54 |     |     function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;
  55 |     | 
  56 |     |     /**
  57 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients
  58 |     |      * are aware of the ERC721 protocol to prevent tokens from being forever locked.
  59 |     |      *
  60 |     |      * Requirements:
  61 |     |      *
  62 |     |      * - `from` cannot be the zero address.
  63 |     |      * - `to` cannot be the zero address.
  64 |     |      * - `tokenId` token must exist and be owned by `from`.
  65 |     |      * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.
  66 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  67 |     |      *
  68 |     |      * Emits a {Transfer} event.
  69 |     |      */
  70 |     |     function safeTransferFrom(address from, address to, uint256 tokenId) external;
  71 |     | 
  72 |     |     /**
  73 |     |      * @dev Transfers `tokenId` token from `from` to `to`.
  74 |     |      *
  75 |     |      * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721
  76 |     |      * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must
  77 |     |      * understand this adds an external call which potentially creates a reentrancy vulnerability.
  78 |     |      *
  79 |     |      * Requirements:
  80 |     |      *
  81 |     |      * - `from` cannot be the zero address.
  82 |     |      * - `to` cannot be the zero address.
  83 |     |      * - `tokenId` token must be owned by `from`.
  84 |     |      * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.
  85 |     |      *
  86 |     |      * Emits a {Transfer} event.
  87 |     |      */
  88 |     |     function transferFrom(address from, address to, uint256 tokenId) external;
  89 |     | 
  90 |     |     /**
  91 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
  92 |     |      * The approval is cleared when the token is transferred.
  93 |     |      *
  94 |     |      * Only a single account can be approved at a time, so approving the zero address clears previous approvals.
  95 |     |      *
  96 |     |      * Requirements:
  97 |     |      *
  98 |     |      * - The caller must own the token or be an approved operator.
  99 |     |      * - `tokenId` must exist.
 100 |     |      *
 101 |     |      * Emits an {Approval} event.
 102 |     |      */
 103 |     |     function approve(address to, uint256 tokenId) external;
 104 |     | 
 105 |     |     /**
 106 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 107 |     |      * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.
 108 |     |      *
 109 |     |      * Requirements:
 110 |     |      *
 111 |     |      * - The `operator` cannot be the caller.
 112 |     |      *
 113 |     |      * Emits an {ApprovalForAll} event.
 114 |     |      */
 115 |     |     function setApprovalForAll(address operator, bool approved) external;
 116 |     | 
 117 |     |     /**
 118 |     |      * @dev Returns the account approved for `tokenId` token.
 119 |     |      *
 120 |     |      * Requirements:
 121 |     |      *
 122 |     |      * - `tokenId` must exist.
 123 |     |      */
 124 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 125 |     | 
 126 |     |     /**
 127 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 128 |     |      *
 129 |     |      * See {setApprovalForAll}
 130 |     |      */
 131 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 132 |     | }
 133 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title ERC721 token receiver interface
  8 |     |  * @dev Interface for any contract that wants to support safeTransfers
  9 |     |  * from ERC721 asset contracts.
 10 |     |  */
 11 |     | interface IERC721Receiver {
 12 |     |     /**
 13 |     |      * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}
 14 |     |      * by `operator` from `from`, this function is called.
 15 |     |      *
 16 |     |      * It must return its Solidity selector to confirm the token transfer.
 17 |     |      * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.
 18 |     |      *
 19 |     |      * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.
 20 |     |      */
 21 |     |     function onERC721Received(
 22 |     |         address operator,
 23 |     |         address from,
 24 |     |         uint256 tokenId,
 25 |     |         bytes calldata data
 26 |     |     ) external returns (bytes4);
 27 |     | }
 28 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "../IERC721.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @title ERC-721 Non-Fungible Token Standard, optional metadata extension
 10 |     |  * @dev See https://eips.ethereum.org/EIPS/eip-721
 11 |     |  */
 12 |     | interface IERC721Metadata is IERC721 {
 13 |     |     /**
 14 |     |      * @dev Returns the token collection name.
 15 |     |      */
 16 |     |     function name() external view returns (string memory);
 17 |     | 
 18 |     |     /**
 19 |     |      * @dev Returns the token collection symbol.
 20 |     |      */
 21 |     |     function symbol() external view returns (string memory);
 22 |     | 
 23 |     |     /**
 24 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 25 |     |      */
 26 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 27 |     | }
 28 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Address.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.1;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Collection of functions related to the address type
   8 |     |  */
   9 |     | library Address {
  10 |     |     /**
  11 |     |      * @dev Returns true if `account` is a contract.
  12 |     |      *
  13 |     |      * [IMPORTANT]
  14 |     |      * ====
  15 |     |      * It is unsafe to assume that an address for which this function returns
  16 |     |      * false is an externally-owned account (EOA) and not a contract.
  17 |     |      *
  18 |     |      * Among others, `isContract` will return false for the following
  19 |     |      * types of addresses:
  20 |     |      *
  21 |     |      *  - an externally-owned account
  22 |     |      *  - a contract in construction
  23 |     |      *  - an address where a contract will be created
  24 |     |      *  - an address where a contract lived, but was destroyed
  25 |     |      *
  26 |     |      * Furthermore, `isContract` will also return true if the target contract within
  27 |     |      * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,
  28 |     |      * which only has an effect at the end of a transaction.
  29 |     |      * ====
  30 |     |      *
  31 |     |      * [IMPORTANT]
  32 |     |      * ====
  33 |     |      * You shouldn't rely on `isContract` to protect against flash loan attacks!
  34 |     |      *
  35 |     |      * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets
  36 |     |      * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract
  37 |     |      * constructor.
  38 |     |      * ====
  39 |     |      */
  40 |     |     function isContract(address account) internal view returns (bool) {
  41 |     |         // This method relies on extcodesize/address.code.length, which returns 0
  42 |     |         // for contracts in construction, since the code is only stored at the end
  43 |     |         // of the constructor execution.
  44 |     | 
  45 |     |         return account.code.length > 0;
  46 |     |     }
  47 |     | 
  48 |     |     /**
  49 |     |      * @dev Replacement for Solidity's `transfer`: sends `amount` wei to
  50 |     |      * `recipient`, forwarding all available gas and reverting on errors.
  51 |     |      *
  52 |     |      * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost
  53 |     |      * of certain opcodes, possibly making contracts go over the 2300 gas limit
  54 |     |      * imposed by `transfer`, making them unable to receive funds via
  55 |     |      * `transfer`. {sendValue} removes this limitation.
  56 |     |      *
  57 |     |      * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].
  58 |     |      *
  59 |     |      * IMPORTANT: because control is transferred to `recipient`, care must be
  60 |     |      * taken to not create reentrancy vulnerabilities. Consider using
  61 |     |      * {ReentrancyGuard} or the
  62 |     |      * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].
  63 |     |      */
  64 |     |     function sendValue(address payable recipient, uint256 amount) internal {
  65 |     |         require(address(this).balance >= amount, "Address: insufficient balance");
  66 |     | 
  67 |     |         (bool success, ) = recipient.call{value: amount}("");
  68 |     |         require(success, "Address: unable to send value, recipient may have reverted");
  69 |     |     }
  70 |     | 
  71 |     |     /**
  72 |     |      * @dev Performs a Solidity function call using a low level `call`. A
  73 |     |      * plain `call` is an unsafe replacement for a function call: use this
  74 |     |      * function instead.
  75 |     |      *
  76 |     |      * If `target` reverts with a revert reason, it is bubbled up by this
  77 |     |      * function (like regular Solidity function calls).
  78 |     |      *
  79 |     |      * Returns the raw returned data. To convert to the expected return value,
  80 |     |      * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].
  81 |     |      *
  82 |     |      * Requirements:
  83 |     |      *
  84 |     |      * - `target` must be a contract.
  85 |     |      * - calling `target` with `data` must not revert.
  86 |     |      *
  87 |     |      * _Available since v3.1._
  88 |     |      */
  89 |     |     function functionCall(address target, bytes memory data) internal returns (bytes memory) {
  90 |     |         return functionCallWithValue(target, data, 0, "Address: low-level call failed");
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with
  95 |     |      * `errorMessage` as a fallback revert reason when `target` reverts.
  96 |     |      *
  97 |     |      * _Available since v3.1._
  98 |     |      */
  99 | *   |     function functionCall(
 100 |     |         address target,
 101 |     |         bytes memory data,
 102 |     |         string memory errorMessage
 103 | *   |     ) internal returns (bytes memory) {
 104 | *   |         return functionCallWithValue(target, data, 0, errorMessage);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 109 |     |      * but also transferring `value` wei to `target`.
 110 |     |      *
 111 |     |      * Requirements:
 112 |     |      *
 113 |     |      * - the calling contract must have an ETH balance of at least `value`.
 114 |     |      * - the called Solidity function must be `payable`.
 115 |     |      *
 116 |     |      * _Available since v3.1._
 117 |     |      */
 118 |     |     function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {
 119 |     |         return functionCallWithValue(target, data, value, "Address: low-level call with value failed");
 120 |     |     }
 121 |     | 
 122 |     |     /**
 123 |     |      * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but
 124 |     |      * with `errorMessage` as a fallback revert reason when `target` reverts.
 125 |     |      *
 126 |     |      * _Available since v3.1._
 127 |     |      */
 128 | *   |     function functionCallWithValue(
 129 |     |         address target,
 130 |     |         bytes memory data,
 131 |     |         uint256 value,
 132 |     |         string memory errorMessage
 133 |     |     ) internal returns (bytes memory) {
 134 |     |         require(address(this).balance >= value, "Address: insufficient balance for call");
 135 | *   |         (bool success, bytes memory returndata) = target.call{value: value}(data);
 136 | *   |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 137 |     |     }
 138 |     | 
 139 |     |     /**
 140 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 141 |     |      * but performing a static call.
 142 |     |      *
 143 |     |      * _Available since v3.3._
 144 |     |      */
 145 |     |     function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {
 146 |     |         return functionStaticCall(target, data, "Address: low-level static call failed");
 147 |     |     }
 148 |     | 
 149 |     |     /**
 150 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 151 |     |      * but performing a static call.
 152 |     |      *
 153 |     |      * _Available since v3.3._
 154 |     |      */
 155 |     |     function functionStaticCall(
 156 |     |         address target,
 157 |     |         bytes memory data,
 158 |     |         string memory errorMessage
 159 |     |     ) internal view returns (bytes memory) {
 160 |     |         (bool success, bytes memory returndata) = target.staticcall(data);
 161 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 162 |     |     }
 163 |     | 
 164 |     |     /**
 165 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],
 166 |     |      * but performing a delegate call.
 167 |     |      *
 168 |     |      * _Available since v3.4._
 169 |     |      */
 170 |     |     function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {
 171 |     |         return functionDelegateCall(target, data, "Address: low-level delegate call failed");
 172 |     |     }
 173 |     | 
 174 |     |     /**
 175 |     |      * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],
 176 |     |      * but performing a delegate call.
 177 |     |      *
 178 |     |      * _Available since v3.4._
 179 |     |      */
 180 |     |     function functionDelegateCall(
 181 |     |         address target,
 182 |     |         bytes memory data,
 183 |     |         string memory errorMessage
 184 |     |     ) internal returns (bytes memory) {
 185 |     |         (bool success, bytes memory returndata) = target.delegatecall(data);
 186 |     |         return verifyCallResultFromTarget(target, success, returndata, errorMessage);
 187 |     |     }
 188 |     | 
 189 |     |     /**
 190 |     |      * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling
 191 |     |      * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.
 192 |     |      *
 193 |     |      * _Available since v4.8._
 194 |     |      */
 195 | *   |     function verifyCallResultFromTarget(
 196 |     |         address target,
 197 |     |         bool success,
 198 |     |         bytes memory returndata,
 199 |     |         string memory errorMessage
 200 | *   |     ) internal view returns (bytes memory) {
 201 | *   |         if (success) {
 202 | *   |             if (returndata.length == 0) {
 203 |     |                 // only check isContract if the call was successful and the return data is empty
 204 |     |                 // otherwise we already know that it was a contract
 205 | *   |                 require(isContract(target), "Address: call to non-contract");
 206 |     |             }
 207 | *   |             return returndata;
 208 |     |         } else {
 209 |     |             _revert(returndata, errorMessage);
 210 |     |         }
 211 |     |     }
 212 |     | 
 213 |     |     /**
 214 |     |      * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the
 215 |     |      * revert reason or using the provided one.
 216 |     |      *
 217 |     |      * _Available since v4.3._
 218 |     |      */
 219 |     |     function verifyCallResult(
 220 |     |         bool success,
 221 |     |         bytes memory returndata,
 222 |     |         string memory errorMessage
 223 |     |     ) internal pure returns (bytes memory) {
 224 |     |         if (success) {
 225 |     |             return returndata;
 226 |     |         } else {
 227 |     |             _revert(returndata, errorMessage);
 228 |     |         }
 229 |     |     }
 230 |     | 
 231 |     |     function _revert(bytes memory returndata, string memory errorMessage) private pure {
 232 |     |         // Look for revert reason and bubble it up if present
 233 |     |         if (returndata.length > 0) {
 234 |     |             // The easiest way to bubble the revert reason is using memory via assembly
 235 |     |             /// @solidity memory-safe-assembly
 236 |     |             assembly {
 237 |     |                 let returndata_size := mload(returndata)
 238 |     |                 revert(add(32, returndata), returndata_size)
 239 |     |             }
 240 |     |         } else {
 241 |     |             revert(errorMessage);
 242 |     |         }
 243 |     |     }
 244 |     | }
 245 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Context.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Provides information about the current execution context, including the
  8 |     |  * sender of the transaction and its data. While these are generally available
  9 |     |  * via msg.sender and msg.data, they should not be accessed in such a direct
 10 |     |  * manner, since when dealing with meta-transactions the account sending and
 11 |     |  * paying for execution may not be the actual sender (as far as an application
 12 |     |  * is concerned).
 13 |     |  *
 14 |     |  * This contract is only required for intermediate, library-like contracts.
 15 |     |  */
 16 |     | abstract contract Context {
 17 |     |     function _msgSender() internal view virtual returns (address) {
 18 | *   |         return msg.sender;
 19 |     |     }
 20 |     | 
 21 |     |     function _msgData() internal view virtual returns (bytes calldata) {
 22 |     |         return msg.data;
 23 |     |     }
 24 |     | 
 25 |     |     function _contextSuffixLength() internal view virtual returns (uint256) {
 26 |     |         return 0;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Counters.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @title Counters
  8 |     |  * @author Matt Condon (@shrugs)
  9 |     |  * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number
 10 |     |  * of elements in a mapping, issuing ERC721 ids, or counting request ids.
 11 |     |  *
 12 |     |  * Include with `using Counters for Counters.Counter;`
 13 |     |  */
 14 |     | library Counters {
 15 |     |     struct Counter {
 16 |     |         // This variable should never be directly accessed by users of the library: interactions must be restricted to
 17 |     |         // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add
 18 |     |         // this feature: see https://github.com/ethereum/solidity/issues/4637
 19 |     |         uint256 _value; // default: 0
 20 |     |     }
 21 |     | 
 22 |     |     function current(Counter storage counter) internal view returns (uint256) {
 23 |     |         return counter._value;
 24 |     |     }
 25 |     | 
 26 |     |     function increment(Counter storage counter) internal {
 27 |     |         unchecked {
 28 |     |             counter._value += 1;
 29 |     |         }
 30 |     |     }
 31 |     | 
 32 |     |     function decrement(Counter storage counter) internal {
 33 |     |         uint256 value = counter._value;
 34 |     |         require(value > 0, "Counter: decrement overflow");
 35 |     |         unchecked {
 36 |     |             counter._value = value - 1;
 37 |     |         }
 38 |     |     }
 39 |     | 
 40 |     |     function reset(Counter storage counter) internal {
 41 |     |         counter._value = 0;
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/ShortStrings.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.8;
   5 |     | 
   6 |     | import "./StorageSlot.sol";
   7 |     | 
   8 |     | // | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |
   9 |     | // | length  | 0x                                                              BB |
  10 |     | type ShortString is bytes32;
  11 |     | 
  12 |     | /**
  13 |     |  * @dev This library provides functions to convert short memory strings
  14 |     |  * into a `ShortString` type that can be used as an immutable variable.
  15 |     |  *
  16 |     |  * Strings of arbitrary length can be optimized using this library if
  17 |     |  * they are short enough (up to 31 bytes) by packing them with their
  18 |     |  * length (1 byte) in a single EVM word (32 bytes). Additionally, a
  19 |     |  * fallback mechanism can be used for every other case.
  20 |     |  *
  21 |     |  * Usage example:
  22 |     |  *
  23 |     |  * ```solidity
  24 |     |  * contract Named {
  25 |     |  *     using ShortStrings for *;
  26 |     |  *
  27 |     |  *     ShortString private immutable _name;
  28 |     |  *     string private _nameFallback;
  29 |     |  *
  30 |     |  *     constructor(string memory contractName) {
  31 |     |  *         _name = contractName.toShortStringWithFallback(_nameFallback);
  32 |     |  *     }
  33 |     |  *
  34 |     |  *     function name() external view returns (string memory) {
  35 |     |  *         return _name.toStringWithFallback(_nameFallback);
  36 |     |  *     }
  37 |     |  * }
  38 |     |  * ```
  39 |     |  */
  40 |     | library ShortStrings {
  41 |     |     // Used as an identifier for strings longer than 31 bytes.
  42 |     |     bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;
  43 |     | 
  44 |     |     error StringTooLong(string str);
  45 |     |     error InvalidShortString();
  46 |     | 
  47 |     |     /**
  48 |     |      * @dev Encode a string of at most 31 chars into a `ShortString`.
  49 |     |      *
  50 |     |      * This will trigger a `StringTooLong` error is the input string is too long.
  51 |     |      */
  52 |     |     function toShortString(string memory str) internal pure returns (ShortString) {
  53 |     |         bytes memory bstr = bytes(str);
  54 |     |         if (bstr.length > 31) {
  55 |     |             revert StringTooLong(str);
  56 |     |         }
  57 |     |         return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));
  58 |     |     }
  59 |     | 
  60 |     |     /**
  61 |     |      * @dev Decode a `ShortString` back to a "normal" string.
  62 |     |      */
  63 |     |     function toString(ShortString sstr) internal pure returns (string memory) {
  64 |     |         uint256 len = byteLength(sstr);
  65 |     |         // using `new string(len)` would work locally but is not memory safe.
  66 |     |         string memory str = new string(32);
  67 |     |         /// @solidity memory-safe-assembly
  68 |     |         assembly {
  69 |     |             mstore(str, len)
  70 |     |             mstore(add(str, 0x20), sstr)
  71 |     |         }
  72 |     |         return str;
  73 |     |     }
  74 |     | 
  75 |     |     /**
  76 |     |      * @dev Return the length of a `ShortString`.
  77 |     |      */
  78 |     |     function byteLength(ShortString sstr) internal pure returns (uint256) {
  79 |     |         uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;
  80 |     |         if (result > 31) {
  81 |     |             revert InvalidShortString();
  82 |     |         }
  83 |     |         return result;
  84 |     |     }
  85 |     | 
  86 |     |     /**
  87 |     |      * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.
  88 |     |      */
  89 |     |     function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {
  90 |     |         if (bytes(value).length < 32) {
  91 |     |             return toShortString(value);
  92 |     |         } else {
  93 |     |             StorageSlot.getStringSlot(store).value = value;
  94 |     |             return ShortString.wrap(_FALLBACK_SENTINEL);
  95 |     |         }
  96 |     |     }
  97 |     | 
  98 |     |     /**
  99 |     |      * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.
 100 |     |      */
 101 |     |     function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {
 102 |     |         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {
 103 |     |             return toString(value);
 104 |     |         } else {
 105 |     |             return store;
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.
 111 |     |      *
 112 |     |      * WARNING: This will return the "byte length" of the string. This may not reflect the actual length in terms of
 113 |     |      * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.
 114 |     |      */
 115 |     |     function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {
 116 |     |         if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {
 117 |     |             return byteLength(value);
 118 |     |         } else {
 119 |     |             return bytes(store).length;
 120 |     |         }
 121 |     |     }
 122 |     | }
 123 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/StorageSlot.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)
   3 |     | // This file was procedurally generated from scripts/generate/templates/StorageSlot.js.
   4 |     | 
   5 |     | pragma solidity ^0.8.0;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Library for reading and writing primitive types to specific storage slots.
   9 |     |  *
  10 |     |  * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.
  11 |     |  * This library helps with reading and writing to such slots without the need for inline assembly.
  12 |     |  *
  13 |     |  * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.
  14 |     |  *
  15 |     |  * Example usage to set ERC1967 implementation slot:
  16 |     |  * ```solidity
  17 |     |  * contract ERC1967 {
  18 |     |  *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
  19 |     |  *
  20 |     |  *     function _getImplementation() internal view returns (address) {
  21 |     |  *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;
  22 |     |  *     }
  23 |     |  *
  24 |     |  *     function _setImplementation(address newImplementation) internal {
  25 |     |  *         require(Address.isContract(newImplementation), "ERC1967: new implementation is not a contract");
  26 |     |  *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;
  27 |     |  *     }
  28 |     |  * }
  29 |     |  * ```
  30 |     |  *
  31 |     |  * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._
  32 |     |  * _Available since v4.9 for `string`, `bytes`._
  33 |     |  */
  34 |     | library StorageSlot {
  35 |     |     struct AddressSlot {
  36 |     |         address value;
  37 |     |     }
  38 |     | 
  39 |     |     struct BooleanSlot {
  40 |     |         bool value;
  41 |     |     }
  42 |     | 
  43 |     |     struct Bytes32Slot {
  44 |     |         bytes32 value;
  45 |     |     }
  46 |     | 
  47 |     |     struct Uint256Slot {
  48 |     |         uint256 value;
  49 |     |     }
  50 |     | 
  51 |     |     struct StringSlot {
  52 |     |         string value;
  53 |     |     }
  54 |     | 
  55 |     |     struct BytesSlot {
  56 |     |         bytes value;
  57 |     |     }
  58 |     | 
  59 |     |     /**
  60 |     |      * @dev Returns an `AddressSlot` with member `value` located at `slot`.
  61 |     |      */
  62 |     |     function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {
  63 |     |         /// @solidity memory-safe-assembly
  64 |     |         assembly {
  65 |     |             r.slot := slot
  66 |     |         }
  67 |     |     }
  68 |     | 
  69 |     |     /**
  70 |     |      * @dev Returns an `BooleanSlot` with member `value` located at `slot`.
  71 |     |      */
  72 |     |     function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {
  73 |     |         /// @solidity memory-safe-assembly
  74 |     |         assembly {
  75 |     |             r.slot := slot
  76 |     |         }
  77 |     |     }
  78 |     | 
  79 |     |     /**
  80 |     |      * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.
  81 |     |      */
  82 |     |     function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {
  83 |     |         /// @solidity memory-safe-assembly
  84 |     |         assembly {
  85 |     |             r.slot := slot
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     /**
  90 |     |      * @dev Returns an `Uint256Slot` with member `value` located at `slot`.
  91 |     |      */
  92 |     |     function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {
  93 |     |         /// @solidity memory-safe-assembly
  94 |     |         assembly {
  95 |     |             r.slot := slot
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /**
 100 |     |      * @dev Returns an `StringSlot` with member `value` located at `slot`.
 101 |     |      */
 102 |     |     function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {
 103 |     |         /// @solidity memory-safe-assembly
 104 |     |         assembly {
 105 |     |             r.slot := slot
 106 |     |         }
 107 |     |     }
 108 |     | 
 109 |     |     /**
 110 |     |      * @dev Returns an `StringSlot` representation of the string storage pointer `store`.
 111 |     |      */
 112 |     |     function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {
 113 |     |         /// @solidity memory-safe-assembly
 114 |     |         assembly {
 115 |     |             r.slot := store.slot
 116 |     |         }
 117 |     |     }
 118 |     | 
 119 |     |     /**
 120 |     |      * @dev Returns an `BytesSlot` with member `value` located at `slot`.
 121 |     |      */
 122 |     |     function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {
 123 |     |         /// @solidity memory-safe-assembly
 124 |     |         assembly {
 125 |     |             r.slot := slot
 126 |     |         }
 127 |     |     }
 128 |     | 
 129 |     |     /**
 130 |     |      * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.
 131 |     |      */
 132 |     |     function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {
 133 |     |         /// @solidity memory-safe-assembly
 134 |     |         assembly {
 135 |     |             r.slot := store.slot
 136 |     |         }
 137 |     |     }
 138 |     | }
 139 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Strings.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./math/Math.sol";
  7 |     | import "./math/SignedMath.sol";
  8 |     | 
  9 |     | /**
 10 |     |  * @dev String operations.
 11 |     |  */
 12 |     | library Strings {
 13 |     |     bytes16 private constant _SYMBOLS = "0123456789abcdef";
 14 |     |     uint8 private constant _ADDRESS_LENGTH = 20;
 15 |     | 
 16 |     |     /**
 17 |     |      * @dev Converts a `uint256` to its ASCII `string` decimal representation.
 18 |     |      */
 19 |     |     function toString(uint256 value) internal pure returns (string memory) {
 20 |     |         unchecked {
 21 |     |             uint256 length = Math.log10(value) + 1;
 22 |     |             string memory buffer = new string(length);
 23 |     |             uint256 ptr;
 24 |     |             /// @solidity memory-safe-assembly
 25 |     |             assembly {
 26 |     |                 ptr := add(buffer, add(32, length))
 27 |     |             }
 28 |     |             while (true) {
 29 |     |                 ptr--;
 30 |     |                 /// @solidity memory-safe-assembly
 31 |     |                 assembly {
 32 |     |                     mstore8(ptr, byte(mod(value, 10), _SYMBOLS))
 33 |     |                 }
 34 |     |                 value /= 10;
 35 |     |                 if (value == 0) break;
 36 |     |             }
 37 |     |             return buffer;
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /**
 42 |     |      * @dev Converts a `int256` to its ASCII `string` decimal representation.
 43 |     |      */
 44 |     |     function toString(int256 value) internal pure returns (string memory) {
 45 |     |         return string(abi.encodePacked(value < 0 ? "-" : "", toString(SignedMath.abs(value))));
 46 |     |     }
 47 |     | 
 48 |     |     /**
 49 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
 50 |     |      */
 51 |     |     function toHexString(uint256 value) internal pure returns (string memory) {
 52 |     |         unchecked {
 53 |     |             return toHexString(value, Math.log256(value) + 1);
 54 |     |         }
 55 |     |     }
 56 |     | 
 57 |     |     /**
 58 |     |      * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
 59 |     |      */
 60 |     |     function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
 61 |     |         bytes memory buffer = new bytes(2 * length + 2);
 62 |     |         buffer[0] = "0";
 63 |     |         buffer[1] = "x";
 64 |     |         for (uint256 i = 2 * length + 1; i > 1; --i) {
 65 |     |             buffer[i] = _SYMBOLS[value & 0xf];
 66 |     |             value >>= 4;
 67 |     |         }
 68 |     |         require(value == 0, "Strings: hex length insufficient");
 69 |     |         return string(buffer);
 70 |     |     }
 71 |     | 
 72 |     |     /**
 73 |     |      * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.
 74 |     |      */
 75 |     |     function toHexString(address addr) internal pure returns (string memory) {
 76 |     |         return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);
 77 |     |     }
 78 |     | 
 79 |     |     /**
 80 |     |      * @dev Returns true if the two strings are equal.
 81 |     |      */
 82 |     |     function equal(string memory a, string memory b) internal pure returns (bool) {
 83 |     |         return keccak256(bytes(a)) == keccak256(bytes(b));
 84 |     |     }
 85 |     | }
 86 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | import "../Strings.sol";
   7 |     | 
   8 |     | /**
   9 |     |  * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.
  10 |     |  *
  11 |     |  * These functions can be used to verify that a message was signed by the holder
  12 |     |  * of the private keys of a given address.
  13 |     |  */
  14 |     | library ECDSA {
  15 |     |     enum RecoverError {
  16 |     |         NoError,
  17 |     |         InvalidSignature,
  18 |     |         InvalidSignatureLength,
  19 |     |         InvalidSignatureS,
  20 |     |         InvalidSignatureV // Deprecated in v4.8
  21 |     |     }
  22 |     | 
  23 |     |     function _throwError(RecoverError error) private pure {
  24 |     |         if (error == RecoverError.NoError) {
  25 |     |             return; // no error: do nothing
  26 |     |         } else if (error == RecoverError.InvalidSignature) {
  27 |     |             revert("ECDSA: invalid signature");
  28 |     |         } else if (error == RecoverError.InvalidSignatureLength) {
  29 |     |             revert("ECDSA: invalid signature length");
  30 |     |         } else if (error == RecoverError.InvalidSignatureS) {
  31 |     |             revert("ECDSA: invalid signature 's' value");
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 |     |     /**
  36 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  37 |     |      * `signature` or error string. This address can then be used for verification purposes.
  38 |     |      *
  39 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  40 |     |      * this function rejects them by requiring the `s` value to be in the lower
  41 |     |      * half order, and the `v` value to be either 27 or 28.
  42 |     |      *
  43 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  44 |     |      * verification to be secure: it is possible to craft signatures that
  45 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  46 |     |      * this is by receiving a hash of the original message (which may otherwise
  47 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  48 |     |      *
  49 |     |      * Documentation for signature generation:
  50 |     |      * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]
  51 |     |      * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]
  52 |     |      *
  53 |     |      * _Available since v4.3._
  54 |     |      */
  55 |     |     function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {
  56 |     |         if (signature.length == 65) {
  57 |     |             bytes32 r;
  58 |     |             bytes32 s;
  59 |     |             uint8 v;
  60 |     |             // ecrecover takes the signature parameters, and the only way to get them
  61 |     |             // currently is to use assembly.
  62 |     |             /// @solidity memory-safe-assembly
  63 |     |             assembly {
  64 |     |                 r := mload(add(signature, 0x20))
  65 |     |                 s := mload(add(signature, 0x40))
  66 |     |                 v := byte(0, mload(add(signature, 0x60)))
  67 |     |             }
  68 |     |             return tryRecover(hash, v, r, s);
  69 |     |         } else {
  70 |     |             return (address(0), RecoverError.InvalidSignatureLength);
  71 |     |         }
  72 |     |     }
  73 |     | 
  74 |     |     /**
  75 |     |      * @dev Returns the address that signed a hashed message (`hash`) with
  76 |     |      * `signature`. This address can then be used for verification purposes.
  77 |     |      *
  78 |     |      * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:
  79 |     |      * this function rejects them by requiring the `s` value to be in the lower
  80 |     |      * half order, and the `v` value to be either 27 or 28.
  81 |     |      *
  82 |     |      * IMPORTANT: `hash` _must_ be the result of a hash operation for the
  83 |     |      * verification to be secure: it is possible to craft signatures that
  84 |     |      * recover to arbitrary addresses for non-hashed data. A safe way to ensure
  85 |     |      * this is by receiving a hash of the original message (which may otherwise
  86 |     |      * be too long), and then calling {toEthSignedMessageHash} on it.
  87 |     |      */
  88 |     |     function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {
  89 |     |         (address recovered, RecoverError error) = tryRecover(hash, signature);
  90 |     |         _throwError(error);
  91 |     |         return recovered;
  92 |     |     }
  93 |     | 
  94 |     |     /**
  95 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.
  96 |     |      *
  97 |     |      * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]
  98 |     |      *
  99 |     |      * _Available since v4.3._
 100 |     |      */
 101 |     |     function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {
 102 |     |         bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);
 103 |     |         uint8 v = uint8((uint256(vs) >> 255) + 27);
 104 |     |         return tryRecover(hash, v, r, s);
 105 |     |     }
 106 |     | 
 107 |     |     /**
 108 |     |      * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.
 109 |     |      *
 110 |     |      * _Available since v4.2._
 111 |     |      */
 112 |     |     function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {
 113 |     |         (address recovered, RecoverError error) = tryRecover(hash, r, vs);
 114 |     |         _throwError(error);
 115 |     |         return recovered;
 116 |     |     }
 117 |     | 
 118 |     |     /**
 119 |     |      * @dev Overload of {ECDSA-tryRecover} that receives the `v`,
 120 |     |      * `r` and `s` signature fields separately.
 121 |     |      *
 122 |     |      * _Available since v4.3._
 123 |     |      */
 124 |     |     function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {
 125 |     |         // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature
 126 |     |         // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines
 127 |     |         // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most
 128 |     |         // signatures from current libraries generate a unique signature with an s-value in the lower half order.
 129 |     |         //
 130 |     |         // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value
 131 |     |         // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or
 132 |     |         // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept
 133 |     |         // these malleable signatures as well.
 134 |     |         if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {
 135 |     |             return (address(0), RecoverError.InvalidSignatureS);
 136 |     |         }
 137 |     | 
 138 |     |         // If the signature is valid (and not malleable), return the signer address
 139 |     |         address signer = ecrecover(hash, v, r, s);
 140 |     |         if (signer == address(0)) {
 141 |     |             return (address(0), RecoverError.InvalidSignature);
 142 |     |         }
 143 |     | 
 144 |     |         return (signer, RecoverError.NoError);
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Overload of {ECDSA-recover} that receives the `v`,
 149 |     |      * `r` and `s` signature fields separately.
 150 |     |      */
 151 | *   |     function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {
 152 |     |         (address recovered, RecoverError error) = tryRecover(hash, v, r, s);
 153 |     |         _throwError(error);
 154 |     |         return recovered;
 155 |     |     }
 156 |     | 
 157 |     |     /**
 158 |     |      * @dev Returns an Ethereum Signed Message, created from a `hash`. This
 159 |     |      * produces hash corresponding to the one signed with the
 160 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 161 |     |      * JSON-RPC method as part of EIP-191.
 162 |     |      *
 163 |     |      * See {recover}.
 164 |     |      */
 165 |     |     function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {
 166 |     |         // 32 is the length in bytes of hash,
 167 |     |         // enforced by the type signature above
 168 |     |         /// @solidity memory-safe-assembly
 169 |     |         assembly {
 170 |     |             mstore(0x00, "\x19Ethereum Signed Message:\n32")
 171 |     |             mstore(0x1c, hash)
 172 |     |             message := keccak256(0x00, 0x3c)
 173 |     |         }
 174 |     |     }
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Returns an Ethereum Signed Message, created from `s`. This
 178 |     |      * produces hash corresponding to the one signed with the
 179 |     |      * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]
 180 |     |      * JSON-RPC method as part of EIP-191.
 181 |     |      *
 182 |     |      * See {recover}.
 183 |     |      */
 184 |     |     function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {
 185 |     |         return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n", Strings.toString(s.length), s));
 186 |     |     }
 187 |     | 
 188 |     |     /**
 189 |     |      * @dev Returns an Ethereum Signed Typed Data, created from a
 190 |     |      * `domainSeparator` and a `structHash`. This produces hash corresponding
 191 |     |      * to the one signed with the
 192 |     |      * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]
 193 |     |      * JSON-RPC method as part of EIP-712.
 194 |     |      *
 195 |     |      * See {recover}.
 196 |     |      */
 197 |     |     function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {
 198 |     |         /// @solidity memory-safe-assembly
 199 |     |         assembly {
 200 |     |             let ptr := mload(0x40)
 201 |     |             mstore(ptr, "\x19\x01")
 202 |     |             mstore(add(ptr, 0x02), domainSeparator)
 203 |     |             mstore(add(ptr, 0x22), structHash)
 204 |     |             data := keccak256(ptr, 0x42)
 205 |     |         }
 206 |     |     }
 207 |     | 
 208 |     |     /**
 209 |     |      * @dev Returns an Ethereum Signed Data with intended validator, created from a
 210 |     |      * `validator` and `data` according to the version 0 of EIP-191.
 211 |     |      *
 212 |     |      * See {recover}.
 213 |     |      */
 214 |     |     function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {
 215 |     |         return keccak256(abi.encodePacked("\x19\x00", validator, data));
 216 |     |     }
 217 |     | }
 218 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.8;
   5 |     | 
   6 |     | import "./ECDSA.sol";
   7 |     | import "../ShortStrings.sol";
   8 |     | import "../../interfaces/IERC5267.sol";
   9 |     | 
  10 |     | /**
  11 |     |  * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.
  12 |     |  *
  13 |     |  * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,
  14 |     |  * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding
  15 |     |  * they need in their contracts using a combination of `abi.encode` and `keccak256`.
  16 |     |  *
  17 |     |  * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding
  18 |     |  * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA
  19 |     |  * ({_hashTypedDataV4}).
  20 |     |  *
  21 |     |  * The implementation of the domain separator was designed to be as efficient as possible while still properly updating
  22 |     |  * the chain id to protect against replay attacks on an eventual fork of the chain.
  23 |     |  *
  24 |     |  * NOTE: This contract implements the version of the encoding known as "v4", as implemented by the JSON RPC method
  25 |     |  * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].
  26 |     |  *
  27 |     |  * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain
  28 |     |  * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the
  29 |     |  * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.
  30 |     |  *
  31 |     |  * _Available since v3.4._
  32 |     |  *
  33 |     |  * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment
  34 |     |  */
  35 |     | abstract contract EIP712 is IERC5267 {
  36 |     |     using ShortStrings for *;
  37 |     | 
  38 |     |     bytes32 private constant _TYPE_HASH =
  39 |     |         keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)");
  40 |     | 
  41 |     |     // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to
  42 |     |     // invalidate the cached domain separator if the chain id changes.
  43 |     |     bytes32 private immutable _cachedDomainSeparator;
  44 |     |     uint256 private immutable _cachedChainId;
  45 |     |     address private immutable _cachedThis;
  46 |     | 
  47 |     |     bytes32 private immutable _hashedName;
  48 |     |     bytes32 private immutable _hashedVersion;
  49 |     | 
  50 |     |     ShortString private immutable _name;
  51 |     |     ShortString private immutable _version;
  52 |     |     string private _nameFallback;
  53 |     |     string private _versionFallback;
  54 |     | 
  55 |     |     /**
  56 |     |      * @dev Initializes the domain separator and parameter caches.
  57 |     |      *
  58 |     |      * The meaning of `name` and `version` is specified in
  59 |     |      * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:
  60 |     |      *
  61 |     |      * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.
  62 |     |      * - `version`: the current major version of the signing domain.
  63 |     |      *
  64 |     |      * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart
  65 |     |      * contract upgrade].
  66 |     |      */
  67 |     |     constructor(string memory name, string memory version) {
  68 |     |         _name = name.toShortStringWithFallback(_nameFallback);
  69 |     |         _version = version.toShortStringWithFallback(_versionFallback);
  70 |     |         _hashedName = keccak256(bytes(name));
  71 |     |         _hashedVersion = keccak256(bytes(version));
  72 |     | 
  73 |     |         _cachedChainId = block.chainid;
  74 |     |         _cachedDomainSeparator = _buildDomainSeparator();
  75 |     |         _cachedThis = address(this);
  76 |     |     }
  77 |     | 
  78 |     |     /**
  79 |     |      * @dev Returns the domain separator for the current chain.
  80 |     |      */
  81 |     |     function _domainSeparatorV4() internal view returns (bytes32) {
  82 |     |         if (address(this) == _cachedThis && block.chainid == _cachedChainId) {
  83 |     |             return _cachedDomainSeparator;
  84 |     |         } else {
  85 |     |             return _buildDomainSeparator();
  86 |     |         }
  87 |     |     }
  88 |     | 
  89 |     |     function _buildDomainSeparator() private view returns (bytes32) {
  90 |     |         return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));
  91 |     |     }
  92 |     | 
  93 |     |     /**
  94 |     |      * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this
  95 |     |      * function returns the hash of the fully encoded EIP712 message for this domain.
  96 |     |      *
  97 |     |      * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:
  98 |     |      *
  99 |     |      * ```solidity
 100 |     |      * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(
 101 |     |      *     keccak256("Mail(address to,string contents)"),
 102 |     |      *     mailTo,
 103 |     |      *     keccak256(bytes(mailContents))
 104 |     |      * )));
 105 |     |      * address signer = ECDSA.recover(digest, signature);
 106 |     |      * ```
 107 |     |      */
 108 |     |     function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {
 109 |     |         return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);
 110 |     |     }
 111 |     | 
 112 |     |     /**
 113 |     |      * @dev See {EIP-5267}.
 114 |     |      *
 115 |     |      * _Available since v4.9._
 116 |     |      */
 117 |     |     function eip712Domain()
 118 |     |         public
 119 |     |         view
 120 |     |         virtual
 121 |     |         override
 122 |     |         returns (
 123 |     |             bytes1 fields,
 124 |     |             string memory name,
 125 |     |             string memory version,
 126 |     |             uint256 chainId,
 127 |     |             address verifyingContract,
 128 |     |             bytes32 salt,
 129 |     |             uint256[] memory extensions
 130 |     |         )
 131 |     |     {
 132 |     |         return (
 133 |     |             hex"0f", // 01111
 134 |     |             _name.toStringWithFallback(_nameFallback),
 135 |     |             _version.toStringWithFallback(_versionFallback),
 136 |     |             block.chainid,
 137 |     |             address(this),
 138 |     |             bytes32(0),
 139 |     |             new uint256[](0)
 140 |     |         );
 141 |     |     }
 142 |     | }
 143 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | import "./IERC165.sol";
  7 |     | 
  8 |     | /**
  9 |     |  * @dev Implementation of the {IERC165} interface.
 10 |     |  *
 11 |     |  * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 12 |     |  * for the additional interface id that will be supported. For example:
 13 |     |  *
 14 |     |  * ```solidity
 15 |     |  * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 16 |     |  *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 17 |     |  * }
 18 |     |  * ```
 19 |     |  *
 20 |     |  * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.
 21 |     |  */
 22 |     | abstract contract ERC165 is IERC165 {
 23 |     |     /**
 24 |     |      * @dev See {IERC165-supportsInterface}.
 25 |     |      */
 26 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 27 |     |         return interfaceId == type(IERC165).interfaceId;
 28 |     |     }
 29 |     | }
 30 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Interface of the ERC165 standard, as defined in the
  8 |     |  * https://eips.ethereum.org/EIPS/eip-165[EIP].
  9 |     |  *
 10 |     |  * Implementers can declare support of contract interfaces, which can then be
 11 |     |  * queried by others ({ERC165Checker}).
 12 |     |  *
 13 |     |  * For an implementation, see {ERC165}.
 14 |     |  */
 15 |     | interface IERC165 {
 16 |     |     /**
 17 |     |      * @dev Returns true if this contract implements the interface defined by
 18 |     |      * `interfaceId`. See the corresponding
 19 |     |      * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
 20 |     |      * to learn more about how these ids are created.
 21 |     |      *
 22 |     |      * This function call must use less than 30 000 gas.
 23 |     |      */
 24 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 25 |     | }
 26 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/Math.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)
   3 |     | 
   4 |     | pragma solidity ^0.8.0;
   5 |     | 
   6 |     | /**
   7 |     |  * @dev Standard math utilities missing in the Solidity language.
   8 |     |  */
   9 |     | library Math {
  10 |     |     enum Rounding {
  11 |     |         Down, // Toward negative infinity
  12 |     |         Up, // Toward infinity
  13 |     |         Zero // Toward zero
  14 |     |     }
  15 |     | 
  16 |     |     /**
  17 |     |      * @dev Returns the largest of two numbers.
  18 |     |      */
  19 |     |     function max(uint256 a, uint256 b) internal pure returns (uint256) {
  20 |     |         return a > b ? a : b;
  21 |     |     }
  22 |     | 
  23 |     |     /**
  24 |     |      * @dev Returns the smallest of two numbers.
  25 |     |      */
  26 |     |     function min(uint256 a, uint256 b) internal pure returns (uint256) {
  27 |     |         return a < b ? a : b;
  28 |     |     }
  29 |     | 
  30 |     |     /**
  31 |     |      * @dev Returns the average of two numbers. The result is rounded towards
  32 |     |      * zero.
  33 |     |      */
  34 |     |     function average(uint256 a, uint256 b) internal pure returns (uint256) {
  35 |     |         // (a + b) / 2 can overflow.
  36 |     |         return (a & b) + (a ^ b) / 2;
  37 |     |     }
  38 |     | 
  39 |     |     /**
  40 |     |      * @dev Returns the ceiling of the division of two numbers.
  41 |     |      *
  42 |     |      * This differs from standard division with `/` in that it rounds up instead
  43 |     |      * of rounding down.
  44 |     |      */
  45 |     |     function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
  46 |     |         // (a + b - 1) / b can overflow on addition, so we distribute.
  47 |     |         return a == 0 ? 0 : (a - 1) / b + 1;
  48 |     |     }
  49 |     | 
  50 |     |     /**
  51 |     |      * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
  52 |     |      * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)
  53 |     |      * with further edits by Uniswap Labs also under MIT license.
  54 |     |      */
  55 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
  56 |     |         unchecked {
  57 |     |             // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
  58 |     |             // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
  59 |     |             // variables such that product = prod1 * 2^256 + prod0.
  60 |     |             uint256 prod0; // Least significant 256 bits of the product
  61 |     |             uint256 prod1; // Most significant 256 bits of the product
  62 |     |             assembly {
  63 |     |                 let mm := mulmod(x, y, not(0))
  64 |     |                 prod0 := mul(x, y)
  65 |     |                 prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  66 |     |             }
  67 |     | 
  68 |     |             // Handle non-overflow cases, 256 by 256 division.
  69 |     |             if (prod1 == 0) {
  70 |     |                 // Solidity will revert if denominator == 0, unlike the div opcode on its own.
  71 |     |                 // The surrounding unchecked block does not change this fact.
  72 |     |                 // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
  73 |     |                 return prod0 / denominator;
  74 |     |             }
  75 |     | 
  76 |     |             // Make sure the result is less than 2^256. Also prevents denominator == 0.
  77 |     |             require(denominator > prod1, "Math: mulDiv overflow");
  78 |     | 
  79 |     |             ///////////////////////////////////////////////
  80 |     |             // 512 by 256 division.
  81 |     |             ///////////////////////////////////////////////
  82 |     | 
  83 |     |             // Make division exact by subtracting the remainder from [prod1 prod0].
  84 |     |             uint256 remainder;
  85 |     |             assembly {
  86 |     |                 // Compute remainder using mulmod.
  87 |     |                 remainder := mulmod(x, y, denominator)
  88 |     | 
  89 |     |                 // Subtract 256 bit number from 512 bit number.
  90 |     |                 prod1 := sub(prod1, gt(remainder, prod0))
  91 |     |                 prod0 := sub(prod0, remainder)
  92 |     |             }
  93 |     | 
  94 |     |             // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.
  95 |     |             // See https://cs.stackexchange.com/q/138556/92363.
  96 |     | 
  97 |     |             // Does not overflow because the denominator cannot be zero at this stage in the function.
  98 |     |             uint256 twos = denominator & (~denominator + 1);
  99 |     |             assembly {
 100 |     |                 // Divide denominator by twos.
 101 |     |                 denominator := div(denominator, twos)
 102 |     | 
 103 |     |                 // Divide [prod1 prod0] by twos.
 104 |     |                 prod0 := div(prod0, twos)
 105 |     | 
 106 |     |                 // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
 107 |     |                 twos := add(div(sub(0, twos), twos), 1)
 108 |     |             }
 109 |     | 
 110 |     |             // Shift in bits from prod1 into prod0.
 111 |     |             prod0 |= prod1 * twos;
 112 |     | 
 113 |     |             // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
 114 |     |             // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
 115 |     |             // four bits. That is, denominator * inv = 1 mod 2^4.
 116 |     |             uint256 inverse = (3 * denominator) ^ 2;
 117 |     | 
 118 |     |             // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works
 119 |     |             // in modular arithmetic, doubling the correct bits in each step.
 120 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^8
 121 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^16
 122 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^32
 123 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^64
 124 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^128
 125 |     |             inverse *= 2 - denominator * inverse; // inverse mod 2^256
 126 |     | 
 127 |     |             // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
 128 |     |             // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
 129 |     |             // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
 130 |     |             // is no longer required.
 131 |     |             result = prod0 * inverse;
 132 |     |             return result;
 133 |     |         }
 134 |     |     }
 135 |     | 
 136 |     |     /**
 137 |     |      * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
 138 |     |      */
 139 |     |     function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
 140 |     |         uint256 result = mulDiv(x, y, denominator);
 141 |     |         if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {
 142 |     |             result += 1;
 143 |     |         }
 144 |     |         return result;
 145 |     |     }
 146 |     | 
 147 |     |     /**
 148 |     |      * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.
 149 |     |      *
 150 |     |      * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
 151 |     |      */
 152 |     |     function sqrt(uint256 a) internal pure returns (uint256) {
 153 |     |         if (a == 0) {
 154 |     |             return 0;
 155 |     |         }
 156 |     | 
 157 |     |         // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
 158 |     |         //
 159 |     |         // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
 160 |     |         // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
 161 |     |         //
 162 |     |         // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
 163 |     |         //  `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
 164 |     |         //  `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
 165 |     |         //
 166 |     |         // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
 167 |     |         uint256 result = 1 << (log2(a) >> 1);
 168 |     | 
 169 |     |         // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
 170 |     |         // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
 171 |     |         // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
 172 |     |         // into the expected uint128 result.
 173 |     |         unchecked {
 174 |     |             result = (result + a / result) >> 1;
 175 |     |             result = (result + a / result) >> 1;
 176 |     |             result = (result + a / result) >> 1;
 177 |     |             result = (result + a / result) >> 1;
 178 |     |             result = (result + a / result) >> 1;
 179 |     |             result = (result + a / result) >> 1;
 180 |     |             result = (result + a / result) >> 1;
 181 |     |             return min(result, a / result);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /**
 186 |     |      * @notice Calculates sqrt(a), following the selected rounding direction.
 187 |     |      */
 188 |     |     function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
 189 |     |         unchecked {
 190 |     |             uint256 result = sqrt(a);
 191 |     |             return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);
 192 |     |         }
 193 |     |     }
 194 |     | 
 195 |     |     /**
 196 |     |      * @dev Return the log in base 2, rounded down, of a positive value.
 197 |     |      * Returns 0 if given 0.
 198 |     |      */
 199 |     |     function log2(uint256 value) internal pure returns (uint256) {
 200 |     |         uint256 result = 0;
 201 |     |         unchecked {
 202 |     |             if (value >> 128 > 0) {
 203 |     |                 value >>= 128;
 204 |     |                 result += 128;
 205 |     |             }
 206 |     |             if (value >> 64 > 0) {
 207 |     |                 value >>= 64;
 208 |     |                 result += 64;
 209 |     |             }
 210 |     |             if (value >> 32 > 0) {
 211 |     |                 value >>= 32;
 212 |     |                 result += 32;
 213 |     |             }
 214 |     |             if (value >> 16 > 0) {
 215 |     |                 value >>= 16;
 216 |     |                 result += 16;
 217 |     |             }
 218 |     |             if (value >> 8 > 0) {
 219 |     |                 value >>= 8;
 220 |     |                 result += 8;
 221 |     |             }
 222 |     |             if (value >> 4 > 0) {
 223 |     |                 value >>= 4;
 224 |     |                 result += 4;
 225 |     |             }
 226 |     |             if (value >> 2 > 0) {
 227 |     |                 value >>= 2;
 228 |     |                 result += 2;
 229 |     |             }
 230 |     |             if (value >> 1 > 0) {
 231 |     |                 result += 1;
 232 |     |             }
 233 |     |         }
 234 |     |         return result;
 235 |     |     }
 236 |     | 
 237 |     |     /**
 238 |     |      * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
 239 |     |      * Returns 0 if given 0.
 240 |     |      */
 241 |     |     function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
 242 |     |         unchecked {
 243 |     |             uint256 result = log2(value);
 244 |     |             return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);
 245 |     |         }
 246 |     |     }
 247 |     | 
 248 |     |     /**
 249 |     |      * @dev Return the log in base 10, rounded down, of a positive value.
 250 |     |      * Returns 0 if given 0.
 251 |     |      */
 252 |     |     function log10(uint256 value) internal pure returns (uint256) {
 253 |     |         uint256 result = 0;
 254 |     |         unchecked {
 255 |     |             if (value >= 10 ** 64) {
 256 |     |                 value /= 10 ** 64;
 257 |     |                 result += 64;
 258 |     |             }
 259 |     |             if (value >= 10 ** 32) {
 260 |     |                 value /= 10 ** 32;
 261 |     |                 result += 32;
 262 |     |             }
 263 |     |             if (value >= 10 ** 16) {
 264 |     |                 value /= 10 ** 16;
 265 |     |                 result += 16;
 266 |     |             }
 267 |     |             if (value >= 10 ** 8) {
 268 |     |                 value /= 10 ** 8;
 269 |     |                 result += 8;
 270 |     |             }
 271 |     |             if (value >= 10 ** 4) {
 272 |     |                 value /= 10 ** 4;
 273 |     |                 result += 4;
 274 |     |             }
 275 |     |             if (value >= 10 ** 2) {
 276 |     |                 value /= 10 ** 2;
 277 |     |                 result += 2;
 278 |     |             }
 279 |     |             if (value >= 10 ** 1) {
 280 |     |                 result += 1;
 281 |     |             }
 282 |     |         }
 283 |     |         return result;
 284 |     |     }
 285 |     | 
 286 |     |     /**
 287 |     |      * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
 288 |     |      * Returns 0 if given 0.
 289 |     |      */
 290 |     |     function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
 291 |     |         unchecked {
 292 |     |             uint256 result = log10(value);
 293 |     |             return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);
 294 |     |         }
 295 |     |     }
 296 |     | 
 297 |     |     /**
 298 |     |      * @dev Return the log in base 256, rounded down, of a positive value.
 299 |     |      * Returns 0 if given 0.
 300 |     |      *
 301 |     |      * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
 302 |     |      */
 303 |     |     function log256(uint256 value) internal pure returns (uint256) {
 304 |     |         uint256 result = 0;
 305 |     |         unchecked {
 306 |     |             if (value >> 128 > 0) {
 307 |     |                 value >>= 128;
 308 |     |                 result += 16;
 309 |     |             }
 310 |     |             if (value >> 64 > 0) {
 311 |     |                 value >>= 64;
 312 |     |                 result += 8;
 313 |     |             }
 314 |     |             if (value >> 32 > 0) {
 315 |     |                 value >>= 32;
 316 |     |                 result += 4;
 317 |     |             }
 318 |     |             if (value >> 16 > 0) {
 319 |     |                 value >>= 16;
 320 |     |                 result += 2;
 321 |     |             }
 322 |     |             if (value >> 8 > 0) {
 323 |     |                 result += 1;
 324 |     |             }
 325 |     |         }
 326 |     |         return result;
 327 |     |     }
 328 |     | 
 329 |     |     /**
 330 |     |      * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
 331 |     |      * Returns 0 if given 0.
 332 |     |      */
 333 |     |     function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
 334 |     |         unchecked {
 335 |     |             uint256 result = log256(value);
 336 |     |             return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);
 337 |     |         }
 338 |     |     }
 339 |     | }
 340 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)
    3 |     | // This file was procedurally generated from scripts/generate/templates/SafeCast.js.
    4 |     | 
    5 |     | pragma solidity ^0.8.0;
    6 |     | 
    7 |     | /**
    8 |     |  * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow
    9 |     |  * checks.
   10 |     |  *
   11 |     |  * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can
   12 |     |  * easily result in undesired exploitation or bugs, since developers usually
   13 |     |  * assume that overflows raise errors. `SafeCast` restores this intuition by
   14 |     |  * reverting the transaction when such an operation overflows.
   15 |     |  *
   16 |     |  * Using this library instead of the unchecked operations eliminates an entire
   17 |     |  * class of bugs, so it's recommended to use it always.
   18 |     |  *
   19 |     |  * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing
   20 |     |  * all math on `uint256` and `int256` and then downcasting.
   21 |     |  */
   22 |     | library SafeCast {
   23 |     |     /**
   24 |     |      * @dev Returns the downcasted uint248 from uint256, reverting on
   25 |     |      * overflow (when the input is greater than largest uint248).
   26 |     |      *
   27 |     |      * Counterpart to Solidity's `uint248` operator.
   28 |     |      *
   29 |     |      * Requirements:
   30 |     |      *
   31 |     |      * - input must fit into 248 bits
   32 |     |      *
   33 |     |      * _Available since v4.7._
   34 |     |      */
   35 |     |     function toUint248(uint256 value) internal pure returns (uint248) {
   36 |     |         require(value <= type(uint248).max, "SafeCast: value doesn't fit in 248 bits");
   37 |     |         return uint248(value);
   38 |     |     }
   39 |     | 
   40 |     |     /**
   41 |     |      * @dev Returns the downcasted uint240 from uint256, reverting on
   42 |     |      * overflow (when the input is greater than largest uint240).
   43 |     |      *
   44 |     |      * Counterpart to Solidity's `uint240` operator.
   45 |     |      *
   46 |     |      * Requirements:
   47 |     |      *
   48 |     |      * - input must fit into 240 bits
   49 |     |      *
   50 |     |      * _Available since v4.7._
   51 |     |      */
   52 |     |     function toUint240(uint256 value) internal pure returns (uint240) {
   53 |     |         require(value <= type(uint240).max, "SafeCast: value doesn't fit in 240 bits");
   54 |     |         return uint240(value);
   55 |     |     }
   56 |     | 
   57 |     |     /**
   58 |     |      * @dev Returns the downcasted uint232 from uint256, reverting on
   59 |     |      * overflow (when the input is greater than largest uint232).
   60 |     |      *
   61 |     |      * Counterpart to Solidity's `uint232` operator.
   62 |     |      *
   63 |     |      * Requirements:
   64 |     |      *
   65 |     |      * - input must fit into 232 bits
   66 |     |      *
   67 |     |      * _Available since v4.7._
   68 |     |      */
   69 |     |     function toUint232(uint256 value) internal pure returns (uint232) {
   70 |     |         require(value <= type(uint232).max, "SafeCast: value doesn't fit in 232 bits");
   71 |     |         return uint232(value);
   72 |     |     }
   73 |     | 
   74 |     |     /**
   75 |     |      * @dev Returns the downcasted uint224 from uint256, reverting on
   76 |     |      * overflow (when the input is greater than largest uint224).
   77 |     |      *
   78 |     |      * Counterpart to Solidity's `uint224` operator.
   79 |     |      *
   80 |     |      * Requirements:
   81 |     |      *
   82 |     |      * - input must fit into 224 bits
   83 |     |      *
   84 |     |      * _Available since v4.2._
   85 |     |      */
   86 |     |     function toUint224(uint256 value) internal pure returns (uint224) {
   87 |     |         require(value <= type(uint224).max, "SafeCast: value doesn't fit in 224 bits");
   88 |     |         return uint224(value);
   89 |     |     }
   90 |     | 
   91 |     |     /**
   92 |     |      * @dev Returns the downcasted uint216 from uint256, reverting on
   93 |     |      * overflow (when the input is greater than largest uint216).
   94 |     |      *
   95 |     |      * Counterpart to Solidity's `uint216` operator.
   96 |     |      *
   97 |     |      * Requirements:
   98 |     |      *
   99 |     |      * - input must fit into 216 bits
  100 |     |      *
  101 |     |      * _Available since v4.7._
  102 |     |      */
  103 |     |     function toUint216(uint256 value) internal pure returns (uint216) {
  104 |     |         require(value <= type(uint216).max, "SafeCast: value doesn't fit in 216 bits");
  105 |     |         return uint216(value);
  106 |     |     }
  107 |     | 
  108 |     |     /**
  109 |     |      * @dev Returns the downcasted uint208 from uint256, reverting on
  110 |     |      * overflow (when the input is greater than largest uint208).
  111 |     |      *
  112 |     |      * Counterpart to Solidity's `uint208` operator.
  113 |     |      *
  114 |     |      * Requirements:
  115 |     |      *
  116 |     |      * - input must fit into 208 bits
  117 |     |      *
  118 |     |      * _Available since v4.7._
  119 |     |      */
  120 |     |     function toUint208(uint256 value) internal pure returns (uint208) {
  121 |     |         require(value <= type(uint208).max, "SafeCast: value doesn't fit in 208 bits");
  122 |     |         return uint208(value);
  123 |     |     }
  124 |     | 
  125 |     |     /**
  126 |     |      * @dev Returns the downcasted uint200 from uint256, reverting on
  127 |     |      * overflow (when the input is greater than largest uint200).
  128 |     |      *
  129 |     |      * Counterpart to Solidity's `uint200` operator.
  130 |     |      *
  131 |     |      * Requirements:
  132 |     |      *
  133 |     |      * - input must fit into 200 bits
  134 |     |      *
  135 |     |      * _Available since v4.7._
  136 |     |      */
  137 |     |     function toUint200(uint256 value) internal pure returns (uint200) {
  138 |     |         require(value <= type(uint200).max, "SafeCast: value doesn't fit in 200 bits");
  139 |     |         return uint200(value);
  140 |     |     }
  141 |     | 
  142 |     |     /**
  143 |     |      * @dev Returns the downcasted uint192 from uint256, reverting on
  144 |     |      * overflow (when the input is greater than largest uint192).
  145 |     |      *
  146 |     |      * Counterpart to Solidity's `uint192` operator.
  147 |     |      *
  148 |     |      * Requirements:
  149 |     |      *
  150 |     |      * - input must fit into 192 bits
  151 |     |      *
  152 |     |      * _Available since v4.7._
  153 |     |      */
  154 |     |     function toUint192(uint256 value) internal pure returns (uint192) {
  155 |     |         require(value <= type(uint192).max, "SafeCast: value doesn't fit in 192 bits");
  156 |     |         return uint192(value);
  157 |     |     }
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the downcasted uint184 from uint256, reverting on
  161 |     |      * overflow (when the input is greater than largest uint184).
  162 |     |      *
  163 |     |      * Counterpart to Solidity's `uint184` operator.
  164 |     |      *
  165 |     |      * Requirements:
  166 |     |      *
  167 |     |      * - input must fit into 184 bits
  168 |     |      *
  169 |     |      * _Available since v4.7._
  170 |     |      */
  171 |     |     function toUint184(uint256 value) internal pure returns (uint184) {
  172 |     |         require(value <= type(uint184).max, "SafeCast: value doesn't fit in 184 bits");
  173 |     |         return uint184(value);
  174 |     |     }
  175 |     | 
  176 |     |     /**
  177 |     |      * @dev Returns the downcasted uint176 from uint256, reverting on
  178 |     |      * overflow (when the input is greater than largest uint176).
  179 |     |      *
  180 |     |      * Counterpart to Solidity's `uint176` operator.
  181 |     |      *
  182 |     |      * Requirements:
  183 |     |      *
  184 |     |      * - input must fit into 176 bits
  185 |     |      *
  186 |     |      * _Available since v4.7._
  187 |     |      */
  188 |     |     function toUint176(uint256 value) internal pure returns (uint176) {
  189 |     |         require(value <= type(uint176).max, "SafeCast: value doesn't fit in 176 bits");
  190 |     |         return uint176(value);
  191 |     |     }
  192 |     | 
  193 |     |     /**
  194 |     |      * @dev Returns the downcasted uint168 from uint256, reverting on
  195 |     |      * overflow (when the input is greater than largest uint168).
  196 |     |      *
  197 |     |      * Counterpart to Solidity's `uint168` operator.
  198 |     |      *
  199 |     |      * Requirements:
  200 |     |      *
  201 |     |      * - input must fit into 168 bits
  202 |     |      *
  203 |     |      * _Available since v4.7._
  204 |     |      */
  205 |     |     function toUint168(uint256 value) internal pure returns (uint168) {
  206 |     |         require(value <= type(uint168).max, "SafeCast: value doesn't fit in 168 bits");
  207 |     |         return uint168(value);
  208 |     |     }
  209 |     | 
  210 |     |     /**
  211 |     |      * @dev Returns the downcasted uint160 from uint256, reverting on
  212 |     |      * overflow (when the input is greater than largest uint160).
  213 |     |      *
  214 |     |      * Counterpart to Solidity's `uint160` operator.
  215 |     |      *
  216 |     |      * Requirements:
  217 |     |      *
  218 |     |      * - input must fit into 160 bits
  219 |     |      *
  220 |     |      * _Available since v4.7._
  221 |     |      */
  222 |     |     function toUint160(uint256 value) internal pure returns (uint160) {
  223 |     |         require(value <= type(uint160).max, "SafeCast: value doesn't fit in 160 bits");
  224 |     |         return uint160(value);
  225 |     |     }
  226 |     | 
  227 |     |     /**
  228 |     |      * @dev Returns the downcasted uint152 from uint256, reverting on
  229 |     |      * overflow (when the input is greater than largest uint152).
  230 |     |      *
  231 |     |      * Counterpart to Solidity's `uint152` operator.
  232 |     |      *
  233 |     |      * Requirements:
  234 |     |      *
  235 |     |      * - input must fit into 152 bits
  236 |     |      *
  237 |     |      * _Available since v4.7._
  238 |     |      */
  239 |     |     function toUint152(uint256 value) internal pure returns (uint152) {
  240 |     |         require(value <= type(uint152).max, "SafeCast: value doesn't fit in 152 bits");
  241 |     |         return uint152(value);
  242 |     |     }
  243 |     | 
  244 |     |     /**
  245 |     |      * @dev Returns the downcasted uint144 from uint256, reverting on
  246 |     |      * overflow (when the input is greater than largest uint144).
  247 |     |      *
  248 |     |      * Counterpart to Solidity's `uint144` operator.
  249 |     |      *
  250 |     |      * Requirements:
  251 |     |      *
  252 |     |      * - input must fit into 144 bits
  253 |     |      *
  254 |     |      * _Available since v4.7._
  255 |     |      */
  256 |     |     function toUint144(uint256 value) internal pure returns (uint144) {
  257 |     |         require(value <= type(uint144).max, "SafeCast: value doesn't fit in 144 bits");
  258 |     |         return uint144(value);
  259 |     |     }
  260 |     | 
  261 |     |     /**
  262 |     |      * @dev Returns the downcasted uint136 from uint256, reverting on
  263 |     |      * overflow (when the input is greater than largest uint136).
  264 |     |      *
  265 |     |      * Counterpart to Solidity's `uint136` operator.
  266 |     |      *
  267 |     |      * Requirements:
  268 |     |      *
  269 |     |      * - input must fit into 136 bits
  270 |     |      *
  271 |     |      * _Available since v4.7._
  272 |     |      */
  273 |     |     function toUint136(uint256 value) internal pure returns (uint136) {
  274 |     |         require(value <= type(uint136).max, "SafeCast: value doesn't fit in 136 bits");
  275 |     |         return uint136(value);
  276 |     |     }
  277 |     | 
  278 |     |     /**
  279 |     |      * @dev Returns the downcasted uint128 from uint256, reverting on
  280 |     |      * overflow (when the input is greater than largest uint128).
  281 |     |      *
  282 |     |      * Counterpart to Solidity's `uint128` operator.
  283 |     |      *
  284 |     |      * Requirements:
  285 |     |      *
  286 |     |      * - input must fit into 128 bits
  287 |     |      *
  288 |     |      * _Available since v2.5._
  289 |     |      */
  290 |     |     function toUint128(uint256 value) internal pure returns (uint128) {
  291 |     |         require(value <= type(uint128).max, "SafeCast: value doesn't fit in 128 bits");
  292 |     |         return uint128(value);
  293 |     |     }
  294 |     | 
  295 |     |     /**
  296 |     |      * @dev Returns the downcasted uint120 from uint256, reverting on
  297 |     |      * overflow (when the input is greater than largest uint120).
  298 |     |      *
  299 |     |      * Counterpart to Solidity's `uint120` operator.
  300 |     |      *
  301 |     |      * Requirements:
  302 |     |      *
  303 |     |      * - input must fit into 120 bits
  304 |     |      *
  305 |     |      * _Available since v4.7._
  306 |     |      */
  307 |     |     function toUint120(uint256 value) internal pure returns (uint120) {
  308 |     |         require(value <= type(uint120).max, "SafeCast: value doesn't fit in 120 bits");
  309 |     |         return uint120(value);
  310 |     |     }
  311 |     | 
  312 |     |     /**
  313 |     |      * @dev Returns the downcasted uint112 from uint256, reverting on
  314 |     |      * overflow (when the input is greater than largest uint112).
  315 |     |      *
  316 |     |      * Counterpart to Solidity's `uint112` operator.
  317 |     |      *
  318 |     |      * Requirements:
  319 |     |      *
  320 |     |      * - input must fit into 112 bits
  321 |     |      *
  322 |     |      * _Available since v4.7._
  323 |     |      */
  324 |     |     function toUint112(uint256 value) internal pure returns (uint112) {
  325 |     |         require(value <= type(uint112).max, "SafeCast: value doesn't fit in 112 bits");
  326 |     |         return uint112(value);
  327 |     |     }
  328 |     | 
  329 |     |     /**
  330 |     |      * @dev Returns the downcasted uint104 from uint256, reverting on
  331 |     |      * overflow (when the input is greater than largest uint104).
  332 |     |      *
  333 |     |      * Counterpart to Solidity's `uint104` operator.
  334 |     |      *
  335 |     |      * Requirements:
  336 |     |      *
  337 |     |      * - input must fit into 104 bits
  338 |     |      *
  339 |     |      * _Available since v4.7._
  340 |     |      */
  341 |     |     function toUint104(uint256 value) internal pure returns (uint104) {
  342 |     |         require(value <= type(uint104).max, "SafeCast: value doesn't fit in 104 bits");
  343 |     |         return uint104(value);
  344 |     |     }
  345 |     | 
  346 |     |     /**
  347 |     |      * @dev Returns the downcasted uint96 from uint256, reverting on
  348 |     |      * overflow (when the input is greater than largest uint96).
  349 |     |      *
  350 |     |      * Counterpart to Solidity's `uint96` operator.
  351 |     |      *
  352 |     |      * Requirements:
  353 |     |      *
  354 |     |      * - input must fit into 96 bits
  355 |     |      *
  356 |     |      * _Available since v4.2._
  357 |     |      */
  358 |     |     function toUint96(uint256 value) internal pure returns (uint96) {
  359 |     |         require(value <= type(uint96).max, "SafeCast: value doesn't fit in 96 bits");
  360 |     |         return uint96(value);
  361 |     |     }
  362 |     | 
  363 |     |     /**
  364 |     |      * @dev Returns the downcasted uint88 from uint256, reverting on
  365 |     |      * overflow (when the input is greater than largest uint88).
  366 |     |      *
  367 |     |      * Counterpart to Solidity's `uint88` operator.
  368 |     |      *
  369 |     |      * Requirements:
  370 |     |      *
  371 |     |      * - input must fit into 88 bits
  372 |     |      *
  373 |     |      * _Available since v4.7._
  374 |     |      */
  375 |     |     function toUint88(uint256 value) internal pure returns (uint88) {
  376 |     |         require(value <= type(uint88).max, "SafeCast: value doesn't fit in 88 bits");
  377 |     |         return uint88(value);
  378 |     |     }
  379 |     | 
  380 |     |     /**
  381 |     |      * @dev Returns the downcasted uint80 from uint256, reverting on
  382 |     |      * overflow (when the input is greater than largest uint80).
  383 |     |      *
  384 |     |      * Counterpart to Solidity's `uint80` operator.
  385 |     |      *
  386 |     |      * Requirements:
  387 |     |      *
  388 |     |      * - input must fit into 80 bits
  389 |     |      *
  390 |     |      * _Available since v4.7._
  391 |     |      */
  392 |     |     function toUint80(uint256 value) internal pure returns (uint80) {
  393 |     |         require(value <= type(uint80).max, "SafeCast: value doesn't fit in 80 bits");
  394 |     |         return uint80(value);
  395 |     |     }
  396 |     | 
  397 |     |     /**
  398 |     |      * @dev Returns the downcasted uint72 from uint256, reverting on
  399 |     |      * overflow (when the input is greater than largest uint72).
  400 |     |      *
  401 |     |      * Counterpart to Solidity's `uint72` operator.
  402 |     |      *
  403 |     |      * Requirements:
  404 |     |      *
  405 |     |      * - input must fit into 72 bits
  406 |     |      *
  407 |     |      * _Available since v4.7._
  408 |     |      */
  409 |     |     function toUint72(uint256 value) internal pure returns (uint72) {
  410 |     |         require(value <= type(uint72).max, "SafeCast: value doesn't fit in 72 bits");
  411 |     |         return uint72(value);
  412 |     |     }
  413 |     | 
  414 |     |     /**
  415 |     |      * @dev Returns the downcasted uint64 from uint256, reverting on
  416 |     |      * overflow (when the input is greater than largest uint64).
  417 |     |      *
  418 |     |      * Counterpart to Solidity's `uint64` operator.
  419 |     |      *
  420 |     |      * Requirements:
  421 |     |      *
  422 |     |      * - input must fit into 64 bits
  423 |     |      *
  424 |     |      * _Available since v2.5._
  425 |     |      */
  426 |     |     function toUint64(uint256 value) internal pure returns (uint64) {
  427 |     |         require(value <= type(uint64).max, "SafeCast: value doesn't fit in 64 bits");
  428 |     |         return uint64(value);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the downcasted uint56 from uint256, reverting on
  433 |     |      * overflow (when the input is greater than largest uint56).
  434 |     |      *
  435 |     |      * Counterpart to Solidity's `uint56` operator.
  436 |     |      *
  437 |     |      * Requirements:
  438 |     |      *
  439 |     |      * - input must fit into 56 bits
  440 |     |      *
  441 |     |      * _Available since v4.7._
  442 |     |      */
  443 |     |     function toUint56(uint256 value) internal pure returns (uint56) {
  444 |     |         require(value <= type(uint56).max, "SafeCast: value doesn't fit in 56 bits");
  445 |     |         return uint56(value);
  446 |     |     }
  447 |     | 
  448 |     |     /**
  449 |     |      * @dev Returns the downcasted uint48 from uint256, reverting on
  450 |     |      * overflow (when the input is greater than largest uint48).
  451 |     |      *
  452 |     |      * Counterpart to Solidity's `uint48` operator.
  453 |     |      *
  454 |     |      * Requirements:
  455 |     |      *
  456 |     |      * - input must fit into 48 bits
  457 |     |      *
  458 |     |      * _Available since v4.7._
  459 |     |      */
  460 |     |     function toUint48(uint256 value) internal pure returns (uint48) {
  461 |     |         require(value <= type(uint48).max, "SafeCast: value doesn't fit in 48 bits");
  462 |     |         return uint48(value);
  463 |     |     }
  464 |     | 
  465 |     |     /**
  466 |     |      * @dev Returns the downcasted uint40 from uint256, reverting on
  467 |     |      * overflow (when the input is greater than largest uint40).
  468 |     |      *
  469 |     |      * Counterpart to Solidity's `uint40` operator.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - input must fit into 40 bits
  474 |     |      *
  475 |     |      * _Available since v4.7._
  476 |     |      */
  477 |     |     function toUint40(uint256 value) internal pure returns (uint40) {
  478 |     |         require(value <= type(uint40).max, "SafeCast: value doesn't fit in 40 bits");
  479 |     |         return uint40(value);
  480 |     |     }
  481 |     | 
  482 |     |     /**
  483 |     |      * @dev Returns the downcasted uint32 from uint256, reverting on
  484 |     |      * overflow (when the input is greater than largest uint32).
  485 |     |      *
  486 |     |      * Counterpart to Solidity's `uint32` operator.
  487 |     |      *
  488 |     |      * Requirements:
  489 |     |      *
  490 |     |      * - input must fit into 32 bits
  491 |     |      *
  492 |     |      * _Available since v2.5._
  493 |     |      */
  494 |     |     function toUint32(uint256 value) internal pure returns (uint32) {
  495 |     |         require(value <= type(uint32).max, "SafeCast: value doesn't fit in 32 bits");
  496 |     |         return uint32(value);
  497 |     |     }
  498 |     | 
  499 |     |     /**
  500 |     |      * @dev Returns the downcasted uint24 from uint256, reverting on
  501 |     |      * overflow (when the input is greater than largest uint24).
  502 |     |      *
  503 |     |      * Counterpart to Solidity's `uint24` operator.
  504 |     |      *
  505 |     |      * Requirements:
  506 |     |      *
  507 |     |      * - input must fit into 24 bits
  508 |     |      *
  509 |     |      * _Available since v4.7._
  510 |     |      */
  511 |     |     function toUint24(uint256 value) internal pure returns (uint24) {
  512 |     |         require(value <= type(uint24).max, "SafeCast: value doesn't fit in 24 bits");
  513 |     |         return uint24(value);
  514 |     |     }
  515 |     | 
  516 |     |     /**
  517 |     |      * @dev Returns the downcasted uint16 from uint256, reverting on
  518 |     |      * overflow (when the input is greater than largest uint16).
  519 |     |      *
  520 |     |      * Counterpart to Solidity's `uint16` operator.
  521 |     |      *
  522 |     |      * Requirements:
  523 |     |      *
  524 |     |      * - input must fit into 16 bits
  525 |     |      *
  526 |     |      * _Available since v2.5._
  527 |     |      */
  528 |     |     function toUint16(uint256 value) internal pure returns (uint16) {
  529 |     |         require(value <= type(uint16).max, "SafeCast: value doesn't fit in 16 bits");
  530 |     |         return uint16(value);
  531 |     |     }
  532 |     | 
  533 |     |     /**
  534 |     |      * @dev Returns the downcasted uint8 from uint256, reverting on
  535 |     |      * overflow (when the input is greater than largest uint8).
  536 |     |      *
  537 |     |      * Counterpart to Solidity's `uint8` operator.
  538 |     |      *
  539 |     |      * Requirements:
  540 |     |      *
  541 |     |      * - input must fit into 8 bits
  542 |     |      *
  543 |     |      * _Available since v2.5._
  544 |     |      */
  545 |     |     function toUint8(uint256 value) internal pure returns (uint8) {
  546 |     |         require(value <= type(uint8).max, "SafeCast: value doesn't fit in 8 bits");
  547 |     |         return uint8(value);
  548 |     |     }
  549 |     | 
  550 |     |     /**
  551 |     |      * @dev Converts a signed int256 into an unsigned uint256.
  552 |     |      *
  553 |     |      * Requirements:
  554 |     |      *
  555 |     |      * - input must be greater than or equal to 0.
  556 |     |      *
  557 |     |      * _Available since v3.0._
  558 |     |      */
  559 |     |     function toUint256(int256 value) internal pure returns (uint256) {
  560 |     |         require(value >= 0, "SafeCast: value must be positive");
  561 |     |         return uint256(value);
  562 |     |     }
  563 |     | 
  564 |     |     /**
  565 |     |      * @dev Returns the downcasted int248 from int256, reverting on
  566 |     |      * overflow (when the input is less than smallest int248 or
  567 |     |      * greater than largest int248).
  568 |     |      *
  569 |     |      * Counterpart to Solidity's `int248` operator.
  570 |     |      *
  571 |     |      * Requirements:
  572 |     |      *
  573 |     |      * - input must fit into 248 bits
  574 |     |      *
  575 |     |      * _Available since v4.7._
  576 |     |      */
  577 |     |     function toInt248(int256 value) internal pure returns (int248 downcasted) {
  578 |     |         downcasted = int248(value);
  579 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 248 bits");
  580 |     |     }
  581 |     | 
  582 |     |     /**
  583 |     |      * @dev Returns the downcasted int240 from int256, reverting on
  584 |     |      * overflow (when the input is less than smallest int240 or
  585 |     |      * greater than largest int240).
  586 |     |      *
  587 |     |      * Counterpart to Solidity's `int240` operator.
  588 |     |      *
  589 |     |      * Requirements:
  590 |     |      *
  591 |     |      * - input must fit into 240 bits
  592 |     |      *
  593 |     |      * _Available since v4.7._
  594 |     |      */
  595 |     |     function toInt240(int256 value) internal pure returns (int240 downcasted) {
  596 |     |         downcasted = int240(value);
  597 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 240 bits");
  598 |     |     }
  599 |     | 
  600 |     |     /**
  601 |     |      * @dev Returns the downcasted int232 from int256, reverting on
  602 |     |      * overflow (when the input is less than smallest int232 or
  603 |     |      * greater than largest int232).
  604 |     |      *
  605 |     |      * Counterpart to Solidity's `int232` operator.
  606 |     |      *
  607 |     |      * Requirements:
  608 |     |      *
  609 |     |      * - input must fit into 232 bits
  610 |     |      *
  611 |     |      * _Available since v4.7._
  612 |     |      */
  613 |     |     function toInt232(int256 value) internal pure returns (int232 downcasted) {
  614 |     |         downcasted = int232(value);
  615 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 232 bits");
  616 |     |     }
  617 |     | 
  618 |     |     /**
  619 |     |      * @dev Returns the downcasted int224 from int256, reverting on
  620 |     |      * overflow (when the input is less than smallest int224 or
  621 |     |      * greater than largest int224).
  622 |     |      *
  623 |     |      * Counterpart to Solidity's `int224` operator.
  624 |     |      *
  625 |     |      * Requirements:
  626 |     |      *
  627 |     |      * - input must fit into 224 bits
  628 |     |      *
  629 |     |      * _Available since v4.7._
  630 |     |      */
  631 |     |     function toInt224(int256 value) internal pure returns (int224 downcasted) {
  632 |     |         downcasted = int224(value);
  633 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 224 bits");
  634 |     |     }
  635 |     | 
  636 |     |     /**
  637 |     |      * @dev Returns the downcasted int216 from int256, reverting on
  638 |     |      * overflow (when the input is less than smallest int216 or
  639 |     |      * greater than largest int216).
  640 |     |      *
  641 |     |      * Counterpart to Solidity's `int216` operator.
  642 |     |      *
  643 |     |      * Requirements:
  644 |     |      *
  645 |     |      * - input must fit into 216 bits
  646 |     |      *
  647 |     |      * _Available since v4.7._
  648 |     |      */
  649 |     |     function toInt216(int256 value) internal pure returns (int216 downcasted) {
  650 |     |         downcasted = int216(value);
  651 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 216 bits");
  652 |     |     }
  653 |     | 
  654 |     |     /**
  655 |     |      * @dev Returns the downcasted int208 from int256, reverting on
  656 |     |      * overflow (when the input is less than smallest int208 or
  657 |     |      * greater than largest int208).
  658 |     |      *
  659 |     |      * Counterpart to Solidity's `int208` operator.
  660 |     |      *
  661 |     |      * Requirements:
  662 |     |      *
  663 |     |      * - input must fit into 208 bits
  664 |     |      *
  665 |     |      * _Available since v4.7._
  666 |     |      */
  667 |     |     function toInt208(int256 value) internal pure returns (int208 downcasted) {
  668 |     |         downcasted = int208(value);
  669 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 208 bits");
  670 |     |     }
  671 |     | 
  672 |     |     /**
  673 |     |      * @dev Returns the downcasted int200 from int256, reverting on
  674 |     |      * overflow (when the input is less than smallest int200 or
  675 |     |      * greater than largest int200).
  676 |     |      *
  677 |     |      * Counterpart to Solidity's `int200` operator.
  678 |     |      *
  679 |     |      * Requirements:
  680 |     |      *
  681 |     |      * - input must fit into 200 bits
  682 |     |      *
  683 |     |      * _Available since v4.7._
  684 |     |      */
  685 |     |     function toInt200(int256 value) internal pure returns (int200 downcasted) {
  686 |     |         downcasted = int200(value);
  687 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 200 bits");
  688 |     |     }
  689 |     | 
  690 |     |     /**
  691 |     |      * @dev Returns the downcasted int192 from int256, reverting on
  692 |     |      * overflow (when the input is less than smallest int192 or
  693 |     |      * greater than largest int192).
  694 |     |      *
  695 |     |      * Counterpart to Solidity's `int192` operator.
  696 |     |      *
  697 |     |      * Requirements:
  698 |     |      *
  699 |     |      * - input must fit into 192 bits
  700 |     |      *
  701 |     |      * _Available since v4.7._
  702 |     |      */
  703 |     |     function toInt192(int256 value) internal pure returns (int192 downcasted) {
  704 |     |         downcasted = int192(value);
  705 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 192 bits");
  706 |     |     }
  707 |     | 
  708 |     |     /**
  709 |     |      * @dev Returns the downcasted int184 from int256, reverting on
  710 |     |      * overflow (when the input is less than smallest int184 or
  711 |     |      * greater than largest int184).
  712 |     |      *
  713 |     |      * Counterpart to Solidity's `int184` operator.
  714 |     |      *
  715 |     |      * Requirements:
  716 |     |      *
  717 |     |      * - input must fit into 184 bits
  718 |     |      *
  719 |     |      * _Available since v4.7._
  720 |     |      */
  721 |     |     function toInt184(int256 value) internal pure returns (int184 downcasted) {
  722 |     |         downcasted = int184(value);
  723 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 184 bits");
  724 |     |     }
  725 |     | 
  726 |     |     /**
  727 |     |      * @dev Returns the downcasted int176 from int256, reverting on
  728 |     |      * overflow (when the input is less than smallest int176 or
  729 |     |      * greater than largest int176).
  730 |     |      *
  731 |     |      * Counterpart to Solidity's `int176` operator.
  732 |     |      *
  733 |     |      * Requirements:
  734 |     |      *
  735 |     |      * - input must fit into 176 bits
  736 |     |      *
  737 |     |      * _Available since v4.7._
  738 |     |      */
  739 |     |     function toInt176(int256 value) internal pure returns (int176 downcasted) {
  740 |     |         downcasted = int176(value);
  741 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 176 bits");
  742 |     |     }
  743 |     | 
  744 |     |     /**
  745 |     |      * @dev Returns the downcasted int168 from int256, reverting on
  746 |     |      * overflow (when the input is less than smallest int168 or
  747 |     |      * greater than largest int168).
  748 |     |      *
  749 |     |      * Counterpart to Solidity's `int168` operator.
  750 |     |      *
  751 |     |      * Requirements:
  752 |     |      *
  753 |     |      * - input must fit into 168 bits
  754 |     |      *
  755 |     |      * _Available since v4.7._
  756 |     |      */
  757 |     |     function toInt168(int256 value) internal pure returns (int168 downcasted) {
  758 |     |         downcasted = int168(value);
  759 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 168 bits");
  760 |     |     }
  761 |     | 
  762 |     |     /**
  763 |     |      * @dev Returns the downcasted int160 from int256, reverting on
  764 |     |      * overflow (when the input is less than smallest int160 or
  765 |     |      * greater than largest int160).
  766 |     |      *
  767 |     |      * Counterpart to Solidity's `int160` operator.
  768 |     |      *
  769 |     |      * Requirements:
  770 |     |      *
  771 |     |      * - input must fit into 160 bits
  772 |     |      *
  773 |     |      * _Available since v4.7._
  774 |     |      */
  775 |     |     function toInt160(int256 value) internal pure returns (int160 downcasted) {
  776 |     |         downcasted = int160(value);
  777 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 160 bits");
  778 |     |     }
  779 |     | 
  780 |     |     /**
  781 |     |      * @dev Returns the downcasted int152 from int256, reverting on
  782 |     |      * overflow (when the input is less than smallest int152 or
  783 |     |      * greater than largest int152).
  784 |     |      *
  785 |     |      * Counterpart to Solidity's `int152` operator.
  786 |     |      *
  787 |     |      * Requirements:
  788 |     |      *
  789 |     |      * - input must fit into 152 bits
  790 |     |      *
  791 |     |      * _Available since v4.7._
  792 |     |      */
  793 |     |     function toInt152(int256 value) internal pure returns (int152 downcasted) {
  794 |     |         downcasted = int152(value);
  795 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 152 bits");
  796 |     |     }
  797 |     | 
  798 |     |     /**
  799 |     |      * @dev Returns the downcasted int144 from int256, reverting on
  800 |     |      * overflow (when the input is less than smallest int144 or
  801 |     |      * greater than largest int144).
  802 |     |      *
  803 |     |      * Counterpart to Solidity's `int144` operator.
  804 |     |      *
  805 |     |      * Requirements:
  806 |     |      *
  807 |     |      * - input must fit into 144 bits
  808 |     |      *
  809 |     |      * _Available since v4.7._
  810 |     |      */
  811 |     |     function toInt144(int256 value) internal pure returns (int144 downcasted) {
  812 |     |         downcasted = int144(value);
  813 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 144 bits");
  814 |     |     }
  815 |     | 
  816 |     |     /**
  817 |     |      * @dev Returns the downcasted int136 from int256, reverting on
  818 |     |      * overflow (when the input is less than smallest int136 or
  819 |     |      * greater than largest int136).
  820 |     |      *
  821 |     |      * Counterpart to Solidity's `int136` operator.
  822 |     |      *
  823 |     |      * Requirements:
  824 |     |      *
  825 |     |      * - input must fit into 136 bits
  826 |     |      *
  827 |     |      * _Available since v4.7._
  828 |     |      */
  829 |     |     function toInt136(int256 value) internal pure returns (int136 downcasted) {
  830 |     |         downcasted = int136(value);
  831 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 136 bits");
  832 |     |     }
  833 |     | 
  834 |     |     /**
  835 |     |      * @dev Returns the downcasted int128 from int256, reverting on
  836 |     |      * overflow (when the input is less than smallest int128 or
  837 |     |      * greater than largest int128).
  838 |     |      *
  839 |     |      * Counterpart to Solidity's `int128` operator.
  840 |     |      *
  841 |     |      * Requirements:
  842 |     |      *
  843 |     |      * - input must fit into 128 bits
  844 |     |      *
  845 |     |      * _Available since v3.1._
  846 |     |      */
  847 |     |     function toInt128(int256 value) internal pure returns (int128 downcasted) {
  848 |     |         downcasted = int128(value);
  849 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 128 bits");
  850 |     |     }
  851 |     | 
  852 |     |     /**
  853 |     |      * @dev Returns the downcasted int120 from int256, reverting on
  854 |     |      * overflow (when the input is less than smallest int120 or
  855 |     |      * greater than largest int120).
  856 |     |      *
  857 |     |      * Counterpart to Solidity's `int120` operator.
  858 |     |      *
  859 |     |      * Requirements:
  860 |     |      *
  861 |     |      * - input must fit into 120 bits
  862 |     |      *
  863 |     |      * _Available since v4.7._
  864 |     |      */
  865 |     |     function toInt120(int256 value) internal pure returns (int120 downcasted) {
  866 |     |         downcasted = int120(value);
  867 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 120 bits");
  868 |     |     }
  869 |     | 
  870 |     |     /**
  871 |     |      * @dev Returns the downcasted int112 from int256, reverting on
  872 |     |      * overflow (when the input is less than smallest int112 or
  873 |     |      * greater than largest int112).
  874 |     |      *
  875 |     |      * Counterpart to Solidity's `int112` operator.
  876 |     |      *
  877 |     |      * Requirements:
  878 |     |      *
  879 |     |      * - input must fit into 112 bits
  880 |     |      *
  881 |     |      * _Available since v4.7._
  882 |     |      */
  883 |     |     function toInt112(int256 value) internal pure returns (int112 downcasted) {
  884 |     |         downcasted = int112(value);
  885 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 112 bits");
  886 |     |     }
  887 |     | 
  888 |     |     /**
  889 |     |      * @dev Returns the downcasted int104 from int256, reverting on
  890 |     |      * overflow (when the input is less than smallest int104 or
  891 |     |      * greater than largest int104).
  892 |     |      *
  893 |     |      * Counterpart to Solidity's `int104` operator.
  894 |     |      *
  895 |     |      * Requirements:
  896 |     |      *
  897 |     |      * - input must fit into 104 bits
  898 |     |      *
  899 |     |      * _Available since v4.7._
  900 |     |      */
  901 |     |     function toInt104(int256 value) internal pure returns (int104 downcasted) {
  902 |     |         downcasted = int104(value);
  903 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 104 bits");
  904 |     |     }
  905 |     | 
  906 |     |     /**
  907 |     |      * @dev Returns the downcasted int96 from int256, reverting on
  908 |     |      * overflow (when the input is less than smallest int96 or
  909 |     |      * greater than largest int96).
  910 |     |      *
  911 |     |      * Counterpart to Solidity's `int96` operator.
  912 |     |      *
  913 |     |      * Requirements:
  914 |     |      *
  915 |     |      * - input must fit into 96 bits
  916 |     |      *
  917 |     |      * _Available since v4.7._
  918 |     |      */
  919 |     |     function toInt96(int256 value) internal pure returns (int96 downcasted) {
  920 |     |         downcasted = int96(value);
  921 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 96 bits");
  922 |     |     }
  923 |     | 
  924 |     |     /**
  925 |     |      * @dev Returns the downcasted int88 from int256, reverting on
  926 |     |      * overflow (when the input is less than smallest int88 or
  927 |     |      * greater than largest int88).
  928 |     |      *
  929 |     |      * Counterpart to Solidity's `int88` operator.
  930 |     |      *
  931 |     |      * Requirements:
  932 |     |      *
  933 |     |      * - input must fit into 88 bits
  934 |     |      *
  935 |     |      * _Available since v4.7._
  936 |     |      */
  937 |     |     function toInt88(int256 value) internal pure returns (int88 downcasted) {
  938 |     |         downcasted = int88(value);
  939 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 88 bits");
  940 |     |     }
  941 |     | 
  942 |     |     /**
  943 |     |      * @dev Returns the downcasted int80 from int256, reverting on
  944 |     |      * overflow (when the input is less than smallest int80 or
  945 |     |      * greater than largest int80).
  946 |     |      *
  947 |     |      * Counterpart to Solidity's `int80` operator.
  948 |     |      *
  949 |     |      * Requirements:
  950 |     |      *
  951 |     |      * - input must fit into 80 bits
  952 |     |      *
  953 |     |      * _Available since v4.7._
  954 |     |      */
  955 |     |     function toInt80(int256 value) internal pure returns (int80 downcasted) {
  956 |     |         downcasted = int80(value);
  957 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 80 bits");
  958 |     |     }
  959 |     | 
  960 |     |     /**
  961 |     |      * @dev Returns the downcasted int72 from int256, reverting on
  962 |     |      * overflow (when the input is less than smallest int72 or
  963 |     |      * greater than largest int72).
  964 |     |      *
  965 |     |      * Counterpart to Solidity's `int72` operator.
  966 |     |      *
  967 |     |      * Requirements:
  968 |     |      *
  969 |     |      * - input must fit into 72 bits
  970 |     |      *
  971 |     |      * _Available since v4.7._
  972 |     |      */
  973 |     |     function toInt72(int256 value) internal pure returns (int72 downcasted) {
  974 |     |         downcasted = int72(value);
  975 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 72 bits");
  976 |     |     }
  977 |     | 
  978 |     |     /**
  979 |     |      * @dev Returns the downcasted int64 from int256, reverting on
  980 |     |      * overflow (when the input is less than smallest int64 or
  981 |     |      * greater than largest int64).
  982 |     |      *
  983 |     |      * Counterpart to Solidity's `int64` operator.
  984 |     |      *
  985 |     |      * Requirements:
  986 |     |      *
  987 |     |      * - input must fit into 64 bits
  988 |     |      *
  989 |     |      * _Available since v3.1._
  990 |     |      */
  991 |     |     function toInt64(int256 value) internal pure returns (int64 downcasted) {
  992 |     |         downcasted = int64(value);
  993 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 64 bits");
  994 |     |     }
  995 |     | 
  996 |     |     /**
  997 |     |      * @dev Returns the downcasted int56 from int256, reverting on
  998 |     |      * overflow (when the input is less than smallest int56 or
  999 |     |      * greater than largest int56).
 1000 |     |      *
 1001 |     |      * Counterpart to Solidity's `int56` operator.
 1002 |     |      *
 1003 |     |      * Requirements:
 1004 |     |      *
 1005 |     |      * - input must fit into 56 bits
 1006 |     |      *
 1007 |     |      * _Available since v4.7._
 1008 |     |      */
 1009 |     |     function toInt56(int256 value) internal pure returns (int56 downcasted) {
 1010 |     |         downcasted = int56(value);
 1011 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 56 bits");
 1012 |     |     }
 1013 |     | 
 1014 |     |     /**
 1015 |     |      * @dev Returns the downcasted int48 from int256, reverting on
 1016 |     |      * overflow (when the input is less than smallest int48 or
 1017 |     |      * greater than largest int48).
 1018 |     |      *
 1019 |     |      * Counterpart to Solidity's `int48` operator.
 1020 |     |      *
 1021 |     |      * Requirements:
 1022 |     |      *
 1023 |     |      * - input must fit into 48 bits
 1024 |     |      *
 1025 |     |      * _Available since v4.7._
 1026 |     |      */
 1027 |     |     function toInt48(int256 value) internal pure returns (int48 downcasted) {
 1028 |     |         downcasted = int48(value);
 1029 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 48 bits");
 1030 |     |     }
 1031 |     | 
 1032 |     |     /**
 1033 |     |      * @dev Returns the downcasted int40 from int256, reverting on
 1034 |     |      * overflow (when the input is less than smallest int40 or
 1035 |     |      * greater than largest int40).
 1036 |     |      *
 1037 |     |      * Counterpart to Solidity's `int40` operator.
 1038 |     |      *
 1039 |     |      * Requirements:
 1040 |     |      *
 1041 |     |      * - input must fit into 40 bits
 1042 |     |      *
 1043 |     |      * _Available since v4.7._
 1044 |     |      */
 1045 |     |     function toInt40(int256 value) internal pure returns (int40 downcasted) {
 1046 |     |         downcasted = int40(value);
 1047 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 40 bits");
 1048 |     |     }
 1049 |     | 
 1050 |     |     /**
 1051 |     |      * @dev Returns the downcasted int32 from int256, reverting on
 1052 |     |      * overflow (when the input is less than smallest int32 or
 1053 |     |      * greater than largest int32).
 1054 |     |      *
 1055 |     |      * Counterpart to Solidity's `int32` operator.
 1056 |     |      *
 1057 |     |      * Requirements:
 1058 |     |      *
 1059 |     |      * - input must fit into 32 bits
 1060 |     |      *
 1061 |     |      * _Available since v3.1._
 1062 |     |      */
 1063 |     |     function toInt32(int256 value) internal pure returns (int32 downcasted) {
 1064 |     |         downcasted = int32(value);
 1065 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 32 bits");
 1066 |     |     }
 1067 |     | 
 1068 |     |     /**
 1069 |     |      * @dev Returns the downcasted int24 from int256, reverting on
 1070 |     |      * overflow (when the input is less than smallest int24 or
 1071 |     |      * greater than largest int24).
 1072 |     |      *
 1073 |     |      * Counterpart to Solidity's `int24` operator.
 1074 |     |      *
 1075 |     |      * Requirements:
 1076 |     |      *
 1077 |     |      * - input must fit into 24 bits
 1078 |     |      *
 1079 |     |      * _Available since v4.7._
 1080 |     |      */
 1081 |     |     function toInt24(int256 value) internal pure returns (int24 downcasted) {
 1082 |     |         downcasted = int24(value);
 1083 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 24 bits");
 1084 |     |     }
 1085 |     | 
 1086 |     |     /**
 1087 |     |      * @dev Returns the downcasted int16 from int256, reverting on
 1088 |     |      * overflow (when the input is less than smallest int16 or
 1089 |     |      * greater than largest int16).
 1090 |     |      *
 1091 |     |      * Counterpart to Solidity's `int16` operator.
 1092 |     |      *
 1093 |     |      * Requirements:
 1094 |     |      *
 1095 |     |      * - input must fit into 16 bits
 1096 |     |      *
 1097 |     |      * _Available since v3.1._
 1098 |     |      */
 1099 |     |     function toInt16(int256 value) internal pure returns (int16 downcasted) {
 1100 |     |         downcasted = int16(value);
 1101 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 16 bits");
 1102 |     |     }
 1103 |     | 
 1104 |     |     /**
 1105 |     |      * @dev Returns the downcasted int8 from int256, reverting on
 1106 |     |      * overflow (when the input is less than smallest int8 or
 1107 |     |      * greater than largest int8).
 1108 |     |      *
 1109 |     |      * Counterpart to Solidity's `int8` operator.
 1110 |     |      *
 1111 |     |      * Requirements:
 1112 |     |      *
 1113 |     |      * - input must fit into 8 bits
 1114 |     |      *
 1115 |     |      * _Available since v3.1._
 1116 |     |      */
 1117 |     |     function toInt8(int256 value) internal pure returns (int8 downcasted) {
 1118 |     |         downcasted = int8(value);
 1119 |     |         require(downcasted == value, "SafeCast: value doesn't fit in 8 bits");
 1120 |     |     }
 1121 |     | 
 1122 |     |     /**
 1123 |     |      * @dev Converts an unsigned uint256 into a signed int256.
 1124 |     |      *
 1125 |     |      * Requirements:
 1126 |     |      *
 1127 |     |      * - input must be less than or equal to maxInt256.
 1128 |     |      *
 1129 |     |      * _Available since v3.0._
 1130 |     |      */
 1131 |     |     function toInt256(uint256 value) internal pure returns (int256) {
 1132 |     |         // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive
 1133 |     |         require(value <= uint256(type(int256).max), "SafeCast: value doesn't fit in an int256");
 1134 |     |         return int256(value);
 1135 |     |     }
 1136 |     | }
 1137 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | // OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)
  3 |     | 
  4 |     | pragma solidity ^0.8.0;
  5 |     | 
  6 |     | /**
  7 |     |  * @dev Standard signed math utilities missing in the Solidity language.
  8 |     |  */
  9 |     | library SignedMath {
 10 |     |     /**
 11 |     |      * @dev Returns the largest of two signed numbers.
 12 |     |      */
 13 |     |     function max(int256 a, int256 b) internal pure returns (int256) {
 14 |     |         return a > b ? a : b;
 15 |     |     }
 16 |     | 
 17 |     |     /**
 18 |     |      * @dev Returns the smallest of two signed numbers.
 19 |     |      */
 20 |     |     function min(int256 a, int256 b) internal pure returns (int256) {
 21 |     |         return a < b ? a : b;
 22 |     |     }
 23 |     | 
 24 |     |     /**
 25 |     |      * @dev Returns the average of two signed numbers without overflow.
 26 |     |      * The result is rounded towards zero.
 27 |     |      */
 28 |     |     function average(int256 a, int256 b) internal pure returns (int256) {
 29 |     |         // Formula from the book "Hacker's Delight"
 30 |     |         int256 x = (a & b) + ((a ^ b) >> 1);
 31 |     |         return x + (int256(uint256(x) >> 255) & (a ^ b));
 32 |     |     }
 33 |     | 
 34 |     |     /**
 35 |     |      * @dev Returns the absolute unsigned value of a signed value.
 36 |     |      */
 37 |     |     function abs(int256 n) internal pure returns (uint256) {
 38 |     |         unchecked {
 39 |     |             // must be unchecked in order to support `n = type(int256).min`
 40 |     |             return uint256(n >= 0 ? n : -n);
 41 |     |         }
 42 |     |     }
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@rari-capital/solmate/src/utils/SSTORE2.sol
   1 |     | // SPDX-License-Identifier: AGPL-3.0-only
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @notice Read and write to persistent storage at a fraction of the cost.
   5 |     | /// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)
   6 |     | /// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)
   7 |     | library SSTORE2 {
   8 |     |     uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it's a STOP opcode to ensure the contract can't be called.
   9 |     | 
  10 |     |     /*///////////////////////////////////////////////////////////////
  11 |     |                                WRITE LOGIC
  12 |     |     //////////////////////////////////////////////////////////////*/
  13 |     | 
  14 |     |     function write(bytes memory data) internal returns (address pointer) {
  15 |     |         // Prefix the bytecode with a STOP opcode to ensure it cannot be called.
  16 |     |         bytes memory runtimeCode = abi.encodePacked(hex"00", data);
  17 |     | 
  18 |     |         bytes memory creationCode = abi.encodePacked(
  19 |     |             //---------------------------------------------------------------------------------------------------------------//
  20 |     |             // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //
  21 |     |             //---------------------------------------------------------------------------------------------------------------//
  22 |     |             // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //
  23 |     |             // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //
  24 |     |             // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //
  25 |     |             // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //
  26 |     |             // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //
  27 |     |             // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //
  28 |     |             // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //
  29 |     |             // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //
  30 |     |             // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //
  31 |     |             // 0xf3    |  0xf3               | RETURN       |                                                                //
  32 |     |             //---------------------------------------------------------------------------------------------------------------//
  33 |     |             hex"60_0B_59_81_38_03_80_92_59_39_F3", // Returns all code in the contract except for the first 11 (0B in hex) bytes.
  34 |     |             runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.
  35 |     |         );
  36 |     | 
  37 |     |         assembly {
  38 |     |             // Deploy a new contract with the generated creation code.
  39 |     |             // We start 32 bytes into the code to avoid copying the byte length.
  40 |     |             pointer := create(0, add(creationCode, 32), mload(creationCode))
  41 |     |         }
  42 |     | 
  43 |     |         require(pointer != address(0), "DEPLOYMENT_FAILED");
  44 |     |     }
  45 |     | 
  46 |     |     /*///////////////////////////////////////////////////////////////
  47 |     |                                READ LOGIC
  48 |     |     //////////////////////////////////////////////////////////////*/
  49 |     | 
  50 |     |     function read(address pointer) internal view returns (bytes memory) {
  51 |     |         return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);
  52 |     |     }
  53 |     | 
  54 |     |     function read(address pointer, uint256 start) internal view returns (bytes memory) {
  55 |     |         start += DATA_OFFSET;
  56 |     | 
  57 |     |         return readBytecode(pointer, start, pointer.code.length - start);
  58 |     |     }
  59 |     | 
  60 |     |     function read(
  61 |     |         address pointer,
  62 |     |         uint256 start,
  63 |     |         uint256 end
  64 |     |     ) internal view returns (bytes memory) {
  65 |     |         start += DATA_OFFSET;
  66 |     |         end += DATA_OFFSET;
  67 |     | 
  68 |     |         require(pointer.code.length >= end, "OUT_OF_BOUNDS");
  69 |     | 
  70 |     |         return readBytecode(pointer, start, end - start);
  71 |     |     }
  72 |     | 
  73 |     |     /*///////////////////////////////////////////////////////////////
  74 |     |                          INTERNAL HELPER LOGIC
  75 |     |     //////////////////////////////////////////////////////////////*/
  76 |     | 
  77 |     |     function readBytecode(
  78 |     |         address pointer,
  79 |     |         uint256 start,
  80 |     |         uint256 size
  81 |     |     ) private view returns (bytes memory data) {
  82 |     |         assembly {
  83 |     |             // Get a pointer to some free memory.
  84 |     |             data := mload(0x40)
  85 |     | 
  86 |     |             // Update the free memory pointer to prevent overriding our data.
  87 |     |             // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).
  88 |     |             // Adding 31 to size and running the result through the logic above ensures
  89 |     |             // the memory pointer remains word-aligned, following the Solidity convention.
  90 |     |             mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))
  91 |     | 
  92 |     |             // Store the size of the data in the first 32 byte chunk of free memory.
  93 |     |             mstore(data, size)
  94 |     | 
  95 |     |             // Copy the code into memory right after the 32 bytes we used to store the size.
  96 |     |             extcodecopy(pointer, add(data, 32), start, size)
  97 |     |         }
  98 |     |     }
  99 |     | }
 100 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol
  1 |     | pragma solidity >=0.5.0;
  2 |     | 
  3 |     | interface IUniswapV2Pair {
  4 |     |     event Approval(address indexed owner, address indexed spender, uint value);
  5 |     |     event Transfer(address indexed from, address indexed to, uint value);
  6 |     | 
  7 |     |     function name() external pure returns (string memory);
  8 |     |     function symbol() external pure returns (string memory);
  9 |     |     function decimals() external pure returns (uint8);
 10 |     |     function totalSupply() external view returns (uint);
 11 |     |     function balanceOf(address owner) external view returns (uint);
 12 |     |     function allowance(address owner, address spender) external view returns (uint);
 13 |     | 
 14 |     |     function approve(address spender, uint value) external returns (bool);
 15 |     |     function transfer(address to, uint value) external returns (bool);
 16 |     |     function transferFrom(address from, address to, uint value) external returns (bool);
 17 |     | 
 18 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 19 |     |     function PERMIT_TYPEHASH() external pure returns (bytes32);
 20 |     |     function nonces(address owner) external view returns (uint);
 21 |     | 
 22 |     |     function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;
 23 |     | 
 24 |     |     event Mint(address indexed sender, uint amount0, uint amount1);
 25 |     |     event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);
 26 |     |     event Swap(
 27 |     |         address indexed sender,
 28 |     |         uint amount0In,
 29 |     |         uint amount1In,
 30 |     |         uint amount0Out,
 31 |     |         uint amount1Out,
 32 |     |         address indexed to
 33 |     |     );
 34 |     |     event Sync(uint112 reserve0, uint112 reserve1);
 35 |     | 
 36 |     |     function MINIMUM_LIQUIDITY() external pure returns (uint);
 37 |     |     function factory() external view returns (address);
 38 |     |     function token0() external view returns (address);
 39 |     |     function token1() external view returns (address);
 40 |     |     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
 41 |     |     function price0CumulativeLast() external view returns (uint);
 42 |     |     function price1CumulativeLast() external view returns (uint);
 43 |     |     function kLast() external view returns (uint);
 44 |     | 
 45 |     |     function mint(address to) external returns (uint liquidity);
 46 |     |     function burn(address to) external returns (uint amount0, uint amount1);
 47 |     |     function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
 48 |     |     function skim(address to) external;
 49 |     |     function sync() external;
 50 |     | 
 51 |     |     function initialize(address, address) external;
 52 |     | }
 53 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }
 22 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.4.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 |     |     uint8 internal constant RESOLUTION = 96;
  9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }
 11 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.5.0;
  3 |     | 
  4 |     | /// @title Immutable state
  5 |     | /// @notice Functions that return immutable state of the router
  6 |     | interface IPeripheryImmutableState {
  7 |     |     /// @return Returns the address of the Uniswap V3 factory
  8 |     |     function factory() external view returns (address);
  9 |     | 
 10 |     |     /// @return Returns the address of WETH9
 11 |     |     function WETH9() external view returns (address);
 12 |     | }
 13 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.7.5;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';
  6 |     | 
  7 |     | /// @title Router token swapping functionality
  8 |     | /// @notice Functions for swapping tokens via Uniswap V3
  9 |     | interface ISwapRouter is IUniswapV3SwapCallback {
 10 |     |     struct ExactInputSingleParams {
 11 |     |         address tokenIn;
 12 |     |         address tokenOut;
 13 |     |         uint24 fee;
 14 |     |         address recipient;
 15 |     |         uint256 deadline;
 16 |     |         uint256 amountIn;
 17 |     |         uint256 amountOutMinimum;
 18 |     |         uint160 sqrtPriceLimitX96;
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 22 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 23 |     |     /// @return amountOut The amount of the received token
 24 |     |     function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);
 25 |     | 
 26 |     |     struct ExactInputParams {
 27 |     |         bytes path;
 28 |     |         address recipient;
 29 |     |         uint256 deadline;
 30 |     |         uint256 amountIn;
 31 |     |         uint256 amountOutMinimum;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 35 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 36 |     |     /// @return amountOut The amount of the received token
 37 |     |     function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);
 38 |     | 
 39 |     |     struct ExactOutputSingleParams {
 40 |     |         address tokenIn;
 41 |     |         address tokenOut;
 42 |     |         uint24 fee;
 43 |     |         address recipient;
 44 |     |         uint256 deadline;
 45 |     |         uint256 amountOut;
 46 |     |         uint256 amountInMaximum;
 47 |     |         uint160 sqrtPriceLimitX96;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 51 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 52 |     |     /// @return amountIn The amount of the input token
 53 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);
 54 |     | 
 55 |     |     struct ExactOutputParams {
 56 |     |         bytes path;
 57 |     |         address recipient;
 58 |     |         uint256 deadline;
 59 |     |         uint256 amountOut;
 60 |     |         uint256 amountInMaximum;
 61 |     |     }
 62 |     | 
 63 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 64 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 65 |     |     /// @return amountIn The amount of the input token
 66 |     |     function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);
 67 |     | }
 68 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/erc721a/contracts/ERC721A.sol
    1 |     | // SPDX-License-Identifier: MIT
    2 |     | // ERC721A Contracts v4.3.0
    3 |     | // Creator: Chiru Labs
    4 |     | 
    5 |     | pragma solidity ^0.8.4;
    6 |     | 
    7 |     | import './IERC721A.sol';
    8 |     | 
    9 |     | /**
   10 |     |  * @dev Interface of ERC721 token receiver.
   11 |     |  */
   12 |     | interface ERC721A__IERC721Receiver {
   13 |     |     function onERC721Received(
   14 |     |         address operator,
   15 |     |         address from,
   16 |     |         uint256 tokenId,
   17 |     |         bytes calldata data
   18 |     |     ) external returns (bytes4);
   19 |     | }
   20 |     | 
   21 |     | /**
   22 |     |  * @title ERC721A
   23 |     |  *
   24 |     |  * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)
   25 |     |  * Non-Fungible Token Standard, including the Metadata extension.
   26 |     |  * Optimized for lower gas during batch mints.
   27 |     |  *
   28 |     |  * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)
   29 |     |  * starting from `_startTokenId()`.
   30 |     |  *
   31 |     |  * The `_sequentialUpTo()` function can be overriden to enable spot mints
   32 |     |  * (i.e. non-consecutive mints) for `tokenId`s greater than `_sequentialUpTo()`.
   33 |     |  *
   34 |     |  * Assumptions:
   35 |     |  *
   36 |     |  * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.
   37 |     |  * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).
   38 |     |  */
   39 |     | contract ERC721A is IERC721A {
   40 |     |     // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).
   41 |     |     struct TokenApprovalRef {
   42 |     |         address value;
   43 |     |     }
   44 |     | 
   45 |     |     // =============================================================
   46 |     |     //                           CONSTANTS
   47 |     |     // =============================================================
   48 |     | 
   49 |     |     // Mask of an entry in packed address data.
   50 |     |     uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 << 64) - 1;
   51 |     | 
   52 |     |     // The bit position of `numberMinted` in packed address data.
   53 |     |     uint256 private constant _BITPOS_NUMBER_MINTED = 64;
   54 |     | 
   55 |     |     // The bit position of `numberBurned` in packed address data.
   56 |     |     uint256 private constant _BITPOS_NUMBER_BURNED = 128;
   57 |     | 
   58 |     |     // The bit position of `aux` in packed address data.
   59 |     |     uint256 private constant _BITPOS_AUX = 192;
   60 |     | 
   61 |     |     // Mask of all 256 bits in packed address data except the 64 bits for `aux`.
   62 |     |     uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 << 192) - 1;
   63 |     | 
   64 |     |     // The bit position of `startTimestamp` in packed ownership.
   65 |     |     uint256 private constant _BITPOS_START_TIMESTAMP = 160;
   66 |     | 
   67 |     |     // The bit mask of the `burned` bit in packed ownership.
   68 |     |     uint256 private constant _BITMASK_BURNED = 1 << 224;
   69 |     | 
   70 |     |     // The bit position of the `nextInitialized` bit in packed ownership.
   71 |     |     uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;
   72 |     | 
   73 |     |     // The bit mask of the `nextInitialized` bit in packed ownership.
   74 |     |     uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 << 225;
   75 |     | 
   76 |     |     // The bit position of `extraData` in packed ownership.
   77 |     |     uint256 private constant _BITPOS_EXTRA_DATA = 232;
   78 |     | 
   79 |     |     // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.
   80 |     |     uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 << 232) - 1;
   81 |     | 
   82 |     |     // The mask of the lower 160 bits for addresses.
   83 |     |     uint256 private constant _BITMASK_ADDRESS = (1 << 160) - 1;
   84 |     | 
   85 |     |     // The maximum `quantity` that can be minted with {_mintERC2309}.
   86 |     |     // This limit is to prevent overflows on the address data entries.
   87 |     |     // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}
   88 |     |     // is required to cause an overflow, which is unrealistic.
   89 |     |     uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;
   90 |     | 
   91 |     |     // The `Transfer` event signature is given by:
   92 |     |     // `keccak256(bytes("Transfer(address,address,uint256)"))`.
   93 |     |     bytes32 private constant _TRANSFER_EVENT_SIGNATURE =
   94 |     |         0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;
   95 |     | 
   96 |     |     // =============================================================
   97 |     |     //                            STORAGE
   98 |     |     // =============================================================
   99 |     | 
  100 |     |     // The next token ID to be minted.
  101 |     |     uint256 private _currentIndex;
  102 |     | 
  103 |     |     // The number of tokens burned.
  104 |     |     uint256 private _burnCounter;
  105 |     | 
  106 |     |     // Token name
  107 |     |     string private _name;
  108 |     | 
  109 |     |     // Token symbol
  110 |     |     string private _symbol;
  111 |     | 
  112 |     |     // Mapping from token ID to ownership details
  113 |     |     // An empty struct value does not necessarily mean the token is unowned.
  114 |     |     // See {_packedOwnershipOf} implementation for details.
  115 |     |     //
  116 |     |     // Bits Layout:
  117 |     |     // - [0..159]   `addr`
  118 |     |     // - [160..223] `startTimestamp`
  119 |     |     // - [224]      `burned`
  120 |     |     // - [225]      `nextInitialized`
  121 |     |     // - [232..255] `extraData`
  122 |     |     mapping(uint256 => uint256) private _packedOwnerships;
  123 |     | 
  124 |     |     // Mapping owner address to address data.
  125 |     |     //
  126 |     |     // Bits Layout:
  127 |     |     // - [0..63]    `balance`
  128 |     |     // - [64..127]  `numberMinted`
  129 |     |     // - [128..191] `numberBurned`
  130 |     |     // - [192..255] `aux`
  131 |     |     mapping(address => uint256) private _packedAddressData;
  132 |     | 
  133 |     |     // Mapping from token ID to approved address.
  134 |     |     mapping(uint256 => TokenApprovalRef) private _tokenApprovals;
  135 |     | 
  136 |     |     // Mapping from owner to operator approvals
  137 |     |     mapping(address => mapping(address => bool)) private _operatorApprovals;
  138 |     | 
  139 |     |     // The amount of tokens minted above `_sequentialUpTo()`.
  140 |     |     // We call these spot mints (i.e. non-sequential mints).
  141 |     |     uint256 private _spotMinted;
  142 |     | 
  143 |     |     // =============================================================
  144 |     |     //                          CONSTRUCTOR
  145 |     |     // =============================================================
  146 |     | 
  147 |     |     constructor(string memory name_, string memory symbol_) {
  148 |     |         _name = name_;
  149 |     |         _symbol = symbol_;
  150 |     |         _currentIndex = _startTokenId();
  151 |     | 
  152 |     |         if (_sequentialUpTo() < _startTokenId()) _revert(SequentialUpToTooSmall.selector);
  153 |     |     }
  154 |     | 
  155 |     |     // =============================================================
  156 |     |     //                   TOKEN COUNTING OPERATIONS
  157 |     |     // =============================================================
  158 |     | 
  159 |     |     /**
  160 |     |      * @dev Returns the starting token ID for sequential mints.
  161 |     |      *
  162 |     |      * Override this function to change the starting token ID for sequential mints.
  163 |     |      *
  164 |     |      * Note: The value returned must never change after any tokens have been minted.
  165 |     |      */
  166 |     |     function _startTokenId() internal view virtual returns (uint256) {
  167 |     |         return 0;
  168 |     |     }
  169 |     | 
  170 |     |     /**
  171 |     |      * @dev Returns the maximum token ID (inclusive) for sequential mints.
  172 |     |      *
  173 |     |      * Override this function to return a value less than 2**256 - 1,
  174 |     |      * but greater than `_startTokenId()`, to enable spot (non-sequential) mints.
  175 |     |      *
  176 |     |      * Note: The value returned must never change after any tokens have been minted.
  177 |     |      */
  178 |     |     function _sequentialUpTo() internal view virtual returns (uint256) {
  179 |     |         return type(uint256).max;
  180 |     |     }
  181 |     | 
  182 |     |     /**
  183 |     |      * @dev Returns the next token ID to be minted.
  184 |     |      */
  185 |     |     function _nextTokenId() internal view virtual returns (uint256) {
  186 |     |         return _currentIndex;
  187 |     |     }
  188 |     | 
  189 |     |     /**
  190 |     |      * @dev Returns the total number of tokens in existence.
  191 |     |      * Burned tokens will reduce the count.
  192 |     |      * To get the total number of tokens minted, please see {_totalMinted}.
  193 |     |      */
  194 |     |     function totalSupply() public view virtual override returns (uint256 result) {
  195 |     |         // Counter underflow is impossible as `_burnCounter` cannot be incremented
  196 |     |         // more than `_currentIndex + _spotMinted - _startTokenId()` times.
  197 |     |         unchecked {
  198 |     |             // With spot minting, the intermediate `result` can be temporarily negative,
  199 |     |             // and the computation must be unchecked.
  200 |     |             result = _currentIndex - _burnCounter - _startTokenId();
  201 |     |             if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;
  202 |     |         }
  203 |     |     }
  204 |     | 
  205 |     |     /**
  206 |     |      * @dev Returns the total amount of tokens minted in the contract.
  207 |     |      */
  208 |     |     function _totalMinted() internal view virtual returns (uint256 result) {
  209 |     |         // Counter underflow is impossible as `_currentIndex` does not decrement,
  210 |     |         // and it is initialized to `_startTokenId()`.
  211 |     |         unchecked {
  212 |     |             result = _currentIndex - _startTokenId();
  213 |     |             if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;
  214 |     |         }
  215 |     |     }
  216 |     | 
  217 |     |     /**
  218 |     |      * @dev Returns the total number of tokens burned.
  219 |     |      */
  220 |     |     function _totalBurned() internal view virtual returns (uint256) {
  221 |     |         return _burnCounter;
  222 |     |     }
  223 |     | 
  224 |     |     /**
  225 |     |      * @dev Returns the total number of tokens that are spot-minted.
  226 |     |      */
  227 |     |     function _totalSpotMinted() internal view virtual returns (uint256) {
  228 |     |         return _spotMinted;
  229 |     |     }
  230 |     | 
  231 |     |     // =============================================================
  232 |     |     //                    ADDRESS DATA OPERATIONS
  233 |     |     // =============================================================
  234 |     | 
  235 |     |     /**
  236 |     |      * @dev Returns the number of tokens in `owner`'s account.
  237 |     |      */
  238 |     |     function balanceOf(address owner) public view virtual override returns (uint256) {
  239 |     |         if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);
  240 |     |         return _packedAddressData[owner] & _BITMASK_ADDRESS_DATA_ENTRY;
  241 |     |     }
  242 |     | 
  243 |     |     /**
  244 |     |      * Returns the number of tokens minted by `owner`.
  245 |     |      */
  246 |     |     function _numberMinted(address owner) internal view returns (uint256) {
  247 |     |         return (_packedAddressData[owner] >> _BITPOS_NUMBER_MINTED) & _BITMASK_ADDRESS_DATA_ENTRY;
  248 |     |     }
  249 |     | 
  250 |     |     /**
  251 |     |      * Returns the number of tokens burned by or on behalf of `owner`.
  252 |     |      */
  253 |     |     function _numberBurned(address owner) internal view returns (uint256) {
  254 |     |         return (_packedAddressData[owner] >> _BITPOS_NUMBER_BURNED) & _BITMASK_ADDRESS_DATA_ENTRY;
  255 |     |     }
  256 |     | 
  257 |     |     /**
  258 |     |      * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).
  259 |     |      */
  260 |     |     function _getAux(address owner) internal view returns (uint64) {
  261 |     |         return uint64(_packedAddressData[owner] >> _BITPOS_AUX);
  262 |     |     }
  263 |     | 
  264 |     |     /**
  265 |     |      * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).
  266 |     |      * If there are multiple variables, please pack them into a uint64.
  267 |     |      */
  268 |     |     function _setAux(address owner, uint64 aux) internal virtual {
  269 |     |         uint256 packed = _packedAddressData[owner];
  270 |     |         uint256 auxCasted;
  271 |     |         // Cast `aux` with assembly to avoid redundant masking.
  272 |     |         assembly {
  273 |     |             auxCasted := aux
  274 |     |         }
  275 |     |         packed = (packed & _BITMASK_AUX_COMPLEMENT) | (auxCasted << _BITPOS_AUX);
  276 |     |         _packedAddressData[owner] = packed;
  277 |     |     }
  278 |     | 
  279 |     |     // =============================================================
  280 |     |     //                            IERC165
  281 |     |     // =============================================================
  282 |     | 
  283 |     |     /**
  284 |     |      * @dev Returns true if this contract implements the interface defined by
  285 |     |      * `interfaceId`. See the corresponding
  286 |     |      * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)
  287 |     |      * to learn more about how these ids are created.
  288 |     |      *
  289 |     |      * This function call must use less than 30000 gas.
  290 |     |      */
  291 |     |     function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
  292 |     |         // The interface IDs are constants representing the first 4 bytes
  293 |     |         // of the XOR of all function selectors in the interface.
  294 |     |         // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)
  295 |     |         // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)
  296 |     |         return
  297 |     |             interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.
  298 |     |             interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.
  299 |     |             interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.
  300 |     |     }
  301 |     | 
  302 |     |     // =============================================================
  303 |     |     //                        IERC721Metadata
  304 |     |     // =============================================================
  305 |     | 
  306 |     |     /**
  307 |     |      * @dev Returns the token collection name.
  308 |     |      */
  309 |     |     function name() public view virtual override returns (string memory) {
  310 |     |         return _name;
  311 |     |     }
  312 |     | 
  313 |     |     /**
  314 |     |      * @dev Returns the token collection symbol.
  315 |     |      */
  316 |     |     function symbol() public view virtual override returns (string memory) {
  317 |     |         return _symbol;
  318 |     |     }
  319 |     | 
  320 |     |     /**
  321 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
  322 |     |      */
  323 |     |     function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {
  324 |     |         if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);
  325 |     | 
  326 |     |         string memory baseURI = _baseURI();
  327 |     |         return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : '';
  328 |     |     }
  329 |     | 
  330 |     |     /**
  331 |     |      * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each
  332 |     |      * token will be the concatenation of the `baseURI` and the `tokenId`. Empty
  333 |     |      * by default, it can be overridden in child contracts.
  334 |     |      */
  335 |     |     function _baseURI() internal view virtual returns (string memory) {
  336 |     |         return '';
  337 |     |     }
  338 |     | 
  339 |     |     // =============================================================
  340 |     |     //                     OWNERSHIPS OPERATIONS
  341 |     |     // =============================================================
  342 |     | 
  343 |     |     /**
  344 |     |      * @dev Returns the owner of the `tokenId` token.
  345 |     |      *
  346 |     |      * Requirements:
  347 |     |      *
  348 |     |      * - `tokenId` must exist.
  349 |     |      */
  350 |     |     function ownerOf(uint256 tokenId) public view virtual override returns (address) {
  351 |     |         return address(uint160(_packedOwnershipOf(tokenId)));
  352 |     |     }
  353 |     | 
  354 |     |     /**
  355 |     |      * @dev Gas spent here starts off proportional to the maximum mint batch size.
  356 |     |      * It gradually moves to O(1) as tokens get transferred around over time.
  357 |     |      */
  358 |     |     function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {
  359 |     |         return _unpackedOwnership(_packedOwnershipOf(tokenId));
  360 |     |     }
  361 |     | 
  362 |     |     /**
  363 |     |      * @dev Returns the unpacked `TokenOwnership` struct at `index`.
  364 |     |      */
  365 |     |     function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {
  366 |     |         return _unpackedOwnership(_packedOwnerships[index]);
  367 |     |     }
  368 |     | 
  369 |     |     /**
  370 |     |      * @dev Returns whether the ownership slot at `index` is initialized.
  371 |     |      * An uninitialized slot does not necessarily mean that the slot has no owner.
  372 |     |      */
  373 |     |     function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {
  374 |     |         return _packedOwnerships[index] != 0;
  375 |     |     }
  376 |     | 
  377 |     |     /**
  378 |     |      * @dev Initializes the ownership slot minted at `index` for efficiency purposes.
  379 |     |      */
  380 |     |     function _initializeOwnershipAt(uint256 index) internal virtual {
  381 |     |         if (_packedOwnerships[index] == 0) {
  382 |     |             _packedOwnerships[index] = _packedOwnershipOf(index);
  383 |     |         }
  384 |     |     }
  385 |     | 
  386 |     |     /**
  387 |     |      * @dev Returns the packed ownership data of `tokenId`.
  388 |     |      */
  389 |     |     function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {
  390 |     |         if (_startTokenId() <= tokenId) {
  391 |     |             packed = _packedOwnerships[tokenId];
  392 |     | 
  393 |     |             if (tokenId > _sequentialUpTo()) {
  394 |     |                 if (_packedOwnershipExists(packed)) return packed;
  395 |     |                 _revert(OwnerQueryForNonexistentToken.selector);
  396 |     |             }
  397 |     | 
  398 |     |             // If the data at the starting slot does not exist, start the scan.
  399 |     |             if (packed == 0) {
  400 |     |                 if (tokenId >= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);
  401 |     |                 // Invariant:
  402 |     |                 // There will always be an initialized ownership slot
  403 |     |                 // (i.e. `ownership.addr != address(0) && ownership.burned == false`)
  404 |     |                 // before an unintialized ownership slot
  405 |     |                 // (i.e. `ownership.addr == address(0) && ownership.burned == false`)
  406 |     |                 // Hence, `tokenId` will not underflow.
  407 |     |                 //
  408 |     |                 // We can directly compare the packed value.
  409 |     |                 // If the address is zero, packed will be zero.
  410 |     |                 for (;;) {
  411 |     |                     unchecked {
  412 |     |                         packed = _packedOwnerships[--tokenId];
  413 |     |                     }
  414 |     |                     if (packed == 0) continue;
  415 |     |                     if (packed & _BITMASK_BURNED == 0) return packed;
  416 |     |                     // Otherwise, the token is burned, and we must revert.
  417 |     |                     // This handles the case of batch burned tokens, where only the burned bit
  418 |     |                     // of the starting slot is set, and remaining slots are left uninitialized.
  419 |     |                     _revert(OwnerQueryForNonexistentToken.selector);
  420 |     |                 }
  421 |     |             }
  422 |     |             // Otherwise, the data exists and we can skip the scan.
  423 |     |             // This is possible because we have already achieved the target condition.
  424 |     |             // This saves 2143 gas on transfers of initialized tokens.
  425 |     |             // If the token is not burned, return `packed`. Otherwise, revert.
  426 |     |             if (packed & _BITMASK_BURNED == 0) return packed;
  427 |     |         }
  428 |     |         _revert(OwnerQueryForNonexistentToken.selector);
  429 |     |     }
  430 |     | 
  431 |     |     /**
  432 |     |      * @dev Returns the unpacked `TokenOwnership` struct from `packed`.
  433 |     |      */
  434 |     |     function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {
  435 |     |         ownership.addr = address(uint160(packed));
  436 |     |         ownership.startTimestamp = uint64(packed >> _BITPOS_START_TIMESTAMP);
  437 |     |         ownership.burned = packed & _BITMASK_BURNED != 0;
  438 |     |         ownership.extraData = uint24(packed >> _BITPOS_EXTRA_DATA);
  439 |     |     }
  440 |     | 
  441 |     |     /**
  442 |     |      * @dev Packs ownership data into a single uint256.
  443 |     |      */
  444 |     |     function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {
  445 |     |         assembly {
  446 |     |             // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.
  447 |     |             owner := and(owner, _BITMASK_ADDRESS)
  448 |     |             // `owner | (block.timestamp << _BITPOS_START_TIMESTAMP) | flags`.
  449 |     |             result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))
  450 |     |         }
  451 |     |     }
  452 |     | 
  453 |     |     /**
  454 |     |      * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.
  455 |     |      */
  456 |     |     function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {
  457 |     |         // For branchless setting of the `nextInitialized` flag.
  458 |     |         assembly {
  459 |     |             // `(quantity == 1) << _BITPOS_NEXT_INITIALIZED`.
  460 |     |             result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))
  461 |     |         }
  462 |     |     }
  463 |     | 
  464 |     |     // =============================================================
  465 |     |     //                      APPROVAL OPERATIONS
  466 |     |     // =============================================================
  467 |     | 
  468 |     |     /**
  469 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.
  470 |     |      *
  471 |     |      * Requirements:
  472 |     |      *
  473 |     |      * - The caller must own the token or be an approved operator.
  474 |     |      */
  475 |     |     function approve(address to, uint256 tokenId) public payable virtual override {
  476 |     |         _approve(to, tokenId, true);
  477 |     |     }
  478 |     | 
  479 |     |     /**
  480 |     |      * @dev Returns the account approved for `tokenId` token.
  481 |     |      *
  482 |     |      * Requirements:
  483 |     |      *
  484 |     |      * - `tokenId` must exist.
  485 |     |      */
  486 |     |     function getApproved(uint256 tokenId) public view virtual override returns (address) {
  487 |     |         if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);
  488 |     | 
  489 |     |         return _tokenApprovals[tokenId].value;
  490 |     |     }
  491 |     | 
  492 |     |     /**
  493 |     |      * @dev Approve or remove `operator` as an operator for the caller.
  494 |     |      * Operators can call {transferFrom} or {safeTransferFrom}
  495 |     |      * for any token owned by the caller.
  496 |     |      *
  497 |     |      * Requirements:
  498 |     |      *
  499 |     |      * - The `operator` cannot be the caller.
  500 |     |      *
  501 |     |      * Emits an {ApprovalForAll} event.
  502 |     |      */
  503 |     |     function setApprovalForAll(address operator, bool approved) public virtual override {
  504 |     |         _operatorApprovals[_msgSenderERC721A()][operator] = approved;
  505 |     |         emit ApprovalForAll(_msgSenderERC721A(), operator, approved);
  506 |     |     }
  507 |     | 
  508 |     |     /**
  509 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
  510 |     |      *
  511 |     |      * See {setApprovalForAll}.
  512 |     |      */
  513 |     |     function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {
  514 |     |         return _operatorApprovals[owner][operator];
  515 |     |     }
  516 |     | 
  517 |     |     /**
  518 |     |      * @dev Returns whether `tokenId` exists.
  519 |     |      *
  520 |     |      * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.
  521 |     |      *
  522 |     |      * Tokens start existing when they are minted. See {_mint}.
  523 |     |      */
  524 |     |     function _exists(uint256 tokenId) internal view virtual returns (bool result) {
  525 |     |         if (_startTokenId() <= tokenId) {
  526 |     |             if (tokenId > _sequentialUpTo()) return _packedOwnershipExists(_packedOwnerships[tokenId]);
  527 |     | 
  528 |     |             if (tokenId < _currentIndex) {
  529 |     |                 uint256 packed;
  530 |     |                 while ((packed = _packedOwnerships[tokenId]) == 0) --tokenId;
  531 |     |                 result = packed & _BITMASK_BURNED == 0;
  532 |     |             }
  533 |     |         }
  534 |     |     }
  535 |     | 
  536 |     |     /**
  537 |     |      * @dev Returns whether `packed` represents a token that exists.
  538 |     |      */
  539 |     |     function _packedOwnershipExists(uint256 packed) private pure returns (bool result) {
  540 |     |         assembly {
  541 |     |             // The following is equivalent to `owner != address(0) && burned == false`.
  542 |     |             // Symbolically tested.
  543 |     |             result := gt(and(packed, _BITMASK_ADDRESS), and(packed, _BITMASK_BURNED))
  544 |     |         }
  545 |     |     }
  546 |     | 
  547 |     |     /**
  548 |     |      * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.
  549 |     |      */
  550 |     |     function _isSenderApprovedOrOwner(
  551 |     |         address approvedAddress,
  552 |     |         address owner,
  553 |     |         address msgSender
  554 |     |     ) private pure returns (bool result) {
  555 |     |         assembly {
  556 |     |             // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren't clean.
  557 |     |             owner := and(owner, _BITMASK_ADDRESS)
  558 |     |             // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren't clean.
  559 |     |             msgSender := and(msgSender, _BITMASK_ADDRESS)
  560 |     |             // `msgSender == owner || msgSender == approvedAddress`.
  561 |     |             result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))
  562 |     |         }
  563 |     |     }
  564 |     | 
  565 |     |     /**
  566 |     |      * @dev Returns the storage slot and value for the approved address of `tokenId`.
  567 |     |      */
  568 |     |     function _getApprovedSlotAndAddress(uint256 tokenId)
  569 |     |         private
  570 |     |         view
  571 |     |         returns (uint256 approvedAddressSlot, address approvedAddress)
  572 |     |     {
  573 |     |         TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];
  574 |     |         // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.
  575 |     |         assembly {
  576 |     |             approvedAddressSlot := tokenApproval.slot
  577 |     |             approvedAddress := sload(approvedAddressSlot)
  578 |     |         }
  579 |     |     }
  580 |     | 
  581 |     |     // =============================================================
  582 |     |     //                      TRANSFER OPERATIONS
  583 |     |     // =============================================================
  584 |     | 
  585 |     |     /**
  586 |     |      * @dev Transfers `tokenId` from `from` to `to`.
  587 |     |      *
  588 |     |      * Requirements:
  589 |     |      *
  590 |     |      * - `from` cannot be the zero address.
  591 |     |      * - `to` cannot be the zero address.
  592 |     |      * - `tokenId` token must be owned by `from`.
  593 |     |      * - If the caller is not `from`, it must be approved to move this token
  594 |     |      * by either {approve} or {setApprovalForAll}.
  595 |     |      *
  596 |     |      * Emits a {Transfer} event.
  597 |     |      */
  598 |     |     function transferFrom(
  599 |     |         address from,
  600 |     |         address to,
  601 |     |         uint256 tokenId
  602 |     |     ) public payable virtual override {
  603 |     |         uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);
  604 |     | 
  605 |     |         // Mask `from` to the lower 160 bits, in case the upper bits somehow aren't clean.
  606 |     |         from = address(uint160(uint256(uint160(from)) & _BITMASK_ADDRESS));
  607 |     | 
  608 |     |         if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);
  609 |     | 
  610 |     |         (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);
  611 |     | 
  612 |     |         // The nested ifs save around 20+ gas over a compound boolean condition.
  613 |     |         if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
  614 |     |             if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);
  615 |     | 
  616 |     |         _beforeTokenTransfers(from, to, tokenId, 1);
  617 |     | 
  618 |     |         // Clear approvals from the previous owner.
  619 |     |         assembly {
  620 |     |             if approvedAddress {
  621 |     |                 // This is equivalent to `delete _tokenApprovals[tokenId]`.
  622 |     |                 sstore(approvedAddressSlot, 0)
  623 |     |             }
  624 |     |         }
  625 |     | 
  626 |     |         // Underflow of the sender's balance is impossible because we check for
  627 |     |         // ownership above and the recipient's balance can't realistically overflow.
  628 |     |         // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.
  629 |     |         unchecked {
  630 |     |             // We can directly increment and decrement the balances.
  631 |     |             --_packedAddressData[from]; // Updates: `balance -= 1`.
  632 |     |             ++_packedAddressData[to]; // Updates: `balance += 1`.
  633 |     | 
  634 |     |             // Updates:
  635 |     |             // - `address` to the next owner.
  636 |     |             // - `startTimestamp` to the timestamp of transfering.
  637 |     |             // - `burned` to `false`.
  638 |     |             // - `nextInitialized` to `true`.
  639 |     |             _packedOwnerships[tokenId] = _packOwnershipData(
  640 |     |                 to,
  641 |     |                 _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)
  642 |     |             );
  643 |     | 
  644 |     |             // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .
  645 |     |             if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {
  646 |     |                 uint256 nextTokenId = tokenId + 1;
  647 |     |                 // If the next slot's address is zero and not burned (i.e. packed value is zero).
  648 |     |                 if (_packedOwnerships[nextTokenId] == 0) {
  649 |     |                     // If the next slot is within bounds.
  650 |     |                     if (nextTokenId != _currentIndex) {
  651 |     |                         // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.
  652 |     |                         _packedOwnerships[nextTokenId] = prevOwnershipPacked;
  653 |     |                     }
  654 |     |                 }
  655 |     |             }
  656 |     |         }
  657 |     | 
  658 |     |         // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.
  659 |     |         uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;
  660 |     |         assembly {
  661 |     |             // Emit the `Transfer` event.
  662 |     |             log4(
  663 |     |                 0, // Start of data (0, since no data).
  664 |     |                 0, // End of data (0, since no data).
  665 |     |                 _TRANSFER_EVENT_SIGNATURE, // Signature.
  666 |     |                 from, // `from`.
  667 |     |                 toMasked, // `to`.
  668 |     |                 tokenId // `tokenId`.
  669 |     |             )
  670 |     |         }
  671 |     |         if (toMasked == 0) _revert(TransferToZeroAddress.selector);
  672 |     | 
  673 |     |         _afterTokenTransfers(from, to, tokenId, 1);
  674 |     |     }
  675 |     | 
  676 |     |     /**
  677 |     |      * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.
  678 |     |      */
  679 |     |     function safeTransferFrom(
  680 |     |         address from,
  681 |     |         address to,
  682 |     |         uint256 tokenId
  683 |     |     ) public payable virtual override {
  684 |     |         safeTransferFrom(from, to, tokenId, '');
  685 |     |     }
  686 |     | 
  687 |     |     /**
  688 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`.
  689 |     |      *
  690 |     |      * Requirements:
  691 |     |      *
  692 |     |      * - `from` cannot be the zero address.
  693 |     |      * - `to` cannot be the zero address.
  694 |     |      * - `tokenId` token must exist and be owned by `from`.
  695 |     |      * - If the caller is not `from`, it must be approved to move this token
  696 |     |      * by either {approve} or {setApprovalForAll}.
  697 |     |      * - If `to` refers to a smart contract, it must implement
  698 |     |      * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
  699 |     |      *
  700 |     |      * Emits a {Transfer} event.
  701 |     |      */
  702 |     |     function safeTransferFrom(
  703 |     |         address from,
  704 |     |         address to,
  705 |     |         uint256 tokenId,
  706 |     |         bytes memory _data
  707 |     |     ) public payable virtual override {
  708 |     |         transferFrom(from, to, tokenId);
  709 |     |         if (to.code.length != 0)
  710 |     |             if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {
  711 |     |                 _revert(TransferToNonERC721ReceiverImplementer.selector);
  712 |     |             }
  713 |     |     }
  714 |     | 
  715 |     |     /**
  716 |     |      * @dev Hook that is called before a set of serially-ordered token IDs
  717 |     |      * are about to be transferred. This includes minting.
  718 |     |      * And also called before burning one token.
  719 |     |      *
  720 |     |      * `startTokenId` - the first token ID to be transferred.
  721 |     |      * `quantity` - the amount to be transferred.
  722 |     |      *
  723 |     |      * Calling conditions:
  724 |     |      *
  725 |     |      * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
  726 |     |      * transferred to `to`.
  727 |     |      * - When `from` is zero, `tokenId` will be minted for `to`.
  728 |     |      * - When `to` is zero, `tokenId` will be burned by `from`.
  729 |     |      * - `from` and `to` are never both zero.
  730 |     |      */
  731 |     |     function _beforeTokenTransfers(
  732 |     |         address from,
  733 |     |         address to,
  734 |     |         uint256 startTokenId,
  735 |     |         uint256 quantity
  736 |     |     ) internal virtual {}
  737 |     | 
  738 |     |     /**
  739 |     |      * @dev Hook that is called after a set of serially-ordered token IDs
  740 |     |      * have been transferred. This includes minting.
  741 |     |      * And also called after one token has been burned.
  742 |     |      *
  743 |     |      * `startTokenId` - the first token ID to be transferred.
  744 |     |      * `quantity` - the amount to be transferred.
  745 |     |      *
  746 |     |      * Calling conditions:
  747 |     |      *
  748 |     |      * - When `from` and `to` are both non-zero, `from`'s `tokenId` has been
  749 |     |      * transferred to `to`.
  750 |     |      * - When `from` is zero, `tokenId` has been minted for `to`.
  751 |     |      * - When `to` is zero, `tokenId` has been burned by `from`.
  752 |     |      * - `from` and `to` are never both zero.
  753 |     |      */
  754 |     |     function _afterTokenTransfers(
  755 |     |         address from,
  756 |     |         address to,
  757 |     |         uint256 startTokenId,
  758 |     |         uint256 quantity
  759 |     |     ) internal virtual {}
  760 |     | 
  761 |     |     /**
  762 |     |      * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.
  763 |     |      *
  764 |     |      * `from` - Previous owner of the given token ID.
  765 |     |      * `to` - Target address that will receive the token.
  766 |     |      * `tokenId` - Token ID to be transferred.
  767 |     |      * `_data` - Optional data to send along with the call.
  768 |     |      *
  769 |     |      * Returns whether the call correctly returned the expected magic value.
  770 |     |      */
  771 |     |     function _checkContractOnERC721Received(
  772 |     |         address from,
  773 |     |         address to,
  774 |     |         uint256 tokenId,
  775 |     |         bytes memory _data
  776 |     |     ) private returns (bool) {
  777 |     |         try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (
  778 |     |             bytes4 retval
  779 |     |         ) {
  780 |     |             return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;
  781 |     |         } catch (bytes memory reason) {
  782 |     |             if (reason.length == 0) {
  783 |     |                 _revert(TransferToNonERC721ReceiverImplementer.selector);
  784 |     |             }
  785 |     |             assembly {
  786 |     |                 revert(add(32, reason), mload(reason))
  787 |     |             }
  788 |     |         }
  789 |     |     }
  790 |     | 
  791 |     |     // =============================================================
  792 |     |     //                        MINT OPERATIONS
  793 |     |     // =============================================================
  794 |     | 
  795 |     |     /**
  796 |     |      * @dev Mints `quantity` tokens and transfers them to `to`.
  797 |     |      *
  798 |     |      * Requirements:
  799 |     |      *
  800 |     |      * - `to` cannot be the zero address.
  801 |     |      * - `quantity` must be greater than 0.
  802 |     |      *
  803 |     |      * Emits a {Transfer} event for each mint.
  804 |     |      */
  805 |     |     function _mint(address to, uint256 quantity) internal virtual {
  806 |     |         uint256 startTokenId = _currentIndex;
  807 |     |         if (quantity == 0) _revert(MintZeroQuantity.selector);
  808 |     | 
  809 |     |         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
  810 |     | 
  811 |     |         // Overflows are incredibly unrealistic.
  812 |     |         // `balance` and `numberMinted` have a maximum limit of 2**64.
  813 |     |         // `tokenId` has a maximum limit of 2**256.
  814 |     |         unchecked {
  815 |     |             // Updates:
  816 |     |             // - `address` to the owner.
  817 |     |             // - `startTimestamp` to the timestamp of minting.
  818 |     |             // - `burned` to `false`.
  819 |     |             // - `nextInitialized` to `quantity == 1`.
  820 |     |             _packedOwnerships[startTokenId] = _packOwnershipData(
  821 |     |                 to,
  822 |     |                 _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)
  823 |     |             );
  824 |     | 
  825 |     |             // Updates:
  826 |     |             // - `balance += quantity`.
  827 |     |             // - `numberMinted += quantity`.
  828 |     |             //
  829 |     |             // We can directly add to the `balance` and `numberMinted`.
  830 |     |             _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);
  831 |     | 
  832 |     |             // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.
  833 |     |             uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;
  834 |     | 
  835 |     |             if (toMasked == 0) _revert(MintToZeroAddress.selector);
  836 |     | 
  837 |     |             uint256 end = startTokenId + quantity;
  838 |     |             uint256 tokenId = startTokenId;
  839 |     | 
  840 |     |             if (end - 1 > _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);
  841 |     | 
  842 |     |             do {
  843 |     |                 assembly {
  844 |     |                     // Emit the `Transfer` event.
  845 |     |                     log4(
  846 |     |                         0, // Start of data (0, since no data).
  847 |     |                         0, // End of data (0, since no data).
  848 |     |                         _TRANSFER_EVENT_SIGNATURE, // Signature.
  849 |     |                         0, // `address(0)`.
  850 |     |                         toMasked, // `to`.
  851 |     |                         tokenId // `tokenId`.
  852 |     |                     )
  853 |     |                 }
  854 |     |                 // The `!=` check ensures that large values of `quantity`
  855 |     |                 // that overflows uint256 will make the loop run out of gas.
  856 |     |             } while (++tokenId != end);
  857 |     | 
  858 |     |             _currentIndex = end;
  859 |     |         }
  860 |     |         _afterTokenTransfers(address(0), to, startTokenId, quantity);
  861 |     |     }
  862 |     | 
  863 |     |     /**
  864 |     |      * @dev Mints `quantity` tokens and transfers them to `to`.
  865 |     |      *
  866 |     |      * This function is intended for efficient minting only during contract creation.
  867 |     |      *
  868 |     |      * It emits only one {ConsecutiveTransfer} as defined in
  869 |     |      * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),
  870 |     |      * instead of a sequence of {Transfer} event(s).
  871 |     |      *
  872 |     |      * Calling this function outside of contract creation WILL make your contract
  873 |     |      * non-compliant with the ERC721 standard.
  874 |     |      * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309
  875 |     |      * {ConsecutiveTransfer} event is only permissible during contract creation.
  876 |     |      *
  877 |     |      * Requirements:
  878 |     |      *
  879 |     |      * - `to` cannot be the zero address.
  880 |     |      * - `quantity` must be greater than 0.
  881 |     |      *
  882 |     |      * Emits a {ConsecutiveTransfer} event.
  883 |     |      */
  884 |     |     function _mintERC2309(address to, uint256 quantity) internal virtual {
  885 |     |         uint256 startTokenId = _currentIndex;
  886 |     |         if (to == address(0)) _revert(MintToZeroAddress.selector);
  887 |     |         if (quantity == 0) _revert(MintZeroQuantity.selector);
  888 |     |         if (quantity > _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);
  889 |     | 
  890 |     |         _beforeTokenTransfers(address(0), to, startTokenId, quantity);
  891 |     | 
  892 |     |         // Overflows are unrealistic due to the above check for `quantity` to be below the limit.
  893 |     |         unchecked {
  894 |     |             // Updates:
  895 |     |             // - `balance += quantity`.
  896 |     |             // - `numberMinted += quantity`.
  897 |     |             //
  898 |     |             // We can directly add to the `balance` and `numberMinted`.
  899 |     |             _packedAddressData[to] += quantity * ((1 << _BITPOS_NUMBER_MINTED) | 1);
  900 |     | 
  901 |     |             // Updates:
  902 |     |             // - `address` to the owner.
  903 |     |             // - `startTimestamp` to the timestamp of minting.
  904 |     |             // - `burned` to `false`.
  905 |     |             // - `nextInitialized` to `quantity == 1`.
  906 |     |             _packedOwnerships[startTokenId] = _packOwnershipData(
  907 |     |                 to,
  908 |     |                 _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)
  909 |     |             );
  910 |     | 
  911 |     |             if (startTokenId + quantity - 1 > _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);
  912 |     | 
  913 |     |             emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);
  914 |     | 
  915 |     |             _currentIndex = startTokenId + quantity;
  916 |     |         }
  917 |     |         _afterTokenTransfers(address(0), to, startTokenId, quantity);
  918 |     |     }
  919 |     | 
  920 |     |     /**
  921 |     |      * @dev Safely mints `quantity` tokens and transfers them to `to`.
  922 |     |      *
  923 |     |      * Requirements:
  924 |     |      *
  925 |     |      * - If `to` refers to a smart contract, it must implement
  926 |     |      * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.
  927 |     |      * - `quantity` must be greater than 0.
  928 |     |      *
  929 |     |      * See {_mint}.
  930 |     |      *
  931 |     |      * Emits a {Transfer} event for each mint.
  932 |     |      */
  933 |     |     function _safeMint(
  934 |     |         address to,
  935 |     |         uint256 quantity,
  936 |     |         bytes memory _data
  937 |     |     ) internal virtual {
  938 |     |         _mint(to, quantity);
  939 |     | 
  940 |     |         unchecked {
  941 |     |             if (to.code.length != 0) {
  942 |     |                 uint256 end = _currentIndex;
  943 |     |                 uint256 index = end - quantity;
  944 |     |                 do {
  945 |     |                     if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {
  946 |     |                         _revert(TransferToNonERC721ReceiverImplementer.selector);
  947 |     |                     }
  948 |     |                 } while (index < end);
  949 |     |                 // This prevents reentrancy to `_safeMint`.
  950 |     |                 // It does not prevent reentrancy to `_safeMintSpot`.
  951 |     |                 if (_currentIndex != end) revert();
  952 |     |             }
  953 |     |         }
  954 |     |     }
  955 |     | 
  956 |     |     /**
  957 |     |      * @dev Equivalent to `_safeMint(to, quantity, '')`.
  958 |     |      */
  959 |     |     function _safeMint(address to, uint256 quantity) internal virtual {
  960 |     |         _safeMint(to, quantity, '');
  961 |     |     }
  962 |     | 
  963 |     |     /**
  964 |     |      * @dev Mints a single token at `tokenId`.
  965 |     |      *
  966 |     |      * Note: A spot-minted `tokenId` that has been burned can be re-minted again.
  967 |     |      *
  968 |     |      * Requirements:
  969 |     |      *
  970 |     |      * - `to` cannot be the zero address.
  971 |     |      * - `tokenId` must be greater than `_sequentialUpTo()`.
  972 |     |      * - `tokenId` must not exist.
  973 |     |      *
  974 |     |      * Emits a {Transfer} event for each mint.
  975 |     |      */
  976 |     |     function _mintSpot(address to, uint256 tokenId) internal virtual {
  977 |     |         if (tokenId <= _sequentialUpTo()) _revert(SpotMintTokenIdTooSmall.selector);
  978 |     |         uint256 prevOwnershipPacked = _packedOwnerships[tokenId];
  979 |     |         if (_packedOwnershipExists(prevOwnershipPacked)) _revert(TokenAlreadyExists.selector);
  980 |     | 
  981 |     |         _beforeTokenTransfers(address(0), to, tokenId, 1);
  982 |     | 
  983 |     |         // Overflows are incredibly unrealistic.
  984 |     |         // The `numberMinted` for `to` is incremented by 1, and has a max limit of 2**64 - 1.
  985 |     |         // `_spotMinted` is incremented by 1, and has a max limit of 2**256 - 1.
  986 |     |         unchecked {
  987 |     |             // Updates:
  988 |     |             // - `address` to the owner.
  989 |     |             // - `startTimestamp` to the timestamp of minting.
  990 |     |             // - `burned` to `false`.
  991 |     |             // - `nextInitialized` to `true` (as `quantity == 1`).
  992 |     |             _packedOwnerships[tokenId] = _packOwnershipData(
  993 |     |                 to,
  994 |     |                 _nextInitializedFlag(1) | _nextExtraData(address(0), to, prevOwnershipPacked)
  995 |     |             );
  996 |     | 
  997 |     |             // Updates:
  998 |     |             // - `balance += 1`.
  999 |     |             // - `numberMinted += 1`.
 1000 |     |             //
 1001 |     |             // We can directly add to the `balance` and `numberMinted`.
 1002 |     |             _packedAddressData[to] += (1 << _BITPOS_NUMBER_MINTED) | 1;
 1003 |     | 
 1004 |     |             // Mask `to` to the lower 160 bits, in case the upper bits somehow aren't clean.
 1005 |     |             uint256 toMasked = uint256(uint160(to)) & _BITMASK_ADDRESS;
 1006 |     | 
 1007 |     |             if (toMasked == 0) _revert(MintToZeroAddress.selector);
 1008 |     | 
 1009 |     |             assembly {
 1010 |     |                 // Emit the `Transfer` event.
 1011 |     |                 log4(
 1012 |     |                     0, // Start of data (0, since no data).
 1013 |     |                     0, // End of data (0, since no data).
 1014 |     |                     _TRANSFER_EVENT_SIGNATURE, // Signature.
 1015 |     |                     0, // `address(0)`.
 1016 |     |                     toMasked, // `to`.
 1017 |     |                     tokenId // `tokenId`.
 1018 |     |                 )
 1019 |     |             }
 1020 |     | 
 1021 |     |             ++_spotMinted;
 1022 |     |         }
 1023 |     | 
 1024 |     |         _afterTokenTransfers(address(0), to, tokenId, 1);
 1025 |     |     }
 1026 |     | 
 1027 |     |     /**
 1028 |     |      * @dev Safely mints a single token at `tokenId`.
 1029 |     |      *
 1030 |     |      * Note: A spot-minted `tokenId` that has been burned can be re-minted again.
 1031 |     |      *
 1032 |     |      * Requirements:
 1033 |     |      *
 1034 |     |      * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}.
 1035 |     |      * - `tokenId` must be greater than `_sequentialUpTo()`.
 1036 |     |      * - `tokenId` must not exist.
 1037 |     |      *
 1038 |     |      * See {_mintSpot}.
 1039 |     |      *
 1040 |     |      * Emits a {Transfer} event.
 1041 |     |      */
 1042 |     |     function _safeMintSpot(
 1043 |     |         address to,
 1044 |     |         uint256 tokenId,
 1045 |     |         bytes memory _data
 1046 |     |     ) internal virtual {
 1047 |     |         _mintSpot(to, tokenId);
 1048 |     | 
 1049 |     |         unchecked {
 1050 |     |             if (to.code.length != 0) {
 1051 |     |                 uint256 currentSpotMinted = _spotMinted;
 1052 |     |                 if (!_checkContractOnERC721Received(address(0), to, tokenId, _data)) {
 1053 |     |                     _revert(TransferToNonERC721ReceiverImplementer.selector);
 1054 |     |                 }
 1055 |     |                 // This prevents reentrancy to `_safeMintSpot`.
 1056 |     |                 // It does not prevent reentrancy to `_safeMint`.
 1057 |     |                 if (_spotMinted != currentSpotMinted) revert();
 1058 |     |             }
 1059 |     |         }
 1060 |     |     }
 1061 |     | 
 1062 |     |     /**
 1063 |     |      * @dev Equivalent to `_safeMintSpot(to, tokenId, '')`.
 1064 |     |      */
 1065 |     |     function _safeMintSpot(address to, uint256 tokenId) internal virtual {
 1066 |     |         _safeMintSpot(to, tokenId, '');
 1067 |     |     }
 1068 |     | 
 1069 |     |     // =============================================================
 1070 |     |     //                       APPROVAL OPERATIONS
 1071 |     |     // =============================================================
 1072 |     | 
 1073 |     |     /**
 1074 |     |      * @dev Equivalent to `_approve(to, tokenId, false)`.
 1075 |     |      */
 1076 |     |     function _approve(address to, uint256 tokenId) internal virtual {
 1077 |     |         _approve(to, tokenId, false);
 1078 |     |     }
 1079 |     | 
 1080 |     |     /**
 1081 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
 1082 |     |      * The approval is cleared when the token is transferred.
 1083 |     |      *
 1084 |     |      * Only a single account can be approved at a time, so approving the
 1085 |     |      * zero address clears previous approvals.
 1086 |     |      *
 1087 |     |      * Requirements:
 1088 |     |      *
 1089 |     |      * - `tokenId` must exist.
 1090 |     |      *
 1091 |     |      * Emits an {Approval} event.
 1092 |     |      */
 1093 |     |     function _approve(
 1094 |     |         address to,
 1095 |     |         uint256 tokenId,
 1096 |     |         bool approvalCheck
 1097 |     |     ) internal virtual {
 1098 |     |         address owner = ownerOf(tokenId);
 1099 |     | 
 1100 |     |         if (approvalCheck && _msgSenderERC721A() != owner)
 1101 |     |             if (!isApprovedForAll(owner, _msgSenderERC721A())) {
 1102 |     |                 _revert(ApprovalCallerNotOwnerNorApproved.selector);
 1103 |     |             }
 1104 |     | 
 1105 |     |         _tokenApprovals[tokenId].value = to;
 1106 |     |         emit Approval(owner, to, tokenId);
 1107 |     |     }
 1108 |     | 
 1109 |     |     // =============================================================
 1110 |     |     //                        BURN OPERATIONS
 1111 |     |     // =============================================================
 1112 |     | 
 1113 |     |     /**
 1114 |     |      * @dev Equivalent to `_burn(tokenId, false)`.
 1115 |     |      */
 1116 |     |     function _burn(uint256 tokenId) internal virtual {
 1117 |     |         _burn(tokenId, false);
 1118 |     |     }
 1119 |     | 
 1120 |     |     /**
 1121 |     |      * @dev Destroys `tokenId`.
 1122 |     |      * The approval is cleared when the token is burned.
 1123 |     |      *
 1124 |     |      * Requirements:
 1125 |     |      *
 1126 |     |      * - `tokenId` must exist.
 1127 |     |      *
 1128 |     |      * Emits a {Transfer} event.
 1129 |     |      */
 1130 |     |     function _burn(uint256 tokenId, bool approvalCheck) internal virtual {
 1131 |     |         uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);
 1132 |     | 
 1133 |     |         address from = address(uint160(prevOwnershipPacked));
 1134 |     | 
 1135 |     |         (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);
 1136 |     | 
 1137 |     |         if (approvalCheck) {
 1138 |     |             // The nested ifs save around 20+ gas over a compound boolean condition.
 1139 |     |             if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))
 1140 |     |                 if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);
 1141 |     |         }
 1142 |     | 
 1143 |     |         _beforeTokenTransfers(from, address(0), tokenId, 1);
 1144 |     | 
 1145 |     |         // Clear approvals from the previous owner.
 1146 |     |         assembly {
 1147 |     |             if approvedAddress {
 1148 |     |                 // This is equivalent to `delete _tokenApprovals[tokenId]`.
 1149 |     |                 sstore(approvedAddressSlot, 0)
 1150 |     |             }
 1151 |     |         }
 1152 |     | 
 1153 |     |         // Underflow of the sender's balance is impossible because we check for
 1154 |     |         // ownership above and the recipient's balance can't realistically overflow.
 1155 |     |         // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.
 1156 |     |         unchecked {
 1157 |     |             // Updates:
 1158 |     |             // - `balance -= 1`.
 1159 |     |             // - `numberBurned += 1`.
 1160 |     |             //
 1161 |     |             // We can directly decrement the balance, and increment the number burned.
 1162 |     |             // This is equivalent to `packed -= 1; packed += 1 << _BITPOS_NUMBER_BURNED;`.
 1163 |     |             _packedAddressData[from] += (1 << _BITPOS_NUMBER_BURNED) - 1;
 1164 |     | 
 1165 |     |             // Updates:
 1166 |     |             // - `address` to the last owner.
 1167 |     |             // - `startTimestamp` to the timestamp of burning.
 1168 |     |             // - `burned` to `true`.
 1169 |     |             // - `nextInitialized` to `true`.
 1170 |     |             _packedOwnerships[tokenId] = _packOwnershipData(
 1171 |     |                 from,
 1172 |     |                 (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)
 1173 |     |             );
 1174 |     | 
 1175 |     |             // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .
 1176 |     |             if (prevOwnershipPacked & _BITMASK_NEXT_INITIALIZED == 0) {
 1177 |     |                 uint256 nextTokenId = tokenId + 1;
 1178 |     |                 // If the next slot's address is zero and not burned (i.e. packed value is zero).
 1179 |     |                 if (_packedOwnerships[nextTokenId] == 0) {
 1180 |     |                     // If the next slot is within bounds.
 1181 |     |                     if (nextTokenId != _currentIndex) {
 1182 |     |                         // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.
 1183 |     |                         _packedOwnerships[nextTokenId] = prevOwnershipPacked;
 1184 |     |                     }
 1185 |     |                 }
 1186 |     |             }
 1187 |     |         }
 1188 |     | 
 1189 |     |         emit Transfer(from, address(0), tokenId);
 1190 |     |         _afterTokenTransfers(from, address(0), tokenId, 1);
 1191 |     | 
 1192 |     |         // Overflow not possible, as `_burnCounter` cannot be exceed `_currentIndex + _spotMinted` times.
 1193 |     |         unchecked {
 1194 |     |             _burnCounter++;
 1195 |     |         }
 1196 |     |     }
 1197 |     | 
 1198 |     |     // =============================================================
 1199 |     |     //                     EXTRA DATA OPERATIONS
 1200 |     |     // =============================================================
 1201 |     | 
 1202 |     |     /**
 1203 |     |      * @dev Directly sets the extra data for the ownership data `index`.
 1204 |     |      */
 1205 |     |     function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {
 1206 |     |         uint256 packed = _packedOwnerships[index];
 1207 |     |         if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);
 1208 |     |         uint256 extraDataCasted;
 1209 |     |         // Cast `extraData` with assembly to avoid redundant masking.
 1210 |     |         assembly {
 1211 |     |             extraDataCasted := extraData
 1212 |     |         }
 1213 |     |         packed = (packed & _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted << _BITPOS_EXTRA_DATA);
 1214 |     |         _packedOwnerships[index] = packed;
 1215 |     |     }
 1216 |     | 
 1217 |     |     /**
 1218 |     |      * @dev Called during each token transfer to set the 24bit `extraData` field.
 1219 |     |      * Intended to be overridden by the cosumer contract.
 1220 |     |      *
 1221 |     |      * `previousExtraData` - the value of `extraData` before transfer.
 1222 |     |      *
 1223 |     |      * Calling conditions:
 1224 |     |      *
 1225 |     |      * - When `from` and `to` are both non-zero, `from`'s `tokenId` will be
 1226 |     |      * transferred to `to`.
 1227 |     |      * - When `from` is zero, `tokenId` will be minted for `to`.
 1228 |     |      * - When `to` is zero, `tokenId` will be burned by `from`.
 1229 |     |      * - `from` and `to` are never both zero.
 1230 |     |      */
 1231 |     |     function _extraData(
 1232 |     |         address from,
 1233 |     |         address to,
 1234 |     |         uint24 previousExtraData
 1235 |     |     ) internal view virtual returns (uint24) {}
 1236 |     | 
 1237 |     |     /**
 1238 |     |      * @dev Returns the next extra data for the packed ownership data.
 1239 |     |      * The returned result is shifted into position.
 1240 |     |      */
 1241 |     |     function _nextExtraData(
 1242 |     |         address from,
 1243 |     |         address to,
 1244 |     |         uint256 prevOwnershipPacked
 1245 |     |     ) private view returns (uint256) {
 1246 |     |         uint24 extraData = uint24(prevOwnershipPacked >> _BITPOS_EXTRA_DATA);
 1247 |     |         return uint256(_extraData(from, to, extraData)) << _BITPOS_EXTRA_DATA;
 1248 |     |     }
 1249 |     | 
 1250 |     |     // =============================================================
 1251 |     |     //                       OTHER OPERATIONS
 1252 |     |     // =============================================================
 1253 |     | 
 1254 |     |     /**
 1255 |     |      * @dev Returns the message sender (defaults to `msg.sender`).
 1256 |     |      *
 1257 |     |      * If you are writing GSN compatible contracts, you need to override this function.
 1258 |     |      */
 1259 |     |     function _msgSenderERC721A() internal view virtual returns (address) {
 1260 |     |         return msg.sender;
 1261 |     |     }
 1262 |     | 
 1263 |     |     /**
 1264 |     |      * @dev Converts a uint256 to its ASCII string decimal representation.
 1265 |     |      */
 1266 |     |     function _toString(uint256 value) internal pure virtual returns (string memory str) {
 1267 |     |         assembly {
 1268 |     |             // The maximum value of a uint256 contains 78 digits (1 byte per digit), but
 1269 |     |             // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.
 1270 |     |             // We will need 1 word for the trailing zeros padding, 1 word for the length,
 1271 |     |             // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.
 1272 |     |             let m := add(mload(0x40), 0xa0)
 1273 |     |             // Update the free memory pointer to allocate.
 1274 |     |             mstore(0x40, m)
 1275 |     |             // Assign the `str` to the end.
 1276 |     |             str := sub(m, 0x20)
 1277 |     |             // Zeroize the slot after the string.
 1278 |     |             mstore(str, 0)
 1279 |     | 
 1280 |     |             // Cache the end of the memory to calculate the length later.
 1281 |     |             let end := str
 1282 |     | 
 1283 |     |             // We write the string from rightmost digit to leftmost digit.
 1284 |     |             // The following is essentially a do-while loop that also handles the zero case.
 1285 |     |             // prettier-ignore
 1286 |     |             for { let temp := value } 1 {} {
 1287 |     |                 str := sub(str, 1)
 1288 |     |                 // Write the character to the pointer.
 1289 |     |                 // The ASCII index of the '0' character is 48.
 1290 |     |                 mstore8(str, add(48, mod(temp, 10)))
 1291 |     |                 // Keep dividing `temp` until zero.
 1292 |     |                 temp := div(temp, 10)
 1293 |     |                 // prettier-ignore
 1294 |     |                 if iszero(temp) { break }
 1295 |     |             }
 1296 |     | 
 1297 |     |             let length := sub(end, str)
 1298 |     |             // Move the pointer 32 bytes leftwards to make room for the length.
 1299 |     |             str := sub(str, 0x20)
 1300 |     |             // Store the length.
 1301 |     |             mstore(str, length)
 1302 |     |         }
 1303 |     |     }
 1304 |     | 
 1305 |     |     /**
 1306 |     |      * @dev For more efficient reverts.
 1307 |     |      */
 1308 |     |     function _revert(bytes4 errorSelector) internal pure {
 1309 |     |         assembly {
 1310 |     |             mstore(0x00, errorSelector)
 1311 |     |             revert(0x00, 0x04)
 1312 |     |         }
 1313 |     |     }
 1314 |     | }
 1315 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/erc721a/contracts/IERC721A.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | // ERC721A Contracts v4.3.0
   3 |     | // Creator: Chiru Labs
   4 |     | 
   5 |     | pragma solidity ^0.8.4;
   6 |     | 
   7 |     | /**
   8 |     |  * @dev Interface of ERC721A.
   9 |     |  */
  10 |     | interface IERC721A {
  11 |     |     /**
  12 |     |      * The caller must own the token or be an approved operator.
  13 |     |      */
  14 |     |     error ApprovalCallerNotOwnerNorApproved();
  15 |     | 
  16 |     |     /**
  17 |     |      * The token does not exist.
  18 |     |      */
  19 |     |     error ApprovalQueryForNonexistentToken();
  20 |     | 
  21 |     |     /**
  22 |     |      * Cannot query the balance for the zero address.
  23 |     |      */
  24 |     |     error BalanceQueryForZeroAddress();
  25 |     | 
  26 |     |     /**
  27 |     |      * Cannot mint to the zero address.
  28 |     |      */
  29 |     |     error MintToZeroAddress();
  30 |     | 
  31 |     |     /**
  32 |     |      * The quantity of tokens minted must be more than zero.
  33 |     |      */
  34 |     |     error MintZeroQuantity();
  35 |     | 
  36 |     |     /**
  37 |     |      * The token does not exist.
  38 |     |      */
  39 |     |     error OwnerQueryForNonexistentToken();
  40 |     | 
  41 |     |     /**
  42 |     |      * The caller must own the token or be an approved operator.
  43 |     |      */
  44 |     |     error TransferCallerNotOwnerNorApproved();
  45 |     | 
  46 |     |     /**
  47 |     |      * The token must be owned by `from`.
  48 |     |      */
  49 |     |     error TransferFromIncorrectOwner();
  50 |     | 
  51 |     |     /**
  52 |     |      * Cannot safely transfer to a contract that does not implement the
  53 |     |      * ERC721Receiver interface.
  54 |     |      */
  55 |     |     error TransferToNonERC721ReceiverImplementer();
  56 |     | 
  57 |     |     /**
  58 |     |      * Cannot transfer to the zero address.
  59 |     |      */
  60 |     |     error TransferToZeroAddress();
  61 |     | 
  62 |     |     /**
  63 |     |      * The token does not exist.
  64 |     |      */
  65 |     |     error URIQueryForNonexistentToken();
  66 |     | 
  67 |     |     /**
  68 |     |      * The `quantity` minted with ERC2309 exceeds the safety limit.
  69 |     |      */
  70 |     |     error MintERC2309QuantityExceedsLimit();
  71 |     | 
  72 |     |     /**
  73 |     |      * The `extraData` cannot be set on an unintialized ownership slot.
  74 |     |      */
  75 |     |     error OwnershipNotInitializedForExtraData();
  76 |     | 
  77 |     |     /**
  78 |     |      * `_sequentialUpTo()` must be greater than `_startTokenId()`.
  79 |     |      */
  80 |     |     error SequentialUpToTooSmall();
  81 |     | 
  82 |     |     /**
  83 |     |      * The `tokenId` of a sequential mint exceeds `_sequentialUpTo()`.
  84 |     |      */
  85 |     |     error SequentialMintExceedsLimit();
  86 |     | 
  87 |     |     /**
  88 |     |      * Spot minting requires a `tokenId` greater than `_sequentialUpTo()`.
  89 |     |      */
  90 |     |     error SpotMintTokenIdTooSmall();
  91 |     | 
  92 |     |     /**
  93 |     |      * Cannot mint over a token that already exists.
  94 |     |      */
  95 |     |     error TokenAlreadyExists();
  96 |     | 
  97 |     |     /**
  98 |     |      * The feature is not compatible with spot mints.
  99 |     |      */
 100 |     |     error NotCompatibleWithSpotMints();
 101 |     | 
 102 |     |     // =============================================================
 103 |     |     //                            STRUCTS
 104 |     |     // =============================================================
 105 |     | 
 106 |     |     struct TokenOwnership {
 107 |     |         // The address of the owner.
 108 |     |         address addr;
 109 |     |         // Stores the start time of ownership with minimal overhead for tokenomics.
 110 |     |         uint64 startTimestamp;
 111 |     |         // Whether the token has been burned.
 112 |     |         bool burned;
 113 |     |         // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.
 114 |     |         uint24 extraData;
 115 |     |     }
 116 |     | 
 117 |     |     // =============================================================
 118 |     |     //                         TOKEN COUNTERS
 119 |     |     // =============================================================
 120 |     | 
 121 |     |     /**
 122 |     |      * @dev Returns the total number of tokens in existence.
 123 |     |      * Burned tokens will reduce the count.
 124 |     |      * To get the total number of tokens minted, please see {_totalMinted}.
 125 |     |      */
 126 |     |     function totalSupply() external view returns (uint256);
 127 |     | 
 128 |     |     // =============================================================
 129 |     |     //                            IERC165
 130 |     |     // =============================================================
 131 |     | 
 132 |     |     /**
 133 |     |      * @dev Returns true if this contract implements the interface defined by
 134 |     |      * `interfaceId`. See the corresponding
 135 |     |      * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)
 136 |     |      * to learn more about how these ids are created.
 137 |     |      *
 138 |     |      * This function call must use less than 30000 gas.
 139 |     |      */
 140 |     |     function supportsInterface(bytes4 interfaceId) external view returns (bool);
 141 |     | 
 142 |     |     // =============================================================
 143 |     |     //                            IERC721
 144 |     |     // =============================================================
 145 |     | 
 146 |     |     /**
 147 |     |      * @dev Emitted when `tokenId` token is transferred from `from` to `to`.
 148 |     |      */
 149 |     |     event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
 150 |     | 
 151 |     |     /**
 152 |     |      * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.
 153 |     |      */
 154 |     |     event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);
 155 |     | 
 156 |     |     /**
 157 |     |      * @dev Emitted when `owner` enables or disables
 158 |     |      * (`approved`) `operator` to manage all of its assets.
 159 |     |      */
 160 |     |     event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
 161 |     | 
 162 |     |     /**
 163 |     |      * @dev Returns the number of tokens in `owner`'s account.
 164 |     |      */
 165 |     |     function balanceOf(address owner) external view returns (uint256 balance);
 166 |     | 
 167 |     |     /**
 168 |     |      * @dev Returns the owner of the `tokenId` token.
 169 |     |      *
 170 |     |      * Requirements:
 171 |     |      *
 172 |     |      * - `tokenId` must exist.
 173 |     |      */
 174 |     |     function ownerOf(uint256 tokenId) external view returns (address owner);
 175 |     | 
 176 |     |     /**
 177 |     |      * @dev Safely transfers `tokenId` token from `from` to `to`,
 178 |     |      * checking first that contract recipients are aware of the ERC721 protocol
 179 |     |      * to prevent tokens from being forever locked.
 180 |     |      *
 181 |     |      * Requirements:
 182 |     |      *
 183 |     |      * - `from` cannot be the zero address.
 184 |     |      * - `to` cannot be the zero address.
 185 |     |      * - `tokenId` token must exist and be owned by `from`.
 186 |     |      * - If the caller is not `from`, it must be have been allowed to move
 187 |     |      * this token by either {approve} or {setApprovalForAll}.
 188 |     |      * - If `to` refers to a smart contract, it must implement
 189 |     |      * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.
 190 |     |      *
 191 |     |      * Emits a {Transfer} event.
 192 |     |      */
 193 |     |     function safeTransferFrom(
 194 |     |         address from,
 195 |     |         address to,
 196 |     |         uint256 tokenId,
 197 |     |         bytes calldata data
 198 |     |     ) external payable;
 199 |     | 
 200 |     |     /**
 201 |     |      * @dev Equivalent to `safeTransferFrom(from, to, tokenId, '')`.
 202 |     |      */
 203 |     |     function safeTransferFrom(
 204 |     |         address from,
 205 |     |         address to,
 206 |     |         uint256 tokenId
 207 |     |     ) external payable;
 208 |     | 
 209 |     |     /**
 210 |     |      * @dev Transfers `tokenId` from `from` to `to`.
 211 |     |      *
 212 |     |      * WARNING: Usage of this method is discouraged, use {safeTransferFrom}
 213 |     |      * whenever possible.
 214 |     |      *
 215 |     |      * Requirements:
 216 |     |      *
 217 |     |      * - `from` cannot be the zero address.
 218 |     |      * - `to` cannot be the zero address.
 219 |     |      * - `tokenId` token must be owned by `from`.
 220 |     |      * - If the caller is not `from`, it must be approved to move this token
 221 |     |      * by either {approve} or {setApprovalForAll}.
 222 |     |      *
 223 |     |      * Emits a {Transfer} event.
 224 |     |      */
 225 |     |     function transferFrom(
 226 |     |         address from,
 227 |     |         address to,
 228 |     |         uint256 tokenId
 229 |     |     ) external payable;
 230 |     | 
 231 |     |     /**
 232 |     |      * @dev Gives permission to `to` to transfer `tokenId` token to another account.
 233 |     |      * The approval is cleared when the token is transferred.
 234 |     |      *
 235 |     |      * Only a single account can be approved at a time, so approving the
 236 |     |      * zero address clears previous approvals.
 237 |     |      *
 238 |     |      * Requirements:
 239 |     |      *
 240 |     |      * - The caller must own the token or be an approved operator.
 241 |     |      * - `tokenId` must exist.
 242 |     |      *
 243 |     |      * Emits an {Approval} event.
 244 |     |      */
 245 |     |     function approve(address to, uint256 tokenId) external payable;
 246 |     | 
 247 |     |     /**
 248 |     |      * @dev Approve or remove `operator` as an operator for the caller.
 249 |     |      * Operators can call {transferFrom} or {safeTransferFrom}
 250 |     |      * for any token owned by the caller.
 251 |     |      *
 252 |     |      * Requirements:
 253 |     |      *
 254 |     |      * - The `operator` cannot be the caller.
 255 |     |      *
 256 |     |      * Emits an {ApprovalForAll} event.
 257 |     |      */
 258 |     |     function setApprovalForAll(address operator, bool _approved) external;
 259 |     | 
 260 |     |     /**
 261 |     |      * @dev Returns the account approved for `tokenId` token.
 262 |     |      *
 263 |     |      * Requirements:
 264 |     |      *
 265 |     |      * - `tokenId` must exist.
 266 |     |      */
 267 |     |     function getApproved(uint256 tokenId) external view returns (address operator);
 268 |     | 
 269 |     |     /**
 270 |     |      * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.
 271 |     |      *
 272 |     |      * See {setApprovalForAll}.
 273 |     |      */
 274 |     |     function isApprovedForAll(address owner, address operator) external view returns (bool);
 275 |     | 
 276 |     |     // =============================================================
 277 |     |     //                        IERC721Metadata
 278 |     |     // =============================================================
 279 |     | 
 280 |     |     /**
 281 |     |      * @dev Returns the token collection name.
 282 |     |      */
 283 |     |     function name() external view returns (string memory);
 284 |     | 
 285 |     |     /**
 286 |     |      * @dev Returns the token collection symbol.
 287 |     |      */
 288 |     |     function symbol() external view returns (string memory);
 289 |     | 
 290 |     |     /**
 291 |     |      * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.
 292 |     |      */
 293 |     |     function tokenURI(uint256 tokenId) external view returns (string memory);
 294 |     | 
 295 |     |     // =============================================================
 296 |     |     //                           IERC2309
 297 |     |     // =============================================================
 298 |     | 
 299 |     |     /**
 300 |     |      * @dev Emitted when tokens in `fromTokenId` to `toTokenId`
 301 |     |      * (inclusive) is transferred from `from` to `to`, as defined in the
 302 |     |      * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.
 303 |     |      *
 304 |     |      * See {_mintERC2309} for more details.
 305 |     |      */
 306 |     |     event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);
 307 |     | }
 308 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/FuzzSetup.sol
   1 |     | // SPDX-License-Identifier: UNLICENSED
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // fuzzlib
   5 |     | import {FuzzBase} from "fuzzlib/FuzzBase.sol";
   6 |     | 
   7 |     | // forge
   8 |     | import {Test} from "forge-std/Test.sol";
   9 |     | 
  10 |     | // PEAS
  11 |     | import {PEAS} from "../../contracts/PEAS.sol";
  12 |     | import {V3TwapUtilities} from '../../contracts/twaputils/V3TwapUtilities.sol';
  13 |     | import {UniswapDexAdapter} from '../../contracts/dex/UniswapDexAdapter.sol';
  14 |     | import {IDecentralizedIndex} from '../../contracts/interfaces/IDecentralizedIndex.sol';
  15 |     | import {WeightedIndex} from '../../contracts/WeightedIndex.sol';
  16 |     | import {StakingPoolToken} from "../../contracts/StakingPoolToken.sol"; 
  17 |     | import {LendingAssetVault} from "../../contracts/LendingAssetVault.sol";
  18 |     | import {IndexUtils} from "../../contracts/IndexUtils.sol";
  19 |     | import {IIndexUtils_LEGACY} from "../../contracts/interfaces/IIndexUtils_LEGACY.sol";
  20 |     | import {MockIndexUtils} from "./mocks/MockIndexUtils.sol";
  21 |     | import {RewardsWhitelist} from "../../contracts/RewardsWhitelist.sol";
  22 |     | 
  23 |     | // oracles
  24 |     | import {ChainlinkSinglePriceOracle} from "../../contracts/oracle/ChainlinkSinglePriceOracle.sol";
  25 |     | import {UniswapV3SinglePriceOracle} from "../../contracts/oracle/UniswapV3SinglePriceOracle.sol";
  26 |     | import {V2ReservesUniswap} from "../../contracts/oracle/V2ReservesUniswap.sol";
  27 |     | import {aspTKNMinimalOracle} from "../../contracts/oracle/aspTKNMinimalOracle.sol";
  28 |     | 
  29 |     | // autocompounding
  30 |     | import {AutoCompoundingPodLpFactory} from "../../contracts/AutoCompoundingPodLpFactory.sol";
  31 |     | import {AutoCompoundingPodLp} from "../../contracts/AutoCompoundingPodLp.sol";
  32 |     | 
  33 |     | // lvf
  34 |     | import {LeverageManager} from "../../contracts/lvf/LeverageManager.sol";
  35 |     | 
  36 |     | // fraxlend
  37 |     | import {FraxlendPairDeployer, ConstructorParams} from "./modules/fraxlend/FraxlendPairDeployer.sol";
  38 |     | import {FraxlendWhitelist} from "./modules/fraxlend/FraxlendWhitelist.sol";
  39 |     | import {FraxlendPairRegistry} from "./modules/fraxlend/FraxlendPairRegistry.sol";
  40 |     | import {FraxlendPair} from "./modules/fraxlend/FraxlendPair.sol";
  41 |     | import {VariableInterestRate} from "./modules/fraxlend/VariableInterestRate.sol";
  42 |     | 
  43 |     | // uniswap-v2-core
  44 |     | import {UniswapV2Factory} from "v2-core/UniswapV2Factory.sol";
  45 |     | import {UniswapV2Pair} from "v2-core/UniswapV2Pair.sol";
  46 |     | 
  47 |     | // uniswap-v2-periphery
  48 |     | import {UniswapV2Router02} from "v2-periphery/UniswapV2Router02.sol";
  49 |     | 
  50 |     | // uniswap-v3-core
  51 |     | import {UniswapV3Factory} from "v3-core/UniswapV3Factory.sol";
  52 |     | import {UniswapV3Pool} from "v3-core/UniswapV3Pool.sol";
  53 |     | 
  54 |     | // uniswap-v3-periphery
  55 |     | import {SwapRouter} from "v3-periphery/SwapRouter.sol";
  56 |     | import {LiquidityManagement} from "v3-periphery/base/LiquidityManagement.sol";
  57 |     | import {PeripheryPayments} from "v3-periphery/base/PeripheryPayments.sol";
  58 |     | import {PoolAddress} from "v3-periphery/libraries/PoolAddress.sol";
  59 |     | 
  60 |     | 
  61 |     | // mocks
  62 |     | import {WETH9} from "./mocks/WETH.sol";
  63 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  64 |     | import {MockERC20} from "./mocks/MockERC20.sol";
  65 |     | import {TestERC20} from "../../contracts/test/TestERC20.sol";
  66 |     | import {TestERC4626Vault} from "../../contracts/test/TestERC4626Vault.sol";
  67 |     | import {MockV3Aggregator} from "./mocks/MockV3Aggregator.sol";
  68 |     | import {MockUniV3Minter} from "./mocks/MockUniV3Minter.sol";
  69 |     | 
  70 |     | contract FuzzSetup is Test, FuzzBase {
  71 |     | 
  72 |     |     /*///////////////////////////////////////////////////////////////
  73 |     |                             GLOBAL VARIABLES
  74 |     |     ///////////////////////////////////////////////////////////////*/
  75 |     | 
  76 |     |     // external actors
  77 |     |     address internal user0 = vm.addr(uint256(keccak256("User0")));
  78 |     |     address internal user1 = vm.addr(uint256(keccak256("User1")));
  79 |     |     address internal user2 = vm.addr(uint256(keccak256("User2")));
  80 |     | 
  81 |     |     address[] internal users = [user0, user1, user2];
  82 |     | 
  83 |     |     // fraxlend protocol actors
  84 |     |     address internal comptroller = vm.addr(uint256(keccak256("comptroller")));
  85 |     |     address internal circuitBreaker = vm.addr(uint256(keccak256("circuitBreaker")));
  86 |     |     address internal timelock = vm.addr(uint256(keccak256("comptroller")));
  87 |     | 
  88 |     |     uint16 internal fee = 100;
  89 |     | 
  90 |     |     /*///////////////////////////////////////////////////////////////
  91 |     |                             TEST CONTRACTS
  92 |     |     ///////////////////////////////////////////////////////////////*/
  93 |     | 
  94 |     |     PEAS internal _peas;
  95 |     |     V3TwapUtilities internal _twapUtils;
  96 |     |     UniswapDexAdapter internal _dexAdapter;
  97 |     |     LendingAssetVault internal _lendingAssetVault;
  98 |     |     RewardsWhitelist internal _rewardsWhitelist;
  99 |     | 
 100 |     |     // oracles
 101 |     |     V2ReservesUniswap internal _v2Res;
 102 |     |     ChainlinkSinglePriceOracle internal _clOracle;
 103 |     |     UniswapV3SinglePriceOracle internal _uniOracle;
 104 |     |     aspTKNMinimalOracle internal _aspTKNMinOracle1;
 105 |     |     aspTKNMinimalOracle internal _aspTKNMinOracle2;
 106 |     |     aspTKNMinimalOracle internal _aspTKNMinOracle4;
 107 |     | 
 108 |     |     // pods
 109 |     |     WeightedIndex internal _pod1; // 1 token
 110 |     |     WeightedIndex internal _pod2; // 2 tokens
 111 |     |     WeightedIndex internal _pod4; // 4 tokens *_*
 112 |     | 
 113 |     |     WeightedIndex[] internal _pods;
 114 |     | 
 115 |     |     // index utils
 116 |     |     MockIndexUtils internal _indexUtils;
 117 |     | 
 118 |     |     // autocompounding
 119 |     |     AutoCompoundingPodLpFactory internal _aspTKNFactory;
 120 |     |     AutoCompoundingPodLp internal _aspTKN1;
 121 |     |     address internal _aspTKN1Address;
 122 |     |     AutoCompoundingPodLp internal _aspTKN2;
 123 |     |     address internal _aspTKN2Address;
 124 |     |     AutoCompoundingPodLp internal _aspTKN4;
 125 |     |     address internal _aspTKN4Address;
 126 |     | 
 127 |     |     AutoCompoundingPodLp[] internal _aspTKNs;
 128 |     | 
 129 |     |     // lvf 
 130 |     |     LeverageManager internal _leverageManager;
 131 |     | 
 132 |     |     // fraxlend
 133 |     |     FraxlendPairDeployer internal _fraxDeployer;
 134 |     |     FraxlendWhitelist internal _fraxWhitelist;
 135 |     |     FraxlendPairRegistry internal _fraxRegistry;
 136 |     |     VariableInterestRate internal _variableInterestRate;
 137 |     | 
 138 |     |     FraxlendPair internal _fraxLPToken1;
 139 |     |     FraxlendPair internal _fraxLPToken2;
 140 |     |     FraxlendPair internal _fraxLPToken4;
 141 |     | 
 142 |     |     FraxlendPair[] internal _fraxPairs;
 143 |     | 
 144 |     |     // mocks
 145 |     |     MockUniV3Minter internal _uniV3Minter;
 146 |     |     MockERC20 internal _mockDai;
 147 |     |     WETH9 internal _weth;
 148 |     |     MockERC20 internal _tokenA;
 149 |     |     MockERC20 internal _tokenB;
 150 |     |     MockERC20 internal _tokenC;
 151 |     |     address[] internal tokens = [address(_weth), address(_tokenA), address(_tokenB), address(_tokenC)];
 152 |     | 
 153 |     |     // mock price feeds
 154 |     |     MockV3Aggregator internal _peasPriceFeed;
 155 |     |     MockV3Aggregator internal _daiPriceFeed;
 156 |     |     MockV3Aggregator internal _wethPriceFeed;
 157 |     |     MockV3Aggregator internal _tokenAPriceFeed;
 158 |     |     MockV3Aggregator internal _tokenBPriceFeed;
 159 |     |     MockV3Aggregator internal _tokenCPriceFeed;
 160 |     | 
 161 |     |     // uniswap-v2-core
 162 |     |     UniswapV2Factory internal _uniV2Factory;
 163 |     |     UniswapV2Pair internal _uniV2Pool;
 164 |     | 
 165 |     |     // uniswap-v2-periphery
 166 |     |     UniswapV2Router02 internal _v2SwapRouter;
 167 |     | 
 168 |     |     // uniswap-v3-core
 169 |     |     UniswapV3Factory internal _uniV3Factory;
 170 |     |     UniswapV3Pool internal _v3peasDaiPool;
 171 |     |     UniswapV3Pool internal _v3wethDaiPool;
 172 |     | 
 173 |     |     // uniswap=v3-periphery
 174 |     |     SwapRouter internal _v3SwapRouter;
 175 |     | 
 176 |     |     /*///////////////////////////////////////////////////////////////
 177 |     |                             SETUP FUNCTIONS
 178 |     |     ///////////////////////////////////////////////////////////////*/
 179 |     | 
 180 |     |     function setup() internal {
 181 |     |         
 182 |     |         _deployUniV3Minter();
 183 |     |         _deployWETH();
 184 |     |         _deployTokens();
 185 |     |         _deployPeas();
 186 |     |         _deployUniV2();
 187 |     |         _deployUniV3();
 188 |     |         _deployTwapUtils();
 189 |     |         _deployDexAdapter();
 190 |     |         _deployRewardsWhitelist();
 191 |     |         _deployIndexUtils();
 192 |     |         _deployPriceFeeds();
 193 |     |         _deployWeightedIndexes();
 194 |     |         _deployAutoCompoundingPodLpFactory();
 195 |     |         _getAutoCompoundingPodLpAddresses();
 196 |     |         _deployAspTKNOracles();
 197 |     |         _deployAspTKNs();
 198 |     |         _deployVariableInterestRate();
 199 |     |         _deployFraxWhitelist();
 200 |     |         _deployFraxPairRegistry();
 201 |     |         _deployFraxPairDeployer();
 202 |     |         _deployFraxPairs();
 203 |     |         _deployLendingAssetVault();
 204 |     |         _deployLeverageManager();
 205 |     | 
 206 |     |         _setupActors();
 207 |     | 
 208 |     |     }
 209 |     | 
 210 |     |     function _deployUniV3Minter() internal {
 211 |     |         _uniV3Minter = new MockUniV3Minter();
 212 |     |     }
 213 |     |     function _deployWETH() internal {
 214 |     |         _weth = new WETH9();
 215 |     | 
 216 |     |         vm.deal(address(this), 100000 ether);
 217 |     |         _weth.deposit{value: 100000 ether}();
 218 |     | 
 219 |     |         vm.deal(address(_uniV3Minter), 100000 ether);
 220 |     |         vm.prank(address(_uniV3Minter));
 221 |     |         _weth.deposit{value: 100000 ether}();
 222 |     |     }
 223 |     | 
 224 |     |     event Message(string a);
 225 |     |     event MessageUint(string a, uint256 b);
 226 |     |     event MessageBool(string a, bool b);
 227 |     |     event MessageAddress(string a, address b);
 228 |     | 
 229 |     |     function _deployTokens() internal {
 230 |     | 
 231 |     |         if (address(this) == 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496) {
 232 |     |             _mockDai = new MockERC20();
 233 |     |             _tokenA = new MockERC20();
 234 |     |             _tokenB = new MockERC20();
 235 |     |             _tokenC = new MockERC20();
 236 |     | 
 237 |     |             _tokenA.initialize("TOKEN A", "TA", 18);
 238 |     |             _tokenB.initialize("TOKEN B", "TB", 6);
 239 |     |             _tokenC.initialize("TOKEN C", "TC", 18);
 240 |     |             bytes memory code = address(_mockDai).code;
 241 |     |         
 242 |     |             vm.etch(0x6B175474E89094C44Da98b954EedeAC495271d0F, code);
 243 |     | 
 244 |     |             _mockDai = MockERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
 245 |     |             _mockDai.initialize("MockDAI", "mDAI", 18);
 246 |     | 
 247 |     |             _mockDai.mint(address(this), 100000 ether);
 248 |     |             _tokenA.mint(address(this), 100000 ether);
 249 |     |             _tokenB.mint(address(this), 100000e6);
 250 |     |             _tokenC.mint(address(this), 100000 ether);
 251 |     | 
 252 |     |             _tokenA.mint(address(_uniV3Minter), 100000 ether);
 253 |     |             _tokenB.mint(address(_uniV3Minter), 100000e6);
 254 |     |             _tokenC.mint(address(_uniV3Minter), 100000 ether);
 255 |     |             _mockDai.mint(address(_uniV3Minter), 100000 ether);
 256 |     |         } else {
 257 |     | 
 258 |     |             _mockDai = MockERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);
 259 |     |             _tokenA = new MockERC20();
 260 |     |             _tokenB = new MockERC20();
 261 |     |             _tokenC = new MockERC20();
 262 |     | 
 263 |     |             _mockDai.initialize("MockDAI", "mDAI", 18);
 264 |     |             _tokenA.initialize("TOKEN A", "TA", 18);
 265 |     |             _tokenB.initialize("TOKEN B", "TB", 6);
 266 |     |             _tokenC.initialize("TOKEN C", "TC", 18);
 267 |     | 
 268 |     |             _tokenA.mint(address(this), 100000 ether);
 269 |     |             _tokenB.mint(address(this), 100000e6);
 270 |     |             _tokenC.mint(address(this), 100000 ether);
 271 |     |             _mockDai.mint(address(this), 100000 ether);
 272 |     | 
 273 |     |             _tokenA.mint(address(_uniV3Minter), 100000 ether);
 274 |     |             _tokenB.mint(address(_uniV3Minter), 100000e6);
 275 |     |             _tokenC.mint(address(_uniV3Minter), 100000 ether);
 276 |     |             _mockDai.mint(address(_uniV3Minter), 100000 ether);
 277 |     |         }
 278 |     |     }
 279 |     | 
 280 |     |     function _deployPeas() internal {
 281 |     |         _peas = new PEAS('Peapods', 'PEAS');
 282 |     | 
 283 |     |         _peas.transfer(address(_uniV3Minter), 100000 ether);
 284 |     |     }
 285 |     | 
 286 |     |     function _deployUniV2() internal {
 287 |     |         _uniV2Factory = new UniswapV2Factory(address(this));
 288 |     |         _v2SwapRouter = new UniswapV2Router02(address(_uniV2Factory), address(_weth));
 289 |     |     }
 290 |     | 
 291 |     |     function _deployUniV3() internal {
 292 |     |         _uniV3Factory = new UniswapV3Factory();
 293 |     |         _v3peasDaiPool = UniswapV3Pool(
 294 |     |             _uniV3Factory.createPool(
 295 |     |                 address(_peas),
 296 |     |                 address(_mockDai),
 297 |     |                 500
 298 |     |             )
 299 |     |         );
 300 |     |         _v3peasDaiPool.initialize(1<<96);
 301 |     |         
 302 |     |         _uniV3Minter.V3addLiquidity(_v3peasDaiPool, 100e18);
 303 |     |         _v3wethDaiPool = UniswapV3Pool(
 304 |     |             _uniV3Factory.createPool(
 305 |     |                 address(_weth),
 306 |     |                 address(_mockDai),
 307 |     |                 500
 308 |     |             )
 309 |     |         );
 310 |     |         _v3wethDaiPool.initialize(1<<96);
 311 |     |         _uniV3Minter.V3addLiquidity(_v3wethDaiPool, 100e18);
 312 |     |         _v3SwapRouter = new SwapRouter(address(_uniV3Factory), address(_weth));
 313 |     | 
 314 |     |     }
 315 |     | 
 316 |     |     function _deployTwapUtils() internal {
 317 |     |         _twapUtils = new V3TwapUtilities();
 318 |     |     }
 319 |     | 
 320 |     |     function _deployDexAdapter() internal {
 321 |     |         _dexAdapter = new UniswapDexAdapter(_twapUtils, address(_v2SwapRouter), address(_v3SwapRouter), false);
 322 |     |     }
 323 |     | 
 324 |     |     function _deployRewardsWhitelist() internal {
 325 |     |         _rewardsWhitelist = new RewardsWhitelist();
 326 |     |     }
 327 |     | 
 328 |     |     // function _deployProtocolFees() internal {
 329 |     |     //     _protocolFees = new ProtocolFees();
 330 |     |     //     _protocolFees.setYieldAdmin(10000);
 331 |     |     //     _protocolFees.setYieldBurn(10000);
 332 |     | 
 333 |     |     //     _protocolFeeRouter = new ProtocolFeeRouter(_protocolFees);
 334 |     |     // }
 335 |     | 
 336 |     |     function _deployIndexUtils() internal {
 337 |     |         _indexUtils = new MockIndexUtils(
 338 |     |             _twapUtils,
 339 |     |             _dexAdapter,
 340 |     |             address(_v3SwapRouter)
 341 |     |         );
 342 |     |     }
 343 |     | 
 344 |     |     function _deployPriceFeeds() internal {
 345 |     |         _peasPriceFeed = new MockV3Aggregator(_peas.decimals(), 3e18);
 346 |     |         _daiPriceFeed = new MockV3Aggregator(_mockDai.decimals(), 1e18);
 347 |     |         _wethPriceFeed = new MockV3Aggregator(_weth.decimals(), 3000e18);
 348 |     |         _tokenAPriceFeed = new MockV3Aggregator(_tokenA.decimals(), 1e18);
 349 |     |         _tokenBPriceFeed = new MockV3Aggregator(_tokenB.decimals(), 100e6);
 350 |     |         _tokenCPriceFeed = new MockV3Aggregator(_tokenC.decimals(), 50e18);
 351 |     |     }
 352 |     | 
 353 |     |     function _deployWeightedIndexes() internal {
 354 |     |         IDecentralizedIndex.Config memory _c;
 355 |     |         IDecentralizedIndex.Fees memory _f;
 356 |     |         _f.bond = fee;
 357 |     |         _f.debond = fee;
 358 |     | 
 359 |     |         // POD1
 360 |     |         address[] memory _t1 = new address[](1);
 361 |     |         _t1[0] = address(_peas);
 362 |     |         uint256[] memory _w1 = new uint256[](1);
 363 |     |         _w1[0] = 100;
 364 |     |         _pod1 = new WeightedIndex('Test1', 'pTEST1', _c, _f, _t1, _w1, address(0), address(_peas), address(_dexAdapter), false);
 365 |     | 
 366 |     |         // approve pod asset & pair asset
 367 |     |         _peas.approve(address(_pod1), type(uint256).max);
 368 |     |         _mockDai.approve(address(_pod1), type(uint256).max);
 369 |     |         // mint some pTKNs
 370 |     |         _pod1.bond(
 371 |     |             address(_peas),
 372 |     |             1 ether,
 373 |     |             1 ether
 374 |     |         );
 375 |     |         // add Liquidity
 376 |     |         _pod1.addLiquidityV2(
 377 |     |             1 ether,
 378 |     |             1 ether,
 379 |     |             100,
 380 |     |             block.timestamp
 381 |     |         );
 382 |     | 
 383 |     |         // add to array for fuzzing
 384 |     |         _pods.push(_pod1);
 385 |     | 
 386 |     |         // POD2
 387 |     |         address[] memory _t2 = new address[](2);
 388 |     |         _t2[0] = address(_peas);
 389 |     |         _t2[1] = address(_weth);
 390 |     |         uint256[] memory _w2 = new uint256[](2);
 391 |     |         _w2[0] = 50;
 392 |     |         _w2[1] = 50;
 393 |     |         _pod2 = new WeightedIndex('Test2', 'pTEST2', _c, _f, _t2, _w2, address(0), address(_peas), address(_dexAdapter), false);
 394 |     | 
 395 |     |         // approve pod asset & pair asset
 396 |     |         _peas.approve(address(_pod2), type(uint256).max);
 397 |     |         _weth.approve(address(_pod2), type(uint256).max);
 398 |     |         _mockDai.approve(address(_pod2), type(uint256).max);
 399 |     |         // mint some pTKNs
 400 |     |         _pod2.bond(
 401 |     |             address(_peas),
 402 |     |             100 ether,
 403 |     |             100 ether
 404 |     |         );
 405 |     |         // add Liquidity
 406 |     |         _pod2.addLiquidityV2(
 407 |     |             100 ether,
 408 |     |             100 ether,
 409 |     |             100,
 410 |     |             block.timestamp
 411 |     |         );
 412 |     | 
 413 |     |         // add to array for fuzzing
 414 |     |         _pods.push(_pod2);
 415 |     | 
 416 |     |         // POD4
 417 |     |         address[] memory _t4 = new address[](4);
 418 |     |         _t4[0] = address(_weth);
 419 |     |         _t4[1] = address(_tokenA);
 420 |     |         _t4[2] = address(_tokenB);
 421 |     |         _t4[3] = address(_tokenC);
 422 |     |         uint256[] memory _w4 = new uint256[](4);
 423 |     |         _w4[0] = 25;
 424 |     |         _w4[1] = 25;
 425 |     |         _w4[2] = 25;
 426 |     |         _w4[3] = 25;
 427 |     |         _pod4 = new WeightedIndex('Test4', 'pTEST4', _c, _f, _t4, _w4, address(0), address(_peas), address(_dexAdapter), false);
 428 |     | 
 429 |     |         // approve pod asset & pair asset
 430 |     |         _weth.approve(address(_pod4), type(uint256).max);
 431 |     |         _tokenA.approve(address(_pod4), type(uint256).max);
 432 |     |         _tokenB.approve(address(_pod4), type(uint256).max);
 433 |     |         _tokenC.approve(address(_pod4), type(uint256).max);
 434 |     |         _mockDai.approve(address(_pod4), type(uint256).max);
 435 |     |         // mint some pTKNs
 436 |     |         _pod4.bond(
 437 |     |             address(_weth),
 438 |     |             1 ether,
 439 |     |             1 ether
 440 |     |         );
 441 |     |         // add Liquidity
 442 |     |         _pod4.addLiquidityV2(
 443 |     |             1 ether,
 444 |     |             1 ether,
 445 |     |             100,
 446 |     |             block.timestamp
 447 |     |         );
 448 |     | 
 449 |     |         // add to array for fuzzing
 450 |     |         _pods.push(_pod4);
 451 |     |     }
 452 |     | 
 453 |     |     function _deployAutoCompoundingPodLpFactory() internal {
 454 |     |         _aspTKNFactory = new AutoCompoundingPodLpFactory();
 455 |     |     }
 456 |     | 
 457 |     |     function _getAutoCompoundingPodLpAddresses() internal {
 458 |     |         _aspTKN1Address = _aspTKNFactory.getNewCaFromParams(
 459 |     |             "Test aspTKN1",
 460 |     |             "aspTKN1",
 461 |     |             _pod1,
 462 |     |             _dexAdapter,
 463 |     |             _indexUtils,
 464 |     |             _rewardsWhitelist,
 465 |     |             _twapUtils,
 466 |     |             0
 467 |     |         );
 468 |     | 
 469 |     |         _aspTKN2Address = _aspTKNFactory.getNewCaFromParams(
 470 |     |             "Test aspTKN2",
 471 |     |             "aspTKN2",
 472 |     |             _pod2,
 473 |     |             _dexAdapter,
 474 |     |             _indexUtils,
 475 |     |             _rewardsWhitelist,
 476 |     |             _twapUtils,
 477 |     |             0
 478 |     |         );
 479 |     | 
 480 |     |         _aspTKN4Address = _aspTKNFactory.getNewCaFromParams(
 481 |     |             "Test aspTKN4",
 482 |     |             "aspTKN4",
 483 |     |             _pod4,
 484 |     |             _dexAdapter,
 485 |     |             _indexUtils,
 486 |     |             _rewardsWhitelist,
 487 |     |             _twapUtils,
 488 |     |             0
 489 |     |         );
 490 |     |     }
 491 |     | 
 492 |     |     function _deployAspTKNOracles() internal {
 493 |     |         _v2Res = new V2ReservesUniswap();
 494 |     |         _clOracle = new ChainlinkSinglePriceOracle();
 495 |     |         _uniOracle = new UniswapV3SinglePriceOracle();
 496 |     | 
 497 |     |         _aspTKNMinOracle1 = new aspTKNMinimalOracle(
 498 |     |             _aspTKN1Address,
 499 |     |             address(_mockDai), // DAI
 500 |     |             false,
 501 |     |             _pod1.lpStakingPool(),
 502 |     |             address(_v3peasDaiPool), // UniV3: PEAS / DAI
 503 |     |             address(_daiPriceFeed), // CL: DAI / USD
 504 |     |             address(0),
 505 |     |             address(0),
 506 |     |             address(0),
 507 |     |             address(_clOracle),
 508 |     |             address(_uniOracle),
 509 |     |             address(_v2Res)
 510 |     |         );
 511 |     | 
 512 |     |         _aspTKNMinOracle2 = new aspTKNMinimalOracle(
 513 |     |             _aspTKN2Address,
 514 |     |             address(_mockDai), // DAI
 515 |     |             false,
 516 |     |             _pod2.lpStakingPool(),
 517 |     |             address(_v3peasDaiPool), // UniV3: PEAS / DAI
 518 |     |             address(_daiPriceFeed), // CL: DAI / USD
 519 |     |             address(0),
 520 |     |             address(0),
 521 |     |             address(0),
 522 |     |             address(_clOracle),
 523 |     |             address(_uniOracle),
 524 |     |             address(_v2Res)
 525 |     |         );
 526 |     | 
 527 |     |         _aspTKNMinOracle4 = new aspTKNMinimalOracle(
 528 |     |             _aspTKN4Address,
 529 |     |             address(_mockDai), // DAI
 530 |     |             false,
 531 |     |             _pod4.lpStakingPool(),
 532 |     |             address(_v3wethDaiPool), // UniV3: PEAS / DAI
 533 |     |             address(_daiPriceFeed), // CL: DAI / USD
 534 |     |             address(0),
 535 |     |             address(0),
 536 |     |             address(0),
 537 |     |             address(_clOracle),
 538 |     |             address(_uniOracle),
 539 |     |             address(_v2Res)
 540 |     |         );
 541 |     |     }
 542 |     | 
 543 |     |     function _deployAspTKNs() internal {
 544 |     |         address _lpToken1 = _pod1.lpStakingPool();
 545 |     |         address _stakingToken1 = StakingPoolToken(_lpToken1).stakingToken();
 546 |     |         // Approve pod LP token
 547 |     |         IERC20(_stakingToken1).approve(_lpToken1, 1000);
 548 |     |         // Stake liquidity tokens for initial aspTKN deposit
 549 |     |         StakingPoolToken(_lpToken1).stake(address(this), 1000);
 550 |     |         // Approve staking token for min deposit
 551 |     |         IERC20(_lpToken1).approve(address(_aspTKNFactory), 1000);
 552 |     | 
 553 |     |         _aspTKNFactory.create(
 554 |     |             "Test aspTKN1",
 555 |     |             "aspTKN1",
 556 |     |             _pod1,
 557 |     |             _dexAdapter,
 558 |     |             _indexUtils,
 559 |     |             _rewardsWhitelist,
 560 |     |             _twapUtils,
 561 |     |             0
 562 |     |         );
 563 |     |         _aspTKN1 = AutoCompoundingPodLp(_aspTKN1Address);
 564 |     | 
 565 |     |         // add to array for fuzzing
 566 |     |         _aspTKNs.push(_aspTKN1);
 567 |     | 
 568 |     |         address _lpToken2 = _pod2.lpStakingPool();
 569 |     |         address _stakingToken2 = StakingPoolToken(_lpToken2).stakingToken();
 570 |     |         // Approve pod LP token
 571 |     |         IERC20(_stakingToken2).approve(_lpToken2, 1000);
 572 |     |         // Stake liquidity tokens for initial aspTKN deposit
 573 |     |         StakingPoolToken(_lpToken2).stake(address(this), 1000);
 574 |     |         // Approve staking token for min deposit
 575 |     |         IERC20(_lpToken2).approve(address(_aspTKNFactory), 1000);
 576 |     | 
 577 |     |         _aspTKNFactory.create(
 578 |     |             "Test aspTKN2",
 579 |     |             "aspTKN2",
 580 |     |             _pod2,
 581 |     |             _dexAdapter,
 582 |     |             _indexUtils,
 583 |     |             _rewardsWhitelist,
 584 |     |             _twapUtils,
 585 |     |             0
 586 |     |         );
 587 |     |         _aspTKN2 = AutoCompoundingPodLp(_aspTKN2Address);
 588 |     | 
 589 |     |         // add to array for fuzzing
 590 |     |         _aspTKNs.push(_aspTKN2);
 591 |     | 
 592 |     |         address _lpToken4 = _pod4.lpStakingPool();
 593 |     |         address _stakingToken4 = StakingPoolToken(_lpToken4).stakingToken();
 594 |     |         // Approve pod LP token
 595 |     |         IERC20(_stakingToken4).approve(_lpToken4, 1000);
 596 |     |         // Stake liquidity tokens for initial aspTKN deposit
 597 |     |         StakingPoolToken(_lpToken4).stake(address(this), 1000);
 598 |     |         // Approve staking token for min deposit
 599 |     |         IERC20(_lpToken4).approve(address(_aspTKNFactory), 1000);
 600 |     | 
 601 |     |         _aspTKNFactory.create(
 602 |     |             "Test aspTKN4",
 603 |     |             "aspTKN4",
 604 |     |             _pod4,
 605 |     |             _dexAdapter,
 606 |     |             _indexUtils,
 607 |     |             _rewardsWhitelist,
 608 |     |             _twapUtils,
 609 |     |             0
 610 |     |         );
 611 |     |         _aspTKN4 = AutoCompoundingPodLp(_aspTKN4Address);
 612 |     | 
 613 |     |         // add to array for fuzzing
 614 |     |         _aspTKNs.push(_aspTKN4);
 615 |     |     }
 616 |     | 
 617 |     |     function _deployVariableInterestRate() internal {
 618 |     |         // These values taken from existing Fraxlend Variable Rate Contract
 619 |     |         _variableInterestRate = new VariableInterestRate(
 620 |     |             "[0.5 0.5@.875 5-10k] 2 days (.75-.85)",
 621 |     |             75000,
 622 |     |             85000,
 623 |     |             87500,
 624 |     |             158247046,
 625 |     |             1582470460,
 626 |     |             3164940920000,
 627 |     |             172800,
 628 |     |             500000000000000000
 629 |     |         );
 630 |     |     }
 631 |     | 
 632 |     |     function _deployFraxWhitelist() internal {
 633 |     |         _fraxWhitelist = new FraxlendWhitelist();
 634 |     |     }
 635 |     | 
 636 |     |     function _deployFraxPairRegistry() internal {
 637 |     |         address[] memory _initialDeployers = new address[](0);
 638 |     |         _fraxRegistry = new FraxlendPairRegistry(
 639 |     |             address(this),
 640 |     |             _initialDeployers
 641 |     |         );
 642 |     |     }
 643 |     | 
 644 |     |     function _deployFraxPairDeployer() internal {
 645 |     |         ConstructorParams memory _params = ConstructorParams(
 646 |     |             circuitBreaker,
 647 |     |             comptroller,
 648 |     |             timelock,
 649 |     |             address(_fraxWhitelist),
 650 |     |             address(_fraxRegistry)
 651 |     |         );
 652 |     |         _fraxDeployer = new FraxlendPairDeployer(
 653 |     |             _params
 654 |     |         );
 655 |     | 
 656 |     |         _fraxDeployer.setCreationCode(type(FraxlendPair).creationCode);
 657 |     | 
 658 |     |         address[] memory _whitelistDeployer = new address[](1);
 659 |     |         _whitelistDeployer[0] = address(this);
 660 |     | 
 661 |     |         _fraxWhitelist.setFraxlendDeployerWhitelist(
 662 |     |             _whitelistDeployer,
 663 |     |             true
 664 |     |         );
 665 |     | 
 666 |     |         address[] memory _registryDeployer = new address[](1);
 667 |     |         _registryDeployer[0] = address(_fraxDeployer);
 668 |     | 
 669 |     |         _fraxRegistry.setDeployers(
 670 |     |             _registryDeployer,
 671 |     |             true
 672 |     |         );
 673 |     |     }
 674 |     | 
 675 |     |     function _deployFraxPairs() internal {
 676 |     | 
 677 |     |         // moving time to help out the twap
 678 |     |         vm.warp(block.timestamp + 1 days);
 679 |     | 
 680 |     |         _fraxLPToken1 = FraxlendPair(
 681 |     |             _fraxDeployer.deploy(
 682 |     |                 abi.encode(
 683 |     |                     address(_pod1),
 684 |     |                     _aspTKN1Address, 
 685 |     |                     address(_aspTKNMinOracle1), 
 686 |     |                     5000, 
 687 |     |                     address(_variableInterestRate), 
 688 |     |                     1000, 
 689 |     |                     75000, 
 690 |     |                     10000, 
 691 |     |                     9000, 
 692 |     |                     2000
 693 |     |                 )
 694 |     |             )
 695 |     |         );
 696 |     | 
 697 |     |         // add to array for fuzzing
 698 |     |         _fraxPairs.push(_fraxLPToken1);
 699 |     | 
 700 |     |         _fraxLPToken2 = FraxlendPair(
 701 |     |             _fraxDeployer.deploy(
 702 |     |                 abi.encode(
 703 |     |                     address(_pod2),
 704 |     |                     _aspTKN2Address, 
 705 |     |                     address(_aspTKNMinOracle2), 
 706 |     |                     5000, 
 707 |     |                     address(_variableInterestRate), 
 708 |     |                     1000, 
 709 |     |                     75000, 
 710 |     |                     10000, 
 711 |     |                     9000, 
 712 |     |                     2000
 713 |     |                 )
 714 |     |             )
 715 |     |         );
 716 |     | 
 717 |     |         // add to array for fuzzing
 718 |     |         _fraxPairs.push(_fraxLPToken2);
 719 |     | 
 720 |     |         _fraxLPToken4 = FraxlendPair(
 721 |     |             _fraxDeployer.deploy(
 722 |     |                 abi.encode(
 723 |     |                     address(_pod4),
 724 |     |                     _aspTKN4Address, 
 725 |     |                     address(_aspTKNMinOracle4), 
 726 |     |                     5000, 
 727 |     |                     address(_variableInterestRate), 
 728 |     |                     1000, 
 729 |     |                     75000, 
 730 |     |                     10000, 
 731 |     |                     9000, 
 732 |     |                     2000
 733 |     |                 )
 734 |     |             )
 735 |     |         );
 736 |     | 
 737 |     |         // add to array for fuzzing
 738 |     |         _fraxPairs.push(_fraxLPToken4);
 739 |     |     }
 740 |     | 
 741 |     |     function _deployLendingAssetVault() internal {
 742 |     |         _lendingAssetVault = new LendingAssetVault(
 743 |     |             "Test LAV",
 744 |     |             "tLAV",
 745 |     |             address(_mockDai)
 746 |     |         );
 747 |     | 
 748 |     |         IERC20 vaultAsset1 = IERC20(_fraxLPToken1.asset());
 749 |     |         vaultAsset1.approve(address(_fraxLPToken1), vaultAsset1.totalSupply());
 750 |     |         vaultAsset1.approve(address(_lendingAssetVault), vaultAsset1.totalSupply());
 751 |     |         _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken1), true);
 752 |     |         _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken1), 5000);
 753 |     | 
 754 |     |         IERC20 vaultAsset2 = IERC20(_fraxLPToken2.asset());
 755 |     |         vaultAsset2.approve(address(_fraxLPToken2), vaultAsset2.totalSupply());
 756 |     |         vaultAsset2.approve(address(_lendingAssetVault), vaultAsset2.totalSupply());
 757 |     |         _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken2), true);
 758 |     |         _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken2), 2500);
 759 |     | 
 760 |     |         IERC20 vaultAsset4 = IERC20(_fraxLPToken4.asset());
 761 |     |         vaultAsset4.approve(address(_fraxLPToken4), vaultAsset4.totalSupply());
 762 |     |         vaultAsset4.approve(address(_lendingAssetVault), vaultAsset4.totalSupply());
 763 |     |         _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken4), true);
 764 |     |         _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken4), 2500);
 765 |     |     }
 766 |     | 
 767 |     |     function _deployLeverageManager() internal {
 768 |     |         _leverageManager = new LeverageManager(
 769 |     |             "Test LM",
 770 |     |             "tLM",
 771 |     |             IIndexUtils_LEGACY(address(_indexUtils))
 772 |     |         );
 773 |     |     }
 774 |     | 
 775 |     |     /*////////////////////////////////////////////////////////////////
 776 |     |                                     HELPERS
 777 |     |     ////////////////////////////////////////////////////////////////*/
 778 |     | 
 779 |     |     function _setupActors() internal {
 780 |     |         for (uint256 i; i < users.length; i++) {
 781 |     |             vm.deal(users[i], 100000 ether);
 782 |     |             vm.prank(users[i]);
 783 |     |             _weth.deposit{value: 100000 ether}();
 784 |     | 
 785 |     |             _tokenA.mint(users[i], 100000 ether);
 786 |     |             _tokenB.mint(users[i], 100000e6);
 787 |     |             _tokenC.mint(users[i], 100000 ether);
 788 |     |             _mockDai.mint(users[i], 100000 ether);
 789 |     | 
 790 |     |             _peas.transfer(users[i], 100000 ether);
 791 |     |         }
 792 |     |     }
 793 |     | 
 794 | *   |     function randomAddress(uint256 seed) internal view returns (address) {
 795 | *   |         return users[bound(seed, 0, users.length - 1)];
 796 |     |     }
 797 |     | 
 798 | *   |     function randomPod(uint256 seed) internal returns (WeightedIndex) {
 799 | *   |         fl.log("POD 1", address(_pods[bound(seed, 0, _pods.length - 1)]));
 800 | *   |         return _pods[bound(seed, 0, _pods.length - 1)];
 801 |     |     }
 802 |     | 
 803 | *   |     function randomIndexToken(WeightedIndex pod, uint256 seed) internal view returns (address) {
 804 | *   |         IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();
 805 | *   |         return indexTokens[bound(seed, 0, indexTokens.length - 1)].token;
 806 |     |     }
 807 |     | 
 808 |     |     function randomAspTKN(uint256 seed) internal view returns (AutoCompoundingPodLp) {
 809 |     |         return _aspTKNs[bound(seed, 0, _aspTKNs.length - 1)];
 810 |     |     }
 811 |     | 
 812 |     |     function randomFraxPair(uint256 seed) internal view returns (FraxlendPair) {
 813 |     |         return _fraxPairs[bound(seed, 0, _fraxPairs.length - 1)];
 814 |     |     }
 815 |     | 
 816 | *   |     function _approveIndexTokens(WeightedIndex pod, address user, uint256 amount) internal {
 817 | *   |         IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();
 818 |     | 
 819 | *   |         for (uint256 i; i < indexTokens.length; i++) {
 820 | *   |             vm.prank(user);
 821 | *   |             MockERC20(indexTokens[i].token).approve(address(pod), type(uint256).max);
 822 |     |         }
 823 |     |     }
 824 |     | 
 825 | *   |     function _checkTokenBalances(WeightedIndex pod, address token, address user, uint256 amount) internal returns (bool hasEnough) {
 826 | *   |         IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();
 827 |     | 
 828 | *   |         hasEnough = true;
 829 | *   |         for (uint256 i; i < indexTokens.length; i++) {
 830 | *   |             uint256 amountNeeded = pod.getInitialAmount(
 831 | *   |                 token,
 832 | *   |                 amount,
 833 | *   |                 indexTokens[i].token
 834 |     |             );
 835 |     | 
 836 | *   |             if (amountNeeded > IERC20(indexTokens[i].token).balanceOf(user)) {
 837 | *   |                 hasEnough = false;
 838 | *   |                 break;
 839 |     |             }
 840 |     |         }
 841 |     |     }
 842 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/PeapodsInvariant.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {PodHandler} from "./handlers/PodHandler.sol";
  5 |     | 
  6 | *r  | contract PeapodsInvariant is PodHandler {
  7 |     |     constructor() payable {
  8 |     |         setup();
  9 |     |     }
 10 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/handlers/PodHandler.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import {Properties} from "../helpers/Properties.sol";
  5 |     | 
  6 |     | import {WeightedIndex} from "../../../contracts/WeightedIndex.sol";
  7 |     | 
  8 |     | import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  9 |     | 
 10 | *r  | contract PodHandler is Properties {
 11 |     | 
 12 |     |     struct BondTemps {
 13 |     |         address user;
 14 |     |         WeightedIndex pod;
 15 |     |         address token;
 16 |     |     }
 17 | *   |     function pod_bond(uint256 userIndexSeed, uint256 podIndexSeed, uint256 indexTokenSeed, uint256 amount) public {
 18 |     |         
 19 |     |         // PRE-CONDITIONS
 20 |     |         BondTemps memory cache;
 21 | *   |         cache.user = randomAddress(userIndexSeed);
 22 | *   |         cache.pod = randomPod(podIndexSeed);
 23 | *   |         cache.token = randomIndexToken(cache.pod, indexTokenSeed);
 24 |     | 
 25 | *   |         amount = fl.clamp(amount, 0, IERC20(cache.token).balanceOf(cache.user));
 26 |     | 
 27 | *   |         _approveIndexTokens(cache.pod, cache.user, amount);
 28 | *   |         if (!_checkTokenBalances(cache.pod, cache.token, cache.user, amount)) return;
 29 |     | 
 30 |     |         // ACTION
 31 | *   |         vm.prank(cache.user);
 32 | *   |         try cache.pod.bond(
 33 | *   |             cache.token,
 34 |     |             amount,
 35 | *   |             0
 36 |     |         ) {} catch {
 37 |     |             fl.t(false, "BOND FAILED");
 38 |     |         }
 39 |     |     }
 40 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/helpers/BeforeAfter.sol
 1 |     | // SPDX-License-Identifier: UNLICENSED
 2 |     | pragma solidity ^0.8.19;
 3 |     | 
 4 |     | import {FuzzSetup} from "../FuzzSetup.sol";
 5 |     | 
 6 |     | contract BeforeAfter is FuzzSetup {}

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/helpers/Properties.sol
 1 |     | // SPDX-License-Identifier: UNLICENSED
 2 |     | pragma solidity ^0.8.19;
 3 |     | 
 4 |     | import {BeforeAfter} from "./BeforeAfter.sol";
 5 |     | 
 6 |     | contract Properties is BeforeAfter {}

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockERC20.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.6.2 <0.9.0;
   3 |     | 
   4 |     | import {IERC20} from "./interfaces/IERC20.sol";
   5 |     | 
   6 |     | /// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.
   7 |     | /// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol
   8 | *   | contract MockERC20 is IERC20 {
   9 |     |     /*//////////////////////////////////////////////////////////////
  10 |     |                             METADATA STORAGE
  11 |     |     //////////////////////////////////////////////////////////////*/
  12 |     | 
  13 |     |     string internal _name;
  14 |     | 
  15 |     |     string internal _symbol;
  16 |     | 
  17 |     |     uint8 internal _decimals;
  18 |     | 
  19 | *   |     function name() external view override returns (string memory) {
  20 |     |         return _name;
  21 |     |     }
  22 |     | 
  23 |     |     function symbol() external view override returns (string memory) {
  24 |     |         return _symbol;
  25 |     |     }
  26 |     | 
  27 | *   |     function decimals() external view override returns (uint8) {
  28 | *   |         return _decimals;
  29 |     |     }
  30 |     | 
  31 |     |     /*//////////////////////////////////////////////////////////////
  32 |     |                               ERC20 STORAGE
  33 |     |     //////////////////////////////////////////////////////////////*/
  34 |     | 
  35 |     |     uint256 internal _totalSupply;
  36 |     | 
  37 |     |     mapping(address => uint256) internal _balanceOf;
  38 |     | 
  39 |     |     mapping(address => mapping(address => uint256)) internal _allowance;
  40 |     | 
  41 | *   |     function totalSupply() external view override returns (uint256) {
  42 |     |         return _totalSupply;
  43 |     |     }
  44 |     | 
  45 | *   |     function balanceOf(address owner) external view override returns (uint256) {
  46 | *   |         return _balanceOf[owner];
  47 |     |     }
  48 |     | 
  49 |     |     function allowance(address owner, address spender) external view override returns (uint256) {
  50 |     |         return _allowance[owner][spender];
  51 |     |     }
  52 |     | 
  53 |     |     /*//////////////////////////////////////////////////////////////
  54 |     |                             EIP-2612 STORAGE
  55 |     |     //////////////////////////////////////////////////////////////*/
  56 |     | 
  57 |     |     uint256 internal INITIAL_CHAIN_ID;
  58 |     | 
  59 |     |     bytes32 internal INITIAL_DOMAIN_SEPARATOR;
  60 |     | 
  61 |     |     mapping(address => uint256) public nonces;
  62 |     | 
  63 |     |     /*//////////////////////////////////////////////////////////////
  64 |     |                                INITIALIZE
  65 |     |     //////////////////////////////////////////////////////////////*/
  66 |     | 
  67 |     |     /// @dev A bool to track whether the contract has been initialized.
  68 |     |     bool private initialized;
  69 |     | 
  70 |     |     /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and
  71 |     |     /// syntaxes, we add an initialization function that can be called only once.
  72 |     |     function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {
  73 |     |         require(!initialized, "ALREADY_INITIALIZED");
  74 |     | 
  75 |     |         _name = name_;
  76 |     |         _symbol = symbol_;
  77 |     |         _decimals = decimals_;
  78 |     | 
  79 |     |         INITIAL_CHAIN_ID = _pureChainId();
  80 |     |         INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();
  81 |     | 
  82 |     |         initialized = true;
  83 |     |     }
  84 |     | 
  85 |     |     /*//////////////////////////////////////////////////////////////
  86 |     |                                ERC20 LOGIC
  87 |     |     //////////////////////////////////////////////////////////////*/
  88 |     | 
  89 | *   |     function approve(address spender, uint256 amount) public virtual override returns (bool) {
  90 | *   |         _allowance[msg.sender][spender] = amount;
  91 |     | 
  92 | *   |         emit Approval(msg.sender, spender, amount);
  93 |     | 
  94 | *   |         return true;
  95 |     |     }
  96 |     | 
  97 |     |     function transfer(address to, uint256 amount) public virtual override returns (bool) {
  98 |     |         _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);
  99 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 100 |     | 
 101 |     |         emit Transfer(msg.sender, to, amount);
 102 |     | 
 103 |     |         return true;
 104 |     |     }
 105 |     | 
 106 | *   |     function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {
 107 | *   |         uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.
 108 |     | 
 109 | *   |         if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);
 110 |     | 
 111 | *   |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 112 | *   |         _balanceOf[to] = _add(_balanceOf[to], amount);
 113 |     | 
 114 | *   |         emit Transfer(from, to, amount);
 115 |     | 
 116 | *   |         return true;
 117 |     |     }
 118 |     | 
 119 |     |     event Message(string a);
 120 |     | 
 121 |     |     function mint(address to, uint256 value) public {
 122 |     |         emit Message("HERE");
 123 |     |         _mint(to, value);
 124 |     |     }
 125 |     | 
 126 |     |     function burn(address from, uint256 value) public virtual {
 127 |     |         _burn(from, value);
 128 |     |     }
 129 |     | 
 130 |     |     /*//////////////////////////////////////////////////////////////
 131 |     |                              EIP-2612 LOGIC
 132 |     |     //////////////////////////////////////////////////////////////*/
 133 |     | 
 134 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 135 |     |         public
 136 |     |         virtual
 137 |     |     {
 138 |     |         require(deadline >= block.timestamp, "PERMIT_DEADLINE_EXPIRED");
 139 |     | 
 140 |     |         address recoveredAddress = ecrecover(
 141 |     |             keccak256(
 142 |     |                 abi.encodePacked(
 143 |     |                     "\x19\x01",
 144 |     |                     DOMAIN_SEPARATOR(),
 145 |     |                     keccak256(
 146 |     |                         abi.encode(
 147 |     |                             keccak256(
 148 |     |                                 "Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)"
 149 |     |                             ),
 150 |     |                             owner,
 151 |     |                             spender,
 152 |     |                             value,
 153 |     |                             nonces[owner]++,
 154 |     |                             deadline
 155 |     |                         )
 156 |     |                     )
 157 |     |                 )
 158 |     |             ),
 159 |     |             v,
 160 |     |             r,
 161 |     |             s
 162 |     |         );
 163 |     | 
 164 |     |         require(recoveredAddress != address(0) && recoveredAddress == owner, "INVALID_SIGNER");
 165 |     | 
 166 |     |         _allowance[recoveredAddress][spender] = value;
 167 |     | 
 168 |     |         emit Approval(owner, spender, value);
 169 |     |     }
 170 |     | 
 171 |     |     function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {
 172 |     |         return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();
 173 |     |     }
 174 |     | 
 175 |     |     function computeDomainSeparator() internal view virtual returns (bytes32) {
 176 |     |         return keccak256(
 177 |     |             abi.encode(
 178 |     |                 keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 179 |     |                 keccak256(bytes(_name)),
 180 |     |                 keccak256("1"),
 181 |     |                 _pureChainId(),
 182 |     |                 address(this)
 183 |     |             )
 184 |     |         );
 185 |     |     }
 186 |     | 
 187 |     |     /*//////////////////////////////////////////////////////////////
 188 |     |                         INTERNAL MINT/BURN LOGIC
 189 |     |     //////////////////////////////////////////////////////////////*/
 190 |     | 
 191 |     |     function _mint(address to, uint256 amount) internal virtual {
 192 |     |         _totalSupply = _add(_totalSupply, amount);
 193 |     |         _balanceOf[to] = _add(_balanceOf[to], amount);
 194 |     | 
 195 |     |         emit Transfer(address(0), to, amount);
 196 |     |     }
 197 |     | 
 198 |     |     function _burn(address from, uint256 amount) internal virtual {
 199 |     |         _balanceOf[from] = _sub(_balanceOf[from], amount);
 200 |     |         _totalSupply = _sub(_totalSupply, amount);
 201 |     | 
 202 |     |         emit Transfer(from, address(0), amount);
 203 |     |     }
 204 |     | 
 205 |     |     /*//////////////////////////////////////////////////////////////
 206 |     |                         INTERNAL SAFE MATH LOGIC
 207 |     |     //////////////////////////////////////////////////////////////*/
 208 |     | 
 209 | *   |     function _add(uint256 a, uint256 b) internal pure returns (uint256) {
 210 | *   |         uint256 c = a + b;
 211 | *   |         require(c >= a, "ERC20: addition overflow");
 212 |     |         return c;
 213 |     |     }
 214 |     | 
 215 | *   |     function _sub(uint256 a, uint256 b) internal pure returns (uint256) {
 216 | *   |         require(a >= b, "ERC20: subtraction underflow");
 217 | *   |         return a - b;
 218 |     |     }
 219 |     | 
 220 |     |     /*//////////////////////////////////////////////////////////////
 221 |     |                                 HELPERS
 222 |     |     //////////////////////////////////////////////////////////////*/
 223 |     | 
 224 |     |     // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no
 225 |     |     // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We
 226 |     |     // can't simply access the chain ID in a normal view or pure function because the solc View Pure
 227 |     |     // Checker changed `chainid` from pure to view in 0.8.0.
 228 |     |     function _viewChainId() private view returns (uint256 chainId) {
 229 |     |         // Assembly required since `block.chainid` was introduced in 0.8.0.
 230 |     |         assembly {
 231 |     |             chainId := chainid()
 232 |     |         }
 233 |     | 
 234 |     |         address(this); // Silence warnings in older Solc versions.
 235 |     |     }
 236 |     | 
 237 |     |     function _pureChainId() private pure returns (uint256 chainId) {
 238 |     |         function() internal view returns (uint256) fnIn = _viewChainId;
 239 |     |         function() internal pure returns (uint256) pureChainId;
 240 |     |         assembly {
 241 |     |             pureChainId := fnIn
 242 |     |         }
 243 |     |         chainId = pureChainId();
 244 |     |     }
 245 |     | }
 246 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockIndexUtils.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   5 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   6 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   7 |     | import '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';
   8 |     | import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
   9 |     | import '../../../contracts/interfaces/IDecentralizedIndex.sol';
  10 |     | import '../../../contracts/interfaces/IDexAdapter.sol';
  11 |     | import '../../../contracts/interfaces/IIndexUtils.sol';
  12 |     | import '../../../contracts/interfaces/IStakingPoolToken.sol';
  13 |     | import '../../../contracts/interfaces/ITokenRewards.sol';
  14 |     | import '../../../contracts/interfaces/IUniswapV2Factory.sol';
  15 |     | import '../../../contracts/interfaces/IUniswapV3Pool.sol';
  16 |     | import '../../../contracts/interfaces/IUniswapV2Router02.sol';
  17 |     | import '../../../contracts/interfaces/IWETH.sol';
  18 |     | import './MockZapper.sol';
  19 |     | 
  20 |     | contract MockIndexUtils is Context, IIndexUtils, MockZapper {
  21 |     |   using SafeERC20 for IERC20;
  22 |     | 
  23 |     |   constructor(
  24 |     |     IV3TwapUtilities _v3TwapUtilities,
  25 |     |     IDexAdapter _dexAdapter,
  26 |     |     address _V3_ROUTER
  27 |     |   ) MockZapper(_v3TwapUtilities, _dexAdapter, _V3_ROUTER) {}
  28 |     | 
  29 |     |   function bond(
  30 |     |     IDecentralizedIndex _indexFund,
  31 |     |     address _token,
  32 |     |     uint256 _amount,
  33 |     |     uint256 _amountMintMin
  34 |     |   ) external {
  35 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund
  36 |     |       .getAllAssets();
  37 |     |     uint256[] memory _balsBefore = new uint256[](_assets.length);
  38 |     | 
  39 |     |     uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(_indexFund));
  40 |     |     uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0
  41 |     |       ? FixedPoint96.Q96
  42 |     |       : (_amount * FixedPoint96.Q96) / _tokenCurSupply;
  43 |     |     uint256 _al = _assets.length;
  44 |     |     for (uint256 _i; _i < _al; _i++) {
  45 |     |       uint256 _amountNeeded = _indexFund.totalSupply() == 0
  46 |     |         ? _indexFund.getInitialAmount(_token, _amount, _assets[_i].token)
  47 |     |         : (IERC20(_assets[_i].token).balanceOf(address(_indexFund)) *
  48 |     |           _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;
  49 |     |       _balsBefore[_i] = IERC20(_assets[_i].token).balanceOf(address(this));
  50 |     |       IERC20(_assets[_i].token).safeTransferFrom(
  51 |     |         _msgSender(),
  52 |     |         address(this),
  53 |     |         _amountNeeded
  54 |     |       );
  55 |     |       IERC20(_assets[_i].token).safeIncreaseAllowance(
  56 |     |         address(_indexFund),
  57 |     |         _amountNeeded
  58 |     |       );
  59 |     |     }
  60 |     |     uint256 _idxBalBefore = IERC20(_indexFund).balanceOf(address(this));
  61 |     |     _indexFund.bond(_token, _amount, _amountMintMin);
  62 |     |     IERC20(_indexFund).safeTransfer(
  63 |     |       _msgSender(),
  64 |     |       IERC20(_indexFund).balanceOf(address(this)) - _idxBalBefore
  65 |     |     );
  66 |     | 
  67 |     |     // refund any excess tokens to user we didn't use to bond
  68 |     |     for (uint256 _i; _i < _al; _i++) {
  69 |     |       _checkAndRefundERC20(_msgSender(), _assets[_i].token, _balsBefore[_i]);
  70 |     |     }
  71 |     |   }
  72 |     | 
  73 |     |   function bondWeightedFromNative(
  74 |     |     IDecentralizedIndex _indexFund,
  75 |     |     uint256 _assetIdx,
  76 |     |     uint256 _amountTokensForAssetIdx,
  77 |     |     uint256 _amountMintMin,
  78 |     |     uint256 _amountPairedLpTokenMin,
  79 |     |     uint256 _slippage, // 1 == 0.1%, 10 == 1%, 1000 == 100%
  80 |     |     uint256 _deadline,
  81 |     |     bool _stakeAsWell
  82 |     |   ) external payable {
  83 |     |     require(msg.value > 0, 'NATIVE');
  84 |     |     uint256 _ethBalBefore = address(this).balance - msg.value;
  85 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund
  86 |     |       .getAllAssets();
  87 |     |     (
  88 |     |       uint256[] memory _balancesBefore,
  89 |     |       uint256[] memory _amountsReceived
  90 |     |     ) = _swapNativeForTokensWeightedV2(
  91 |     |         _indexFund,
  92 |     |         _stakeAsWell ? msg.value / 2 : msg.value,
  93 |     |         _assets,
  94 |     |         _assetIdx,
  95 |     |         _amountTokensForAssetIdx
  96 |     |       );
  97 |     | 
  98 |     |     // allowance for _assetIdx is increased in _bondToRecipient below,
  99 |     |     // we just need to increase allowance for any other index tokens here first
 100 |     |     for (uint256 _i; _i < _assets.length; _i++) {
 101 |     |       if (_i == _assetIdx) {
 102 |     |         continue;
 103 |     |       }
 104 |     |       IERC20(_assets[_i].token).safeIncreaseAllowance(
 105 |     |         address(_indexFund),
 106 |     |         _amountsReceived[_i]
 107 |     |       );
 108 |     |     }
 109 |     |     uint256 _idxTokensGained = _bondToRecipient(
 110 |     |       _indexFund,
 111 |     |       _assets[_assetIdx].token,
 112 |     |       _amountsReceived[_assetIdx],
 113 |     |       _amountMintMin,
 114 |     |       _stakeAsWell ? address(this) : _msgSender()
 115 |     |     );
 116 |     | 
 117 |     |     if (_stakeAsWell) {
 118 |     |       _zapIndexTokensAndNative(
 119 |     |         _msgSender(),
 120 |     |         _indexFund,
 121 |     |         _idxTokensGained,
 122 |     |         msg.value / 2,
 123 |     |         _amountPairedLpTokenMin,
 124 |     |         _slippage,
 125 |     |         _deadline
 126 |     |       );
 127 |     |     }
 128 |     | 
 129 |     |     // refund any excess tokens to user we didn't use to bond
 130 |     |     for (uint256 _i; _i < _assets.length; _i++) {
 131 |     |       _checkAndRefundERC20(
 132 |     |         _msgSender(),
 133 |     |         _assets[_i].token,
 134 |     |         _balancesBefore[_i]
 135 |     |       );
 136 |     |     }
 137 |     | 
 138 |     |     // refund excess ETH
 139 |     |     if (address(this).balance > _ethBalBefore) {
 140 |     |       (bool _s, ) = payable(_msgSender()).call{
 141 |     |         value: address(this).balance - _ethBalBefore
 142 |     |       }('');
 143 |     |       require(_s, 'ETHREFUND');
 144 |     |     }
 145 |     |   }
 146 |     | 
 147 |     |   function addLPAndStake(
 148 |     |     IDecentralizedIndex _indexFund,
 149 |     |     uint256 _amountIdxTokens,
 150 |     |     address _pairedLpTokenProvided,
 151 |     |     uint256 _amtPairedLpTokenProvided,
 152 |     |     uint256 _amountPairedLpTokenMin,
 153 |     |     uint256 _slippage,
 154 |     |     uint256 _deadline
 155 |     |   ) external payable override returns (uint256 _amountOut) {
 156 |     |     address _indexFundAddy = address(_indexFund);
 157 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 158 |     |     uint256 _idxTokensBefore = IERC20(_indexFundAddy).balanceOf(address(this));
 159 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 160 |     |       address(this)
 161 |     |     );
 162 |     |     uint256 _ethBefore = address(this).balance - msg.value;
 163 |     |     IERC20(_indexFundAddy).safeTransferFrom(
 164 |     |       _msgSender(),
 165 |     |       address(this),
 166 |     |       _amountIdxTokens
 167 |     |     );
 168 |     |     if (_pairedLpTokenProvided == address(0)) {
 169 |     |       require(msg.value > 0, 'NEEDETH');
 170 |     |       _amtPairedLpTokenProvided = msg.value;
 171 |     |     } else {
 172 |     |       IERC20(_pairedLpTokenProvided).safeTransferFrom(
 173 |     |         _msgSender(),
 174 |     |         address(this),
 175 |     |         _amtPairedLpTokenProvided
 176 |     |       );
 177 |     |     }
 178 |     |     if (_pairedLpTokenProvided != _pairedLpToken) {
 179 |     |       _zap(
 180 |     |         _pairedLpTokenProvided,
 181 |     |         _pairedLpToken,
 182 |     |         _amtPairedLpTokenProvided,
 183 |     |         _amountPairedLpTokenMin
 184 |     |       );
 185 |     |     }
 186 |     | 
 187 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(
 188 |     |       _indexFundAddy,
 189 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 190 |     |     );
 191 |     |     _amountOut = _indexFund.addLiquidityV2(
 192 |     |       IERC20(_indexFundAddy).balanceOf(address(this)) - _idxTokensBefore,
 193 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,
 194 |     |       _slippage,
 195 |     |       _deadline
 196 |     |     );
 197 |     | 
 198 |     |     IERC20(DEX_ADAPTER.getV2Pool(_indexFundAddy, _pairedLpToken))
 199 |     |       .safeIncreaseAllowance(_indexFund.lpStakingPool(), _amountOut);
 200 |     |     IStakingPoolToken(_indexFund.lpStakingPool()).stake(
 201 |     |       _msgSender(),
 202 |     |       _amountOut
 203 |     |     );
 204 |     | 
 205 |     |     // refunds if needed for index tokens and pairedLpToken
 206 |     |     if (address(this).balance > _ethBefore) {
 207 |     |       (bool _s, ) = payable(_msgSender()).call{
 208 |     |         value: address(this).balance - _ethBefore
 209 |     |       }('');
 210 |     |       require(_s && address(this).balance >= _ethBefore, 'TOOMUCH');
 211 |     |     }
 212 |     |     _checkAndRefundERC20(_msgSender(), _indexFundAddy, _idxTokensBefore);
 213 |     |     _checkAndRefundERC20(_msgSender(), _pairedLpToken, _pairedLpTokenBefore);
 214 |     |   }
 215 |     | 
 216 |     |   function unstakeAndRemoveLP(
 217 |     |     IDecentralizedIndex _indexFund,
 218 |     |     uint256 _amountStakedTokens,
 219 |     |     uint256 _minLPTokens,
 220 |     |     uint256 _minPairedLpToken,
 221 |     |     uint256 _deadline
 222 |     |   ) external override {
 223 |     |     address _stakingPool = _indexFund.lpStakingPool();
 224 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 225 |     |     uint256 _stakingBalBefore = IERC20(_stakingPool).balanceOf(address(this));
 226 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 227 |     |       address(this)
 228 |     |     );
 229 |     |     IERC20(_stakingPool).safeTransferFrom(
 230 |     |       _msgSender(),
 231 |     |       address(this),
 232 |     |       _amountStakedTokens
 233 |     |     );
 234 |     |     uint256 _indexBalBefore = _unstakeAndRemoveLP(
 235 |     |       _indexFund,
 236 |     |       _stakingPool,
 237 |     |       IERC20(_stakingPool).balanceOf(address(this)) - _stakingBalBefore,
 238 |     |       _minLPTokens,
 239 |     |       _minPairedLpToken,
 240 |     |       _deadline
 241 |     |     );
 242 |     |     if (
 243 |     |       IERC20(address(_indexFund)).balanceOf(address(this)) > _indexBalBefore
 244 |     |     ) {
 245 |     |       IERC20(address(_indexFund)).safeTransfer(
 246 |     |         _msgSender(),
 247 |     |         IERC20(address(_indexFund)).balanceOf(address(this)) - _indexBalBefore
 248 |     |       );
 249 |     |     }
 250 |     |     if (
 251 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) > _pairedLpTokenBefore
 252 |     |     ) {
 253 |     |       IERC20(_pairedLpToken).safeTransfer(
 254 |     |         _msgSender(),
 255 |     |         IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 256 |     |       );
 257 |     |     }
 258 |     |   }
 259 |     | 
 260 |     |   function claimRewardsMulti(address[] memory _rewards) external {
 261 |     |     uint256 _rl = _rewards.length;
 262 |     |     for (uint256 _i; _i < _rl; _i++) {
 263 |     |       ITokenRewards(_rewards[_i]).claimReward(_msgSender());
 264 |     |     }
 265 |     |   }
 266 |     | 
 267 |     |   function _swapNativeForTokensWeightedV2(
 268 |     |     IDecentralizedIndex _indexFund,
 269 |     |     uint256 _amountNative,
 270 |     |     IDecentralizedIndex.IndexAssetInfo[] memory _assets,
 271 |     |     uint256 _poolIdx,
 272 |     |     uint256 _amountForPoolIdx
 273 |     |   ) internal returns (uint256[] memory, uint256[] memory) {
 274 |     |     uint256[] memory _amountBefore = new uint256[](_assets.length);
 275 |     |     uint256[] memory _amountReceived = new uint256[](_assets.length);
 276 |     |     uint256 _tokenCurSupply = IERC20(_assets[_poolIdx].token).balanceOf(
 277 |     |       address(_indexFund)
 278 |     |     );
 279 |     |     uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0
 280 |     |       ? FixedPoint96.Q96
 281 |     |       : (_amountForPoolIdx * FixedPoint96.Q96) / _tokenCurSupply;
 282 |     |     uint256 _nativeLeft = _amountNative;
 283 |     |     uint256 _al = _assets.length;
 284 |     |     for (uint256 _i; _i < _al; _i++) {
 285 |     |       (_nativeLeft, _amountBefore[_i], _amountReceived[_i]) = _swapForIdxToken(
 286 |     |         _indexFund,
 287 |     |         _assets[_poolIdx].token,
 288 |     |         _amountForPoolIdx,
 289 |     |         _assets[_i].token,
 290 |     |         _tokenAmtSupplyRatioX96,
 291 |     |         _nativeLeft
 292 |     |       );
 293 |     |     }
 294 |     |     return (_amountBefore, _amountReceived);
 295 |     |   }
 296 |     | 
 297 |     |   function _swapForIdxToken(
 298 |     |     IDecentralizedIndex _indexFund,
 299 |     |     address _initToken,
 300 |     |     uint256 _initTokenAmount,
 301 |     |     address _outToken,
 302 |     |     uint256 _tokenAmtSupplyRatioX96,
 303 |     |     uint256 _nativeLeft
 304 |     |   )
 305 |     |     internal
 306 |     |     returns (
 307 |     |       uint256 _newNativeLeft,
 308 |     |       uint256 _amountBefore,
 309 |     |       uint256 _amountReceived
 310 |     |     )
 311 |     |   {
 312 |     |     address _weth = DEX_ADAPTER.WETH();
 313 |     |     if (address(this).balance > 0) {
 314 |     |       IWETH(WETH).deposit{ value: address(this).balance }();
 315 |     |     }
 316 |     |     uint256 _nativeBefore = IERC20(_weth).balanceOf(address(this));
 317 |     |     _amountBefore = IERC20(_outToken).balanceOf(address(this));
 318 |     |     uint256 _amountOut = _indexFund.totalSupply() == 0
 319 |     |       ? _indexFund.getInitialAmount(_initToken, _initTokenAmount, _outToken)
 320 |     |       : (IERC20(_outToken).balanceOf(address(_indexFund)) *
 321 |     |         _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;
 322 |     |     DEX_ADAPTER.swapV2Single(
 323 |     |       _weth,
 324 |     |       _outToken,
 325 |     |       _nativeLeft,
 326 |     |       _amountOut,
 327 |     |       address(this)
 328 |     |     );
 329 |     |     _newNativeLeft =
 330 |     |       _nativeLeft -
 331 |     |       (_nativeBefore - IERC20(_weth).balanceOf(address(this)));
 332 |     |     _amountReceived =
 333 |     |       IERC20(_outToken).balanceOf(address(this)) -
 334 |     |       _amountBefore;
 335 |     |   }
 336 |     | 
 337 |     |   function _unstakeAndRemoveLP(
 338 |     |     IDecentralizedIndex _indexFund,
 339 |     |     address _stakingPool,
 340 |     |     uint256 _unstakeAmount,
 341 |     |     uint256 _minLPTokens,
 342 |     |     uint256 _minPairedLpTokens,
 343 |     |     uint256 _deadline
 344 |     |   ) internal returns (uint256 _fundTokensBefore) {
 345 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 346 |     |     address _v2Pool = DEX_ADAPTER.getV2Pool(
 347 |     |       address(_indexFund),
 348 |     |       _pairedLpToken
 349 |     |     );
 350 |     |     uint256 _v2TokensBefore = IERC20(_v2Pool).balanceOf(address(this));
 351 |     |     IStakingPoolToken(_stakingPool).unstake(_unstakeAmount);
 352 |     | 
 353 |     |     _fundTokensBefore = _indexFund.balanceOf(address(this));
 354 |     |     IERC20(_v2Pool).safeIncreaseAllowance(
 355 |     |       address(_indexFund),
 356 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore
 357 |     |     );
 358 |     |     _indexFund.removeLiquidityV2(
 359 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore,
 360 |     |       _minLPTokens,
 361 |     |       _minPairedLpTokens,
 362 |     |       _deadline
 363 |     |     );
 364 |     |   }
 365 |     | 
 366 |     |   function _bondToRecipient(
 367 |     |     IDecentralizedIndex _indexFund,
 368 |     |     address _indexToken,
 369 |     |     uint256 _bondTokens,
 370 |     |     uint256 _amountMintMin,
 371 |     |     address _recipient
 372 |     |   ) internal returns (uint256) {
 373 |     |     uint256 _idxTokensBefore = IERC20(address(_indexFund)).balanceOf(
 374 |     |       address(this)
 375 |     |     );
 376 |     |     IERC20(_indexToken).safeIncreaseAllowance(address(_indexFund), _bondTokens);
 377 |     |     _indexFund.bond(_indexToken, _bondTokens, _amountMintMin);
 378 |     |     uint256 _idxTokensGained = IERC20(address(_indexFund)).balanceOf(
 379 |     |       address(this)
 380 |     |     ) - _idxTokensBefore;
 381 |     |     if (_recipient != address(this)) {
 382 |     |       IERC20(address(_indexFund)).safeTransfer(_recipient, _idxTokensGained);
 383 |     |     }
 384 |     |     return _idxTokensGained;
 385 |     |   }
 386 |     | 
 387 |     |   function _zapIndexTokensAndNative(
 388 |     |     address _user,
 389 |     |     IDecentralizedIndex _indexFund,
 390 |     |     uint256 _amountTokens,
 391 |     |     uint256 _amountETH,
 392 |     |     uint256 _amtPairedLpTokenMin,
 393 |     |     uint256 _slippage,
 394 |     |     uint256 _deadline
 395 |     |   ) internal {
 396 |     |     address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();
 397 |     |     uint256 _tokensBefore = IERC20(address(_indexFund)).balanceOf(
 398 |     |       address(this)
 399 |     |     ) - _amountTokens;
 400 |     |     uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(
 401 |     |       address(this)
 402 |     |     );
 403 |     |     address _stakingPool = _indexFund.lpStakingPool();
 404 |     | 
 405 |     |     _zap(address(0), _pairedLpToken, _amountETH, _amtPairedLpTokenMin);
 406 |     | 
 407 |     |     address _v2Pool = DEX_ADAPTER.getV2Pool(
 408 |     |       address(_indexFund),
 409 |     |       _pairedLpToken
 410 |     |     );
 411 |     |     uint256 _lpTokensBefore = IERC20(_v2Pool).balanceOf(address(this));
 412 |     |     IERC20(_pairedLpToken).safeIncreaseAllowance(
 413 |     |       address(_indexFund),
 414 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 415 |     |     );
 416 |     |     _indexFund.addLiquidityV2(
 417 |     |       _amountTokens,
 418 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,
 419 |     |       _slippage,
 420 |     |       _deadline
 421 |     |     );
 422 |     |     IERC20(_v2Pool).safeIncreaseAllowance(
 423 |     |       _stakingPool,
 424 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore
 425 |     |     );
 426 |     |     IStakingPoolToken(_stakingPool).stake(
 427 |     |       _user,
 428 |     |       IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore
 429 |     |     );
 430 |     | 
 431 |     |     // check & refund excess tokens from LPing as needed
 432 |     |     if (IERC20(address(_indexFund)).balanceOf(address(this)) > _tokensBefore) {
 433 |     |       IERC20(address(_indexFund)).safeTransfer(
 434 |     |         _user,
 435 |     |         IERC20(address(_indexFund)).balanceOf(address(this)) - _tokensBefore
 436 |     |       );
 437 |     |     }
 438 |     |     if (
 439 |     |       IERC20(_pairedLpToken).balanceOf(address(this)) > _pairedLpTokenBefore
 440 |     |     ) {
 441 |     |       IERC20(_pairedLpToken).safeTransfer(
 442 |     |         _user,
 443 |     |         IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore
 444 |     |       );
 445 |     |     }
 446 |     |   }
 447 |     | 
 448 |     |   function _checkAndRefundERC20(
 449 |     |     address _user,
 450 |     |     address _asset,
 451 |     |     uint256 _beforeBal
 452 |     |   ) internal {
 453 |     |     uint256 _curBal = IERC20(_asset).balanceOf(address(this));
 454 |     |     if (_curBal > _beforeBal) {
 455 |     |       IERC20(_asset).safeTransfer(_user, _curBal - _beforeBal);
 456 |     |     }
 457 |     |   }
 458 |     | }
 459 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockUniV3Minter.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | // uniswap-v3-core
  5 |     | import {UniswapV3Factory} from "v3-core/UniswapV3Factory.sol";
  6 |     | import {UniswapV3Pool} from "v3-core/UniswapV3Pool.sol";
  7 |     | import {IUniswapV3MintCallback} from "v3-core/interfaces/callback/IUniswapV3MintCallback.sol";
  8 |     | 
  9 |     | // uniswap-v3-periphery
 10 |     | import {SwapRouter} from "v3-periphery/SwapRouter.sol";
 11 |     | import {LiquidityManagement} from "v3-periphery/base/LiquidityManagement.sol";
 12 |     | import {PeripheryPayments} from "v3-periphery/base/PeripheryPayments.sol";
 13 |     | import {PoolAddress} from "v3-periphery/libraries/PoolAddress.sol";
 14 |     | 
 15 |     | 
 16 |     | // mocks
 17 |     | import {WETH9} from "./WETH.sol";
 18 |     | import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
 19 |     | import {MockERC20} from "./MockERC20.sol";
 20 |     | 
 21 |     | contract MockUniV3Minter is IUniswapV3MintCallback {
 22 |     | 
 23 |     | 
 24 |     |     constructor() {}
 25 |     |     function V3addLiquidity(UniswapV3Pool _pool, uint256 amount) public {
 26 |     |         PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({
 27 |     |             token0: _pool.token0(),
 28 |     |             token1: _pool.token1(),
 29 |     |             fee: _pool.fee()
 30 |     |         });
 31 |     |         _pool.mint(
 32 |     |             msg.sender,
 33 |     |             -887200,
 34 |     |             887200,
 35 |     |             uint128(amount),
 36 |     |             abi.encode(LiquidityManagement.MintCallbackData({
 37 |     |                 poolKey: poolKey,
 38 |     |                 payer: address(this)
 39 |     |                 })
 40 |     |             )
 41 |     |         );
 42 |     |     }
 43 |     | 
 44 |     |     event MessageUint(string a, uint256 b);
 45 |     |     event MessageAddress(string a, address b);
 46 |     | 
 47 |     |     function uniswapV3MintCallback(
 48 |     |         uint256 amount0Owed,
 49 |     |         uint256 amount1Owed,
 50 |     |         bytes calldata data
 51 |     |     ) external override {
 52 |     |         emit MessageUint("amount0Owed", amount0Owed);
 53 |     |         emit MessageUint("amount1Owed", amount1Owed);
 54 |     | 
 55 |     |         LiquidityManagement.MintCallbackData memory decoded = abi.decode(data, (LiquidityManagement.MintCallbackData));
 56 |     | 
 57 |     |         emit MessageUint("Balance Token0", IERC20(decoded.poolKey.token0).balanceOf(address(this)));
 58 |     |         emit MessageUint("Balance Token1", IERC20(decoded.poolKey.token1).balanceOf(address(this)));
 59 |     | 
 60 |     |         emit MessageAddress("Token0", decoded.poolKey.token0);
 61 |     |         emit MessageAddress("Token1", decoded.poolKey.token1);
 62 |     | 
 63 |     |         if (amount0Owed > 0) IERC20(decoded.poolKey.token0).transfer(msg.sender, amount0Owed);
 64 |     |         if (amount1Owed > 0) IERC20(decoded.poolKey.token1).transfer(msg.sender, amount1Owed);
 65 |     |     }
 66 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockV3Aggregator.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /**
  5 |     |  * @title MockV3Aggregator
  6 |     |  * @notice Based on the FluxAggregator contract
  7 |     |  * @notice Use this contract when you need to test
  8 |     |  * other contract's ability to read data from an
  9 |     |  * aggregator contract, but how the aggregator got
 10 |     |  * its answer is unimportant
 11 |     |  */
 12 |     | contract MockV3Aggregator {
 13 |     |     uint256 public constant version = 0;
 14 |     | 
 15 |     |     uint8 public decimals;
 16 |     |     int256 public latestAnswer;
 17 |     |     uint256 public latestTimestamp;
 18 |     |     uint256 public latestRound;
 19 |     | 
 20 |     |     mapping(uint256 => int256) public getAnswer;
 21 |     |     mapping(uint256 => uint256) public getTimestamp;
 22 |     |     mapping(uint256 => uint256) private getStartedAt;
 23 |     | 
 24 |     |     constructor(uint8 _decimals, int256 _initialAnswer) {
 25 |     |         decimals = _decimals;
 26 |     |         updateAnswer(_initialAnswer);
 27 |     |     }
 28 |     | 
 29 |     |     function updateAnswer(int256 _answer) public {
 30 |     |         latestAnswer = _answer;
 31 |     |         latestTimestamp = block.timestamp;
 32 |     |         latestRound++;
 33 |     |         getAnswer[latestRound] = _answer;
 34 |     |         getTimestamp[latestRound] = block.timestamp;
 35 |     |         getStartedAt[latestRound] = block.timestamp;
 36 |     |     }
 37 |     | 
 38 |     |     function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {
 39 |     |         latestRound = _roundId;
 40 |     |         latestAnswer = _answer;
 41 |     |         latestTimestamp = _timestamp;
 42 |     |         getAnswer[latestRound] = _answer;
 43 |     |         getTimestamp[latestRound] = _timestamp;
 44 |     |         getStartedAt[latestRound] = _startedAt;
 45 |     |     }
 46 |     | 
 47 |     |     function getRoundData(uint80 _roundId)
 48 |     |         external
 49 |     |         returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
 50 |     |     {
 51 |     |         return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);
 52 |     |     }
 53 |     | 
 54 |     |     function latestRoundData()
 55 |     |         external
 56 |     |         returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)
 57 |     |     {
 58 |     |         return (
 59 |     |             uint80(latestRound),
 60 |     |             getAnswer[latestRound],
 61 |     |             getStartedAt[latestRound],
 62 |     |             getTimestamp[latestRound],
 63 |     |             uint80(latestRound)
 64 |     |         );
 65 |     |     }
 66 |     | 
 67 |     |     function description() external pure returns (string memory) {
 68 |     |         return "v0.6/tests/MockV3Aggregator.sol";
 69 |     |     }
 70 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockZapper.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | import '@openzeppelin/contracts/access/Ownable.sol';
   5 |     | import '@openzeppelin/contracts/interfaces/IERC4626.sol';
   6 |     | import '@openzeppelin/contracts/token/ERC20/IERC20.sol';
   7 |     | import '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';
   8 |     | import '@uniswap/v3-core/contracts/libraries/FixedPoint96.sol';
   9 |     | import '@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol';
  10 |     | import '@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol';
  11 |     | import '../../../contracts/interfaces/ICurvePool.sol';
  12 |     | import '../../../contracts/interfaces/IDecentralizedIndex.sol';
  13 |     | import '../../../contracts/interfaces/IDexAdapter.sol';
  14 |     | import '../../../contracts/interfaces/IUniswapV2Pair.sol';
  15 |     | import '../../../contracts/interfaces/IUniswapV3Pool.sol';
  16 |     | import '../../../contracts/interfaces/IV3TwapUtilities.sol';
  17 |     | import '../../../contracts/interfaces/IWETH.sol';
  18 |     | import '../../../contracts/interfaces/IZapper.sol';
  19 |     | 
  20 |     | contract MockZapper is IZapper, Context, Ownable {
  21 |     |   using SafeERC20 for IERC20;
  22 |     | 
  23 |     |   address constant STYETH = 0x583019fF0f430721aDa9cfb4fac8F06cA104d0B4;
  24 |     |   address constant YETH = 0x1BED97CBC3c24A4fb5C069C6E311a967386131f7;
  25 |     |   address constant WETH_YETH_POOL = 0x69ACcb968B19a53790f43e57558F5E443A91aF22;
  26 |     |   address V3_ROUTER;
  27 |     |   address immutable V2_ROUTER;
  28 |     |   address immutable WETH;
  29 |     |   IV3TwapUtilities immutable V3_TWAP_UTILS;
  30 |     |   IDexAdapter immutable DEX_ADAPTER;
  31 |     | 
  32 |     |   uint256 _slippage = 30; // 3%
  33 |     | 
  34 |     |   address public OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;
  35 |     |   address public pOHM;
  36 |     | 
  37 |     |   // token in => token out => swap pool(s)
  38 |     |   mapping(address => mapping(address => Pools)) public zapMap;
  39 |     |   // curve pool => token => idx
  40 |     |   mapping(address => mapping(address => int128)) public curveTokenIdx;
  41 |     | 
  42 |     |   event Message(string a);
  43 |     | 
  44 |     |   constructor(IV3TwapUtilities _v3TwapUtilities, IDexAdapter _dexAdapter, address _V3_ROUTER) {
  45 |     |     V2_ROUTER = _dexAdapter.V2_ROUTER();
  46 |     |     V3_TWAP_UTILS = _v3TwapUtilities;
  47 |     |     DEX_ADAPTER = _dexAdapter;
  48 |     |     WETH = _dexAdapter.WETH();
  49 |     |     V3_ROUTER = _V3_ROUTER;
  50 |     | 
  51 |     |     emit Message("Here");
  52 |     | 
  53 |     |     // if (block.chainid == 1) {
  54 |     |     //   // WETH/YETH
  55 |     |     //   _setZapMapFromPoolSingle(
  56 |     |     //     PoolType.CURVE,
  57 |     |     //     0x69ACcb968B19a53790f43e57558F5E443A91aF22
  58 |     |     //   );
  59 |     |     //   // WETH/DAI
  60 |     |     //   _setZapMapFromPoolSingle(
  61 |     |     //     PoolType.V3,
  62 |     |     //     0x60594a405d53811d3BC4766596EFD80fd545A270
  63 |     |     //   );
  64 |     |     //   // WETH/USDC
  65 |     |     //   _setZapMapFromPoolSingle(
  66 |     |     //     PoolType.V3,
  67 |     |     //     0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640
  68 |     |     //   );
  69 |     |     //   // WETH/OHM
  70 |     |     //   _setZapMapFromPoolSingle(
  71 |     |     //     PoolType.V3,
  72 |     |     //     0x88051B0eea095007D3bEf21aB287Be961f3d8598
  73 |     |     //   );
  74 |     |     //   // USDC/OHM
  75 |     |     //   _setZapMapFromPoolSingle(
  76 |     |     //     PoolType.V3,
  77 |     |     //     0x893f503FaC2Ee1e5B78665db23F9c94017Aae97D
  78 |     |     //   );
  79 |     |     // }
  80 |     |   }
  81 |     | 
  82 |     |   function _zap(
  83 |     |     address _in,
  84 |     |     address _out,
  85 |     |     uint256 _amountIn,
  86 |     |     uint256 _amountOutMin
  87 |     |   ) internal returns (uint256 _amountOut) {
  88 |     |     if (_in == address(0)) {
  89 |     |       _amountIn = _ethToWETH(_amountIn);
  90 |     |       _in = WETH;
  91 |     |       if (_out == WETH) {
  92 |     |         return _amountIn;
  93 |     |       }
  94 |     |     }
  95 |     |     // handle pOHM separately through pod, modularize later
  96 |     |     bool _isOutPOHM;
  97 |     |     if (pOHM == _out) {
  98 |     |       _isOutPOHM = true;
  99 |     |       _out = OHM;
 100 |     |     }
 101 |     |     // handle yETH and st-yETH special through curve pool, modularize later
 102 |     |     if (_out == YETH || _out == STYETH) {
 103 |     |       require(_in == WETH, 'YETHIN');
 104 |     |       return _wethToYeth(_amountIn, _amountOutMin, _out == STYETH);
 105 |     |     } else if (_in == YETH || _in == STYETH) {
 106 |     |       require(_out == WETH, 'YETHOUT');
 107 |     |       return _styethToWeth(_amountIn, _amountOutMin, _in == YETH);
 108 |     |     }
 109 |     |     Pools memory _poolInfo = zapMap[_in][_out];
 110 |     |     // no pool so just try to swap over one path univ2
 111 |     |     if (_poolInfo.pool1 == address(0)) {
 112 |     |       address[] memory _path = new address[](2);
 113 |     |       _path[0] = _in;
 114 |     |       _path[1] = _out;
 115 |     |       _amountOut = _swapV2(_path, _amountIn, _amountOutMin);
 116 |     |     } else {
 117 |     |       bool _twoHops = _poolInfo.pool2 != address(0);
 118 |     |       if (_poolInfo.poolType == PoolType.CURVE) {
 119 |     |         // curve
 120 |     |         _amountOut = _swapCurve(
 121 |     |           _poolInfo.pool1,
 122 |     |           curveTokenIdx[_poolInfo.pool1][_in],
 123 |     |           curveTokenIdx[_poolInfo.pool1][_out],
 124 |     |           _amountIn,
 125 |     |           _amountOutMin
 126 |     |         );
 127 |     |       } else if (_poolInfo.poolType == PoolType.V2) {
 128 |     |         // univ2
 129 |     |         address _token0 = IUniswapV2Pair(_poolInfo.pool1).token0();
 130 |     |         address[] memory _path = new address[](_twoHops ? 3 : 2);
 131 |     |         _path[0] = _in;
 132 |     |         _path[1] = !_twoHops ? _out : _token0 == _in
 133 |     |           ? IUniswapV2Pair(_poolInfo.pool1).token1()
 134 |     |           : _token0;
 135 |     |         if (_twoHops) {
 136 |     |           _path[2] = _out;
 137 |     |         }
 138 |     |         _amountOut = _swapV2(_path, _amountIn, _amountOutMin);
 139 |     |       } else {
 140 |     |         // univ3
 141 |     |         if (_twoHops) {
 142 |     |           address _t0 = IUniswapV3Pool(_poolInfo.pool1).token0();
 143 |     |           _amountOut = _swapV3Multi(
 144 |     |             _in,
 145 |     |             _getPoolFee(_poolInfo.pool1),
 146 |     |             _t0 == _in ? IUniswapV3Pool(_poolInfo.pool1).token1() : _t0,
 147 |     |             _getPoolFee(_poolInfo.pool2),
 148 |     |             _out,
 149 |     |             _amountIn,
 150 |     |             _amountOutMin
 151 |     |           );
 152 |     |         } else {
 153 |     |           _amountOut = _swapV3Single(
 154 |     |             _in,
 155 |     |             _getPoolFee(_poolInfo.pool1),
 156 |     |             _out,
 157 |     |             _amountIn,
 158 |     |             _amountOutMin
 159 |     |           );
 160 |     |         }
 161 |     |       }
 162 |     |     }
 163 |     |     if (!_isOutPOHM) {
 164 |     |       return _amountOut;
 165 |     |     }
 166 |     |     uint256 _pOHMBefore = IERC20(pOHM).balanceOf(address(this));
 167 |     |     IERC20(OHM).safeIncreaseAllowance(pOHM, _amountOut);
 168 |     |     IDecentralizedIndex(pOHM).bond(OHM, _amountOut, 0);
 169 |     |     return IERC20(pOHM).balanceOf(address(this)) - _pOHMBefore;
 170 |     |   }
 171 |     | 
 172 |     |   function _getPoolFee(address _pool) internal view returns (uint24) {
 173 |     |     return block.chainid == 42161 ? 0 : IUniswapV3Pool(_pool).fee();
 174 |     |   }
 175 |     | 
 176 |     |   function _ethToWETH(uint256 _amountETH) internal returns (uint256) {
 177 |     |     uint256 _wethBal = IERC20(WETH).balanceOf(address(this));
 178 |     |     IWETH(WETH).deposit{ value: _amountETH }();
 179 |     |     return IERC20(WETH).balanceOf(address(this)) - _wethBal;
 180 |     |   }
 181 |     | 
 182 |     |   function _swapV3Single(
 183 |     |     address _in,
 184 |     |     uint24 _fee,
 185 |     |     address _out,
 186 |     |     uint256 _amountIn,
 187 |     |     uint256 _amountOutMin
 188 |     |   ) internal returns (uint256) {
 189 |     |     if (_amountOutMin == 0) {
 190 |     |       address _v3Pool;
 191 |     |       try DEX_ADAPTER.getV3Pool(_in, _out, uint24(10000)) returns (
 192 |     |         address __v3Pool
 193 |     |       ) {
 194 |     |         _v3Pool = __v3Pool;
 195 |     |       } catch {
 196 |     |         _v3Pool = DEX_ADAPTER.getV3Pool(_in, _out, int24(200));
 197 |     |       }
 198 |     |       address _token0 = _in < _out ? _in : _out;
 199 |     |       uint256 _poolPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(
 200 |     |         V3_TWAP_UTILS.sqrtPriceX96FromPoolAndInterval(_v3Pool)
 201 |     |       );
 202 |     |       _amountOutMin = _in == _token0
 203 |     |         ? (_poolPriceX96 * _amountIn) / FixedPoint96.Q96
 204 |     |         : (_amountIn * FixedPoint96.Q96) / _poolPriceX96;
 205 |     |     }
 206 |     | 
 207 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 208 |     |     IERC20(_in).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);
 209 |     |     DEX_ADAPTER.swapV3Single(
 210 |     |       _in,
 211 |     |       _out,
 212 |     |       _fee,
 213 |     |       _amountIn,
 214 |     |       (_amountOutMin * (1000 - _slippage)) / 1000,
 215 |     |       address(this)
 216 |     |     );
 217 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 218 |     |   }
 219 |     | 
 220 |     |   function _swapV3Multi(
 221 |     |     address _in,
 222 |     |     uint24 _fee1,
 223 |     |     address _in2,
 224 |     |     uint24 _fee2,
 225 |     |     address _out,
 226 |     |     uint256 _amountIn,
 227 |     |     uint256 _amountOutMin
 228 |     |   ) internal returns (uint256) {
 229 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 230 |     |     IERC20(_in).safeIncreaseAllowance(V3_ROUTER, _amountIn);
 231 |     |     bytes memory _path = abi.encodePacked(_in, _fee1, _in2, _fee2, _out);
 232 |     |     ISwapRouter(V3_ROUTER).exactInput(
 233 |     |       ISwapRouter.ExactInputParams({
 234 |     |         path: _path,
 235 |     |         recipient: address(this),
 236 |     |         deadline: block.timestamp,
 237 |     |         amountIn: _amountIn,
 238 |     |         amountOutMinimum: _amountOutMin
 239 |     |       })
 240 |     |     );
 241 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 242 |     |   }
 243 |     | 
 244 |     |   function _swapV2(
 245 |     |     address[] memory _path,
 246 |     |     uint256 _amountIn,
 247 |     |     uint256 _amountOutMin
 248 |     |   ) internal returns (uint256) {
 249 |     |     address _out = _path.length == 3 ? _path[2] : _path[1];
 250 |     |     uint256 _outBefore = IERC20(_out).balanceOf(address(this));
 251 |     |     IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);
 252 |     |     DEX_ADAPTER.swapV2Single(
 253 |     |       _path[0],
 254 |     |       _path[1],
 255 |     |       _amountIn,
 256 |     |       _amountOutMin,
 257 |     |       address(this)
 258 |     |     );
 259 |     |     return IERC20(_out).balanceOf(address(this)) - _outBefore;
 260 |     |   }
 261 |     | 
 262 |     |   function _swapCurve(
 263 |     |     address _pool,
 264 |     |     int128 _i,
 265 |     |     int128 _j,
 266 |     |     uint256 _amountIn,
 267 |     |     uint256 _amountOutMin
 268 |     |   ) internal returns (uint256) {
 269 |     |     IERC20(ICurvePool(_pool).coins(uint128(_i))).safeIncreaseAllowance(
 270 |     |       _pool,
 271 |     |       _amountIn
 272 |     |     );
 273 |     |     return
 274 |     |       ICurvePool(_pool).exchange(
 275 |     |         _i,
 276 |     |         _j,
 277 |     |         _amountIn,
 278 |     |         _amountOutMin,
 279 |     |         address(this)
 280 |     |       );
 281 |     |   }
 282 |     | 
 283 |     |   function _wethToYeth(
 284 |     |     uint256 _ethAmount,
 285 |     |     uint256 _minYethAmount,
 286 |     |     bool _stakeToStyeth
 287 |     |   ) internal returns (uint256) {
 288 |     |     uint256 _boughtYeth = _swapCurve(
 289 |     |       WETH_YETH_POOL,
 290 |     |       0,
 291 |     |       1,
 292 |     |       _ethAmount,
 293 |     |       _minYethAmount
 294 |     |     );
 295 |     |     if (_stakeToStyeth) {
 296 |     |       IERC20(YETH).safeIncreaseAllowance(STYETH, _boughtYeth);
 297 |     |       return IERC4626(STYETH).deposit(_boughtYeth, address(this));
 298 |     |     }
 299 |     |     return _boughtYeth;
 300 |     |   }
 301 |     | 
 302 |     |   function _styethToWeth(
 303 |     |     uint256 _stYethAmount,
 304 |     |     uint256 _minWethAmount,
 305 |     |     bool _isYethOnly
 306 |     |   ) internal returns (uint256) {
 307 |     |     uint256 _yethAmount;
 308 |     |     if (_isYethOnly) {
 309 |     |       _yethAmount = _stYethAmount;
 310 |     |     } else {
 311 |     |       _yethAmount = IERC4626(STYETH).redeem(
 312 |     |         _stYethAmount,
 313 |     |         address(this),
 314 |     |         address(this)
 315 |     |       );
 316 |     |     }
 317 |     |     return _swapCurve(WETH_YETH_POOL, 1, 0, _yethAmount, _minWethAmount);
 318 |     |   }
 319 |     | 
 320 |     |   function _setZapMapFromPoolSingle(PoolType _type, address _pool) internal {
 321 |     |     address _t0;
 322 |     |     address _t1;
 323 |     |     if (_type == PoolType.CURVE) {
 324 |     |       _t0 = ICurvePool(_pool).coins(0);
 325 |     |       _t1 = ICurvePool(_pool).coins(1);
 326 |     |       curveTokenIdx[_pool][_t0] = 0;
 327 |     |       curveTokenIdx[_pool][_t1] = 1;
 328 |     |     } else {
 329 |     |       _t0 = IUniswapV3Pool(_pool).token0();
 330 |     |       _t1 = IUniswapV3Pool(_pool).token1();
 331 |     |     }
 332 |     |     Pools memory _poolConf = Pools({
 333 |     |       poolType: _type,
 334 |     |       pool1: _pool,
 335 |     |       pool2: address(0)
 336 |     |     });
 337 |     |     zapMap[_t0][_t1] = _poolConf;
 338 |     |     zapMap[_t1][_t0] = _poolConf;
 339 |     |   }
 340 |     | 
 341 |     |   function setOHM(address _OHM, address _pOHM) external onlyOwner {
 342 |     |     OHM = _OHM == address(0) ? OHM : _OHM;
 343 |     |     pOHM = _pOHM == address(0) ? pOHM : _pOHM;
 344 |     |   }
 345 |     | 
 346 |     |   function setSlippage(uint256 _slip) external onlyOwner {
 347 |     |     require(_slip >= 0 && _slip <= 1000, 'BOUNDS');
 348 |     |     _slippage = _slip;
 349 |     |   }
 350 |     | 
 351 |     |   function setZapMap(
 352 |     |     address _in,
 353 |     |     address _out,
 354 |     |     Pools memory _pools
 355 |     |   ) external onlyOwner {
 356 |     |     zapMap[_in][_out] = _pools;
 357 |     |   }
 358 |     | 
 359 |     |   function setZapMapFromPoolSingle(
 360 |     |     PoolType _type,
 361 |     |     address _pool
 362 |     |   ) external onlyOwner {
 363 |     |     _setZapMapFromPoolSingle(_type, _pool);
 364 |     |   }
 365 |     | 
 366 |     |   function rescueETH() external onlyOwner {
 367 |     |     (bool _sent, ) = payable(owner()).call{ value: address(this).balance }('');
 368 |     |     require(_sent);
 369 |     |   }
 370 |     | 
 371 |     |   function rescueERC20(IERC20 _token) external onlyOwner {
 372 |     |     require(_token.balanceOf(address(this)) > 0);
 373 |     |     _token.safeTransfer(owner(), _token.balanceOf(address(this)));
 374 |     |   }
 375 |     | 
 376 |     |   receive() external payable {}
 377 |     | }
 378 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/WETH.sol
   1 |     | /**
   2 |     |  *Submitted for verification at Etherscan.io on 2017-12-12
   3 |     |  */
   4 |     | 
   5 |     | // Copyright (C) 2015, 2016, 2017 Dapphub
   6 |     | 
   7 |     | // This program is free software: you can redistribute it and/or modify
   8 |     | // it under the terms of the GNU General Public License as published by
   9 |     | // the Free Software Foundation, either version 3 of the License, or
  10 |     | // (at your option) any later version.
  11 |     | 
  12 |     | // This program is distributed in the hope that it will be useful,
  13 |     | // but WITHOUT ANY WARRANTY; without even the implied warranty of
  14 |     | // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  15 |     | // GNU General Public License for more details.
  16 |     | 
  17 |     | // You should have received a copy of the GNU General Public License
  18 |     | // along with this program.  If not, see <http://www.gnu.org/licenses/>.
  19 |     | 
  20 |     | pragma solidity ^0.8.13;
  21 |     | 
  22 | *   | contract WETH9 {
  23 | *   |     string public name = "Wrapped Ether";
  24 |     |     string public symbol = "WETH";
  25 | *   |     uint8 public decimals = 18;
  26 |     | 
  27 |     |     event Approval(address indexed src, address indexed guy, uint wad);
  28 |     |     event Transfer(address indexed src, address indexed dst, uint wad);
  29 |     |     event Deposit(address indexed dst, uint wad);
  30 |     |     event Withdrawal(address indexed src, uint wad);
  31 |     | 
  32 | *   |     mapping(address => uint) public balanceOf;
  33 |     |     mapping(address => mapping(address => uint)) public allowance;
  34 |     | 
  35 |     |     receive() external payable {
  36 |     |         deposit();
  37 |     |     }
  38 |     | 
  39 |     |     function deposit() public payable {
  40 |     |         balanceOf[msg.sender] += msg.value;
  41 |     |         emit Deposit(msg.sender, msg.value);
  42 |     |     }
  43 |     | 
  44 |     |     function withdraw(uint wad) public {
  45 |     |         require(balanceOf[msg.sender] >= wad);
  46 |     |         balanceOf[msg.sender] -= wad;
  47 |     |         msg.sender.call{value: wad}("");
  48 |     |         emit Withdrawal(msg.sender, wad);
  49 |     |     }
  50 |     | 
  51 | *   |     function totalSupply() public view returns (uint) {
  52 |     |         return address(this).balance;
  53 |     |     }
  54 |     | 
  55 | *   |     function approve(address guy, uint wad) public returns (bool) {
  56 | *   |         allowance[msg.sender][guy] = wad;
  57 | *   |         emit Approval(msg.sender, guy, wad);
  58 | *   |         return true;
  59 |     |     }
  60 |     | 
  61 | *   |     function transfer(address dst, uint wad) public returns (bool) {
  62 | *   |         return transferFrom(msg.sender, dst, wad);
  63 |     |     }
  64 |     | 
  65 | *   |     function transferFrom(
  66 |     |         address src,
  67 |     |         address dst,
  68 |     |         uint wad
  69 | *   |     ) public returns (bool) {
  70 | *   |         require(balanceOf[src] >= wad);
  71 |     | 
  72 | *   |         if (
  73 | *   |             src != msg.sender && allowance[src][msg.sender] != type(uint256).max
  74 |     |         ) {
  75 |     |             require(allowance[src][msg.sender] >= wad);
  76 |     |             allowance[src][msg.sender] -= wad;
  77 |     |         }
  78 |     | 
  79 | *   |         balanceOf[src] -= wad;
  80 | *   |         balanceOf[dst] += wad;
  81 |     | 
  82 | *   |         emit Transfer(src, dst, wad);
  83 |     | 
  84 | *   |         return true;
  85 |     |     }
  86 |     | }
  87 |     | 
  88 |     | /*
  89 |     |                     GNU GENERAL PUBLIC LICENSE
  90 |     |                        Version 3, 29 June 2007
  91 |     | 
  92 |     |  Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
  93 |     |  Everyone is permitted to copy and distribute verbatim copies
  94 |     |  of this license document, but changing it is not allowed.
  95 |     | 
  96 |     |                             Preamble
  97 |     | 
  98 |     |   The GNU General Public License is a free, copyleft license for
  99 |     | software and other kinds of works.
 100 |     | 
 101 |     |   The licenses for most software and other practical works are designed
 102 |     | to take away your freedom to share and change the works.  By contrast,
 103 |     | the GNU General Public License is intended to guarantee your freedom to
 104 |     | share and change all versions of a program--to make sure it remains free
 105 |     | software for all its users.  We, the Free Software Foundation, use the
 106 |     | GNU General Public License for most of our software; it applies also to
 107 |     | any other work released this way by its authors.  You can apply it to
 108 |     | your programs, too.
 109 |     | 
 110 |     |   When we speak of free software, we are referring to freedom, not
 111 |     | price.  Our General Public Licenses are designed to make sure that you
 112 |     | have the freedom to distribute copies of free software (and charge for
 113 |     | them if you wish), that you receive source code or can get it if you
 114 |     | want it, that you can change the software or use pieces of it in new
 115 |     | free programs, and that you know you can do these things.
 116 |     | 
 117 |     |   To protect your rights, we need to prevent others from denying you
 118 |     | these rights or asking you to surrender the rights.  Therefore, you have
 119 |     | certain responsibilities if you distribute copies of the software, or if
 120 |     | you modify it: responsibilities to respect the freedom of others.
 121 |     | 
 122 |     |   For example, if you distribute copies of such a program, whether
 123 |     | gratis or for a fee, you must pass on to the recipients the same
 124 |     | freedoms that you received.  You must make sure that they, too, receive
 125 |     | or can get the source code.  And you must show them these terms so they
 126 |     | know their rights.
 127 |     | 
 128 |     |   Developers that use the GNU GPL protect your rights with two steps:
 129 |     | (1) assert copyright on the software, and (2) offer you this License
 130 |     | giving you legal permission to copy, distribute and/or modify it.
 131 |     | 
 132 |     |   For the developers' and authors' protection, the GPL clearly explains
 133 |     | that there is no warranty for this free software.  For both users' and
 134 |     | authors' sake, the GPL requires that modified versions be marked as
 135 |     | changed, so that their problems will not be attributed erroneously to
 136 |     | authors of previous versions.
 137 |     | 
 138 |     |   Some devices are designed to deny users access to install or run
 139 |     | modified versions of the software inside them, although the manufacturer
 140 |     | can do so.  This is fundamentally incompatible with the aim of
 141 |     | protecting users' freedom to change the software.  The systematic
 142 |     | pattern of such abuse occurs in the area of products for individuals to
 143 |     | use, which is precisely where it is most unacceptable.  Therefore, we
 144 |     | have designed this version of the GPL to prohibit the practice for those
 145 |     | products.  If such problems arise substantially in other domains, we
 146 |     | stand ready to extend this provision to those domains in future versions
 147 |     | of the GPL, as needed to protect the freedom of users.
 148 |     | 
 149 |     |   Finally, every program is threatened constantly by software patents.
 150 |     | States should not allow patents to restrict development and use of
 151 |     | software on general-purpose computers, but in those that do, we wish to
 152 |     | avoid the special danger that patents applied to a free program could
 153 |     | make it effectively proprietary.  To prevent this, the GPL assures that
 154 |     | patents cannot be used to render the program non-free.
 155 |     | 
 156 |     |   The precise terms and conditions for copying, distribution and
 157 |     | modification follow.
 158 |     | 
 159 |     |                        TERMS AND CONDITIONS
 160 |     | 
 161 |     |   0. Definitions.
 162 |     | 
 163 |     |   "This License" refers to version 3 of the GNU General Public License.
 164 |     | 
 165 |     |   "Copyright" also means copyright-like laws that apply to other kinds of
 166 |     | works, such as semiconductor masks.
 167 |     | 
 168 |     |   "The Program" refers to any copyrightable work licensed under this
 169 |     | License.  Each licensee is addressed as "you".  "Licensees" and
 170 |     | "recipients" may be individuals or organizations.
 171 |     | 
 172 |     |   To "modify" a work means to copy from or adapt all or part of the work
 173 |     | in a fashion requiring copyright permission, other than the making of an
 174 |     | exact copy.  The resulting work is called a "modified version" of the
 175 |     | earlier work or a work "based on" the earlier work.
 176 |     | 
 177 |     |   A "covered work" means either the unmodified Program or a work based
 178 |     | on the Program.
 179 |     | 
 180 |     |   To "propagate" a work means to do anything with it that, without
 181 |     | permission, would make you directly or secondarily liable for
 182 |     | infringement under applicable copyright law, except executing it on a
 183 |     | computer or modifying a private copy.  Propagation includes copying,
 184 |     | distribution (with or without modification), making available to the
 185 |     | public, and in some countries other activities as well.
 186 |     | 
 187 |     |   To "convey" a work means any kind of propagation that enables other
 188 |     | parties to make or receive copies.  Mere interaction with a user through
 189 |     | a computer network, with no transfer of a copy, is not conveying.
 190 |     | 
 191 |     |   An interactive user interface displays "Appropriate Legal Notices"
 192 |     | to the extent that it includes a convenient and prominently visible
 193 |     | feature that (1) displays an appropriate copyright notice, and (2)
 194 |     | tells the user that there is no warranty for the work (except to the
 195 |     | extent that warranties are provided), that licensees may convey the
 196 |     | work under this License, and how to view a copy of this License.  If
 197 |     | the interface presents a list of user commands or options, such as a
 198 |     | menu, a prominent item in the list meets this criterion.
 199 |     | 
 200 |     |   1. Source Code.
 201 |     | 
 202 |     |   The "source code" for a work means the preferred form of the work
 203 |     | for making modifications to it.  "Object code" means any non-source
 204 |     | form of a work.
 205 |     | 
 206 |     |   A "Standard Interface" means an interface that either is an official
 207 |     | standard defined by a recognized standards body, or, in the case of
 208 |     | interfaces specified for a particular programming language, one that
 209 |     | is widely used among developers working in that language.
 210 |     | 
 211 |     |   The "System Libraries" of an executable work include anything, other
 212 |     | than the work as a whole, that (a) is included in the normal form of
 213 |     | packaging a Major Component, but which is not part of that Major
 214 |     | Component, and (b) serves only to enable use of the work with that
 215 |     | Major Component, or to implement a Standard Interface for which an
 216 |     | implementation is available to the public in source code form.  A
 217 |     | "Major Component", in this context, means a major essential component
 218 |     | (kernel, window system, and so on) of the specific operating system
 219 |     | (if any) on which the executable work runs, or a compiler used to
 220 |     | produce the work, or an object code interpreter used to run it.
 221 |     | 
 222 |     |   The "Corresponding Source" for a work in object code form means all
 223 |     | the source code needed to generate, install, and (for an executable
 224 |     | work) run the object code and to modify the work, including scripts to
 225 |     | control those activities.  However, it does not include the work's
 226 |     | System Libraries, or general-purpose tools or generally available free
 227 |     | programs which are used unmodified in performing those activities but
 228 |     | which are not part of the work.  For example, Corresponding Source
 229 |     | includes interface definition files associated with source files for
 230 |     | the work, and the source code for shared libraries and dynamically
 231 |     | linked subprograms that the work is specifically designed to require,
 232 |     | such as by intimate data communication or control flow between those
 233 |     | subprograms and other parts of the work.
 234 |     | 
 235 |     |   The Corresponding Source need not include anything that users
 236 |     | can regenerate automatically from other parts of the Corresponding
 237 |     | Source.
 238 |     | 
 239 |     |   The Corresponding Source for a work in source code form is that
 240 |     | same work.
 241 |     | 
 242 |     |   2. Basic Permissions.
 243 |     | 
 244 |     |   All rights granted under this License are granted for the term of
 245 |     | copyright on the Program, and are irrevocable provided the stated
 246 |     | conditions are met.  This License explicitly affirms your unlimited
 247 |     | permission to run the unmodified Program.  The output from running a
 248 |     | covered work is covered by this License only if the output, given its
 249 |     | content, constitutes a covered work.  This License acknowledges your
 250 |     | rights of fair use or other equivalent, as provided by copyright law.
 251 |     | 
 252 |     |   You may make, run and propagate covered works that you do not
 253 |     | convey, without conditions so long as your license otherwise remains
 254 |     | in force.  You may convey covered works to others for the sole purpose
 255 |     | of having them make modifications exclusively for you, or provide you
 256 |     | with facilities for running those works, provided that you comply with
 257 |     | the terms of this License in conveying all material for which you do
 258 |     | not control copyright.  Those thus making or running the covered works
 259 |     | for you must do so exclusively on your behalf, under your direction
 260 |     | and control, on terms that prohibit them from making any copies of
 261 |     | your copyrighted material outside their relationship with you.
 262 |     | 
 263 |     |   Conveying under any other circumstances is permitted solely under
 264 |     | the conditions stated below.  Sublicensing is not allowed; section 10
 265 |     | makes it unnecessary.
 266 |     | 
 267 |     |   3. Protecting Users' Legal Rights From Anti-Circumvention Law.
 268 |     | 
 269 |     |   No covered work shall be deemed part of an effective technological
 270 |     | measure under any applicable law fulfilling obligations under article
 271 |     | 11 of the WIPO copyright treaty adopted on 20 December 1996, or
 272 |     | similar laws prohibiting or restricting circumvention of such
 273 |     | measures.
 274 |     | 
 275 |     |   When you convey a covered work, you waive any legal power to forbid
 276 |     | circumvention of technological measures to the extent such circumvention
 277 |     | is effected by exercising rights under this License with respect to
 278 |     | the covered work, and you disclaim any intention to limit operation or
 279 |     | modification of the work as a means of enforcing, against the work's
 280 |     | users, your or third parties' legal rights to forbid circumvention of
 281 |     | technological measures.
 282 |     | 
 283 |     |   4. Conveying Verbatim Copies.
 284 |     | 
 285 |     |   You may convey verbatim copies of the Program's source code as you
 286 |     | receive it, in any medium, provided that you conspicuously and
 287 |     | appropriately publish on each copy an appropriate copyright notice;
 288 |     | keep intact all notices stating that this License and any
 289 |     | non-permissive terms added in accord with section 7 apply to the code;
 290 |     | keep intact all notices of the absence of any warranty; and give all
 291 |     | recipients a copy of this License along with the Program.
 292 |     | 
 293 |     |   You may charge any price or no price for each copy that you convey,
 294 |     | and you may offer support or warranty protection for a fee.
 295 |     | 
 296 |     |   5. Conveying Modified Source Versions.
 297 |     | 
 298 |     |   You may convey a work based on the Program, or the modifications to
 299 |     | produce it from the Program, in the form of source code under the
 300 |     | terms of section 4, provided that you also meet all of these conditions:
 301 |     | 
 302 |     |     a) The work must carry prominent notices stating that you modified
 303 |     |     it, and giving a relevant date.
 304 |     | 
 305 |     |     b) The work must carry prominent notices stating that it is
 306 |     |     released under this License and any conditions added under section
 307 |     |     7.  This requirement modifies the requirement in section 4 to
 308 |     |     "keep intact all notices".
 309 |     | 
 310 |     |     c) You must license the entire work, as a whole, under this
 311 |     |     License to anyone who comes into possession of a copy.  This
 312 |     |     License will therefore apply, along with any applicable section 7
 313 |     |     additional terms, to the whole of the work, and all its parts,
 314 |     |     regardless of how they are packaged.  This License gives no
 315 |     |     permission to license the work in any other way, but it does not
 316 |     |     invalidate such permission if you have separately received it.
 317 |     | 
 318 |     |     d) If the work has interactive user interfaces, each must display
 319 |     |     Appropriate Legal Notices; however, if the Program has interactive
 320 |     |     interfaces that do not display Appropriate Legal Notices, your
 321 |     |     work need not make them do so.
 322 |     | 
 323 |     |   A compilation of a covered work with other separate and independent
 324 |     | works, which are not by their nature extensions of the covered work,
 325 |     | and which are not combined with it such as to form a larger program,
 326 |     | in or on a volume of a storage or distribution medium, is called an
 327 |     | "aggregate" if the compilation and its resulting copyright are not
 328 |     | used to limit the access or legal rights of the compilation's users
 329 |     | beyond what the individual works permit.  Inclusion of a covered work
 330 |     | in an aggregate does not cause this License to apply to the other
 331 |     | parts of the aggregate.
 332 |     | 
 333 |     |   6. Conveying Non-Source Forms.
 334 |     | 
 335 |     |   You may convey a covered work in object code form under the terms
 336 |     | of sections 4 and 5, provided that you also convey the
 337 |     | machine-readable Corresponding Source under the terms of this License,
 338 |     | in one of these ways:
 339 |     | 
 340 |     |     a) Convey the object code in, or embodied in, a physical product
 341 |     |     (including a physical distribution medium), accompanied by the
 342 |     |     Corresponding Source fixed on a durable physical medium
 343 |     |     customarily used for software interchange.
 344 |     | 
 345 |     |     b) Convey the object code in, or embodied in, a physical product
 346 |     |     (including a physical distribution medium), accompanied by a
 347 |     |     written offer, valid for at least three years and valid for as
 348 |     |     long as you offer spare parts or customer support for that product
 349 |     |     model, to give anyone who possesses the object code either (1) a
 350 |     |     copy of the Corresponding Source for all the software in the
 351 |     |     product that is covered by this License, on a durable physical
 352 |     |     medium customarily used for software interchange, for a price no
 353 |     |     more than your reasonable cost of physically performing this
 354 |     |     conveying of source, or (2) access to copy the
 355 |     |     Corresponding Source from a network server at no charge.
 356 |     | 
 357 |     |     c) Convey individual copies of the object code with a copy of the
 358 |     |     written offer to provide the Corresponding Source.  This
 359 |     |     alternative is allowed only occasionally and noncommercially, and
 360 |     |     only if you received the object code with such an offer, in accord
 361 |     |     with subsection 6b.
 362 |     | 
 363 |     |     d) Convey the object code by offering access from a designated
 364 |     |     place (gratis or for a charge), and offer equivalent access to the
 365 |     |     Corresponding Source in the same way through the same place at no
 366 |     |     further charge.  You need not require recipients to copy the
 367 |     |     Corresponding Source along with the object code.  If the place to
 368 |     |     copy the object code is a network server, the Corresponding Source
 369 |     |     may be on a different server (operated by you or a third party)
 370 |     |     that supports equivalent copying facilities, provided you maintain
 371 |     |     clear directions next to the object code saying where to find the
 372 |     |     Corresponding Source.  Regardless of what server hosts the
 373 |     |     Corresponding Source, you remain obligated to ensure that it is
 374 |     |     available for as long as needed to satisfy these requirements.
 375 |     | 
 376 |     |     e) Convey the object code using peer-to-peer transmission, provided
 377 |     |     you inform other peers where the object code and Corresponding
 378 |     |     Source of the work are being offered to the general public at no
 379 |     |     charge under subsection 6d.
 380 |     | 
 381 |     |   A separable portion of the object code, whose source code is excluded
 382 |     | from the Corresponding Source as a System Library, need not be
 383 |     | included in conveying the object code work.
 384 |     | 
 385 |     |   A "User Product" is either (1) a "consumer product", which means any
 386 |     | tangible personal property which is normally used for personal, family,
 387 |     | or household purposes, or (2) anything designed or sold for incorporation
 388 |     | into a dwelling.  In determining whether a product is a consumer product,
 389 |     | doubtful cases shall be resolved in favor of coverage.  For a particular
 390 |     | product received by a particular user, "normally used" refers to a
 391 |     | typical or common use of that class of product, regardless of the status
 392 |     | of the particular user or of the way in which the particular user
 393 |     | actually uses, or expects or is expected to use, the product.  A product
 394 |     | is a consumer product regardless of whether the product has substantial
 395 |     | commercial, industrial or non-consumer uses, unless such uses represent
 396 |     | the only significant mode of use of the product.
 397 |     | 
 398 |     |   "Installation Information" for a User Product means any methods,
 399 |     | procedures, authorization keys, or other information required to install
 400 |     | and execute modified versions of a covered work in that User Product from
 401 |     | a modified version of its Corresponding Source.  The information must
 402 |     | suffice to ensure that the continued functioning of the modified object
 403 |     | code is in no case prevented or interfered with solely because
 404 |     | modification has been made.
 405 |     | 
 406 |     |   If you convey an object code work under this section in, or with, or
 407 |     | specifically for use in, a User Product, and the conveying occurs as
 408 |     | part of a transaction in which the right of possession and use of the
 409 |     | User Product is transferred to the recipient in perpetuity or for a
 410 |     | fixed term (regardless of how the transaction is characterized), the
 411 |     | Corresponding Source conveyed under this section must be accompanied
 412 |     | by the Installation Information.  But this requirement does not apply
 413 |     | if neither you nor any third party retains the ability to install
 414 |     | modified object code on the User Product (for example, the work has
 415 |     | been installed in ROM).
 416 |     | 
 417 |     |   The requirement to provide Installation Information does not include a
 418 |     | requirement to continue to provide support service, warranty, or updates
 419 |     | for a work that has been modified or installed by the recipient, or for
 420 |     | the User Product in which it has been modified or installed.  Access to a
 421 |     | network may be denied when the modification itself materially and
 422 |     | adversely affects the operation of the network or violates the rules and
 423 |     | protocols for communication across the network.
 424 |     | 
 425 |     |   Corresponding Source conveyed, and Installation Information provided,
 426 |     | in accord with this section must be in a format that is publicly
 427 |     | documented (and with an implementation available to the public in
 428 |     | source code form), and must require no special password or key for
 429 |     | unpacking, reading or copying.
 430 |     | 
 431 |     |   7. Additional Terms.
 432 |     | 
 433 |     |   "Additional permissions" are terms that supplement the terms of this
 434 |     | License by making exceptions from one or more of its conditions.
 435 |     | Additional permissions that are applicable to the entire Program shall
 436 |     | be treated as though they were included in this License, to the extent
 437 |     | that they are valid under applicable law.  If additional permissions
 438 |     | apply only to part of the Program, that part may be used separately
 439 |     | under those permissions, but the entire Program remains governed by
 440 |     | this License without regard to the additional permissions.
 441 |     | 
 442 |     |   When you convey a copy of a covered work, you may at your option
 443 |     | remove any additional permissions from that copy, or from any part of
 444 |     | it.  (Additional permissions may be written to require their own
 445 |     | removal in certain cases when you modify the work.)  You may place
 446 |     | additional permissions on material, added by you to a covered work,
 447 |     | for which you have or can give appropriate copyright permission.
 448 |     | 
 449 |     |   Notwithstanding any other provision of this License, for material you
 450 |     | add to a covered work, you may (if authorized by the copyright holders of
 451 |     | that material) supplement the terms of this License with terms:
 452 |     | 
 453 |     |     a) Disclaiming warranty or limiting liability differently from the
 454 |     |     terms of sections 15 and 16 of this License; or
 455 |     | 
 456 |     |     b) Requiring preservation of specified reasonable legal notices or
 457 |     |     author attributions in that material or in the Appropriate Legal
 458 |     |     Notices displayed by works containing it; or
 459 |     | 
 460 |     |     c) Prohibiting misrepresentation of the origin of that material, or
 461 |     |     requiring that modified versions of such material be marked in
 462 |     |     reasonable ways as different from the original version; or
 463 |     | 
 464 |     |     d) Limiting the use for publicity purposes of names of licensors or
 465 |     |     authors of the material; or
 466 |     | 
 467 |     |     e) Declining to grant rights under trademark law for use of some
 468 |     |     trade names, trademarks, or service marks; or
 469 |     | 
 470 |     |     f) Requiring indemnification of licensors and authors of that
 471 |     |     material by anyone who conveys the material (or modified versions of
 472 |     |     it) with contractual assumptions of liability to the recipient, for
 473 |     |     any liability that these contractual assumptions directly impose on
 474 |     |     those licensors and authors.
 475 |     | 
 476 |     |   All other non-permissive additional terms are considered "further
 477 |     | restrictions" within the meaning of section 10.  If the Program as you
 478 |     | received it, or any part of it, contains a notice stating that it is
 479 |     | governed by this License along with a term that is a further
 480 |     | restriction, you may remove that term.  If a license document contains
 481 |     | a further restriction but permits relicensing or conveying under this
 482 |     | License, you may add to a covered work material governed by the terms
 483 |     | of that license document, provided that the further restriction does
 484 |     | not survive such relicensing or conveying.
 485 |     | 
 486 |     |   If you add terms to a covered work in accord with this section, you
 487 |     | must place, in the relevant source files, a statement of the
 488 |     | additional terms that apply to those files, or a notice indicating
 489 |     | where to find the applicable terms.
 490 |     | 
 491 |     |   Additional terms, permissive or non-permissive, may be stated in the
 492 |     | form of a separately written license, or stated as exceptions;
 493 |     | the above requirements apply either way.
 494 |     | 
 495 |     |   8. Termination.
 496 |     | 
 497 |     |   You may not propagate or modify a covered work except as expressly
 498 |     | provided under this License.  Any attempt otherwise to propagate or
 499 |     | modify it is void, and will automatically terminate your rights under
 500 |     | this License (including any patent licenses granted under the third
 501 |     | paragraph of section 11).
 502 |     | 
 503 |     |   However, if you cease all violation of this License, then your
 504 |     | license from a particular copyright holder is reinstated (a)
 505 |     | provisionally, unless and until the copyright holder explicitly and
 506 |     | finally terminates your license, and (b) permanently, if the copyright
 507 |     | holder fails to notify you of the violation by some reasonable means
 508 |     | prior to 60 days after the cessation.
 509 |     | 
 510 |     |   Moreover, your license from a particular copyright holder is
 511 |     | reinstated permanently if the copyright holder notifies you of the
 512 |     | violation by some reasonable means, this is the first time you have
 513 |     | received notice of violation of this License (for any work) from that
 514 |     | copyright holder, and you cure the violation prior to 30 days after
 515 |     | your receipt of the notice.
 516 |     | 
 517 |     |   Termination of your rights under this section does not terminate the
 518 |     | licenses of parties who have received copies or rights from you under
 519 |     | this License.  If your rights have been terminated and not permanently
 520 |     | reinstated, you do not qualify to receive new licenses for the same
 521 |     | material under section 10.
 522 |     | 
 523 |     |   9. Acceptance Not Required for Having Copies.
 524 |     | 
 525 |     |   You are not required to accept this License in order to receive or
 526 |     | run a copy of the Program.  Ancillary propagation of a covered work
 527 |     | occurring solely as a consequence of using peer-to-peer transmission
 528 |     | to receive a copy likewise does not require acceptance.  However,
 529 |     | nothing other than this License grants you permission to propagate or
 530 |     | modify any covered work.  These actions infringe copyright if you do
 531 |     | not accept this License.  Therefore, by modifying or propagating a
 532 |     | covered work, you indicate your acceptance of this License to do so.
 533 |     | 
 534 |     |   10. Automatic Licensing of Downstream Recipients.
 535 |     | 
 536 |     |   Each time you convey a covered work, the recipient automatically
 537 |     | receives a license from the original licensors, to run, modify and
 538 |     | propagate that work, subject to this License.  You are not responsible
 539 |     | for enforcing compliance by third parties with this License.
 540 |     | 
 541 |     |   An "entity transaction" is a transaction transferring control of an
 542 |     | organization, or substantially all assets of one, or subdividing an
 543 |     | organization, or merging organizations.  If propagation of a covered
 544 |     | work results from an entity transaction, each party to that
 545 |     | transaction who receives a copy of the work also receives whatever
 546 |     | licenses to the work the party's predecessor in interest had or could
 547 |     | give under the previous paragraph, plus a right to possession of the
 548 |     | Corresponding Source of the work from the predecessor in interest, if
 549 |     | the predecessor has it or can get it with reasonable efforts.
 550 |     | 
 551 |     |   You may not impose any further restrictions on the exercise of the
 552 |     | rights granted or affirmed under this License.  For example, you may
 553 |     | not impose a license fee, royalty, or other charge for exercise of
 554 |     | rights granted under this License, and you may not initiate litigation
 555 |     | (including a cross-claim or counterclaim in a lawsuit) alleging that
 556 |     | any patent claim is infringed by making, using, selling, offering for
 557 |     | sale, or importing the Program or any portion of it.
 558 |     | 
 559 |     |   11. Patents.
 560 |     | 
 561 |     |   A "contributor" is a copyright holder who authorizes use under this
 562 |     | License of the Program or a work on which the Program is based.  The
 563 |     | work thus licensed is called the contributor's "contributor version".
 564 |     | 
 565 |     |   A contributor's "essential patent claims" are all patent claims
 566 |     | owned or controlled by the contributor, whether already acquired or
 567 |     | hereafter acquired, that would be infringed by some manner, permitted
 568 |     | by this License, of making, using, or selling its contributor version,
 569 |     | but do not include claims that would be infringed only as a
 570 |     | consequence of further modification of the contributor version.  For
 571 |     | purposes of this definition, "control" includes the right to grant
 572 |     | patent sublicenses in a manner consistent with the requirements of
 573 |     | this License.
 574 |     | 
 575 |     |   Each contributor grants you a non-exclusive, worldwide, royalty-free
 576 |     | patent license under the contributor's essential patent claims, to
 577 |     | make, use, sell, offer for sale, import and otherwise run, modify and
 578 |     | propagate the contents of its contributor version.
 579 |     | 
 580 |     |   In the following three paragraphs, a "patent license" is any express
 581 |     | agreement or commitment, however denominated, not to enforce a patent
 582 |     | (such as an express permission to practice a patent or covenant not to
 583 |     | sue for patent infringement).  To "grant" such a patent license to a
 584 |     | party means to make such an agreement or commitment not to enforce a
 585 |     | patent against the party.
 586 |     | 
 587 |     |   If you convey a covered work, knowingly relying on a patent license,
 588 |     | and the Corresponding Source of the work is not available for anyone
 589 |     | to copy, free of charge and under the terms of this License, through a
 590 |     | publicly available network server or other readily accessible means,
 591 |     | then you must either (1) cause the Corresponding Source to be so
 592 |     | available, or (2) arrange to deprive yourself of the benefit of the
 593 |     | patent license for this particular work, or (3) arrange, in a manner
 594 |     | consistent with the requirements of this License, to extend the patent
 595 |     | license to downstream recipients.  "Knowingly relying" means you have
 596 |     | actual knowledge that, but for the patent license, your conveying the
 597 |     | covered work in a country, or your recipient's use of the covered work
 598 |     | in a country, would infringe one or more identifiable patents in that
 599 |     | country that you have reason to believe are valid.
 600 |     | 
 601 |     |   If, pursuant to or in connection with a single transaction or
 602 |     | arrangement, you convey, or propagate by procuring conveyance of, a
 603 |     | covered work, and grant a patent license to some of the parties
 604 |     | receiving the covered work authorizing them to use, propagate, modify
 605 |     | or convey a specific copy of the covered work, then the patent license
 606 |     | you grant is automatically extended to all recipients of the covered
 607 |     | work and works based on it.
 608 |     | 
 609 |     |   A patent license is "discriminatory" if it does not include within
 610 |     | the scope of its coverage, prohibits the exercise of, or is
 611 |     | conditioned on the non-exercise of one or more of the rights that are
 612 |     | specifically granted under this License.  You may not convey a covered
 613 |     | work if you are a party to an arrangement with a third party that is
 614 |     | in the business of distributing software, under which you make payment
 615 |     | to the third party based on the extent of your activity of conveying
 616 |     | the work, and under which the third party grants, to any of the
 617 |     | parties who would receive the covered work from you, a discriminatory
 618 |     | patent license (a) in connection with copies of the covered work
 619 |     | conveyed by you (or copies made from those copies), or (b) primarily
 620 |     | for and in connection with specific products or compilations that
 621 |     | contain the covered work, unless you entered into that arrangement,
 622 |     | or that patent license was granted, prior to 28 March 2007.
 623 |     | 
 624 |     |   Nothing in this License shall be construed as excluding or limiting
 625 |     | any implied license or other defenses to infringement that may
 626 |     | otherwise be available to you under applicable patent law.
 627 |     | 
 628 |     |   12. No Surrender of Others' Freedom.
 629 |     | 
 630 |     |   If conditions are imposed on you (whether by court order, agreement or
 631 |     | otherwise) that contradict the conditions of this License, they do not
 632 |     | excuse you from the conditions of this License.  If you cannot convey a
 633 |     | covered work so as to satisfy simultaneously your obligations under this
 634 |     | License and any other pertinent obligations, then as a consequence you may
 635 |     | not convey it at all.  For example, if you agree to terms that obligate you
 636 |     | to collect a royalty for further conveying from those to whom you convey
 637 |     | the Program, the only way you could satisfy both those terms and this
 638 |     | License would be to refrain entirely from conveying the Program.
 639 |     | 
 640 |     |   13. Use with the GNU Affero General Public License.
 641 |     | 
 642 |     |   Notwithstanding any other provision of this License, you have
 643 |     | permission to link or combine any covered work with a work licensed
 644 |     | under version 3 of the GNU Affero General Public License into a single
 645 |     | combined work, and to convey the resulting work.  The terms of this
 646 |     | License will continue to apply to the part which is the covered work,
 647 |     | but the special requirements of the GNU Affero General Public License,
 648 |     | section 13, concerning interaction through a network will apply to the
 649 |     | combination as such.
 650 |     | 
 651 |     |   14. Revised Versions of this License.
 652 |     | 
 653 |     |   The Free Software Foundation may publish revised and/or new versions of
 654 |     | the GNU General Public License from time to time.  Such new versions will
 655 |     | be similar in spirit to the present version, but may differ in detail to
 656 |     | address new problems or concerns.
 657 |     | 
 658 |     |   Each version is given a distinguishing version number.  If the
 659 |     | Program specifies that a certain numbered version of the GNU General
 660 |     | Public License "or any later version" applies to it, you have the
 661 |     | option of following the terms and conditions either of that numbered
 662 |     | version or of any later version published by the Free Software
 663 |     | Foundation.  If the Program does not specify a version number of the
 664 |     | GNU General Public License, you may choose any version ever published
 665 |     | by the Free Software Foundation.
 666 |     | 
 667 |     |   If the Program specifies that a proxy can decide which future
 668 |     | versions of the GNU General Public License can be used, that proxy's
 669 |     | public statement of acceptance of a version permanently authorizes you
 670 |     | to choose that version for the Program.
 671 |     | 
 672 |     |   Later license versions may give you additional or different
 673 |     | permissions.  However, no additional obligations are imposed on any
 674 |     | author or copyright holder as a result of your choosing to follow a
 675 |     | later version.
 676 |     | 
 677 |     |   15. Disclaimer of Warranty.
 678 |     | 
 679 |     |   THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
 680 |     | APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
 681 |     | HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
 682 |     | OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
 683 |     | THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 684 |     | PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
 685 |     | IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
 686 |     | ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
 687 |     | 
 688 |     |   16. Limitation of Liability.
 689 |     | 
 690 |     |   IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
 691 |     | WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
 692 |     | THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
 693 |     | GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
 694 |     | USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
 695 |     | DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
 696 |     | PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
 697 |     | EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
 698 |     | SUCH DAMAGES.
 699 |     | 
 700 |     |   17. Interpretation of Sections 15 and 16.
 701 |     | 
 702 |     |   If the disclaimer of warranty and limitation of liability provided
 703 |     | above cannot be given local legal effect according to their terms,
 704 |     | reviewing courts shall apply local law that most closely approximates
 705 |     | an absolute waiver of all civil liability in connection with the
 706 |     | Program, unless a warranty or assumption of liability accompanies a
 707 |     | copy of the Program in return for a fee.
 708 |     | 
 709 |     |                      END OF TERMS AND CONDITIONS
 710 |     | 
 711 |     |             How to Apply These Terms to Your New Programs
 712 |     | 
 713 |     |   If you develop a new program, and you want it to be of the greatest
 714 |     | possible use to the public, the best way to achieve this is to make it
 715 |     | free software which everyone can redistribute and change under these terms.
 716 |     | 
 717 |     |   To do so, attach the following notices to the program.  It is safest
 718 |     | to attach them to the start of each source file to most effectively
 719 |     | state the exclusion of warranty; and each file should have at least
 720 |     | the "copyright" line and a pointer to where the full notice is found.
 721 |     | 
 722 |     |     <one line to give the program's name and a brief idea of what it does.>
 723 |     |     Copyright (C) <year>  <name of author>
 724 |     | 
 725 |     |     This program is free software: you can redistribute it and/or modify
 726 |     |     it under the terms of the GNU General Public License as published by
 727 |     |     the Free Software Foundation, either version 3 of the License, or
 728 |     |     (at your option) any later version.
 729 |     | 
 730 |     |     This program is distributed in the hope that it will be useful,
 731 |     |     but WITHOUT ANY WARRANTY; without even the implied warranty of
 732 |     |     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 733 |     |     GNU General Public License for more details.
 734 |     | 
 735 |     |     You should have received a copy of the GNU General Public License
 736 |     |     along with this program.  If not, see <http://www.gnu.org/licenses/>.
 737 |     | 
 738 |     | Also add information on how to contact you by electronic and paper mail.
 739 |     | 
 740 |     |   If the program does terminal interaction, make it output a short
 741 |     | notice like this when it starts in an interactive mode:
 742 |     | 
 743 |     |     <program>  Copyright (C) <year>  <name of author>
 744 |     |     This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
 745 |     |     This is free software, and you are welcome to redistribute it
 746 |     |     under certain conditions; type `show c' for details.
 747 |     | 
 748 |     | The hypothetical commands `show w' and `show c' should show the appropriate
 749 |     | parts of the General Public License.  Of course, your program's commands
 750 |     | might be different; for a GUI interface, you would use an "about box".
 751 |     | 
 752 |     |   You should also get your employer (if you work as a programmer) or school,
 753 |     | if any, to sign a "copyright disclaimer" for the program, if necessary.
 754 |     | For more information on this, and how to apply and follow the GNU GPL, see
 755 |     | <http://www.gnu.org/licenses/>.
 756 |     | 
 757 |     |   The GNU General Public License does not permit incorporating your program
 758 |     | into proprietary programs.  If your program is a subroutine library, you
 759 |     | may consider it more useful to permit linking proprietary applications with
 760 |     | the library.  If this is what you want to do, use the GNU Lesser General
 761 |     | Public License instead of this License.  But first, please read
 762 |     | <http://www.gnu.org/philosophy/why-not-lgpl.html>.
 763 |     | 
 764 |     | */

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/interfaces/IERC20.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.6.2;
  3 |     | 
  4 |     | /// @dev Interface of the ERC20 standard as defined in the EIP.
  5 |     | /// @dev This includes the optional name, symbol, and decimals metadata.
  6 |     | interface IERC20 {
  7 |     |     /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).
  8 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  9 |     | 
 10 |     |     /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`
 11 |     |     /// is the new allowance.
 12 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 13 |     | 
 14 |     |     /// @notice Returns the amount of tokens in existence.
 15 |     |     function totalSupply() external view returns (uint256);
 16 |     | 
 17 |     |     /// @notice Returns the amount of tokens owned by `account`.
 18 |     |     function balanceOf(address account) external view returns (uint256);
 19 |     | 
 20 |     |     /// @notice Moves `amount` tokens from the caller's account to `to`.
 21 |     |     function transfer(address to, uint256 amount) external returns (bool);
 22 |     | 
 23 |     |     /// @notice Returns the remaining number of tokens that `spender` is allowed
 24 |     |     /// to spend on behalf of `owner`
 25 |     |     function allowance(address owner, address spender) external view returns (uint256);
 26 |     | 
 27 |     |     /// @notice Sets `amount` as the allowance of `spender` over the caller's tokens.
 28 |     |     /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729
 29 |     |     function approve(address spender, uint256 amount) external returns (bool);
 30 |     | 
 31 |     |     /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.
 32 |     |     /// `amount` is then deducted from the caller's allowance.
 33 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 34 |     | 
 35 |     |     /// @notice Returns the name of the token.
 36 |     |     function name() external view returns (string memory);
 37 |     | 
 38 |     |     /// @notice Returns the symbol of the token.
 39 |     |     function symbol() external view returns (string memory);
 40 |     | 
 41 |     |     /// @notice Returns the decimals places of the token.
 42 |     |     function decimals() external view returns (uint8);
 43 |     | }
 44 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPair.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ========================== FraxlendPair ============================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | // Sam Kazemian: https://github.com/samkazemian
  22 |     | // Travis Moore: https://github.com/FortisFortuna
  23 |     | // Jack Corddry: https://github.com/corddry
  24 |     | // Rich Gee: https://github.com/zer0blockchain
  25 |     | 
  26 |     | // ====================================================================
  27 |     | 
  28 |     | import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
  29 |     | import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  30 |     | import { IERC20Metadata } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
  31 |     | import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
  32 |     | import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";
  33 |     | import { FraxlendPairConstants } from "./FraxlendPairConstants.sol";
  34 |     | import { FraxlendPairCore } from "./FraxlendPairCore.sol";
  35 |     | import { Timelock2Step } from "./Timelock2Step.sol";
  36 |     | import { SafeERC20 } from "./libraries/SafeERC20.sol";
  37 |     | import { VaultAccount, VaultAccountingLibrary } from "./libraries/VaultAccount.sol";
  38 |     | import { IRateCalculatorV2 } from "./interfaces/IRateCalculatorV2.sol";
  39 |     | import { ISwapper } from "./interfaces/ISwapper.sol";
  40 |     | 
  41 |     | /// @title FraxlendPair
  42 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
  43 |     | /// @notice  The FraxlendPair is a lending pair that allows users to engage in lending and borrowing activities
  44 |     | contract FraxlendPair is IERC20Metadata, FraxlendPairCore {
  45 |     |     using VaultAccountingLibrary for VaultAccount;
  46 |     |     using SafeERC20 for IERC20;
  47 |     |     using SafeCast for uint256;
  48 |     | 
  49 |     |     /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)
  50 |     |     /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)
  51 |     |     /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)
  52 |     |     constructor(
  53 |     |         bytes memory _configData,
  54 |     |         bytes memory _immutables,
  55 |     |         bytes memory _customConfigData
  56 |     |     ) FraxlendPairCore(_configData, _immutables, _customConfigData) {}
  57 |     | 
  58 |     |     // ============================================================================================
  59 |     |     // ERC20 Metadata
  60 |     |     // ============================================================================================
  61 |     | 
  62 |     |     function name() public view override(ERC20, IERC20Metadata) returns (string memory) {
  63 |     |         return nameOfContract;
  64 |     |     }
  65 |     | 
  66 |     |     function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {
  67 |     |         return symbolOfContract;
  68 |     |     }
  69 |     | 
  70 |     |     function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {
  71 |     |         return decimalsOfContract;
  72 |     |     }
  73 |     | 
  74 |     |     // totalSupply for fToken ERC20 compatibility
  75 |     |     function totalSupply() public view override(ERC20, IERC20) returns (uint256) {
  76 |     |         return totalAsset.shares;
  77 |     |     }
  78 |     | 
  79 |     |     // ============================================================================================
  80 |     |     // Functions: Helpers
  81 |     |     // ============================================================================================
  82 |     | 
  83 |     |     function asset() external view returns (address) {
  84 |     |         return address(assetContract);
  85 |     |     }
  86 |     | 
  87 |     |     function getConstants()
  88 |     |         external
  89 |     |         pure
  90 |     |         returns (
  91 |     |             uint256 _LTV_PRECISION,
  92 |     |             uint256 _LIQ_PRECISION,
  93 |     |             uint256 _UTIL_PREC,
  94 |     |             uint256 _FEE_PRECISION,
  95 |     |             uint256 _EXCHANGE_PRECISION,
  96 |     |             uint256 _DEVIATION_PRECISION,
  97 |     |             uint256 _RATE_PRECISION,
  98 |     |             uint256 _MAX_PROTOCOL_FEE
  99 |     |         )
 100 |     |     {
 101 |     |         _LTV_PRECISION = LTV_PRECISION;
 102 |     |         _LIQ_PRECISION = LIQ_PRECISION;
 103 |     |         _UTIL_PREC = UTIL_PREC;
 104 |     |         _FEE_PRECISION = FEE_PRECISION;
 105 |     |         _EXCHANGE_PRECISION = EXCHANGE_PRECISION;
 106 |     |         _DEVIATION_PRECISION = DEVIATION_PRECISION;
 107 |     |         _RATE_PRECISION = RATE_PRECISION;
 108 |     |         _MAX_PROTOCOL_FEE = MAX_PROTOCOL_FEE;
 109 |     |     }
 110 |     | 
 111 |     |     /// @notice The ```getUserSnapshot``` function gets user level accounting data
 112 |     |     /// @param _address The user address
 113 |     |     /// @return _userAssetShares The user fToken balance
 114 |     |     /// @return _userBorrowShares The user borrow shares
 115 |     |     /// @return _userCollateralBalance The user collateral balance
 116 |     |     function getUserSnapshot(
 117 |     |         address _address
 118 |     |     ) external view returns (uint256 _userAssetShares, uint256 _userBorrowShares, uint256 _userCollateralBalance) {
 119 |     |         _userAssetShares = balanceOf(_address);
 120 |     |         _userBorrowShares = userBorrowShares[_address];
 121 |     |         _userCollateralBalance = userCollateralBalance[_address];
 122 |     |     }
 123 |     | 
 124 |     |     /// @notice The ```getPairAccounting``` function gets all pair level accounting numbers
 125 |     |     /// @return _totalAssetAmount Total assets deposited and interest accrued, total claims
 126 |     |     /// @return _totalAssetShares Total fTokens
 127 |     |     /// @return _totalBorrowAmount Total borrows
 128 |     |     /// @return _totalBorrowShares Total borrow shares
 129 |     |     /// @return _totalCollateral Total collateral
 130 |     |     function getPairAccounting()
 131 |     |         external
 132 |     |         view
 133 |     |         returns (
 134 |     |             uint128 _totalAssetAmount,
 135 |     |             uint128 _totalAssetShares,
 136 |     |             uint128 _totalBorrowAmount,
 137 |     |             uint128 _totalBorrowShares,
 138 |     |             uint256 _totalCollateral
 139 |     |         )
 140 |     |     {
 141 |     |         (, , , , VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow) = previewAddInterest();
 142 |     |         _totalAssetAmount = _totalAsset.totalAmount(address(externalAssetVault)).toUint128();
 143 |     |         _totalAssetShares = _totalAsset.shares;
 144 |     |         _totalBorrowAmount = _totalBorrow.amount;
 145 |     |         _totalBorrowShares = _totalBorrow.shares;
 146 |     |         _totalCollateral = totalCollateral;
 147 |     |     }
 148 |     | 
 149 |     |     /// @notice The ```toBorrowShares``` function converts a given amount of borrow debt into the number of shares
 150 |     |     /// @param _amount Amount of borrow
 151 |     |     /// @param _roundUp Whether to roundup during division
 152 |     |     /// @param _previewInterest Whether to simulate interest accrual
 153 |     |     /// @return _shares The number of shares
 154 |     |     function toBorrowShares(
 155 |     |         uint256 _amount,
 156 |     |         bool _roundUp,
 157 |     |         bool _previewInterest
 158 |     |     ) external view returns (uint256 _shares) {
 159 |     |         if (_previewInterest) {
 160 |     |             (, , , , , VaultAccount memory _totalBorrow) = previewAddInterest();
 161 |     |             _shares = _totalBorrow.toShares(_amount, _roundUp);
 162 |     |         } else {
 163 |     |             _shares = totalBorrow.toShares(_amount, _roundUp);
 164 |     |         }
 165 |     |     }
 166 |     | 
 167 |     |     /// @notice The ```toBorrowAmount``` function converts a given amount of borrow debt into the number of shares
 168 |     |     /// @param _shares Shares of borrow
 169 |     |     /// @param _roundUp Whether to roundup during division
 170 |     |     /// @param _previewInterest Whether to simulate interest accrual
 171 |     |     /// @return _amount The amount of asset
 172 |     |     function toBorrowAmount(
 173 |     |         uint256 _shares,
 174 |     |         bool _roundUp,
 175 |     |         bool _previewInterest
 176 |     |     ) external view returns (uint256 _amount) {
 177 |     |         if (_previewInterest) {
 178 |     |             (, , , , , VaultAccount memory _totalBorrow) = previewAddInterest();
 179 |     |             _amount = _totalBorrow.toAmount(_shares, _roundUp);
 180 |     |         } else {
 181 |     |             _amount = totalBorrow.toAmount(_shares, _roundUp);
 182 |     |         }
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice The ```toAssetAmount``` function converts a given number of shares to an asset amount
 186 |     |     /// @param _shares Shares of asset (fToken)
 187 |     |     /// @param _roundUp Whether to round up after division
 188 |     |     /// @param _previewInterest Whether to preview interest accrual before calculation
 189 |     |     /// @return _amount The amount of asset
 190 |     |     function toAssetAmount(
 191 |     |         uint256 _shares,
 192 |     |         bool _roundUp,
 193 |     |         bool _previewInterest
 194 |     |     ) public view returns (uint256 _amount) {
 195 |     |         if (_previewInterest) {
 196 |     |             (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
 197 |     |             _amount = _totalAsset.toAmount(_shares, _roundUp);
 198 |     |         } else {
 199 |     |             _amount = totalAsset.toAmount(_shares, _roundUp);
 200 |     |         }
 201 |     |     }
 202 |     | 
 203 |     |     /// @notice The ```toAssetShares``` function converts a given asset amount to a number of asset shares (fTokens)
 204 |     |     /// @param _amount The amount of asset
 205 |     |     /// @param _roundUp Whether to round up after division
 206 |     |     /// @param _previewInterest Whether to preview interest accrual before calculation
 207 |     |     /// @return _shares The number of shares (fTokens)
 208 |     |     function toAssetShares(
 209 |     |         uint256 _amount,
 210 |     |         bool _roundUp,
 211 |     |         bool _previewInterest
 212 |     |     ) public view returns (uint256 _shares) {
 213 |     |         if (_previewInterest) {
 214 |     |             (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
 215 |     |             _shares = _totalAsset.toShares(_amount, _roundUp);
 216 |     |         } else {
 217 |     |             _shares = totalAsset.toShares(_amount, _roundUp);
 218 |     |         }
 219 |     |     }
 220 |     | 
 221 |     |     function convertToAssets(uint256 _shares) external view returns (uint256 _assets) {
 222 |     |         _assets = toAssetAmount(_shares, false, true);
 223 |     |     }
 224 |     | 
 225 |     |     function convertToShares(uint256 _assets) external view returns (uint256 _shares) {
 226 |     |         _shares = toAssetShares(_assets, false, true);
 227 |     |     }
 228 |     | 
 229 |     |     function pricePerShare() external view returns (uint256 _amount) {
 230 |     |         _amount = toAssetAmount(1e18, false, true);
 231 |     |     }
 232 |     | 
 233 |     |     function totalAssets() external view returns (uint256) {
 234 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
 235 |     |         return _totalAsset.totalAmount(address(externalAssetVault));
 236 |     |     }
 237 |     | 
 238 |     |     function maxDeposit(address) public view returns (uint256 _maxAssets) {
 239 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
 240 |     |         _maxAssets = _totalAsset.totalAmount(address(externalAssetVault)) >= depositLimit ? 0 : depositLimit - _totalAsset.totalAmount(address(externalAssetVault));
 241 |     |     }
 242 |     | 
 243 |     |     function maxMint(address) external view returns (uint256 _maxShares) {
 244 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
 245 |     |         uint256 _maxDeposit = _totalAsset.totalAmount(address(externalAssetVault)) >= depositLimit ? 0 : depositLimit - _totalAsset.totalAmount(address(externalAssetVault));
 246 |     |         _maxShares = _totalAsset.toShares(_maxDeposit, false);
 247 |     |     }
 248 |     | 
 249 |     |     function maxWithdraw(address _owner) external view returns (uint256 _maxAssets) {
 250 |     |         if (isWithdrawPaused) return 0;
 251 |     |         (
 252 |     |             ,
 253 |     |             ,
 254 |     |             uint256 _feesShare,
 255 |     |             ,
 256 |     |             VaultAccount memory _totalAsset,
 257 |     |             VaultAccount memory _totalBorrow
 258 |     |         ) = previewAddInterest();
 259 |     |         // Get the owner balance and include the fees share if owner is this contract
 260 |     |         uint256 _ownerBalance = _owner == address(this) ? balanceOf(_owner) + _feesShare : balanceOf(_owner);
 261 |     | 
 262 |     |         // Return the lower of total assets in contract or total assets available to _owner
 263 |     |         uint256 _totalAssetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow, true);
 264 |     |         uint256 _totalUserWithdraw = _totalAsset.toAmount(_ownerBalance, false);
 265 |     |         _maxAssets = _totalAssetsAvailable < _totalUserWithdraw ? _totalAssetsAvailable : _totalUserWithdraw;
 266 |     |     }
 267 |     | 
 268 |     |     function maxRedeem(address _owner) external view returns (uint256 _maxShares) {
 269 |     |         if (isWithdrawPaused) return 0;
 270 |     |         (
 271 |     |             ,
 272 |     |             ,
 273 |     |             uint256 _feesShare,
 274 |     |             ,
 275 |     |             VaultAccount memory _totalAsset,
 276 |     |             VaultAccount memory _totalBorrow
 277 |     |         ) = previewAddInterest();
 278 |     | 
 279 |     |         // Calculate the total shares available
 280 |     |         uint256 _totalAssetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow, true);
 281 |     |         uint256 _totalSharesAvailable = _totalAsset.toShares(_totalAssetsAvailable, false);
 282 |     | 
 283 |     |         // Get the owner balance and include the fees share if owner is this contract
 284 |     |         uint256 _ownerBalance = _owner == address(this) ? balanceOf(_owner) + _feesShare : balanceOf(_owner);
 285 |     |         _maxShares = _totalSharesAvailable < _ownerBalance ? _totalSharesAvailable : _ownerBalance;
 286 |     |     }
 287 |     | 
 288 |     |     // ============================================================================================
 289 |     |     // Functions: Configuration
 290 |     |     // ============================================================================================
 291 |     | 
 292 |     |     bool public isOracleSetterRevoked;
 293 |     | 
 294 |     |     /// @notice The ```RevokeOracleSetter``` event is emitted when the oracle setter is revoked
 295 |     |     event RevokeOracleInfoSetter();
 296 |     | 
 297 |     |     /// @notice The ```revokeOracleSetter``` function revokes the oracle setter
 298 |     |     function revokeOracleInfoSetter() external {
 299 |     |         _requireTimelock();
 300 |     |         isOracleSetterRevoked = true;
 301 |     |         emit RevokeOracleInfoSetter();
 302 |     |     }
 303 |     | 
 304 |     |     /// @notice The ```SetOracleInfo``` event is emitted when the oracle info (address and max deviation) is set
 305 |     |     /// @param oldOracle The old oracle address
 306 |     |     /// @param oldMaxOracleDeviation The old max oracle deviation
 307 |     |     /// @param newOracle The new oracle address
 308 |     |     /// @param newMaxOracleDeviation The new max oracle deviation
 309 |     |     event SetOracleInfo(
 310 |     |         address oldOracle,
 311 |     |         uint32 oldMaxOracleDeviation,
 312 |     |         address newOracle,
 313 |     |         uint32 newMaxOracleDeviation
 314 |     |     );
 315 |     | 
 316 |     |     /// @notice The ```setOracleInfo``` function sets the oracle data
 317 |     |     /// @param _newOracle The new oracle address
 318 |     |     /// @param _newMaxOracleDeviation The new max oracle deviation
 319 |     |     function setOracle(address _newOracle, uint32 _newMaxOracleDeviation) external {
 320 |     |         _requireTimelock();
 321 |     |         if (isOracleSetterRevoked) revert SetterRevoked();
 322 |     |         ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;
 323 |     |         emit SetOracleInfo(
 324 |     |             _exchangeRateInfo.oracle,
 325 |     |             _exchangeRateInfo.maxOracleDeviation,
 326 |     |             _newOracle,
 327 |     |             _newMaxOracleDeviation
 328 |     |         );
 329 |     |         _exchangeRateInfo.oracle = _newOracle;
 330 |     |         _exchangeRateInfo.maxOracleDeviation = _newMaxOracleDeviation;
 331 |     |         exchangeRateInfo = _exchangeRateInfo;
 332 |     |     }
 333 |     | 
 334 |     |     bool public isMaxLTVSetterRevoked;
 335 |     | 
 336 |     |     /// @notice The ```RevokeMaxLTVSetter``` event is emitted when the max LTV setter is revoked
 337 |     |     event RevokeMaxLTVSetter();
 338 |     | 
 339 |     |     /// @notice The ```revokeMaxLTVSetter``` function revokes the max LTV setter
 340 |     |     function revokeMaxLTVSetter() external {
 341 |     |         _requireTimelock();
 342 |     |         isMaxLTVSetterRevoked = true;
 343 |     |         emit RevokeMaxLTVSetter();
 344 |     |     }
 345 |     | 
 346 |     |     /// @notice The ```SetMaxLTV``` event is emitted when the max LTV is set
 347 |     |     /// @param oldMaxLTV The old max LTV
 348 |     |     /// @param newMaxLTV The new max LTV
 349 |     |     event SetMaxLTV(uint256 oldMaxLTV, uint256 newMaxLTV);
 350 |     | 
 351 |     |     /// @notice The ```setMaxLTV``` function sets the max LTV
 352 |     |     /// @param _newMaxLTV The new max LTV
 353 |     |     function setMaxLTV(uint256 _newMaxLTV) external {
 354 |     |         _requireTimelock();
 355 |     |         if (isMaxLTVSetterRevoked) revert SetterRevoked();
 356 |     |         emit SetMaxLTV(maxLTV, _newMaxLTV);
 357 |     |         maxLTV = _newMaxLTV;
 358 |     |     }
 359 |     | 
 360 |     |     bool public isRateContractSetterRevoked;
 361 |     | 
 362 |     |     /// @notice The ```RevokeRateContractSetter``` event is emitted when the rate contract setter is revoked
 363 |     |     event RevokeRateContractSetter();
 364 |     | 
 365 |     |     /// @notice The ```revokeRateContractSetter``` function revokes the rate contract setter
 366 |     |     function revokeRateContractSetter() external {
 367 |     |         _requireTimelock();
 368 |     |         isRateContractSetterRevoked = true;
 369 |     |         emit RevokeRateContractSetter();
 370 |     |     }
 371 |     | 
 372 |     |     /// @notice The ```SetRateContract``` event is emitted when the rate contract is set
 373 |     |     /// @param oldRateContract The old rate contract
 374 |     |     /// @param newRateContract The new rate contract
 375 |     |     event SetRateContract(address oldRateContract, address newRateContract);
 376 |     | 
 377 |     |     /// @notice The ```setRateContract``` function sets the rate contract address
 378 |     |     /// @param _newRateContract The new rate contract address
 379 |     |     function setRateContract(address _newRateContract) external {
 380 |     |         _requireTimelock();
 381 |     |         if (isRateContractSetterRevoked) revert SetterRevoked();
 382 |     |         emit SetRateContract(address(rateContract), _newRateContract);
 383 |     |         rateContract = IRateCalculatorV2(_newRateContract);
 384 |     |     }
 385 |     | 
 386 |     |     bool public isLiquidationFeeSetterRevoked;
 387 |     | 
 388 |     |     /// @notice The ```RevokeLiquidationFeeSetter``` event is emitted when the liquidation fee setter is revoked
 389 |     |     event RevokeLiquidationFeeSetter();
 390 |     | 
 391 |     |     /// @notice The ```revokeLiquidationFeeSetter``` function revokes the liquidation fee setter
 392 |     |     function revokeLiquidationFeeSetter() external {
 393 |     |         _requireTimelock();
 394 |     |         isLiquidationFeeSetterRevoked = true;
 395 |     |         emit RevokeLiquidationFeeSetter();
 396 |     |     }
 397 |     | 
 398 |     |     /// @notice The ```SetLiquidationFees``` event is emitted when the liquidation fees are set
 399 |     |     /// @param oldCleanLiquidationFee The old clean liquidation fee
 400 |     |     /// @param oldDirtyLiquidationFee The old dirty liquidation fee
 401 |     |     /// @param oldProtocolLiquidationFee The old protocol liquidation fee
 402 |     |     /// @param newCleanLiquidationFee The new clean liquidation fee
 403 |     |     /// @param newDirtyLiquidationFee The new dirty liquidation fee
 404 |     |     /// @param newProtocolLiquidationFee The new protocol liquidation fee
 405 |     |     event SetLiquidationFees(
 406 |     |         uint256 oldCleanLiquidationFee,
 407 |     |         uint256 oldDirtyLiquidationFee,
 408 |     |         uint256 oldProtocolLiquidationFee,
 409 |     |         uint256 newCleanLiquidationFee,
 410 |     |         uint256 newDirtyLiquidationFee,
 411 |     |         uint256 newProtocolLiquidationFee
 412 |     |     );
 413 |     | 
 414 |     |     /// @notice The ```setLiquidationFees``` function sets the liquidation fees
 415 |     |     /// @param _newCleanLiquidationFee The new clean liquidation fee
 416 |     |     /// @param _newDirtyLiquidationFee The new dirty liquidation fee
 417 |     |     function setLiquidationFees(
 418 |     |         uint256 _newCleanLiquidationFee,
 419 |     |         uint256 _newDirtyLiquidationFee,
 420 |     |         uint256 _newProtocolLiquidationFee
 421 |     |     ) external {
 422 |     |         _requireTimelock();
 423 |     |         if (isLiquidationFeeSetterRevoked) revert SetterRevoked();
 424 |     |         emit SetLiquidationFees(
 425 |     |             cleanLiquidationFee,
 426 |     |             dirtyLiquidationFee,
 427 |     |             protocolLiquidationFee,
 428 |     |             _newCleanLiquidationFee,
 429 |     |             _newDirtyLiquidationFee,
 430 |     |             _newProtocolLiquidationFee
 431 |     |         );
 432 |     |         cleanLiquidationFee = _newCleanLiquidationFee;
 433 |     |         dirtyLiquidationFee = _newDirtyLiquidationFee;
 434 |     |         protocolLiquidationFee = _newProtocolLiquidationFee;
 435 |     |     }
 436 |     | 
 437 |     |     /// @notice The ```ChangeFee``` event first when the fee is changed
 438 |     |     /// @param newFee The new fee
 439 |     |     event ChangeFee(uint32 newFee);
 440 |     | 
 441 |     |     /// @notice The ```changeFee``` function changes the protocol fee, max 50%
 442 |     |     /// @param _newFee The new fee
 443 |     |     function changeFee(uint32 _newFee) external {
 444 |     |         _requireTimelock();
 445 |     |         if (isInterestPaused) revert InterestPaused();
 446 |     |         if (_newFee > MAX_PROTOCOL_FEE) {
 447 |     |             revert BadProtocolFee();
 448 |     |         }
 449 |     |         _addInterest();
 450 |     |         currentRateInfo.feeToProtocolRate = _newFee;
 451 |     |         emit ChangeFee(_newFee);
 452 |     |     }
 453 |     | 
 454 |     |     /// @notice The ```WithdrawFees``` event fires when the fees are withdrawn
 455 |     |     /// @param shares Number of shares (fTokens) redeemed
 456 |     |     /// @param recipient To whom the assets were sent
 457 |     |     /// @param amountToTransfer The amount of fees redeemed
 458 |     |     event WithdrawFees(uint128 shares, address recipient, uint256 amountToTransfer, uint256 collateralAmount);
 459 |     | 
 460 |     |     /// @notice The ```withdrawFees``` function withdraws fees accumulated
 461 |     |     /// @param _shares Number of fTokens to redeem
 462 |     |     /// @param _recipient Address to send the assets
 463 |     |     /// @return _amountToTransfer Amount of assets sent to recipient
 464 |     |     function withdrawFees(uint128 _shares, address _recipient) external onlyOwner returns (uint256 _amountToTransfer) {
 465 |     |         if (_recipient == address(0)) revert InvalidReceiver();
 466 |     | 
 467 |     |         // Grab some data from state to save gas
 468 |     |         VaultAccount memory _totalAsset = totalAsset;
 469 |     | 
 470 |     |         // Take all available if 0 value passed
 471 |     |         if (_shares == 0) _shares = balanceOf(address(this)).toUint128();
 472 |     | 
 473 |     |         // We must calculate this before we subtract from _totalAsset or invoke _burn
 474 |     |         _amountToTransfer = _totalAsset.toAmount(_shares, true);
 475 |     | 
 476 |     |         _approve(address(this), msg.sender, _shares);
 477 |     |         _redeem(_totalAsset, _amountToTransfer.toUint128(), _shares, _recipient, address(this), false);
 478 |     |         uint256 _collateralAmount = userCollateralBalance[address(this)];
 479 |     |         _removeCollateral(_collateralAmount, _recipient, address(this));
 480 |     |         emit WithdrawFees(_shares, _recipient, _amountToTransfer, _collateralAmount);
 481 |     |     }
 482 |     | 
 483 |     |     /// @notice The ```SetSwapper``` event fires whenever a swapper is black or whitelisted
 484 |     |     /// @param swapper The swapper address
 485 |     |     /// @param approval The approval
 486 |     |     event SetSwapper(address swapper, bool approval);
 487 |     | 
 488 |     |     /// @notice The ```setSwapper``` function is called to black or whitelist a given swapper address
 489 |     |     /// @dev
 490 |     |     /// @param _swapper The swapper address
 491 |     |     /// @param _approval The approval
 492 |     |     function setSwapper(address _swapper, bool _approval) external onlyOwner {
 493 |     |         swappers[_swapper] = _approval;
 494 |     |         emit SetSwapper(_swapper, _approval);
 495 |     |     }
 496 |     | 
 497 |     |     // ============================================================================================
 498 |     |     // Functions: Access Control
 499 |     |     // ============================================================================================
 500 |     | 
 501 |     |     /// @notice The ```pause``` function is called to pause all contract functionality
 502 |     |     function pause() external {
 503 |     |         _requireProtocolOrOwner();
 504 |     |         if (!isBorrowAccessControlRevoked) _setBorrowLimit(0);
 505 |     |         if (!isDepositAccessControlRevoked) _setDepositLimit(0);
 506 |     |         if (!isRepayAccessControlRevoked) _pauseRepay(true);
 507 |     |         if (!isWithdrawAccessControlRevoked) _pauseWithdraw(true);
 508 |     |         if (!isLiquidateAccessControlRevoked) _pauseLiquidate(true);
 509 |     |         if (!isInterestAccessControlRevoked) {
 510 |     |             _addInterest();
 511 |     |             _pauseInterest(true);
 512 |     |         }
 513 |     |     }
 514 |     | 
 515 |     |     /// @notice The ```unpause``` function is called to unpause all contract functionality
 516 |     |     function unpause() external {
 517 |     |         _requireTimelockOrOwner();
 518 |     |         if (!isBorrowAccessControlRevoked) _setBorrowLimit(type(uint256).max);
 519 |     |         if (!isDepositAccessControlRevoked) _setDepositLimit(type(uint256).max);
 520 |     |         if (!isRepayAccessControlRevoked) _pauseRepay(false);
 521 |     |         if (!isWithdrawAccessControlRevoked) _pauseWithdraw(false);
 522 |     |         if (!isLiquidateAccessControlRevoked) _pauseLiquidate(false);
 523 |     |         if (!isInterestAccessControlRevoked) {
 524 |     |             _addInterest();
 525 |     |             _pauseInterest(false);
 526 |     |         }
 527 |     |     }
 528 |     | 
 529 |     |     /// @notice The ```pauseBorrow``` function sets borrow limit to 0
 530 |     |     function pauseBorrow() external {
 531 |     |         _requireProtocolOrOwner();
 532 |     |         if (isBorrowAccessControlRevoked) revert AccessControlRevoked();
 533 |     |         _setBorrowLimit(0);
 534 |     |     }
 535 |     | 
 536 |     |     /// @notice The ```setBorrowLimit``` function sets the borrow limit
 537 |     |     /// @param _limit The new borrow limit
 538 |     |     function setBorrowLimit(uint256 _limit) external {
 539 |     |         _requireTimelockOrOwner();
 540 |     |         if (isBorrowAccessControlRevoked) revert AccessControlRevoked();
 541 |     |         _setBorrowLimit(_limit);
 542 |     |     }
 543 |     | 
 544 |     |     /// @notice The ```revokeBorrowLimitAccessControl``` function revokes borrow limit access control
 545 |     |     /// @param _borrowLimit The new borrow limit
 546 |     |     function revokeBorrowLimitAccessControl(uint256 _borrowLimit) external {
 547 |     |         _requireTimelock();
 548 |     |         _revokeBorrowAccessControl(_borrowLimit);
 549 |     |     }
 550 |     | 
 551 |     |     /// @notice The ```pauseDeposit``` function pauses deposit functionality
 552 |     |     function pauseDeposit() external {
 553 |     |         _requireProtocolOrOwner();
 554 |     |         if (isDepositAccessControlRevoked) revert AccessControlRevoked();
 555 |     |         _setDepositLimit(0);
 556 |     |     }
 557 |     | 
 558 |     |     /// @notice The ```setDepositLimit``` function sets the deposit limit
 559 |     |     /// @param _limit The new deposit limit
 560 |     |     function setDepositLimit(uint256 _limit) external {
 561 |     |         _requireTimelockOrOwner();
 562 |     |         if (isDepositAccessControlRevoked) revert AccessControlRevoked();
 563 |     |         _setDepositLimit(_limit);
 564 |     |     }
 565 |     | 
 566 |     |     /// @notice The ```revokeDepositLimitAccessControl``` function revokes deposit limit access control
 567 |     |     /// @param _depositLimit The new deposit limit
 568 |     |     function revokeDepositLimitAccessControl(uint256 _depositLimit) external {
 569 |     |         _requireTimelock();
 570 |     |         _revokeDepositAccessControl(_depositLimit);
 571 |     |     }
 572 |     | 
 573 |     |     /// @notice The ```pauseRepay``` function pauses repay functionality
 574 |     |     /// @param _isPaused The new pause state
 575 |     |     function pauseRepay(bool _isPaused) external {
 576 |     |         if (_isPaused) {
 577 |     |             _requireProtocolOrOwner();
 578 |     |         } else {
 579 |     |             _requireTimelockOrOwner();
 580 |     |         }
 581 |     |         if (isRepayAccessControlRevoked) revert AccessControlRevoked();
 582 |     |         _pauseRepay(_isPaused);
 583 |     |     }
 584 |     | 
 585 |     |     /// @notice The ```revokeRepayAccessControl``` function revokes repay access control
 586 |     |     function revokeRepayAccessControl() external {
 587 |     |         _requireTimelock();
 588 |     |         _revokeRepayAccessControl();
 589 |     |     }
 590 |     | 
 591 |     |     /// @notice The ```pauseWithdraw``` function pauses withdraw functionality
 592 |     |     /// @param _isPaused The new pause state
 593 |     |     function pauseWithdraw(bool _isPaused) external {
 594 |     |         if (_isPaused) {
 595 |     |             _requireProtocolOrOwner();
 596 |     |         } else {
 597 |     |             _requireTimelockOrOwner();
 598 |     |         }
 599 |     |         if (isWithdrawAccessControlRevoked) revert AccessControlRevoked();
 600 |     |         _pauseWithdraw(_isPaused);
 601 |     |     }
 602 |     | 
 603 |     |     /// @notice The ```revokeWithdrawAccessControl``` function revokes withdraw access control
 604 |     |     function revokeWithdrawAccessControl() external {
 605 |     |         _requireTimelock();
 606 |     |         _revokeWithdrawAccessControl();
 607 |     |     }
 608 |     | 
 609 |     |     /// @notice The ```pauseLiquidate``` function pauses liquidate functionality
 610 |     |     /// @param _isPaused The new pause state
 611 |     |     function pauseLiquidate(bool _isPaused) external {
 612 |     |         if (_isPaused) {
 613 |     |             _requireProtocolOrOwner();
 614 |     |         } else {
 615 |     |             _requireTimelockOrOwner();
 616 |     |         }
 617 |     |         if (isLiquidateAccessControlRevoked) revert AccessControlRevoked();
 618 |     |         _pauseLiquidate(_isPaused);
 619 |     |     }
 620 |     | 
 621 |     |     /// @notice The ```revokeLiquidateAccessControl``` function revokes liquidate access control
 622 |     |     function revokeLiquidateAccessControl() external {
 623 |     |         _requireTimelock();
 624 |     |         _revokeLiquidateAccessControl();
 625 |     |     }
 626 |     | 
 627 |     |     /// @notice The ```pauseInterest``` function pauses interest functionality
 628 |     |     /// @param _isPaused The new pause state
 629 |     |     function pauseInterest(bool _isPaused) external {
 630 |     |         if (_isPaused) {
 631 |     |             _requireProtocolOrOwner();
 632 |     |         } else {
 633 |     |             _requireTimelockOrOwner();
 634 |     |         }
 635 |     |         if (isInterestAccessControlRevoked) revert AccessControlRevoked();
 636 |     |         // Resets the lastTimestamp which has the effect of no interest accruing over the pause period
 637 |     |         _addInterest();
 638 |     |         _pauseInterest(_isPaused);
 639 |     |     }
 640 |     | 
 641 |     |     /// @notice The ```revokeInterestAccessControl``` function revokes interest access control
 642 |     |     function revokeInterestAccessControl() external {
 643 |     |         _requireTimelock();
 644 |     |         _revokeInterestAccessControl();
 645 |     |     }
 646 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairAccessControl.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ==================== FraxlendPairAccessControl =====================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | 
  22 |     | // ====================================================================
  23 |     | 
  24 |     | import { Ownable2Step, Ownable } from "@openzeppelin/contracts/access/Ownable2Step.sol";
  25 |     | import { Timelock2Step } from "./Timelock2Step.sol";
  26 |     | import { FraxlendPairAccessControlErrors } from "./FraxlendPairAccessControlErrors.sol";
  27 |     | import { IERC4626Extended } from './interfaces/IERC4626Extended.sol';
  28 |     | 
  29 |     | /// @title FraxlendPairAccessControl
  30 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
  31 |     | /// @notice  An abstract contract which contains the access control logic for FraxlendPair
  32 |     | abstract contract FraxlendPairAccessControl is Timelock2Step, Ownable2Step, FraxlendPairAccessControlErrors {
  33 |     |     // Deployer
  34 |     |     address public immutable DEPLOYER_ADDRESS;
  35 |     | 
  36 |     |     // Admin contracts
  37 |     |     address public circuitBreakerAddress;
  38 |     | 
  39 |     |     // External asset vault
  40 |     |     IERC4626Extended public externalAssetVault;
  41 |     | 
  42 |     |     // access control
  43 |     |     uint256 public borrowLimit = type(uint256).max;
  44 |     |     bool public isBorrowAccessControlRevoked;
  45 |     | 
  46 |     |     uint256 public depositLimit = type(uint256).max;
  47 |     |     bool public isDepositAccessControlRevoked;
  48 |     | 
  49 |     |     bool public isRepayPaused;
  50 |     |     bool public isRepayAccessControlRevoked;
  51 |     | 
  52 |     |     bool public isWithdrawPaused;
  53 |     |     bool public isWithdrawAccessControlRevoked;
  54 |     | 
  55 |     |     bool public isLiquidatePaused;
  56 |     |     bool public isLiquidateAccessControlRevoked;
  57 |     | 
  58 |     |     bool public isInterestPaused;
  59 |     |     bool public isInterestAccessControlRevoked;
  60 |     | 
  61 |     |     /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)
  62 |     |     constructor(bytes memory _immutables) Timelock2Step() Ownable2Step() {
  63 |     |         // Handle Immutables Configuration
  64 |     |         (address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress) = abi.decode(
  65 |     |             _immutables,
  66 |     |             (address, address, address)
  67 |     |         );
  68 |     |         _setTimelock(_timelockAddress);
  69 |     |         _transferOwnership(_comptrollerAddress);
  70 |     | 
  71 |     |         // Deployer contract
  72 |     |         DEPLOYER_ADDRESS = msg.sender;
  73 |     |         circuitBreakerAddress = _circuitBreakerAddress;
  74 |     |     }
  75 |     | 
  76 |     |     // ============================================================================================
  77 |     |     // Functions: Access Control
  78 |     |     // ============================================================================================
  79 |     | 
  80 |     |     function _requireProtocolOrOwner() internal view {
  81 |     |         if (
  82 |     |             msg.sender != circuitBreakerAddress &&
  83 |     |             msg.sender != owner() &&
  84 |     |             msg.sender != DEPLOYER_ADDRESS &&
  85 |     |             msg.sender != timelockAddress
  86 |     |         ) {
  87 |     |             revert OnlyProtocolOrOwner();
  88 |     |         }
  89 |     |     }
  90 |     | 
  91 |     |     function _requireTimelockOrOwner() internal view {
  92 |     |         if (msg.sender != owner() && msg.sender != timelockAddress) {
  93 |     |             revert OnlyTimelockOrOwner();
  94 |     |         }
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice The ```RevokeBorrowAccessControl``` event is emitted when access to borrow limit is revoked
  98 |     |     /// @param borrowLimit The final permanent borrow limit
  99 |     |     event RevokeBorrowAccessControl(uint256 borrowLimit);
 100 |     | 
 101 |     |     function _revokeBorrowAccessControl(uint256 _borrowLimit) internal {
 102 |     |         isBorrowAccessControlRevoked = true;
 103 |     |         borrowLimit = _borrowLimit;
 104 |     |         emit RevokeBorrowAccessControl(_borrowLimit);
 105 |     |     }
 106 |     | 
 107 |     |     /// @notice The ```SetBorrowLimit``` event is emitted when the borrow limit is set
 108 |     |     /// @param limit The new borrow limit
 109 |     |     event SetBorrowLimit(uint256 limit);
 110 |     | 
 111 |     |     function _setBorrowLimit(uint256 _limit) internal {
 112 |     |         borrowLimit = _limit;
 113 |     |         emit SetBorrowLimit(_limit);
 114 |     |     }
 115 |     | 
 116 |     |     /// @notice The ```RevokeDepositAccessControl``` event is emitted when access to deposit limit is revoked
 117 |     |     /// @param depositLimit The final permanent deposit limit
 118 |     |     event RevokeDepositAccessControl(uint256 depositLimit);
 119 |     | 
 120 |     |     function _revokeDepositAccessControl(uint256 _depositLimit) internal {
 121 |     |         isDepositAccessControlRevoked = true;
 122 |     |         depositLimit = _depositLimit;
 123 |     |         emit RevokeDepositAccessControl(_depositLimit);
 124 |     |     }
 125 |     | 
 126 |     |     /// @notice The ```SetDepositLimit``` event is emitted when the deposit limit is set
 127 |     |     /// @param limit The new deposit limit
 128 |     |     event SetDepositLimit(uint256 limit);
 129 |     | 
 130 |     |     function _setDepositLimit(uint256 _limit) internal {
 131 |     |         depositLimit = _limit;
 132 |     |         emit SetDepositLimit(_limit);
 133 |     |     }
 134 |     | 
 135 |     |     /// @notice The ```RevokeRepayAccessControl``` event is emitted when repay access control is revoked
 136 |     |     event RevokeRepayAccessControl();
 137 |     | 
 138 |     |     function _revokeRepayAccessControl() internal {
 139 |     |         isRepayAccessControlRevoked = true;
 140 |     |         emit RevokeRepayAccessControl();
 141 |     |     }
 142 |     | 
 143 |     |     /// @notice The ```PauseRepay``` event is emitted when repay is paused or unpaused
 144 |     |     /// @param isPaused The new paused state
 145 |     |     event PauseRepay(bool isPaused);
 146 |     | 
 147 |     |     function _pauseRepay(bool _isPaused) internal {
 148 |     |         isRepayPaused = _isPaused;
 149 |     |         emit PauseRepay(_isPaused);
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice The ```RevokeWithdrawAccessControl``` event is emitted when withdraw access control is revoked
 153 |     |     event RevokeWithdrawAccessControl();
 154 |     | 
 155 |     |     function _revokeWithdrawAccessControl() internal {
 156 |     |         isWithdrawAccessControlRevoked = true;
 157 |     |         emit RevokeWithdrawAccessControl();
 158 |     |     }
 159 |     | 
 160 |     |     /// @notice The ```PauseWithdraw``` event is emitted when withdraw is paused or unpaused
 161 |     |     /// @param isPaused The new paused state
 162 |     |     event PauseWithdraw(bool isPaused);
 163 |     | 
 164 |     |     function _pauseWithdraw(bool _isPaused) internal {
 165 |     |         isWithdrawPaused = _isPaused;
 166 |     |         emit PauseWithdraw(_isPaused);
 167 |     |     }
 168 |     | 
 169 |     |     /// @notice The ```RevokeLiquidateAccessControl``` event is emitted when liquidate access control is revoked
 170 |     |     event RevokeLiquidateAccessControl();
 171 |     | 
 172 |     |     function _revokeLiquidateAccessControl() internal {
 173 |     |         isLiquidateAccessControlRevoked = true;
 174 |     |         emit RevokeLiquidateAccessControl();
 175 |     |     }
 176 |     | 
 177 |     |     /// @notice The ```PauseLiquidate``` event is emitted when liquidate is paused or unpaused
 178 |     |     /// @param isPaused The new paused state
 179 |     |     event PauseLiquidate(bool isPaused);
 180 |     | 
 181 |     |     function _pauseLiquidate(bool _isPaused) internal {
 182 |     |         isLiquidatePaused = _isPaused;
 183 |     |         emit PauseLiquidate(_isPaused);
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice The ```RevokeInterestAccessControl``` event is emitted when interest access control is revoked
 187 |     |     event RevokeInterestAccessControl();
 188 |     | 
 189 |     |     function _revokeInterestAccessControl() internal {
 190 |     |         isInterestAccessControlRevoked = true;
 191 |     |         emit RevokeInterestAccessControl();
 192 |     |     }
 193 |     | 
 194 |     |     /// @notice The ```PauseInterest``` event is emitted when interest is paused or unpaused
 195 |     |     /// @param isPaused The new paused state
 196 |     |     event PauseInterest(bool isPaused);
 197 |     | 
 198 |     |     function _pauseInterest(bool _isPaused) internal {
 199 |     |         isInterestPaused = _isPaused;
 200 |     |         emit PauseInterest(_isPaused);
 201 |     |     }
 202 |     | 
 203 |     |     /// @notice The ```SetExternalAssetVault``` event is emitted when the external vault account is changed
 204 |     |     event SetExternalAssetVault(address oldVault, address newVault);
 205 |     | 
 206 |     |     function _setExternalAssetVault(IERC4626Extended vault) internal {
 207 |     |         IERC4626Extended _oldVault = externalAssetVault;
 208 |     |         externalAssetVault = vault;
 209 |     |         emit SetExternalAssetVault(address(_oldVault), address(vault));
 210 |     |     }
 211 |     | 
 212 |     |     function setExternalAssetVault(IERC4626Extended vault) external {
 213 |     |         _requireTimelock();
 214 |     |         _setExternalAssetVault(vault);
 215 |     |     }
 216 |     | 
 217 |     |     /// @notice The ```SetCircuitBreaker``` event is emitted when the circuit breaker address is set
 218 |     |     /// @param oldCircuitBreaker The old circuit breaker address
 219 |     |     /// @param newCircuitBreaker The new circuit breaker address
 220 |     |     event SetCircuitBreaker(address oldCircuitBreaker, address newCircuitBreaker);
 221 |     | 
 222 |     |     /// @notice The ```_setCircuitBreaker``` function is called to set the circuit breaker address
 223 |     |     /// @param _newCircuitBreaker The new circuit breaker address
 224 |     |     function _setCircuitBreaker(address _newCircuitBreaker) internal {
 225 |     |         address oldCircuitBreaker = circuitBreakerAddress;
 226 |     |         circuitBreakerAddress = _newCircuitBreaker;
 227 |     |         emit SetCircuitBreaker(oldCircuitBreaker, _newCircuitBreaker);
 228 |     |     }
 229 |     | 
 230 |     |     /// @notice The ```setCircuitBreaker``` function is called to set the circuit breaker address
 231 |     |     /// @param _newCircuitBreaker The new circuit breaker address
 232 |     |     function setCircuitBreaker(address _newCircuitBreaker) external virtual {
 233 |     |         _requireTimelock();
 234 |     |         _setCircuitBreaker(_newCircuitBreaker);
 235 |     |     }
 236 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairAccessControlErrors.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | // ====================================================================
  5 |     | // |     ______                   _______                             |
  6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
  7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
  8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
  9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
 10 |     | // |                                                                  |
 11 |     | // ====================================================================
 12 |     | // ================ FraxlendPairAccessControlErrors ===================
 13 |     | // ====================================================================
 14 |     | // Frax Finance: https://github.com/FraxFinance
 15 |     | 
 16 |     | // Primary Author
 17 |     | // Drake Evans: https://github.com/DrakeEvans
 18 |     | 
 19 |     | // Reviewers
 20 |     | // Dennis: https://github.com/denett
 21 |     | 
 22 |     | // ====================================================================
 23 |     | 
 24 |     | /// @title FraxlendPairAccessControlErrors
 25 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
 26 |     | /// @notice  An abstract contract which contains the errors for the Access Control contract
 27 |     | abstract contract FraxlendPairAccessControlErrors {
 28 |     |     error OnlyProtocolOrOwner();
 29 |     |     error OnlyTimelockOrOwner();
 30 |     |     error ExceedsBorrowLimit();
 31 |     |     error AccessControlRevoked();
 32 |     |     error RepayPaused();
 33 |     |     error ExceedsDepositLimit();
 34 |     |     error WithdrawPaused();
 35 |     |     error LiquidatePaused();
 36 |     |     error InterestPaused();
 37 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairConstants.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | // ====================================================================
  5 |     | // |     ______                   _______                             |
  6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
  7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
  8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
  9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
 10 |     | // |                                                                  |
 11 |     | // ====================================================================
 12 |     | // ===================== FraxlendPairConstants ========================
 13 |     | // ====================================================================
 14 |     | // Frax Finance: https://github.com/FraxFinance
 15 |     | 
 16 |     | // Primary Author
 17 |     | // Drake Evans: https://github.com/DrakeEvans
 18 |     | 
 19 |     | // Reviewers
 20 |     | // Dennis: https://github.com/denett
 21 |     | // Sam Kazemian: https://github.com/samkazemian
 22 |     | // Travis Moore: https://github.com/FortisFortuna
 23 |     | // Jack Corddry: https://github.com/corddry
 24 |     | // Rich Gee: https://github.com/zer0blockchain
 25 |     | 
 26 |     | // ====================================================================
 27 |     | 
 28 |     | /// @title FraxlendPairConstants
 29 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
 30 |     | /// @notice  An abstract contract which contains the errors and constants for the FraxlendPair contract
 31 |     | abstract contract FraxlendPairConstants {
 32 |     |     // ============================================================================================
 33 |     |     // Constants
 34 |     |     // ============================================================================================
 35 |     | 
 36 |     |     // Precision settings
 37 |     |     uint256 public constant LTV_PRECISION = 1e5; // 5 decimals
 38 |     |     uint256 public constant LIQ_PRECISION = 1e5;
 39 |     |     uint256 public constant UTIL_PREC = 1e5;
 40 |     |     uint256 public constant FEE_PRECISION = 1e5;
 41 |     |     uint256 public constant EXCHANGE_PRECISION = 1e18;
 42 |     |     uint256 public constant DEVIATION_PRECISION = 1e5;
 43 |     |     uint256 public constant RATE_PRECISION = 1e18;
 44 |     | 
 45 |     |     // Protocol Fee
 46 |     |     uint256 public constant MAX_PROTOCOL_FEE = 5e4; // 50% 1e5 precision
 47 |     | 
 48 |     |     error Insolvent(uint256 _borrow, uint256 _collateral, uint256 _exchangeRate);
 49 |     |     error BorrowerSolvent();
 50 |     |     error InsufficientAssetsInContract(uint256 _assets, uint256 _request);
 51 |     |     error SlippageTooHigh(uint256 _minOut, uint256 _actual);
 52 |     |     error BadSwapper();
 53 |     |     error InvalidPath(address _expected, address _actual);
 54 |     |     error BadProtocolFee();
 55 |     |     error PastDeadline(uint256 _blockTimestamp, uint256 _deadline);
 56 |     |     error SetterRevoked();
 57 |     |     error ExceedsMaxOracleDeviation();
 58 |     |     error InvalidReceiver();
 59 |     |     error ExternalAssetVaultOnly();
 60 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairCore.sol
    1 |     | // SPDX-License-Identifier: ISC
    2 |     | pragma solidity ^0.8.19;
    3 |     | 
    4 |     | // ====================================================================
    5 |     | // |     ______                   _______                             |
    6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
    7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
    8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
    9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
   10 |     | // |                                                                  |
   11 |     | // ====================================================================
   12 |     | // ========================= FraxlendPairCore =========================
   13 |     | // ====================================================================
   14 |     | // Frax Finance: https://github.com/FraxFinance
   15 |     | 
   16 |     | // Primary Author
   17 |     | // Drake Evans: https://github.com/DrakeEvans
   18 |     | 
   19 |     | // Reviewers
   20 |     | // Dennis: https://github.com/denett
   21 |     | // Sam Kazemian: https://github.com/samkazemian
   22 |     | // Travis Moore: https://github.com/FortisFortuna
   23 |     | // Jack Corddry: https://github.com/corddry
   24 |     | // Rich Gee: https://github.com/zer0blockchain
   25 |     | 
   26 |     | // ====================================================================
   27 |     | 
   28 |     | import { ERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
   29 |     | import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
   30 |     | import { ReentrancyGuard } from "@openzeppelin/contracts/security/ReentrancyGuard.sol";
   31 |     | import { SafeCast } from "@openzeppelin/contracts/utils/math/SafeCast.sol";
   32 |     | import { FraxlendPairAccessControl } from "./FraxlendPairAccessControl.sol";
   33 |     | import { FraxlendPairConstants } from "./FraxlendPairConstants.sol";
   34 |     | import { VaultAccount, VaultAccountingLibrary } from "./libraries/VaultAccount.sol";
   35 |     | import { SafeERC20 } from "./libraries/SafeERC20.sol";
   36 |     | import { IDualOracle } from "./interfaces/IDualOracle.sol";
   37 |     | import { IRateCalculatorV2 } from "./interfaces/IRateCalculatorV2.sol";
   38 |     | import { ISwapper } from "./interfaces/ISwapper.sol";
   39 |     | 
   40 |     | /// @title FraxlendPairCore
   41 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
   42 |     | /// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair
   43 |     | abstract contract FraxlendPairCore is FraxlendPairAccessControl, FraxlendPairConstants, ERC20, ReentrancyGuard {
   44 |     |     using VaultAccountingLibrary for VaultAccount;
   45 |     |     using SafeERC20 for IERC20;
   46 |     |     using SafeCast for uint256;
   47 |     | 
   48 |     |     function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {
   49 |     |         _major = 3;
   50 |     |         _minor = 0;
   51 |     |         _patch = 0;
   52 |     |     }
   53 |     | 
   54 |     |     // ============================================================================================
   55 |     |     // Settings set by constructor()
   56 |     |     // ============================================================================================
   57 |     | 
   58 |     |     // Asset and collateral contracts
   59 |     |     IERC20 internal immutable assetContract;
   60 |     |     IERC20 public immutable collateralContract;
   61 |     | 
   62 |     |     // LTV Settings
   63 |     |     /// @notice The maximum LTV allowed for this pair
   64 |     |     /// @dev 1e5 precision
   65 |     |     uint256 public maxLTV;
   66 |     | 
   67 |     |     // Liquidation Fees
   68 |     |     /// @notice The liquidation fee, given as a % of repayment amount, when all collateral is consumed in liquidation
   69 |     |     /// @dev 1e5 precision
   70 |     |     uint256 public cleanLiquidationFee;
   71 |     |     /// @notice The liquidation fee, given as % of repayment amount, when some collateral remains for borrower
   72 |     |     /// @dev 1e5 precision
   73 |     |     uint256 public dirtyLiquidationFee;
   74 |     |     /// @notice The portion of the liquidation fee given to protocol
   75 |     |     /// @dev 1e5 precision
   76 |     |     uint256 public protocolLiquidationFee;
   77 |     | 
   78 |     |     // Interest Rate Calculator Contract
   79 |     |     IRateCalculatorV2 public rateContract; // For complex rate calculations
   80 |     | 
   81 |     |     // Swapper
   82 |     |     mapping(address => bool) public swappers; // approved swapper addresses
   83 |     | 
   84 |     |     // ERC20 Metadata
   85 |     |     string internal nameOfContract;
   86 |     |     string internal symbolOfContract;
   87 |     |     uint8 internal immutable decimalsOfContract;
   88 |     | 
   89 |     |     // ============================================================================================
   90 |     |     // Storage
   91 |     |     // ============================================================================================
   92 |     | 
   93 |     |     /// @notice Stores information about the current interest rate
   94 |     |     /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec & fullUtilizationRate is 1e18 precision
   95 |     |     CurrentRateInfo public currentRateInfo;
   96 |     | 
   97 |     |     struct CurrentRateInfo {
   98 |     |         uint32 lastBlock;
   99 |     |         uint32 feeToProtocolRate; // Fee amount 1e5 precision
  100 |     |         uint64 lastTimestamp;
  101 |     |         uint64 ratePerSec;
  102 |     |         uint64 fullUtilizationRate;
  103 |     |     }
  104 |     | 
  105 |     |     /// @notice Stores information about the current exchange rate. Collateral:Asset ratio
  106 |     |     /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token
  107 |     |     ExchangeRateInfo public exchangeRateInfo;
  108 |     | 
  109 |     |     struct ExchangeRateInfo {
  110 |     |         address oracle;
  111 |     |         uint32 maxOracleDeviation; // % of larger number, 1e5 precision
  112 |     |         uint184 lastTimestamp;
  113 |     |         uint256 lowExchangeRate;
  114 |     |         uint256 highExchangeRate;
  115 |     |     }
  116 |     | 
  117 |     |     // Contract Level Accounting
  118 |     |     VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding
  119 |     |     VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding
  120 |     |     uint256 public totalCollateral; // total amount of collateral in contract
  121 |     | 
  122 |     |     // User Level Accounting
  123 |     |     /// @notice Stores the balance of collateral for each user
  124 |     |     mapping(address => uint256) public userCollateralBalance; // amount of collateral each user is backed
  125 |     |     /// @notice Stores the balance of borrow shares for each user
  126 |     |     mapping(address => uint256) public userBorrowShares; // represents the shares held by individuals
  127 |     | 
  128 |     |     // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()
  129 |     | 
  130 |     |     // ============================================================================================
  131 |     |     // Constructor
  132 |     |     // ============================================================================================
  133 |     | 
  134 |     |     /// @notice The ```constructor``` function is called on deployment
  135 |     |     /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)
  136 |     |     /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)
  137 |     |     /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)
  138 |     |     constructor(
  139 |     |         bytes memory _configData,
  140 |     |         bytes memory _immutables,
  141 |     |         bytes memory _customConfigData
  142 |     |     ) FraxlendPairAccessControl(_immutables) ERC20("", "") {
  143 |     |         {
  144 |     |             (
  145 |     |                 address _asset,
  146 |     |                 address _collateral,
  147 |     |                 address _oracle,
  148 |     |                 uint32 _maxOracleDeviation,
  149 |     |                 address _rateContract,
  150 |     |                 uint64 _fullUtilizationRate,
  151 |     |                 uint256 _maxLTV,
  152 |     |                 uint256 _liquidationFee,
  153 |     |                 uint256 _protocolLiquidationFee
  154 |     |             ) = abi.decode(
  155 |     |                     _configData,
  156 |     |                     (address, address, address, uint32, address, uint64, uint256, uint256, uint256)
  157 |     |                 );
  158 |     | 
  159 |     |             // Pair Settings
  160 |     |             assetContract = IERC20(_asset);
  161 |     |             collateralContract = IERC20(_collateral);
  162 |     | 
  163 |     |             currentRateInfo.feeToProtocolRate = 0;
  164 |     |             currentRateInfo.fullUtilizationRate = _fullUtilizationRate;
  165 |     |             currentRateInfo.lastTimestamp = uint64(block.timestamp - 1);
  166 |     |             currentRateInfo.lastBlock = uint32(block.number - 1);
  167 |     | 
  168 |     |             exchangeRateInfo.oracle = _oracle;
  169 |     |             exchangeRateInfo.maxOracleDeviation = _maxOracleDeviation;
  170 |     | 
  171 |     |             rateContract = IRateCalculatorV2(_rateContract);
  172 |     | 
  173 |     |             //Liquidation Fee Settings
  174 |     |             cleanLiquidationFee = _liquidationFee;
  175 |     |             dirtyLiquidationFee = (_liquidationFee * 90_000) / LIQ_PRECISION; // 90% of clean fee
  176 |     |             protocolLiquidationFee = _protocolLiquidationFee;
  177 |     | 
  178 |     |             // set maxLTV
  179 |     |             maxLTV = _maxLTV;
  180 |     |         }
  181 |     | 
  182 |     |         {
  183 |     |             (string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract) = abi.decode(
  184 |     |                 _customConfigData,
  185 |     |                 (string, string, uint8)
  186 |     |             );
  187 |     | 
  188 |     |             // ERC20 Metadata
  189 |     |             nameOfContract = _nameOfContract;
  190 |     |             symbolOfContract = _symbolOfContract;
  191 |     |             decimalsOfContract = _decimalsOfContract;
  192 |     | 
  193 |     |             // Instantiate Interest
  194 |     |             _addInterest();
  195 |     |             // Instantiate Exchange Rate
  196 |     |             _updateExchangeRate();
  197 |     |         }
  198 |     |     }
  199 |     | 
  200 |     |     // ============================================================================================
  201 |     |     // Internal Helpers
  202 |     |     // ============================================================================================
  203 |     | 
  204 |     |     /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract
  205 |     |     /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets
  206 |     |     /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows
  207 |     |     /// @return The balance of Asset Tokens held by contract
  208 |     |     function _totalAssetAvailable(
  209 |     |         VaultAccount memory _totalAsset,
  210 |     |         VaultAccount memory _totalBorrow,
  211 |     |         bool _includeVault
  212 |     |     ) internal view returns (uint256) {
  213 |     |         if (_includeVault) {
  214 |     |             return _totalAsset.totalAmount(address(externalAssetVault)) - _totalBorrow.amount;
  215 |     |         }
  216 |     |         return _totalAsset.amount - _totalBorrow.amount;
  217 |     |     }
  218 |     | 
  219 |     |     /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate
  220 |     |     /// @param _borrower The borrower address to check
  221 |     |     /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset
  222 |     |     /// @return Whether borrower is solvent
  223 |     |     function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {
  224 |     |         if (maxLTV == 0) return true;
  225 |     |         uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);
  226 |     |         if (_borrowerAmount == 0) return true;
  227 |     |         uint256 _collateralAmount = userCollateralBalance[_borrower];
  228 |     |         if (_collateralAmount == 0) return false;
  229 |     | 
  230 |     |         uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;
  231 |     |         return _ltv <= maxLTV;
  232 |     |     }
  233 |     | 
  234 |     |     // ============================================================================================
  235 |     |     // Modifiers
  236 |     |     // ============================================================================================
  237 |     | 
  238 |     |     /// @notice Checks for solvency AFTER executing contract code
  239 |     |     /// @param _borrower The borrower whose solvency we will check
  240 |     |     modifier isSolvent(address _borrower) {
  241 |     |         _;
  242 |     |         ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;
  243 |     | 
  244 |     |         if (!_isSolvent(_borrower, exchangeRateInfo.highExchangeRate)) {
  245 |     |             revert Insolvent(
  246 |     |                 totalBorrow.toAmount(userBorrowShares[_borrower], true),
  247 |     |                 userCollateralBalance[_borrower],
  248 |     |                 exchangeRateInfo.highExchangeRate
  249 |     |             );
  250 |     |         }
  251 |     |     }
  252 |     | 
  253 |     |     // ============================================================================================
  254 |     |     // Functions: Interest Accumulation and Adjustment
  255 |     |     // ============================================================================================
  256 |     | 
  257 |     |     /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers
  258 |     |     /// @param interestEarned The total interest accrued by all borrowers
  259 |     |     /// @param rate The interest rate used to calculate accrued interest
  260 |     |     /// @param feesAmount The amount of fees paid to protocol
  261 |     |     /// @param feesShare The amount of shares distributed to protocol
  262 |     |     event AddInterest(uint256 interestEarned, uint256 rate, uint256 feesAmount, uint256 feesShare);
  263 |     | 
  264 |     |     /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated
  265 |     |     /// @param oldRatePerSec The old interest rate (per second)
  266 |     |     /// @param oldFullUtilizationRate The old full utilization rate
  267 |     |     /// @param newRatePerSec The new interest rate (per second)
  268 |     |     /// @param newFullUtilizationRate The new full utilization rate
  269 |     |     event UpdateRate(
  270 |     |         uint256 oldRatePerSec,
  271 |     |         uint256 oldFullUtilizationRate,
  272 |     |         uint256 newRatePerSec,
  273 |     |         uint256 newFullUtilizationRate
  274 |     |     );
  275 |     | 
  276 |     |     /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual
  277 |     |     /// @return _interestEarned The amount of interest accrued by all borrowers
  278 |     |     /// @return _feesAmount The amount of fees paid to protocol
  279 |     |     /// @return _feesShare The amount of shares distributed to protocol
  280 |     |     /// @return _currentRateInfo The new rate info struct
  281 |     |     /// @return _totalAsset The new total asset struct
  282 |     |     /// @return _totalBorrow The new total borrow struct
  283 |     |     function addInterest(
  284 |     |         bool _returnAccounting
  285 |     |     )
  286 |     |         external
  287 |     |         nonReentrant
  288 |     |         returns (
  289 |     |             uint256 _interestEarned,
  290 |     |             uint256 _feesAmount,
  291 |     |             uint256 _feesShare,
  292 |     |             CurrentRateInfo memory _currentRateInfo,
  293 |     |             VaultAccount memory _totalAsset,
  294 |     |             VaultAccount memory _totalBorrow
  295 |     |         )
  296 |     |     {
  297 |     |         (, _interestEarned, _feesAmount, _feesShare, _currentRateInfo) = _addInterest();
  298 |     |         if (_returnAccounting) {
  299 |     |             _totalAsset = totalAsset;
  300 |     |             _totalBorrow = totalBorrow;
  301 |     |         }
  302 |     |     }
  303 |     | 
  304 |     |     /// @notice The ```previewAddInterest``` function
  305 |     |     /// @return _interestEarned The amount of interest accrued by all borrowers
  306 |     |     /// @return _feesAmount The amount of fees paid to protocol
  307 |     |     /// @return _feesShare The amount of shares distributed to protocol
  308 |     |     /// @return _newCurrentRateInfo The new rate info struct
  309 |     |     /// @return _totalAsset The new total asset struct
  310 |     |     /// @return _totalBorrow The new total borrow struct
  311 |     |     function previewAddInterest()
  312 |     |         public
  313 |     |         view
  314 |     |         returns (
  315 |     |             uint256 _interestEarned,
  316 |     |             uint256 _feesAmount,
  317 |     |             uint256 _feesShare,
  318 |     |             CurrentRateInfo memory _newCurrentRateInfo,
  319 |     |             VaultAccount memory _totalAsset,
  320 |     |             VaultAccount memory _totalBorrow
  321 |     |         )
  322 |     |     {
  323 |     |         _newCurrentRateInfo = currentRateInfo;
  324 |     |         // Write return values
  325 |     |         InterestCalculationResults memory _results = _calculateInterest(_newCurrentRateInfo);
  326 |     | 
  327 |     |         if (_results.isInterestUpdated) {
  328 |     |             _interestEarned = _results.interestEarned;
  329 |     |             _feesAmount = _results.feesAmount;
  330 |     |             _feesShare = _results.feesShare;
  331 |     | 
  332 |     |             _newCurrentRateInfo.ratePerSec = _results.newRate;
  333 |     |             _newCurrentRateInfo.fullUtilizationRate = _results.newFullUtilizationRate;
  334 |     | 
  335 |     |             _totalAsset = _results.totalAsset;
  336 |     |             _totalBorrow = _results.totalBorrow;
  337 |     |         } else {
  338 |     |             _totalAsset = totalAsset;
  339 |     |             _totalBorrow = totalBorrow;
  340 |     |         }
  341 |     |     }
  342 |     | 
  343 |     |     struct InterestCalculationResults {
  344 |     |         bool isInterestUpdated;
  345 |     |         uint64 newRate;
  346 |     |         uint64 newFullUtilizationRate;
  347 |     |         uint256 interestEarned;
  348 |     |         uint256 feesAmount;
  349 |     |         uint256 feesShare;
  350 |     |         VaultAccount totalAsset;
  351 |     |         VaultAccount totalBorrow;
  352 |     |     }
  353 |     | 
  354 |     |     /// @notice The ```_calculateInterest``` function calculates the interest to be accrued and the new interest rate info
  355 |     |     /// @param _currentRateInfo The current rate info
  356 |     |     /// @return _results The results of the interest calculation
  357 |     |     function _calculateInterest(
  358 |     |         CurrentRateInfo memory _currentRateInfo
  359 |     |     ) internal view returns (InterestCalculationResults memory _results) {
  360 |     |         // Short circuit if interest already calculated this block OR if interest is paused
  361 |     |         if (_currentRateInfo.lastTimestamp != block.timestamp && !isInterestPaused) {
  362 |     |             // Indicate that interest is updated and calculated
  363 |     |             _results.isInterestUpdated = true;
  364 |     | 
  365 |     |             // Write return values and use these to save gas
  366 |     |             _results.totalAsset = totalAsset;
  367 |     |             _results.totalBorrow = totalBorrow;
  368 |     | 
  369 |     |             // Time elapsed since last interest update
  370 |     |             uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;
  371 |     | 
  372 |     |             // Total assets available including what resides in the external vault
  373 |     |             uint256 _totalAssetsAvailable = _results.totalAsset.totalAmount(address(externalAssetVault));
  374 |     | 
  375 |     |             // Get the utilization rate
  376 |     |             uint256 _utilizationRate = _totalAssetsAvailable == 0
  377 |     |                 ? 0
  378 |     |                 : (UTIL_PREC * _results.totalBorrow.amount) / _totalAssetsAvailable;
  379 |     | 
  380 |     |             // Request new interest rate and full utilization rate from the rate calculator
  381 |     |             (_results.newRate, _results.newFullUtilizationRate) = IRateCalculatorV2(rateContract).getNewRate(
  382 |     |                 _deltaTime,
  383 |     |                 _utilizationRate,
  384 |     |                 _currentRateInfo.fullUtilizationRate
  385 |     |             );
  386 |     | 
  387 |     |             // Calculate interest accrued
  388 |     |             _results.interestEarned = (_deltaTime * _results.totalBorrow.amount * _results.newRate) / RATE_PRECISION;
  389 |     | 
  390 |     |             // Accrue interest (if any) and fees iff no overflow
  391 |     |             if (
  392 |     |                 _results.interestEarned > 0 &&
  393 |     |                 _results.interestEarned + _results.totalBorrow.amount <= type(uint128).max &&
  394 |     |                 _results.interestEarned + _totalAssetsAvailable <= type(uint128).max
  395 |     |             ) {
  396 |     |                 // Increment totalBorrow and totalAsset by interestEarned
  397 |     |                 _results.totalBorrow.amount += _results.interestEarned.toUint128();
  398 |     |                 _results.totalAsset.amount += _results.interestEarned.toUint128();
  399 |     |                 if (_currentRateInfo.feeToProtocolRate > 0) {
  400 |     |                     _results.feesAmount =
  401 |     |                         (_results.interestEarned * _currentRateInfo.feeToProtocolRate) /
  402 |     |                         FEE_PRECISION;
  403 |     | 
  404 |     |                     _results.feesShare =
  405 |     |                         (_results.feesAmount * _results.totalAsset.shares) /
  406 |     |                         (_results.totalAsset.totalAmount(address(0)) - _results.feesAmount);
  407 |     | 
  408 |     |                     // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees
  409 |     |                     // We can safely cast because _feesShare < _feesAmount < interestEarned which is always less than uint128
  410 |     |                     _results.totalAsset.shares += _results.feesShare.toUint128();
  411 |     |                 }
  412 |     |             }
  413 |     |         }
  414 |     |     }
  415 |     | 
  416 |     |     /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate
  417 |     |     /// @dev Can only called once per block
  418 |     |     /// @return _isInterestUpdated True if interest was calculated
  419 |     |     /// @return _interestEarned The amount of interest accrued by all borrowers
  420 |     |     /// @return _feesAmount The amount of fees paid to protocol
  421 |     |     /// @return _feesShare The amount of shares distributed to protocol
  422 |     |     /// @return _currentRateInfo The new rate info struct
  423 |     |     function _addInterest()
  424 |     |         internal
  425 |     |         returns (
  426 |     |             bool _isInterestUpdated,
  427 |     |             uint256 _interestEarned,
  428 |     |             uint256 _feesAmount,
  429 |     |             uint256 _feesShare,
  430 |     |             CurrentRateInfo memory _currentRateInfo
  431 |     |         )
  432 |     |     {
  433 |     |         // Pull from storage and set default return values
  434 |     |         _currentRateInfo = currentRateInfo;
  435 |     | 
  436 |     |         // Calc interest
  437 |     |         InterestCalculationResults memory _results = _calculateInterest(_currentRateInfo);
  438 |     | 
  439 |     |         // Write return values only if interest was updated and calculated
  440 |     |         if (_results.isInterestUpdated) {
  441 |     |             _isInterestUpdated = _results.isInterestUpdated;
  442 |     |             _interestEarned = _results.interestEarned;
  443 |     |             _feesAmount = _results.feesAmount;
  444 |     |             _feesShare = _results.feesShare;
  445 |     | 
  446 |     |             // emit here so that we have access to the old values
  447 |     |             emit UpdateRate(
  448 |     |                 _currentRateInfo.ratePerSec,
  449 |     |                 _currentRateInfo.fullUtilizationRate,
  450 |     |                 _results.newRate,
  451 |     |                 _results.newFullUtilizationRate
  452 |     |             );
  453 |     |             emit AddInterest(_interestEarned, _results.newRate, _feesAmount, _feesShare);
  454 |     | 
  455 |     |             // overwrite original values
  456 |     |             _currentRateInfo.ratePerSec = _results.newRate;
  457 |     |             _currentRateInfo.fullUtilizationRate = _results.newFullUtilizationRate;
  458 |     |             _currentRateInfo.lastTimestamp = uint64(block.timestamp);
  459 |     |             _currentRateInfo.lastBlock = uint32(block.number);
  460 |     | 
  461 |     |             // Effects: write to state
  462 |     |             currentRateInfo = _currentRateInfo;
  463 |     |             totalAsset = _results.totalAsset;
  464 |     |             totalBorrow = _results.totalBorrow;
  465 |     |             if (_feesShare > 0) _mint(address(this), _feesShare);
  466 |     |         }
  467 |     |     }
  468 |     | 
  469 |     |     // ============================================================================================
  470 |     |     // Functions: ExchangeRate
  471 |     |     // ============================================================================================
  472 |     | 
  473 |     |     /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated
  474 |     |     /// @param lowExchangeRate The low exchange rate
  475 |     |     /// @param highExchangeRate The high exchange rate
  476 |     |     event UpdateExchangeRate(uint256 lowExchangeRate, uint256 highExchangeRate);
  477 |     | 
  478 |     |     /// @notice The ```WarnOracleData``` event is emitted when one of the oracles has stale or otherwise problematic data
  479 |     |     /// @param oracle The oracle address
  480 |     |     event WarnOracleData(address oracle);
  481 |     | 
  482 |     |     /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.
  483 |     |     /// @dev This function is invoked at most once per block as these queries can be expensive
  484 |     |     /// @return _isBorrowAllowed True if deviation is within bounds
  485 |     |     /// @return _lowExchangeRate The low exchange rate
  486 |     |     /// @return _highExchangeRate The high exchange rate
  487 |     |     function updateExchangeRate()
  488 |     |         external
  489 |     |         nonReentrant
  490 |     |         returns (bool _isBorrowAllowed, uint256 _lowExchangeRate, uint256 _highExchangeRate)
  491 |     |     {
  492 |     |         return _updateExchangeRate();
  493 |     |     }
  494 |     | 
  495 |     |     /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.
  496 |     |     /// @dev This function is invoked at most once per block as these queries can be expensive
  497 |     |     /// @return _isBorrowAllowed True if deviation is within bounds
  498 |     |     /// @return _lowExchangeRate The low exchange rate
  499 |     |     /// @return _highExchangeRate The high exchange rate
  500 |     | 
  501 |     |     function _updateExchangeRate()
  502 |     |         internal
  503 |     |         returns (bool _isBorrowAllowed, uint256 _lowExchangeRate, uint256 _highExchangeRate)
  504 |     |     {
  505 |     |         // Pull from storage to save gas and set default return values
  506 |     |         ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;
  507 |     | 
  508 |     |         // Short circuit if already updated this block
  509 |     |         if (_exchangeRateInfo.lastTimestamp != block.timestamp) {
  510 |     |             // Get the latest exchange rate from the dual oracle
  511 |     |             bool _oneOracleBad;
  512 |     |             (_oneOracleBad, _lowExchangeRate, _highExchangeRate) = IDualOracle(_exchangeRateInfo.oracle).getPrices();
  513 |     | 
  514 |     |             // If one oracle is bad data, emit an event for off-chain monitoring
  515 |     |             if (_oneOracleBad) emit WarnOracleData(_exchangeRateInfo.oracle);
  516 |     | 
  517 |     |             // Effects: Bookkeeping and write to storage
  518 |     |             _exchangeRateInfo.lastTimestamp = uint184(block.timestamp);
  519 |     |             _exchangeRateInfo.lowExchangeRate = _lowExchangeRate;
  520 |     |             _exchangeRateInfo.highExchangeRate = _highExchangeRate;
  521 |     |             exchangeRateInfo = _exchangeRateInfo;
  522 |     |             emit UpdateExchangeRate(_lowExchangeRate, _highExchangeRate);
  523 |     |         } else {
  524 |     |             // Use default return values if already updated this block
  525 |     |             _lowExchangeRate = _exchangeRateInfo.lowExchangeRate;
  526 |     |             _highExchangeRate = _exchangeRateInfo.highExchangeRate;
  527 |     |         }
  528 |     | 
  529 |     |         uint256 _deviation = (DEVIATION_PRECISION *
  530 |     |             (_exchangeRateInfo.highExchangeRate - _exchangeRateInfo.lowExchangeRate)) /
  531 |     |             _exchangeRateInfo.highExchangeRate;
  532 |     |         if (_deviation <= _exchangeRateInfo.maxOracleDeviation) {
  533 |     |             _isBorrowAllowed = true;
  534 |     |         }
  535 |     |     }
  536 |     | 
  537 |     |     // ============================================================================================
  538 |     |     // Functions: Lending
  539 |     |     // ============================================================================================
  540 |     | 
  541 |     |     /// @notice The ```Deposit``` event fires when a user deposits assets to the pair
  542 |     |     /// @param caller the msg.sender
  543 |     |     /// @param owner the account the fTokens are sent to
  544 |     |     /// @param assets the amount of assets deposited
  545 |     |     /// @param shares the number of fTokens minted
  546 |     |     event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);
  547 |     | 
  548 |     |     /// @notice The ```_deposit``` function is the internal implementation for lending assets
  549 |     |     /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function
  550 |     |     /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token
  551 |     |     /// @param _amount The amount of Asset Token to be transferred
  552 |     |     /// @param _shares The amount of Asset Shares (fTokens) to be minted
  553 |     |     /// @param _receiver The address to receive the Asset Shares (fTokens)
  554 |     |     /// @param _shouldTransfer Whether asset tokens should be deposited from the sender
  555 |     |     function _deposit(VaultAccount memory _totalAsset, uint128 _amount, uint128 _shares, address _receiver, bool _shouldTransfer) internal {
  556 |     |         // Effects: bookkeeping
  557 |     |         _totalAsset.amount += _amount;
  558 |     |         _totalAsset.shares += _shares;
  559 |     | 
  560 |     |         // Effects: write back to storage
  561 |     |         _mint(_receiver, _shares);
  562 |     |         totalAsset = _totalAsset;
  563 |     | 
  564 |     |         // Interactions
  565 |     |         if (_shouldTransfer) {
  566 |     |             assetContract.safeTransferFrom(msg.sender, address(this), _amount);
  567 |     |         }
  568 |     |         emit Deposit(msg.sender, _receiver, _amount, _shares);
  569 |     |     }
  570 |     | 
  571 |     |     function previewDeposit(uint256 _assets) external view returns (uint256 _sharesReceived) {
  572 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
  573 |     |         _sharesReceived = _totalAsset.toShares(_assets, false);
  574 |     |     }
  575 |     | 
  576 |     |     /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend
  577 |     |     /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function
  578 |     |     /// @param _amount The amount of Asset Token to transfer to Pair
  579 |     |     /// @param _receiver The address to receive the Asset Shares (fTokens)
  580 |     |     /// @return _sharesReceived The number of fTokens received for the deposit
  581 |     |     function deposit(uint256 _amount, address _receiver) external nonReentrant returns (uint256 _sharesReceived) {
  582 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  583 |     | 
  584 |     |         // Accrue interest if necessary
  585 |     |         _addInterest();
  586 |     | 
  587 |     |         // Pull from storage to save gas
  588 |     |         VaultAccount memory _totalAsset = totalAsset;
  589 |     | 
  590 |     |         // Check if this deposit will violate the deposit limit
  591 |     |         if (depositLimit < _totalAsset.totalAmount(address(externalAssetVault)) + _amount) revert ExceedsDepositLimit();
  592 |     | 
  593 |     |         // Calculate the number of fTokens to mint
  594 |     |         _sharesReceived = _totalAsset.toShares(_amount, false);
  595 |     | 
  596 |     |         // Execute the deposit effects
  597 |     |         _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver, true);
  598 |     |     }
  599 |     | 
  600 |     |     /// @notice The ```_depositFromVault``` function deposits assets here from the configured external vault if available
  601 |     |     /// @param _amount The amount of Asset Tokens to be transferred from the vault
  602 |     |     /// @return _sharesReceived The number of Asset Shares (fTokens) to mint for Asset Tokens
  603 |     |     function _depositFromVault(uint256 _amount) internal returns (uint256 _sharesReceived) {
  604 |     |         // Accrue interest if necessary
  605 |     |         _addInterest();
  606 |     | 
  607 |     |         // Pull from storage to save gas
  608 |     |         VaultAccount memory _totalAsset = totalAsset;
  609 |     | 
  610 |     |         // Check if this deposit will violate the deposit limit
  611 |     |         if (depositLimit < _totalAsset.totalAmount(address(externalAssetVault))) revert ExceedsDepositLimit();
  612 |     | 
  613 |     |         // Calculate the number of fTokens to mint
  614 |     |         _sharesReceived = _totalAsset.toShares(_amount, false);
  615 |     | 
  616 |     |         // Withdraw assets from external vault here
  617 |     |         externalAssetVault.whitelistWithdraw(_amount);
  618 |     | 
  619 |     |         // Execute the deposit effects
  620 |     |         _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), address(externalAssetVault), false);
  621 |     |     }
  622 |     | 
  623 |     |     /// @notice The ```_withdrawToVault``` function withdraws assets back to an external vault if previously used
  624 |     |     /// @param _amountToReturn The amount of Asset Tokens to be transferred to the vault
  625 |     |     /// @return _shares The number of Asset Shares (fTokens) to burn for Asset Tokens
  626 |     |     function _withdrawToVault(uint256 _amountToReturn) internal returns (uint256 _shares) {
  627 |     |         // Accrue interest if necessary
  628 |     |         _addInterest();
  629 |     | 
  630 |     |         // Pull from storage to save gas
  631 |     |         VaultAccount memory _totalAsset = totalAsset;
  632 |     | 
  633 |     |         // Calculate the number of shares to burn based on the assets to transfer
  634 |     |         _shares = _totalAsset.toShares(_amountToReturn, true);
  635 |     | 
  636 |     |         // Execute the withdraw effects for vault
  637 |     |         // receive assets here in order to call whitelistDeposit and handle accounting in external vault
  638 |     |         _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), address(this), address(externalAssetVault), true);
  639 |     | 
  640 |     |         // Deposit assets to external vault
  641 |     |         assetContract.approve(address(externalAssetVault), _amountToReturn);
  642 |     |         externalAssetVault.whitelistDeposit(_amountToReturn);
  643 |     |     }
  644 |     | 
  645 |     |     function previewMint(uint256 _shares) external view returns (uint256 _amount) {
  646 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
  647 |     |         _amount = _totalAsset.toAmount(_shares, false);
  648 |     |     }
  649 |     | 
  650 |     |     function mint(uint256 _shares, address _receiver) external nonReentrant returns (uint256 _amount) {
  651 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  652 |     | 
  653 |     |         // Accrue interest if necessary
  654 |     |         _addInterest();
  655 |     | 
  656 |     |         // Pull from storage to save gas
  657 |     |         VaultAccount memory _totalAsset = totalAsset;
  658 |     | 
  659 |     |         // Calculate the number of assets to transfer based on the shares to mint
  660 |     |         _amount = _totalAsset.toAmount(_shares, false);
  661 |     | 
  662 |     |         // Check if this deposit will violate the deposit limit
  663 |     |         if (depositLimit < _totalAsset.totalAmount(address(externalAssetVault)) + _amount) revert ExceedsDepositLimit();
  664 |     | 
  665 |     |         // Execute the deposit effects
  666 |     |         _deposit(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, true);
  667 |     |     }
  668 |     | 
  669 |     |     /// @notice The ```Withdraw``` event fires when a user redeems their fTokens for the underlying asset
  670 |     |     /// @param caller the msg.sender
  671 |     |     /// @param receiver The address to which the underlying asset will be transferred to
  672 |     |     /// @param owner The owner of the fTokens
  673 |     |     /// @param assets The assets transferred
  674 |     |     /// @param shares The number of fTokens burned
  675 |     |     event Withdraw(
  676 |     |         address indexed caller,
  677 |     |         address indexed receiver,
  678 |     |         address indexed owner,
  679 |     |         uint256 assets,
  680 |     |         uint256 shares
  681 |     |     );
  682 |     | 
  683 |     |     /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair
  684 |     |     /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function
  685 |     |     /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)
  686 |     |     /// @param _amountToReturn The number of Asset Tokens to return
  687 |     |     /// @param _shares The number of Asset Shares (fTokens) to burn
  688 |     |     /// @param _receiver The address to which the Asset Tokens will be transferred
  689 |     |     /// @param _owner The owner of the Asset Shares (fTokens)
  690 |     |     function _redeem(
  691 |     |         VaultAccount memory _totalAsset,
  692 |     |         uint128 _amountToReturn,
  693 |     |         uint128 _shares,
  694 |     |         address _receiver,
  695 |     |         address _owner,
  696 |     |         bool _skipAllowanceCheck
  697 |     |     ) internal {
  698 |     |         // Check for sufficient allowance/approval if necessary
  699 |     |         if (msg.sender != _owner && !_skipAllowanceCheck) {
  700 |     |             uint256 allowed = allowance(_owner, msg.sender);
  701 |     |             // NOTE: This will revert on underflow ensuring that allowance > shares
  702 |     |             if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);
  703 |     |         }
  704 |     | 
  705 |     |         // Check for sufficient withdraw liquidity (not strictly necessary because balance will underflow)
  706 |     |         uint256 _totAssetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow, true);
  707 |     |         if (_totAssetsAvailable < _amountToReturn) {
  708 |     |             revert InsufficientAssetsInContract(_totAssetsAvailable, _amountToReturn);
  709 |     |         }
  710 |     | 
  711 |     |         // If we're redeeming back to the vault, don't deposit from the vault
  712 |     |         if (_owner != address(externalAssetVault)) {
  713 |     |             uint256 _localAssetsAvailable= _totalAssetAvailable(_totalAsset, totalBorrow, false);
  714 |     |             if (_localAssetsAvailable < _amountToReturn) {
  715 |     |                 uint256 _vaultAmt = _amountToReturn - _localAssetsAvailable;
  716 |     |                 _depositFromVault(_vaultAmt);
  717 |     | 
  718 |     |                 // Rewrite to memory, now it's the latest value!
  719 |     |                 _totalAsset = totalAsset;
  720 |     |             }
  721 |     |         }
  722 |     | 
  723 |     |         // Effects: bookkeeping
  724 |     |         _totalAsset.amount -= _amountToReturn;
  725 |     |         _totalAsset.shares -= _shares;
  726 |     | 
  727 |     |         // Effects: write to storage
  728 |     |         totalAsset = _totalAsset;
  729 |     |         _burn(_owner, _shares);
  730 |     | 
  731 |     |         // Interactions
  732 |     |         assetContract.safeTransfer(_receiver, _amountToReturn);
  733 |     |         emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);
  734 |     |     }
  735 |     | 
  736 |     |     function previewRedeem(uint256 _shares) external view returns (uint256 _assets) {
  737 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
  738 |     |         _assets = _totalAsset.toAmount(_shares, false);
  739 |     |     }
  740 |     | 
  741 |     |     /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens
  742 |     |     /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens
  743 |     |     /// @param _receiver The address to which the Asset Tokens will be transferred
  744 |     |     /// @param _owner The owner of the Asset Shares (fTokens)
  745 |     |     /// @return _amountToReturn The amount of Asset Tokens to be transferred
  746 |     |     function redeem(
  747 |     |         uint256 _shares,
  748 |     |         address _receiver,
  749 |     |         address _owner
  750 |     |     ) external nonReentrant returns (uint256 _amountToReturn) {
  751 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  752 |     | 
  753 |     |         // Check if withdraw is paused and revert if necessary
  754 |     |         if (isWithdrawPaused) revert WithdrawPaused();
  755 |     | 
  756 |     |         // Accrue interest if necessary
  757 |     |         _addInterest();
  758 |     | 
  759 |     |         // Pull from storage to save gas
  760 |     |         VaultAccount memory _totalAsset = totalAsset;
  761 |     | 
  762 |     |         // Calculate the number of assets to transfer based on the shares to burn
  763 |     |         _amountToReturn = _totalAsset.toAmount(_shares, false);
  764 |     | 
  765 |     |         // Execute the withdraw effects
  766 |     |         _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner, false);
  767 |     |     }
  768 |     | 
  769 |     |     /// @notice The ```previewWithdraw``` function returns the number of Asset Shares (fTokens) that would be burned for a given amount of Asset Tokens
  770 |     |     /// @param _amount The amount of Asset Tokens to be withdrawn
  771 |     |     /// @return _sharesToBurn The number of shares that would be burned
  772 |     |     function previewWithdraw(uint256 _amount) external view returns (uint256 _sharesToBurn) {
  773 |     |         (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();
  774 |     |         _sharesToBurn = _totalAsset.toShares(_amount, true);
  775 |     |     }
  776 |     | 
  777 |     |     /// @notice The ```withdraw``` function allows the caller to withdraw their Asset Tokens for a given amount of fTokens
  778 |     |     /// @param _amount The amount to withdraw
  779 |     |     /// @param _receiver The address to which the Asset Tokens will be transferred
  780 |     |     /// @param _owner The owner of the Asset Shares (fTokens)
  781 |     |     /// @return _sharesToBurn The number of shares (fTokens) that were burned
  782 |     |     function withdraw(
  783 |     |         uint256 _amount,
  784 |     |         address _receiver,
  785 |     |         address _owner
  786 |     |     ) external nonReentrant returns (uint256 _sharesToBurn) {
  787 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  788 |     | 
  789 |     |         // Check if withdraw is paused and revert if necessary
  790 |     |         if (isWithdrawPaused) revert WithdrawPaused();
  791 |     | 
  792 |     |         // Accrue interest if necessary
  793 |     |         _addInterest();
  794 |     | 
  795 |     |         // Pull from storage to save gas
  796 |     |         VaultAccount memory _totalAsset = totalAsset;
  797 |     | 
  798 |     |         // Calculate the number of shares to burn based on the amount to withdraw
  799 |     |         _sharesToBurn = _totalAsset.toShares(_amount, true);
  800 |     | 
  801 |     |         // Execute the withdraw effects
  802 |     |         _redeem(_totalAsset, _amount.toUint128(), _sharesToBurn.toUint128(), _receiver, _owner, false);
  803 |     |     }
  804 |     | 
  805 |     |     // ============================================================================================
  806 |     |     // Functions: Borrowing
  807 |     |     // ============================================================================================
  808 |     | 
  809 |     |     /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position
  810 |     |     /// @param _borrower The borrower whose account was debited
  811 |     |     /// @param _receiver The address to which the Asset Tokens were transferred
  812 |     |     /// @param _borrowAmount The amount of Asset Tokens transferred
  813 |     |     /// @param _sharesAdded The number of Borrow Shares the borrower was debited
  814 |     |     event BorrowAsset(
  815 |     |         address indexed _borrower,
  816 |     |         address indexed _receiver,
  817 |     |         uint256 _borrowAmount,
  818 |     |         uint256 _sharesAdded
  819 |     |     );
  820 |     | 
  821 |     |     /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets
  822 |     |     /// @param _borrowAmount The amount of the Asset Token to borrow
  823 |     |     /// @param _receiver The address to receive the Asset Tokens
  824 |     |     /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited
  825 |     |     function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {
  826 |     |         // Get borrow accounting from storage to save gas
  827 |     |         VaultAccount memory _totalBorrow = totalBorrow;
  828 |     | 
  829 |     |         // Check available capital (not strictly necessary because balance will underflow, but better revert message)
  830 |     |         uint256 _totalAssetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow, true);
  831 |     |         if (_totalAssetsAvailable < _borrowAmount) {
  832 |     |             revert InsufficientAssetsInContract(_totalAssetsAvailable, _borrowAmount);
  833 |     |         }
  834 |     |         uint256 _localAssetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow, false);
  835 |     |         if (_localAssetsAvailable < _borrowAmount) {
  836 |     |             uint256 _externalAmt = _borrowAmount - _localAssetsAvailable;
  837 |     |             _depositFromVault(_externalAmt);
  838 |     |         }
  839 |     | 
  840 |     |         // Calculate the number of shares to add based on the amount to borrow
  841 |     |         _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);
  842 |     | 
  843 |     |         // Effects: Bookkeeping to add shares & amounts to total Borrow accounting
  844 |     |         _totalBorrow.amount += _borrowAmount;
  845 |     |         _totalBorrow.shares += _sharesAdded.toUint128();
  846 |     |         // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128
  847 |     | 
  848 |     |         // Effects: write back to storage
  849 |     |         totalBorrow = _totalBorrow;
  850 |     |         userBorrowShares[msg.sender] += _sharesAdded;
  851 |     | 
  852 |     |         // Interactions
  853 |     |         if (_receiver != address(this)) {
  854 |     |             assetContract.safeTransfer(_receiver, _borrowAmount);
  855 |     |         }
  856 |     |         emit BorrowAsset(msg.sender, _receiver, _borrowAmount, _sharesAdded);
  857 |     |     }
  858 |     | 
  859 |     |     /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position
  860 |     |     /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable
  861 |     |     /// @param _borrowAmount The amount of Asset Token to borrow
  862 |     |     /// @param _collateralAmount The amount of Collateral Token to transfer to Pair
  863 |     |     /// @param _receiver The address which will receive the Asset Tokens
  864 |     |     /// @return _shares The number of borrow Shares the msg.sender will be debited
  865 |     |     function borrowAsset(
  866 |     |         uint256 _borrowAmount,
  867 |     |         uint256 _collateralAmount,
  868 |     |         address _receiver
  869 |     |     ) external nonReentrant isSolvent(msg.sender) returns (uint256 _shares) {
  870 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  871 |     | 
  872 |     |         // Accrue interest if necessary
  873 |     |         _addInterest();
  874 |     | 
  875 |     |         // Check if borrow will violate the borrow limit and revert if necessary
  876 |     |         if (borrowLimit < totalBorrow.amount + _borrowAmount) revert ExceedsBorrowLimit();
  877 |     | 
  878 |     |         // Update _exchangeRate and check if borrow is allowed based on deviation
  879 |     |         (bool _isBorrowAllowed, , ) = _updateExchangeRate();
  880 |     |         if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();
  881 |     | 
  882 |     |         // Only add collateral if necessary
  883 |     |         if (_collateralAmount > 0) {
  884 |     |             _addCollateral(msg.sender, _collateralAmount, msg.sender);
  885 |     |         }
  886 |     | 
  887 |     |         // Effects: Call internal borrow function
  888 |     |         _shares = _borrowAsset(_borrowAmount.toUint128(), _receiver);
  889 |     |     }
  890 |     | 
  891 |     |     /// @notice The ```AddCollateral``` event is emitted when a borrower adds collateral to their position
  892 |     |     /// @param sender The source of funds for the new collateral
  893 |     |     /// @param borrower The borrower account for which the collateral should be credited
  894 |     |     /// @param collateralAmount The amount of Collateral Token to be transferred
  895 |     |     event AddCollateral(address indexed sender, address indexed borrower, uint256 collateralAmount);
  896 |     | 
  897 |     |     /// @notice The ```_addCollateral``` function is an internal implementation for adding collateral to a borrowers position
  898 |     |     /// @param _sender The source of funds for the new collateral
  899 |     |     /// @param _collateralAmount The amount of Collateral Token to be transferred
  900 |     |     /// @param _borrower The borrower account for which the collateral should be credited
  901 |     |     function _addCollateral(address _sender, uint256 _collateralAmount, address _borrower) internal {
  902 |     |         // Effects: write to state
  903 |     |         userCollateralBalance[_borrower] += _collateralAmount;
  904 |     |         totalCollateral += _collateralAmount;
  905 |     | 
  906 |     |         // Interactions
  907 |     |         if (_sender != address(this)) {
  908 |     |             collateralContract.safeTransferFrom(_sender, address(this), _collateralAmount);
  909 |     |         }
  910 |     |         emit AddCollateral(_sender, _borrower, _collateralAmount);
  911 |     |     }
  912 |     | 
  913 |     |     /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position
  914 |     |     /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation
  915 |     |     /// @param _collateralAmount The amount of Collateral Token to be added to borrower's position
  916 |     |     /// @param _borrower The account to be credited
  917 |     |     function addCollateral(uint256 _collateralAmount, address _borrower) external nonReentrant {
  918 |     |         if (_borrower == address(0)) revert InvalidReceiver();
  919 |     | 
  920 |     |         _addInterest();
  921 |     |         _addCollateral(msg.sender, _collateralAmount, _borrower);
  922 |     |     }
  923 |     | 
  924 |     |     /// @notice The ```RemoveCollateral``` event is emitted when collateral is removed from a borrower's position
  925 |     |     /// @param _sender The account from which funds are transferred
  926 |     |     /// @param _collateralAmount The amount of Collateral Token to be transferred
  927 |     |     /// @param _receiver The address to which Collateral Tokens will be transferred
  928 |     |     event RemoveCollateral(
  929 |     |         address indexed _sender,
  930 |     |         uint256 _collateralAmount,
  931 |     |         address indexed _receiver,
  932 |     |         address indexed _borrower
  933 |     |     );
  934 |     | 
  935 |     |     /// @notice The ```_removeCollateral``` function is the internal implementation for removing collateral from a borrower's position
  936 |     |     /// @param _collateralAmount The amount of Collateral Token to remove from the borrower's position
  937 |     |     /// @param _receiver The address to receive the Collateral Token transferred
  938 |     |     /// @param _borrower The borrower whose account will be debited the Collateral amount
  939 |     |     function _removeCollateral(uint256 _collateralAmount, address _receiver, address _borrower) internal {
  940 |     |         // Effects: write to state
  941 |     |         // NOTE: Following line will revert on underflow if _collateralAmount > userCollateralBalance
  942 |     |         userCollateralBalance[_borrower] -= _collateralAmount;
  943 |     |         // NOTE: Following line will revert on underflow if totalCollateral < _collateralAmount
  944 |     |         totalCollateral -= _collateralAmount;
  945 |     | 
  946 |     |         // Interactions
  947 |     |         if (_receiver != address(this)) {
  948 |     |             collateralContract.safeTransfer(_receiver, _collateralAmount);
  949 |     |         }
  950 |     |         emit RemoveCollateral(msg.sender, _collateralAmount, _receiver, _borrower);
  951 |     |     }
  952 |     | 
  953 |     |     /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender's borrow position
  954 |     |     /// @dev msg.sender must be solvent after invocation or transaction will revert
  955 |     |     /// @param _collateralAmount The amount of Collateral Token to transfer
  956 |     |     /// @param _receiver The address to receive the transferred funds
  957 |     |     function removeCollateral(
  958 |     |         uint256 _collateralAmount,
  959 |     |         address _receiver
  960 |     |     ) external nonReentrant isSolvent(msg.sender) {
  961 |     |         if (_receiver == address(0)) revert InvalidReceiver();
  962 |     | 
  963 |     |         _addInterest();
  964 |     |         // Note: exchange rate is irrelevant when borrower has no debt shares
  965 |     |         if (userBorrowShares[msg.sender] > 0) {
  966 |     |             (bool _isBorrowAllowed, , ) = _updateExchangeRate();
  967 |     |             if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();
  968 |     |         }
  969 |     |         _removeCollateral(_collateralAmount, _receiver, msg.sender);
  970 |     |     }
  971 |     | 
  972 |     |     /// @notice The ```RepayAsset``` event is emitted whenever a debt position is repaid
  973 |     |     /// @param payer The address paying for the repayment
  974 |     |     /// @param borrower The borrower whose account will be credited
  975 |     |     /// @param amountToRepay The amount of Asset token to be transferred
  976 |     |     /// @param shares The amount of Borrow Shares which will be debited from the borrower after repayment
  977 |     |     event RepayAsset(address indexed payer, address indexed borrower, uint256 amountToRepay, uint256 shares);
  978 |     | 
  979 |     |     /// @notice The ```_repayAsset``` function is the internal implementation for repaying a borrow position
  980 |     |     /// @dev The payer must have called ERC20.approve() on the Asset Token contract prior to invocation
  981 |     |     /// @param _totalBorrow An in memory copy of the totalBorrow VaultAccount struct
  982 |     |     /// @param _amountToRepay The amount of Asset Token to transfer
  983 |     |     /// @param _shares The number of Borrow Shares the sender is repaying
  984 |     |     /// @param _payer The address from which funds will be transferred
  985 |     |     /// @param _borrower The borrower account which will be credited
  986 |     |     function _repayAsset(
  987 |     |         VaultAccount memory _totalBorrow,
  988 |     |         uint128 _amountToRepay,
  989 |     |         uint128 _shares,
  990 |     |         address _payer,
  991 |     |         address _borrower
  992 |     |     ) internal {
  993 |     |         // Effects: Bookkeeping
  994 |     |         _totalBorrow.amount -= _amountToRepay;
  995 |     |         _totalBorrow.shares -= _shares;
  996 |     | 
  997 |     |         // Effects: write to state
  998 |     |         userBorrowShares[_borrower] -= _shares;
  999 |     |         totalBorrow = _totalBorrow;
 1000 |     | 
 1001 |     |         // Interactions
 1002 |     |         if (_payer != address(this)) {
 1003 |     |             assetContract.safeTransferFrom(_payer, address(this), _amountToRepay);
 1004 |     |         }
 1005 |     |         externalAssetVault.whitelistUpdate();
 1006 |     |         uint256 _externalAssetsToWithdraw = externalAssetVault.vaultUtilization(address(this));
 1007 |     |         if (_externalAssetsToWithdraw > 0) {
 1008 |     |             uint256 _extAmount = _externalAssetsToWithdraw > _amountToRepay ? _amountToRepay : _externalAssetsToWithdraw;
 1009 |     |             _withdrawToVault(_extAmount);
 1010 |     |         }
 1011 |     |         emit RepayAsset(_payer, _borrower, _amountToRepay, _shares);
 1012 |     |     }
 1013 |     | 
 1014 |     |     /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.
 1015 |     |     /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract
 1016 |     |     /// @param _shares The number of Borrow Shares which will be repaid by the call
 1017 |     |     /// @param _borrower The account for which the debt will be reduced
 1018 |     |     /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares
 1019 |     |     function repayAsset(uint256 _shares, address _borrower) external nonReentrant returns (uint256 _amountToRepay) {
 1020 |     |         if (_borrower == address(0)) revert InvalidReceiver();
 1021 |     | 
 1022 |     |         // Check if repay is paused revert if necessary
 1023 |     |         if (isRepayPaused) revert RepayPaused();
 1024 |     | 
 1025 |     |         // Accrue interest if necessary
 1026 |     |         _addInterest();
 1027 |     | 
 1028 |     |         // Calculate amount to repay based on shares
 1029 |     |         VaultAccount memory _totalBorrow = totalBorrow;
 1030 |     |         _amountToRepay = _totalBorrow.toAmount(_shares, true);
 1031 |     | 
 1032 |     |         // Execute repayment effects
 1033 |     |         _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower);
 1034 |     |     }
 1035 |     | 
 1036 |     |     // ============================================================================================
 1037 |     |     // Functions: Liquidations
 1038 |     |     // ============================================================================================
 1039 |     |     /// @notice The ```Liquidate``` event is emitted when a liquidation occurs
 1040 |     |     /// @param _borrower The borrower account for which the liquidation occurred
 1041 |     |     /// @param _collateralForLiquidator The amount of Collateral Token transferred to the liquidator
 1042 |     |     /// @param _sharesToLiquidate The number of Borrow Shares the liquidator repaid on behalf of the borrower
 1043 |     |     /// @param _sharesToAdjust The number of Borrow Shares that were adjusted on liabilities and assets (a writeoff)
 1044 |     |     event Liquidate(
 1045 |     |         address indexed _borrower,
 1046 |     |         uint256 _collateralForLiquidator,
 1047 |     |         uint256 _sharesToLiquidate,
 1048 |     |         uint256 _amountLiquidatorToRepay,
 1049 |     |         uint256 _feesAmount,
 1050 |     |         uint256 _sharesToAdjust,
 1051 |     |         uint256 _amountToAdjust
 1052 |     |     );
 1053 |     | 
 1054 |     |     /// @notice The ```liquidate``` function allows a third party to repay a borrower's debt if they have become insolvent
 1055 |     |     /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```
 1056 |     |     /// @param _sharesToLiquidate The number of Borrow Shares repaid by the liquidator
 1057 |     |     /// @param _deadline The timestamp after which tx will revert
 1058 |     |     /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken
 1059 |     |     /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator
 1060 |     |     function liquidate(
 1061 |     |         uint128 _sharesToLiquidate,
 1062 |     |         uint256 _deadline,
 1063 |     |         address _borrower
 1064 |     |     ) external nonReentrant returns (uint256 _collateralForLiquidator) {
 1065 |     |         if (_borrower == address(0)) revert InvalidReceiver();
 1066 |     | 
 1067 |     |         // Check if liquidate is paused revert if necessary
 1068 |     |         if (isLiquidatePaused) revert LiquidatePaused();
 1069 |     | 
 1070 |     |         // Ensure deadline has not passed
 1071 |     |         if (block.timestamp > _deadline) revert PastDeadline(block.timestamp, _deadline);
 1072 |     | 
 1073 |     |         // accrue interest if necessary
 1074 |     |         _addInterest();
 1075 |     | 
 1076 |     |         // Update exchange rate and use the lower rate for liquidations
 1077 |     |         (, uint256 _exchangeRate, ) = _updateExchangeRate();
 1078 |     | 
 1079 |     |         // Check if borrower is solvent, revert if they are
 1080 |     |         if (_isSolvent(_borrower, _exchangeRate)) {
 1081 |     |             revert BorrowerSolvent();
 1082 |     |         }
 1083 |     | 
 1084 |     |         // Read from state
 1085 |     |         VaultAccount memory _totalBorrow = totalBorrow;
 1086 |     |         uint256 _userCollateralBalance = userCollateralBalance[_borrower];
 1087 |     |         uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();
 1088 |     | 
 1089 |     |         // Prevent stack-too-deep
 1090 |     |         int256 _leftoverCollateral;
 1091 |     |         uint256 _feesAmount;
 1092 |     |         {
 1093 |     |             // Checks & Calculations
 1094 |     |             // Determine the liquidation amount in collateral units (i.e. how much debt liquidator is going to repay)
 1095 |     |             uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *
 1096 |     |                 _exchangeRate) / EXCHANGE_PRECISION);
 1097 |     | 
 1098 |     |             // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee
 1099 |     |             // This fee only applies if the liquidator does a full liquidation
 1100 |     |             uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *
 1101 |     |                 (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;
 1102 |     | 
 1103 |     |             // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value
 1104 |     |             // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)
 1105 |     |             _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());
 1106 |     | 
 1107 |     |             // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral
 1108 |     |             // This will only be true when there liquidator is cleaning out the position
 1109 |     |             _collateralForLiquidator = _leftoverCollateral <= 0
 1110 |     |                 ? _userCollateralBalance
 1111 |     |                 : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;
 1112 |     | 
 1113 |     |             if (protocolLiquidationFee > 0) {
 1114 |     |                 _feesAmount = (protocolLiquidationFee * _collateralForLiquidator) / LIQ_PRECISION;
 1115 |     |                 _collateralForLiquidator = _collateralForLiquidator - _feesAmount;
 1116 |     |             }
 1117 |     |         }
 1118 |     | 
 1119 |     |         // Calculated here for use during repayment, grouped with other calcs before effects start
 1120 |     |         uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();
 1121 |     | 
 1122 |     |         // Determine if and how much debt to adjust
 1123 |     |         uint128 _sharesToAdjust = 0;
 1124 |     |         {
 1125 |     |             uint128 _amountToAdjust = 0;
 1126 |     |             if (_leftoverCollateral <= 0) {
 1127 |     |                 // Determine if we need to adjust any shares
 1128 |     |                 _sharesToAdjust = _borrowerShares - _sharesToLiquidate;
 1129 |     |                 if (_sharesToAdjust > 0) {
 1130 |     |                     // Write off bad debt
 1131 |     |                     _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();
 1132 |     | 
 1133 |     |                     // Note: Ensure this memory struct will be passed to _repayAsset for write to state
 1134 |     |                     _totalBorrow.amount -= _amountToAdjust;
 1135 |     | 
 1136 |     |                     // Effects: write to state
 1137 |     |                     totalAsset.amount -= _amountToAdjust;
 1138 |     |                 }
 1139 |     |             }
 1140 |     |             emit Liquidate(
 1141 |     |                 _borrower,
 1142 |     |                 _collateralForLiquidator,
 1143 |     |                 _sharesToLiquidate,
 1144 |     |                 _amountLiquidatorToRepay,
 1145 |     |                 _feesAmount,
 1146 |     |                 _sharesToAdjust,
 1147 |     |                 _amountToAdjust
 1148 |     |             );
 1149 |     |         }
 1150 |     | 
 1151 |     |         // Effects & Interactions
 1152 |     |         // NOTE: reverts if _shares > userBorrowShares
 1153 |     |         _repayAsset(
 1154 |     |             _totalBorrow,
 1155 |     |             _amountLiquidatorToRepay,
 1156 |     |             _sharesToLiquidate + _sharesToAdjust,
 1157 |     |             msg.sender,
 1158 |     |             _borrower
 1159 |     |         ); // liquidator repays shares on behalf of borrower
 1160 |     |         // NOTE: reverts if _collateralForLiquidator > userCollateralBalance
 1161 |     |         // Collateral is removed on behalf of borrower and sent to liquidator
 1162 |     |         // NOTE: reverts if _collateralForLiquidator > userCollateralBalance
 1163 |     |         _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);
 1164 |     |         // Adjust bookkeeping only (decreases collateral held by borrower)
 1165 |     |         _removeCollateral(_feesAmount, address(this), _borrower);
 1166 |     |         // Adjusts bookkeeping only (increases collateral held by protocol)
 1167 |     |         _addCollateral(address(this), _feesAmount, address(this));
 1168 |     |     }
 1169 |     | 
 1170 |     |     // ============================================================================================
 1171 |     |     // Functions: Leverage
 1172 |     |     // ============================================================================================
 1173 |     | 
 1174 |     |     /// @notice The ```LeveragedPosition``` event is emitted when a borrower takes out a new leveraged position
 1175 |     |     /// @param _borrower The account for which the debt is debited
 1176 |     |     /// @param _swapperAddress The address of the swapper which conforms the FraxSwap interface
 1177 |     |     /// @param _borrowAmount The amount of Asset Token to be borrowed to be borrowed
 1178 |     |     /// @param _borrowShares The number of Borrow Shares the borrower is credited
 1179 |     |     /// @param _initialCollateralAmount The amount of initial Collateral Tokens supplied by the borrower
 1180 |     |     /// @param _amountCollateralOut The amount of Collateral Token which was received for the Asset Tokens
 1181 |     |     event LeveragedPosition(
 1182 |     |         address indexed _borrower,
 1183 |     |         address _swapperAddress,
 1184 |     |         uint256 _borrowAmount,
 1185 |     |         uint256 _borrowShares,
 1186 |     |         uint256 _initialCollateralAmount,
 1187 |     |         uint256 _amountCollateralOut
 1188 |     |     );
 1189 |     | 
 1190 |     |     /// @notice The ```leveragedPosition``` function allows a user to enter a leveraged borrow position with minimal upfront Collateral
 1191 |     |     /// @dev Caller must invoke ```ERC20.approve()``` on the Collateral Token contract prior to calling function
 1192 |     |     /// @param _swapperAddress The address of the whitelisted swapper to use to swap borrowed Asset Tokens for Collateral Tokens
 1193 |     |     /// @param _borrowAmount The amount of Asset Tokens borrowed
 1194 |     |     /// @param _initialCollateralAmount The initial amount of Collateral Tokens supplied by the borrower
 1195 |     |     /// @param _amountCollateralOutMin The minimum amount of Collateral Tokens to be received in exchange for the borrowed Asset Tokens
 1196 |     |     /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.
 1197 |     |     /// @return _totalCollateralBalance The total amount of Collateral Tokens added to a users account (initial + swap)
 1198 |     |     function leveragedPosition(
 1199 |     |         address _swapperAddress,
 1200 |     |         uint256 _borrowAmount,
 1201 |     |         uint256 _initialCollateralAmount,
 1202 |     |         uint256 _amountCollateralOutMin,
 1203 |     |         address[] memory _path
 1204 |     |     ) external nonReentrant isSolvent(msg.sender) returns (uint256 _totalCollateralBalance) {
 1205 |     |         // Accrue interest if necessary
 1206 |     |         _addInterest();
 1207 |     | 
 1208 |     |         // Update exchange rate and check if borrow is allowed, revert if not
 1209 |     |         {
 1210 |     |             (bool _isBorrowAllowed, , ) = _updateExchangeRate();
 1211 |     |             if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();
 1212 |     |         }
 1213 |     | 
 1214 |     |         IERC20 _assetContract = assetContract;
 1215 |     |         IERC20 _collateralContract = collateralContract;
 1216 |     | 
 1217 |     |         if (!swappers[_swapperAddress]) {
 1218 |     |             revert BadSwapper();
 1219 |     |         }
 1220 |     |         if (_path[0] != address(_assetContract)) {
 1221 |     |             revert InvalidPath(address(_assetContract), _path[0]);
 1222 |     |         }
 1223 |     |         if (_path[_path.length - 1] != address(_collateralContract)) {
 1224 |     |             revert InvalidPath(address(_collateralContract), _path[_path.length - 1]);
 1225 |     |         }
 1226 |     | 
 1227 |     |         // Add initial collateral
 1228 |     |         if (_initialCollateralAmount > 0) {
 1229 |     |             _addCollateral(msg.sender, _initialCollateralAmount, msg.sender);
 1230 |     |         }
 1231 |     | 
 1232 |     |         // Debit borrowers account
 1233 |     |         // setting recipient to address(this) means no transfer will happen
 1234 |     |         uint256 _borrowShares = _borrowAsset(_borrowAmount.toUint128(), address(this));
 1235 |     | 
 1236 |     |         // Interactions
 1237 |     |         _assetContract.approve(_swapperAddress, _borrowAmount);
 1238 |     | 
 1239 |     |         // Even though swappers are trusted, we verify the balance before and after swap
 1240 |     |         uint256 _initialCollateralBalance = _collateralContract.balanceOf(address(this));
 1241 |     |         ISwapper(_swapperAddress).swapExactTokensForTokens(
 1242 |     |             _borrowAmount,
 1243 |     |             _amountCollateralOutMin,
 1244 |     |             _path,
 1245 |     |             address(this),
 1246 |     |             block.timestamp
 1247 |     |         );
 1248 |     |         uint256 _finalCollateralBalance = _collateralContract.balanceOf(address(this));
 1249 |     | 
 1250 |     |         // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT
 1251 |     |         // Effects: bookkeeping & write to state
 1252 |     |         uint256 _amountCollateralOut = _finalCollateralBalance - _initialCollateralBalance;
 1253 |     |         if (_amountCollateralOut < _amountCollateralOutMin) {
 1254 |     |             revert SlippageTooHigh(_amountCollateralOutMin, _amountCollateralOut);
 1255 |     |         }
 1256 |     | 
 1257 |     |         // address(this) as _sender means no transfer occurs as the pair has already received the collateral during swap
 1258 |     |         _addCollateral(address(this), _amountCollateralOut, msg.sender);
 1259 |     | 
 1260 |     |         _totalCollateralBalance = _initialCollateralAmount + _amountCollateralOut;
 1261 |     |         emit LeveragedPosition(
 1262 |     |             msg.sender,
 1263 |     |             _swapperAddress,
 1264 |     |             _borrowAmount,
 1265 |     |             _borrowShares,
 1266 |     |             _initialCollateralAmount,
 1267 |     |             _amountCollateralOut
 1268 |     |         );
 1269 |     |     }
 1270 |     | 
 1271 |     |     /// @notice The ```RepayAssetWithCollateral``` event is emitted whenever ```repayAssetWithCollateral()``` is invoked
 1272 |     |     /// @param _borrower The borrower account for which the repayment is taking place
 1273 |     |     /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps
 1274 |     |     /// @param _collateralToSwap The amount of Collateral Token to swap and use for repayment
 1275 |     |     /// @param _amountAssetOut The amount of Asset Token which was repaid
 1276 |     |     /// @param _sharesRepaid The number of Borrow Shares which were repaid
 1277 |     |     event RepayAssetWithCollateral(
 1278 |     |         address indexed _borrower,
 1279 |     |         address _swapperAddress,
 1280 |     |         uint256 _collateralToSwap,
 1281 |     |         uint256 _amountAssetOut,
 1282 |     |         uint256 _sharesRepaid
 1283 |     |     );
 1284 |     | 
 1285 |     |     /// @notice The ```repayAssetWithCollateral``` function allows a borrower to repay their debt using existing collateral in contract
 1286 |     |     /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps
 1287 |     |     /// @param _collateralToSwap The amount of Collateral Tokens to swap for Asset Tokens
 1288 |     |     /// @param _amountAssetOutMin The minimum amount of Asset Tokens to receive during the swap
 1289 |     |     /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.
 1290 |     |     /// @return _amountAssetOut The amount of Asset Tokens received for the Collateral Tokens, the amount the borrowers account was credited
 1291 |     |     function repayAssetWithCollateral(
 1292 |     |         address _swapperAddress,
 1293 |     |         uint256 _collateralToSwap,
 1294 |     |         uint256 _amountAssetOutMin,
 1295 |     |         address[] calldata _path
 1296 |     |     ) external nonReentrant isSolvent(msg.sender) returns (uint256 _amountAssetOut) {
 1297 |     |         // Accrue interest if necessary
 1298 |     |         _addInterest();
 1299 |     | 
 1300 |     |         // Update exchange rate and check if borrow is allowed, revert if not
 1301 |     |         (bool _isBorrowAllowed, , ) = _updateExchangeRate();
 1302 |     |         if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();
 1303 |     | 
 1304 |     |         IERC20 _assetContract = assetContract;
 1305 |     |         IERC20 _collateralContract = collateralContract;
 1306 |     | 
 1307 |     |         if (!swappers[_swapperAddress]) {
 1308 |     |             revert BadSwapper();
 1309 |     |         }
 1310 |     |         if (_path[0] != address(_collateralContract)) {
 1311 |     |             revert InvalidPath(address(_collateralContract), _path[0]);
 1312 |     |         }
 1313 |     |         if (_path[_path.length - 1] != address(_assetContract)) {
 1314 |     |             revert InvalidPath(address(_assetContract), _path[_path.length - 1]);
 1315 |     |         }
 1316 |     | 
 1317 |     |         // Effects: bookkeeping & write to state
 1318 |     |         // Debit users collateral balance in preparation for swap, setting _recipient to address(this) means no transfer occurs
 1319 |     |         _removeCollateral(_collateralToSwap, address(this), msg.sender);
 1320 |     | 
 1321 |     |         // Interactions
 1322 |     |         _collateralContract.approve(_swapperAddress, _collateralToSwap);
 1323 |     | 
 1324 |     |         // Even though swappers are trusted, we verify the balance before and after swap
 1325 |     |         uint256 _initialAssetBalance = _assetContract.balanceOf(address(this));
 1326 |     |         ISwapper(_swapperAddress).swapExactTokensForTokens(
 1327 |     |             _collateralToSwap,
 1328 |     |             _amountAssetOutMin,
 1329 |     |             _path,
 1330 |     |             address(this),
 1331 |     |             block.timestamp
 1332 |     |         );
 1333 |     |         uint256 _finalAssetBalance = _assetContract.balanceOf(address(this));
 1334 |     | 
 1335 |     |         // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT
 1336 |     |         // Effects: bookkeeping
 1337 |     |         _amountAssetOut = _finalAssetBalance - _initialAssetBalance;
 1338 |     |         if (_amountAssetOut < _amountAssetOutMin) {
 1339 |     |             revert SlippageTooHigh(_amountAssetOutMin, _amountAssetOut);
 1340 |     |         }
 1341 |     | 
 1342 |     |         VaultAccount memory _totalBorrow = totalBorrow;
 1343 |     |         uint256 _sharesToRepay = _totalBorrow.toShares(_amountAssetOut, false);
 1344 |     | 
 1345 |     |         // Effects: write to state
 1346 |     |         // Note: setting _payer to address(this) means no actual transfer will occur.  Contract already has funds
 1347 |     |         _repayAsset(_totalBorrow, _amountAssetOut.toUint128(), _sharesToRepay.toUint128(), address(this), msg.sender);
 1348 |     | 
 1349 |     |         emit RepayAssetWithCollateral(msg.sender, _swapperAddress, _collateralToSwap, _amountAssetOut, _sharesToRepay);
 1350 |     |     }
 1351 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairDeployer.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ====================== FraxlendPairDeployer ========================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | // Sam Kazemian: https://github.com/samkazemian
  22 |     | // Travis Moore: https://github.com/FortisFortuna
  23 |     | // Jack Corddry: https://github.com/corddry
  24 |     | // Rich Gee: https://github.com/zer0blockchain
  25 |     | 
  26 |     | // ====================================================================
  27 |     | 
  28 |     | import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  29 |     | import { Ownable } from "@openzeppelin/contracts/access/Ownable.sol";
  30 |     | import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";
  31 |     | import { SSTORE2 } from "@rari-capital/solmate/src/utils/SSTORE2.sol";
  32 |     | import { BytesLib } from "solidity-bytes-utils/contracts/BytesLib.sol";
  33 |     | import { IFraxlendWhitelist } from "./interfaces/IFraxlendWhitelist.sol";
  34 |     | import { IFraxlendPair } from "./interfaces/IFraxlendPair.sol";
  35 |     | import { IFraxlendPairRegistry } from "./interfaces/IFraxlendPairRegistry.sol";
  36 |     | import { SafeERC20 } from "./libraries/SafeERC20.sol";
  37 |     | 
  38 |     | // solhint-disable no-inline-assembly
  39 |     | 
  40 |     | struct ConstructorParams {
  41 |     |     address circuitBreaker;
  42 |     |     address comptroller;
  43 |     |     address timelock;
  44 |     |     address fraxlendWhitelist;
  45 |     |     address fraxlendPairRegistry;
  46 |     | }
  47 |     | 
  48 |     | /// @title FraxlendPairDeployer
  49 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
  50 |     | /// @notice Deploys and initializes new FraxlendPairs
  51 |     | /// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs
  52 |     | contract FraxlendPairDeployer is Ownable {
  53 |     |     using Strings for uint256;
  54 |     |     using SafeERC20 for IERC20;
  55 |     | 
  56 |     |     // Storage
  57 |     |     address public contractAddress1;
  58 |     |     address public contractAddress2;
  59 |     | 
  60 |     |     // Admin contracts
  61 |     |     address public circuitBreakerAddress;
  62 |     |     address public comptrollerAddress;
  63 |     |     address public timelockAddress;
  64 |     |     address public fraxlendPairRegistryAddress;
  65 |     |     address public fraxlendWhitelistAddress;
  66 |     | 
  67 |     |     // Default swappers
  68 |     |     address[] public defaultSwappers;
  69 |     | 
  70 |     |     /// @notice Emits when a new pair is deployed
  71 |     |     /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed
  72 |     |     /// @param address_ The address of the pair
  73 |     |     /// @param asset The address of the Asset Token contract
  74 |     |     /// @param collateral The address of the Collateral Token contract
  75 |     |     /// @param name The name of the Pair
  76 |     |     /// @param configData The config data of the Pair
  77 |     |     /// @param immutables The immutables of the Pair
  78 |     |     /// @param customConfigData The custom config data of the Pair
  79 |     |     event LogDeploy(
  80 |     |         address indexed address_,
  81 |     |         address indexed asset,
  82 |     |         address indexed collateral,
  83 |     |         string name,
  84 |     |         bytes configData,
  85 |     |         bytes immutables,
  86 |     |         bytes customConfigData
  87 |     |     );
  88 |     | 
  89 |     |     /// @notice List of the names of all deployed Pairs
  90 |     |     address[] public deployedPairsArray;
  91 |     | 
  92 |     |     constructor(ConstructorParams memory _params) Ownable() {
  93 |     |         circuitBreakerAddress = _params.circuitBreaker;
  94 |     |         comptrollerAddress = _params.comptroller;
  95 |     |         timelockAddress = _params.timelock;
  96 |     |         fraxlendWhitelistAddress = _params.fraxlendWhitelist;
  97 |     |         fraxlendPairRegistryAddress = _params.fraxlendPairRegistry;
  98 |     |     }
  99 |     | 
 100 |     |     function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {
 101 |     |         return (4, 1, 0);
 102 |     |     }
 103 |     | 
 104 |     |     // ============================================================================================
 105 |     |     // Functions: View Functions
 106 |     |     // ============================================================================================
 107 |     | 
 108 |     |     /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray
 109 |     |     /// @return length of array
 110 |     |     function deployedPairsLength() external view returns (uint256) {
 111 |     |         return deployedPairsArray.length;
 112 |     |     }
 113 |     | 
 114 |     |     /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray
 115 |     |     /// @return _deployedPairs memory All deployed pair addresses
 116 |     |     function getAllPairAddresses() external view returns (address[] memory _deployedPairs) {
 117 |     |         _deployedPairs = deployedPairsArray;
 118 |     |     }
 119 |     | 
 120 |     |     function getNextNameSymbol(
 121 |     |         address _asset,
 122 |     |         address _collateral
 123 |     |     ) public view returns (string memory _name, string memory _symbol) {
 124 |     |         uint256 _length = IFraxlendPairRegistry(fraxlendPairRegistryAddress).deployedPairsLength();
 125 |     |         _name = string(
 126 |     |             abi.encodePacked(
 127 |     |                 "Fraxlend Interest Bearing ",
 128 |     |                 IERC20(_asset).safeSymbol(),
 129 |     |                 " (",
 130 |     |                 IERC20(_collateral).safeName(),
 131 |     |                 ")",
 132 |     |                 " - ",
 133 |     |                 (_length + 1).toString()
 134 |     |             )
 135 |     |         );
 136 |     |         _symbol = string(
 137 |     |             abi.encodePacked(
 138 |     |                 "f",
 139 |     |                 IERC20(_asset).safeSymbol(),
 140 |     |                 "(",
 141 |     |                 IERC20(_collateral).safeSymbol(),
 142 |     |                 ")",
 143 |     |                 "-",
 144 |     |                 (_length + 1).toString()
 145 |     |             )
 146 |     |         );
 147 |     |     }
 148 |     | 
 149 |     |     // ============================================================================================
 150 |     |     // Functions: Setters
 151 |     |     // ============================================================================================
 152 |     | 
 153 |     |     /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair
 154 |     |     /// @dev splits the data if necessary to accommodate creation code that is slightly larger than 24kb
 155 |     |     /// @param _creationCode The creationCode for the Fraxlend Pair
 156 |     |     function setCreationCode(bytes calldata _creationCode) external onlyOwner {
 157 |     |         bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13_000);
 158 |     |         contractAddress1 = SSTORE2.write(_firstHalf);
 159 |     |         if (_creationCode.length > 13_000) {
 160 |     |             bytes memory _secondHalf = BytesLib.slice(_creationCode, 13_000, _creationCode.length - 13_000);
 161 |     |             contractAddress2 = SSTORE2.write(_secondHalf);
 162 |     |         }
 163 |     |     }
 164 |     | 
 165 |     |     /// @notice The ```setDefaultSwappers``` function is used to set default list of approved swappers
 166 |     |     /// @param _swappers The list of swappers to set as default allowed
 167 |     |     function setDefaultSwappers(address[] memory _swappers) external onlyOwner {
 168 |     |         defaultSwappers = _swappers;
 169 |     |     }
 170 |     | 
 171 |     |     /// @notice The ```SetTimelock``` event is emitted when the timelockAddress is set
 172 |     |     /// @param oldAddress The original address
 173 |     |     /// @param newAddress The new address
 174 |     |     event SetTimelock(address oldAddress, address newAddress);
 175 |     | 
 176 |     |     /// @notice The ```setTimelock``` function sets the timelockAddress
 177 |     |     /// @param _newAddress the new time lock address
 178 |     |     function setTimelock(address _newAddress) external onlyOwner {
 179 |     |         emit SetTimelock(timelockAddress, _newAddress);
 180 |     |         timelockAddress = _newAddress;
 181 |     |     }
 182 |     | 
 183 |     |     /// @notice The ```SetRegistry``` event is emitted when the fraxlendPairRegistryAddress is set
 184 |     |     /// @param oldAddress The old address
 185 |     |     /// @param newAddress The new address
 186 |     |     event SetRegistry(address oldAddress, address newAddress);
 187 |     | 
 188 |     |     /// @notice The ```setRegistry``` function sets the fraxlendPairRegistryAddress
 189 |     |     /// @param _newAddress The new address
 190 |     |     function setRegistry(address _newAddress) external onlyOwner {
 191 |     |         emit SetRegistry(fraxlendPairRegistryAddress, _newAddress);
 192 |     |         fraxlendPairRegistryAddress = _newAddress;
 193 |     |     }
 194 |     | 
 195 |     |     /// @notice The ```SetComptroller``` event is emitted when the comptrollerAddress is set
 196 |     |     /// @param oldAddress The old address
 197 |     |     /// @param newAddress The new address
 198 |     |     event SetComptroller(address oldAddress, address newAddress);
 199 |     | 
 200 |     |     /// @notice The ```setComptroller``` function sets the comptrollerAddress
 201 |     |     /// @param _newAddress The new address
 202 |     |     function setComptroller(address _newAddress) external onlyOwner {
 203 |     |         emit SetComptroller(comptrollerAddress, _newAddress);
 204 |     |         comptrollerAddress = _newAddress;
 205 |     |     }
 206 |     | 
 207 |     |     /// @notice The ```SetWhitelist``` event is emitted when the fraxlendWhitelistAddress is set
 208 |     |     /// @param oldAddress The old address
 209 |     |     /// @param newAddress The new address
 210 |     |     event SetWhitelist(address oldAddress, address newAddress);
 211 |     | 
 212 |     |     /// @notice The ```setWhitelist``` function sets the fraxlendWhitelistAddress
 213 |     |     /// @param _newAddress The new address
 214 |     |     function setWhitelist(address _newAddress) external onlyOwner {
 215 |     |         emit SetWhitelist(fraxlendWhitelistAddress, _newAddress);
 216 |     |         fraxlendWhitelistAddress = _newAddress;
 217 |     |     }
 218 |     | 
 219 |     |     /// @notice The ```SetCircuitBreaker``` event is emitted when the circuitBreakerAddress is set
 220 |     |     /// @param oldAddress The old address
 221 |     |     /// @param newAddress The new address
 222 |     |     event SetCircuitBreaker(address oldAddress, address newAddress);
 223 |     | 
 224 |     |     /// @notice The ```setCircuitBreaker``` function sets the circuitBreakerAddress
 225 |     |     /// @param _newAddress The new address
 226 |     |     function setCircuitBreaker(address _newAddress) external onlyOwner {
 227 |     |         emit SetCircuitBreaker(circuitBreakerAddress, _newAddress);
 228 |     |         circuitBreakerAddress = _newAddress;
 229 |     |     }
 230 |     | 
 231 |     |     // ============================================================================================
 232 |     |     // Functions: Internal Methods
 233 |     |     // ============================================================================================
 234 |     | 
 235 |     |     /// @notice The ```_deploy``` function is an internal function with deploys the pair
 236 |     |     /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)
 237 |     |     /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)
 238 |     |     /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)
 239 |     |     /// @return _pairAddress The address to which the Pair was deployed
 240 |     |     function _deploy(
 241 |     |         bytes memory _configData,
 242 |     |         bytes memory _immutables,
 243 |     |         bytes memory _customConfigData
 244 |     |     ) private returns (address _pairAddress) {
 245 |     |         // Get creation code
 246 |     |         emit Debug("GETTING CREATION CODE");
 247 |     |         bytes memory _creationCode = BytesLib.concat(SSTORE2.read(contractAddress1), SSTORE2.read(contractAddress2));
 248 |     | 
 249 |     |         emit Debug("GETTING BYTECODE");
 250 |     |         // Get bytecode
 251 |     |         bytes memory bytecode = abi.encodePacked(
 252 |     |             _creationCode,
 253 |     |             abi.encode(_configData, _immutables, _customConfigData)
 254 |     |         );
 255 |     | 
 256 |     |         emit Debug("GETTING SALT");
 257 |     |         // Generate salt using constructor params
 258 |     |         bytes32 salt = keccak256(abi.encodePacked(_configData, _immutables, _customConfigData));
 259 |     | 
 260 |     |         /// @solidity memory-safe-assembly
 261 |     |         assembly {
 262 |     |             _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)
 263 |     |         }
 264 |     |         if (_pairAddress == address(0)) revert Create2Failed();
 265 |     | 
 266 |     |         deployedPairsArray.push(_pairAddress);
 267 |     | 
 268 |     |         // Set additional values for FraxlendPair
 269 |     |         IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);
 270 |     |         address[] memory _defaultSwappers = defaultSwappers;
 271 |     |         for (uint256 i = 0; i < _defaultSwappers.length; i++) {
 272 |     |             _fraxlendPair.setSwapper(_defaultSwappers[i], true);
 273 |     |         }
 274 |     | 
 275 |     |         return _pairAddress;
 276 |     |     }
 277 |     | 
 278 |     |     // ============================================================================================
 279 |     |     // Functions: External Deploy Methods
 280 |     |     // ============================================================================================
 281 |     | 
 282 |     |     event Debug(string a);
 283 |     | 
 284 |     |     /// @notice The ```deploy``` function allows the deployment of a FraxlendPair with default values
 285 |     |     /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)
 286 |     |     /// @return _pairAddress The address to which the Pair was deployed
 287 |     |     function deploy(bytes memory _configData) external returns (address _pairAddress) {
 288 |     |         if (!IFraxlendWhitelist(fraxlendWhitelistAddress).fraxlendDeployerWhitelist(msg.sender)) {
 289 |     |             revert WhitelistedDeployersOnly();
 290 |     |         }
 291 |     | 
 292 |     |         (address _asset, address _collateral, , , , , , , ) = abi.decode(
 293 |     |             _configData,
 294 |     |             (address, address, address, uint32, address, uint64, uint256, uint256, uint256)
 295 |     |         );
 296 |     | 
 297 |     |         (string memory _name, string memory _symbol) = getNextNameSymbol(_asset, _collateral);
 298 |     | 
 299 |     |         bytes memory _immutables = abi.encode(circuitBreakerAddress, comptrollerAddress, timelockAddress);
 300 |     |         bytes memory _customConfigData = abi.encode(_name, _symbol, IERC20(_asset).safeDecimals());
 301 |     | 
 302 |     |         emit Debug("ABOUT TO DEPLOY");
 303 |     |         _pairAddress = _deploy(_configData, _immutables, _customConfigData);
 304 |     | 
 305 |     |         IFraxlendPairRegistry(fraxlendPairRegistryAddress).addPair(_pairAddress);
 306 |     | 
 307 |     |         emit LogDeploy(_pairAddress, _asset, _collateral, _name, _configData, _immutables, _customConfigData);
 308 |     |     }
 309 |     | 
 310 |     |     // ============================================================================================
 311 |     |     // Functions: Admin
 312 |     |     // ============================================================================================
 313 |     | 
 314 |     |     /// @notice The ```globalPause``` function calls the pause() function on a given set of pair addresses
 315 |     |     /// @dev Ignores reverts when calling pause()
 316 |     |     /// @param _addresses Addresses to attempt to pause()
 317 |     |     /// @return _updatedAddresses Addresses for which pause() was successful
 318 |     |     function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {
 319 |     |         if (msg.sender != circuitBreakerAddress) revert CircuitBreakerOnly();
 320 |     | 
 321 |     |         address _pairAddress;
 322 |     |         uint256 _lengthOfArray = _addresses.length;
 323 |     |         _updatedAddresses = new address[](_lengthOfArray);
 324 |     |         for (uint256 i = 0; i < _lengthOfArray; ) {
 325 |     |             _pairAddress = _addresses[i];
 326 |     |             try IFraxlendPair(_pairAddress).pause() {
 327 |     |                 _updatedAddresses[i] = _addresses[i];
 328 |     |             } catch {}
 329 |     |             unchecked {
 330 |     |                 i = i + 1;
 331 |     |             }
 332 |     |         }
 333 |     |     }
 334 |     | 
 335 |     |     // ============================================================================================
 336 |     |     // Errors
 337 |     |     // ============================================================================================
 338 |     | 
 339 |     |     error CircuitBreakerOnly();
 340 |     |     error WhitelistedDeployersOnly();
 341 |     |     error Create2Failed();
 342 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairRegistry.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ====================== FraxlendPairRegistry ========================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | // Rich Gee: https://github.com/zer0blockchain
  22 |     | 
  23 |     | // ====================================================================
  24 |     | 
  25 |     | import { IERC20Metadata } from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
  26 |     | import { Ownable2Step } from "@openzeppelin/contracts/access/Ownable2Step.sol";
  27 |     | 
  28 |     | contract FraxlendPairRegistry is Ownable2Step {
  29 |     |     /// @notice addresses of deployers allowed to add to the registry
  30 |     |     mapping(address => bool) public deployers;
  31 |     | 
  32 |     |     /// @notice List of the addresses of all deployed Pairs
  33 |     |     address[] public deployedPairsArray;
  34 |     | 
  35 |     |     /// @notice name => deployed address
  36 |     |     mapping(string => address) public deployedPairsByName;
  37 |     | 
  38 |     |     constructor(address _ownerAddress, address[] memory _initialDeployers) Ownable2Step() {
  39 |     |         for (uint256 i = 0; i < _initialDeployers.length; i++) {
  40 |     |             deployers[_initialDeployers[i]] = true;
  41 |     |         }
  42 |     |         _transferOwnership(_ownerAddress);
  43 |     |     }
  44 |     | 
  45 |     |     // ============================================================================================
  46 |     |     // Functions: View Functions
  47 |     |     // ============================================================================================
  48 |     | 
  49 |     |     /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray
  50 |     |     /// @return length of array
  51 |     |     function deployedPairsLength() external view returns (uint256) {
  52 |     |         return deployedPairsArray.length;
  53 |     |     }
  54 |     | 
  55 |     |     /// @notice The ```getAllPairAddresses``` function returns an array of all deployed pairs
  56 |     |     /// @return _deployedPairsArray The array of pairs deployed
  57 |     |     function getAllPairAddresses() external view returns (address[] memory _deployedPairsArray) {
  58 |     |         _deployedPairsArray = deployedPairsArray;
  59 |     |     }
  60 |     | 
  61 |     |     // ============================================================================================
  62 |     |     // Functions: Setters
  63 |     |     // ============================================================================================
  64 |     | 
  65 |     |     /// @notice The ```SetDeployer``` event is called when a deployer is added or removed from the whitelist
  66 |     |     /// @param deployer The address to be set
  67 |     |     /// @param _bool The value to set (allow or disallow)
  68 |     |     event SetDeployer(address deployer, bool _bool);
  69 |     | 
  70 |     |     /// @notice The ```setDeployers``` function sets the deployers whitelist
  71 |     |     /// @param _deployers The deployers to set
  72 |     |     /// @param _bool The boolean to set
  73 |     |     function setDeployers(address[] memory _deployers, bool _bool) external onlyOwner {
  74 |     |         for (uint256 i = 0; i < _deployers.length; i++) {
  75 |     |             deployers[_deployers[i]] = _bool;
  76 |     |             emit SetDeployer(_deployers[i], _bool);
  77 |     |         }
  78 |     |     }
  79 |     | 
  80 |     |     // ============================================================================================
  81 |     |     // Functions: External Methods
  82 |     |     // ============================================================================================
  83 |     | 
  84 |     |     /// @notice The ```AddPair``` event is emitted when a new pair is added to the registry
  85 |     |     /// @param pairAddress The address of the pair
  86 |     |     event AddPair(address pairAddress);
  87 |     | 
  88 |     |     /// @notice The ```addPair``` function adds a pair to the registry and ensures a unique name
  89 |     |     /// @param _pairAddress The address of the pair
  90 |     |     function addPair(address _pairAddress) external {
  91 |     |         // Ensure caller is on the whitelist
  92 |     |         if (!deployers[msg.sender]) revert AddressIsNotDeployer();
  93 |     | 
  94 |     |         // Add pair to the global list
  95 |     |         deployedPairsArray.push(_pairAddress);
  96 |     | 
  97 |     |         // Pull name, ensure uniqueness and add to the name mapping
  98 |     |         string memory _name = IERC20Metadata(_pairAddress).name();
  99 |     |         if (deployedPairsByName[_name] != address(0)) revert NameMustBeUnique();
 100 |     |         deployedPairsByName[_name] = _pairAddress;
 101 |     | 
 102 |     |         emit AddPair(_pairAddress);
 103 |     |     }
 104 |     | 
 105 |     |     // ============================================================================================
 106 |     |     // Errors
 107 |     |     // ============================================================================================
 108 |     | 
 109 |     |     error AddressIsNotDeployer();
 110 |     |     error NameMustBeUnique();
 111 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendWhitelist.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | // ====================================================================
  5 |     | // |     ______                   _______                             |
  6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
  7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
  8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
  9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
 10 |     | // |                                                                  |
 11 |     | // ====================================================================
 12 |     | // ======================= FraxlendWhitelist ==========================
 13 |     | // ====================================================================
 14 |     | // Frax Finance: https://github.com/FraxFinance
 15 |     | 
 16 |     | // Primary Author
 17 |     | // Drake Evans: https://github.com/DrakeEvans
 18 |     | 
 19 |     | // Reviewers
 20 |     | // Dennis: https://github.com/denett
 21 |     | // Sam Kazemian: https://github.com/samkazemian
 22 |     | // Travis Moore: https://github.com/FortisFortuna
 23 |     | // Jack Corddry: https://github.com/corddry
 24 |     | // Rich Gee: https://github.com/zer0blockchain
 25 |     | 
 26 |     | // ====================================================================
 27 |     | 
 28 |     | import { Ownable2Step } from "@openzeppelin/contracts/access/Ownable2Step.sol";
 29 |     | 
 30 |     | contract FraxlendWhitelist is Ownable2Step {
 31 |     |     /// @notice Fraxlend Deployer Whitelist mapping.
 32 |     |     mapping(address => bool) public fraxlendDeployerWhitelist;
 33 |     | 
 34 |     |     constructor() Ownable2Step() {}
 35 |     | 
 36 |     |     /// @notice The ```SetFraxlendDeployerWhitelist``` event fires whenever a status is set for a given address.
 37 |     |     /// @param _address address being set.
 38 |     |     /// @param _bool approval being set.
 39 |     |     event SetFraxlendDeployerWhitelist(address indexed _address, bool _bool);
 40 |     | 
 41 |     |     /// @notice The ```setFraxlendDeployerWhitelist``` function sets a given address to true/false for use as a custom deployer.
 42 |     |     /// @param _addresses addresses to set status for.
 43 |     |     /// @param _bool status of approval.
 44 |     |     function setFraxlendDeployerWhitelist(address[] calldata _addresses, bool _bool) external onlyOwner {
 45 |     |         for (uint256 i = 0; i < _addresses.length; i++) {
 46 |     |             fraxlendDeployerWhitelist[_addresses[i]] = _bool;
 47 |     |             emit SetFraxlendDeployerWhitelist(_addresses[i], _bool);
 48 |     |         }
 49 |     |     }
 50 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/Timelock2Step.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ========================== Timelock2Step ===========================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | 
  22 |     | // ====================================================================
  23 |     | 
  24 |     | /// @title Timelock2Step
  25 |     | /// @author Drake Evans (Frax Finance) https://github.com/drakeevans
  26 |     | /// @dev Inspired by the OpenZeppelin's Ownable2Step contract
  27 |     | /// @notice  An abstract contract which contains 2-step transfer and renounce logic for a timelock address
  28 |     | abstract contract Timelock2Step {
  29 |     |     /// @notice The pending timelock address
  30 |     |     address public pendingTimelockAddress;
  31 |     | 
  32 |     |     /// @notice The current timelock address
  33 |     |     address public timelockAddress;
  34 |     | 
  35 |     |     constructor() {
  36 |     |         timelockAddress = msg.sender;
  37 |     |     }
  38 |     | 
  39 |     |     /// @notice Emitted when timelock is transferred
  40 |     |     error OnlyTimelock();
  41 |     | 
  42 |     |     /// @notice Emitted when pending timelock is transferred
  43 |     |     error OnlyPendingTimelock();
  44 |     | 
  45 |     |     /// @notice The ```TimelockTransferStarted``` event is emitted when the timelock transfer is initiated
  46 |     |     /// @param previousTimelock The address of the previous timelock
  47 |     |     /// @param newTimelock The address of the new timelock
  48 |     |     event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);
  49 |     | 
  50 |     |     /// @notice The ```TimelockTransferred``` event is emitted when the timelock transfer is completed
  51 |     |     /// @param previousTimelock The address of the previous timelock
  52 |     |     /// @param newTimelock The address of the new timelock
  53 |     |     event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);
  54 |     | 
  55 |     |     /// @notice The ```_isSenderTimelock``` function checks if msg.sender is current timelock address
  56 |     |     /// @return Whether or not msg.sender is current timelock address
  57 |     |     function _isSenderTimelock() internal view returns (bool) {
  58 |     |         return msg.sender == timelockAddress;
  59 |     |     }
  60 |     | 
  61 |     |     /// @notice The ```_requireTimelock``` function reverts if msg.sender is not current timelock address
  62 |     |     function _requireTimelock() internal view {
  63 |     |         if (msg.sender != timelockAddress) revert OnlyTimelock();
  64 |     |     }
  65 |     | 
  66 |     |     /// @notice The ```_isSenderPendingTimelock``` function checks if msg.sender is pending timelock address
  67 |     |     /// @return Whether or not msg.sender is pending timelock address
  68 |     |     function _isSenderPendingTimelock() internal view returns (bool) {
  69 |     |         return msg.sender == pendingTimelockAddress;
  70 |     |     }
  71 |     | 
  72 |     |     /// @notice The ```_requirePendingTimelock``` function reverts if msg.sender is not pending timelock address
  73 |     |     function _requirePendingTimelock() internal view {
  74 |     |         if (msg.sender != pendingTimelockAddress) revert OnlyPendingTimelock();
  75 |     |     }
  76 |     | 
  77 |     |     /// @notice The ```_transferTimelock``` function initiates the timelock transfer
  78 |     |     /// @dev This function is to be implemented by a public function
  79 |     |     /// @param _newTimelock The address of the nominated (pending) timelock
  80 |     |     function _transferTimelock(address _newTimelock) internal {
  81 |     |         pendingTimelockAddress = _newTimelock;
  82 |     |         emit TimelockTransferStarted(timelockAddress, _newTimelock);
  83 |     |     }
  84 |     | 
  85 |     |     /// @notice The ```_acceptTransferTimelock``` function completes the timelock transfer
  86 |     |     /// @dev This function is to be implemented by a public function
  87 |     |     function _acceptTransferTimelock() internal {
  88 |     |         pendingTimelockAddress = address(0);
  89 |     |         _setTimelock(msg.sender);
  90 |     |     }
  91 |     | 
  92 |     |     /// @notice The ```_setTimelock``` function sets the timelock address
  93 |     |     /// @dev This function is to be implemented by a public function
  94 |     |     /// @param _newTimelock The address of the new timelock
  95 |     |     function _setTimelock(address _newTimelock) internal {
  96 |     |         emit TimelockTransferred(timelockAddress, _newTimelock);
  97 |     |         timelockAddress = _newTimelock;
  98 |     |     }
  99 |     | 
 100 |     |     /// @notice The ```transferTimelock``` function initiates the timelock transfer
 101 |     |     /// @dev Must be called by the current timelock
 102 |     |     /// @param _newTimelock The address of the nominated (pending) timelock
 103 |     |     function transferTimelock(address _newTimelock) external virtual {
 104 |     |         _requireTimelock();
 105 |     |         _transferTimelock(_newTimelock);
 106 |     |     }
 107 |     | 
 108 |     |     /// @notice The ```acceptTransferTimelock``` function completes the timelock transfer
 109 |     |     /// @dev Must be called by the pending timelock
 110 |     |     function acceptTransferTimelock() external virtual {
 111 |     |         _requirePendingTimelock();
 112 |     |         _acceptTransferTimelock();
 113 |     |     }
 114 |     | 
 115 |     |     /// @notice The ```renounceTimelock``` function renounces the timelock after setting pending timelock to current timelock
 116 |     |     /// @dev Pending timelock must be set to current timelock before renouncing, creating a 2-step renounce process
 117 |     |     function renounceTimelock() external virtual {
 118 |     |         _requireTimelock();
 119 |     |         _requirePendingTimelock();
 120 |     |         _transferTimelock(address(0));
 121 |     |         _setTimelock(address(0));
 122 |     |     }
 123 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/VariableInterestRate.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity ^0.8.19;
   3 |     | 
   4 |     | // ====================================================================
   5 |     | // |     ______                   _______                             |
   6 |     | // |    / _____________ __  __   / ____(_____  ____ _____  ________   |
   7 |     | // |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |
   8 |     | // |  / __/ / /  / /_/ _>  <   / __/ / / / / / /_/ / / / / /__/  __/  |
   9 |     | // | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |
  10 |     | // |                                                                  |
  11 |     | // ====================================================================
  12 |     | // ====================== VariableInterestRate ========================
  13 |     | // ====================================================================
  14 |     | // Frax Finance: https://github.com/FraxFinance
  15 |     | 
  16 |     | // Primary Author
  17 |     | // Drake Evans: https://github.com/DrakeEvans
  18 |     | 
  19 |     | // Reviewers
  20 |     | // Dennis: https://github.com/denett
  21 |     | 
  22 |     | // ====================================================================
  23 |     | 
  24 |     | import { Strings } from "@openzeppelin/contracts/utils/Strings.sol";
  25 |     | import { IRateCalculatorV2 } from "./interfaces/IRateCalculatorV2.sol";
  26 |     | 
  27 |     | /// @title A formula for calculating interest rates as a function of utilization and time
  28 |     | /// @author Drake Evans github.com/drakeevans
  29 |     | /// @notice A Contract for calculating interest rates as a function of utilization and time
  30 |     | contract VariableInterestRate is IRateCalculatorV2 {
  31 |     |     using Strings for uint256;
  32 |     | 
  33 |     |     /// @notice The name suffix for the interest rate calculator
  34 |     |     string public suffix;
  35 |     | 
  36 |     |     // Utilization Settings
  37 |     |     /// @notice The minimum utilization wherein no adjustment to full utilization and vertex rates occurs
  38 |     |     uint256 public immutable MIN_TARGET_UTIL;
  39 |     |     /// @notice The maximum utilization wherein no adjustment to full utilization and vertex rates occurs
  40 |     |     uint256 public immutable MAX_TARGET_UTIL;
  41 |     |     /// @notice The utilization at which the slope increases
  42 |     |     uint256 public immutable VERTEX_UTILIZATION;
  43 |     |     /// @notice precision of utilization calculations
  44 |     |     uint256 public constant UTIL_PREC = 1e5; // 5 decimals
  45 |     | 
  46 |     |     // Interest Rate Settings (all rates are per second), 365.24 days per year
  47 |     |     /// @notice The minimum interest rate (per second) when utilization is 100%
  48 |     |     uint256 public immutable MIN_FULL_UTIL_RATE; // 18 decimals
  49 |     |     /// @notice The maximum interest rate (per second) when utilization is 100%
  50 |     |     uint256 public immutable MAX_FULL_UTIL_RATE; // 18 decimals
  51 |     |     /// @notice The interest rate (per second) when utilization is 0%
  52 |     |     uint256 public immutable ZERO_UTIL_RATE; // 18 decimals
  53 |     |     /// @notice The interest rate half life in seconds, determines rate of adjustments to rate curve
  54 |     |     uint256 public immutable RATE_HALF_LIFE; // 1 decimals
  55 |     |     /// @notice The percent of the delta between max and min
  56 |     |     uint256 public immutable VERTEX_RATE_PERCENT; // 18 decimals
  57 |     |     /// @notice The precision of interest rate calculations
  58 |     |     uint256 public constant RATE_PREC = 1e18; // 18 decimals
  59 |     | 
  60 |     |     /// @notice The ```constructor``` function
  61 |     |     /// @param _suffix The suffix of the contract name
  62 |     |     /// @param _vertexUtilization The utilization at which the slope increases
  63 |     |     /// @param _vertexRatePercentOfDelta The percent of the delta between max and min, defines vertex rate
  64 |     |     /// @param _minUtil The minimum utilization wherein no adjustment to full utilization and vertex rates occurs
  65 |     |     /// @param _maxUtil The maximum utilization wherein no adjustment to full utilization and vertex rates occurs
  66 |     |     /// @param _zeroUtilizationRate The interest rate (per second) when utilization is 0%
  67 |     |     /// @param _minFullUtilizationRate The minimum interest rate at 100% utilization
  68 |     |     /// @param _maxFullUtilizationRate The maximum interest rate at 100% utilization
  69 |     |     /// @param _rateHalfLife The half life parameter for interest rate adjustments
  70 |     |     constructor(
  71 |     |         string memory _suffix,
  72 |     |         uint256 _vertexUtilization,
  73 |     |         uint256 _vertexRatePercentOfDelta,
  74 |     |         uint256 _minUtil,
  75 |     |         uint256 _maxUtil,
  76 |     |         uint256 _zeroUtilizationRate,
  77 |     |         uint256 _minFullUtilizationRate,
  78 |     |         uint256 _maxFullUtilizationRate,
  79 |     |         uint256 _rateHalfLife
  80 |     |     ) {
  81 |     |         suffix = _suffix;
  82 |     |         MIN_TARGET_UTIL = _minUtil;
  83 |     |         MAX_TARGET_UTIL = _maxUtil;
  84 |     |         VERTEX_UTILIZATION = _vertexUtilization;
  85 |     |         ZERO_UTIL_RATE = _zeroUtilizationRate;
  86 |     |         MIN_FULL_UTIL_RATE = _minFullUtilizationRate;
  87 |     |         MAX_FULL_UTIL_RATE = _maxFullUtilizationRate;
  88 |     |         RATE_HALF_LIFE = _rateHalfLife;
  89 |     |         VERTEX_RATE_PERCENT = _vertexRatePercentOfDelta;
  90 |     |     }
  91 |     | 
  92 |     |     /// @notice The ```name``` function returns the name of the rate contract
  93 |     |     /// @return memory name of contract
  94 |     |     function name() external view returns (string memory) {
  95 |     |         return string(abi.encodePacked("Variable Rate V2 ", suffix));
  96 |     |     }
  97 |     | 
  98 |     |     /// @notice The ```version``` function returns the semantic version of the rate contract
  99 |     |     /// @dev Follows semantic versioning
 100 |     |     /// @return _major Major version
 101 |     |     /// @return _minor Minor version
 102 |     |     /// @return _patch Patch version
 103 |     |     function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {
 104 |     |         _major = 2;
 105 |     |         _minor = 0;
 106 |     |         _patch = 0;
 107 |     |     }
 108 |     | 
 109 |     |     /// @notice The ```getFullUtilizationInterest``` function calculate the new maximum interest rate, i.e. rate when utilization is 100%
 110 |     |     /// @dev Given in interest per second
 111 |     |     /// @param _deltaTime The elapsed time since last update given in seconds
 112 |     |     /// @param _utilization The utilization %, given with 5 decimals of precision
 113 |     |     /// @param _fullUtilizationInterest The interest value when utilization is 100%, given with 18 decimals of precision
 114 |     |     /// @return _newFullUtilizationInterest The new maximum interest rate
 115 |     |     function getFullUtilizationInterest(
 116 |     |         uint256 _deltaTime,
 117 |     |         uint256 _utilization,
 118 |     |         uint64 _fullUtilizationInterest
 119 |     |     ) internal view returns (uint64 _newFullUtilizationInterest) {
 120 |     |         if (_utilization < MIN_TARGET_UTIL) {
 121 |     |             // 18 decimals
 122 |     |             uint256 _deltaUtilization = ((MIN_TARGET_UTIL - _utilization) * 1e18) / MIN_TARGET_UTIL;
 123 |     |             // 36 decimals
 124 |     |             uint256 _decayGrowth = (RATE_HALF_LIFE * 1e36) + (_deltaUtilization * _deltaUtilization * _deltaTime);
 125 |     |             // 18 decimals
 126 |     |             _newFullUtilizationInterest = uint64((_fullUtilizationInterest * (RATE_HALF_LIFE * 1e36)) / _decayGrowth);
 127 |     |         } else if (_utilization > MAX_TARGET_UTIL) {
 128 |     |             // 18 decimals
 129 |     |             uint256 _deltaUtilization = ((_utilization - MAX_TARGET_UTIL) * 1e18) / (UTIL_PREC - MAX_TARGET_UTIL);
 130 |     |             // 36 decimals
 131 |     |             uint256 _decayGrowth = (RATE_HALF_LIFE * 1e36) + (_deltaUtilization * _deltaUtilization * _deltaTime);
 132 |     |             // 18 decimals
 133 |     |             _newFullUtilizationInterest = uint64((_fullUtilizationInterest * _decayGrowth) / (RATE_HALF_LIFE * 1e36));
 134 |     |         } else {
 135 |     |             _newFullUtilizationInterest = _fullUtilizationInterest;
 136 |     |         }
 137 |     |         if (_newFullUtilizationInterest > MAX_FULL_UTIL_RATE) {
 138 |     |             _newFullUtilizationInterest = uint64(MAX_FULL_UTIL_RATE);
 139 |     |         } else if (_newFullUtilizationInterest < MIN_FULL_UTIL_RATE) {
 140 |     |             _newFullUtilizationInterest = uint64(MIN_FULL_UTIL_RATE);
 141 |     |         }
 142 |     |     }
 143 |     | 
 144 |     |     /// @notice The ```getNewRate``` function calculates interest rates using two linear functions f(utilization)
 145 |     |     /// @param _deltaTime The elapsed time since last update, given in seconds
 146 |     |     /// @param _utilization The utilization %, given with 5 decimals of precision
 147 |     |     /// @param _oldFullUtilizationInterest The interest value when utilization is 100%, given with 18 decimals of precision
 148 |     |     /// @return _newRatePerSec The new interest rate, 18 decimals of precision
 149 |     |     /// @return _newFullUtilizationInterest The new max interest rate, 18 decimals of precision
 150 |     |     function getNewRate(
 151 |     |         uint256 _deltaTime,
 152 |     |         uint256 _utilization,
 153 |     |         uint64 _oldFullUtilizationInterest
 154 |     |     ) external view returns (uint64 _newRatePerSec, uint64 _newFullUtilizationInterest) {
 155 |     |         _newFullUtilizationInterest = getFullUtilizationInterest(_deltaTime, _utilization, _oldFullUtilizationInterest);
 156 |     | 
 157 |     |         // _vertexInterest is calculated as the percentage of the delta between min and max interest
 158 |     |         uint256 _vertexInterest = (((_newFullUtilizationInterest - ZERO_UTIL_RATE) * VERTEX_RATE_PERCENT) / RATE_PREC) +
 159 |     |             ZERO_UTIL_RATE;
 160 |     |         if (_utilization < VERTEX_UTILIZATION) {
 161 |     |             // For readability, the following formula is equivalent to:
 162 |     |             // uint256 _slope = ((_vertexInterest - ZERO_UTIL_RATE) * UTIL_PREC) / VERTEX_UTILIZATION;
 163 |     |             // _newRatePerSec = uint64(ZERO_UTIL_RATE + ((_utilization * _slope) / UTIL_PREC));
 164 |     | 
 165 |     |             // 18 decimals
 166 |     |             _newRatePerSec = uint64(
 167 |     |                 ZERO_UTIL_RATE + (_utilization * (_vertexInterest - ZERO_UTIL_RATE)) / VERTEX_UTILIZATION
 168 |     |             );
 169 |     |         } else {
 170 |     |             // For readability, the following formula is equivalent to:
 171 |     |             // uint256 _slope = (((_newFullUtilizationInterest - _vertexInterest) * UTIL_PREC) / (UTIL_PREC - VERTEX_UTILIZATION));
 172 |     |             // _newRatePerSec = uint64(_vertexInterest + (((_utilization - VERTEX_UTILIZATION) * _slope) / UTIL_PREC));
 173 |     | 
 174 |     |             // 18 decimals
 175 |     |             _newRatePerSec = uint64(
 176 |     |                 _vertexInterest +
 177 |     |                     ((_utilization - VERTEX_UTILIZATION) * (_newFullUtilizationInterest - _vertexInterest)) /
 178 |     |                     (UTIL_PREC - VERTEX_UTILIZATION)
 179 |     |             );
 180 |     |         }
 181 |     |     }
 182 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IDualOracle.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import { IERC165 } from "@openzeppelin/contracts/utils/introspection/IERC165.sol";
  5 |     | 
  6 |     | interface IDualOracle is IERC165 {
  7 |     |     function ORACLE_PRECISION() external view returns (uint256);
  8 |     | 
  9 |     |     function BASE_TOKEN_0() external view returns (address);
 10 |     | 
 11 |     |     function BASE_TOKEN_0_DECIMALS() external view returns (uint256);
 12 |     | 
 13 |     |     function BASE_TOKEN_1() external view returns (address);
 14 |     | 
 15 |     |     function BASE_TOKEN_1_DECIMALS() external view returns (uint256);
 16 |     | 
 17 |     |     function decimals() external view returns (uint8);
 18 |     | 
 19 |     |     function getPricesNormalized() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);
 20 |     | 
 21 |     |     function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);
 22 |     | 
 23 |     |     function name() external view returns (string memory);
 24 |     | 
 25 |     |     function NORMALIZATION_0() external view returns (int256);
 26 |     | 
 27 |     |     function NORMALIZATION_1() external view returns (int256);
 28 |     | 
 29 |     |     function QUOTE_TOKEN_0() external view returns (address);
 30 |     | 
 31 |     |     function QUOTE_TOKEN_0_DECIMALS() external view returns (uint256);
 32 |     | 
 33 |     |     function QUOTE_TOKEN_1() external view returns (address);
 34 |     | 
 35 |     |     function QUOTE_TOKEN_1_DECIMALS() external view returns (uint256);
 36 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IERC4626Extended.sol
  1 |     | // SPDX-License-Identifier: UNLICENSED
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";
  5 |     | 
  6 |     | interface IERC4626Extended is IERC4626 {
  7 |     |     function vaultUtilization(address vault) external view returns (uint256);
  8 |     | 
  9 |     |     function totalAssetsUtilized() external view returns (uint256);
 10 |     | 
 11 |     |     function totalAvailableAssets() external view returns (uint256);
 12 |     | 
 13 |     |     function whitelistUpdate() external;
 14 |     | 
 15 |     |     function whitelistWithdraw(uint256 amount) external;
 16 |     | 
 17 |     |     function whitelistDeposit(uint256 amount) external;
 18 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendPair.sol
   1 |     | // SPDX-License-Identifier: ISC
   2 |     | pragma solidity >=0.8.19;
   3 |     | 
   4 |     | interface IFraxlendPair {
   5 |     |     function CIRCUIT_BREAKER_ADDRESS() external view returns (address);
   6 |     | 
   7 |     |     function COMPTROLLER_ADDRESS() external view returns (address);
   8 |     | 
   9 |     |     function DEPLOYER_ADDRESS() external view returns (address);
  10 |     | 
  11 |     |     function FRAXLEND_WHITELIST_ADDRESS() external view returns (address);
  12 |     | 
  13 |     |     function timelockAddress() external view returns (address);
  14 |     | 
  15 |     |     function addCollateral(uint256 _collateralAmount, address _borrower) external;
  16 |     | 
  17 |     |     function addInterest()
  18 |     |         external
  19 |     |         returns (uint256 _interestEarned, uint256 _feesAmount, uint256 _feesShare, uint64 _newRate);
  20 |     | 
  21 |     |     function allowance(address owner, address spender) external view returns (uint256);
  22 |     | 
  23 |     |     function approve(address spender, uint256 amount) external returns (bool);
  24 |     | 
  25 |     |     function approvedBorrowers(address) external view returns (bool);
  26 |     | 
  27 |     |     function approvedLenders(address) external view returns (bool);
  28 |     | 
  29 |     |     function asset() external view returns (address);
  30 |     | 
  31 |     |     function balanceOf(address account) external view returns (uint256);
  32 |     | 
  33 |     |     function borrowAsset(
  34 |     |         uint256 _borrowAmount,
  35 |     |         uint256 _collateralAmount,
  36 |     |         address _receiver
  37 |     |     ) external returns (uint256 _shares);
  38 |     | 
  39 |     |     function borrowerWhitelistActive() external view returns (bool);
  40 |     | 
  41 |     |     function changeFee(uint32 _newFee) external;
  42 |     | 
  43 |     |     function cleanLiquidationFee() external view returns (uint256);
  44 |     | 
  45 |     |     function collateralContract() external view returns (address);
  46 |     | 
  47 |     |     function currentRateInfo()
  48 |     |         external
  49 |     |         view
  50 |     |         returns (
  51 |     |             uint32 lastBlock,
  52 |     |             uint32 feeToProtocolRate,
  53 |     |             uint64 lastTimestamp,
  54 |     |             uint64 ratePerSec,
  55 |     |             uint64 fullUtilizationRate
  56 |     |         );
  57 |     | 
  58 |     |     function decimals() external view returns (uint8);
  59 |     | 
  60 |     |     function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);
  61 |     | 
  62 |     |     function deposit(uint256 _amount, address _receiver) external returns (uint256 _sharesReceived);
  63 |     | 
  64 |     |     function dirtyLiquidationFee() external view returns (uint256);
  65 |     | 
  66 |     |     function exchangeRateInfo() external view returns (uint32 lastTimestamp, uint224 exchangeRate);
  67 |     | 
  68 |     |     function getConstants()
  69 |     |         external
  70 |     |         pure
  71 |     |         returns (
  72 |     |             uint256 _LTV_PRECISION,
  73 |     |             uint256 _LIQ_PRECISION,
  74 |     |             uint256 _UTIL_PREC,
  75 |     |             uint256 _FEE_PRECISION,
  76 |     |             uint256 _EXCHANGE_PRECISION,
  77 |     |             uint64 _DEFAULT_INT,
  78 |     |             uint16 _DEFAULT_PROTOCOL_FEE,
  79 |     |             uint256 _MAX_PROTOCOL_FEE
  80 |     |         );
  81 |     | 
  82 |     |     function getImmutableAddressBool()
  83 |     |         external
  84 |     |         view
  85 |     |         returns (
  86 |     |             address _assetContract,
  87 |     |             address _collateralContract,
  88 |     |             address _oracleMultiply,
  89 |     |             address _oracleDivide,
  90 |     |             address _rateContract,
  91 |     |             address _DEPLOYER_CONTRACT,
  92 |     |             address _COMPTROLLER_ADDRESS,
  93 |     |             address _FRAXLEND_WHITELIST,
  94 |     |             bool _borrowerWhitelistActive,
  95 |     |             bool _lenderWhitelistActive
  96 |     |         );
  97 |     | 
  98 |     |     function getImmutableUint256()
  99 |     |         external
 100 |     |         view
 101 |     |         returns (
 102 |     |             uint256 _oracleNormalization,
 103 |     |             uint256 _maxLTV,
 104 |     |             uint256 _cleanLiquidationFee,
 105 |     |             uint256 _maturityDate,
 106 |     |             uint256 _penaltyRate
 107 |     |         );
 108 |     | 
 109 |     |     function getPairAccounting()
 110 |     |         external
 111 |     |         view
 112 |     |         returns (
 113 |     |             uint128 _totalAssetAmount,
 114 |     |             uint128 _totalAssetShares,
 115 |     |             uint128 _totalBorrowAmount,
 116 |     |             uint128 _totalBorrowShares,
 117 |     |             uint256 _totalCollateral
 118 |     |         );
 119 |     | 
 120 |     |     function getUserSnapshot(
 121 |     |         address _address
 122 |     |     ) external view returns (uint256 _userAssetShares, uint256 _userBorrowShares, uint256 _userCollateralBalance);
 123 |     | 
 124 |     |     function increaseAllowance(address spender, uint256 addedValue) external returns (bool);
 125 |     | 
 126 |     |     function lenderWhitelistActive() external view returns (bool);
 127 |     | 
 128 |     |     function leveragedPosition(
 129 |     |         address _swapperAddress,
 130 |     |         uint256 _borrowAmount,
 131 |     |         uint256 _initialCollateralAmount,
 132 |     |         uint256 _amountCollateralOutMin,
 133 |     |         address[] memory _path
 134 |     |     ) external returns (uint256 _totalCollateralBalance);
 135 |     | 
 136 |     |     function liquidate(
 137 |     |         uint128 _sharesToLiquidate,
 138 |     |         uint256 _deadline,
 139 |     |         address _borrower
 140 |     |     ) external returns (uint256 _collateralForLiquidator);
 141 |     | 
 142 |     |     function maturityDate() external view returns (uint256);
 143 |     | 
 144 |     |     function maxLTV() external view returns (uint256);
 145 |     | 
 146 |     |     function maxOracleDelay() external view returns (uint256);
 147 |     | 
 148 |     |     function name() external view returns (string memory);
 149 |     | 
 150 |     |     function oracleDivide() external view returns (address);
 151 |     | 
 152 |     |     function oracleMultiply() external view returns (address);
 153 |     | 
 154 |     |     function oracleNormalization() external view returns (uint256);
 155 |     | 
 156 |     |     function owner() external view returns (address);
 157 |     | 
 158 |     |     function pause() external;
 159 |     | 
 160 |     |     function paused() external view returns (bool);
 161 |     | 
 162 |     |     function penaltyRate() external view returns (uint256);
 163 |     | 
 164 |     |     function rateContract() external view returns (address);
 165 |     | 
 166 |     |     function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 _amountToReturn);
 167 |     | 
 168 |     |     function removeCollateral(uint256 _collateralAmount, address _receiver) external;
 169 |     | 
 170 |     |     function renounceOwnership() external;
 171 |     | 
 172 |     |     function repayAsset(uint256 _shares, address _borrower) external returns (uint256 _amountToRepay);
 173 |     | 
 174 |     |     function repayAssetWithCollateral(
 175 |     |         address _swapperAddress,
 176 |     |         uint256 _collateralToSwap,
 177 |     |         uint256 _amountAssetOutMin,
 178 |     |         address[] memory _path
 179 |     |     ) external returns (uint256 _amountAssetOut);
 180 |     | 
 181 |     |     function setApprovedBorrowers(address[] memory _borrowers, bool _approval) external;
 182 |     | 
 183 |     |     function setApprovedLenders(address[] memory _lenders, bool _approval) external;
 184 |     | 
 185 |     |     function setMaxOracleDelay(uint256 _newDelay) external;
 186 |     | 
 187 |     |     function setSwapper(address _swapper, bool _approval) external;
 188 |     | 
 189 |     |     function setTimelock(address _newAddress) external;
 190 |     | 
 191 |     |     function swappers(address) external view returns (bool);
 192 |     | 
 193 |     |     function symbol() external view returns (string memory);
 194 |     | 
 195 |     |     function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256);
 196 |     | 
 197 |     |     function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256);
 198 |     | 
 199 |     |     function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256);
 200 |     | 
 201 |     |     function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256);
 202 |     | 
 203 |     |     function totalAsset() external view returns (uint128 amount, uint128 shares);
 204 |     | 
 205 |     |     function totalBorrow() external view returns (uint128 amount, uint128 shares);
 206 |     | 
 207 |     |     function totalCollateral() external view returns (uint256);
 208 |     | 
 209 |     |     function totalSupply() external view returns (uint256);
 210 |     | 
 211 |     |     function transfer(address to, uint256 amount) external returns (bool);
 212 |     | 
 213 |     |     function transferFrom(address from, address to, uint256 amount) external returns (bool);
 214 |     | 
 215 |     |     function transferOwnership(address newOwner) external;
 216 |     | 
 217 |     |     function unpause() external;
 218 |     | 
 219 |     |     function updateExchangeRate() external returns (uint256 _exchangeRate);
 220 |     | 
 221 |     |     function userBorrowShares(address) external view returns (uint256);
 222 |     | 
 223 |     |     function userCollateralBalance(address) external view returns (uint256);
 224 |     | 
 225 |     |     function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch);
 226 |     | 
 227 |     |     function withdrawFees(uint128 _shares, address _recipient) external returns (uint256 _amountToTransfer);
 228 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendPairRegistry.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IFraxlendPairRegistry {
  5 |     |     event AddPair(address pairAddress);
  6 |     |     event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
  7 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  8 |     |     event SetDeployer(address deployer, bool _bool);
  9 |     | 
 10 |     |     function acceptOwnership() external;
 11 |     | 
 12 |     |     function addPair(address _pairAddress) external;
 13 |     | 
 14 |     |     function deployedPairsArray(uint256) external view returns (address);
 15 |     | 
 16 |     |     function deployedPairsByName(string memory) external view returns (address);
 17 |     | 
 18 |     |     function deployedPairsLength() external view returns (uint256);
 19 |     | 
 20 |     |     function deployers(address) external view returns (bool);
 21 |     | 
 22 |     |     function getAllPairAddresses() external view returns (address[] memory _deployedPairsArray);
 23 |     | 
 24 |     |     function owner() external view returns (address);
 25 |     | 
 26 |     |     function pendingOwner() external view returns (address);
 27 |     | 
 28 |     |     function renounceOwnership() external;
 29 |     | 
 30 |     |     function setDeployers(address[] memory _deployers, bool _bool) external;
 31 |     | 
 32 |     |     function transferOwnership(address newOwner) external;
 33 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendWhitelist.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity >=0.8.19;
  3 |     | 
  4 |     | interface IFraxlendWhitelist {
  5 |     |     event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);
  6 |     |     event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);
  7 |     |     event SetFraxlendDeployerWhitelist(address indexed _address, bool _bool);
  8 |     | 
  9 |     |     function acceptOwnership() external;
 10 |     | 
 11 |     |     function fraxlendDeployerWhitelist(address) external view returns (bool);
 12 |     | 
 13 |     |     function owner() external view returns (address);
 14 |     | 
 15 |     |     function pendingOwner() external view returns (address);
 16 |     | 
 17 |     |     function renounceOwnership() external;
 18 |     | 
 19 |     |     function setFraxlendDeployerWhitelist(address[] memory _addresses, bool _bool) external;
 20 |     | 
 21 |     |     function transferOwnership(address newOwner) external;
 22 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IRateCalculatorV2.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | interface IRateCalculatorV2 {
  5 |     |     function name() external view returns (string memory);
  6 |     | 
  7 |     |     function version() external view returns (uint256, uint256, uint256);
  8 |     | 
  9 |     |     function getNewRate(
 10 |     |         uint256 _deltaTime,
 11 |     |         uint256 _utilization,
 12 |     |         uint64 _maxInterest
 13 |     |     ) external view returns (uint64 _newRatePerSec, uint64 _newMaxInterest);
 14 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/ISwapper.sol
  1 |     | // SPDX-License-Identifier: MIT
  2 |     | pragma solidity >=0.8.19;
  3 |     | 
  4 |     | interface ISwapper {
  5 |     |     function swapExactTokensForTokens(
  6 |     |         uint256 amountIn,
  7 |     |         uint256 amountOutMin,
  8 |     |         address[] calldata path,
  9 |     |         address to,
 10 |     |         uint256 deadline
 11 |     |     ) external returns (uint256[] memory amounts);
 12 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/BytesLib.sol
   1 |     | // SPDX-License-Identifier: Unlicense
   2 |     | /*
   3 |     |  * @title Solidity Bytes Arrays Utils
   4 |     |  * @author Gonalo S <goncalo.sa@consensys.net>
   5 |     |  *
   6 |     |  * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
   7 |     |  *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.
   8 |     |  */
   9 |     | pragma solidity >=0.8.0 <0.9.0;
  10 |     | 
  11 |     | 
  12 |     | library BytesLib {
  13 |     |     function concat(
  14 |     |         bytes memory _preBytes,
  15 |     |         bytes memory _postBytes
  16 |     |     )
  17 |     |         internal
  18 |     |         pure
  19 |     |         returns (bytes memory)
  20 |     |     {
  21 |     |         bytes memory tempBytes;
  22 |     | 
  23 |     |         assembly {
  24 |     |             // Get a location of some free memory and store it in tempBytes as
  25 |     |             // Solidity does for memory variables.
  26 |     |             tempBytes := mload(0x40)
  27 |     | 
  28 |     |             // Store the length of the first bytes array at the beginning of
  29 |     |             // the memory for tempBytes.
  30 |     |             let length := mload(_preBytes)
  31 |     |             mstore(tempBytes, length)
  32 |     | 
  33 |     |             // Maintain a memory counter for the current write location in the
  34 |     |             // temp bytes array by adding the 32 bytes for the array length to
  35 |     |             // the starting location.
  36 |     |             let mc := add(tempBytes, 0x20)
  37 |     |             // Stop copying when the memory counter reaches the length of the
  38 |     |             // first bytes array.
  39 |     |             let end := add(mc, length)
  40 |     | 
  41 |     |             for {
  42 |     |                 // Initialize a copy counter to the start of the _preBytes data,
  43 |     |                 // 32 bytes into its memory.
  44 |     |                 let cc := add(_preBytes, 0x20)
  45 |     |             } lt(mc, end) {
  46 |     |                 // Increase both counters by 32 bytes each iteration.
  47 |     |                 mc := add(mc, 0x20)
  48 |     |                 cc := add(cc, 0x20)
  49 |     |             } {
  50 |     |                 // Write the _preBytes data into the tempBytes memory 32 bytes
  51 |     |                 // at a time.
  52 |     |                 mstore(mc, mload(cc))
  53 |     |             }
  54 |     | 
  55 |     |             // Add the length of _postBytes to the current length of tempBytes
  56 |     |             // and store it as the new length in the first 32 bytes of the
  57 |     |             // tempBytes memory.
  58 |     |             length := mload(_postBytes)
  59 |     |             mstore(tempBytes, add(length, mload(tempBytes)))
  60 |     | 
  61 |     |             // Move the memory counter back from a multiple of 0x20 to the
  62 |     |             // actual end of the _preBytes data.
  63 |     |             mc := end
  64 |     |             // Stop copying when the memory counter reaches the new combined
  65 |     |             // length of the arrays.
  66 |     |             end := add(mc, length)
  67 |     | 
  68 |     |             for {
  69 |     |                 let cc := add(_postBytes, 0x20)
  70 |     |             } lt(mc, end) {
  71 |     |                 mc := add(mc, 0x20)
  72 |     |                 cc := add(cc, 0x20)
  73 |     |             } {
  74 |     |                 mstore(mc, mload(cc))
  75 |     |             }
  76 |     | 
  77 |     |             // Update the free-memory pointer by padding our last write location
  78 |     |             // to 32 bytes: add 31 bytes to the end of tempBytes to move to the
  79 |     |             // next 32 byte block, then round down to the nearest multiple of
  80 |     |             // 32. If the sum of the length of the two arrays is zero then add
  81 |     |             // one before rounding down to leave a blank 32 bytes (the length block with 0).
  82 |     |             mstore(0x40, and(
  83 |     |               add(add(end, iszero(add(length, mload(_preBytes)))), 31),
  84 |     |               not(31) // Round down to the nearest 32 bytes.
  85 |     |             ))
  86 |     |         }
  87 |     | 
  88 |     |         return tempBytes;
  89 |     |     }
  90 |     | 
  91 |     |     function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {
  92 |     |         assembly {
  93 |     |             // Read the first 32 bytes of _preBytes storage, which is the length
  94 |     |             // of the array. (We don't need to use the offset into the slot
  95 |     |             // because arrays use the entire slot.)
  96 |     |             let fslot := sload(_preBytes.slot)
  97 |     |             // Arrays of 31 bytes or less have an even value in their slot,
  98 |     |             // while longer arrays have an odd value. The actual length is
  99 |     |             // the slot divided by two for odd values, and the lowest order
 100 |     |             // byte divided by two for even values.
 101 |     |             // If the slot is even, bitwise and the slot with 255 and divide by
 102 |     |             // two to get the length. If the slot is odd, bitwise and the slot
 103 |     |             // with -1 and divide by two.
 104 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 105 |     |             let mlength := mload(_postBytes)
 106 |     |             let newlength := add(slength, mlength)
 107 |     |             // slength can contain both the length and contents of the array
 108 |     |             // if length < 32 bytes so let's prepare for that
 109 |     |             // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 110 |     |             switch add(lt(slength, 32), lt(newlength, 32))
 111 |     |             case 2 {
 112 |     |                 // Since the new array still fits in the slot, we just need to
 113 |     |                 // update the contents of the slot.
 114 |     |                 // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length
 115 |     |                 sstore(
 116 |     |                     _preBytes.slot,
 117 |     |                     // all the modifications to the slot are inside this
 118 |     |                     // next block
 119 |     |                     add(
 120 |     |                         // we can just add to the slot contents because the
 121 |     |                         // bytes we want to change are the LSBs
 122 |     |                         fslot,
 123 |     |                         add(
 124 |     |                             mul(
 125 |     |                                 div(
 126 |     |                                     // load the bytes from memory
 127 |     |                                     mload(add(_postBytes, 0x20)),
 128 |     |                                     // zero all bytes to the right
 129 |     |                                     exp(0x100, sub(32, mlength))
 130 |     |                                 ),
 131 |     |                                 // and now shift left the number of bytes to
 132 |     |                                 // leave space for the length in the slot
 133 |     |                                 exp(0x100, sub(32, newlength))
 134 |     |                             ),
 135 |     |                             // increase length by the double of the memory
 136 |     |                             // bytes length
 137 |     |                             mul(mlength, 2)
 138 |     |                         )
 139 |     |                     )
 140 |     |                 )
 141 |     |             }
 142 |     |             case 1 {
 143 |     |                 // The stored value fits in the slot, but the combined value
 144 |     |                 // will exceed it.
 145 |     |                 // get the keccak hash to get the contents of the array
 146 |     |                 mstore(0x0, _preBytes.slot)
 147 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 148 |     | 
 149 |     |                 // save new length
 150 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 151 |     | 
 152 |     |                 // The contents of the _postBytes array start 32 bytes into
 153 |     |                 // the structure. Our first read should obtain the `submod`
 154 |     |                 // bytes that can fit into the unused space in the last word
 155 |     |                 // of the stored array. To get this, we read 32 bytes starting
 156 |     |                 // from `submod`, so the data we read overlaps with the array
 157 |     |                 // contents by `submod` bytes. Masking the lowest-order
 158 |     |                 // `submod` bytes allows us to add that value directly to the
 159 |     |                 // stored value.
 160 |     | 
 161 |     |                 let submod := sub(32, slength)
 162 |     |                 let mc := add(_postBytes, submod)
 163 |     |                 let end := add(_postBytes, mlength)
 164 |     |                 let mask := sub(exp(0x100, submod), 1)
 165 |     | 
 166 |     |                 sstore(
 167 |     |                     sc,
 168 |     |                     add(
 169 |     |                         and(
 170 |     |                             fslot,
 171 |     |                             0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00
 172 |     |                         ),
 173 |     |                         and(mload(mc), mask)
 174 |     |                     )
 175 |     |                 )
 176 |     | 
 177 |     |                 for {
 178 |     |                     mc := add(mc, 0x20)
 179 |     |                     sc := add(sc, 1)
 180 |     |                 } lt(mc, end) {
 181 |     |                     sc := add(sc, 1)
 182 |     |                     mc := add(mc, 0x20)
 183 |     |                 } {
 184 |     |                     sstore(sc, mload(mc))
 185 |     |                 }
 186 |     | 
 187 |     |                 mask := exp(0x100, sub(mc, end))
 188 |     | 
 189 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 190 |     |             }
 191 |     |             default {
 192 |     |                 // get the keccak hash to get the contents of the array
 193 |     |                 mstore(0x0, _preBytes.slot)
 194 |     |                 // Start copying to the last used word of the stored array.
 195 |     |                 let sc := add(keccak256(0x0, 0x20), div(slength, 32))
 196 |     | 
 197 |     |                 // save new length
 198 |     |                 sstore(_preBytes.slot, add(mul(newlength, 2), 1))
 199 |     | 
 200 |     |                 // Copy over the first `submod` bytes of the new data as in
 201 |     |                 // case 1 above.
 202 |     |                 let slengthmod := mod(slength, 32)
 203 |     |                 let mlengthmod := mod(mlength, 32)
 204 |     |                 let submod := sub(32, slengthmod)
 205 |     |                 let mc := add(_postBytes, submod)
 206 |     |                 let end := add(_postBytes, mlength)
 207 |     |                 let mask := sub(exp(0x100, submod), 1)
 208 |     | 
 209 |     |                 sstore(sc, add(sload(sc), and(mload(mc), mask)))
 210 |     | 
 211 |     |                 for {
 212 |     |                     sc := add(sc, 1)
 213 |     |                     mc := add(mc, 0x20)
 214 |     |                 } lt(mc, end) {
 215 |     |                     sc := add(sc, 1)
 216 |     |                     mc := add(mc, 0x20)
 217 |     |                 } {
 218 |     |                     sstore(sc, mload(mc))
 219 |     |                 }
 220 |     | 
 221 |     |                 mask := exp(0x100, sub(mc, end))
 222 |     | 
 223 |     |                 sstore(sc, mul(div(mload(mc), mask), mask))
 224 |     |             }
 225 |     |         }
 226 |     |     }
 227 |     | 
 228 |     |     function slice(
 229 |     |         bytes memory _bytes,
 230 |     |         uint256 _start,
 231 |     |         uint256 _length
 232 |     |     )
 233 |     |         internal
 234 |     |         pure
 235 |     |         returns (bytes memory)
 236 |     |     {
 237 |     |         require(_length + 31 >= _length, "slice_overflow");
 238 |     |         require(_bytes.length >= _start + _length, "slice_outOfBounds");
 239 |     | 
 240 |     |         bytes memory tempBytes;
 241 |     | 
 242 |     |         assembly {
 243 |     |             switch iszero(_length)
 244 |     |             case 0 {
 245 |     |                 // Get a location of some free memory and store it in tempBytes as
 246 |     |                 // Solidity does for memory variables.
 247 |     |                 tempBytes := mload(0x40)
 248 |     | 
 249 |     |                 // The first word of the slice result is potentially a partial
 250 |     |                 // word read from the original array. To read it, we calculate
 251 |     |                 // the length of that partial word and start copying that many
 252 |     |                 // bytes into the array. The first word we copy will start with
 253 |     |                 // data we don't care about, but the last `lengthmod` bytes will
 254 |     |                 // land at the beginning of the contents of the new array. When
 255 |     |                 // we're done copying, we overwrite the full first word with
 256 |     |                 // the actual length of the slice.
 257 |     |                 let lengthmod := and(_length, 31)
 258 |     | 
 259 |     |                 // The multiplication in the next line is necessary
 260 |     |                 // because when slicing multiples of 32 bytes (lengthmod == 0)
 261 |     |                 // the following copy loop was copying the origin's length
 262 |     |                 // and then ending prematurely not copying everything it should.
 263 |     |                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
 264 |     |                 let end := add(mc, _length)
 265 |     | 
 266 |     |                 for {
 267 |     |                     // The multiplication in the next line has the same exact purpose
 268 |     |                     // as the one above.
 269 |     |                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
 270 |     |                 } lt(mc, end) {
 271 |     |                     mc := add(mc, 0x20)
 272 |     |                     cc := add(cc, 0x20)
 273 |     |                 } {
 274 |     |                     mstore(mc, mload(cc))
 275 |     |                 }
 276 |     | 
 277 |     |                 mstore(tempBytes, _length)
 278 |     | 
 279 |     |                 //update free-memory pointer
 280 |     |                 //allocating the array padded to 32 bytes like the compiler does now
 281 |     |                 mstore(0x40, and(add(mc, 31), not(31)))
 282 |     |             }
 283 |     |             //if we want a zero-length slice let's just return a zero-length array
 284 |     |             default {
 285 |     |                 tempBytes := mload(0x40)
 286 |     |                 //zero out the 32 bytes slice we are about to return
 287 |     |                 //we need to do it because Solidity does not garbage collect
 288 |     |                 mstore(tempBytes, 0)
 289 |     | 
 290 |     |                 mstore(0x40, add(tempBytes, 0x20))
 291 |     |             }
 292 |     |         }
 293 |     | 
 294 |     |         return tempBytes;
 295 |     |     }
 296 |     | 
 297 |     |     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
 298 |     |         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
 299 |     |         address tempAddress;
 300 |     | 
 301 |     |         assembly {
 302 |     |             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
 303 |     |         }
 304 |     | 
 305 |     |         return tempAddress;
 306 |     |     }
 307 |     | 
 308 |     |     function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {
 309 |     |         require(_bytes.length >= _start + 1 , "toUint8_outOfBounds");
 310 |     |         uint8 tempUint;
 311 |     | 
 312 |     |         assembly {
 313 |     |             tempUint := mload(add(add(_bytes, 0x1), _start))
 314 |     |         }
 315 |     | 
 316 |     |         return tempUint;
 317 |     |     }
 318 |     | 
 319 |     |     function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {
 320 |     |         require(_bytes.length >= _start + 2, "toUint16_outOfBounds");
 321 |     |         uint16 tempUint;
 322 |     | 
 323 |     |         assembly {
 324 |     |             tempUint := mload(add(add(_bytes, 0x2), _start))
 325 |     |         }
 326 |     | 
 327 |     |         return tempUint;
 328 |     |     }
 329 |     | 
 330 |     |     function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {
 331 |     |         require(_bytes.length >= _start + 4, "toUint32_outOfBounds");
 332 |     |         uint32 tempUint;
 333 |     | 
 334 |     |         assembly {
 335 |     |             tempUint := mload(add(add(_bytes, 0x4), _start))
 336 |     |         }
 337 |     | 
 338 |     |         return tempUint;
 339 |     |     }
 340 |     | 
 341 |     |     function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {
 342 |     |         require(_bytes.length >= _start + 8, "toUint64_outOfBounds");
 343 |     |         uint64 tempUint;
 344 |     | 
 345 |     |         assembly {
 346 |     |             tempUint := mload(add(add(_bytes, 0x8), _start))
 347 |     |         }
 348 |     | 
 349 |     |         return tempUint;
 350 |     |     }
 351 |     | 
 352 |     |     function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {
 353 |     |         require(_bytes.length >= _start + 12, "toUint96_outOfBounds");
 354 |     |         uint96 tempUint;
 355 |     | 
 356 |     |         assembly {
 357 |     |             tempUint := mload(add(add(_bytes, 0xc), _start))
 358 |     |         }
 359 |     | 
 360 |     |         return tempUint;
 361 |     |     }
 362 |     | 
 363 |     |     function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {
 364 |     |         require(_bytes.length >= _start + 16, "toUint128_outOfBounds");
 365 |     |         uint128 tempUint;
 366 |     | 
 367 |     |         assembly {
 368 |     |             tempUint := mload(add(add(_bytes, 0x10), _start))
 369 |     |         }
 370 |     | 
 371 |     |         return tempUint;
 372 |     |     }
 373 |     | 
 374 |     |     function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {
 375 |     |         require(_bytes.length >= _start + 32, "toUint256_outOfBounds");
 376 |     |         uint256 tempUint;
 377 |     | 
 378 |     |         assembly {
 379 |     |             tempUint := mload(add(add(_bytes, 0x20), _start))
 380 |     |         }
 381 |     | 
 382 |     |         return tempUint;
 383 |     |     }
 384 |     | 
 385 |     |     function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {
 386 |     |         require(_bytes.length >= _start + 32, "toBytes32_outOfBounds");
 387 |     |         bytes32 tempBytes32;
 388 |     | 
 389 |     |         assembly {
 390 |     |             tempBytes32 := mload(add(add(_bytes, 0x20), _start))
 391 |     |         }
 392 |     | 
 393 |     |         return tempBytes32;
 394 |     |     }
 395 |     | 
 396 |     |     function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
 397 |     |         bool success = true;
 398 |     | 
 399 |     |         assembly {
 400 |     |             let length := mload(_preBytes)
 401 |     | 
 402 |     |             // if lengths don't match the arrays are not equal
 403 |     |             switch eq(length, mload(_postBytes))
 404 |     |             case 1 {
 405 |     |                 // cb is a circuit breaker in the for loop since there's
 406 |     |                 //  no said feature for inline assembly loops
 407 |     |                 // cb = 1 - don't breaker
 408 |     |                 // cb = 0 - break
 409 |     |                 let cb := 1
 410 |     | 
 411 |     |                 let mc := add(_preBytes, 0x20)
 412 |     |                 let end := add(mc, length)
 413 |     | 
 414 |     |                 for {
 415 |     |                     let cc := add(_postBytes, 0x20)
 416 |     |                 // the next line is the loop condition:
 417 |     |                 // while(uint256(mc < end) + cb == 2)
 418 |     |                 } eq(add(lt(mc, end), cb), 2) {
 419 |     |                     mc := add(mc, 0x20)
 420 |     |                     cc := add(cc, 0x20)
 421 |     |                 } {
 422 |     |                     // if any of these checks fails then arrays are not equal
 423 |     |                     if iszero(eq(mload(mc), mload(cc))) {
 424 |     |                         // unsuccess:
 425 |     |                         success := 0
 426 |     |                         cb := 0
 427 |     |                     }
 428 |     |                 }
 429 |     |             }
 430 |     |             default {
 431 |     |                 // unsuccess:
 432 |     |                 success := 0
 433 |     |             }
 434 |     |         }
 435 |     | 
 436 |     |         return success;
 437 |     |     }
 438 |     | 
 439 |     |     function equal_nonAligned(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {
 440 |     |         bool success = true;
 441 |     | 
 442 |     |         assembly {
 443 |     |             let length := mload(_preBytes)
 444 |     | 
 445 |     |             // if lengths don't match the arrays are not equal
 446 |     |             switch eq(length, mload(_postBytes))
 447 |     |             case 1 {
 448 |     |                 // cb is a circuit breaker in the for loop since there's
 449 |     |                 //  no said feature for inline assembly loops
 450 |     |                 // cb = 1 - don't breaker
 451 |     |                 // cb = 0 - break
 452 |     |                 let cb := 1
 453 |     | 
 454 |     |                 let endMinusWord := add(_preBytes, length)
 455 |     |                 let mc := add(_preBytes, 0x20)
 456 |     |                 let cc := add(_postBytes, 0x20)
 457 |     | 
 458 |     |                 for {
 459 |     |                 // the next line is the loop condition:
 460 |     |                 // while(uint256(mc < endWord) + cb == 2)
 461 |     |                 } eq(add(lt(mc, endMinusWord), cb), 2) {
 462 |     |                     mc := add(mc, 0x20)
 463 |     |                     cc := add(cc, 0x20)
 464 |     |                 } {
 465 |     |                     // if any of these checks fails then arrays are not equal
 466 |     |                     if iszero(eq(mload(mc), mload(cc))) {
 467 |     |                         // unsuccess:
 468 |     |                         success := 0
 469 |     |                         cb := 0
 470 |     |                     }
 471 |     |                 }
 472 |     | 
 473 |     |                 // Only if still successful
 474 |     |                 // For <1 word tail bytes
 475 |     |                 if gt(success, 0) {
 476 |     |                     // Get the remainder of length/32
 477 |     |                     // length % 32 = AND(length, 32 - 1)
 478 |     |                     let numTailBytes := and(length, 0x1f)
 479 |     |                     let mcRem := mload(mc)
 480 |     |                     let ccRem := mload(cc)
 481 |     |                     for {
 482 |     |                         let i := 0
 483 |     |                     // the next line is the loop condition:
 484 |     |                     // while(uint256(i < numTailBytes) + cb == 2)
 485 |     |                     } eq(add(lt(i, numTailBytes), cb), 2) {
 486 |     |                         i := add(i, 1)
 487 |     |                     } {
 488 |     |                         if iszero(eq(byte(i, mcRem), byte(i, ccRem))) {
 489 |     |                             // unsuccess:
 490 |     |                             success := 0
 491 |     |                             cb := 0
 492 |     |                         }
 493 |     |                     }
 494 |     |                 }
 495 |     |             }
 496 |     |             default {
 497 |     |                 // unsuccess:
 498 |     |                 success := 0
 499 |     |             }
 500 |     |         }
 501 |     | 
 502 |     |         return success;
 503 |     |     }
 504 |     | 
 505 |     |     function equalStorage(
 506 |     |         bytes storage _preBytes,
 507 |     |         bytes memory _postBytes
 508 |     |     )
 509 |     |         internal
 510 |     |         view
 511 |     |         returns (bool)
 512 |     |     {
 513 |     |         bool success = true;
 514 |     | 
 515 |     |         assembly {
 516 |     |             // we know _preBytes_offset is 0
 517 |     |             let fslot := sload(_preBytes.slot)
 518 |     |             // Decode the length of the stored array like in concatStorage().
 519 |     |             let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)
 520 |     |             let mlength := mload(_postBytes)
 521 |     | 
 522 |     |             // if lengths don't match the arrays are not equal
 523 |     |             switch eq(slength, mlength)
 524 |     |             case 1 {
 525 |     |                 // slength can contain both the length and contents of the array
 526 |     |                 // if length < 32 bytes so let's prepare for that
 527 |     |                 // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage
 528 |     |                 if iszero(iszero(slength)) {
 529 |     |                     switch lt(slength, 32)
 530 |     |                     case 1 {
 531 |     |                         // blank the last byte which is the length
 532 |     |                         fslot := mul(div(fslot, 0x100), 0x100)
 533 |     | 
 534 |     |                         if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {
 535 |     |                             // unsuccess:
 536 |     |                             success := 0
 537 |     |                         }
 538 |     |                     }
 539 |     |                     default {
 540 |     |                         // cb is a circuit breaker in the for loop since there's
 541 |     |                         //  no said feature for inline assembly loops
 542 |     |                         // cb = 1 - don't breaker
 543 |     |                         // cb = 0 - break
 544 |     |                         let cb := 1
 545 |     | 
 546 |     |                         // get the keccak hash to get the contents of the array
 547 |     |                         mstore(0x0, _preBytes.slot)
 548 |     |                         let sc := keccak256(0x0, 0x20)
 549 |     | 
 550 |     |                         let mc := add(_postBytes, 0x20)
 551 |     |                         let end := add(mc, mlength)
 552 |     | 
 553 |     |                         // the next line is the loop condition:
 554 |     |                         // while(uint256(mc < end) + cb == 2)
 555 |     |                         for {} eq(add(lt(mc, end), cb), 2) {
 556 |     |                             sc := add(sc, 1)
 557 |     |                             mc := add(mc, 0x20)
 558 |     |                         } {
 559 |     |                             if iszero(eq(sload(sc), mload(mc))) {
 560 |     |                                 // unsuccess:
 561 |     |                                 success := 0
 562 |     |                                 cb := 0
 563 |     |                             }
 564 |     |                         }
 565 |     |                     }
 566 |     |                 }
 567 |     |             }
 568 |     |             default {
 569 |     |                 // unsuccess:
 570 |     |                 success := 0
 571 |     |             }
 572 |     |         }
 573 |     | 
 574 |     |         return success;
 575 |     |     }
 576 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/SafeERC20.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
  5 |     | import { SafeERC20 as OZSafeERC20 } from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
  6 |     | 
  7 |     | // solhint-disable avoid-low-level-calls
  8 |     | // solhint-disable max-line-length
  9 |     | 
 10 |     | /// @title SafeERC20 provides helper functions for safe transfers as well as safe metadata access
 11 |     | /// @author Library originally written by @Boring_Crypto github.com/boring_crypto, modified by Drake Evans (Frax Finance) github.com/drakeevans
 12 |     | /// @dev original: https://github.com/boringcrypto/BoringSolidity/blob/fed25c5d43cb7ce20764cd0b838e21a02ea162e9/contracts/libraries/BoringERC20.sol
 13 |     | library SafeERC20 {
 14 |     |     bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()
 15 |     |     bytes4 private constant SIG_NAME = 0x06fdde03; // name()
 16 |     |     bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()
 17 |     | 
 18 |     |     function returnDataToString(bytes memory data) internal pure returns (string memory) {
 19 |     |         if (data.length >= 64) {
 20 |     |             return abi.decode(data, (string));
 21 |     |         } else if (data.length == 32) {
 22 |     |             uint8 i = 0;
 23 |     |             while (i < 32 && data[i] != 0) {
 24 |     |                 i++;
 25 |     |             }
 26 |     |             bytes memory bytesArray = new bytes(i);
 27 |     |             for (i = 0; i < 32 && data[i] != 0; i++) {
 28 |     |                 bytesArray[i] = data[i];
 29 |     |             }
 30 |     |             return string(bytesArray);
 31 |     |         } else {
 32 |     |             return "???";
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Provides a safe ERC20.symbol version which returns '???' as fallback string.
 37 |     |     /// @param token The address of the ERC-20 token contract.
 38 |     |     /// @return (string) Token symbol.
 39 |     |     function safeSymbol(IERC20 token) internal view returns (string memory) {
 40 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));
 41 |     |         return success ? returnDataToString(data) : "???";
 42 |     |     }
 43 |     | 
 44 |     |     /// @notice Provides a safe ERC20.name version which returns '???' as fallback string.
 45 |     |     /// @param token The address of the ERC-20 token contract.
 46 |     |     /// @return (string) Token name.
 47 |     |     function safeName(IERC20 token) internal view returns (string memory) {
 48 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));
 49 |     |         return success ? returnDataToString(data) : "???";
 50 |     |     }
 51 |     | 
 52 |     |     /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.
 53 |     |     /// @param token The address of the ERC-20 token contract.
 54 |     |     /// @return (uint8) Token decimals.
 55 |     |     function safeDecimals(IERC20 token) internal view returns (uint8) {
 56 |     |         (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));
 57 |     |         return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;
 58 |     |     }
 59 |     | 
 60 |     |     function safeTransfer(IERC20 token, address to, uint256 value) internal {
 61 |     |         OZSafeERC20.safeTransfer(token, to, value);
 62 |     |     }
 63 |     | 
 64 |     |     function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {
 65 |     |         OZSafeERC20.safeTransferFrom(token, from, to, value);
 66 |     |     }
 67 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/VaultAccount.sol
  1 |     | // SPDX-License-Identifier: ISC
  2 |     | pragma solidity ^0.8.19;
  3 |     | 
  4 |     | import { IERC4626Extended } from "../interfaces/IERC4626Extended.sol";
  5 |     | 
  6 |     | struct VaultAccount {
  7 |     |     uint128 amount; // Total amount, analogous to market cap
  8 |     |     uint128 shares; // Total shares, analogous to shares outstanding
  9 |     | }
 10 |     | 
 11 |     | /// @title VaultAccount Library
 12 |     | /// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto
 13 |     | /// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations
 14 |     | /// @dev Uses uint128 to save on storage
 15 |     | library VaultAccountingLibrary {
 16 |     |     function totalAmount(VaultAccount memory total, address vault) internal view returns (uint256 amount) {
 17 |     |         if (vault == address(0)) {
 18 |     |           return total.amount;
 19 |     |         }
 20 |     |         return total.amount + IERC4626Extended(vault).totalAvailableAssets();
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Calculates the shares value in relationship to `amount` and `total`
 24 |     |     /// @dev Given an amount, return the appropriate number of shares
 25 |     |     function toShares(VaultAccount memory total, uint256 amount, bool roundUp) internal pure returns (uint256 shares) {
 26 |     |         if (total.amount == 0) {
 27 |     |             shares = amount;
 28 |     |         } else {
 29 |     |             shares = (amount * total.shares) / total.amount;
 30 |     |             if (roundUp && (shares * total.amount) / total.shares < amount) {
 31 |     |                 shares = shares + 1;
 32 |     |             }
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     /// @notice Calculates the amount value in relationship to `shares` and `total`
 37 |     |     /// @dev Given a number of shares, returns the appropriate amount
 38 |     |     function toAmount(VaultAccount memory total, uint256 shares, bool roundUp) internal pure returns (uint256 amount) {
 39 |     |         if (total.shares == 0) {
 40 |     |             amount = shares;
 41 |     |         } else {
 42 |     |             amount = (shares * total.amount) / total.shares;
 43 |     |             if (roundUp && (amount * total.shares) / total.amount < shares) {
 44 |     |                 amount = amount + 1;
 45 |     |             }
 46 |     |         }
 47 |     |     }
 48 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-3.0-or-later
  2 |     | 
  3 |     | pragma solidity ^0.8.0;
  4 |     | 
  5 |     | // helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false
  6 |     | library TransferHelper {
  7 |     |     function safeApprove(address token, address to, uint256 value) internal {
  8 |     |         // bytes4(keccak256(bytes('approve(address,uint256)')));
  9 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));
 10 |     |         require(
 11 |     |             success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper::safeApprove: approve failed"
 12 |     |         );
 13 |     |     }
 14 |     | 
 15 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 16 |     |         // bytes4(keccak256(bytes('transfer(address,uint256)')));
 17 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
 18 |     |         require(
 19 |     |             success && (data.length == 0 || abi.decode(data, (bool))), "TransferHelper::safeTransfer: transfer failed"
 20 |     |         );
 21 |     |     }
 22 |     | 
 23 |     |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 24 |     |         // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));
 25 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));
 26 |     |         require(
 27 |     |             success && (data.length == 0 || abi.decode(data, (bool))),
 28 |     |             "TransferHelper::transferFrom: transferFrom failed"
 29 |     |         );
 30 |     |     }
 31 |     | 
 32 |     |     function safeTransferETH(address to, uint256 value) internal {
 33 |     |         (bool success,) = to.call{value: value}(new bytes(0));
 34 |     |         require(success, "TransferHelper::safeTransferETH: ETH transfer failed");
 35 |     |     }
 36 |     | }
 37 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2ERC20.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./interfaces/IUniswapV2ERC20.sol";
  4 |     | import "./libraries/SafeMath.sol";
  5 |     | 
  6 |     | contract UniswapV2ERC20 is IUniswapV2ERC20 {
  7 |     |     using SafeMath for uint256;
  8 |     | 
  9 |     |     string public constant name = "Uniswap V2";
 10 |     |     string public constant symbol = "UNI-V2";
 11 |     |     uint8 public constant decimals = 18;
 12 |     |     uint256 public totalSupply;
 13 |     |     mapping(address => uint256) public balanceOf;
 14 |     |     mapping(address => mapping(address => uint256)) public allowance;
 15 |     | 
 16 |     |     bytes32 public DOMAIN_SEPARATOR;
 17 |     |     // keccak256("Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)");
 18 |     |     bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;
 19 |     |     mapping(address => uint256) public nonces;
 20 |     | 
 21 |     |     // event Approval(address indexed owner, address indexed spender, uint value);
 22 |     |     // event Transfer(address indexed from, address indexed to, uint value);
 23 |     | 
 24 |     |     constructor() {
 25 |     |         uint256 chainId;
 26 |     |         DOMAIN_SEPARATOR = keccak256(
 27 |     |             abi.encode(
 28 |     |                 keccak256("EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)"),
 29 |     |                 keccak256(bytes(name)),
 30 |     |                 keccak256(bytes("1")),
 31 |     |                 chainId,
 32 |     |                 address(this)
 33 |     |             )
 34 |     |         );
 35 |     |     }
 36 |     | 
 37 |     |     function _mint(address to, uint256 value) internal {
 38 |     |         totalSupply = totalSupply.add(value);
 39 |     |         balanceOf[to] = balanceOf[to].add(value);
 40 |     |         emit Transfer(address(0), to, value);
 41 |     |     }
 42 |     | 
 43 |     |     function _burn(address from, uint256 value) internal {
 44 |     |         balanceOf[from] = balanceOf[from].sub(value);
 45 |     |         totalSupply = totalSupply.sub(value);
 46 |     |         emit Transfer(from, address(0), value);
 47 |     |     }
 48 |     | 
 49 |     |     function _approve(address owner, address spender, uint256 value) private {
 50 |     |         allowance[owner][spender] = value;
 51 |     |         emit Approval(owner, spender, value);
 52 |     |     }
 53 |     | 
 54 |     |     function _transfer(address from, address to, uint256 value) private {
 55 |     |         balanceOf[from] = balanceOf[from].sub(value);
 56 |     |         balanceOf[to] = balanceOf[to].add(value);
 57 |     |         emit Transfer(from, to, value);
 58 |     |     }
 59 |     | 
 60 |     |     function approve(address spender, uint256 value) external returns (bool) {
 61 |     |         _approve(msg.sender, spender, value);
 62 |     |         return true;
 63 |     |     }
 64 |     | 
 65 |     |     function transfer(address to, uint256 value) external returns (bool) {
 66 |     |         _transfer(msg.sender, to, value);
 67 |     |         return true;
 68 |     |     }
 69 |     | 
 70 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool) {
 71 |     |         if (allowance[from][msg.sender] != type(uint256).max) {
 72 |     |             allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);
 73 |     |         }
 74 |     |         _transfer(from, to, value);
 75 |     |         return true;
 76 |     |     }
 77 |     | 
 78 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 79 |     |         external
 80 |     |     {
 81 |     |         require(deadline >= block.timestamp, "UniswapV2: EXPIRED");
 82 |     |         bytes32 digest = keccak256(
 83 |     |             abi.encodePacked(
 84 |     |                 "\x19\x01",
 85 |     |                 DOMAIN_SEPARATOR,
 86 |     |                 keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))
 87 |     |             )
 88 |     |         );
 89 |     |         address recoveredAddress = ecrecover(digest, v, r, s);
 90 |     |         require(recoveredAddress != address(0) && recoveredAddress == owner, "UniswapV2: INVALID_SIGNATURE");
 91 |     |         _approve(owner, spender, value);
 92 |     |     }
 93 |     | }
 94 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2Factory.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./interfaces/IUniswapV2Factory.sol";
  4 |     | import "./UniswapV2Pair.sol";
  5 |     | 
  6 |     | contract UniswapV2Factory is IUniswapV2Factory {
  7 |     |     address public feeTo;
  8 |     |     address public feeToSetter;
  9 |     | 
 10 |     |     mapping(address => mapping(address => address)) public getPair;
 11 |     |     address[] public allPairs;
 12 |     | 
 13 |     |     // event PairCreated(address indexed token0, address indexed token1, address pair, uint);
 14 |     | 
 15 |     |     constructor(address _feeToSetter) {
 16 |     |         feeToSetter = _feeToSetter;
 17 |     |     }
 18 |     | 
 19 |     |     function allPairsLength() external view returns (uint256) {
 20 |     |         return allPairs.length;
 21 |     |     }
 22 |     | 
 23 |     |     function createPair(address tokenA, address tokenB) external returns (address pair) {
 24 |     |         require(tokenA != tokenB, "UniswapV2: IDENTICAL_ADDRESSES");
 25 |     |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 26 |     |         require(token0 != address(0), "UniswapV2: ZERO_ADDRESS");
 27 |     |         require(getPair[token0][token1] == address(0), "UniswapV2: PAIR_EXISTS"); // single check is sufficient
 28 |     | 
 29 |     |         bytes memory bytecode = type(UniswapV2Pair).creationCode;
 30 |     |         bytes32 salt = keccak256(abi.encodePacked(token0, token1));
 31 |     |         assembly {
 32 |     |             pair := create2(0, add(bytecode, 32), mload(bytecode), salt)
 33 |     |         }
 34 |     | 
 35 |     |         IUniswapV2Pair(pair).initialize(token0, token1);
 36 |     |         getPair[token0][token1] = pair;
 37 |     |         getPair[token1][token0] = pair; // populate mapping in the reverse direction
 38 |     |         allPairs.push(pair);
 39 |     | 
 40 |     |         emit PairCreated(token0, token1, pair, allPairs.length);
 41 |     |     }
 42 |     | 
 43 |     |     function setFeeTo(address _feeTo) external {
 44 |     |         require(msg.sender == feeToSetter, "UniswapV2: FORBIDDEN");
 45 |     |         feeTo = _feeTo;
 46 |     |     }
 47 |     | 
 48 |     |     function setFeeToSetter(address _feeToSetter) external {
 49 |     |         require(msg.sender == feeToSetter, "UniswapV2: FORBIDDEN");
 50 |     |         feeToSetter = _feeToSetter;
 51 |     |     }
 52 |     | }
 53 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2Pair.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | import "./interfaces/IUniswapV2Pair.sol";
   4 |     | import "./UniswapV2ERC20.sol";
   5 |     | import "./libraries/Math.sol";
   6 |     | import "./libraries/UQ112x112.sol";
   7 |     | import "./interfaces/IERC20.sol";
   8 |     | import "./interfaces/IUniswapV2Factory.sol";
   9 |     | import "./interfaces/IUniswapV2Callee.sol";
  10 |     | 
  11 |     | contract UniswapV2Pair is UniswapV2ERC20 {
  12 |     |     using SafeMath for uint256;
  13 |     |     using UQ112x112 for uint224;
  14 |     | 
  15 |     |     uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;
  16 |     |     bytes4 private constant SELECTOR = bytes4(keccak256(bytes("transfer(address,uint256)")));
  17 |     | 
  18 |     |     address public factory;
  19 |     |     address public token0;
  20 |     |     address public token1;
  21 |     | 
  22 |     |     uint112 public reserve0; // uses single storage slot, accessible via getReserves
  23 |     |     uint112 public reserve1; // uses single storage slot, accessible via getReserves
  24 |     |     uint32 public blockTimestampLast; // uses single storage slot, accessible via getReserves
  25 |     | 
  26 |     |     uint256 public price0CumulativeLast;
  27 |     |     uint256 public price1CumulativeLast;
  28 |     |     uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event
  29 |     | 
  30 |     |     uint256 private unlocked = 1;
  31 |     | 
  32 |     |     modifier lock() {
  33 |     |         require(unlocked == 1, "UniswapV2: LOCKED");
  34 |     |         unlocked = 0;
  35 |     |         _;
  36 |     |         unlocked = 1;
  37 |     |     }
  38 |     | 
  39 |     |     function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {
  40 |     |         _reserve0 = reserve0;
  41 |     |         _reserve1 = reserve1;
  42 |     |         _blockTimestampLast = blockTimestampLast;
  43 |     |     }
  44 |     | 
  45 |     |     function _safeTransfer(address token, address to, uint256 value) private {
  46 |     |         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));
  47 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "UniswapV2: TRANSFER_FAILED");
  48 |     |     }
  49 |     | 
  50 |     |     event Mint(address indexed sender, uint256 amount0, uint256 amount1);
  51 |     |     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
  52 |     |     event Swap(
  53 |     |         address indexed sender,
  54 |     |         uint256 amount0In,
  55 |     |         uint256 amount1In,
  56 |     |         uint256 amount0Out,
  57 |     |         uint256 amount1Out,
  58 |     |         address indexed to
  59 |     |     );
  60 |     |     event Sync(uint112 reserve0, uint112 reserve1);
  61 |     | 
  62 |     |     constructor() {
  63 |     |         factory = msg.sender;
  64 |     |     }
  65 |     | 
  66 |     |     // called once by the factory at time of deployment
  67 |     |     function initialize(address _token0, address _token1) external {
  68 |     |         require(msg.sender == factory, "UniswapV2: FORBIDDEN"); // sufficient check
  69 |     |         token0 = _token0;
  70 |     |         token1 = _token1;
  71 |     |     }
  72 |     | 
  73 |     |     // update reserves and, on the first call per block, price accumulators
  74 |     |     function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {
  75 |     |         require(balance0 <= type(uint112).max && balance1 <= type(uint112).max, "UniswapV2: OVERFLOW");
  76 |     |         uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);
  77 |     |         uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired
  78 |     |         if (timeElapsed > 0 && _reserve0 != 0 && _reserve1 != 0) {
  79 |     |             // * never overflows, and + overflow is desired
  80 |     |             price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;
  81 |     |             price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;
  82 |     |         }
  83 |     |         reserve0 = uint112(balance0);
  84 |     |         reserve1 = uint112(balance1);
  85 |     |         blockTimestampLast = blockTimestamp;
  86 |     |         emit Sync(reserve0, reserve1);
  87 |     |     }
  88 |     | 
  89 |     |     // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)
  90 |     |     function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {
  91 |     |         address feeTo = IUniswapV2Factory(factory).feeTo();
  92 |     |         feeOn = feeTo != address(0);
  93 |     |         uint256 _kLast = kLast; // gas savings
  94 |     |         if (feeOn) {
  95 |     |             if (_kLast != 0) {
  96 |     |                 uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));
  97 |     |                 uint256 rootKLast = Math.sqrt(_kLast);
  98 |     |                 if (rootK > rootKLast) {
  99 |     |                     uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));
 100 |     |                     uint256 denominator = rootK.mul(5).add(rootKLast);
 101 |     |                     uint256 liquidity = numerator / denominator;
 102 |     |                     if (liquidity > 0) _mint(feeTo, liquidity);
 103 |     |                 }
 104 |     |             }
 105 |     |         } else if (_kLast != 0) {
 106 |     |             kLast = 0;
 107 |     |         }
 108 |     |     }
 109 |     | 
 110 |     |     // this low-level function should be called from a contract which performs important safety checks
 111 |     |     function mint(address to) external lock returns (uint256 liquidity) {
 112 |     |         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
 113 |     |         uint256 balance0 = IERC20(token0).balanceOf(address(this));
 114 |     |         uint256 balance1 = IERC20(token1).balanceOf(address(this));
 115 |     |         uint256 amount0 = balance0.sub(_reserve0);
 116 |     |         uint256 amount1 = balance1.sub(_reserve1);
 117 |     | 
 118 |     |         bool feeOn = _mintFee(_reserve0, _reserve1);
 119 |     |         uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
 120 |     |         if (_totalSupply == 0) {
 121 |     |             liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);
 122 |     |             _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens
 123 |     |         } else {
 124 |     |             liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);
 125 |     |         }
 126 |     |         require(liquidity > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED");
 127 |     |         _mint(to, liquidity);
 128 |     | 
 129 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 130 |     |         if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
 131 |     |         emit Mint(msg.sender, amount0, amount1);
 132 |     |     }
 133 |     | 
 134 |     |     // this low-level function should be called from a contract which performs important safety checks
 135 |     |     function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {
 136 |     |         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
 137 |     |         address _token0 = token0; // gas savings
 138 |     |         address _token1 = token1; // gas savings
 139 |     |         uint256 balance0 = IERC20(_token0).balanceOf(address(this));
 140 |     |         uint256 balance1 = IERC20(_token1).balanceOf(address(this));
 141 |     |         uint256 liquidity = balanceOf[address(this)];
 142 |     | 
 143 |     |         bool feeOn = _mintFee(_reserve0, _reserve1);
 144 |     |         uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee
 145 |     |         amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution
 146 |     |         amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution
 147 |     |         require(amount0 > 0 && amount1 > 0, "UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED");
 148 |     |         _burn(address(this), liquidity);
 149 |     |         _safeTransfer(_token0, to, amount0);
 150 |     |         _safeTransfer(_token1, to, amount1);
 151 |     |         balance0 = IERC20(_token0).balanceOf(address(this));
 152 |     |         balance1 = IERC20(_token1).balanceOf(address(this));
 153 |     | 
 154 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 155 |     |         if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date
 156 |     |         emit Burn(msg.sender, amount0, amount1, to);
 157 |     |     }
 158 |     | 
 159 |     |     // this low-level function should be called from a contract which performs important safety checks
 160 |     |     function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {
 161 |     |         require(amount0Out > 0 || amount1Out > 0, "UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT");
 162 |     |         (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings
 163 |     |         require(amount0Out < _reserve0 && amount1Out < _reserve1, "UniswapV2: INSUFFICIENT_LIQUIDITY");
 164 |     | 
 165 |     |         uint256 balance0;
 166 |     |         uint256 balance1;
 167 |     |         {
 168 |     |             // scope for _token{0,1}, avoids stack too deep errors
 169 |     |             address _token0 = token0;
 170 |     |             address _token1 = token1;
 171 |     |             require(to != _token0 && to != _token1, "UniswapV2: INVALID_TO");
 172 |     |             if (amount0Out > 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens
 173 |     |             if (amount1Out > 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens
 174 |     |             if (data.length > 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);
 175 |     |             balance0 = IERC20(_token0).balanceOf(address(this));
 176 |     |             balance1 = IERC20(_token1).balanceOf(address(this));
 177 |     |         }
 178 |     |         uint256 amount0In = balance0 > _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;
 179 |     |         uint256 amount1In = balance1 > _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;
 180 |     |         require(amount0In > 0 || amount1In > 0, "UniswapV2: INSUFFICIENT_INPUT_AMOUNT");
 181 |     |         {
 182 |     |             // scope for reserve{0,1}Adjusted, avoids stack too deep errors
 183 |     |             uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));
 184 |     |             uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));
 185 |     |             require(
 186 |     |                 balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),
 187 |     |                 "UniswapV2: K"
 188 |     |             );
 189 |     |         }
 190 |     | 
 191 |     |         _update(balance0, balance1, _reserve0, _reserve1);
 192 |     |         emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);
 193 |     |     }
 194 |     | 
 195 |     |     // force balances to match reserves
 196 |     |     function skim(address to) external lock {
 197 |     |         address _token0 = token0; // gas savings
 198 |     |         address _token1 = token1; // gas savings
 199 |     |         _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));
 200 |     |         _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));
 201 |     |     }
 202 |     | 
 203 |     |     // force reserves to match balances
 204 |     |     function sync() external lock {
 205 |     |         _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);
 206 |     |     }
 207 |     | }
 208 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IERC20.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | interface IERC20 {
  4 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  5 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  6 |     | 
  7 |     |     function name() external view returns (string memory);
  8 |     | 
  9 |     |     function symbol() external view returns (string memory);
 10 |     | 
 11 |     |     function decimals() external view returns (uint8);
 12 |     | 
 13 |     |     function totalSupply() external view returns (uint256);
 14 |     | 
 15 |     |     function balanceOf(address owner) external view returns (uint256);
 16 |     | 
 17 |     |     function allowance(address owner, address spender) external view returns (uint256);
 18 |     | 
 19 |     |     function approve(address spender, uint256 value) external returns (bool);
 20 |     | 
 21 |     |     function transfer(address to, uint256 value) external returns (bool);
 22 |     | 
 23 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 24 |     | }
 25 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Callee.sol
 1 |     | pragma solidity ^0.8.0;
 2 |     | 
 3 |     | interface IUniswapV2Callee {
 4 |     |     function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;
 5 |     | }
 6 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2ERC20.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | interface IUniswapV2ERC20 {
  4 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  5 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  6 |     | 
  7 |     |     function name() external pure returns (string memory);
  8 |     | 
  9 |     |     function symbol() external pure returns (string memory);
 10 |     | 
 11 |     |     function decimals() external pure returns (uint8);
 12 |     | 
 13 |     |     function totalSupply() external view returns (uint256);
 14 |     | 
 15 |     |     function balanceOf(address owner) external view returns (uint256);
 16 |     | 
 17 |     |     function allowance(address owner, address spender) external view returns (uint256);
 18 |     | 
 19 |     |     function approve(address spender, uint256 value) external returns (bool);
 20 |     | 
 21 |     |     function transfer(address to, uint256 value) external returns (bool);
 22 |     | 
 23 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 24 |     | 
 25 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 26 |     | 
 27 |     |     function PERMIT_TYPEHASH() external pure returns (bytes32);
 28 |     | 
 29 |     |     function nonces(address owner) external view returns (uint256);
 30 |     | 
 31 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 32 |     |         external;
 33 |     | }
 34 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Factory.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | interface IUniswapV2Factory {
  4 |     |     event PairCreated(address indexed token0, address indexed token1, address pair, uint256);
  5 |     | 
  6 |     |     function feeTo() external view returns (address);
  7 |     | 
  8 |     |     function feeToSetter() external view returns (address);
  9 |     | 
 10 |     |     function getPair(address tokenA, address tokenB) external view returns (address pair);
 11 |     | 
 12 |     |     function allPairs(uint256) external view returns (address pair);
 13 |     | 
 14 |     |     function allPairsLength() external view returns (uint256);
 15 |     | 
 16 |     |     function createPair(address tokenA, address tokenB) external returns (address pair);
 17 |     | 
 18 |     |     function setFeeTo(address) external;
 19 |     | 
 20 |     |     function setFeeToSetter(address) external;
 21 |     | }
 22 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Pair.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | interface IUniswapV2Pair {
  4 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
  5 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
  6 |     | 
  7 |     |     function name() external pure returns (string memory);
  8 |     | 
  9 |     |     function symbol() external pure returns (string memory);
 10 |     | 
 11 |     |     function decimals() external pure returns (uint8);
 12 |     | 
 13 |     |     function totalSupply() external view returns (uint256);
 14 |     | 
 15 |     |     function balanceOf(address owner) external view returns (uint256);
 16 |     | 
 17 |     |     function allowance(address owner, address spender) external view returns (uint256);
 18 |     | 
 19 |     |     function approve(address spender, uint256 value) external returns (bool);
 20 |     | 
 21 |     |     function transfer(address to, uint256 value) external returns (bool);
 22 |     | 
 23 |     |     function transferFrom(address from, address to, uint256 value) external returns (bool);
 24 |     | 
 25 |     |     function DOMAIN_SEPARATOR() external view returns (bytes32);
 26 |     | 
 27 |     |     function PERMIT_TYPEHASH() external pure returns (bytes32);
 28 |     | 
 29 |     |     function nonces(address owner) external view returns (uint256);
 30 |     | 
 31 |     |     function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)
 32 |     |         external;
 33 |     | 
 34 |     |     event Mint(address indexed sender, uint256 amount0, uint256 amount1);
 35 |     |     event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);
 36 |     |     event Swap(
 37 |     |         address indexed sender,
 38 |     |         uint256 amount0In,
 39 |     |         uint256 amount1In,
 40 |     |         uint256 amount0Out,
 41 |     |         uint256 amount1Out,
 42 |     |         address indexed to
 43 |     |     );
 44 |     |     event Sync(uint112 reserve0, uint112 reserve1);
 45 |     | 
 46 |     |     function MINIMUM_LIQUIDITY() external pure returns (uint256);
 47 |     | 
 48 |     |     function factory() external view returns (address);
 49 |     | 
 50 |     |     function token0() external view returns (address);
 51 |     | 
 52 |     |     function token1() external view returns (address);
 53 |     | 
 54 |     |     function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);
 55 |     | 
 56 |     |     function price0CumulativeLast() external view returns (uint256);
 57 |     | 
 58 |     |     function price1CumulativeLast() external view returns (uint256);
 59 |     | 
 60 |     |     function kLast() external view returns (uint256);
 61 |     | 
 62 |     |     function mint(address to) external returns (uint256 liquidity);
 63 |     | 
 64 |     |     function burn(address to) external returns (uint256 amount0, uint256 amount1);
 65 |     | 
 66 |     |     function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;
 67 |     | 
 68 |     |     function skim(address to) external;
 69 |     | 
 70 |     |     function sync() external;
 71 |     | 
 72 |     |     function initialize(address, address) external;
 73 |     | }
 74 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/Math.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | // a library for performing various math operations
  4 |     | 
  5 |     | library Math {
  6 |     |     function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
  7 |     |         z = x < y ? x : y;
  8 |     |     }
  9 |     | 
 10 |     |     // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
 11 |     |     function sqrt(uint256 y) internal pure returns (uint256 z) {
 12 |     |         if (y > 3) {
 13 |     |             z = y;
 14 |     |             uint256 x = y / 2 + 1;
 15 |     |             while (x < z) {
 16 |     |                 z = x;
 17 |     |                 x = (y / x + x) / 2;
 18 |     |             }
 19 |     |         } else if (y != 0) {
 20 |     |             z = 1;
 21 |     |         }
 22 |     |     }
 23 |     | }
 24 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/SafeMath.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | // a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)
  4 |     | 
  5 |     | library SafeMath {
  6 |     |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
  7 |     |         require((z = x + y) >= x, "ds-math-add-overflow");
  8 |     |     }
  9 |     | 
 10 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 11 |     |         require((z = x - y) <= x, "ds-math-sub-underflow");
 12 |     |     }
 13 |     | 
 14 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 15 |     |         require(y == 0 || (z = x * y) / y == x, "ds-math-mul-overflow");
 16 |     |     }
 17 |     | }
 18 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/UQ112x112.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | // a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))
  4 |     | 
  5 |     | // range: [0, 2**112 - 1]
  6 |     | // resolution: 1 / 2**112
  7 |     | 
  8 |     | library UQ112x112 {
  9 |     |     uint224 constant Q112 = 2 ** 112;
 10 |     | 
 11 |     |     // encode a uint112 as a UQ112x112
 12 |     |     function encode(uint112 y) internal pure returns (uint224 z) {
 13 |     |         z = uint224(y) * Q112; // never overflows
 14 |     |     }
 15 |     | 
 16 |     |     // divide a UQ112x112 by a uint112, returning a UQ112x112
 17 |     |     function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {
 18 |     |         z = x / uint224(y);
 19 |     |     }
 20 |     | }
 21 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/UniswapV2Router02.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | import "v2-core/interfaces/IUniswapV2Factory.sol";
   4 |     | import "uniswap-v2/libraries/TransferHelper.sol";
   5 |     | 
   6 |     | import "./interfaces/IUniswapV2Router02.sol";
   7 |     | import "./libraries/UniswapV2Library.sol";
   8 |     | import "./interfaces/IWETH.sol";
   9 |     | 
  10 |     | contract UniswapV2Router02 is IUniswapV2Router02 {
  11 |     |     using SafeMath for uint256;
  12 |     | 
  13 |     |     address public immutable factory;
  14 |     |     address public immutable WETH;
  15 |     | 
  16 |     |     modifier ensure(uint256 deadline) {
  17 |     |         require(deadline >= block.timestamp, "UniswapV2Router: EXPIRED");
  18 |     |         _;
  19 |     |     }
  20 |     | 
  21 |     |     constructor(address _factory, address _WETH) {
  22 |     |         factory = _factory;
  23 |     |         WETH = _WETH;
  24 |     |     }
  25 |     | 
  26 |     |     receive() external payable {
  27 |     |         assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract
  28 |     |     }
  29 |     | 
  30 |     |     // **** ADD LIQUIDITY ****
  31 |     |     function _addLiquidity(
  32 |     |         address tokenA,
  33 |     |         address tokenB,
  34 |     |         uint256 amountADesired,
  35 |     |         uint256 amountBDesired,
  36 |     |         uint256 amountAMin,
  37 |     |         uint256 amountBMin
  38 |     |     ) internal virtual returns (uint256 amountA, uint256 amountB) {
  39 |     |         // create the pair if it doesn't exist yet
  40 |     |         if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {
  41 |     |             IUniswapV2Factory(factory).createPair(tokenA, tokenB);
  42 |     |         }
  43 |     |         (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);
  44 |     |         if (reserveA == 0 && reserveB == 0) {
  45 |     |             (amountA, amountB) = (amountADesired, amountBDesired);
  46 |     |         } else {
  47 |     |             uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);
  48 |     |             if (amountBOptimal <= amountBDesired) {
  49 |     |                 require(amountBOptimal >= amountBMin, "UniswapV2Router: INSUFFICIENT_B_AMOUNT");
  50 |     |                 (amountA, amountB) = (amountADesired, amountBOptimal);
  51 |     |             } else {
  52 |     |                 uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);
  53 |     |                 assert(amountAOptimal <= amountADesired);
  54 |     |                 require(amountAOptimal >= amountAMin, "UniswapV2Router: INSUFFICIENT_A_AMOUNT");
  55 |     |                 (amountA, amountB) = (amountAOptimal, amountBDesired);
  56 |     |             }
  57 |     |         }
  58 |     |     }
  59 |     | 
  60 |     |     event MessageNum(string a, uint256 b);
  61 |     | 
  62 |     |     function addLiquidity(
  63 |     |         address tokenA,
  64 |     |         address tokenB,
  65 |     |         uint256 amountADesired,
  66 |     |         uint256 amountBDesired,
  67 |     |         uint256 amountAMin,
  68 |     |         uint256 amountBMin,
  69 |     |         address to,
  70 |     |         uint256 deadline
  71 |     |     ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB, uint256 liquidity) {
  72 |     |         (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);
  73 |     |         address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);
  74 |     |         TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);
  75 |     |         emit MessageNum("amount transfered", amountB);
  76 |     |         TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);
  77 |     |         liquidity = IUniswapV2Pair(pair).mint(to);
  78 |     |     }
  79 |     | 
  80 |     |     function addLiquidityETH(
  81 |     |         address token,
  82 |     |         uint256 amountTokenDesired,
  83 |     |         uint256 amountTokenMin,
  84 |     |         uint256 amountETHMin,
  85 |     |         address to,
  86 |     |         uint256 deadline
  87 |     |     )
  88 |     |         external
  89 |     |         payable
  90 |     |         virtual
  91 |     |         override
  92 |     |         ensure(deadline)
  93 |     |         returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)
  94 |     |     {
  95 |     |         (amountToken, amountETH) =
  96 |     |             _addLiquidity(token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);
  97 |     |         address pair = UniswapV2Library.pairFor(factory, token, WETH);
  98 |     |         TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);
  99 |     |         IWETH(WETH).deposit{value: amountETH}();
 100 |     |         assert(IWETH(WETH).transfer(pair, amountETH));
 101 |     |         liquidity = IUniswapV2Pair(pair).mint(to);
 102 |     |         // refund dust eth, if any
 103 |     |         if (msg.value > amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);
 104 |     |     }
 105 |     | 
 106 |     |     // **** REMOVE LIQUIDITY ****
 107 |     |     function removeLiquidity(
 108 |     |         address tokenA,
 109 |     |         address tokenB,
 110 |     |         uint256 liquidity,
 111 |     |         uint256 amountAMin,
 112 |     |         uint256 amountBMin,
 113 |     |         address to,
 114 |     |         uint256 deadline
 115 |     |     ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {
 116 |     |         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
 117 |     |         IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair
 118 |     |         (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);
 119 |     |         (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);
 120 |     |         (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);
 121 |     |         require(amountA >= amountAMin, "UniswapV2Router: INSUFFICIENT_A_AMOUNT");
 122 |     |         require(amountB >= amountBMin, "UniswapV2Router: INSUFFICIENT_B_AMOUNT");
 123 |     |     }
 124 |     | 
 125 |     |     function removeLiquidityETH(
 126 |     |         address token,
 127 |     |         uint256 liquidity,
 128 |     |         uint256 amountTokenMin,
 129 |     |         uint256 amountETHMin,
 130 |     |         address to,
 131 |     |         uint256 deadline
 132 |     |     ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {
 133 |     |         (amountToken, amountETH) =
 134 |     |             removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);
 135 |     |         TransferHelper.safeTransfer(token, to, amountToken);
 136 |     |         IWETH(WETH).withdraw(amountETH);
 137 |     |         TransferHelper.safeTransferETH(to, amountETH);
 138 |     |     }
 139 |     | 
 140 |     |     function removeLiquidityWithPermit(
 141 |     |         address tokenA,
 142 |     |         address tokenB,
 143 |     |         uint256 liquidity,
 144 |     |         uint256 amountAMin,
 145 |     |         uint256 amountBMin,
 146 |     |         address to,
 147 |     |         uint256 deadline,
 148 |     |         bool approveMax,
 149 |     |         uint8 v,
 150 |     |         bytes32 r,
 151 |     |         bytes32 s
 152 |     |     ) external virtual override returns (uint256 amountA, uint256 amountB) {
 153 |     |         address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);
 154 |     |         uint256 value = approveMax ? type(uint256).max : liquidity;
 155 |     |         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
 156 |     |         (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);
 157 |     |     }
 158 |     | 
 159 |     |     function removeLiquidityETHWithPermit(
 160 |     |         address token,
 161 |     |         uint256 liquidity,
 162 |     |         uint256 amountTokenMin,
 163 |     |         uint256 amountETHMin,
 164 |     |         address to,
 165 |     |         uint256 deadline,
 166 |     |         bool approveMax,
 167 |     |         uint8 v,
 168 |     |         bytes32 r,
 169 |     |         bytes32 s
 170 |     |     ) external virtual override returns (uint256 amountToken, uint256 amountETH) {
 171 |     |         address pair = UniswapV2Library.pairFor(factory, token, WETH);
 172 |     |         uint256 value = approveMax ? type(uint256).max : liquidity;
 173 |     |         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
 174 |     |         (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);
 175 |     |     }
 176 |     | 
 177 |     |     // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****
 178 |     |     function removeLiquidityETHSupportingFeeOnTransferTokens(
 179 |     |         address token,
 180 |     |         uint256 liquidity,
 181 |     |         uint256 amountTokenMin,
 182 |     |         uint256 amountETHMin,
 183 |     |         address to,
 184 |     |         uint256 deadline
 185 |     |     ) public virtual override ensure(deadline) returns (uint256 amountETH) {
 186 |     |         (, amountETH) = removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);
 187 |     |         TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));
 188 |     |         IWETH(WETH).withdraw(amountETH);
 189 |     |         TransferHelper.safeTransferETH(to, amountETH);
 190 |     |     }
 191 |     | 
 192 |     |     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
 193 |     |         address token,
 194 |     |         uint256 liquidity,
 195 |     |         uint256 amountTokenMin,
 196 |     |         uint256 amountETHMin,
 197 |     |         address to,
 198 |     |         uint256 deadline,
 199 |     |         bool approveMax,
 200 |     |         uint8 v,
 201 |     |         bytes32 r,
 202 |     |         bytes32 s
 203 |     |     ) external virtual override returns (uint256 amountETH) {
 204 |     |         address pair = UniswapV2Library.pairFor(factory, token, WETH);
 205 |     |         uint256 value = approveMax ? type(uint256).max : liquidity;
 206 |     |         IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);
 207 |     |         amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(
 208 |     |             token, liquidity, amountTokenMin, amountETHMin, to, deadline
 209 |     |         );
 210 |     |     }
 211 |     | 
 212 |     |     // **** SWAP ****
 213 |     |     // requires the initial amount to have already been sent to the first pair
 214 |     |     function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {
 215 |     |         for (uint256 i; i < path.length - 1; i++) {
 216 |     |             (address input, address output) = (path[i], path[i + 1]);
 217 |     |             (address token0,) = UniswapV2Library.sortTokens(input, output);
 218 |     |             uint256 amountOut = amounts[i + 1];
 219 |     |             (uint256 amount0Out, uint256 amount1Out) =
 220 |     |                 input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));
 221 |     |             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
 222 |     |             IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(
 223 |     |                 amount0Out, amount1Out, to, new bytes(0)
 224 |     |             );
 225 |     |         }
 226 |     |     }
 227 |     | 
 228 |     |     function swapExactTokensForTokens(
 229 |     |         uint256 amountIn,
 230 |     |         uint256 amountOutMin,
 231 |     |         address[] calldata path,
 232 |     |         address to,
 233 |     |         uint256 deadline
 234 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 235 |     |         amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
 236 |     |         require(amounts[amounts.length - 1] >= amountOutMin, "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT");
 237 |     |         TransferHelper.safeTransferFrom(
 238 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
 239 |     |         );
 240 |     |         _swap(amounts, path, to);
 241 |     |     }
 242 |     | 
 243 |     |     function swapTokensForExactTokens(
 244 |     |         uint256 amountOut,
 245 |     |         uint256 amountInMax,
 246 |     |         address[] calldata path,
 247 |     |         address to,
 248 |     |         uint256 deadline
 249 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 250 |     |         amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
 251 |     |         require(amounts[0] <= amountInMax, "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT");
 252 |     |         TransferHelper.safeTransferFrom(
 253 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
 254 |     |         );
 255 |     |         _swap(amounts, path, to);
 256 |     |     }
 257 |     | 
 258 |     |     function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)
 259 |     |         external
 260 |     |         payable
 261 |     |         virtual
 262 |     |         override
 263 |     |         ensure(deadline)
 264 |     |         returns (uint256[] memory amounts)
 265 |     |     {
 266 |     |         require(path[0] == WETH, "UniswapV2Router: INVALID_PATH");
 267 |     |         amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);
 268 |     |         require(amounts[amounts.length - 1] >= amountOutMin, "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT");
 269 |     |         IWETH(WETH).deposit{value: amounts[0]}();
 270 |     |         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
 271 |     |         _swap(amounts, path, to);
 272 |     |     }
 273 |     | 
 274 |     |     function swapTokensForExactETH(
 275 |     |         uint256 amountOut,
 276 |     |         uint256 amountInMax,
 277 |     |         address[] calldata path,
 278 |     |         address to,
 279 |     |         uint256 deadline
 280 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 281 |     |         require(path[path.length - 1] == WETH, "UniswapV2Router: INVALID_PATH");
 282 |     |         amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
 283 |     |         require(amounts[0] <= amountInMax, "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT");
 284 |     |         TransferHelper.safeTransferFrom(
 285 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
 286 |     |         );
 287 |     |         _swap(amounts, path, address(this));
 288 |     |         IWETH(WETH).withdraw(amounts[amounts.length - 1]);
 289 |     |         TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
 290 |     |     }
 291 |     | 
 292 |     |     function swapExactTokensForETH(
 293 |     |         uint256 amountIn,
 294 |     |         uint256 amountOutMin,
 295 |     |         address[] calldata path,
 296 |     |         address to,
 297 |     |         uint256 deadline
 298 |     |     ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {
 299 |     |         require(path[path.length - 1] == WETH, "UniswapV2Router: INVALID_PATH");
 300 |     |         amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);
 301 |     |         require(amounts[amounts.length - 1] >= amountOutMin, "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT");
 302 |     |         TransferHelper.safeTransferFrom(
 303 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]
 304 |     |         );
 305 |     |         _swap(amounts, path, address(this));
 306 |     |         IWETH(WETH).withdraw(amounts[amounts.length - 1]);
 307 |     |         TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);
 308 |     |     }
 309 |     | 
 310 |     |     function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)
 311 |     |         external
 312 |     |         payable
 313 |     |         virtual
 314 |     |         override
 315 |     |         ensure(deadline)
 316 |     |         returns (uint256[] memory amounts)
 317 |     |     {
 318 |     |         require(path[0] == WETH, "UniswapV2Router: INVALID_PATH");
 319 |     |         amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);
 320 |     |         require(amounts[0] <= msg.value, "UniswapV2Router: EXCESSIVE_INPUT_AMOUNT");
 321 |     |         IWETH(WETH).deposit{value: amounts[0]}();
 322 |     |         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));
 323 |     |         _swap(amounts, path, to);
 324 |     |         // refund dust eth, if any
 325 |     |         if (msg.value > amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);
 326 |     |     }
 327 |     | 
 328 |     |     // **** SWAP (supporting fee-on-transfer tokens) ****
 329 |     |     // requires the initial amount to have already been sent to the first pair
 330 |     |     function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {
 331 |     |         for (uint256 i; i < path.length - 1; i++) {
 332 |     |             (address input, address output) = (path[i], path[i + 1]);
 333 |     |             (address token0,) = UniswapV2Library.sortTokens(input, output);
 334 |     |             IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));
 335 |     |             uint256 amountInput;
 336 |     |             uint256 amountOutput;
 337 |     |             {
 338 |     |                 // scope to avoid stack too deep errors
 339 |     |                 (uint256 reserve0, uint256 reserve1,) = pair.getReserves();
 340 |     |                 (uint256 reserveInput, uint256 reserveOutput) =
 341 |     |                     input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 342 |     |                 amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);
 343 |     |                 amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);
 344 |     |             }
 345 |     |             (uint256 amount0Out, uint256 amount1Out) =
 346 |     |                 input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));
 347 |     |             address to = i < path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;
 348 |     |             pair.swap(amount0Out, amount1Out, to, new bytes(0));
 349 |     |         }
 350 |     |     }
 351 |     | 
 352 |     |     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
 353 |     |         uint256 amountIn,
 354 |     |         uint256 amountOutMin,
 355 |     |         address[] calldata path,
 356 |     |         address to,
 357 |     |         uint256 deadline
 358 |     |     ) external virtual override ensure(deadline) {
 359 |     |         TransferHelper.safeTransferFrom(
 360 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
 361 |     |         );
 362 |     |         uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
 363 |     |         _swapSupportingFeeOnTransferTokens(path, to);
 364 |     |         require(
 365 |     |             IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
 366 |     |             "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
 367 |     |         );
 368 |     |     }
 369 |     | 
 370 |     |     function swapExactETHForTokensSupportingFeeOnTransferTokens(
 371 |     |         uint256 amountOutMin,
 372 |     |         address[] calldata path,
 373 |     |         address to,
 374 |     |         uint256 deadline
 375 |     |     ) external payable virtual override ensure(deadline) {
 376 |     |         require(path[0] == WETH, "UniswapV2Router: INVALID_PATH");
 377 |     |         uint256 amountIn = msg.value;
 378 |     |         IWETH(WETH).deposit{value: amountIn}();
 379 |     |         assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));
 380 |     |         uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);
 381 |     |         _swapSupportingFeeOnTransferTokens(path, to);
 382 |     |         require(
 383 |     |             IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) >= amountOutMin,
 384 |     |             "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT"
 385 |     |         );
 386 |     |     }
 387 |     | 
 388 |     |     function swapExactTokensForETHSupportingFeeOnTransferTokens(
 389 |     |         uint256 amountIn,
 390 |     |         uint256 amountOutMin,
 391 |     |         address[] calldata path,
 392 |     |         address to,
 393 |     |         uint256 deadline
 394 |     |     ) external virtual override ensure(deadline) {
 395 |     |         require(path[path.length - 1] == WETH, "UniswapV2Router: INVALID_PATH");
 396 |     |         TransferHelper.safeTransferFrom(
 397 |     |             path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn
 398 |     |         );
 399 |     |         _swapSupportingFeeOnTransferTokens(path, address(this));
 400 |     |         uint256 amountOut = IERC20(WETH).balanceOf(address(this));
 401 |     |         require(amountOut >= amountOutMin, "UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT");
 402 |     |         IWETH(WETH).withdraw(amountOut);
 403 |     |         TransferHelper.safeTransferETH(to, amountOut);
 404 |     |     }
 405 |     | 
 406 |     |     // **** LIBRARY FUNCTIONS ****
 407 |     |     function quote(uint256 amountA, uint256 reserveA, uint256 reserveB)
 408 |     |         public
 409 |     |         pure
 410 |     |         virtual
 411 |     |         override
 412 |     |         returns (uint256 amountB)
 413 |     |     {
 414 |     |         return UniswapV2Library.quote(amountA, reserveA, reserveB);
 415 |     |     }
 416 |     | 
 417 |     |     function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
 418 |     |         public
 419 |     |         pure
 420 |     |         virtual
 421 |     |         override
 422 |     |         returns (uint256 amountOut)
 423 |     |     {
 424 |     |         return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);
 425 |     |     }
 426 |     | 
 427 |     |     function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)
 428 |     |         public
 429 |     |         pure
 430 |     |         virtual
 431 |     |         override
 432 |     |         returns (uint256 amountIn)
 433 |     |     {
 434 |     |         return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);
 435 |     |     }
 436 |     | 
 437 |     |     function getAmountsOut(uint256 amountIn, address[] memory path)
 438 |     |         public
 439 |     |         virtual
 440 |     |         override
 441 |     |         returns (uint256[] memory amounts)
 442 |     |     {
 443 |     |         return UniswapV2Library.getAmountsOut(factory, amountIn, path);
 444 |     |     }
 445 |     | 
 446 |     |     function getAmountsIn(uint256 amountOut, address[] memory path)
 447 |     |         public
 448 |     |         virtual
 449 |     |         override
 450 |     |         returns (uint256[] memory amounts)
 451 |     |     {
 452 |     |         return UniswapV2Library.getAmountsIn(factory, amountOut, path);
 453 |     |     }
 454 |     | }
 455 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol
   1 |     | pragma solidity ^0.8.0;
   2 |     | 
   3 |     | interface IUniswapV2Router01 {
   4 |     |     function addLiquidity(
   5 |     |         address tokenA,
   6 |     |         address tokenB,
   7 |     |         uint256 amountADesired,
   8 |     |         uint256 amountBDesired,
   9 |     |         uint256 amountAMin,
  10 |     |         uint256 amountBMin,
  11 |     |         address to,
  12 |     |         uint256 deadline
  13 |     |     ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);
  14 |     | 
  15 |     |     function addLiquidityETH(
  16 |     |         address token,
  17 |     |         uint256 amountTokenDesired,
  18 |     |         uint256 amountTokenMin,
  19 |     |         uint256 amountETHMin,
  20 |     |         address to,
  21 |     |         uint256 deadline
  22 |     |     ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);
  23 |     | 
  24 |     |     function removeLiquidity(
  25 |     |         address tokenA,
  26 |     |         address tokenB,
  27 |     |         uint256 liquidity,
  28 |     |         uint256 amountAMin,
  29 |     |         uint256 amountBMin,
  30 |     |         address to,
  31 |     |         uint256 deadline
  32 |     |     ) external returns (uint256 amountA, uint256 amountB);
  33 |     | 
  34 |     |     function removeLiquidityETH(
  35 |     |         address token,
  36 |     |         uint256 liquidity,
  37 |     |         uint256 amountTokenMin,
  38 |     |         uint256 amountETHMin,
  39 |     |         address to,
  40 |     |         uint256 deadline
  41 |     |     ) external returns (uint256 amountToken, uint256 amountETH);
  42 |     | 
  43 |     |     function removeLiquidityWithPermit(
  44 |     |         address tokenA,
  45 |     |         address tokenB,
  46 |     |         uint256 liquidity,
  47 |     |         uint256 amountAMin,
  48 |     |         uint256 amountBMin,
  49 |     |         address to,
  50 |     |         uint256 deadline,
  51 |     |         bool approveMax,
  52 |     |         uint8 v,
  53 |     |         bytes32 r,
  54 |     |         bytes32 s
  55 |     |     ) external returns (uint256 amountA, uint256 amountB);
  56 |     | 
  57 |     |     function removeLiquidityETHWithPermit(
  58 |     |         address token,
  59 |     |         uint256 liquidity,
  60 |     |         uint256 amountTokenMin,
  61 |     |         uint256 amountETHMin,
  62 |     |         address to,
  63 |     |         uint256 deadline,
  64 |     |         bool approveMax,
  65 |     |         uint8 v,
  66 |     |         bytes32 r,
  67 |     |         bytes32 s
  68 |     |     ) external returns (uint256 amountToken, uint256 amountETH);
  69 |     | 
  70 |     |     function swapExactTokensForTokens(
  71 |     |         uint256 amountIn,
  72 |     |         uint256 amountOutMin,
  73 |     |         address[] calldata path,
  74 |     |         address to,
  75 |     |         uint256 deadline
  76 |     |     ) external returns (uint256[] memory amounts);
  77 |     | 
  78 |     |     function swapTokensForExactTokens(
  79 |     |         uint256 amountOut,
  80 |     |         uint256 amountInMax,
  81 |     |         address[] calldata path,
  82 |     |         address to,
  83 |     |         uint256 deadline
  84 |     |     ) external returns (uint256[] memory amounts);
  85 |     | 
  86 |     |     function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)
  87 |     |         external
  88 |     |         payable
  89 |     |         returns (uint256[] memory amounts);
  90 |     | 
  91 |     |     function swapTokensForExactETH(
  92 |     |         uint256 amountOut,
  93 |     |         uint256 amountInMax,
  94 |     |         address[] calldata path,
  95 |     |         address to,
  96 |     |         uint256 deadline
  97 |     |     ) external returns (uint256[] memory amounts);
  98 |     | 
  99 |     |     function swapExactTokensForETH(
 100 |     |         uint256 amountIn,
 101 |     |         uint256 amountOutMin,
 102 |     |         address[] calldata path,
 103 |     |         address to,
 104 |     |         uint256 deadline
 105 |     |     ) external returns (uint256[] memory amounts);
 106 |     | 
 107 |     |     function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)
 108 |     |         external
 109 |     |         payable
 110 |     |         returns (uint256[] memory amounts);
 111 |     | 
 112 |     |     function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);
 113 |     | 
 114 |     |     function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
 115 |     |         external
 116 |     |         pure
 117 |     |         returns (uint256 amountOut);
 118 |     | 
 119 |     |     function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)
 120 |     |         external
 121 |     |         pure
 122 |     |         returns (uint256 amountIn);
 123 |     | 
 124 |     |     function getAmountsOut(uint256 amountIn, address[] calldata path) external returns (uint256[] memory amounts);
 125 |     | 
 126 |     |     function getAmountsIn(uint256 amountOut, address[] calldata path) external returns (uint256[] memory amounts);
 127 |     | }
 128 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "./IUniswapV2Router01.sol";
  4 |     | 
  5 |     | interface IUniswapV2Router02 is IUniswapV2Router01 {
  6 |     |     function removeLiquidityETHSupportingFeeOnTransferTokens(
  7 |     |         address token,
  8 |     |         uint256 liquidity,
  9 |     |         uint256 amountTokenMin,
 10 |     |         uint256 amountETHMin,
 11 |     |         address to,
 12 |     |         uint256 deadline
 13 |     |     ) external returns (uint256 amountETH);
 14 |     | 
 15 |     |     function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(
 16 |     |         address token,
 17 |     |         uint256 liquidity,
 18 |     |         uint256 amountTokenMin,
 19 |     |         uint256 amountETHMin,
 20 |     |         address to,
 21 |     |         uint256 deadline,
 22 |     |         bool approveMax,
 23 |     |         uint8 v,
 24 |     |         bytes32 r,
 25 |     |         bytes32 s
 26 |     |     ) external returns (uint256 amountETH);
 27 |     | 
 28 |     |     function swapExactTokensForTokensSupportingFeeOnTransferTokens(
 29 |     |         uint256 amountIn,
 30 |     |         uint256 amountOutMin,
 31 |     |         address[] calldata path,
 32 |     |         address to,
 33 |     |         uint256 deadline
 34 |     |     ) external;
 35 |     | 
 36 |     |     function swapExactETHForTokensSupportingFeeOnTransferTokens(
 37 |     |         uint256 amountOutMin,
 38 |     |         address[] calldata path,
 39 |     |         address to,
 40 |     |         uint256 deadline
 41 |     |     ) external payable;
 42 |     | 
 43 |     |     function swapExactTokensForETHSupportingFeeOnTransferTokens(
 44 |     |         uint256 amountIn,
 45 |     |         uint256 amountOutMin,
 46 |     |         address[] calldata path,
 47 |     |         address to,
 48 |     |         uint256 deadline
 49 |     |     ) external;
 50 |     | }
 51 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IWETH.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | interface IWETH {
  4 |     |     function deposit() external payable;
  5 |     | 
  6 |     |     function transfer(address to, uint256 value) external returns (bool);
  7 |     | 
  8 |     |     function withdraw(uint256) external;
  9 |     | }
 10 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/libraries/UniswapV2Library.sol
  1 |     | pragma solidity ^0.8.0;
  2 |     | 
  3 |     | import "v2-core/interfaces/IUniswapV2Pair.sol";
  4 |     | import "v2-core/UniswapV2Pair.sol";
  5 |     | 
  6 |     | library UniswapV2Library {
  7 |     |     using SafeMath for uint256;
  8 |     | 
  9 |     |     // returns sorted token addresses, used to handle return values from pairs sorted in this order
 10 |     |     function sortTokens(address tokenA, address tokenB) internal view returns (address token0, address token1) {
 11 |     |         require(tokenA != tokenB, "UniswapV2Library: IDENTICAL_ADDRESSES");
 12 |     |         (token0, token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 13 |     |         require(token0 != address(0), "UniswapV2Library: ZERO_ADDRESS");
 14 |     |     }
 15 |     | 
 16 |     |     // calculates the CREATE2 address for a pair without making any external calls
 17 |     |     function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {
 18 |     |         (address token0, address token1) = sortTokens(tokenA, tokenB);
 19 |     |         pair = IUniswapV2Factory(factory).getPair(token0, token1);
 20 |     |     }
 21 |     | 
 22 |     |     // fetches and sorts the reserves for a pair
 23 |     |     event Message(string a);
 24 |     | 
 25 |     |     function getReserves(address factory, address tokenA, address tokenB)
 26 |     |         internal
 27 |     |         view
 28 |     |         returns (uint256 reserveA, uint256 reserveB)
 29 |     |     {
 30 |     |         (address token0,) = sortTokens(tokenA, tokenB);
 31 |     |         (uint256 reserve0, uint256 reserve1,) = UniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();
 32 |     |         (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);
 33 |     |     }
 34 |     | 
 35 |     |     // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset
 36 |     |     function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {
 37 |     |         require(amountA > 0, "UniswapV2Library: INSUFFICIENT_AMOUNT");
 38 |     |         require(reserveA > 0 && reserveB > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
 39 |     |         amountB = amountA.mul(reserveB) / reserveA;
 40 |     |     }
 41 |     | 
 42 |     |     // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset
 43 |     |     function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)
 44 |     |         internal
 45 |     |         pure
 46 |     |         returns (uint256 amountOut)
 47 |     |     {
 48 |     |         require(amountIn > 0, "UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT");
 49 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
 50 |     |         uint256 amountInWithFee = amountIn.mul(997);
 51 |     |         uint256 numerator = amountInWithFee.mul(reserveOut);
 52 |     |         uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);
 53 |     |         amountOut = numerator / denominator;
 54 |     |     }
 55 |     | 
 56 |     |     // given an output amount of an asset and pair reserves, returns a required input amount of the other asset
 57 |     |     function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)
 58 |     |         internal
 59 |     |         pure
 60 |     |         returns (uint256 amountIn)
 61 |     |     {
 62 |     |         require(amountOut > 0, "UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT");
 63 |     |         require(reserveIn > 0 && reserveOut > 0, "UniswapV2Library: INSUFFICIENT_LIQUIDITY");
 64 |     |         uint256 numerator = reserveIn.mul(amountOut).mul(1000);
 65 |     |         uint256 denominator = reserveOut.sub(amountOut).mul(997);
 66 |     |         amountIn = (numerator / denominator).add(1);
 67 |     |     }
 68 |     | 
 69 |     |     // performs chained getAmountOut calculations on any number of pairs
 70 |     |     function getAmountsOut(address factory, uint256 amountIn, address[] memory path)
 71 |     |         internal
 72 |     |         returns (uint256[] memory amounts)
 73 |     |     {
 74 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
 75 |     |         amounts = new uint256[](path.length);
 76 |     |         amounts[0] = amountIn;
 77 |     |         for (uint256 i; i < path.length - 1; i++) {
 78 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);
 79 |     |             amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);
 80 |     |         }
 81 |     |     }
 82 |     | 
 83 |     |     // performs chained getAmountIn calculations on any number of pairs
 84 |     |     function getAmountsIn(address factory, uint256 amountOut, address[] memory path)
 85 |     |         internal
 86 |     |         returns (uint256[] memory amounts)
 87 |     |     {
 88 |     |         require(path.length >= 2, "UniswapV2Library: INVALID_PATH");
 89 |     |         amounts = new uint256[](path.length);
 90 |     |         amounts[amounts.length - 1] = amountOut;
 91 |     |         for (uint256 i = path.length - 1; i > 0; i--) {
 92 |     |             (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);
 93 |     |             amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);
 94 |     |         }
 95 |     |     }
 96 |     | }
 97 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/NoDelegateCall.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | /// @title Prevents delegatecall to a contract
  5 |     | /// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract
  6 |     | /// @dev    Changed pragma to >=0.8.12
  7 |     | abstract contract NoDelegateCall {
  8 |     |     /// @dev The original address of this contract
  9 |     |     address private immutable original;
 10 |     | 
 11 |     |     constructor() {
 12 |     |         // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.
 13 |     |         // In other words, this variable won't change when it's checked at runtime.
 14 |     |         original = address(this);
 15 |     |     }
 16 |     | 
 17 |     |     /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,
 18 |     |     ///     and the use of immutable means the address bytes are copied in every place the modifier is used.
 19 |     |     function checkNotDelegateCall() private view {
 20 |     |         require(address(this) == original);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Prevents delegatecall into the modified method
 24 |     |     modifier noDelegateCall() {
 25 |     |         checkNotDelegateCall();
 26 |     |         _;
 27 |     |     }
 28 |     | }
 29 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | import {IUniswapV3Factory} from
  5 |     |     "./interfaces/IUniswapV3Factory.sol";
  6 |     | 
  7 |     | import {UniswapV3PoolDeployer} from "./UniswapV3PoolDeployer.sol";
  8 |     | import {NoDelegateCall} from "./NoDelegateCall.sol";
  9 |     | import {UniswapV3Pool} from "./UniswapV3Pool.sol";
 10 |     | 
 11 |     | /// @title Canonical Uniswap V3 factory
 12 |     | /// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees
 13 |     | /// @dev    Changed pragma to >=0.8.12
 14 |     | contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {
 15 |     |     /// @inheritdoc IUniswapV3Factory
 16 |     |     address public override owner;
 17 |     | 
 18 |     |     /// @inheritdoc IUniswapV3Factory
 19 |     |     mapping(uint24 => int24) public override feeAmountTickSpacing;
 20 |     |     /// @inheritdoc IUniswapV3Factory
 21 |     |     mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;
 22 |     | 
 23 |     |     constructor() {
 24 |     |         owner = msg.sender;
 25 |     |         emit OwnerChanged(address(0), msg.sender);
 26 |     | 
 27 |     |         feeAmountTickSpacing[500] = 10;
 28 |     |         emit FeeAmountEnabled(500, 10);
 29 |     |         feeAmountTickSpacing[3000] = 60;
 30 |     |         emit FeeAmountEnabled(3000, 60);
 31 |     |         feeAmountTickSpacing[10_000] = 200;
 32 |     |         emit FeeAmountEnabled(10_000, 200);
 33 |     |     }
 34 |     | 
 35 |     |     /// @inheritdoc IUniswapV3Factory
 36 |     |     function createPool(
 37 |     |         address tokenA,
 38 |     |         address tokenB,
 39 |     |         uint24 fee
 40 |     |     ) external override noDelegateCall returns (address pool) {
 41 |     |         require(tokenA != tokenB);
 42 |     |         (address token0, address token1) = tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);
 43 |     |         require(token0 != address(0));
 44 |     |         int24 tickSpacing = feeAmountTickSpacing[fee];
 45 |     |         require(tickSpacing != 0);
 46 |     |         require(getPool[token0][token1][fee] == address(0));
 47 |     |         pool = deploy(address(this), token0, token1, fee, tickSpacing);
 48 |     |         getPool[token0][token1][fee] = pool;
 49 |     |         // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses
 50 |     |         getPool[token1][token0][fee] = pool;
 51 |     |         emit PoolCreated(token0, token1, fee, tickSpacing, pool);
 52 |     |     }
 53 |     | 
 54 |     |     /// @inheritdoc IUniswapV3Factory
 55 |     |     function setOwner(address _owner) external override {
 56 |     |         require(msg.sender == owner);
 57 |     |         emit OwnerChanged(owner, _owner);
 58 |     |         owner = _owner;
 59 |     |     }
 60 |     | 
 61 |     |     /// @inheritdoc IUniswapV3Factory
 62 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {
 63 |     |         require(msg.sender == owner);
 64 |     |         require(fee < 1_000_000);
 65 |     |         // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that
 66 |     |         // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick
 67 |     |         // 16384 ticks represents a >5x price change with ticks of 1 bips
 68 |     |         require(tickSpacing > 0 && tickSpacing < 16_384);
 69 |     |         require(feeAmountTickSpacing[fee] == 0);
 70 |     | 
 71 |     |         feeAmountTickSpacing[fee] = tickSpacing;
 72 |     |         emit FeeAmountEnabled(fee, tickSpacing);
 73 |     |     }
 74 |     | }
 75 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3Pool.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity ^0.8.0;
   3 |     | 
   4 |     | import './interfaces/IUniswapV3Pool.sol';
   5 |     | 
   6 |     | import './NoDelegateCall.sol';
   7 |     | 
   8 |     | import './libraries/LowGasSafeMath.sol';
   9 |     | import './libraries/SafeCast.sol';
  10 |     | import './libraries/Tick.sol';
  11 |     | import './libraries/TickBitmap.sol';
  12 |     | import './libraries/Position.sol';
  13 |     | import './libraries/Oracle.sol';
  14 |     | 
  15 |     | import './libraries/FullMath.sol';
  16 |     | import './libraries/FixedPoint128.sol';
  17 |     | import './libraries/TransferHelper.sol';
  18 |     | import './libraries/TickMath.sol';
  19 |     | import './libraries/LiquidityMath.sol';
  20 |     | import './libraries/SqrtPriceMath.sol';
  21 |     | import './libraries/SwapMath.sol';
  22 |     | 
  23 |     | import './interfaces/IUniswapV3PoolDeployer.sol';
  24 |     | import './interfaces/IUniswapV3Factory.sol';
  25 |     | import './interfaces/IERC20Minimal.sol';
  26 |     | import './interfaces/callback/IUniswapV3MintCallback.sol';
  27 |     | import './interfaces/callback/IUniswapV3SwapCallback.sol';
  28 |     | import './interfaces/callback/IUniswapV3FlashCallback.sol';
  29 |     | 
  30 |     | contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {
  31 |     |     using LowGasSafeMath for uint256;
  32 |     |     using LowGasSafeMath for int256;
  33 |     |     using SafeCast for uint256;
  34 |     |     using SafeCast for int256;
  35 |     |     using Tick for mapping(int24 => Tick.Info);
  36 |     |     using TickBitmap for mapping(int16 => uint256);
  37 |     |     using Position for mapping(bytes32 => Position.Info);
  38 |     |     using Position for Position.Info;
  39 |     |     using Oracle for Oracle.Observation[65535];
  40 |     | 
  41 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  42 |     |     address public immutable override factory;
  43 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  44 |     |     address public immutable override token0;
  45 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  46 |     |     address public immutable override token1;
  47 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  48 |     |     uint24 public immutable override fee;
  49 |     | 
  50 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  51 |     |     int24 public immutable override tickSpacing;
  52 |     | 
  53 |     |     /// @inheritdoc IUniswapV3PoolImmutables
  54 |     |     uint128 public immutable override maxLiquidityPerTick;
  55 |     | 
  56 |     |     struct Slot0 {
  57 |     |         // the current price
  58 |     |         uint160 sqrtPriceX96;
  59 |     |         // the current tick
  60 |     |         int24 tick;
  61 |     |         // the most-recently updated index of the observations array
  62 |     |         uint16 observationIndex;
  63 |     |         // the current maximum number of observations that are being stored
  64 |     |         uint16 observationCardinality;
  65 |     |         // the next maximum number of observations to store, triggered in observations.write
  66 |     |         uint16 observationCardinalityNext;
  67 |     |         // the current protocol fee as a percentage of the swap fee taken on withdrawal
  68 |     |         // represented as an integer denominator (1/x)%
  69 |     |         uint8 feeProtocol;
  70 |     |         // whether the pool is locked
  71 |     |         bool unlocked;
  72 |     |     }
  73 |     |     /// @inheritdoc IUniswapV3PoolState
  74 |     |     Slot0 public override slot0;
  75 |     | 
  76 |     |     /// @inheritdoc IUniswapV3PoolState
  77 |     |     uint256 public override feeGrowthGlobal0X128;
  78 |     |     /// @inheritdoc IUniswapV3PoolState
  79 |     |     uint256 public override feeGrowthGlobal1X128;
  80 |     | 
  81 |     |     // accumulated protocol fees in token0/token1 units
  82 |     |     struct ProtocolFees {
  83 |     |         uint128 token0;
  84 |     |         uint128 token1;
  85 |     |     }
  86 |     |     /// @inheritdoc IUniswapV3PoolState
  87 |     |     ProtocolFees public override protocolFees;
  88 |     | 
  89 |     |     /// @inheritdoc IUniswapV3PoolState
  90 |     |     uint128 public override liquidity;
  91 |     | 
  92 |     |     /// @inheritdoc IUniswapV3PoolState
  93 |     |     mapping(int24 => Tick.Info) public override ticks;
  94 |     |     /// @inheritdoc IUniswapV3PoolState
  95 |     |     mapping(int16 => uint256) public override tickBitmap;
  96 |     |     /// @inheritdoc IUniswapV3PoolState
  97 |     |     mapping(bytes32 => Position.Info) public override positions;
  98 |     |     /// @inheritdoc IUniswapV3PoolState
  99 |     |     Oracle.Observation[65535] public override observations;
 100 |     | 
 101 |     |     /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance
 102 |     |     /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because
 103 |     |     /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.
 104 |     |     modifier lock() {
 105 |     |         require(slot0.unlocked, 'LOK');
 106 |     |         slot0.unlocked = false;
 107 |     |         _;
 108 |     |         slot0.unlocked = true;
 109 |     |     }
 110 |     | 
 111 |     |     /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()
 112 |     |     modifier onlyFactoryOwner() {
 113 |     |         require(msg.sender == IUniswapV3Factory(factory).owner());
 114 |     |         _;
 115 |     |     }
 116 |     | 
 117 |     |     constructor() {
 118 |     |         int24 _tickSpacing;
 119 |     |         (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();
 120 |     |         tickSpacing = _tickSpacing;
 121 |     | 
 122 |     |         maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);
 123 |     |     }
 124 |     | 
 125 |     |     /// @dev Common checks for valid tick inputs.
 126 |     |     function checkTicks(int24 tickLower, int24 tickUpper) private pure {
 127 |     |         require(tickLower < tickUpper, 'TLU');
 128 |     |         require(tickLower >= TickMath.MIN_TICK, 'TLM');
 129 |     |         require(tickUpper <= TickMath.MAX_TICK, 'TUM');
 130 |     |     }
 131 |     | 
 132 |     |     /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.
 133 |     |     function _blockTimestamp() internal view virtual returns (uint32) {
 134 |     |         return uint32(block.timestamp); // truncation is desired
 135 |     |     }
 136 |     | 
 137 |     |     /// @dev Get the pool's balance of token0
 138 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 139 |     |     /// check
 140 |     |     function balance0() private view returns (uint256) {
 141 |     |         (bool success, bytes memory data) =
 142 |     |             token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));
 143 |     |         require(success && data.length >= 32);
 144 |     |         return abi.decode(data, (uint256));
 145 |     |     }
 146 |     | 
 147 |     |     /// @dev Get the pool's balance of token1
 148 |     |     /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize
 149 |     |     /// check
 150 |     |     function balance1() private view returns (uint256) {
 151 |     |         (bool success, bytes memory data) =
 152 |     |             token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));
 153 |     |         require(success && data.length >= 32);
 154 |     |         return abi.decode(data, (uint256));
 155 |     |     }
 156 |     | 
 157 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 158 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 159 |     |         external
 160 |     |         view
 161 |     |         override
 162 |     |         noDelegateCall
 163 |     |         returns (
 164 |     |             int56 tickCumulativeInside,
 165 |     |             uint160 secondsPerLiquidityInsideX128,
 166 |     |             uint32 secondsInside
 167 |     |         )
 168 |     |     {
 169 |     |         checkTicks(tickLower, tickUpper);
 170 |     | 
 171 |     |         int56 tickCumulativeLower;
 172 |     |         int56 tickCumulativeUpper;
 173 |     |         uint160 secondsPerLiquidityOutsideLowerX128;
 174 |     |         uint160 secondsPerLiquidityOutsideUpperX128;
 175 |     |         uint32 secondsOutsideLower;
 176 |     |         uint32 secondsOutsideUpper;
 177 |     | 
 178 |     |         {
 179 |     |             Tick.Info storage lower = ticks[tickLower];
 180 |     |             Tick.Info storage upper = ticks[tickUpper];
 181 |     |             bool initializedLower;
 182 |     |             (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (
 183 |     |                 lower.tickCumulativeOutside,
 184 |     |                 lower.secondsPerLiquidityOutsideX128,
 185 |     |                 lower.secondsOutside,
 186 |     |                 lower.initialized
 187 |     |             );
 188 |     |             require(initializedLower);
 189 |     | 
 190 |     |             bool initializedUpper;
 191 |     |             (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (
 192 |     |                 upper.tickCumulativeOutside,
 193 |     |                 upper.secondsPerLiquidityOutsideX128,
 194 |     |                 upper.secondsOutside,
 195 |     |                 upper.initialized
 196 |     |             );
 197 |     |             require(initializedUpper);
 198 |     |         }
 199 |     | 
 200 |     |         Slot0 memory _slot0 = slot0;
 201 |     | 
 202 |     |         if (_slot0.tick < tickLower) {
 203 |     |             return (
 204 |     |                 tickCumulativeLower - tickCumulativeUpper,
 205 |     |                 secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,
 206 |     |                 secondsOutsideLower - secondsOutsideUpper
 207 |     |             );
 208 |     |         } else if (_slot0.tick < tickUpper) {
 209 |     |             uint32 time = _blockTimestamp();
 210 |     |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =
 211 |     |                 observations.observeSingle(
 212 |     |                     time,
 213 |     |                     0,
 214 |     |                     _slot0.tick,
 215 |     |                     _slot0.observationIndex,
 216 |     |                     liquidity,
 217 |     |                     _slot0.observationCardinality
 218 |     |                 );
 219 |     |             return (
 220 |     |                 tickCumulative - tickCumulativeLower - tickCumulativeUpper,
 221 |     |                 secondsPerLiquidityCumulativeX128 -
 222 |     |                     secondsPerLiquidityOutsideLowerX128 -
 223 |     |                     secondsPerLiquidityOutsideUpperX128,
 224 |     |                 time - secondsOutsideLower - secondsOutsideUpper
 225 |     |             );
 226 |     |         } else {
 227 |     |             return (
 228 |     |                 tickCumulativeUpper - tickCumulativeLower,
 229 |     |                 secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,
 230 |     |                 secondsOutsideUpper - secondsOutsideLower
 231 |     |             );
 232 |     |         }
 233 |     |     }
 234 |     | 
 235 |     |     /// @inheritdoc IUniswapV3PoolDerivedState
 236 |     |     function observe(uint32[] calldata secondsAgos)
 237 |     |         external
 238 |     |         view
 239 |     |         override
 240 |     |         noDelegateCall
 241 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)
 242 |     |     {
 243 |     |         return
 244 |     |             observations.observe(
 245 |     |                 _blockTimestamp(),
 246 |     |                 secondsAgos,
 247 |     |                 slot0.tick,
 248 |     |                 slot0.observationIndex,
 249 |     |                 liquidity,
 250 |     |                 slot0.observationCardinality
 251 |     |             );
 252 |     |     }
 253 |     | 
 254 |     |     /// @inheritdoc IUniswapV3PoolActions
 255 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext)
 256 |     |         external
 257 |     |         override
 258 |     |         lock
 259 |     |         noDelegateCall
 260 |     |     {
 261 |     |         uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event
 262 |     |         uint16 observationCardinalityNextNew =
 263 |     |             observations.grow(observationCardinalityNextOld, observationCardinalityNext);
 264 |     |         slot0.observationCardinalityNext = observationCardinalityNextNew;
 265 |     |         if (observationCardinalityNextOld != observationCardinalityNextNew)
 266 |     |             emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);
 267 |     |     }
 268 |     | 
 269 |     |     /// @inheritdoc IUniswapV3PoolActions
 270 |     |     /// @dev not locked because it initializes unlocked
 271 |     |     function initialize(uint160 sqrtPriceX96) external override {
 272 |     |         require(slot0.sqrtPriceX96 == 0, 'AI');
 273 |     | 
 274 |     |         int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);
 275 |     | 
 276 |     |         (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());
 277 |     | 
 278 |     |         slot0 = Slot0({
 279 |     |             sqrtPriceX96: sqrtPriceX96,
 280 |     |             tick: tick,
 281 |     |             observationIndex: 0,
 282 |     |             observationCardinality: cardinality,
 283 |     |             observationCardinalityNext: cardinalityNext,
 284 |     |             feeProtocol: 0,
 285 |     |             unlocked: true
 286 |     |         });
 287 |     | 
 288 |     |         emit Initialize(sqrtPriceX96, tick);
 289 |     |     }
 290 |     | 
 291 |     |     struct ModifyPositionParams {
 292 |     |         // the address that owns the position
 293 |     |         address owner;
 294 |     |         // the lower and upper tick of the position
 295 |     |         int24 tickLower;
 296 |     |         int24 tickUpper;
 297 |     |         // any change in liquidity
 298 |     |         int128 liquidityDelta;
 299 |     |     }
 300 |     | 
 301 |     |     event Message(string a);
 302 |     |     event MessageUint160(string a, uint160 b);
 303 |     |     event MessageUint128(string a, int128 b);
 304 |     | 
 305 |     |     /// @dev Effect some changes to a position
 306 |     |     /// @param params the position details and the change to the position's liquidity to effect
 307 |     |     /// @return position a storage pointer referencing the position with the given owner and tick range
 308 |     |     /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient
 309 |     |     /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient
 310 |     |     function _modifyPosition(ModifyPositionParams memory params)
 311 |     |         private
 312 |     |         noDelegateCall
 313 |     |         returns (
 314 |     |             Position.Info storage position,
 315 |     |             int256 amount0,
 316 |     |             int256 amount1
 317 |     |         )
 318 |     |     {
 319 |     |         checkTicks(params.tickLower, params.tickUpper);
 320 |     | 
 321 |     |         Slot0 memory _slot0 = slot0; // SLOAD for gas optimization
 322 |     | 
 323 |     |         emit Message("HERE");
 324 |     |         position = _updatePosition(
 325 |     |             params.owner,
 326 |     |             params.tickLower,
 327 |     |             params.tickUpper,
 328 |     |             params.liquidityDelta,
 329 |     |             _slot0.tick
 330 |     |         );
 331 |     |         emit Message("HERE1");
 332 |     |         if (params.liquidityDelta != 0) {
 333 |     |             if (_slot0.tick < params.tickLower) {
 334 |     |                 // current tick is below the passed range; liquidity can only become in range by crossing from left to
 335 |     |                 // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it
 336 |     |                 emit Message("HERE2");
 337 |     |                 amount0 = SqrtPriceMath.getAmount0Delta(
 338 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 339 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 340 |     |                     params.liquidityDelta
 341 |     |                 );
 342 |     |                 emit Message("HERE3");
 343 |     |             } else if (_slot0.tick < params.tickUpper) {
 344 |     |                 emit Message("HERE4");
 345 |     |                 // current tick is inside the passed range
 346 |     |                 uint128 liquidityBefore = liquidity; // SLOAD for gas optimization
 347 |     | 
 348 |     |                 // write an oracle entry
 349 |     |                 (slot0.observationIndex, slot0.observationCardinality) = observations.write(
 350 |     |                     _slot0.observationIndex,
 351 |     |                     _blockTimestamp(),
 352 |     |                     _slot0.tick,
 353 |     |                     liquidityBefore,
 354 |     |                     _slot0.observationCardinality,
 355 |     |                     _slot0.observationCardinalityNext
 356 |     |                 );
 357 |     |                 emit Message("HERE4a");
 358 |     |                 emit MessageUint160("sqrtA", _slot0.sqrtPriceX96);
 359 |     |                 emit MessageUint160("sqrtB", TickMath.getSqrtRatioAtTick(params.tickUpper));
 360 |     |                 emit MessageUint128("liquidity", params.liquidityDelta);
 361 |     |                 amount0 = SqrtPriceMath.getAmount0Delta(
 362 |     |                     _slot0.sqrtPriceX96,
 363 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 364 |     |                     params.liquidityDelta
 365 |     |                 );
 366 |     |                 emit Message("HERE4b");
 367 |     |                 amount1 = SqrtPriceMath.getAmount1Delta(
 368 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 369 |     |                     _slot0.sqrtPriceX96,
 370 |     |                     params.liquidityDelta
 371 |     |                 );
 372 |     |                 emit Message("HERE4c");
 373 |     | 
 374 |     |                 liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);
 375 |     |                 emit Message("HERE5");
 376 |     |             } else {
 377 |     |                 // current tick is above the passed range; liquidity can only become in range by crossing from right to
 378 |     |                 // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it
 379 |     |                 emit Message("HERE6");
 380 |     |                 amount1 = SqrtPriceMath.getAmount1Delta(
 381 |     |                     TickMath.getSqrtRatioAtTick(params.tickLower),
 382 |     |                     TickMath.getSqrtRatioAtTick(params.tickUpper),
 383 |     |                     params.liquidityDelta
 384 |     |                 );
 385 |     |                 emit Message("HERE7");
 386 |     |             }
 387 |     |         }
 388 |     |         emit Message("HERE8");
 389 |     |     }
 390 |     | 
 391 |     |     /// @dev Gets and updates a position with the given liquidity delta
 392 |     |     /// @param owner the owner of the position
 393 |     |     /// @param tickLower the lower tick of the position's tick range
 394 |     |     /// @param tickUpper the upper tick of the position's tick range
 395 |     |     /// @param tick the current tick, passed to avoid sloads
 396 |     |     function _updatePosition(
 397 |     |         address owner,
 398 |     |         int24 tickLower,
 399 |     |         int24 tickUpper,
 400 |     |         int128 liquidityDelta,
 401 |     |         int24 tick
 402 |     |     ) private returns (Position.Info storage position) {
 403 |     |         position = positions.get(owner, tickLower, tickUpper);
 404 |     | 
 405 |     |         uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization
 406 |     |         uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization
 407 |     | 
 408 |     |         // if we need to update the ticks, do it
 409 |     |         bool flippedLower;
 410 |     |         bool flippedUpper;
 411 |     |         if (liquidityDelta != 0) {
 412 |     |             uint32 time = _blockTimestamp();
 413 |     |             (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =
 414 |     |                 observations.observeSingle(
 415 |     |                     time,
 416 |     |                     0,
 417 |     |                     slot0.tick,
 418 |     |                     slot0.observationIndex,
 419 |     |                     liquidity,
 420 |     |                     slot0.observationCardinality
 421 |     |                 );
 422 |     | 
 423 |     |             flippedLower = ticks.update(
 424 |     |                 tickLower,
 425 |     |                 tick,
 426 |     |                 liquidityDelta,
 427 |     |                 _feeGrowthGlobal0X128,
 428 |     |                 _feeGrowthGlobal1X128,
 429 |     |                 secondsPerLiquidityCumulativeX128,
 430 |     |                 tickCumulative,
 431 |     |                 time,
 432 |     |                 false,
 433 |     |                 maxLiquidityPerTick
 434 |     |             );
 435 |     |             flippedUpper = ticks.update(
 436 |     |                 tickUpper,
 437 |     |                 tick,
 438 |     |                 liquidityDelta,
 439 |     |                 _feeGrowthGlobal0X128,
 440 |     |                 _feeGrowthGlobal1X128,
 441 |     |                 secondsPerLiquidityCumulativeX128,
 442 |     |                 tickCumulative,
 443 |     |                 time,
 444 |     |                 true,
 445 |     |                 maxLiquidityPerTick
 446 |     |             );
 447 |     | 
 448 |     |             if (flippedLower) {
 449 |     |                 tickBitmap.flipTick(tickLower, tickSpacing);
 450 |     |             }
 451 |     |             if (flippedUpper) {
 452 |     |                 tickBitmap.flipTick(tickUpper, tickSpacing);
 453 |     |             }
 454 |     |         }
 455 |     | 
 456 |     |         (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =
 457 |     |             ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);
 458 |     | 
 459 |     |         position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);
 460 |     | 
 461 |     |         // clear any tick data that is no longer needed
 462 |     |         if (liquidityDelta < 0) {
 463 |     |             if (flippedLower) {
 464 |     |                 ticks.clear(tickLower);
 465 |     |             }
 466 |     |             if (flippedUpper) {
 467 |     |                 ticks.clear(tickUpper);
 468 |     |             }
 469 |     |         }
 470 |     |     }
 471 |     |     event MessageAddress(string a, address b);
 472 |     |     /// @inheritdoc IUniswapV3PoolActions
 473 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 474 |     |     function mint(
 475 |     |         address recipient,
 476 |     |         int24 tickLower,
 477 |     |         int24 tickUpper,
 478 |     |         uint128 amount,
 479 |     |         bytes calldata data
 480 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 481 |     |         require(amount > 0);
 482 |     |         (, int256 amount0Int, int256 amount1Int) =
 483 |     |             _modifyPosition(
 484 |     |                 ModifyPositionParams({
 485 |     |                     owner: recipient,
 486 |     |                     tickLower: tickLower,
 487 |     |                     tickUpper: tickUpper,
 488 |     |                     liquidityDelta: int256(int128(amount)).toInt128()
 489 |     |                 })
 490 |     |             );
 491 |     | 
 492 |     |         amount0 = uint256(amount0Int);
 493 |     |         amount1 = uint256(amount1Int);
 494 |     | 
 495 |     |         uint256 balance0Before;
 496 |     |         uint256 balance1Before;
 497 |     |         if (amount0 > 0) balance0Before = balance0();
 498 |     |         if (amount1 > 0) balance1Before = balance1();
 499 |     |         emit Message("BEFORE MINT");
 500 |     |         emit MessageAddress("msg.sender", msg.sender);
 501 |     |         IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);
 502 |     |         if (amount0 > 0) require(balance0Before.add(amount0) <= balance0(), 'M0');
 503 |     |         if (amount1 > 0) require(balance1Before.add(amount1) <= balance1(), 'M1');
 504 |     | 
 505 |     |         emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);
 506 |     |     }
 507 |     | 
 508 |     |     /// @inheritdoc IUniswapV3PoolActions
 509 |     |     function collect(
 510 |     |         address recipient,
 511 |     |         int24 tickLower,
 512 |     |         int24 tickUpper,
 513 |     |         uint128 amount0Requested,
 514 |     |         uint128 amount1Requested
 515 |     |     ) external override lock returns (uint128 amount0, uint128 amount1) {
 516 |     |         // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}
 517 |     |         Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);
 518 |     | 
 519 |     |         amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;
 520 |     |         amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;
 521 |     | 
 522 |     |         if (amount0 > 0) {
 523 |     |             position.tokensOwed0 -= amount0;
 524 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 525 |     |         }
 526 |     |         if (amount1 > 0) {
 527 |     |             position.tokensOwed1 -= amount1;
 528 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 529 |     |         }
 530 |     | 
 531 |     |         emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);
 532 |     |     }
 533 |     | 
 534 |     |     /// @inheritdoc IUniswapV3PoolActions
 535 |     |     /// @dev noDelegateCall is applied indirectly via _modifyPosition
 536 |     |     function burn(
 537 |     |         int24 tickLower,
 538 |     |         int24 tickUpper,
 539 |     |         uint128 amount
 540 |     |     ) external override lock returns (uint256 amount0, uint256 amount1) {
 541 |     |         (Position.Info storage position, int256 amount0Int, int256 amount1Int) =
 542 |     |             _modifyPosition(
 543 |     |                 ModifyPositionParams({
 544 |     |                     owner: msg.sender,
 545 |     |                     tickLower: tickLower,
 546 |     |                     tickUpper: tickUpper,
 547 |     |                     liquidityDelta: -int256(int128(amount)).toInt128()
 548 |     |                 })
 549 |     |             );
 550 |     | 
 551 |     |         amount0 = uint256(-amount0Int);
 552 |     |         amount1 = uint256(-amount1Int);
 553 |     | 
 554 |     |         if (amount0 > 0 || amount1 > 0) {
 555 |     |             (position.tokensOwed0, position.tokensOwed1) = (
 556 |     |                 position.tokensOwed0 + uint128(amount0),
 557 |     |                 position.tokensOwed1 + uint128(amount1)
 558 |     |             );
 559 |     |         }
 560 |     | 
 561 |     |         emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);
 562 |     |     }
 563 |     | 
 564 |     |     struct SwapCache {
 565 |     |         // the protocol fee for the input token
 566 |     |         uint8 feeProtocol;
 567 |     |         // liquidity at the beginning of the swap
 568 |     |         uint128 liquidityStart;
 569 |     |         // the timestamp of the current block
 570 |     |         uint32 blockTimestamp;
 571 |     |         // the current value of the tick accumulator, computed only if we cross an initialized tick
 572 |     |         int56 tickCumulative;
 573 |     |         // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick
 574 |     |         uint160 secondsPerLiquidityCumulativeX128;
 575 |     |         // whether we've computed and cached the above two accumulators
 576 |     |         bool computedLatestObservation;
 577 |     |     }
 578 |     | 
 579 |     |     // the top level state of the swap, the results of which are recorded in storage at the end
 580 |     |     struct SwapState {
 581 |     |         // the amount remaining to be swapped in/out of the input/output asset
 582 |     |         int256 amountSpecifiedRemaining;
 583 |     |         // the amount already swapped out/in of the output/input asset
 584 |     |         int256 amountCalculated;
 585 |     |         // current sqrt(price)
 586 |     |         uint160 sqrtPriceX96;
 587 |     |         // the tick associated with the current price
 588 |     |         int24 tick;
 589 |     |         // the global fee growth of the input token
 590 |     |         uint256 feeGrowthGlobalX128;
 591 |     |         // amount of input token paid as protocol fee
 592 |     |         uint128 protocolFee;
 593 |     |         // the current liquidity in range
 594 |     |         uint128 liquidity;
 595 |     |     }
 596 |     | 
 597 |     |     struct StepComputations {
 598 |     |         // the price at the beginning of the step
 599 |     |         uint160 sqrtPriceStartX96;
 600 |     |         // the next tick to swap to from the current tick in the swap direction
 601 |     |         int24 tickNext;
 602 |     |         // whether tickNext is initialized or not
 603 |     |         bool initialized;
 604 |     |         // sqrt(price) for the next tick (1/0)
 605 |     |         uint160 sqrtPriceNextX96;
 606 |     |         // how much is being swapped in in this step
 607 |     |         uint256 amountIn;
 608 |     |         // how much is being swapped out
 609 |     |         uint256 amountOut;
 610 |     |         // how much fee is being paid in
 611 |     |         uint256 feeAmount;
 612 |     |     }
 613 |     | 
 614 |     |     /// @inheritdoc IUniswapV3PoolActions
 615 |     |     function swap(
 616 |     |         address recipient,
 617 |     |         bool zeroForOne,
 618 |     |         int256 amountSpecified,
 619 |     |         uint160 sqrtPriceLimitX96,
 620 |     |         bytes calldata data
 621 |     |     ) external override noDelegateCall returns (int256 amount0, int256 amount1) {
 622 |     |         require(amountSpecified != 0, 'AS');
 623 |     | 
 624 |     |         Slot0 memory slot0Start = slot0;
 625 |     | 
 626 |     |         require(slot0Start.unlocked, 'LOK');
 627 |     |         require(
 628 |     |             zeroForOne
 629 |     |                 ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO
 630 |     |                 : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,
 631 |     |             'SPL'
 632 |     |         );
 633 |     | 
 634 |     |         slot0.unlocked = false;
 635 |     | 
 636 |     |         SwapCache memory cache =
 637 |     |             SwapCache({
 638 |     |                 liquidityStart: liquidity,
 639 |     |                 blockTimestamp: _blockTimestamp(),
 640 |     |                 feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),
 641 |     |                 secondsPerLiquidityCumulativeX128: 0,
 642 |     |                 tickCumulative: 0,
 643 |     |                 computedLatestObservation: false
 644 |     |             });
 645 |     | 
 646 |     |         bool exactInput = amountSpecified > 0;
 647 |     | 
 648 |     |         SwapState memory state =
 649 |     |             SwapState({
 650 |     |                 amountSpecifiedRemaining: amountSpecified,
 651 |     |                 amountCalculated: 0,
 652 |     |                 sqrtPriceX96: slot0Start.sqrtPriceX96,
 653 |     |                 tick: slot0Start.tick,
 654 |     |                 feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,
 655 |     |                 protocolFee: 0,
 656 |     |                 liquidity: cache.liquidityStart
 657 |     |             });
 658 |     | 
 659 |     |         // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit
 660 |     |         while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {
 661 |     |             StepComputations memory step;
 662 |     | 
 663 |     |             step.sqrtPriceStartX96 = state.sqrtPriceX96;
 664 |     | 
 665 |     |             (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(
 666 |     |                 state.tick,
 667 |     |                 tickSpacing,
 668 |     |                 zeroForOne
 669 |     |             );
 670 |     | 
 671 |     |             // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds
 672 |     |             if (step.tickNext < TickMath.MIN_TICK) {
 673 |     |                 step.tickNext = TickMath.MIN_TICK;
 674 |     |             } else if (step.tickNext > TickMath.MAX_TICK) {
 675 |     |                 step.tickNext = TickMath.MAX_TICK;
 676 |     |             }
 677 |     | 
 678 |     |             // get the price for the next tick
 679 |     |             step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);
 680 |     | 
 681 |     |             // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted
 682 |     |             (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(
 683 |     |                 state.sqrtPriceX96,
 684 |     |                 (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)
 685 |     |                     ? sqrtPriceLimitX96
 686 |     |                     : step.sqrtPriceNextX96,
 687 |     |                 state.liquidity,
 688 |     |                 state.amountSpecifiedRemaining,
 689 |     |                 fee
 690 |     |             );
 691 |     | 
 692 |     |             if (exactInput) {
 693 |     |                 state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();
 694 |     |                 state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());
 695 |     |             } else {
 696 |     |                 state.amountSpecifiedRemaining += step.amountOut.toInt256();
 697 |     |                 state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());
 698 |     |             }
 699 |     | 
 700 |     |             // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee
 701 |     |             if (cache.feeProtocol > 0) {
 702 |     |                 uint256 delta = step.feeAmount / cache.feeProtocol;
 703 |     |                 step.feeAmount -= delta;
 704 |     |                 state.protocolFee += uint128(delta);
 705 |     |             }
 706 |     | 
 707 |     |             // update global fee tracker
 708 |     |             if (state.liquidity > 0)
 709 |     |                 state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);
 710 |     | 
 711 |     |             // shift tick if we reached the next price
 712 |     |             if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {
 713 |     |                 // if the tick is initialized, run the tick transition
 714 |     |                 if (step.initialized) {
 715 |     |                     // check for the placeholder value, which we replace with the actual value the first time the swap
 716 |     |                     // crosses an initialized tick
 717 |     |                     if (!cache.computedLatestObservation) {
 718 |     |                         (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(
 719 |     |                             cache.blockTimestamp,
 720 |     |                             0,
 721 |     |                             slot0Start.tick,
 722 |     |                             slot0Start.observationIndex,
 723 |     |                             cache.liquidityStart,
 724 |     |                             slot0Start.observationCardinality
 725 |     |                         );
 726 |     |                         cache.computedLatestObservation = true;
 727 |     |                     }
 728 |     |                     int128 liquidityNet =
 729 |     |                         ticks.cross(
 730 |     |                             step.tickNext,
 731 |     |                             (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),
 732 |     |                             (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),
 733 |     |                             cache.secondsPerLiquidityCumulativeX128,
 734 |     |                             cache.tickCumulative,
 735 |     |                             cache.blockTimestamp
 736 |     |                         );
 737 |     |                     // if we're moving leftward, we interpret liquidityNet as the opposite sign
 738 |     |                     // safe because liquidityNet cannot be type(int128).min
 739 |     |                     if (zeroForOne) liquidityNet = -liquidityNet;
 740 |     | 
 741 |     |                     state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);
 742 |     |                 }
 743 |     | 
 744 |     |                 state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;
 745 |     |             } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {
 746 |     |                 // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved
 747 |     |                 state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);
 748 |     |             }
 749 |     |         }
 750 |     | 
 751 |     |         // update tick and write an oracle entry if the tick change
 752 |     |         if (state.tick != slot0Start.tick) {
 753 |     |             (uint16 observationIndex, uint16 observationCardinality) =
 754 |     |                 observations.write(
 755 |     |                     slot0Start.observationIndex,
 756 |     |                     cache.blockTimestamp,
 757 |     |                     slot0Start.tick,
 758 |     |                     cache.liquidityStart,
 759 |     |                     slot0Start.observationCardinality,
 760 |     |                     slot0Start.observationCardinalityNext
 761 |     |                 );
 762 |     |             (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (
 763 |     |                 state.sqrtPriceX96,
 764 |     |                 state.tick,
 765 |     |                 observationIndex,
 766 |     |                 observationCardinality
 767 |     |             );
 768 |     |         } else {
 769 |     |             // otherwise just update the price
 770 |     |             slot0.sqrtPriceX96 = state.sqrtPriceX96;
 771 |     |         }
 772 |     | 
 773 |     |         // update liquidity if it changed
 774 |     |         if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;
 775 |     | 
 776 |     |         // update fee growth global and, if necessary, protocol fees
 777 |     |         // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees
 778 |     |         if (zeroForOne) {
 779 |     |             feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;
 780 |     |             if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;
 781 |     |         } else {
 782 |     |             feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;
 783 |     |             if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;
 784 |     |         }
 785 |     | 
 786 |     |         (amount0, amount1) = zeroForOne == exactInput
 787 |     |             ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)
 788 |     |             : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);
 789 |     | 
 790 |     |         // do the transfers and collect payment
 791 |     |         if (zeroForOne) {
 792 |     |             if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));
 793 |     | 
 794 |     |             uint256 balance0Before = balance0();
 795 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 796 |     |             require(balance0Before.add(uint256(amount0)) <= balance0(), 'IIA');
 797 |     |         } else {
 798 |     |             if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));
 799 |     | 
 800 |     |             uint256 balance1Before = balance1();
 801 |     |             IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);
 802 |     |             require(balance1Before.add(uint256(amount1)) <= balance1(), 'IIA');
 803 |     |         }
 804 |     | 
 805 |     |         emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);
 806 |     |         slot0.unlocked = true;
 807 |     |     }
 808 |     | 
 809 |     |     /// @inheritdoc IUniswapV3PoolActions
 810 |     |     function flash(
 811 |     |         address recipient,
 812 |     |         uint256 amount0,
 813 |     |         uint256 amount1,
 814 |     |         bytes calldata data
 815 |     |     ) external override lock noDelegateCall {
 816 |     |         uint128 _liquidity = liquidity;
 817 |     |         require(_liquidity > 0, 'L');
 818 |     | 
 819 |     |         uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);
 820 |     |         uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);
 821 |     |         uint256 balance0Before = balance0();
 822 |     |         uint256 balance1Before = balance1();
 823 |     | 
 824 |     |         if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);
 825 |     |         if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);
 826 |     | 
 827 |     |         IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);
 828 |     | 
 829 |     |         uint256 balance0After = balance0();
 830 |     |         uint256 balance1After = balance1();
 831 |     | 
 832 |     |         require(balance0Before.add(fee0) <= balance0After, 'F0');
 833 |     |         require(balance1Before.add(fee1) <= balance1After, 'F1');
 834 |     | 
 835 |     |         // sub is safe because we know balanceAfter is gt balanceBefore by at least fee
 836 |     |         uint256 paid0 = balance0After - balance0Before;
 837 |     |         uint256 paid1 = balance1After - balance1Before;
 838 |     | 
 839 |     |         if (paid0 > 0) {
 840 |     |             uint8 feeProtocol0 = slot0.feeProtocol % 16;
 841 |     |             uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;
 842 |     |             if (uint128(fees0) > 0) protocolFees.token0 += uint128(fees0);
 843 |     |             feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);
 844 |     |         }
 845 |     |         if (paid1 > 0) {
 846 |     |             uint8 feeProtocol1 = slot0.feeProtocol >> 4;
 847 |     |             uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;
 848 |     |             if (uint128(fees1) > 0) protocolFees.token1 += uint128(fees1);
 849 |     |             feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);
 850 |     |         }
 851 |     | 
 852 |     |         emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);
 853 |     |     }
 854 |     | 
 855 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 856 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {
 857 |     |         require(
 858 |     |             (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&
 859 |     |                 (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))
 860 |     |         );
 861 |     |         uint8 feeProtocolOld = slot0.feeProtocol;
 862 |     |         slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);
 863 |     |         emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);
 864 |     |     }
 865 |     | 
 866 |     |     /// @inheritdoc IUniswapV3PoolOwnerActions
 867 |     |     function collectProtocol(
 868 |     |         address recipient,
 869 |     |         uint128 amount0Requested,
 870 |     |         uint128 amount1Requested
 871 |     |     ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {
 872 |     |         amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;
 873 |     |         amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;
 874 |     | 
 875 |     |         if (amount0 > 0) {
 876 |     |             if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings
 877 |     |             protocolFees.token0 -= amount0;
 878 |     |             TransferHelper.safeTransfer(token0, recipient, amount0);
 879 |     |         }
 880 |     |         if (amount1 > 0) {
 881 |     |             if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings
 882 |     |             protocolFees.token1 -= amount1;
 883 |     |             TransferHelper.safeTransfer(token1, recipient, amount1);
 884 |     |         }
 885 |     | 
 886 |     |         emit CollectProtocol(msg.sender, recipient, amount0, amount1);
 887 |     |     }
 888 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.12;
  3 |     | 
  4 |     | import {IUniswapV3PoolDeployer} from
  5 |     |     "./interfaces/IUniswapV3PoolDeployer.sol";
  6 |     | 
  7 |     | import {UniswapV3Pool} from "./UniswapV3Pool.sol";
  8 |     | 
  9 |     | /// @dev    Changed pragma to >=0.8.12
 10 |     | contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {
 11 |     |     struct Parameters {
 12 |     |         address factory;
 13 |     |         address token0;
 14 |     |         address token1;
 15 |     |         uint24 fee;
 16 |     |         int24 tickSpacing;
 17 |     |     }
 18 |     | 
 19 |     |     /// @inheritdoc IUniswapV3PoolDeployer
 20 |     |     Parameters public override parameters;
 21 |     | 
 22 |     |     /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then
 23 |     |     /// clearing it after deploying the pool.
 24 |     |     /// @param factory The contract address of the Uniswap V3 factory
 25 |     |     /// @param token0 The first token of the pool by address sort order
 26 |     |     /// @param token1 The second token of the pool by address sort order
 27 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The spacing between usable ticks
 29 |     |     function deploy(
 30 |     |         address factory,
 31 |     |         address token0,
 32 |     |         address token1,
 33 |     |         uint24 fee,
 34 |     |         int24 tickSpacing
 35 |     |     ) internal returns (address pool) {
 36 |     |         parameters = Parameters({
 37 |     |             factory: factory,
 38 |     |             token0: token0,
 39 |     |             token1: token1,
 40 |     |             fee: fee,
 41 |     |             tickSpacing: tickSpacing
 42 |     |         });
 43 |     |         pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());
 44 |     |         delete parameters;
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IERC20Minimal.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Minimal ERC20 interface for Uniswap
  5 |     | /// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3
  6 |     | interface IERC20Minimal {
  7 |     |     /// @notice Returns the balance of a token
  8 |     |     /// @param account The account for which to look up the number of tokens it has, i.e. its balance
  9 |     |     /// @return The number of tokens held by the account
 10 |     |     function balanceOf(address account) external view returns (uint256);
 11 |     | 
 12 |     |     /// @notice Transfers the amount of token from the `msg.sender` to the recipient
 13 |     |     /// @param recipient The account that will receive the amount transferred
 14 |     |     /// @param amount The number of tokens to send from the sender to the recipient
 15 |     |     /// @return Returns true for a successful transfer, false for an unsuccessful transfer
 16 |     |     function transfer(address recipient, uint256 amount) external returns (bool);
 17 |     | 
 18 |     |     /// @notice Returns the current allowance given to a spender by an owner
 19 |     |     /// @param owner The account of the token owner
 20 |     |     /// @param spender The account of the token spender
 21 |     |     /// @return The current allowance granted by `owner` to `spender`
 22 |     |     function allowance(address owner, address spender) external view returns (uint256);
 23 |     | 
 24 |     |     /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`
 25 |     |     /// @param spender The account which will be allowed to spend a given amount of the owners tokens
 26 |     |     /// @param amount The amount of tokens allowed to be used by `spender`
 27 |     |     /// @return Returns true for a successful approval, false for unsuccessful
 28 |     |     function approve(address spender, uint256 amount) external returns (bool);
 29 |     | 
 30 |     |     /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`
 31 |     |     /// @param sender The account from which the transfer will be initiated
 32 |     |     /// @param recipient The recipient of the transfer
 33 |     |     /// @param amount The amount of the transfer
 34 |     |     /// @return Returns true for a successful transfer, false for unsuccessful
 35 |     |     function transferFrom(
 36 |     |         address sender,
 37 |     |         address recipient,
 38 |     |         uint256 amount
 39 |     |     ) external returns (bool);
 40 |     | 
 41 |     |     /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.
 42 |     |     /// @param from The account from which the tokens were sent, i.e. the balance decreased
 43 |     |     /// @param to The account to which the tokens were sent, i.e. the balance increased
 44 |     |     /// @param value The amount of tokens that were transferred
 45 |     |     event Transfer(address indexed from, address indexed to, uint256 value);
 46 |     | 
 47 |     |     /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.
 48 |     |     /// @param owner The account that approved spending of its tokens
 49 |     |     /// @param spender The account for which the spending allowance was modified
 50 |     |     /// @param value The new allowance from the owner to the spender
 51 |     |     event Approval(address indexed owner, address indexed spender, uint256 value);
 52 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3Factory.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title The interface for the Uniswap V3 Factory
  5 |     | /// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees
  6 |     | interface IUniswapV3Factory {
  7 |     |     /// @notice Emitted when the owner of the factory is changed
  8 |     |     /// @param oldOwner The owner before the owner was changed
  9 |     |     /// @param newOwner The owner after the owner was changed
 10 |     |     event OwnerChanged(address indexed oldOwner, address indexed newOwner);
 11 |     | 
 12 |     |     /// @notice Emitted when a pool is created
 13 |     |     /// @param token0 The first token of the pool by address sort order
 14 |     |     /// @param token1 The second token of the pool by address sort order
 15 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 16 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks
 17 |     |     /// @param pool The address of the created pool
 18 |     |     event PoolCreated(
 19 |     |         address indexed token0,
 20 |     |         address indexed token1,
 21 |     |         uint24 indexed fee,
 22 |     |         int24 tickSpacing,
 23 |     |         address pool
 24 |     |     );
 25 |     | 
 26 |     |     /// @notice Emitted when a new fee amount is enabled for pool creation via the factory
 27 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip
 28 |     |     /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee
 29 |     |     event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);
 30 |     | 
 31 |     |     /// @notice Returns the current owner of the factory
 32 |     |     /// @dev Can be changed by the current owner via setOwner
 33 |     |     /// @return The address of the factory owner
 34 |     |     function owner() external view returns (address);
 35 |     | 
 36 |     |     /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled
 37 |     |     /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context
 38 |     |     /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee
 39 |     |     /// @return The tick spacing
 40 |     |     function feeAmountTickSpacing(uint24 fee) external view returns (int24);
 41 |     | 
 42 |     |     /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist
 43 |     |     /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order
 44 |     |     /// @param tokenA The contract address of either token0 or token1
 45 |     |     /// @param tokenB The contract address of the other token
 46 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 47 |     |     /// @return pool The pool address
 48 |     |     function getPool(
 49 |     |         address tokenA,
 50 |     |         address tokenB,
 51 |     |         uint24 fee
 52 |     |     ) external view returns (address pool);
 53 |     | 
 54 |     |     /// @notice Creates a pool for the given two tokens and fee
 55 |     |     /// @param tokenA One of the two tokens in the desired pool
 56 |     |     /// @param tokenB The other of the two tokens in the desired pool
 57 |     |     /// @param fee The desired fee for the pool
 58 |     |     /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved
 59 |     |     /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments
 60 |     |     /// are invalid.
 61 |     |     /// @return pool The address of the newly created pool
 62 |     |     function createPool(
 63 |     |         address tokenA,
 64 |     |         address tokenB,
 65 |     |         uint24 fee
 66 |     |     ) external returns (address pool);
 67 |     | 
 68 |     |     /// @notice Updates the owner of the factory
 69 |     |     /// @dev Must be called by the current owner
 70 |     |     /// @param _owner The new owner of the factory
 71 |     |     function setOwner(address _owner) external;
 72 |     | 
 73 |     |     /// @notice Enables a fee amount with the given tickSpacing
 74 |     |     /// @dev Fee amounts may never be removed once enabled
 75 |     |     /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)
 76 |     |     /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount
 77 |     |     function enableFeeAmount(uint24 fee, int24 tickSpacing) external;
 78 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3Pool.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './pool/IUniswapV3PoolImmutables.sol';
  5 |     | import './pool/IUniswapV3PoolState.sol';
  6 |     | import './pool/IUniswapV3PoolDerivedState.sol';
  7 |     | import './pool/IUniswapV3PoolActions.sol';
  8 |     | import './pool/IUniswapV3PoolOwnerActions.sol';
  9 |     | import './pool/IUniswapV3PoolEvents.sol';
 10 |     | 
 11 |     | /// @title The interface for a Uniswap V3 Pool
 12 |     | /// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform
 13 |     | /// to the ERC20 specification
 14 |     | /// @dev The pool interface is broken up into many smaller pieces
 15 |     | interface IUniswapV3Pool is
 16 |     |     IUniswapV3PoolImmutables,
 17 |     |     IUniswapV3PoolState,
 18 |     |     IUniswapV3PoolDerivedState,
 19 |     |     IUniswapV3PoolActions,
 20 |     |     IUniswapV3PoolOwnerActions,
 21 |     |     IUniswapV3PoolEvents
 22 |     | {
 23 |     | 
 24 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3PoolDeployer.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title An interface for a contract that is capable of deploying Uniswap V3 Pools
  5 |     | /// @notice A contract that constructs a pool must implement this to pass arguments to the pool
  6 |     | /// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash
  7 |     | /// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain
  8 |     | interface IUniswapV3PoolDeployer {
  9 |     |     /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.
 10 |     |     /// @dev Called by the pool constructor to fetch the parameters of the pool
 11 |     |     /// Returns factory The factory address
 12 |     |     /// Returns token0 The first token of the pool by address sort order
 13 |     |     /// Returns token1 The second token of the pool by address sort order
 14 |     |     /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// Returns tickSpacing The minimum number of ticks between initialized ticks
 16 |     |     function parameters()
 17 |     |         external
 18 |     |         view
 19 |     |         returns (
 20 |     |             address factory,
 21 |     |             address token0,
 22 |     |             address token1,
 23 |     |             uint24 fee,
 24 |     |             int24 tickSpacing
 25 |     |         );
 26 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3FlashCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#flash
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface
  6 |     | interface IUniswapV3FlashCallback {
  7 |     |     /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.
  8 |     |     /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param fee0 The fee amount in token0 due to the pool by the end of the flash
 11 |     |     /// @param fee1 The fee amount in token1 due to the pool by the end of the flash
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call
 13 |     |     function uniswapV3FlashCallback(
 14 |     |         uint256 fee0,
 15 |     |         uint256 fee1,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3MintCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#mint
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface
  6 |     | interface IUniswapV3MintCallback {
  7 |     |     /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity
 11 |     |     /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity
 12 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call
 13 |     |     function uniswapV3MintCallback(
 14 |     |         uint256 amount0Owed,
 15 |     |         uint256 amount1Owed,
 16 |     |         bytes calldata data
 17 |     |     ) external;
 18 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3SwapCallback.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Callback for IUniswapV3PoolActions#swap
  5 |     | /// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface
  6 |     | interface IUniswapV3SwapCallback {
  7 |     |     /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.
  8 |     |     /// @dev In the implementation you must pay the pool tokens owed for the swap.
  9 |     |     /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.
 10 |     |     /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.
 11 |     |     /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by
 12 |     |     /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.
 13 |     |     /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by
 14 |     |     /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.
 15 |     |     /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call
 16 |     |     function uniswapV3SwapCallback(
 17 |     |         int256 amount0Delta,
 18 |     |         int256 amount1Delta,
 19 |     |         bytes calldata data
 20 |     |     ) external;
 21 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolActions.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Permissionless pool actions
   5 |     | /// @notice Contains pool methods that can be called by anyone
   6 |     | interface IUniswapV3PoolActions {
   7 |     |     /// @notice Sets the initial price for the pool
   8 |     |     /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value
   9 |     |     /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96
  10 |     |     function initialize(uint160 sqrtPriceX96) external;
  11 |     | 
  12 |     |     /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position
  13 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback
  14 |     |     /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends
  15 |     |     /// on tickLower, tickUpper, the amount of liquidity, and the current price.
  16 |     |     /// @param recipient The address for which the liquidity will be created
  17 |     |     /// @param tickLower The lower tick of the position in which to add liquidity
  18 |     |     /// @param tickUpper The upper tick of the position in which to add liquidity
  19 |     |     /// @param amount The amount of liquidity to mint
  20 |     |     /// @param data Any data that should be passed through to the callback
  21 |     |     /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback
  22 |     |     /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback
  23 |     |     function mint(
  24 |     |         address recipient,
  25 |     |         int24 tickLower,
  26 |     |         int24 tickUpper,
  27 |     |         uint128 amount,
  28 |     |         bytes calldata data
  29 |     |     ) external returns (uint256 amount0, uint256 amount1);
  30 |     | 
  31 |     |     /// @notice Collects tokens owed to a position
  32 |     |     /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.
  33 |     |     /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or
  34 |     |     /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the
  35 |     |     /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.
  36 |     |     /// @param recipient The address which should receive the fees collected
  37 |     |     /// @param tickLower The lower tick of the position for which to collect fees
  38 |     |     /// @param tickUpper The upper tick of the position for which to collect fees
  39 |     |     /// @param amount0Requested How much token0 should be withdrawn from the fees owed
  40 |     |     /// @param amount1Requested How much token1 should be withdrawn from the fees owed
  41 |     |     /// @return amount0 The amount of fees collected in token0
  42 |     |     /// @return amount1 The amount of fees collected in token1
  43 |     |     function collect(
  44 |     |         address recipient,
  45 |     |         int24 tickLower,
  46 |     |         int24 tickUpper,
  47 |     |         uint128 amount0Requested,
  48 |     |         uint128 amount1Requested
  49 |     |     ) external returns (uint128 amount0, uint128 amount1);
  50 |     | 
  51 |     |     /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position
  52 |     |     /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0
  53 |     |     /// @dev Fees must be collected separately via a call to #collect
  54 |     |     /// @param tickLower The lower tick of the position for which to burn liquidity
  55 |     |     /// @param tickUpper The upper tick of the position for which to burn liquidity
  56 |     |     /// @param amount How much liquidity to burn
  57 |     |     /// @return amount0 The amount of token0 sent to the recipient
  58 |     |     /// @return amount1 The amount of token1 sent to the recipient
  59 |     |     function burn(
  60 |     |         int24 tickLower,
  61 |     |         int24 tickUpper,
  62 |     |         uint128 amount
  63 |     |     ) external returns (uint256 amount0, uint256 amount1);
  64 |     | 
  65 |     |     /// @notice Swap token0 for token1, or token1 for token0
  66 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback
  67 |     |     /// @param recipient The address to receive the output of the swap
  68 |     |     /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0
  69 |     |     /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)
  70 |     |     /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this
  71 |     |     /// value after the swap. If one for zero, the price cannot be greater than this value after the swap
  72 |     |     /// @param data Any data to be passed through to the callback
  73 |     |     /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive
  74 |     |     /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive
  75 |     |     function swap(
  76 |     |         address recipient,
  77 |     |         bool zeroForOne,
  78 |     |         int256 amountSpecified,
  79 |     |         uint160 sqrtPriceLimitX96,
  80 |     |         bytes calldata data
  81 |     |     ) external returns (int256 amount0, int256 amount1);
  82 |     | 
  83 |     |     /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback
  84 |     |     /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback
  85 |     |     /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling
  86 |     |     /// with 0 amount{0,1} and sending the donation amount(s) from the callback
  87 |     |     /// @param recipient The address which will receive the token0 and token1 amounts
  88 |     |     /// @param amount0 The amount of token0 to send
  89 |     |     /// @param amount1 The amount of token1 to send
  90 |     |     /// @param data Any data to be passed through to the callback
  91 |     |     function flash(
  92 |     |         address recipient,
  93 |     |         uint256 amount0,
  94 |     |         uint256 amount1,
  95 |     |         bytes calldata data
  96 |     |     ) external;
  97 |     | 
  98 |     |     /// @notice Increase the maximum number of price and liquidity observations that this pool will store
  99 |     |     /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to
 100 |     |     /// the input observationCardinalityNext.
 101 |     |     /// @param observationCardinalityNext The desired minimum number of observations for the pool to store
 102 |     |     function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;
 103 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Pool state that is not stored
  5 |     | /// @notice Contains view functions to provide information about the pool that is computed rather than stored on the
  6 |     | /// blockchain. The functions here may have variable gas costs.
  7 |     | interface IUniswapV3PoolDerivedState {
  8 |     |     /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp
  9 |     |     /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing
 10 |     |     /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,
 11 |     |     /// you must call it with secondsAgos = [3600, 0].
 12 |     |     /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in
 13 |     |     /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.
 14 |     |     /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned
 15 |     |     /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp
 16 |     |     /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block
 17 |     |     /// timestamp
 18 |     |     function observe(uint32[] calldata secondsAgos)
 19 |     |         external
 20 |     |         view
 21 |     |         returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);
 22 |     | 
 23 |     |     /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range
 24 |     |     /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.
 25 |     |     /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first
 26 |     |     /// snapshot is taken and the second snapshot is taken.
 27 |     |     /// @param tickLower The lower tick of the range
 28 |     |     /// @param tickUpper The upper tick of the range
 29 |     |     /// @return tickCumulativeInside The snapshot of the tick accumulator for the range
 30 |     |     /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range
 31 |     |     /// @return secondsInside The snapshot of seconds per liquidity for the range
 32 |     |     function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)
 33 |     |         external
 34 |     |         view
 35 |     |         returns (
 36 |     |             int56 tickCumulativeInside,
 37 |     |             uint160 secondsPerLiquidityInsideX128,
 38 |     |             uint32 secondsInside
 39 |     |         );
 40 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolEvents.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Events emitted by a pool
   5 |     | /// @notice Contains all events emitted by the pool
   6 |     | interface IUniswapV3PoolEvents {
   7 |     |     /// @notice Emitted exactly once by a pool when #initialize is first called on the pool
   8 |     |     /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize
   9 |     |     /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96
  10 |     |     /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool
  11 |     |     event Initialize(uint160 sqrtPriceX96, int24 tick);
  12 |     | 
  13 |     |     /// @notice Emitted when liquidity is minted for a given position
  14 |     |     /// @param sender The address that minted the liquidity
  15 |     |     /// @param owner The owner of the position and recipient of any minted liquidity
  16 |     |     /// @param tickLower The lower tick of the position
  17 |     |     /// @param tickUpper The upper tick of the position
  18 |     |     /// @param amount The amount of liquidity minted to the position range
  19 |     |     /// @param amount0 How much token0 was required for the minted liquidity
  20 |     |     /// @param amount1 How much token1 was required for the minted liquidity
  21 |     |     event Mint(
  22 |     |         address sender,
  23 |     |         address indexed owner,
  24 |     |         int24 indexed tickLower,
  25 |     |         int24 indexed tickUpper,
  26 |     |         uint128 amount,
  27 |     |         uint256 amount0,
  28 |     |         uint256 amount1
  29 |     |     );
  30 |     | 
  31 |     |     /// @notice Emitted when fees are collected by the owner of a position
  32 |     |     /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees
  33 |     |     /// @param owner The owner of the position for which fees are collected
  34 |     |     /// @param tickLower The lower tick of the position
  35 |     |     /// @param tickUpper The upper tick of the position
  36 |     |     /// @param amount0 The amount of token0 fees collected
  37 |     |     /// @param amount1 The amount of token1 fees collected
  38 |     |     event Collect(
  39 |     |         address indexed owner,
  40 |     |         address recipient,
  41 |     |         int24 indexed tickLower,
  42 |     |         int24 indexed tickUpper,
  43 |     |         uint128 amount0,
  44 |     |         uint128 amount1
  45 |     |     );
  46 |     | 
  47 |     |     /// @notice Emitted when a position's liquidity is removed
  48 |     |     /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect
  49 |     |     /// @param owner The owner of the position for which liquidity is removed
  50 |     |     /// @param tickLower The lower tick of the position
  51 |     |     /// @param tickUpper The upper tick of the position
  52 |     |     /// @param amount The amount of liquidity to remove
  53 |     |     /// @param amount0 The amount of token0 withdrawn
  54 |     |     /// @param amount1 The amount of token1 withdrawn
  55 |     |     event Burn(
  56 |     |         address indexed owner,
  57 |     |         int24 indexed tickLower,
  58 |     |         int24 indexed tickUpper,
  59 |     |         uint128 amount,
  60 |     |         uint256 amount0,
  61 |     |         uint256 amount1
  62 |     |     );
  63 |     | 
  64 |     |     /// @notice Emitted by the pool for any swaps between token0 and token1
  65 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  66 |     |     /// @param recipient The address that received the output of the swap
  67 |     |     /// @param amount0 The delta of the token0 balance of the pool
  68 |     |     /// @param amount1 The delta of the token1 balance of the pool
  69 |     |     /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96
  70 |     |     /// @param liquidity The liquidity of the pool after the swap
  71 |     |     /// @param tick The log base 1.0001 of price of the pool after the swap
  72 |     |     event Swap(
  73 |     |         address indexed sender,
  74 |     |         address indexed recipient,
  75 |     |         int256 amount0,
  76 |     |         int256 amount1,
  77 |     |         uint160 sqrtPriceX96,
  78 |     |         uint128 liquidity,
  79 |     |         int24 tick
  80 |     |     );
  81 |     | 
  82 |     |     /// @notice Emitted by the pool for any flashes of token0/token1
  83 |     |     /// @param sender The address that initiated the swap call, and that received the callback
  84 |     |     /// @param recipient The address that received the tokens from flash
  85 |     |     /// @param amount0 The amount of token0 that was flashed
  86 |     |     /// @param amount1 The amount of token1 that was flashed
  87 |     |     /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee
  88 |     |     /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee
  89 |     |     event Flash(
  90 |     |         address indexed sender,
  91 |     |         address indexed recipient,
  92 |     |         uint256 amount0,
  93 |     |         uint256 amount1,
  94 |     |         uint256 paid0,
  95 |     |         uint256 paid1
  96 |     |     );
  97 |     | 
  98 |     |     /// @notice Emitted by the pool for increases to the number of observations that can be stored
  99 |     |     /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index
 100 |     |     /// just before a mint/swap/burn.
 101 |     |     /// @param observationCardinalityNextOld The previous value of the next observation cardinality
 102 |     |     /// @param observationCardinalityNextNew The updated value of the next observation cardinality
 103 |     |     event IncreaseObservationCardinalityNext(
 104 |     |         uint16 observationCardinalityNextOld,
 105 |     |         uint16 observationCardinalityNextNew
 106 |     |     );
 107 |     | 
 108 |     |     /// @notice Emitted when the protocol fee is changed by the pool
 109 |     |     /// @param feeProtocol0Old The previous value of the token0 protocol fee
 110 |     |     /// @param feeProtocol1Old The previous value of the token1 protocol fee
 111 |     |     /// @param feeProtocol0New The updated value of the token0 protocol fee
 112 |     |     /// @param feeProtocol1New The updated value of the token1 protocol fee
 113 |     |     event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);
 114 |     | 
 115 |     |     /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner
 116 |     |     /// @param sender The address that collects the protocol fees
 117 |     |     /// @param recipient The address that receives the collected protocol fees
 118 |     |     /// @param amount0 The amount of token0 protocol fees that is withdrawn
 119 |     |     /// @param amount0 The amount of token1 protocol fees that is withdrawn
 120 |     |     event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);
 121 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolImmutables.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Pool state that never changes
  5 |     | /// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values
  6 |     | interface IUniswapV3PoolImmutables {
  7 |     |     /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface
  8 |     |     /// @return The contract address
  9 |     |     function factory() external view returns (address);
 10 |     | 
 11 |     |     /// @notice The first of the two tokens of the pool, sorted by address
 12 |     |     /// @return The token contract address
 13 |     |     function token0() external view returns (address);
 14 |     | 
 15 |     |     /// @notice The second of the two tokens of the pool, sorted by address
 16 |     |     /// @return The token contract address
 17 |     |     function token1() external view returns (address);
 18 |     | 
 19 |     |     /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6
 20 |     |     /// @return The fee
 21 |     |     function fee() external view returns (uint24);
 22 |     | 
 23 |     |     /// @notice The pool tick spacing
 24 |     |     /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive
 25 |     |     /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...
 26 |     |     /// This value is an int24 to avoid casting even though it is always positive.
 27 |     |     /// @return The tick spacing
 28 |     |     function tickSpacing() external view returns (int24);
 29 |     | 
 30 |     |     /// @notice The maximum amount of position liquidity that can use any tick in the range
 31 |     |     /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and
 32 |     |     /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool
 33 |     |     /// @return The max amount of liquidity per tick
 34 |     |     function maxLiquidityPerTick() external view returns (uint128);
 35 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Permissioned pool actions
  5 |     | /// @notice Contains pool methods that may only be called by the factory owner
  6 |     | interface IUniswapV3PoolOwnerActions {
  7 |     |     /// @notice Set the denominator of the protocol's % share of the fees
  8 |     |     /// @param feeProtocol0 new protocol fee for token0 of the pool
  9 |     |     /// @param feeProtocol1 new protocol fee for token1 of the pool
 10 |     |     function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;
 11 |     | 
 12 |     |     /// @notice Collect the protocol fee accrued to the pool
 13 |     |     /// @param recipient The address to which collected protocol fees should be sent
 14 |     |     /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1
 15 |     |     /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0
 16 |     |     /// @return amount0 The protocol fee collected in token0
 17 |     |     /// @return amount1 The protocol fee collected in token1
 18 |     |     function collectProtocol(
 19 |     |         address recipient,
 20 |     |         uint128 amount0Requested,
 21 |     |         uint128 amount1Requested
 22 |     |     ) external returns (uint128 amount0, uint128 amount1);
 23 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolState.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Pool state that can change
   5 |     | /// @notice These methods compose the pool's state, and can change with any frequency including multiple times
   6 |     | /// per transaction
   7 |     | interface IUniswapV3PoolState {
   8 |     |     /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas
   9 |     |     /// when accessed externally.
  10 |     |     /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value
  11 |     |     /// tick The current tick of the pool, i.e. according to the last tick transition that was run.
  12 |     |     /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick
  13 |     |     /// boundary.
  14 |     |     /// observationIndex The index of the last oracle observation that was written,
  15 |     |     /// observationCardinality The current maximum number of observations stored in the pool,
  16 |     |     /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.
  17 |     |     /// feeProtocol The protocol fee for both tokens of the pool.
  18 |     |     /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0
  19 |     |     /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.
  20 |     |     /// unlocked Whether the pool is currently locked to reentrancy
  21 |     |     function slot0()
  22 |     |         external
  23 |     |         view
  24 |     |         returns (
  25 |     |             uint160 sqrtPriceX96,
  26 |     |             int24 tick,
  27 |     |             uint16 observationIndex,
  28 |     |             uint16 observationCardinality,
  29 |     |             uint16 observationCardinalityNext,
  30 |     |             uint8 feeProtocol,
  31 |     |             bool unlocked
  32 |     |         );
  33 |     | 
  34 |     |     /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool
  35 |     |     /// @dev This value can overflow the uint256
  36 |     |     function feeGrowthGlobal0X128() external view returns (uint256);
  37 |     | 
  38 |     |     /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool
  39 |     |     /// @dev This value can overflow the uint256
  40 |     |     function feeGrowthGlobal1X128() external view returns (uint256);
  41 |     | 
  42 |     |     /// @notice The amounts of token0 and token1 that are owed to the protocol
  43 |     |     /// @dev Protocol fees will never exceed uint128 max in either token
  44 |     |     function protocolFees() external view returns (uint128 token0, uint128 token1);
  45 |     | 
  46 |     |     /// @notice The currently in range liquidity available to the pool
  47 |     |     /// @dev This value has no relationship to the total liquidity across all ticks
  48 |     |     function liquidity() external view returns (uint128);
  49 |     | 
  50 |     |     /// @notice Look up information about a specific tick in the pool
  51 |     |     /// @param tick The tick to look up
  52 |     |     /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or
  53 |     |     /// tick upper,
  54 |     |     /// liquidityNet how much liquidity changes when the pool price crosses the tick,
  55 |     |     /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,
  56 |     |     /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,
  57 |     |     /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick
  58 |     |     /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,
  59 |     |     /// secondsOutside the seconds spent on the other side of the tick from the current tick,
  60 |     |     /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.
  61 |     |     /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.
  62 |     |     /// In addition, these values are only relative and must be used only in comparison to previous snapshots for
  63 |     |     /// a specific position.
  64 |     |     function ticks(int24 tick)
  65 |     |         external
  66 |     |         view
  67 |     |         returns (
  68 |     |             uint128 liquidityGross,
  69 |     |             int128 liquidityNet,
  70 |     |             uint256 feeGrowthOutside0X128,
  71 |     |             uint256 feeGrowthOutside1X128,
  72 |     |             int56 tickCumulativeOutside,
  73 |     |             uint160 secondsPerLiquidityOutsideX128,
  74 |     |             uint32 secondsOutside,
  75 |     |             bool initialized
  76 |     |         );
  77 |     | 
  78 |     |     /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information
  79 |     |     function tickBitmap(int16 wordPosition) external view returns (uint256);
  80 |     | 
  81 |     |     /// @notice Returns the information about a position by the position's key
  82 |     |     /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper
  83 |     |     /// @return _liquidity The amount of liquidity in the position,
  84 |     |     /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,
  85 |     |     /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,
  86 |     |     /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,
  87 |     |     /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke
  88 |     |     function positions(bytes32 key)
  89 |     |         external
  90 |     |         view
  91 |     |         returns (
  92 |     |             uint128 _liquidity,
  93 |     |             uint256 feeGrowthInside0LastX128,
  94 |     |             uint256 feeGrowthInside1LastX128,
  95 |     |             uint128 tokensOwed0,
  96 |     |             uint128 tokensOwed1
  97 |     |         );
  98 |     | 
  99 |     |     /// @notice Returns data about a specific observation index
 100 |     |     /// @param index The element of the observations array to fetch
 101 |     |     /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time
 102 |     |     /// ago, rather than at a specific index in the array.
 103 |     |     /// @return blockTimestamp The timestamp of the observation,
 104 |     |     /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,
 105 |     |     /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,
 106 |     |     /// Returns initialized whether the observation has been initialized and the values are safe to use
 107 |     |     function observations(uint256 index)
 108 |     |         external
 109 |     |         view
 110 |     |         returns (
 111 |     |             uint32 blockTimestamp,
 112 |     |             int56 tickCumulative,
 113 |     |             uint160 secondsPerLiquidityCumulativeX128,
 114 |     |             bool initialized
 115 |     |         );
 116 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/BitMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title BitMath
  5 |     | /// @dev This library provides functionality for computing bit properties of an unsigned integer
  6 |     | library BitMath {
  7 |     |     /// @notice Returns the index of the most significant bit of the number,
  8 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
  9 |     |     /// @dev The function satisfies the property:
 10 |     |     ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)
 11 |     |     /// @param x the value for which to compute the most significant bit, must be greater than 0
 12 |     |     /// @return r the index of the most significant bit
 13 |     |     function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {
 14 |     |         require(x > 0);
 15 |     | 
 16 |     |         if (x >= 0x100000000000000000000000000000000) {
 17 |     |             x >>= 128;
 18 |     |             r += 128;
 19 |     |         }
 20 |     |         if (x >= 0x10000000000000000) {
 21 |     |             x >>= 64;
 22 |     |             r += 64;
 23 |     |         }
 24 |     |         if (x >= 0x100000000) {
 25 |     |             x >>= 32;
 26 |     |             r += 32;
 27 |     |         }
 28 |     |         if (x >= 0x10000) {
 29 |     |             x >>= 16;
 30 |     |             r += 16;
 31 |     |         }
 32 |     |         if (x >= 0x100) {
 33 |     |             x >>= 8;
 34 |     |             r += 8;
 35 |     |         }
 36 |     |         if (x >= 0x10) {
 37 |     |             x >>= 4;
 38 |     |             r += 4;
 39 |     |         }
 40 |     |         if (x >= 0x4) {
 41 |     |             x >>= 2;
 42 |     |             r += 2;
 43 |     |         }
 44 |     |         if (x >= 0x2) r += 1;
 45 |     |     }
 46 |     | 
 47 |     |     /// @notice Returns the index of the least significant bit of the number,
 48 |     |     ///     where the least significant bit is at index 0 and the most significant bit is at index 255
 49 |     |     /// @dev The function satisfies the property:
 50 |     |     ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)
 51 |     |     /// @param x the value for which to compute the least significant bit, must be greater than 0
 52 |     |     /// @return r the index of the least significant bit
 53 |     |     function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {
 54 |     |         require(x > 0);
 55 |     | 
 56 |     |         r = 255;
 57 |     |         if (x & type(uint128).max > 0) {
 58 |     |             r -= 128;
 59 |     |         } else {
 60 |     |             x >>= 128;
 61 |     |         }
 62 |     |         if (x & type(uint64).max > 0) {
 63 |     |             r -= 64;
 64 |     |         } else {
 65 |     |             x >>= 64;
 66 |     |         }
 67 |     |         if (x & type(uint32).max > 0) {
 68 |     |             r -= 32;
 69 |     |         } else {
 70 |     |             x >>= 32;
 71 |     |         }
 72 |     |         if (x & type(uint16).max > 0) {
 73 |     |             r -= 16;
 74 |     |         } else {
 75 |     |             x >>= 16;
 76 |     |         }
 77 |     |         if (x & type(uint8).max > 0) {
 78 |     |             r -= 8;
 79 |     |         } else {
 80 |     |             x >>= 8;
 81 |     |         }
 82 |     |         if (x & 0xf > 0) {
 83 |     |             r -= 4;
 84 |     |         } else {
 85 |     |             x >>= 4;
 86 |     |         }
 87 |     |         if (x & 0x3 > 0) {
 88 |     |             r -= 2;
 89 |     |         } else {
 90 |     |             x >>= 2;
 91 |     |         }
 92 |     |         if (x & 0x1 > 0) r -= 1;
 93 |     |     }
 94 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FixedPoint128.sol
 1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
 2 |     | pragma solidity >=0.8.0;
 3 |     | 
 4 |     | /// @title FixedPoint128
 5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
 6 |     | library FixedPoint128 {
 7 |     |     uint256 internal constant Q128 = 0x100000000000000000000000000000000;
 8 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FixedPoint96.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title FixedPoint96
  5 |     | /// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)
  6 |     | /// @dev Used in SqrtPriceMath.sol
  7 |     | library FixedPoint96 {
  8 |     |     uint8 internal constant RESOLUTION = 96;
  9 |     |     uint256 internal constant Q96 = 0x1000000000000000000000000;
 10 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FullMath.sol
   1 |     | // SPDX-License-Identifier: MIT
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Contains 512-bit math functions
   5 |     | /// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
   6 |     | /// @dev Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
   7 |     | library FullMath {
   8 |     |     /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
   9 |     |     /// @param a The multiplicand
  10 |     |     /// @param b The multiplier
  11 |     |     /// @param denominator The divisor
  12 |     |     /// @return result The 256-bit result
  13 |     |     /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv
  14 |     |     function mulDiv(
  15 |     |         uint256 a,
  16 |     |         uint256 b,
  17 |     |         uint256 denominator
  18 |     |     ) internal pure returns (uint256 result) {
  19 |     |         unchecked{
  20 |     |         // 512-bit multiply [prod1 prod0] = a * b
  21 |     |         // Compute the product mod 2**256 and mod 2**256 - 1
  22 |     |         // then use the Chinese Remainder Theorem to reconstruct
  23 |     |         // the 512 bit result. The result is stored in two 256
  24 |     |         // variables such that product = prod1 * 2**256 + prod0
  25 |     |         uint256 prod0; // Least significant 256 bits of the product
  26 |     |         uint256 prod1; // Most significant 256 bits of the product
  27 |     |         assembly {
  28 |     |             let mm := mulmod(a, b, not(0))
  29 |     |             prod0 := mul(a, b)
  30 |     |             prod1 := sub(sub(mm, prod0), lt(mm, prod0))
  31 |     |         }
  32 |     | 
  33 |     |         // Handle non-overflow cases, 256 by 256 division
  34 |     |         if (prod1 == 0) {
  35 |     |             require(denominator > 0);
  36 |     |             assembly {
  37 |     |                 result := div(prod0, denominator)
  38 |     |             }
  39 |     |             return result;
  40 |     |         }
  41 |     | 
  42 |     |         // Make sure the result is less than 2**256.
  43 |     |         // Also prevents denominator == 0
  44 |     |         require(denominator > prod1);
  45 |     | 
  46 |     |         ///////////////////////////////////////////////
  47 |     |         // 512 by 256 division.
  48 |     |         ///////////////////////////////////////////////
  49 |     | 
  50 |     |         // Make division exact by subtracting the remainder from [prod1 prod0]
  51 |     |         // Compute remainder using mulmod
  52 |     |         uint256 remainder;
  53 |     |         assembly {
  54 |     |             remainder := mulmod(a, b, denominator)
  55 |     |         }
  56 |     |         // Subtract 256 bit number from 512 bit number
  57 |     |         assembly {
  58 |     |             prod1 := sub(prod1, gt(remainder, prod0))
  59 |     |             prod0 := sub(prod0, remainder)
  60 |     |         }
  61 |     | 
  62 |     |         // Factor powers of two out of denominator
  63 |     |         // Compute largest power of two divisor of denominator.
  64 |     |         // Always >= 1.
  65 |     |         uint256 twos = uint256(-int256(denominator) & int256(denominator));
  66 |     |         // Divide denominator by power of two
  67 |     |         assembly {
  68 |     |             denominator := div(denominator, twos)
  69 |     |         }
  70 |     | 
  71 |     |         // Divide [prod1 prod0] by the factors of two
  72 |     |         assembly {
  73 |     |             prod0 := div(prod0, twos)
  74 |     |         }
  75 |     |         // Shift in bits from prod1 into prod0. For this we need
  76 |     |         // to flip `twos` such that it is 2**256 / twos.
  77 |     |         // If twos is zero, then it becomes one
  78 |     |         assembly {
  79 |     |             twos := add(div(sub(0, twos), twos), 1)
  80 |     |         }
  81 |     |         prod0 |= prod1 * twos;
  82 |     | 
  83 |     |         // Invert denominator mod 2**256
  84 |     |         // Now that denominator is an odd number, it has an inverse
  85 |     |         // modulo 2**256 such that denominator * inv = 1 mod 2**256.
  86 |     |         // Compute the inverse by starting with a seed that is correct
  87 |     |         // correct for four bits. That is, denominator * inv = 1 mod 2**4
  88 |     |         uint256 inv = (3 * denominator) ^ 2;
  89 |     |         // Now use Newton-Raphson iteration to improve the precision.
  90 |     |         // Thanks to Hensel's lifting lemma, this also works in modular
  91 |     |         // arithmetic, doubling the correct bits in each step.
  92 |     |         inv *= 2 - denominator * inv; // inverse mod 2**8
  93 |     |         inv *= 2 - denominator * inv; // inverse mod 2**16
  94 |     |         inv *= 2 - denominator * inv; // inverse mod 2**32
  95 |     |         inv *= 2 - denominator * inv; // inverse mod 2**64
  96 |     |         inv *= 2 - denominator * inv; // inverse mod 2**128
  97 |     |         inv *= 2 - denominator * inv; // inverse mod 2**256
  98 |     | 
  99 |     |         // Because the division is now exact we can divide by multiplying
 100 |     |         // with the modular inverse of denominator. This will give us the
 101 |     |         // correct result modulo 2**256. Since the precoditions guarantee
 102 |     |         // that the outcome is less than 2**256, this is the final result.
 103 |     |         // We don't need to compute the high bits of the result and prod1
 104 |     |         // is no longer required.
 105 |     |         result = prod0 * inv;
 106 |     |         }
 107 |     |         return result;
 108 |     |     }
 109 |     | 
 110 |     |     /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0
 111 |     |     /// @param a The multiplicand
 112 |     |     /// @param b The multiplier
 113 |     |     /// @param denominator The divisor
 114 |     |     /// @return result The 256-bit result
 115 |     |     function mulDivRoundingUp(
 116 |     |         uint256 a,
 117 |     |         uint256 b,
 118 |     |         uint256 denominator
 119 |     |     ) internal pure returns (uint256 result) {
 120 |     |         result = mulDiv(a, b, denominator);
 121 |     |         if (mulmod(a, b, denominator) > 0) {
 122 |     |             require(result < type(uint256).max);
 123 |     |             result++;
 124 |     |         }
 125 |     |     }
 126 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/LiquidityMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Math library for liquidity
  5 |     | library LiquidityMath {
  6 |     |     /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows
  7 |     |     /// @param x The liquidity before change
  8 |     |     /// @param y The delta by which liquidity should be changed
  9 |     |     /// @return z The liquidity delta
 10 |     |     function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {
 11 |     |         if (y < 0) {
 12 |     |             require((z = x - uint128(-y)) < x, 'LS');
 13 |     |         } else {
 14 |     |             require((z = x + uint128(y)) >= x, 'LA');
 15 |     |         }
 16 |     |     }
 17 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 |     |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 |     |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 |     |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 |     |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 |     |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 |     |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Oracle.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Oracle
   5 |     | /// @notice Provides price and liquidity data useful for a wide variety of system designs
   6 |     | /// @dev Instances of stored oracle data, "observations", are collected in the oracle array
   7 |     | /// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the
   8 |     | /// maximum length of the oracle array. New slots will be added when the array is fully populated.
   9 |     | /// Observations are overwritten when the full length of the oracle array is populated.
  10 |     | /// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()
  11 |     | library Oracle {
  12 |     |     struct Observation {
  13 |     |         // the block timestamp of the observation
  14 |     |         uint32 blockTimestamp;
  15 |     |         // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized
  16 |     |         int56 tickCumulative;
  17 |     |         // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized
  18 |     |         uint160 secondsPerLiquidityCumulativeX128;
  19 |     |         // whether or not the observation is initialized
  20 |     |         bool initialized;
  21 |     |     }
  22 |     | 
  23 |     |     /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values
  24 |     |     /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows
  25 |     |     /// @param last The specified observation to be transformed
  26 |     |     /// @param blockTimestamp The timestamp of the new observation
  27 |     |     /// @param tick The active tick at the time of the new observation
  28 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  29 |     |     /// @return Observation The newly populated observation
  30 |     |     function transform(
  31 |     |         Observation memory last,
  32 |     |         uint32 blockTimestamp,
  33 |     |         int24 tick,
  34 |     |         uint128 liquidity
  35 |     |     ) private pure returns (Observation memory) {
  36 |     |         uint32 delta = blockTimestamp - last.blockTimestamp;
  37 |     |         return
  38 |     |             Observation({
  39 |     |                 blockTimestamp: blockTimestamp,
  40 |     |                 tickCumulative: last.tickCumulative + int56(tick) * int56(int32(delta)),
  41 |     |                 secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +
  42 |     |                     ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),
  43 |     |                 initialized: true
  44 |     |             });
  45 |     |     }
  46 |     | 
  47 |     |     /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array
  48 |     |     /// @param self The stored oracle array
  49 |     |     /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32
  50 |     |     /// @return cardinality The number of populated elements in the oracle array
  51 |     |     /// @return cardinalityNext The new length of the oracle array, independent of population
  52 |     |     function initialize(Observation[65535] storage self, uint32 time)
  53 |     |         internal
  54 |     |         returns (uint16 cardinality, uint16 cardinalityNext)
  55 |     |     {
  56 |     |         self[0] = Observation({
  57 |     |             blockTimestamp: time,
  58 |     |             tickCumulative: 0,
  59 |     |             secondsPerLiquidityCumulativeX128: 0,
  60 |     |             initialized: true
  61 |     |         });
  62 |     |         return (1, 1);
  63 |     |     }
  64 |     | 
  65 |     |     /// @notice Writes an oracle observation to the array
  66 |     |     /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.
  67 |     |     /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality
  68 |     |     /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.
  69 |     |     /// @param self The stored oracle array
  70 |     |     /// @param index The index of the observation that was most recently written to the observations array
  71 |     |     /// @param blockTimestamp The timestamp of the new observation
  72 |     |     /// @param tick The active tick at the time of the new observation
  73 |     |     /// @param liquidity The total in-range liquidity at the time of the new observation
  74 |     |     /// @param cardinality The number of populated elements in the oracle array
  75 |     |     /// @param cardinalityNext The new length of the oracle array, independent of population
  76 |     |     /// @return indexUpdated The new index of the most recently written element in the oracle array
  77 |     |     /// @return cardinalityUpdated The new cardinality of the oracle array
  78 |     |     function write(
  79 |     |         Observation[65535] storage self,
  80 |     |         uint16 index,
  81 |     |         uint32 blockTimestamp,
  82 |     |         int24 tick,
  83 |     |         uint128 liquidity,
  84 |     |         uint16 cardinality,
  85 |     |         uint16 cardinalityNext
  86 |     |     ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {
  87 |     |         Observation memory last = self[index];
  88 |     | 
  89 |     |         // early return if we've already written an observation this block
  90 |     |         if (last.blockTimestamp == blockTimestamp) return (index, cardinality);
  91 |     | 
  92 |     |         // if the conditions are right, we can bump the cardinality
  93 |     |         if (cardinalityNext > cardinality && index == (cardinality - 1)) {
  94 |     |             cardinalityUpdated = cardinalityNext;
  95 |     |         } else {
  96 |     |             cardinalityUpdated = cardinality;
  97 |     |         }
  98 |     | 
  99 |     |         indexUpdated = (index + 1) % cardinalityUpdated;
 100 |     |         self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Prepares the oracle array to store up to `next` observations
 104 |     |     /// @param self The stored oracle array
 105 |     |     /// @param current The current next cardinality of the oracle array
 106 |     |     /// @param next The proposed next cardinality which will be populated in the oracle array
 107 |     |     /// @return next The next cardinality which will be populated in the oracle array
 108 |     |     function grow(
 109 |     |         Observation[65535] storage self,
 110 |     |         uint16 current,
 111 |     |         uint16 next
 112 |     |     ) internal returns (uint16) {
 113 |     |         require(current > 0, 'I');
 114 |     |         // no-op if the passed next value isn't greater than the current next value
 115 |     |         if (next <= current) return current;
 116 |     |         // store in each slot to prevent fresh SSTOREs in swaps
 117 |     |         // this data will not be used because the initialized boolean is still false
 118 |     |         for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;
 119 |     |         return next;
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice comparator for 32-bit timestamps
 123 |     |     /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time
 124 |     |     /// @param time A timestamp truncated to 32 bits
 125 |     |     /// @param a A comparison timestamp from which to determine the relative position of `time`
 126 |     |     /// @param b From which to determine the relative position of `time`
 127 |     |     /// @return bool Whether `a` is chronologically <= `b`
 128 |     |     function lte(
 129 |     |         uint32 time,
 130 |     |         uint32 a,
 131 |     |         uint32 b
 132 |     |     ) private pure returns (bool) {
 133 |     |         // if there hasn't been overflow, no need to adjust
 134 |     |         if (a <= time && b <= time) return a <= b;
 135 |     | 
 136 |     |         uint256 aAdjusted = a > time ? a : a + 2**32;
 137 |     |         uint256 bAdjusted = b > time ? b : b + 2**32;
 138 |     | 
 139 |     |         return aAdjusted <= bAdjusted;
 140 |     |     }
 141 |     | 
 142 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.
 143 |     |     /// The result may be the same observation, or adjacent observations.
 144 |     |     /// @dev The answer must be contained in the array, used when the target is located within the stored observation
 145 |     |     /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation
 146 |     |     /// @param self The stored oracle array
 147 |     |     /// @param time The current block.timestamp
 148 |     |     /// @param target The timestamp at which the reserved observation should be for
 149 |     |     /// @param index The index of the observation that was most recently written to the observations array
 150 |     |     /// @param cardinality The number of populated elements in the oracle array
 151 |     |     /// @return beforeOrAt The observation recorded before, or at, the target
 152 |     |     /// @return atOrAfter The observation recorded at, or after, the target
 153 |     |     function binarySearch(
 154 |     |         Observation[65535] storage self,
 155 |     |         uint32 time,
 156 |     |         uint32 target,
 157 |     |         uint16 index,
 158 |     |         uint16 cardinality
 159 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 160 |     |         uint256 l = (index + 1) % cardinality; // oldest observation
 161 |     |         uint256 r = l + cardinality - 1; // newest observation
 162 |     |         uint256 i;
 163 |     |         while (true) {
 164 |     |             i = (l + r) / 2;
 165 |     | 
 166 |     |             beforeOrAt = self[i % cardinality];
 167 |     | 
 168 |     |             // we've landed on an uninitialized tick, keep searching higher (more recently)
 169 |     |             if (!beforeOrAt.initialized) {
 170 |     |                 l = i + 1;
 171 |     |                 continue;
 172 |     |             }
 173 |     | 
 174 |     |             atOrAfter = self[(i + 1) % cardinality];
 175 |     | 
 176 |     |             bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);
 177 |     | 
 178 |     |             // check if we've found the answer!
 179 |     |             if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;
 180 |     | 
 181 |     |             if (!targetAtOrAfter) r = i - 1;
 182 |     |             else l = i + 1;
 183 |     |         }
 184 |     |     }
 185 |     | 
 186 |     |     /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied
 187 |     |     /// @dev Assumes there is at least 1 initialized observation.
 188 |     |     /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.
 189 |     |     /// @param self The stored oracle array
 190 |     |     /// @param time The current block.timestamp
 191 |     |     /// @param target The timestamp at which the reserved observation should be for
 192 |     |     /// @param tick The active tick at the time of the returned or simulated observation
 193 |     |     /// @param index The index of the observation that was most recently written to the observations array
 194 |     |     /// @param liquidity The total pool liquidity at the time of the call
 195 |     |     /// @param cardinality The number of populated elements in the oracle array
 196 |     |     /// @return beforeOrAt The observation which occurred at, or before, the given timestamp
 197 |     |     /// @return atOrAfter The observation which occurred at, or after, the given timestamp
 198 |     |     function getSurroundingObservations(
 199 |     |         Observation[65535] storage self,
 200 |     |         uint32 time,
 201 |     |         uint32 target,
 202 |     |         int24 tick,
 203 |     |         uint16 index,
 204 |     |         uint128 liquidity,
 205 |     |         uint16 cardinality
 206 |     |     ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {
 207 |     |         // optimistically set before to the newest observation
 208 |     |         beforeOrAt = self[index];
 209 |     | 
 210 |     |         // if the target is chronologically at or after the newest observation, we can early return
 211 |     |         if (lte(time, beforeOrAt.blockTimestamp, target)) {
 212 |     |             if (beforeOrAt.blockTimestamp == target) {
 213 |     |                 // if newest observation equals target, we're in the same block, so we can ignore atOrAfter
 214 |     |                 return (beforeOrAt, atOrAfter);
 215 |     |             } else {
 216 |     |                 // otherwise, we need to transform
 217 |     |                 return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));
 218 |     |             }
 219 |     |         }
 220 |     | 
 221 |     |         // now, set before to the oldest observation
 222 |     |         beforeOrAt = self[(index + 1) % cardinality];
 223 |     |         if (!beforeOrAt.initialized) beforeOrAt = self[0];
 224 |     | 
 225 |     |         // ensure that the target is chronologically at or after the oldest observation
 226 |     |         require(lte(time, beforeOrAt.blockTimestamp, target), 'OLD');
 227 |     | 
 228 |     |         // if we've reached this point, we have to binary search
 229 |     |         return binarySearch(self, time, target, index, cardinality);
 230 |     |     }
 231 |     | 
 232 |     |     /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.
 233 |     |     /// 0 may be passed as `secondsAgo' to return the current cumulative values.
 234 |     |     /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values
 235 |     |     /// at exactly the timestamp between the two observations.
 236 |     |     /// @param self The stored oracle array
 237 |     |     /// @param time The current block timestamp
 238 |     |     /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation
 239 |     |     /// @param tick The current tick
 240 |     |     /// @param index The index of the observation that was most recently written to the observations array
 241 |     |     /// @param liquidity The current in-range pool liquidity
 242 |     |     /// @param cardinality The number of populated elements in the oracle array
 243 |     |     /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`
 244 |     |     /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`
 245 |     |     function observeSingle(
 246 |     |         Observation[65535] storage self,
 247 |     |         uint32 time,
 248 |     |         uint32 secondsAgo,
 249 |     |         int24 tick,
 250 |     |         uint16 index,
 251 |     |         uint128 liquidity,
 252 |     |         uint16 cardinality
 253 |     |     ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {
 254 |     |         if (secondsAgo == 0) {
 255 |     |             Observation memory last = self[index];
 256 |     |             if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);
 257 |     |             return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);
 258 |     |         }
 259 |     | 
 260 |     |         uint32 target = time - secondsAgo;
 261 |     | 
 262 |     |         (Observation memory beforeOrAt, Observation memory atOrAfter) =
 263 |     |             getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);
 264 |     | 
 265 |     |         if (target == beforeOrAt.blockTimestamp) {
 266 |     |             // we're at the left boundary
 267 |     |             return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);
 268 |     |         } else if (target == atOrAfter.blockTimestamp) {
 269 |     |             // we're at the right boundary
 270 |     |             return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);
 271 |     |         } else {
 272 |     |             // we're in the middle
 273 |     |             uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;
 274 |     |             uint32 targetDelta = target - beforeOrAt.blockTimestamp;
 275 |     |             return (
 276 |     |                 beforeOrAt.tickCumulative +
 277 |     |                     ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(int32(observationTimeDelta))) *
 278 |     |                     int56(int32(targetDelta)),
 279 |     |                 beforeOrAt.secondsPerLiquidityCumulativeX128 +
 280 |     |                     uint160(
 281 |     |                         (uint256(
 282 |     |                             atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128
 283 |     |                         ) * targetDelta) / observationTimeDelta
 284 |     |                     )
 285 |     |             );
 286 |     |         }
 287 |     |     }
 288 |     | 
 289 |     |     /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`
 290 |     |     /// @dev Reverts if `secondsAgos` > oldest observation
 291 |     |     /// @param self The stored oracle array
 292 |     |     /// @param time The current block.timestamp
 293 |     |     /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation
 294 |     |     /// @param tick The current tick
 295 |     |     /// @param index The index of the observation that was most recently written to the observations array
 296 |     |     /// @param liquidity The current in-range pool liquidity
 297 |     |     /// @param cardinality The number of populated elements in the oracle array
 298 |     |     /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`
 299 |     |     /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`
 300 |     |     function observe(
 301 |     |         Observation[65535] storage self,
 302 |     |         uint32 time,
 303 |     |         uint32[] memory secondsAgos,
 304 |     |         int24 tick,
 305 |     |         uint16 index,
 306 |     |         uint128 liquidity,
 307 |     |         uint16 cardinality
 308 |     |     ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {
 309 |     |         require(cardinality > 0, 'I');
 310 |     | 
 311 |     |         tickCumulatives = new int56[](secondsAgos.length);
 312 |     |         secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);
 313 |     |         for (uint256 i = 0; i < secondsAgos.length; i++) {
 314 |     |             (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(
 315 |     |                 self,
 316 |     |                 time,
 317 |     |                 secondsAgos[i],
 318 |     |                 tick,
 319 |     |                 index,
 320 |     |                 liquidity,
 321 |     |                 cardinality
 322 |     |             );
 323 |     |         }
 324 |     |     }
 325 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Position.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './FixedPoint128.sol';
  6 |     | import './LiquidityMath.sol';
  7 |     | 
  8 |     | /// @title Position
  9 |     | /// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary
 10 |     | /// @dev Positions store additional state for tracking fees owed to the position
 11 |     | library Position {
 12 |     |     // info stored for each user's position
 13 |     |     struct Info {
 14 |     |         // the amount of liquidity owned by this position
 15 |     |         uint128 liquidity;
 16 |     |         // fee growth per unit of liquidity as of the last update to liquidity or fees owed
 17 |     |         uint256 feeGrowthInside0LastX128;
 18 |     |         uint256 feeGrowthInside1LastX128;
 19 |     |         // the fees owed to the position owner in token0/token1
 20 |     |         uint128 tokensOwed0;
 21 |     |         uint128 tokensOwed1;
 22 |     |     }
 23 |     | 
 24 |     |     /// @notice Returns the Info struct of a position, given an owner and position boundaries
 25 |     |     /// @param self The mapping containing all user positions
 26 |     |     /// @param owner The address of the position owner
 27 |     |     /// @param tickLower The lower tick boundary of the position
 28 |     |     /// @param tickUpper The upper tick boundary of the position
 29 |     |     /// @return position The position info struct of the given owners' position
 30 |     |     function get(
 31 |     |         mapping(bytes32 => Info) storage self,
 32 |     |         address owner,
 33 |     |         int24 tickLower,
 34 |     |         int24 tickUpper
 35 |     |     ) internal view returns (Position.Info storage position) {
 36 |     |         position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Credits accumulated fees to a user's position
 40 |     |     /// @param self The individual position to update
 41 |     |     /// @param liquidityDelta The change in pool liquidity as a result of the position update
 42 |     |     /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
 43 |     |     /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
 44 |     |     function update(
 45 |     |         Info storage self,
 46 |     |         int128 liquidityDelta,
 47 |     |         uint256 feeGrowthInside0X128,
 48 |     |         uint256 feeGrowthInside1X128
 49 |     |     ) internal {
 50 |     |         Info memory _self = self;
 51 |     | 
 52 |     |         uint128 liquidityNext;
 53 |     |         if (liquidityDelta == 0) {
 54 |     |             require(_self.liquidity > 0, 'NP'); // disallow pokes for 0 liquidity positions
 55 |     |             liquidityNext = _self.liquidity;
 56 |     |         } else {
 57 |     |             liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);
 58 |     |         }
 59 |     | 
 60 |     |         // calculate accumulated fees
 61 |     |         uint128 tokensOwed0 =
 62 |     |             uint128(
 63 |     |                 FullMath.mulDiv(
 64 |     |                     feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,
 65 |     |                     _self.liquidity,
 66 |     |                     FixedPoint128.Q128
 67 |     |                 )
 68 |     |             );
 69 |     |         uint128 tokensOwed1 =
 70 |     |             uint128(
 71 |     |                 FullMath.mulDiv(
 72 |     |                     feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,
 73 |     |                     _self.liquidity,
 74 |     |                     FixedPoint128.Q128
 75 |     |                 )
 76 |     |             );
 77 |     | 
 78 |     |         // update the position
 79 |     |         if (liquidityDelta != 0) self.liquidity = liquidityNext;
 80 |     |         self.feeGrowthInside0LastX128 = feeGrowthInside0X128;
 81 |     |         self.feeGrowthInside1LastX128 = feeGrowthInside1X128;
 82 |     |         if (tokensOwed0 > 0 || tokensOwed1 > 0) {
 83 |     |             // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
 84 |     |             self.tokensOwed0 += tokensOwed0;
 85 |     |             self.tokensOwed1 += tokensOwed1;
 86 |     |         }
 87 |     |     }
 88 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SafeCast.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Safe casting methods
  5 |     | /// @notice Contains methods for safely casting between types
  6 |     | library SafeCast {
  7 |     |     /// @notice Cast a uint256 to a uint160, revert on overflow
  8 |     |     /// @param y The uint256 to be downcasted
  9 |     |     /// @return z The downcasted integer, now type uint160
 10 |     |     function toUint160(uint256 y) internal pure returns (uint160 z) {
 11 |     |         require((z = uint160(y)) == y);
 12 |     |     }
 13 |     | 
 14 |     |     /// @notice Cast a int256 to a int128, revert on overflow or underflow
 15 |     |     /// @param y The int256 to be downcasted
 16 |     |     /// @return z The downcasted integer, now type int128
 17 |     |     function toInt128(int256 y) internal pure returns (int128 z) {
 18 |     |         require((z = int128(y)) == y);
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Cast a uint256 to a int256, revert on overflow
 22 |     |     /// @param y The uint256 to be casted
 23 |     |     /// @return z The casted integer, now type int256
 24 |     |     function toInt256(uint256 y) internal pure returns (int256 z) {
 25 |     |         require(y < 2**255);
 26 |     |         z = int256(y);
 27 |     |     }
 28 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SqrtPriceMath.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './FullMath.sol';
   8 |     | import './UnsafeMath.sol';
   9 |     | import './FixedPoint96.sol';
  10 |     | 
  11 |     | /// @title Functions based on Q64.96 sqrt price and liquidity
  12 |     | /// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas
  13 |     | library SqrtPriceMath {
  14 |     |     using LowGasSafeMath for uint256;
  15 |     |     using SafeCast for uint256;
  16 |     | 
  17 |     |     /// @notice Gets the next sqrt price given a delta of token0
  18 |     |     /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least
  19 |     |     /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
  20 |     |     /// price less in order to not send too much output.
  21 |     |     /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
  22 |     |     /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
  23 |     |     /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta
  24 |     |     /// @param liquidity The amount of usable liquidity
  25 |     |     /// @param amount How much of token0 to add or remove from virtual reserves
  26 |     |     /// @param add Whether to add or remove the amount of token0
  27 |     |     /// @return The price after adding or removing amount, depending on add
  28 |     |     function getNextSqrtPriceFromAmount0RoundingUp(
  29 |     |         uint160 sqrtPX96,
  30 |     |         uint128 liquidity,
  31 |     |         uint256 amount,
  32 |     |         bool add
  33 |     |     ) internal pure returns (uint160) {
  34 |     |         // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
  35 |     |         if (amount == 0) return sqrtPX96;
  36 |     |         uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
  37 |     | 
  38 |     |         if (add) {
  39 |     |             uint256 product;
  40 |     |             if ((product = amount * sqrtPX96) / amount == sqrtPX96) {
  41 |     |                 uint256 denominator = numerator1 + product;
  42 |     |                 if (denominator >= numerator1)
  43 |     |                     // always fits in 160 bits
  44 |     |                     return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));
  45 |     |             }
  46 |     | 
  47 |     |             return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));
  48 |     |         } else {
  49 |     |             uint256 product;
  50 |     |             // if the product overflows, we know the denominator underflows
  51 |     |             // in addition, we must check that the denominator does not underflow
  52 |     |             require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);
  53 |     |             uint256 denominator = numerator1 - product;
  54 |     |             return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();
  55 |     |         }
  56 |     |     }
  57 |     | 
  58 |     |     /// @notice Gets the next sqrt price given a delta of token1
  59 |     |     /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
  60 |     |     /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
  61 |     |     /// price less in order to not send too much output.
  62 |     |     /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
  63 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta
  64 |     |     /// @param liquidity The amount of usable liquidity
  65 |     |     /// @param amount How much of token1 to add, or remove, from virtual reserves
  66 |     |     /// @param add Whether to add, or remove, the amount of token1
  67 |     |     /// @return The price after adding or removing `amount`
  68 |     |     function getNextSqrtPriceFromAmount1RoundingDown(
  69 |     |         uint160 sqrtPX96,
  70 |     |         uint128 liquidity,
  71 |     |         uint256 amount,
  72 |     |         bool add
  73 |     |     ) internal pure returns (uint160) {
  74 |     |         // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
  75 |     |         // in both cases, avoid a mulDiv for most inputs
  76 |     |         if (add) {
  77 |     |             uint256 quotient =
  78 |     |                 (
  79 |     |                     amount <= type(uint160).max
  80 |     |                         ? (amount << FixedPoint96.RESOLUTION) / liquidity
  81 |     |                         : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)
  82 |     |                 );
  83 |     | 
  84 |     |             return uint256(sqrtPX96).add(quotient).toUint160();
  85 |     |         } else {
  86 |     |             uint256 quotient =
  87 |     |                 (
  88 |     |                     amount <= type(uint160).max
  89 |     |                         ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)
  90 |     |                         : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)
  91 |     |                 );
  92 |     | 
  93 |     |             require(sqrtPX96 > quotient);
  94 |     |             // always fits 160 bits
  95 |     |             return uint160(sqrtPX96 - quotient);
  96 |     |         }
  97 |     |     }
  98 |     | 
  99 |     |     /// @notice Gets the next sqrt price given an input amount of token0 or token1
 100 |     |     /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds
 101 |     |     /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount
 102 |     |     /// @param liquidity The amount of usable liquidity
 103 |     |     /// @param amountIn How much of token0, or token1, is being swapped in
 104 |     |     /// @param zeroForOne Whether the amount in is token0 or token1
 105 |     |     /// @return sqrtQX96 The price after adding the input amount to token0 or token1
 106 |     |     function getNextSqrtPriceFromInput(
 107 |     |         uint160 sqrtPX96,
 108 |     |         uint128 liquidity,
 109 |     |         uint256 amountIn,
 110 |     |         bool zeroForOne
 111 |     |     ) internal pure returns (uint160 sqrtQX96) {
 112 |     |         require(sqrtPX96 > 0);
 113 |     |         require(liquidity > 0);
 114 |     | 
 115 |     |         // round to make sure that we don't pass the target price
 116 |     |         return
 117 |     |             zeroForOne
 118 |     |                 ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)
 119 |     |                 : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);
 120 |     |     }
 121 |     | 
 122 |     |     /// @notice Gets the next sqrt price given an output amount of token0 or token1
 123 |     |     /// @dev Throws if price or liquidity are 0 or the next price is out of bounds
 124 |     |     /// @param sqrtPX96 The starting price before accounting for the output amount
 125 |     |     /// @param liquidity The amount of usable liquidity
 126 |     |     /// @param amountOut How much of token0, or token1, is being swapped out
 127 |     |     /// @param zeroForOne Whether the amount out is token0 or token1
 128 |     |     /// @return sqrtQX96 The price after removing the output amount of token0 or token1
 129 |     |     function getNextSqrtPriceFromOutput(
 130 |     |         uint160 sqrtPX96,
 131 |     |         uint128 liquidity,
 132 |     |         uint256 amountOut,
 133 |     |         bool zeroForOne
 134 |     |     ) internal pure returns (uint160 sqrtQX96) {
 135 |     |         require(sqrtPX96 > 0);
 136 |     |         require(liquidity > 0);
 137 |     | 
 138 |     |         // round to make sure that we pass the target price
 139 |     |         return
 140 |     |             zeroForOne
 141 |     |                 ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)
 142 |     |                 : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);
 143 |     |     }
 144 |     |     
 145 |     |     event Message(string a);
 146 |     |     event MessageUint160(string a, uint160 b);
 147 |     |     event MessageUint256(string a, uint256 b);
 148 |     | 
 149 |     | 
 150 |     |     /// @notice Gets the amount0 delta between two prices
 151 |     |     /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
 152 |     |     /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
 153 |     |     /// @param sqrtRatioAX96 A sqrt price
 154 |     |     /// @param sqrtRatioBX96 Another sqrt price
 155 |     |     /// @param liquidity The amount of usable liquidity
 156 |     |     /// @param roundUp Whether to round the amount up or down
 157 |     |     /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices
 158 |     |     function getAmount0Delta(
 159 |     |         uint160 sqrtRatioAX96,
 160 |     |         uint160 sqrtRatioBX96,
 161 |     |         uint128 liquidity,
 162 |     |         bool roundUp
 163 |     |     ) internal returns (uint256 amount0) {
 164 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 165 |     | 
 166 |     |         emit Message("HERE9");
 167 |     |         uint256 numerator1;
 168 |     |         unchecked {
 169 |     |             numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;
 170 |     |         }
 171 |     |         emit MessageUint256("numerator1", numerator1);
 172 |     |         uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;
 173 |     |         emit MessageUint256("numerator2", numerator2);
 174 |     |         require(sqrtRatioAX96 > 0);
 175 |     | 
 176 |     |         return
 177 |     |             roundUp
 178 |     |                 ? UnsafeMath.divRoundingUp(
 179 |     |                     FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),
 180 |     |                     sqrtRatioAX96
 181 |     |                 )
 182 |     |                 : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;
 183 |     |     }
 184 |     | 
 185 |     |     /// @notice Gets the amount1 delta between two prices
 186 |     |     /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))
 187 |     |     /// @param sqrtRatioAX96 A sqrt price
 188 |     |     /// @param sqrtRatioBX96 Another sqrt price
 189 |     |     /// @param liquidity The amount of usable liquidity
 190 |     |     /// @param roundUp Whether to round the amount up, or down
 191 |     |     /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices
 192 |     |     function getAmount1Delta(
 193 |     |         uint160 sqrtRatioAX96,
 194 |     |         uint160 sqrtRatioBX96,
 195 |     |         uint128 liquidity,
 196 |     |         bool roundUp
 197 |     |     ) internal pure returns (uint256 amount1) {
 198 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 199 |     | 
 200 |     |         return
 201 |     |             roundUp
 202 |     |                 ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)
 203 |     |                 : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 204 |     |     }
 205 |     | 
 206 |     |     /// @notice Helper that gets signed token0 delta
 207 |     |     /// @param sqrtRatioAX96 A sqrt price
 208 |     |     /// @param sqrtRatioBX96 Another sqrt price
 209 |     |     /// @param liquidity The change in liquidity for which to compute the amount0 delta
 210 |     |     /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
 211 |     |     function getAmount0Delta(
 212 |     |         uint160 sqrtRatioAX96,
 213 |     |         uint160 sqrtRatioBX96,
 214 |     |         int128 liquidity
 215 |     |     ) internal  returns (int256 amount0) {
 216 |     |         return
 217 |     |             liquidity < 0
 218 |     |                 ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 219 |     |                 : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 220 |     |     }
 221 |     | 
 222 |     |     /// @notice Helper that gets signed token1 delta
 223 |     |     /// @param sqrtRatioAX96 A sqrt price
 224 |     |     /// @param sqrtRatioBX96 Another sqrt price
 225 |     |     /// @param liquidity The change in liquidity for which to compute the amount1 delta
 226 |     |     /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
 227 |     |     function getAmount1Delta(
 228 |     |         uint160 sqrtRatioAX96,
 229 |     |         uint160 sqrtRatioBX96,
 230 |     |         int128 liquidity
 231 |     |     ) internal pure returns (int256 amount1) {
 232 |     |         return
 233 |     |             liquidity < 0
 234 |     |                 ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()
 235 |     |                 : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();
 236 |     |     }
 237 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SwapMath.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './FullMath.sol';
  5 |     | import './SqrtPriceMath.sol';
  6 |     | 
  7 |     | /// @title Computes the result of a swap within ticks
  8 |     | /// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.
  9 |     | library SwapMath {
 10 |     |     /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap
 11 |     |     /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
 12 |     |     /// @param sqrtRatioCurrentX96 The current sqrt price of the pool
 13 |     |     /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
 14 |     |     /// @param liquidity The usable liquidity
 15 |     |     /// @param amountRemaining How much input or output amount is remaining to be swapped in/out
 16 |     |     /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
 17 |     |     /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
 18 |     |     /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
 19 |     |     /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
 20 |     |     /// @return feeAmount The amount of input that will be taken as a fee
 21 |     |     function computeSwapStep(
 22 |     |         uint160 sqrtRatioCurrentX96,
 23 |     |         uint160 sqrtRatioTargetX96,
 24 |     |         uint128 liquidity,
 25 |     |         int256 amountRemaining,
 26 |     |         uint24 feePips
 27 |     |     )
 28 |     |         internal
 29 |     |         returns (
 30 |     |             uint160 sqrtRatioNextX96,
 31 |     |             uint256 amountIn,
 32 |     |             uint256 amountOut,
 33 |     |             uint256 feeAmount
 34 |     |         )
 35 |     |     {
 36 |     |         bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;
 37 |     |         bool exactIn = amountRemaining >= 0;
 38 |     | 
 39 |     |         if (exactIn) {
 40 |     |             uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);
 41 |     |             amountIn = zeroForOne
 42 |     |                 ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)
 43 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);
 44 |     |             if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;
 45 |     |             else
 46 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(
 47 |     |                     sqrtRatioCurrentX96,
 48 |     |                     liquidity,
 49 |     |                     amountRemainingLessFee,
 50 |     |                     zeroForOne
 51 |     |                 );
 52 |     |         } else {
 53 |     |             amountOut = zeroForOne
 54 |     |                 ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)
 55 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);
 56 |     |             if (uint256(-amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;
 57 |     |             else
 58 |     |                 sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(
 59 |     |                     sqrtRatioCurrentX96,
 60 |     |                     liquidity,
 61 |     |                     uint256(-amountRemaining),
 62 |     |                     zeroForOne
 63 |     |                 );
 64 |     |         }
 65 |     | 
 66 |     |         bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;
 67 |     | 
 68 |     |         // get the input/output amounts
 69 |     |         if (zeroForOne) {
 70 |     |             amountIn = max && exactIn
 71 |     |                 ? amountIn
 72 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);
 73 |     |             amountOut = max && !exactIn
 74 |     |                 ? amountOut
 75 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);
 76 |     |         } else {
 77 |     |             amountIn = max && exactIn
 78 |     |                 ? amountIn
 79 |     |                 : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);
 80 |     |             amountOut = max && !exactIn
 81 |     |                 ? amountOut
 82 |     |                 : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);
 83 |     |         }
 84 |     | 
 85 |     |         // cap the output amount to not exceed the remaining output amount
 86 |     |         if (!exactIn && amountOut > uint256(-amountRemaining)) {
 87 |     |             amountOut = uint256(-amountRemaining);
 88 |     |         }
 89 |     | 
 90 |     |         if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {
 91 |     |             // we didn't reach the target, so take the remainder of the maximum input as fee
 92 |     |             feeAmount = uint256(amountRemaining) - amountIn;
 93 |     |         } else {
 94 |     |             feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);
 95 |     |         }
 96 |     |     }
 97 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Tick.sol
   1 |     | // SPDX-License-Identifier: BUSL-1.1
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import './LowGasSafeMath.sol';
   5 |     | import './SafeCast.sol';
   6 |     | 
   7 |     | import './TickMath.sol';
   8 |     | import './LiquidityMath.sol';
   9 |     | 
  10 |     | /// @title Tick
  11 |     | /// @notice Contains functions for managing tick processes and relevant calculations
  12 |     | library Tick {
  13 |     |     using LowGasSafeMath for int256;
  14 |     |     using SafeCast for int256;
  15 |     | 
  16 |     |     // info stored for each initialized individual tick
  17 |     |     struct Info {
  18 |     |         // the total position liquidity that references this tick
  19 |     |         uint128 liquidityGross;
  20 |     |         // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
  21 |     |         int128 liquidityNet;
  22 |     |         // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  23 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  24 |     |         uint256 feeGrowthOutside0X128;
  25 |     |         uint256 feeGrowthOutside1X128;
  26 |     |         // the cumulative tick value on the other side of the tick
  27 |     |         int56 tickCumulativeOutside;
  28 |     |         // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
  29 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  30 |     |         uint160 secondsPerLiquidityOutsideX128;
  31 |     |         // the seconds spent on the other side of the tick (relative to the current tick)
  32 |     |         // only has relative meaning, not absolute  the value depends on when the tick is initialized
  33 |     |         uint32 secondsOutside;
  34 |     |         // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
  35 |     |         // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks
  36 |     |         bool initialized;
  37 |     |     }
  38 |     | 
  39 |     |     /// @notice Derives max liquidity per tick from given tick spacing
  40 |     |     /// @dev Executed within the pool constructor
  41 |     |     /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
  42 |     |     ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
  43 |     |     /// @return The max liquidity per tick
  44 |     |     function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {
  45 |     |         int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;
  46 |     |         int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;
  47 |     |         uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;
  48 |     |         return type(uint128).max / numTicks;
  49 |     |     }
  50 |     | 
  51 |     |     /// @notice Retrieves fee growth data
  52 |     |     /// @param self The mapping containing all tick information for initialized ticks
  53 |     |     /// @param tickLower The lower tick boundary of the position
  54 |     |     /// @param tickUpper The upper tick boundary of the position
  55 |     |     /// @param tickCurrent The current tick
  56 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
  57 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
  58 |     |     /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries
  59 |     |     /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries
  60 |     |     function getFeeGrowthInside(
  61 |     |         mapping(int24 => Tick.Info) storage self,
  62 |     |         int24 tickLower,
  63 |     |         int24 tickUpper,
  64 |     |         int24 tickCurrent,
  65 |     |         uint256 feeGrowthGlobal0X128,
  66 |     |         uint256 feeGrowthGlobal1X128
  67 |     |     ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {
  68 |     |         Info storage lower = self[tickLower];
  69 |     |         Info storage upper = self[tickUpper];
  70 |     | 
  71 |     |         // calculate fee growth below
  72 |     |         uint256 feeGrowthBelow0X128;
  73 |     |         uint256 feeGrowthBelow1X128;
  74 |     |         if (tickCurrent >= tickLower) {
  75 |     |             feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;
  76 |     |             feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;
  77 |     |         } else {
  78 |     |             feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;
  79 |     |             feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;
  80 |     |         }
  81 |     | 
  82 |     |         // calculate fee growth above
  83 |     |         uint256 feeGrowthAbove0X128;
  84 |     |         uint256 feeGrowthAbove1X128;
  85 |     |         if (tickCurrent < tickUpper) {
  86 |     |             feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;
  87 |     |             feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;
  88 |     |         } else {
  89 |     |             feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;
  90 |     |             feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;
  91 |     |         }
  92 |     | 
  93 |     |         feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;
  94 |     |         feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;
  95 |     |     }
  96 |     | 
  97 |     |     /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
  98 |     |     /// @param self The mapping containing all tick information for initialized ticks
  99 |     |     /// @param tick The tick that will be updated
 100 |     |     /// @param tickCurrent The current tick
 101 |     |     /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)
 102 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 103 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 104 |     |     /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool
 105 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 106 |     |     /// @param time The current block timestamp cast to a uint32
 107 |     |     /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick
 108 |     |     /// @param maxLiquidity The maximum liquidity allocation for a single tick
 109 |     |     /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa
 110 |     |     function update(
 111 |     |         mapping(int24 => Tick.Info) storage self,
 112 |     |         int24 tick,
 113 |     |         int24 tickCurrent,
 114 |     |         int128 liquidityDelta,
 115 |     |         uint256 feeGrowthGlobal0X128,
 116 |     |         uint256 feeGrowthGlobal1X128,
 117 |     |         uint160 secondsPerLiquidityCumulativeX128,
 118 |     |         int56 tickCumulative,
 119 |     |         uint32 time,
 120 |     |         bool upper,
 121 |     |         uint128 maxLiquidity
 122 |     |     ) internal returns (bool flipped) {
 123 |     |         Tick.Info storage info = self[tick];
 124 |     | 
 125 |     |         uint128 liquidityGrossBefore = info.liquidityGross;
 126 |     |         uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);
 127 |     | 
 128 |     |         require(liquidityGrossAfter <= maxLiquidity, 'LO');
 129 |     | 
 130 |     |         flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);
 131 |     | 
 132 |     |         if (liquidityGrossBefore == 0) {
 133 |     |             // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
 134 |     |             if (tick <= tickCurrent) {
 135 |     |                 info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;
 136 |     |                 info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;
 137 |     |                 info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;
 138 |     |                 info.tickCumulativeOutside = tickCumulative;
 139 |     |                 info.secondsOutside = time;
 140 |     |             }
 141 |     |             info.initialized = true;
 142 |     |         }
 143 |     | 
 144 |     |         info.liquidityGross = liquidityGrossAfter;
 145 |     | 
 146 |     |         // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
 147 |     |         info.liquidityNet = upper
 148 |     |             ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()
 149 |     |             : int256(info.liquidityNet).add(liquidityDelta).toInt128();
 150 |     |     }
 151 |     | 
 152 |     |     /// @notice Clears tick data
 153 |     |     /// @param self The mapping containing all initialized tick information for initialized ticks
 154 |     |     /// @param tick The tick that will be cleared
 155 |     |     function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {
 156 |     |         delete self[tick];
 157 |     |     }
 158 |     | 
 159 |     |     /// @notice Transitions to next tick as needed by price movement
 160 |     |     /// @param self The mapping containing all tick information for initialized ticks
 161 |     |     /// @param tick The destination tick of the transition
 162 |     |     /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
 163 |     |     /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
 164 |     |     /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
 165 |     |     /// @param tickCumulative The tick * time elapsed since the pool was first initialized
 166 |     |     /// @param time The current block.timestamp
 167 |     |     /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
 168 |     |     function cross(
 169 |     |         mapping(int24 => Tick.Info) storage self,
 170 |     |         int24 tick,
 171 |     |         uint256 feeGrowthGlobal0X128,
 172 |     |         uint256 feeGrowthGlobal1X128,
 173 |     |         uint160 secondsPerLiquidityCumulativeX128,
 174 |     |         int56 tickCumulative,
 175 |     |         uint32 time
 176 |     |     ) internal returns (int128 liquidityNet) {
 177 |     |         Tick.Info storage info = self[tick];
 178 |     |         info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;
 179 |     |         info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;
 180 |     |         info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;
 181 |     |         info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;
 182 |     |         info.secondsOutside = time - info.secondsOutside;
 183 |     |         liquidityNet = info.liquidityNet;
 184 |     |     }
 185 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TickBitmap.sol
  1 |     | // SPDX-License-Identifier: BUSL-1.1
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | import './BitMath.sol';
  5 |     | 
  6 |     | /// @title Packed tick initialized state library
  7 |     | /// @notice Stores a packed mapping of tick index to its initialized state
  8 |     | /// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.
  9 |     | library TickBitmap {
 10 |     |     /// @notice Computes the position in the mapping where the initialized bit for a tick lives
 11 |     |     /// @param tick The tick for which to compute the position
 12 |     |     /// @return wordPos The key in the mapping containing the word in which the bit is stored
 13 |     |     /// @return bitPos The bit position in the word where the flag is stored
 14 |     |     function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {
 15 |     |         wordPos = int16(tick >> 8);
 16 |     |         bitPos = uint8(uint24(tick % 256));
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Flips the initialized state for a given tick from false to true, or vice versa
 20 |     |     /// @param self The mapping in which to flip the tick
 21 |     |     /// @param tick The tick to flip
 22 |     |     /// @param tickSpacing The spacing between usable ticks
 23 |     |     function flipTick(
 24 |     |         mapping(int16 => uint256) storage self,
 25 |     |         int24 tick,
 26 |     |         int24 tickSpacing
 27 |     |     ) internal {
 28 |     |         require(tick % tickSpacing == 0); // ensure that the tick is spaced
 29 |     |         (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);
 30 |     |         uint256 mask = 1 << bitPos;
 31 |     |         self[wordPos] ^= mask;
 32 |     |     }
 33 |     | 
 34 |     |     /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
 35 |     |     /// to the left (less than or equal to) or right (greater than) of the given tick
 36 |     |     /// @param self The mapping in which to compute the next initialized tick
 37 |     |     /// @param tick The starting tick
 38 |     |     /// @param tickSpacing The spacing between usable ticks
 39 |     |     /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
 40 |     |     /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
 41 |     |     /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
 42 |     |     function nextInitializedTickWithinOneWord(
 43 |     |         mapping(int16 => uint256) storage self,
 44 |     |         int24 tick,
 45 |     |         int24 tickSpacing,
 46 |     |         bool lte
 47 |     |     ) internal view returns (int24 next, bool initialized) {
 48 |     |         int24 compressed = tick / tickSpacing;
 49 |     |         if (tick < 0 && tick % tickSpacing != 0) compressed--; // round towards negative infinity
 50 |     | 
 51 |     |         if (lte) {
 52 |     |             (int16 wordPos, uint8 bitPos) = position(compressed);
 53 |     |             // all the 1s at or to the right of the current bitPos
 54 |     |             uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);
 55 |     |             uint256 masked = self[wordPos] & mask;
 56 |     | 
 57 |     |             // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
 58 |     |             initialized = masked != 0;
 59 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 60 |     |             next = initialized
 61 |     |                 ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing
 62 |     |                 : (compressed - int24(uint24(bitPos))) * tickSpacing;
 63 |     |         } else {
 64 |     |             // start from the word of the next tick, since the current tick state doesn't matter
 65 |     |             (int16 wordPos, uint8 bitPos) = position(compressed + 1);
 66 |     |             // all the 1s at or to the left of the bitPos
 67 |     |             uint256 mask = ~((1 << bitPos) - 1);
 68 |     |             uint256 masked = self[wordPos] & mask;
 69 |     | 
 70 |     |             // if there are no initialized ticks to the left of the current tick, return leftmost in the word
 71 |     |             initialized = masked != 0;
 72 |     |             // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
 73 |     |             next = initialized
 74 |     |                 ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing
 75 |     |                 : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;
 76 |     |         }
 77 |     |     }
 78 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TickMath.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | /// @title Math library for computing sqrt prices from ticks and vice versa
   5 |     | /// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
   6 |     | /// prices between 2**-128 and 2**128
   7 |     | library TickMath {
   8 |     |     /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128
   9 |     |     int24 internal constant MIN_TICK = -887272;
  10 |     |     /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128
  11 |     |     int24 internal constant MAX_TICK = -MIN_TICK;
  12 |     | 
  13 |     |     /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)
  14 |     |     uint160 internal constant MIN_SQRT_RATIO = 4295128739;
  15 |     |     /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)
  16 |     |     uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;
  17 |     | 
  18 |     |     /// @notice Calculates sqrt(1.0001^tick) * 2^96
  19 |     |     /// @dev Throws if |tick| > max tick
  20 |     |     /// @param tick The input tick for the above formula
  21 |     |     /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
  22 |     |     /// at the given tick
  23 |     |     function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {
  24 |     |         uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));
  25 |     |         require(absTick <= uint256(uint24(MAX_TICK)), 'T');
  26 |     | 
  27 |     |         uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;
  28 |     |         if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;
  29 |     |         if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;
  30 |     |         if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;
  31 |     |         if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;
  32 |     |         if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;
  33 |     |         if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;
  34 |     |         if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;
  35 |     |         if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;
  36 |     |         if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;
  37 |     |         if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;
  38 |     |         if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;
  39 |     |         if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;
  40 |     |         if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;
  41 |     |         if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;
  42 |     |         if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;
  43 |     |         if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;
  44 |     |         if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;
  45 |     |         if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;
  46 |     |         if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;
  47 |     | 
  48 |     |         if (tick > 0) ratio = type(uint256).max / ratio;
  49 |     | 
  50 |     |         // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.
  51 |     |         // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
  52 |     |         // we round up in the division so getTickAtSqrtRatio of the output price is always consistent
  53 |     |         sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));
  54 |     |     }
  55 |     | 
  56 |     |     /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
  57 |     |     /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
  58 |     |     /// ever return.
  59 |     |     /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
  60 |     |     /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
  61 |     |     function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {
  62 |     |         // second inequality must be < because the price can never reach the price at the max tick
  63 |     |         require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');
  64 |     |         uint256 ratio = uint256(sqrtPriceX96) << 32;
  65 |     | 
  66 |     |         uint256 r = ratio;
  67 |     |         uint256 msb = 0;
  68 |     | 
  69 |     |         assembly {
  70 |     |             let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))
  71 |     |             msb := or(msb, f)
  72 |     |             r := shr(f, r)
  73 |     |         }
  74 |     |         assembly {
  75 |     |             let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))
  76 |     |             msb := or(msb, f)
  77 |     |             r := shr(f, r)
  78 |     |         }
  79 |     |         assembly {
  80 |     |             let f := shl(5, gt(r, 0xFFFFFFFF))
  81 |     |             msb := or(msb, f)
  82 |     |             r := shr(f, r)
  83 |     |         }
  84 |     |         assembly {
  85 |     |             let f := shl(4, gt(r, 0xFFFF))
  86 |     |             msb := or(msb, f)
  87 |     |             r := shr(f, r)
  88 |     |         }
  89 |     |         assembly {
  90 |     |             let f := shl(3, gt(r, 0xFF))
  91 |     |             msb := or(msb, f)
  92 |     |             r := shr(f, r)
  93 |     |         }
  94 |     |         assembly {
  95 |     |             let f := shl(2, gt(r, 0xF))
  96 |     |             msb := or(msb, f)
  97 |     |             r := shr(f, r)
  98 |     |         }
  99 |     |         assembly {
 100 |     |             let f := shl(1, gt(r, 0x3))
 101 |     |             msb := or(msb, f)
 102 |     |             r := shr(f, r)
 103 |     |         }
 104 |     |         assembly {
 105 |     |             let f := gt(r, 0x1)
 106 |     |             msb := or(msb, f)
 107 |     |         }
 108 |     | 
 109 |     |         if (msb >= 128) r = ratio >> (msb - 127);
 110 |     |         else r = ratio << (127 - msb);
 111 |     | 
 112 |     |         int256 log_2 = (int256(msb) - 128) << 64;
 113 |     | 
 114 |     |         assembly {
 115 |     |             r := shr(127, mul(r, r))
 116 |     |             let f := shr(128, r)
 117 |     |             log_2 := or(log_2, shl(63, f))
 118 |     |             r := shr(f, r)
 119 |     |         }
 120 |     |         assembly {
 121 |     |             r := shr(127, mul(r, r))
 122 |     |             let f := shr(128, r)
 123 |     |             log_2 := or(log_2, shl(62, f))
 124 |     |             r := shr(f, r)
 125 |     |         }
 126 |     |         assembly {
 127 |     |             r := shr(127, mul(r, r))
 128 |     |             let f := shr(128, r)
 129 |     |             log_2 := or(log_2, shl(61, f))
 130 |     |             r := shr(f, r)
 131 |     |         }
 132 |     |         assembly {
 133 |     |             r := shr(127, mul(r, r))
 134 |     |             let f := shr(128, r)
 135 |     |             log_2 := or(log_2, shl(60, f))
 136 |     |             r := shr(f, r)
 137 |     |         }
 138 |     |         assembly {
 139 |     |             r := shr(127, mul(r, r))
 140 |     |             let f := shr(128, r)
 141 |     |             log_2 := or(log_2, shl(59, f))
 142 |     |             r := shr(f, r)
 143 |     |         }
 144 |     |         assembly {
 145 |     |             r := shr(127, mul(r, r))
 146 |     |             let f := shr(128, r)
 147 |     |             log_2 := or(log_2, shl(58, f))
 148 |     |             r := shr(f, r)
 149 |     |         }
 150 |     |         assembly {
 151 |     |             r := shr(127, mul(r, r))
 152 |     |             let f := shr(128, r)
 153 |     |             log_2 := or(log_2, shl(57, f))
 154 |     |             r := shr(f, r)
 155 |     |         }
 156 |     |         assembly {
 157 |     |             r := shr(127, mul(r, r))
 158 |     |             let f := shr(128, r)
 159 |     |             log_2 := or(log_2, shl(56, f))
 160 |     |             r := shr(f, r)
 161 |     |         }
 162 |     |         assembly {
 163 |     |             r := shr(127, mul(r, r))
 164 |     |             let f := shr(128, r)
 165 |     |             log_2 := or(log_2, shl(55, f))
 166 |     |             r := shr(f, r)
 167 |     |         }
 168 |     |         assembly {
 169 |     |             r := shr(127, mul(r, r))
 170 |     |             let f := shr(128, r)
 171 |     |             log_2 := or(log_2, shl(54, f))
 172 |     |             r := shr(f, r)
 173 |     |         }
 174 |     |         assembly {
 175 |     |             r := shr(127, mul(r, r))
 176 |     |             let f := shr(128, r)
 177 |     |             log_2 := or(log_2, shl(53, f))
 178 |     |             r := shr(f, r)
 179 |     |         }
 180 |     |         assembly {
 181 |     |             r := shr(127, mul(r, r))
 182 |     |             let f := shr(128, r)
 183 |     |             log_2 := or(log_2, shl(52, f))
 184 |     |             r := shr(f, r)
 185 |     |         }
 186 |     |         assembly {
 187 |     |             r := shr(127, mul(r, r))
 188 |     |             let f := shr(128, r)
 189 |     |             log_2 := or(log_2, shl(51, f))
 190 |     |             r := shr(f, r)
 191 |     |         }
 192 |     |         assembly {
 193 |     |             r := shr(127, mul(r, r))
 194 |     |             let f := shr(128, r)
 195 |     |             log_2 := or(log_2, shl(50, f))
 196 |     |         }
 197 |     | 
 198 |     |         int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number
 199 |     | 
 200 |     |         int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);
 201 |     |         int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);
 202 |     | 
 203 |     |         tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;
 204 |     |     }
 205 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library TransferHelper {
  7 |     |     /// @notice Transfers tokens from the targeted address to the given destination
  8 |     |     /// @notice Errors with 'STF' if transfer fails
  9 |     |     /// @param token The contract address of the token to be transferred
 10 |     |     /// @param from The originating address from which the tokens will be transferred
 11 |     |     /// @param to The destination address of the transfer
 12 |     |     /// @param value The amount to be transferred
 13 |     |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 14 |     |         (bool success, bytes memory data) =
 15 |     |             token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
 16 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "STF");
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 20 |     |     /// @dev Errors with ST if transfer fails
 21 |     |     /// @param token The contract address of the token which will be transferred
 22 |     |     /// @param to The recipient of the transfer
 23 |     |     /// @param value The value of the transfer
 24 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 25 |     |         (bool success, bytes memory data) =
 26 |     |             token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
 27 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "ST");
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Approves the stipulated contract to spend the given allowance in the given token
 31 |     |     /// @dev Errors with 'SA' if transfer fails
 32 |     |     /// @param token The contract address of the token to be approved
 33 |     |     /// @param to The target of the approval
 34 |     |     /// @param value The amount of the given token the target will be allowed to spend
 35 |     |     function safeApprove(address token, address to, uint256 value) internal {
 36 |     |         (bool success, bytes memory data) =
 37 |     |             token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
 38 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "SA");
 39 |     |     }
 40 |     | 
 41 |     |     /// @notice Transfers ETH to the recipient address
 42 |     |     /// @dev Fails with `STE`
 43 |     |     /// @param to The destination of the transfer
 44 |     |     /// @param value The value to be transferred
 45 |     |     function safeTransferETH(address to, uint256 value) internal {
 46 |     |         (bool success,) = to.call{value: value}(new bytes(0));
 47 |     |         require(success, "STE");
 48 |     |     }
 49 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/UnsafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity >=0.8.0;
  3 |     | 
  4 |     | /// @title Math functions that do not check inputs or outputs
  5 |     | /// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks
  6 |     | library UnsafeMath {
  7 |     |     /// @notice Returns ceil(x / y)
  8 |     |     /// @dev division by 0 has unspecified behavior, and must be checked externally
  9 |     |     /// @param x The dividend
 10 |     |     /// @param y The divisor
 11 |     |     /// @return z The quotient, ceil(x / y)
 12 |     |     function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {
 13 |     |         assembly {
 14 |     |             z := add(div(x, y), gt(mod(x, y), 0))
 15 |     |         }
 16 |     |     }
 17 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/SwapRouter.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity ^0.8.0;
   3 |     | pragma abicoder v2;
   4 |     | 
   5 |     | import "v3-core/libraries/SafeCast.sol";
   6 |     | import "v3-core/libraries/TickMath.sol";
   7 |     | import "v3-core/interfaces/IUniswapV3Pool.sol";
   8 |     | import "v3-core/interfaces/IUniswapV3Factory.sol";
   9 |     | 
  10 |     | import "./interfaces/ISwapRouter.sol";
  11 |     | import "./base/PeripheryImmutableState.sol";
  12 |     | import "./base/PeripheryValidation.sol";
  13 |     | import "./base/PeripheryPaymentsWithFee.sol";
  14 |     | import "./base/Multicall.sol";
  15 |     | import "./base/SelfPermit.sol";
  16 |     | import "./libraries/Path.sol";
  17 |     | import "./libraries/CallbackValidation.sol";
  18 |     | import "./interfaces/external/IWETH9.sol";
  19 |     | 
  20 |     | /// @title Uniswap V3 Swap Router
  21 |     | /// @notice Router for stateless execution of swaps against Uniswap V3
  22 |     | contract SwapRouter is
  23 |     |     ISwapRouter,
  24 |     |     PeripheryImmutableState,
  25 |     |     PeripheryValidation,
  26 |     |     PeripheryPaymentsWithFee,
  27 |     |     Multicall,
  28 |     |     SelfPermit
  29 |     | {
  30 |     |     using Path for bytes;
  31 |     |     using SafeCast for uint256;
  32 |     | 
  33 |     |     /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap
  34 |     |     /// can never actually be this value
  35 |     |     uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;
  36 |     | 
  37 |     |     /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.
  38 |     |     uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;
  39 |     | 
  40 |     |     constructor(address _factory, address _WETH9) PeripheryImmutableState(_factory, _WETH9) {}
  41 |     | 
  42 |     |     /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.
  43 |     |     function getPool(
  44 |     |         address tokenA,
  45 |     |         address tokenB,
  46 |     |         uint24 fee
  47 |     |     ) private view returns (IUniswapV3Pool) {
  48 |     |         return IUniswapV3Pool(IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee));
  49 |     |     }
  50 |     | 
  51 |     |     struct SwapCallbackData {
  52 |     |         bytes path;
  53 |     |         address payer;
  54 |     |     }
  55 |     | 
  56 |     |     /// @inheritdoc IUniswapV3SwapCallback
  57 |     |     function uniswapV3SwapCallback(
  58 |     |         int256 amount0Delta,
  59 |     |         int256 amount1Delta,
  60 |     |         bytes calldata _data
  61 |     |     ) external override {
  62 |     |         require(amount0Delta > 0 || amount1Delta > 0); // swaps entirely within 0-liquidity regions are not supported
  63 |     |         SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));
  64 |     |         (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();
  65 |     |         CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);
  66 |     | 
  67 |     |         (bool isExactInput, uint256 amountToPay) = amount0Delta > 0
  68 |     |             ? (tokenIn < tokenOut, uint256(amount0Delta))
  69 |     |             : (tokenOut < tokenIn, uint256(amount1Delta));
  70 |     |         if (isExactInput) {
  71 |     |             pay(tokenIn, data.payer, msg.sender, amountToPay);
  72 |     |         } else {
  73 |     |             // either initiate the next swap or pay
  74 |     |             if (data.path.hasMultiplePools()) {
  75 |     |                 data.path = data.path.skipToken();
  76 |     |                 exactOutputInternal(amountToPay, msg.sender, 0, data);
  77 |     |             } else {
  78 |     |                 amountInCached = amountToPay;
  79 |     |                 tokenIn = tokenOut; // swap in/out because exact output swaps are reversed
  80 |     |                 pay(tokenIn, data.payer, msg.sender, amountToPay);
  81 |     |             }
  82 |     |         }
  83 |     |     }
  84 |     | 
  85 |     |     /// @dev Performs a single exact input swap
  86 |     |     function exactInputInternal(
  87 |     |         uint256 amountIn,
  88 |     |         address recipient,
  89 |     |         uint160 sqrtPriceLimitX96,
  90 |     |         SwapCallbackData memory data
  91 |     |     ) private returns (uint256 amountOut) {
  92 |     |         // allow swapping to the router address with address 0
  93 |     |         if (recipient == address(0)) recipient = address(this);
  94 |     | 
  95 |     |         (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();
  96 |     | 
  97 |     |         bool zeroForOne = tokenIn < tokenOut;
  98 |     | 
  99 |     |         (int256 amount0, int256 amount1) = getPool(tokenIn, tokenOut, fee).swap(
 100 |     |             recipient,
 101 |     |             zeroForOne,
 102 |     |             amountIn.toInt256(),
 103 |     |             sqrtPriceLimitX96 == 0
 104 |     |                 ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)
 105 |     |                 : sqrtPriceLimitX96,
 106 |     |             abi.encode(data)
 107 |     |         );
 108 |     | 
 109 |     |         return uint256(-(zeroForOne ? amount1 : amount0));
 110 |     |     }
 111 |     | 
 112 |     |     /// @inheritdoc ISwapRouter
 113 |     |     function exactInputSingle(ExactInputSingleParams calldata params)
 114 |     |         external
 115 |     |         payable
 116 |     |         override
 117 |     |         checkDeadline(params.deadline)
 118 |     |         returns (uint256 amountOut)
 119 |     |     {
 120 |     |         amountOut = exactInputInternal(
 121 |     |             params.amountIn,
 122 |     |             params.recipient,
 123 |     |             params.sqrtPriceLimitX96,
 124 |     |             SwapCallbackData({
 125 |     |                 path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut),
 126 |     |                 payer: msg.sender
 127 |     |             })
 128 |     |         );
 129 |     |         require(amountOut >= params.amountOutMinimum, "Too little received");
 130 |     |     }
 131 |     | 
 132 |     |     /// @inheritdoc ISwapRouter
 133 |     |     function exactInput(ExactInputParams memory params)
 134 |     |         external
 135 |     |         payable
 136 |     |         override
 137 |     |         checkDeadline(params.deadline)
 138 |     |         returns (uint256 amountOut)
 139 |     |     {
 140 |     |         address payer = msg.sender; // msg.sender pays for the first hop
 141 |     | 
 142 |     |         while (true) {
 143 |     |             bool hasMultiplePools = params.path.hasMultiplePools();
 144 |     | 
 145 |     |             // the outputs of prior swaps become the inputs to subsequent ones
 146 |     |             params.amountIn = exactInputInternal(
 147 |     |                 params.amountIn,
 148 |     |                 hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies
 149 |     |                 0,
 150 |     |                 SwapCallbackData({
 151 |     |                     path: params.path.getFirstPool(), // only the first pool in the path is necessary
 152 |     |                     payer: payer
 153 |     |                 })
 154 |     |             );
 155 |     | 
 156 |     |             // decide whether to continue or terminate
 157 |     |             if (hasMultiplePools) {
 158 |     |                 payer = address(this); // at this point, the caller has paid
 159 |     |                 params.path = params.path.skipToken();
 160 |     |             } else {
 161 |     |                 amountOut = params.amountIn;
 162 |     |                 break;
 163 |     |             }
 164 |     |         }
 165 |     | 
 166 |     |         require(amountOut >= params.amountOutMinimum, "Too little received");
 167 |     |     }
 168 |     | 
 169 |     |     /// @dev Performs a single exact output swap
 170 |     |     function exactOutputInternal(
 171 |     |         uint256 amountOut,
 172 |     |         address recipient,
 173 |     |         uint160 sqrtPriceLimitX96,
 174 |     |         SwapCallbackData memory data
 175 |     |     ) private returns (uint256 amountIn) {
 176 |     |         // allow swapping to the router address with address 0
 177 |     |         if (recipient == address(0)) recipient = address(this);
 178 |     | 
 179 |     |         (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();
 180 |     | 
 181 |     |         bool zeroForOne = tokenIn < tokenOut;
 182 |     | 
 183 |     |         (int256 amount0Delta, int256 amount1Delta) = getPool(tokenIn, tokenOut, fee).swap(
 184 |     |             recipient,
 185 |     |             zeroForOne,
 186 |     |             -amountOut.toInt256(),
 187 |     |             sqrtPriceLimitX96 == 0
 188 |     |                 ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)
 189 |     |                 : sqrtPriceLimitX96,
 190 |     |             abi.encode(data)
 191 |     |         );
 192 |     | 
 193 |     |         uint256 amountOutReceived;
 194 |     |         (amountIn, amountOutReceived) = zeroForOne
 195 |     |             ? (uint256(amount0Delta), uint256(-amount1Delta))
 196 |     |             : (uint256(amount1Delta), uint256(-amount0Delta));
 197 |     |         // it's technically possible to not receive the full output amount,
 198 |     |         // so if no price limit has been specified, require this possibility away
 199 |     |         if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);
 200 |     |     }
 201 |     | 
 202 |     |     /// @inheritdoc ISwapRouter
 203 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params)
 204 |     |         external
 205 |     |         payable
 206 |     |         override
 207 |     |         checkDeadline(params.deadline)
 208 |     |         returns (uint256 amountIn)
 209 |     |     {
 210 |     |         // avoid an SLOAD by using the swap return data
 211 |     |         amountIn = exactOutputInternal(
 212 |     |             params.amountOut,
 213 |     |             params.recipient,
 214 |     |             params.sqrtPriceLimitX96,
 215 |     |             SwapCallbackData({
 216 |     |                 path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn),
 217 |     |                 payer: msg.sender
 218 |     |             })
 219 |     |         );
 220 |     | 
 221 |     |         require(amountIn <= params.amountInMaximum, "Too much requested");
 222 |     |         // has to be reset even though we don't use it in the single hop case
 223 |     |         amountInCached = DEFAULT_AMOUNT_IN_CACHED;
 224 |     |     }
 225 |     | 
 226 |     |     /// @inheritdoc ISwapRouter
 227 |     |     function exactOutput(ExactOutputParams calldata params)
 228 |     |         external
 229 |     |         payable
 230 |     |         override
 231 |     |         checkDeadline(params.deadline)
 232 |     |         returns (uint256 amountIn)
 233 |     |     {
 234 |     |         // it's okay that the payer is fixed to msg.sender here, as they're only paying for the "final" exact output
 235 |     |         // swap, which happens first, and subsequent swaps are paid for within nested callback frames
 236 |     |         exactOutputInternal(
 237 |     |             params.amountOut,
 238 |     |             params.recipient,
 239 |     |             0,
 240 |     |             SwapCallbackData({path: params.path, payer: msg.sender})
 241 |     |         );
 242 |     | 
 243 |     |         amountIn = amountInCached;
 244 |     |         require(amountIn <= params.amountInMaximum, "Too much requested");
 245 |     |         amountInCached = DEFAULT_AMOUNT_IN_CACHED;
 246 |     |     }
 247 |     | }
 248 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/BlockTimestamp.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Function for getting block timestamp
  5 |     | /// @dev Base contract that is overridden for tests
  6 |     | abstract contract BlockTimestamp {
  7 |     |     /// @dev Method that exists purely to be overridden for tests
  8 |     |     /// @return The current block timestamp
  9 |     |     function _blockTimestamp() internal view virtual returns (uint256) {
 10 |     |         return block.timestamp;
 11 |     |     }
 12 |     | }
 13 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/LiquidityManagement.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import 'v3-core/interfaces/IUniswapV3Factory.sol';
  6 |     | import 'v3-core/interfaces/callback/IUniswapV3MintCallback.sol';
  7 |     | import 'v3-core/libraries/TickMath.sol';
  8 |     | 
  9 |     | import '../libraries/PoolAddress.sol';
 10 |     | import '../libraries/CallbackValidation.sol';
 11 |     | import '../libraries/LiquidityAmounts.sol';
 12 |     | 
 13 |     | import './PeripheryPayments.sol';
 14 |     | import './PeripheryImmutableState.sol';
 15 |     | 
 16 |     | /// @title Liquidity management functions
 17 |     | /// @notice Internal functions for safely managing liquidity in Uniswap V3
 18 |     | abstract contract LiquidityManagement is IUniswapV3MintCallback, PeripheryImmutableState, PeripheryPayments {
 19 |     |     struct MintCallbackData {
 20 |     |         PoolAddress.PoolKey poolKey;
 21 |     |         address payer;
 22 |     |     }
 23 |     | 
 24 |     |     /// @inheritdoc IUniswapV3MintCallback
 25 |     |     function uniswapV3MintCallback(
 26 |     |         uint256 amount0Owed,
 27 |     |         uint256 amount1Owed,
 28 |     |         bytes calldata data
 29 |     |     ) external override {
 30 |     |         MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));
 31 |     |         CallbackValidation.verifyCallback(factory, decoded.poolKey);
 32 |     | 
 33 |     |         if (amount0Owed > 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);
 34 |     |         if (amount1Owed > 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);
 35 |     |     }
 36 |     | 
 37 |     |     struct AddLiquidityParams {
 38 |     |         address token0;
 39 |     |         address token1;
 40 |     |         uint24 fee;
 41 |     |         address recipient;
 42 |     |         int24 tickLower;
 43 |     |         int24 tickUpper;
 44 |     |         uint256 amount0Desired;
 45 |     |         uint256 amount1Desired;
 46 |     |         uint256 amount0Min;
 47 |     |         uint256 amount1Min;
 48 |     |     }
 49 |     | 
 50 |     |     /// @notice Add liquidity to an initialized pool
 51 |     |     function addLiquidity(AddLiquidityParams memory params)
 52 |     |         internal
 53 |     |         returns (
 54 |     |             uint128 liquidity,
 55 |     |             uint256 amount0,
 56 |     |             uint256 amount1,
 57 |     |             IUniswapV3Pool pool
 58 |     |         )
 59 |     |     {
 60 |     |         PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({
 61 |     |             token0: params.token0,
 62 |     |             token1: params.token1,
 63 |     |             fee: params.fee
 64 |     |         });
 65 |     | 
 66 |     |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));
 67 |     | 
 68 |     |         // compute the liquidity amount
 69 |     |         {
 70 |     |             (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
 71 |     |             uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);
 72 |     |             uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);
 73 |     | 
 74 |     |             liquidity = LiquidityAmounts.getLiquidityForAmounts(
 75 |     |                 sqrtPriceX96,
 76 |     |                 sqrtRatioAX96,
 77 |     |                 sqrtRatioBX96,
 78 |     |                 params.amount0Desired,
 79 |     |                 params.amount1Desired
 80 |     |             );
 81 |     |         }
 82 |     | 
 83 |     |         (amount0, amount1) = pool.mint(
 84 |     |             params.recipient,
 85 |     |             params.tickLower,
 86 |     |             params.tickUpper,
 87 |     |             liquidity,
 88 |     |             abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))
 89 |     |         );
 90 |     | 
 91 |     |         require(amount0 >= params.amount0Min && amount1 >= params.amount1Min, 'Price slippage check');
 92 |     |     }
 93 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/Multicall.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "../interfaces/IMulticall.sol";
  6 |     | 
  7 |     | /// @title Multicall
  8 |     | /// @notice Enables calling multiple methods in a single call to the contract
  9 |     | abstract contract Multicall is IMulticall {
 10 |     |     /// @inheritdoc IMulticall
 11 |     |     function multicall(bytes[] calldata data)
 12 |     |         public
 13 |     |         payable
 14 |     |         override
 15 |     |         returns (bytes[] memory results)
 16 |     |     {
 17 |     |         results = new bytes[](data.length);
 18 |     |         for (uint256 i = 0; i < data.length; i++) {
 19 |     |             (bool success, bytes memory result) = address(this).delegatecall(data[i]);
 20 |     | 
 21 |     |             if (!success) {
 22 |     |                 // Next 5 lines from https://ethereum.stackexchange.com/a/83577
 23 |     |                 if (result.length < 68) revert();
 24 |     |                 assembly {
 25 |     |                     result := add(result, 0x04)
 26 |     |                 }
 27 |     |                 revert(abi.decode(result, (string)));
 28 |     |             }
 29 |     | 
 30 |     |             results[i] = result;
 31 |     |         }
 32 |     |     }
 33 |     | }
 34 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "../interfaces/IPeripheryImmutableState.sol";
  5 |     | 
  6 |     | /// @title Immutable state
  7 |     | /// @notice Immutable state used by periphery contracts
  8 |     | abstract contract PeripheryImmutableState is IPeripheryImmutableState {
  9 |     |     /// @inheritdoc IPeripheryImmutableState
 10 |     |     address public immutable override factory;
 11 |     |     /// @inheritdoc IPeripheryImmutableState
 12 |     |     address public immutable override WETH9;
 13 |     | 
 14 |     |     constructor(address _factory, address _WETH9) {
 15 |     |         factory = _factory;
 16 |     |         WETH9 = _WETH9;
 17 |     |     }
 18 |     | }
 19 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryPayments.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | import "../interfaces/IPeripheryPayments.sol";
  7 |     | import "../interfaces/external/IWETH9.sol";
  8 |     | 
  9 |     | import "../libraries/TransferHelper.sol";
 10 |     | 
 11 |     | import "./PeripheryImmutableState.sol";
 12 |     | 
 13 |     | abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {
 14 |     |     receive() external payable {
 15 |     |         require(msg.sender == WETH9, "Not WETH9");
 16 |     |     }
 17 |     | 
 18 |     |     /// @inheritdoc IPeripheryPayments
 19 |     |     function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {
 20 |     |         uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));
 21 |     |         require(balanceWETH9 >= amountMinimum, "Insufficient WETH9");
 22 |     | 
 23 |     |         if (balanceWETH9 > 0) {
 24 |     |             IWETH9(WETH9).withdraw(balanceWETH9);
 25 |     |             TransferHelper.safeTransferETH(recipient, balanceWETH9);
 26 |     |         }
 27 |     |     }
 28 |     | 
 29 |     |     /// @inheritdoc IPeripheryPayments
 30 |     |     function sweepToken(
 31 |     |         address token,
 32 |     |         uint256 amountMinimum,
 33 |     |         address recipient
 34 |     |     ) public payable override {
 35 |     |         uint256 balanceToken = IERC20(token).balanceOf(address(this));
 36 |     |         require(balanceToken >= amountMinimum, "Insufficient token");
 37 |     | 
 38 |     |         if (balanceToken > 0) {
 39 |     |             TransferHelper.safeTransfer(token, recipient, balanceToken);
 40 |     |         }
 41 |     |     }
 42 |     | 
 43 |     |     /// @inheritdoc IPeripheryPayments
 44 |     |     function refundETH() external payable override {
 45 |     |         if (address(this).balance > 0) {
 46 |     |             TransferHelper.safeTransferETH(msg.sender, address(this).balance);
 47 |     |         }
 48 |     |     }
 49 |     | 
 50 |     |     /// @param token The token to pay
 51 |     |     /// @param payer The entity that must pay
 52 |     |     /// @param recipient The entity that will receive payment
 53 |     |     /// @param value The amount to pay
 54 |     |     function pay(address token, address payer, address recipient, uint256 value) internal {
 55 |     |         if (token == WETH9 && address(this).balance >= value) {
 56 |     |             // pay with WETH9
 57 |     |             IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay
 58 |     |             IWETH9(WETH9).transfer(recipient, value);
 59 |     |         } else if (payer == address(this)) {
 60 |     |             // pay with tokens already in the contract (for the exact input multihop case)
 61 |     |             TransferHelper.safeTransfer(token, recipient, value);
 62 |     |         } else {
 63 |     |             // pull payment
 64 |     |             TransferHelper.safeTransferFrom(token, payer, recipient, value);
 65 |     |         }
 66 |     |     }
 67 |     | }
 68 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryPaymentsWithFee.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
  5 |     | import "../libraries/LowGasSafeMath.sol";
  6 |     | 
  7 |     | import "./PeripheryPayments.sol";
  8 |     | import "../interfaces/IPeripheryPaymentsWithFee.sol";
  9 |     | 
 10 |     | import "../interfaces/external/IWETH9.sol";
 11 |     | import "../libraries/TransferHelper.sol";
 12 |     | 
 13 |     | abstract contract PeripheryPaymentsWithFee is PeripheryPayments, IPeripheryPaymentsWithFee {
 14 |     |     using LowGasSafeMath for uint256;
 15 |     | 
 16 |     |     /// @inheritdoc IPeripheryPaymentsWithFee
 17 |     |     function unwrapWETH9WithFee(
 18 |     |         uint256 amountMinimum,
 19 |     |         address recipient,
 20 |     |         uint256 feeBips,
 21 |     |         address feeRecipient
 22 |     |     ) public payable override {
 23 |     |         require(feeBips > 0 && feeBips <= 100);
 24 |     | 
 25 |     |         uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));
 26 |     |         require(balanceWETH9 >= amountMinimum, "Insufficient WETH9");
 27 |     | 
 28 |     |         if (balanceWETH9 > 0) {
 29 |     |             IWETH9(WETH9).withdraw(balanceWETH9);
 30 |     |             uint256 feeAmount = balanceWETH9.mul(feeBips) / 10_000;
 31 |     |             if (feeAmount > 0) TransferHelper.safeTransferETH(feeRecipient, feeAmount);
 32 |     |             TransferHelper.safeTransferETH(recipient, balanceWETH9 - feeAmount);
 33 |     |         }
 34 |     |     }
 35 |     | 
 36 |     |     /// @inheritdoc IPeripheryPaymentsWithFee
 37 |     |     function sweepTokenWithFee(
 38 |     |         address token,
 39 |     |         uint256 amountMinimum,
 40 |     |         address recipient,
 41 |     |         uint256 feeBips,
 42 |     |         address feeRecipient
 43 |     |     ) public payable override {
 44 |     |         require(feeBips > 0 && feeBips <= 100);
 45 |     | 
 46 |     |         uint256 balanceToken = IERC20(token).balanceOf(address(this));
 47 |     |         require(balanceToken >= amountMinimum, "Insufficient token");
 48 |     | 
 49 |     |         if (balanceToken > 0) {
 50 |     |             uint256 feeAmount = balanceToken.mul(feeBips) / 10_000;
 51 |     |             if (feeAmount > 0) TransferHelper.safeTransfer(token, feeRecipient, feeAmount);
 52 |     |             TransferHelper.safeTransfer(token, recipient, balanceToken - feeAmount);
 53 |     |         }
 54 |     |     }
 55 |     | }
 56 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryValidation.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./BlockTimestamp.sol";
  5 |     | 
  6 |     | abstract contract PeripheryValidation is BlockTimestamp {
  7 |     |     modifier checkDeadline(uint256 deadline) {
  8 |     |         require(_blockTimestamp() <= deadline, "Transaction too old");
  9 |     |         _;
 10 |     |     }
 11 |     | }
 12 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/SelfPermit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
  6 |     | 
  7 |     | import "../interfaces/ISelfPermit.sol";
  8 |     | import "../interfaces/external/IERC20PermitAllowed.sol";
  9 |     | 
 10 |     | /// @title Self Permit
 11 |     | /// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
 12 |     | /// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function
 13 |     | /// that requires an approval in a single transaction.
 14 |     | abstract contract SelfPermit is ISelfPermit {
 15 |     |     /// @inheritdoc ISelfPermit
 16 |     |     function selfPermit(
 17 |     |         address token,
 18 |     |         uint256 value,
 19 |     |         uint256 deadline,
 20 |     |         uint8 v,
 21 |     |         bytes32 r,
 22 |     |         bytes32 s
 23 |     |     ) public payable override {
 24 |     |         IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);
 25 |     |     }
 26 |     | 
 27 |     |     /// @inheritdoc ISelfPermit
 28 |     |     function selfPermitIfNecessary(
 29 |     |         address token,
 30 |     |         uint256 value,
 31 |     |         uint256 deadline,
 32 |     |         uint8 v,
 33 |     |         bytes32 r,
 34 |     |         bytes32 s
 35 |     |     ) external payable override {
 36 |     |         if (IERC20(token).allowance(msg.sender, address(this)) < value) {
 37 |     |             selfPermit(token, value, deadline, v, r, s);
 38 |     |         }
 39 |     |     }
 40 |     | 
 41 |     |     /// @inheritdoc ISelfPermit
 42 |     |     function selfPermitAllowed(
 43 |     |         address token,
 44 |     |         uint256 nonce,
 45 |     |         uint256 expiry,
 46 |     |         uint8 v,
 47 |     |         bytes32 r,
 48 |     |         bytes32 s
 49 |     |     ) public payable override {
 50 |     |         IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);
 51 |     |     }
 52 |     | 
 53 |     |     /// @inheritdoc ISelfPermit
 54 |     |     function selfPermitAllowedIfNecessary(
 55 |     |         address token,
 56 |     |         uint256 nonce,
 57 |     |         uint256 expiry,
 58 |     |         uint8 v,
 59 |     |         bytes32 r,
 60 |     |         bytes32 s
 61 |     |     ) external payable override {
 62 |     |         if (IERC20(token).allowance(msg.sender, address(this)) < type(uint256).max) {
 63 |     |             selfPermitAllowed(token, nonce, expiry, v, r, s);
 64 |     |         }
 65 |     |     }
 66 |     | }
 67 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IMulticall.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | /// @title Multicall interface
  6 |     | /// @notice Enables calling multiple methods in a single call to the contract
  7 |     | interface IMulticall {
  8 |     |     /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed
  9 |     |     /// @dev The `msg.value` should not be trusted for any method callable from multicall.
 10 |     |     /// @param data The encoded function data for each of the calls to make to this contract
 11 |     |     /// @return results The results from each of the calls passed in via data
 12 |     |     function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);
 13 |     | }
 14 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryImmutableState.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Immutable state
  5 |     | /// @notice Functions that return immutable state of the router
  6 |     | interface IPeripheryImmutableState {
  7 |     |     /// @return Returns the address of the Uniswap V3 factory
  8 |     |     function factory() external view returns (address);
  9 |     | 
 10 |     |     /// @return Returns the address of WETH9
 11 |     |     function WETH9() external view returns (address);
 12 |     | }
 13 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryPayments.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Periphery Payments
  5 |     | /// @notice Functions to ease deposits and withdrawals of ETH
  6 |     | interface IPeripheryPayments {
  7 |     |     /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.
  8 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
  9 |     |     /// @param amountMinimum The minimum amount of WETH9 to unwrap
 10 |     |     /// @param recipient The address receiving ETH
 11 |     |     function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;
 12 |     | 
 13 |     |     /// @notice Refunds any ETH balance held by this contract to the `msg.sender`
 14 |     |     /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps
 15 |     |     /// that use ether for the input amount
 16 |     |     function refundETH() external payable;
 17 |     | 
 18 |     |     /// @notice Transfers the full amount of a token held by this contract to recipient
 19 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
 20 |     |     /// @param token The contract address of the token which will be transferred to `recipient`
 21 |     |     /// @param amountMinimum The minimum amount of token required for a transfer
 22 |     |     /// @param recipient The destination address of the token
 23 |     |     function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;
 24 |     | }
 25 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryPaymentsWithFee.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./IPeripheryPayments.sol";
  5 |     | 
  6 |     | /// @title Periphery Payments
  7 |     | /// @notice Functions to ease deposits and withdrawals of ETH
  8 |     | interface IPeripheryPaymentsWithFee is IPeripheryPayments {
  9 |     |     /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between
 10 |     |     /// 0 (exclusive), and 1 (inclusive) going to feeRecipient
 11 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.
 12 |     |     function unwrapWETH9WithFee(
 13 |     |         uint256 amountMinimum,
 14 |     |         address recipient,
 15 |     |         uint256 feeBips,
 16 |     |         address feeRecipient
 17 |     |     ) external payable;
 18 |     | 
 19 |     |     /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between
 20 |     |     /// 0 (exclusive) and 1 (inclusive) going to feeRecipient
 21 |     |     /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users
 22 |     |     function sweepTokenWithFee(
 23 |     |         address token,
 24 |     |         uint256 amountMinimum,
 25 |     |         address recipient,
 26 |     |         uint256 feeBips,
 27 |     |         address feeRecipient
 28 |     |     ) external payable;
 29 |     | }
 30 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/ISelfPermit.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Self Permit
  5 |     | /// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route
  6 |     | interface ISelfPermit {
  7 |     |     /// @notice Permits this contract to spend a given token from `msg.sender`
  8 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
  9 |     |     /// @param token The address of the token spent
 10 |     |     /// @param value The amount that can be spent of token
 11 |     |     /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
 12 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 13 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 14 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 15 |     |     function selfPermit(
 16 |     |         address token,
 17 |     |         uint256 value,
 18 |     |         uint256 deadline,
 19 |     |         uint8 v,
 20 |     |         bytes32 r,
 21 |     |         bytes32 s
 22 |     |     ) external payable;
 23 |     | 
 24 |     |     /// @notice Permits this contract to spend a given token from `msg.sender`
 25 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this).
 26 |     |     /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit
 27 |     |     /// @param token The address of the token spent
 28 |     |     /// @param value The amount that can be spent of token
 29 |     |     /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp
 30 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 31 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 32 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 33 |     |     function selfPermitIfNecessary(
 34 |     |         address token,
 35 |     |         uint256 value,
 36 |     |         uint256 deadline,
 37 |     |         uint8 v,
 38 |     |         bytes32 r,
 39 |     |         bytes32 s
 40 |     |     ) external payable;
 41 |     | 
 42 |     |     /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
 43 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
 44 |     |     /// @param token The address of the token spent
 45 |     |     /// @param nonce The current nonce of the owner
 46 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 47 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 48 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 49 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 50 |     |     function selfPermitAllowed(
 51 |     |         address token,
 52 |     |         uint256 nonce,
 53 |     |         uint256 expiry,
 54 |     |         uint8 v,
 55 |     |         bytes32 r,
 56 |     |         bytes32 s
 57 |     |     ) external payable;
 58 |     | 
 59 |     |     /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter
 60 |     |     /// @dev The `owner` is always msg.sender and the `spender` is always address(this)
 61 |     |     /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.
 62 |     |     /// @param token The address of the token spent
 63 |     |     /// @param nonce The current nonce of the owner
 64 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 65 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 66 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 67 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 68 |     |     function selfPermitAllowedIfNecessary(
 69 |     |         address token,
 70 |     |         uint256 nonce,
 71 |     |         uint256 expiry,
 72 |     |         uint8 v,
 73 |     |         bytes32 r,
 74 |     |         bytes32 s
 75 |     |     ) external payable;
 76 |     | }
 77 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/ISwapRouter.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | pragma abicoder v2;
  4 |     | 
  5 |     | import "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol";
  6 |     | 
  7 |     | /// @title Router token swapping functionality
  8 |     | /// @notice Functions for swapping tokens via Uniswap V3
  9 |     | interface ISwapRouter is IUniswapV3SwapCallback {
 10 |     |     struct ExactInputSingleParams {
 11 |     |         address tokenIn;
 12 |     |         address tokenOut;
 13 |     |         uint24 fee;
 14 |     |         address recipient;
 15 |     |         uint256 deadline;
 16 |     |         uint256 amountIn;
 17 |     |         uint256 amountOutMinimum;
 18 |     |         uint160 sqrtPriceLimitX96;
 19 |     |     }
 20 |     | 
 21 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another token
 22 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata
 23 |     |     /// @return amountOut The amount of the received token
 24 |     |     function exactInputSingle(ExactInputSingleParams calldata params)
 25 |     |         external
 26 |     |         payable
 27 |     |         returns (uint256 amountOut);
 28 |     | 
 29 |     |     struct ExactInputParams {
 30 |     |         bytes path;
 31 |     |         address recipient;
 32 |     |         uint256 deadline;
 33 |     |         uint256 amountIn;
 34 |     |         uint256 amountOutMinimum;
 35 |     |     }
 36 |     | 
 37 |     |     /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path
 38 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata
 39 |     |     /// @return amountOut The amount of the received token
 40 |     |     function exactInput(ExactInputParams calldata params)
 41 |     |         external
 42 |     |         payable
 43 |     |         returns (uint256 amountOut);
 44 |     | 
 45 |     |     struct ExactOutputSingleParams {
 46 |     |         address tokenIn;
 47 |     |         address tokenOut;
 48 |     |         uint24 fee;
 49 |     |         address recipient;
 50 |     |         uint256 deadline;
 51 |     |         uint256 amountOut;
 52 |     |         uint256 amountInMaximum;
 53 |     |         uint160 sqrtPriceLimitX96;
 54 |     |     }
 55 |     | 
 56 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another token
 57 |     |     /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata
 58 |     |     /// @return amountIn The amount of the input token
 59 |     |     function exactOutputSingle(ExactOutputSingleParams calldata params)
 60 |     |         external
 61 |     |         payable
 62 |     |         returns (uint256 amountIn);
 63 |     | 
 64 |     |     struct ExactOutputParams {
 65 |     |         bytes path;
 66 |     |         address recipient;
 67 |     |         uint256 deadline;
 68 |     |         uint256 amountOut;
 69 |     |         uint256 amountInMaximum;
 70 |     |     }
 71 |     | 
 72 |     |     /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)
 73 |     |     /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata
 74 |     |     /// @return amountIn The amount of the input token
 75 |     |     function exactOutput(ExactOutputParams calldata params)
 76 |     |         external
 77 |     |         payable
 78 |     |         returns (uint256 amountIn);
 79 |     | }
 80 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/external/IERC20PermitAllowed.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Interface for permit
  5 |     | /// @notice Interface used by DAI/CHAI for permit
  6 |     | interface IERC20PermitAllowed {
  7 |     |     /// @notice Approve the spender to spend some tokens via the holder signature
  8 |     |     /// @dev This is the permit interface used by DAI and CHAI
  9 |     |     /// @param holder The address of the token holder, the token owner
 10 |     |     /// @param spender The address of the token spender
 11 |     |     /// @param nonce The holder's nonce, increases at each call to permit
 12 |     |     /// @param expiry The timestamp at which the permit is no longer valid
 13 |     |     /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0
 14 |     |     /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`
 15 |     |     /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`
 16 |     |     /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`
 17 |     |     function permit(
 18 |     |         address holder,
 19 |     |         address spender,
 20 |     |         uint256 nonce,
 21 |     |         uint256 expiry,
 22 |     |         bool allowed,
 23 |     |         uint8 v,
 24 |     |         bytes32 r,
 25 |     |         bytes32 s
 26 |     |     ) external;
 27 |     | }
 28 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/external/IWETH9.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | /// @title Interface for WETH9
  7 |     | interface IWETH9 is IERC20 {
  8 |     |     /// @notice Deposit ether to get wrapped ether
  9 |     |     function deposit() external payable;
 10 |     | 
 11 |     |     /// @notice Withdraw wrapped ether to get ether
 12 |     |     function withdraw(uint256) external;
 13 |     | }
 14 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/BytesLib.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | /*
   3 |     |  * @title Solidity Bytes Arrays Utils
   4 |     |  * @author Gonalo S <goncalo.sa@consensys.net>
   5 |     |  *
   6 |     |  * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.
   7 |     |  *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.
   8 |     |  */
   9 |     | pragma solidity ^0.8.0;
  10 |     | 
  11 |     | library BytesLib {
  12 |     |     function slice(
  13 |     |         bytes memory _bytes,
  14 |     |         uint256 _start,
  15 |     |         uint256 _length
  16 |     |     ) internal pure returns (bytes memory) {
  17 |     |         require(_length + 31 >= _length, "slice_overflow");
  18 |     |         require(_start + _length >= _start, "slice_overflow");
  19 |     |         require(_bytes.length >= _start + _length, "slice_outOfBounds");
  20 |     | 
  21 |     |         bytes memory tempBytes;
  22 |     | 
  23 |     |         assembly {
  24 |     |             switch iszero(_length)
  25 |     |             case 0 {
  26 |     |                 // Get a location of some free memory and store it in tempBytes as
  27 |     |                 // Solidity does for memory variables.
  28 |     |                 tempBytes := mload(0x40)
  29 |     | 
  30 |     |                 // The first word of the slice result is potentially a partial
  31 |     |                 // word read from the original array. To read it, we calculate
  32 |     |                 // the length of that partial word and start copying that many
  33 |     |                 // bytes into the array. The first word we copy will start with
  34 |     |                 // data we don't care about, but the last `lengthmod` bytes will
  35 |     |                 // land at the beginning of the contents of the new array. When
  36 |     |                 // we're done copying, we overwrite the full first word with
  37 |     |                 // the actual length of the slice.
  38 |     |                 let lengthmod := and(_length, 31)
  39 |     | 
  40 |     |                 // The multiplication in the next line is necessary
  41 |     |                 // because when slicing multiples of 32 bytes (lengthmod == 0)
  42 |     |                 // the following copy loop was copying the origin's length
  43 |     |                 // and then ending prematurely not copying everything it should.
  44 |     |                 let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))
  45 |     |                 let end := add(mc, _length)
  46 |     | 
  47 |     |                 for {
  48 |     |                     // The multiplication in the next line has the same exact purpose
  49 |     |                     // as the one above.
  50 |     |                     let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)
  51 |     |                 } lt(mc, end) {
  52 |     |                     mc := add(mc, 0x20)
  53 |     |                     cc := add(cc, 0x20)
  54 |     |                 } { mstore(mc, mload(cc)) }
  55 |     | 
  56 |     |                 mstore(tempBytes, _length)
  57 |     | 
  58 |     |                 //update free-memory pointer
  59 |     |                 //allocating the array padded to 32 bytes like the compiler does now
  60 |     |                 mstore(0x40, and(add(mc, 31), not(31)))
  61 |     |             }
  62 |     |             //if we want a zero-length slice let's just return a zero-length array
  63 |     |             default {
  64 |     |                 tempBytes := mload(0x40)
  65 |     |                 //zero out the 32 bytes slice we are about to return
  66 |     |                 //we need to do it because Solidity does not garbage collect
  67 |     |                 mstore(tempBytes, 0)
  68 |     | 
  69 |     |                 mstore(0x40, add(tempBytes, 0x20))
  70 |     |             }
  71 |     |         }
  72 |     | 
  73 |     |         return tempBytes;
  74 |     |     }
  75 |     | 
  76 |     |     function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {
  77 |     |         require(_start + 20 >= _start, "toAddress_overflow");
  78 |     |         require(_bytes.length >= _start + 20, "toAddress_outOfBounds");
  79 |     |         address tempAddress;
  80 |     | 
  81 |     |         assembly {
  82 |     |             tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)
  83 |     |         }
  84 |     | 
  85 |     |         return tempAddress;
  86 |     |     }
  87 |     | 
  88 |     |     function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {
  89 |     |         require(_start + 3 >= _start, "toUint24_overflow");
  90 |     |         require(_bytes.length >= _start + 3, "toUint24_outOfBounds");
  91 |     |         uint24 tempUint;
  92 |     | 
  93 |     |         assembly {
  94 |     |             tempUint := mload(add(add(_bytes, 0x3), _start))
  95 |     |         }
  96 |     | 
  97 |     |         return tempUint;
  98 |     |     }
  99 |     | }
 100 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/CallbackValidation.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "v3-core/interfaces/IUniswapV3Pool.sol";
  5 |     | import "v3-core/interfaces/IUniswapV3Factory.sol";
  6 |     | import "./PoolAddress.sol";
  7 |     | 
  8 |     | /// @notice Provides validation for callbacks from Uniswap V3 Pools
  9 |     | library CallbackValidation {
 10 |     |     /// @notice Returns the address of a valid Uniswap V3 Pool
 11 |     |     /// @param factory The contract address of the Uniswap V3 factory
 12 |     |     /// @param tokenA The contract address of either token0 or token1
 13 |     |     /// @param tokenB The contract address of the other token
 14 |     |     /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip
 15 |     |     /// @return pool The V3 pool contract address
 16 |     |     function verifyCallback(
 17 |     |         address factory,
 18 |     |         address tokenA,
 19 |     |         address tokenB,
 20 |     |         uint24 fee
 21 |     |     ) internal view returns (IUniswapV3Pool pool) {
 22 |     |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee));
 23 |     |         require(msg.sender == address(pool));
 24 |     |     }
 25 |     | 
 26 |     |     /// @notice Returns the address of a valid Uniswap V3 Pool
 27 |     |     /// @param factory The contract address of the Uniswap V3 factory
 28 |     |     /// @param poolKey The identifying key of the V3 pool
 29 |     |     /// @return pool The V3 pool contract address
 30 |     |     function verifyCallback(
 31 |     |         address factory,
 32 |     |         PoolAddress.PoolKey memory poolKey
 33 |     |     ) internal view returns (IUniswapV3Pool pool) {
 34 |     |         pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));
 35 |     |         require(msg.sender == address(pool));
 36 |     |     }
 37 |     | }
 38 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/LiquidityAmounts.sol
   1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
   2 |     | pragma solidity >=0.8.0;
   3 |     | 
   4 |     | import 'v3-core/libraries/FullMath.sol';
   5 |     | import 'v3-core/libraries/FixedPoint96.sol';
   6 |     | 
   7 |     | /// @title Liquidity amount functions
   8 |     | /// @notice Provides functions for computing liquidity amounts from token amounts and prices
   9 |     | library LiquidityAmounts {
  10 |     |     /// @notice Downcasts uint256 to uint128
  11 |     |     /// @param x The uint258 to be downcasted
  12 |     |     /// @return y The passed value, downcasted to uint128
  13 |     |     function toUint128(uint256 x) private pure returns (uint128 y) {
  14 |     |         require((y = uint128(x)) == x);
  15 |     |     }
  16 |     | 
  17 |     |     /// @notice Computes the amount of liquidity received for a given amount of token0 and price range
  18 |     |     /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))
  19 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  20 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  21 |     |     /// @param amount0 The amount0 being sent in
  22 |     |     /// @return liquidity The amount of returned liquidity
  23 |     |     function getLiquidityForAmount0(
  24 |     |         uint160 sqrtRatioAX96,
  25 |     |         uint160 sqrtRatioBX96,
  26 |     |         uint256 amount0
  27 |     |     ) internal pure returns (uint128 liquidity) {
  28 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  29 |     |         uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);
  30 |     |         unchecked {
  31 |     |             return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));
  32 |     |         }
  33 |     |     }
  34 |     | 
  35 |     |     /// @notice Computes the amount of liquidity received for a given amount of token1 and price range
  36 |     |     /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).
  37 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  38 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  39 |     |     /// @param amount1 The amount1 being sent in
  40 |     |     /// @return liquidity The amount of returned liquidity
  41 |     |     function getLiquidityForAmount1(
  42 |     |         uint160 sqrtRatioAX96,
  43 |     |         uint160 sqrtRatioBX96,
  44 |     |         uint256 amount1
  45 |     |     ) internal pure returns (uint128 liquidity) {
  46 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  47 |     |         unchecked {
  48 |     |             return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));
  49 |     |         }
  50 |     |     }
  51 |     | 
  52 |     |     /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current
  53 |     |     /// pool prices and the prices at the tick boundaries
  54 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
  55 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  56 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  57 |     |     /// @param amount0 The amount of token0 being sent in
  58 |     |     /// @param amount1 The amount of token1 being sent in
  59 |     |     /// @return liquidity The maximum amount of liquidity received
  60 |     |     function getLiquidityForAmounts(
  61 |     |         uint160 sqrtRatioX96,
  62 |     |         uint160 sqrtRatioAX96,
  63 |     |         uint160 sqrtRatioBX96,
  64 |     |         uint256 amount0,
  65 |     |         uint256 amount1
  66 |     |     ) internal pure returns (uint128 liquidity) {
  67 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  68 |     | 
  69 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
  70 |     |             liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);
  71 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
  72 |     |             uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);
  73 |     |             uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);
  74 |     | 
  75 |     |             liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;
  76 |     |         } else {
  77 |     |             liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);
  78 |     |         }
  79 |     |     }
  80 |     | 
  81 |     |     /// @notice Computes the amount of token0 for a given amount of liquidity and a price range
  82 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
  83 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
  84 |     |     /// @param liquidity The liquidity being valued
  85 |     |     /// @return amount0 The amount of token0
  86 |     |     function getAmount0ForLiquidity(
  87 |     |         uint160 sqrtRatioAX96,
  88 |     |         uint160 sqrtRatioBX96,
  89 |     |         uint128 liquidity
  90 |     |     ) internal pure returns (uint256 amount0) {
  91 |     |         unchecked {
  92 |     |             if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
  93 |     | 
  94 |     |             return
  95 |     |                 FullMath.mulDiv(
  96 |     |                     uint256(liquidity) << FixedPoint96.RESOLUTION,
  97 |     |                     sqrtRatioBX96 - sqrtRatioAX96,
  98 |     |                     sqrtRatioBX96
  99 |     |                 ) / sqrtRatioAX96;
 100 |     |         }
 101 |     |     }
 102 |     | 
 103 |     |     /// @notice Computes the amount of token1 for a given amount of liquidity and a price range
 104 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
 105 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 106 |     |     /// @param liquidity The liquidity being valued
 107 |     |     /// @return amount1 The amount of token1
 108 |     |     function getAmount1ForLiquidity(
 109 |     |         uint160 sqrtRatioAX96,
 110 |     |         uint160 sqrtRatioBX96,
 111 |     |         uint128 liquidity
 112 |     |     ) internal pure returns (uint256 amount1) {
 113 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 114 |     | 
 115 |     |         unchecked {
 116 |     |             return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);
 117 |     |         }
 118 |     |     }
 119 |     | 
 120 |     |     /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current
 121 |     |     /// pool prices and the prices at the tick boundaries
 122 |     |     /// @param sqrtRatioX96 A sqrt price representing the current pool prices
 123 |     |     /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary
 124 |     |     /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary
 125 |     |     /// @param liquidity The liquidity being valued
 126 |     |     /// @return amount0 The amount of token0
 127 |     |     /// @return amount1 The amount of token1
 128 |     |     function getAmountsForLiquidity(
 129 |     |         uint160 sqrtRatioX96,
 130 |     |         uint160 sqrtRatioAX96,
 131 |     |         uint160 sqrtRatioBX96,
 132 |     |         uint128 liquidity
 133 |     |     ) internal pure returns (uint256 amount0, uint256 amount1) {
 134 |     |         if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);
 135 |     | 
 136 |     |         if (sqrtRatioX96 <= sqrtRatioAX96) {
 137 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 138 |     |         } else if (sqrtRatioX96 < sqrtRatioBX96) {
 139 |     |             amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);
 140 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);
 141 |     |         } else {
 142 |     |             amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);
 143 |     |         }
 144 |     |     }
 145 |     | }

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/LowGasSafeMath.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Optimized overflow and underflow safe math operations
  5 |     | /// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost
  6 |     | library LowGasSafeMath {
  7 |     |     /// @notice Returns x + y, reverts if sum overflows uint256
  8 |     |     /// @param x The augend
  9 |     |     /// @param y The addend
 10 |     |     /// @return z The sum of x and y
 11 |     |     function add(uint256 x, uint256 y) internal pure returns (uint256 z) {
 12 |     |         require((z = x + y) >= x);
 13 |     |     }
 14 |     | 
 15 |     |     /// @notice Returns x - y, reverts if underflows
 16 |     |     /// @param x The minuend
 17 |     |     /// @param y The subtrahend
 18 |     |     /// @return z The difference of x and y
 19 |     |     function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {
 20 |     |         require((z = x - y) <= x);
 21 |     |     }
 22 |     | 
 23 |     |     /// @notice Returns x * y, reverts if overflows
 24 |     |     /// @param x The multiplicand
 25 |     |     /// @param y The multiplier
 26 |     |     /// @return z The product of x and y
 27 |     |     function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {
 28 |     |         require(x == 0 || (z = x * y) / x == y);
 29 |     |     }
 30 |     | 
 31 |     |     /// @notice Returns x + y, reverts if overflows or underflows
 32 |     |     /// @param x The augend
 33 |     |     /// @param y The addend
 34 |     |     /// @return z The sum of x and y
 35 |     |     function add(int256 x, int256 y) internal pure returns (int256 z) {
 36 |     |         require((z = x + y) >= x == (y >= 0));
 37 |     |     }
 38 |     | 
 39 |     |     /// @notice Returns x - y, reverts if overflows or underflows
 40 |     |     /// @param x The minuend
 41 |     |     /// @param y The subtrahend
 42 |     |     /// @return z The difference of x and y
 43 |     |     function sub(int256 x, int256 y) internal pure returns (int256 z) {
 44 |     |         require((z = x - y) <= x == (y >= 0));
 45 |     |     }
 46 |     | }
 47 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/Path.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "./BytesLib.sol";
  5 |     | 
  6 |     | /// @title Functions for manipulating path data for multihop swaps
  7 |     | library Path {
  8 |     |     using BytesLib for bytes;
  9 |     | 
 10 |     |     /// @dev The length of the bytes encoded address
 11 |     |     uint256 private constant ADDR_SIZE = 20;
 12 |     |     /// @dev The length of the bytes encoded fee
 13 |     |     uint256 private constant FEE_SIZE = 3;
 14 |     | 
 15 |     |     /// @dev The offset of a single token address and pool fee
 16 |     |     uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;
 17 |     |     /// @dev The offset of an encoded pool key
 18 |     |     uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;
 19 |     |     /// @dev The minimum length of an encoding that contains 2 or more pools
 20 |     |     uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;
 21 |     | 
 22 |     |     /// @notice Returns true iff the path contains two or more pools
 23 |     |     /// @param path The encoded swap path
 24 |     |     /// @return True if path contains two or more pools, otherwise false
 25 |     |     function hasMultiplePools(bytes memory path) internal pure returns (bool) {
 26 |     |         return path.length >= MULTIPLE_POOLS_MIN_LENGTH;
 27 |     |     }
 28 |     | 
 29 |     |     /// @notice Returns the number of pools in the path
 30 |     |     /// @param path The encoded swap path
 31 |     |     /// @return The number of pools in the path
 32 |     |     function numPools(bytes memory path) internal pure returns (uint256) {
 33 |     |         // Ignore the first token address. From then on every fee and token offset indicates a pool.
 34 |     |         return ((path.length - ADDR_SIZE) / NEXT_OFFSET);
 35 |     |     }
 36 |     | 
 37 |     |     /// @notice Decodes the first pool in path
 38 |     |     /// @param path The bytes encoded swap path
 39 |     |     /// @return tokenA The first token of the given pool
 40 |     |     /// @return tokenB The second token of the given pool
 41 |     |     /// @return fee The fee level of the pool
 42 |     |     function decodeFirstPool(bytes memory path)
 43 |     |         internal
 44 |     |         pure
 45 |     |         returns (address tokenA, address tokenB, uint24 fee)
 46 |     |     {
 47 |     |         tokenA = path.toAddress(0);
 48 |     |         fee = path.toUint24(ADDR_SIZE);
 49 |     |         tokenB = path.toAddress(NEXT_OFFSET);
 50 |     |     }
 51 |     | 
 52 |     |     /// @notice Gets the segment corresponding to the first pool in the path
 53 |     |     /// @param path The bytes encoded swap path
 54 |     |     /// @return The segment containing all data necessary to target the first pool in the path
 55 |     |     function getFirstPool(bytes memory path) internal pure returns (bytes memory) {
 56 |     |         return path.slice(0, POP_OFFSET);
 57 |     |     }
 58 |     | 
 59 |     |     /// @notice Skips a token + fee element from the buffer and returns the remainder
 60 |     |     /// @param path The swap path
 61 |     |     /// @return The remaining token + fee elements in the path
 62 |     |     function skipToken(bytes memory path) internal pure returns (bytes memory) {
 63 |     |         return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);
 64 |     |     }
 65 |     | }
 66 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/PoolAddress.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | /// @title Provides functions for deriving a pool address from the factory, tokens, and the fee
  5 |     | library PoolAddress {
  6 |     |     bytes32 internal constant POOL_INIT_CODE_HASH =
  7 |     |         0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;
  8 |     | 
  9 |     |     /// @notice The identifying key of the pool
 10 |     |     struct PoolKey {
 11 |     |         address token0;
 12 |     |         address token1;
 13 |     |         uint24 fee;
 14 |     |     }
 15 |     | 
 16 |     |     /// @notice Returns PoolKey: the ordered tokens with the matched fee levels
 17 |     |     /// @param tokenA The first token of a pool, unsorted
 18 |     |     /// @param tokenB The second token of a pool, unsorted
 19 |     |     /// @param fee The fee level of the pool
 20 |     |     /// @return Poolkey The pool details with ordered token0 and token1 assignments
 21 |     |     function getPoolKey(
 22 |     |         address tokenA,
 23 |     |         address tokenB,
 24 |     |         uint24 fee
 25 |     |     ) internal pure returns (PoolKey memory) {
 26 |     |         if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);
 27 |     |         return PoolKey({token0: tokenA, token1: tokenB, fee: fee});
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Deterministically computes the pool address given the factory and PoolKey
 31 |     |     /// @param factory The Uniswap V3 factory contract address
 32 |     |     /// @param key The PoolKey
 33 |     |     /// @return pool The contract address of the V3 pool
 34 |     |     function computeAddress(
 35 |     |         address factory,
 36 |     |         PoolKey memory key
 37 |     |     ) internal pure returns (address pool) {
 38 |     |         require(key.token0 < key.token1);
 39 |     |         pool = address(
 40 |     |             uint160(
 41 |     |                 uint256(
 42 |     |                     keccak256(
 43 |     |                         abi.encodePacked(
 44 |     |                             hex"ff",
 45 |     |                             factory,
 46 |     |                             keccak256(abi.encode(key.token0, key.token1, key.fee)),
 47 |     |                             POOL_INIT_CODE_HASH
 48 |     |                         )
 49 |     |                     )
 50 |     |                 )
 51 |     |             )
 52 |     |         );
 53 |     |     }
 54 |     | }
 55 |     | 

/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/TransferHelper.sol
  1 |     | // SPDX-License-Identifier: GPL-2.0-or-later
  2 |     | pragma solidity ^0.8.0;
  3 |     | 
  4 |     | import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
  5 |     | 
  6 |     | library TransferHelper {
  7 |     |     /// @notice Transfers tokens from the targeted address to the given destination
  8 |     |     /// @notice Errors with 'STF' if transfer fails
  9 |     |     /// @param token The contract address of the token to be transferred
 10 |     |     /// @param from The originating address from which the tokens will be transferred
 11 |     |     /// @param to The destination address of the transfer
 12 |     |     /// @param value The amount to be transferred
 13 |     |     function safeTransferFrom(address token, address from, address to, uint256 value) internal {
 14 |     |         (bool success, bytes memory data) =
 15 |     |             token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));
 16 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "STF");
 17 |     |     }
 18 |     | 
 19 |     |     /// @notice Transfers tokens from msg.sender to a recipient
 20 |     |     /// @dev Errors with ST if transfer fails
 21 |     |     /// @param token The contract address of the token which will be transferred
 22 |     |     /// @param to The recipient of the transfer
 23 |     |     /// @param value The value of the transfer
 24 |     |     function safeTransfer(address token, address to, uint256 value) internal {
 25 |     |         (bool success, bytes memory data) =
 26 |     |             token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));
 27 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "ST");
 28 |     |     }
 29 |     | 
 30 |     |     /// @notice Approves the stipulated contract to spend the given allowance in the given token
 31 |     |     /// @dev Errors with 'SA' if transfer fails
 32 |     |     /// @param token The contract address of the token to be approved
 33 |     |     /// @param to The target of the approval
 34 |     |     /// @param value The amount of the given token the target will be allowed to spend
 35 |     |     function safeApprove(address token, address to, uint256 value) internal {
 36 |     |         (bool success, bytes memory data) =
 37 |     |             token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));
 38 |     |         require(success && (data.length == 0 || abi.decode(data, (bool))), "SA");
 39 |     |     }
 40 |     | 
 41 |     |     /// @notice Transfers ETH to the recipient address
 42 |     |     /// @dev Fails with `STE`
 43 |     |     /// @param to The destination of the transfer
 44 |     |     /// @param value The value to be transferred
 45 |     |     function safeTransferETH(address to, uint256 value) internal {
 46 |     |         (bool success,) = to.call{value: value}(new bytes(0));
 47 |     |         require(success, "STE");
 48 |     |     }
 49 |     | }
 50 |     | 

