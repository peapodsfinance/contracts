<style> code { white-space: pre-wrap; display: block; background-color: #eee; }.executed { background-color: #afa; }.reverted { background-color: #ffa; }.unexecuted { background-color: #faa; }.neutral { background-color: #eee; }</style><b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/AutoCompoundingPodLp.sol</b>
<code>
   1 |     | <span class='unexecuted'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./interfaces/IDecentralizedIndex.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./interfaces/IIndexUtils.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./interfaces/IRewardsWhitelister.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./interfaces/IV3TwapUtilities.sol&#39;;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>contract AutoCompoundingPodLp is IERC4626, ERC20, ERC20Permit, Ownable {</span>
  18 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>  struct Pools {</span>
  21 |     | <span class='neutral'>    address pool1;</span>
  22 |     | <span class='neutral'>    address pool2;</span>
  23 |     | <span class='neutral'>  }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>  event TokenToPairedLpSwapError(</span>
  26 |     | <span class='neutral'>    address rewardsToken,</span>
  27 |     | <span class='neutral'>    address pairedLpToken,</span>
  28 |     | <span class='neutral'>    uint256 amountIn</span>
  29 |     | <span class='neutral'>  );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>  uint256 constant FACTOR = 10 ** 18;</span>
  32 |     | <span class='unexecuted'>  uint24 constant REWARDS_POOL_FEE = 10000;</span>
  33 |     | <span class='unexecuted'>  uint256 constant LP_SLIPPAGE = 80; // 8%</span>
  34 |     | <span class='unexecuted'>  uint256 constant REWARDS_SWAP_SLIPPAGE = 20; // 2%</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>  IDexAdapter immutable DEX_ADAPTER;</span>
  37 |     | <span class='neutral'>  IV3TwapUtilities immutable V3_TWAP_UTILS;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>  IDecentralizedIndex public pod;</span>
  40 |     | <span class='unexecuted'>  IIndexUtils public indexUtils;</span>
  41 |     | <span class='unexecuted'>  IRewardsWhitelister public rewardsWhitelister;</span>
  42 |     | <span class='unexecuted'>  bool public yieldConvEnabled = true;</span>
  43 |     | <span class='unexecuted'>  uint16 public protocolFee = 50; // 1000 precision</span>
  44 |     | <span class='neutral'>  // token in =&gt; token out =&gt; swap pool(s)</span>
  45 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; Pools)) public swapMaps;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>  // inputTkn =&gt; outputTkn =&gt; amountInOverride</span>
  48 |     | <span class='neutral'>  mapping(address =&gt; mapping(address =&gt; uint256)) _tokenToPairedSwapAmountInOverride;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>  // internal tracking</span>
  51 |     | <span class='neutral'>  uint256 _totalAssets;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>  /// @notice can pass _pod as null address and set later if need be</span>
  54 |     | <span class='unexecuted'>  constructor(</span>
  55 |     | <span class='neutral'>    string memory _name,</span>
  56 |     | <span class='neutral'>    string memory _symbol,</span>
  57 |     | <span class='neutral'>    IDecentralizedIndex _pod,</span>
  58 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  59 |     | <span class='neutral'>    IIndexUtils _utils,</span>
  60 |     | <span class='neutral'>    IRewardsWhitelister _whitelist,</span>
  61 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities</span>
  62 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) ERC20Permit(_name) {</span>
  63 |     | <span class='unexecuted'>    DEX_ADAPTER = _dexAdapter;</span>
  64 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  65 |     | <span class='unexecuted'>    pod = _pod;</span>
  66 |     | <span class='unexecuted'>    indexUtils = _utils;</span>
  67 |     | <span class='unexecuted'>    rewardsWhitelister = _whitelist;</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>  function asset() external view override returns (address) {</span>
  71 |     | <span class='unexecuted'>    return _asset();</span>
  72 |     | <span class='neutral'>  }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>  function totalAssets() public view override returns (uint256) {</span>
  75 |     | <span class='unexecuted'>    return _totalAssets;</span>
  76 |     | <span class='neutral'>  }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='unexecuted'>  function convertToShares(</span>
  79 |     | <span class='neutral'>    uint256 _assets</span>
  80 |     | <span class='unexecuted'>  ) public view override returns (uint256 _shares) {</span>
  81 |     | <span class='unexecuted'>    return (_assets * FACTOR) / _cbr();</span>
  82 |     | <span class='neutral'>  }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>  function convertToAssets(</span>
  85 |     | <span class='neutral'>    uint256 _shares</span>
  86 |     | <span class='unexecuted'>  ) public view override returns (uint256 _assets) {</span>
  87 |     | <span class='unexecuted'>    return (_shares * _cbr()) / FACTOR;</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>  function maxDeposit(</span>
  91 |     | <span class='neutral'>    address</span>
  92 |     | <span class='unexecuted'>  ) external pure override returns (uint256 maxAssets) {</span>
  93 |     | <span class='unexecuted'>    return type(uint256).max - 1;</span>
  94 |     | <span class='neutral'>  }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>  function previewDeposit(</span>
  97 |     | <span class='neutral'>    uint256 _assets</span>
  98 |     | <span class='neutral'>  ) external view override returns (uint256 _shares) {</span>
  99 |     | <span class='neutral'>    return convertToShares(_assets);</span>
 100 |     | <span class='neutral'>  }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>  function deposit(</span>
 103 |     | <span class='neutral'>    uint256 _assets,</span>
 104 |     | <span class='neutral'>    address _receiver</span>
 105 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
 106 |     | <span class='unexecuted'>    return _deposit(_assets, _receiver);</span>
 107 |     | <span class='neutral'>  }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>  function _deposit(</span>
 110 |     | <span class='neutral'>    uint256 _assets,</span>
 111 |     | <span class='neutral'>    address _receiver</span>
 112 |     | <span class='unexecuted'>  ) internal returns (uint256 _shares) {</span>
 113 |     | <span class='unexecuted'>    require(_assets != 0, &#39;M&#39;);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>    _processRewardsToPodLp(0, block.timestamp);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 118 |     | <span class='unexecuted'>    _totalAssets += _assets;</span>
 119 |     | <span class='unexecuted'>    IERC20(_asset()).safeTransferFrom(_msgSender(), address(this), _assets);</span>
 120 |     | <span class='unexecuted'>    _mint(_receiver, _shares);</span>
 121 |     | <span class='unexecuted'>    emit Deposit(_msgSender(), _receiver, _assets, _shares);</span>
 122 |     | <span class='neutral'>  }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>  function maxMint(address) external pure override returns (uint256 maxShares) {</span>
 125 |     | <span class='neutral'>    maxShares = type(uint256).max - 1;</span>
 126 |     | <span class='neutral'>  }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>  function previewMint(</span>
 129 |     | <span class='neutral'>    uint256 _shares</span>
 130 |     | <span class='neutral'>  ) external view override returns (uint256 _assets) {</span>
 131 |     | <span class='neutral'>    _assets = convertToAssets(_shares);</span>
 132 |     | <span class='neutral'>  }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>  function mint(</span>
 135 |     | <span class='neutral'>    uint256 _shares,</span>
 136 |     | <span class='neutral'>    address _receiver</span>
 137 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 138 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 139 |     | <span class='unexecuted'>    _deposit(_assets, _receiver);</span>
 140 |     | <span class='neutral'>  }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>  function maxWithdraw(</span>
 143 |     | <span class='neutral'>    address _owner</span>
 144 |     | <span class='unexecuted'>  ) external view override returns (uint256 maxAssets) {</span>
 145 |     | <span class='unexecuted'>    maxAssets = (balanceOf(_owner) * _cbr()) / FACTOR;</span>
 146 |     | <span class='neutral'>  }</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='unexecuted'>  function previewWithdraw(</span>
 149 |     | <span class='neutral'>    uint256 _assets</span>
 150 |     | <span class='unexecuted'>  ) external view override returns (uint256 _shares) {</span>
 151 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 152 |     | <span class='neutral'>  }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>  function withdraw(</span>
 155 |     | <span class='neutral'>    uint256 _assets,</span>
 156 |     | <span class='neutral'>    address _receiver,</span>
 157 |     | <span class='neutral'>    address</span>
 158 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
 159 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 160 |     | <span class='unexecuted'>    _withdraw(_shares, _receiver);</span>
 161 |     | <span class='neutral'>  }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>  function maxRedeem(</span>
 164 |     | <span class='neutral'>    address _owner</span>
 165 |     | <span class='unexecuted'>  ) external view override returns (uint256 _maxShares) {</span>
 166 |     | <span class='unexecuted'>    _maxShares = balanceOf(_owner);</span>
 167 |     | <span class='neutral'>  }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='unexecuted'>  function previewRedeem(</span>
 170 |     | <span class='neutral'>    uint256 _shares</span>
 171 |     | <span class='unexecuted'>  ) external view override returns (uint256 _assets) {</span>
 172 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 173 |     | <span class='neutral'>  }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>  function redeem(</span>
 176 |     | <span class='neutral'>    uint256 _shares,</span>
 177 |     | <span class='neutral'>    address _receiver,</span>
 178 |     | <span class='neutral'>    address</span>
 179 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 180 |     | <span class='unexecuted'>    _assets = _withdraw(_shares, _receiver);</span>
 181 |     | <span class='neutral'>  }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>  function processAllRewardsTokensToPodLp(</span>
 184 |     | <span class='neutral'>    uint256 _amountLpOutMin,</span>
 185 |     | <span class='neutral'>    uint256 _deadline</span>
 186 |     | <span class='unexecuted'>  ) external onlyOwner returns (uint256) {</span>
 187 |     | <span class='unexecuted'>    return _processRewardsToPodLp(_amountLpOutMin, _deadline);</span>
 188 |     | <span class='neutral'>  }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='unexecuted'>  function _withdraw(</span>
 191 |     | <span class='neutral'>    uint256 _shares,</span>
 192 |     | <span class='neutral'>    address _receiver</span>
 193 |     | <span class='unexecuted'>  ) internal returns (uint256 _assets) {</span>
 194 |     | <span class='unexecuted'>    require(_shares != 0, &#39;B&#39;);</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='unexecuted'>    _processRewardsToPodLp(0, block.timestamp);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 199 |     | <span class='unexecuted'>    _burn(_msgSender(), _shares);</span>
 200 |     | <span class='unexecuted'>    IERC20(_asset()).safeTransfer(_receiver, _assets);</span>
 201 |     | <span class='unexecuted'>    _totalAssets -= _assets;</span>
 202 |     | <span class='unexecuted'>    emit Withdraw(_msgSender(), _receiver, _receiver, _assets, _shares);</span>
 203 |     | <span class='neutral'>  }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>  // @notice: assumes underlying vault asset has decimals == 18</span>
 206 |     | <span class='unexecuted'>  function _cbr() internal view returns (uint256) {</span>
 207 |     | <span class='unexecuted'>    uint256 _supply = totalSupply();</span>
 208 |     | <span class='unexecuted'>    return _supply == 0 ? FACTOR : (FACTOR * totalAssets()) / _supply;</span>
 209 |     | <span class='neutral'>  }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='unexecuted'>  function _asset() internal view returns (address) {</span>
 212 |     | <span class='unexecuted'>    return pod.lpStakingPool();</span>
 213 |     | <span class='neutral'>  }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>  function _assetDecimals() internal view returns (uint8) {</span>
 216 |     | <span class='neutral'>    return IERC20Metadata(_asset()).decimals();</span>
 217 |     | <span class='neutral'>  }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>  function _processRewardsToPodLp(</span>
 220 |     | <span class='neutral'>    uint256 _amountLpOutMin,</span>
 221 |     | <span class='neutral'>    uint256 _deadline</span>
 222 |     | <span class='unexecuted'>  ) internal returns (uint256 _lpAmtOut) {</span>
 223 |     | <span class='unexecuted'>    if (!yieldConvEnabled) {</span>
 224 |     | <span class='unexecuted'>      return _lpAmtOut;</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='unexecuted'>    address[] memory _tokens = rewardsWhitelister.getFullWhitelist();</span>
 227 |     | <span class='unexecuted'>    uint256 _len = _tokens.length;</span>
 228 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _len; _i++) {</span>
 229 |     | <span class='unexecuted'>      address _token = _tokens[_i];</span>
 230 |     | <span class='unexecuted'>      uint256 _bal = IERC20(_token).balanceOf(address(this));</span>
 231 |     | <span class='unexecuted'>      if (_bal == 0) {</span>
 232 |     | <span class='unexecuted'>        continue;</span>
 233 |     | <span class='neutral'>      }</span>
 234 |     | <span class='unexecuted'>      uint256 _newLp = _tokenToPodLp(_token, _bal, _amountLpOutMin, _deadline);</span>
 235 |     | <span class='unexecuted'>      _lpAmtOut += _newLp;</span>
 236 |     | <span class='unexecuted'>      _totalAssets += _newLp;</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'>  }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>  function _tokenToPodLp(</span>
 241 |     | <span class='neutral'>    address _token,</span>
 242 |     | <span class='neutral'>    uint256 _amountIn,</span>
 243 |     | <span class='neutral'>    uint256 _amountLpOutMin,</span>
 244 |     | <span class='neutral'>    uint256 _deadline</span>
 245 |     | <span class='unexecuted'>  ) internal returns (uint256 _lpAmtOut) {</span>
 246 |     | <span class='unexecuted'>    uint256 _pairedOut = _tokenToPairedLpToken(_token, _amountIn, 0);</span>
 247 |     | <span class='unexecuted'>    if (protocolFee &gt; 0) {</span>
 248 |     | <span class='unexecuted'>      uint256 _pairedFee = (_pairedOut * protocolFee) / 1000;</span>
 249 |     | <span class='unexecuted'>      IERC20(pod.PAIRED_LP_TOKEN()).safeTransfer(owner(), _pairedFee);</span>
 250 |     | <span class='unexecuted'>      _pairedOut -= _pairedFee;</span>
 251 |     | <span class='neutral'>    }</span>
 252 |     | <span class='unexecuted'>    _lpAmtOut = _pairedLpTokenToPodLp(_pairedOut, _amountLpOutMin, _deadline);</span>
 253 |     | <span class='neutral'>  }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>  function _tokenToPairedLpToken(</span>
 256 |     | <span class='neutral'>    address _token,</span>
 257 |     | <span class='neutral'>    uint256 _amountIn,</span>
 258 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 259 |     | <span class='unexecuted'>  ) internal returns (uint256 _amountOut) {</span>
 260 |     | <span class='unexecuted'>    address _pairedLpToken = pod.PAIRED_LP_TOKEN();</span>
 261 |     | <span class='unexecuted'>    if (_token == _pairedLpToken) {</span>
 262 |     | <span class='unexecuted'>      return _amountIn;</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>    address _rewardsToken = pod.lpRewardsToken();</span>
 266 |     | <span class='unexecuted'>    if (_token != address(0) &amp;&amp; _token != _rewardsToken) {</span>
 267 |     | <span class='unexecuted'>      return _swap(_token, _pairedLpToken, _amountIn, _amountOutMin);</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='unexecuted'>    uint256 _amountInOverride = _tokenToPairedSwapAmountInOverride[</span>
 270 |     | <span class='neutral'>      _rewardsToken</span>
 271 |     | <span class='neutral'>    ][_pairedLpToken];</span>
 272 |     | <span class='unexecuted'>    _amountIn = _amountInOverride &gt; 0 ? _amountInOverride : _amountIn;</span>
 273 |     | <span class='unexecuted'>    (address _token0, address _token1) = _pairedLpToken &lt; _rewardsToken</span>
 274 |     | <span class='unexecuted'>      ? (_pairedLpToken, _rewardsToken)</span>
 275 |     | <span class='unexecuted'>      : (_rewardsToken, _pairedLpToken);</span>
 276 |     | <span class='unexecuted'>    address _pool = DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_POOL_FEE);</span>
 277 |     | <span class='unexecuted'>    uint160 _rewardsSqrtPriceX96 = V3_TWAP_UTILS</span>
 278 |     | <span class='neutral'>      .sqrtPriceX96FromPoolAndInterval(_pool);</span>
 279 |     | <span class='unexecuted'>    uint256 _rewardsPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(</span>
 280 |     | <span class='neutral'>      _rewardsSqrtPriceX96</span>
 281 |     | <span class='neutral'>    );</span>
 282 |     | <span class='unexecuted'>    if (_amountOutMin == 0) {</span>
 283 |     | <span class='unexecuted'>      uint256 _amountOutNoSlip = _token0 == _rewardsToken</span>
 284 |     | <span class='unexecuted'>        ? (_rewardsPriceX96 * _amountIn) / FixedPoint96.Q96</span>
 285 |     | <span class='unexecuted'>        : (_amountIn * FixedPoint96.Q96) / _rewardsPriceX96;</span>
 286 |     | <span class='unexecuted'>      _amountOutMin =</span>
 287 |     | <span class='unexecuted'>        (_amountOutNoSlip * (1000 - REWARDS_SWAP_SLIPPAGE)) /</span>
 288 |     | <span class='unexecuted'>        1000;</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='unexecuted'>    IERC20(_rewardsToken).safeIncreaseAllowance(</span>
 291 |     | <span class='unexecuted'>      address(DEX_ADAPTER),</span>
 292 |     | <span class='unexecuted'>      _amountIn</span>
 293 |     | <span class='neutral'>    );</span>
 294 |     | <span class='unexecuted'>    try</span>
 295 |     | <span class='unexecuted'>      DEX_ADAPTER.swapV3Single(</span>
 296 |     | <span class='neutral'>        _rewardsToken,</span>
 297 |     | <span class='neutral'>        _pairedLpToken,</span>
 298 |     | <span class='neutral'>        REWARDS_POOL_FEE,</span>
 299 |     | <span class='neutral'>        _amountIn,</span>
 300 |     | <span class='neutral'>        _amountOutMin,</span>
 301 |     | <span class='unexecuted'>        address(this)</span>
 302 |     | <span class='neutral'>      )</span>
 303 |     | <span class='neutral'>    returns (uint256 __amountOut) {</span>
 304 |     | <span class='unexecuted'>      _tokenToPairedSwapAmountInOverride[_rewardsToken][_pairedLpToken] = 0;</span>
 305 |     | <span class='unexecuted'>      _amountOut = __amountOut;</span>
 306 |     | <span class='neutral'>    } catch {</span>
 307 |     | <span class='unexecuted'>      _tokenToPairedSwapAmountInOverride[_rewardsToken][_pairedLpToken] =</span>
 308 |     | <span class='unexecuted'>        _amountIn /</span>
 309 |     | <span class='unexecuted'>        2;</span>
 310 |     | <span class='unexecuted'>      IERC20(_rewardsToken).safeDecreaseAllowance(</span>
 311 |     | <span class='unexecuted'>        address(DEX_ADAPTER),</span>
 312 |     | <span class='unexecuted'>        _amountIn</span>
 313 |     | <span class='neutral'>      );</span>
 314 |     | <span class='unexecuted'>      emit TokenToPairedLpSwapError(_rewardsToken, _pairedLpToken, _amountIn);</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'>  }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='unexecuted'>  function _pairedLpTokenToPodLp(</span>
 319 |     | <span class='neutral'>    uint256 _amountIn,</span>
 320 |     | <span class='neutral'>    uint256 _amountOutMin,</span>
 321 |     | <span class='neutral'>    uint256 _deadline</span>
 322 |     | <span class='unexecuted'>  ) internal returns (uint256 _amountOut) {</span>
 323 |     | <span class='unexecuted'>    address _pairedLpToken = pod.PAIRED_LP_TOKEN();</span>
 324 |     | <span class='unexecuted'>    uint256 _half = _amountIn / 2;</span>
 325 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(address(DEX_ADAPTER), _half);</span>
 326 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 327 |     | <span class='neutral'>      _pairedLpToken,</span>
 328 |     | <span class='unexecuted'>      address(pod),</span>
 329 |     | <span class='neutral'>      _half,</span>
 330 |     | <span class='neutral'>      _amountOutMin,</span>
 331 |     | <span class='unexecuted'>      address(this)</span>
 332 |     | <span class='neutral'>    );</span>
 333 |     | <span class='unexecuted'>    uint256 _podAmt = pod.balanceOf(address(this));</span>
 334 |     | <span class='unexecuted'>    IERC20(pod).safeIncreaseAllowance(address(indexUtils), _podAmt);</span>
 335 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(address(indexUtils), _half);</span>
 336 |     | <span class='unexecuted'>    return</span>
 337 |     | <span class='unexecuted'>      indexUtils.addLPAndStake(</span>
 338 |     | <span class='unexecuted'>        pod,</span>
 339 |     | <span class='neutral'>        _podAmt,</span>
 340 |     | <span class='neutral'>        _pairedLpToken,</span>
 341 |     | <span class='neutral'>        _half,</span>
 342 |     | <span class='neutral'>        _half,</span>
 343 |     | <span class='neutral'>        LP_SLIPPAGE,</span>
 344 |     | <span class='neutral'>        _deadline</span>
 345 |     | <span class='neutral'>      );</span>
 346 |     | <span class='neutral'>  }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>  function _swap(</span>
 349 |     | <span class='neutral'>    address _in,</span>
 350 |     | <span class='neutral'>    address _out,</span>
 351 |     | <span class='neutral'>    uint256 _amountIn,</span>
 352 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 353 |     | <span class='unexecuted'>  ) internal returns (uint256 _amountOut) {</span>
 354 |     | <span class='unexecuted'>    Pools memory _swapMap = swapMaps[_in][_out];</span>
 355 |     | <span class='unexecuted'>    if (_swapMap.pool1 == address(0)) {</span>
 356 |     | <span class='unexecuted'>      address[] memory _path1 = new address[](2);</span>
 357 |     | <span class='unexecuted'>      _path1[0] = _in;</span>
 358 |     | <span class='unexecuted'>      _path1[1] = _out;</span>
 359 |     | <span class='unexecuted'>      return _swapV2(_path1, _amountIn, _amountOutMin);</span>
 360 |     | <span class='neutral'>    }</span>
 361 |     | <span class='unexecuted'>    bool _twoHops = _swapMap.pool2 != address(0);</span>
 362 |     | <span class='unexecuted'>    address _token0 = IUniswapV2Pair(_swapMap.pool1).token0();</span>
 363 |     | <span class='unexecuted'>    address[] memory _path = new address[](_twoHops ? 3 : 2);</span>
 364 |     | <span class='unexecuted'>    _path[0] = _in;</span>
 365 |     | <span class='unexecuted'>    _path[1] = !_twoHops</span>
 366 |     | <span class='unexecuted'>      ? _out</span>
 367 |     | <span class='unexecuted'>      : _token0 == _in</span>
 368 |     | <span class='unexecuted'>        ? IUniswapV2Pair(_swapMap.pool1).token1()</span>
 369 |     | <span class='unexecuted'>        : _token0;</span>
 370 |     | <span class='unexecuted'>    if (_twoHops) {</span>
 371 |     | <span class='unexecuted'>      _path[2] = _out;</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='unexecuted'>    _amountOut = _swapV2(_path, _amountIn, _amountOutMin);</span>
 374 |     | <span class='neutral'>  }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='unexecuted'>  function _swapV2(</span>
 377 |     | <span class='neutral'>    address[] memory _path,</span>
 378 |     | <span class='neutral'>    uint256 _amountIn,</span>
 379 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 380 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 381 |     | <span class='unexecuted'>    address _out = _path.length == 3 ? _path[2] : _path[1];</span>
 382 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 383 |     | <span class='unexecuted'>    IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);</span>
 384 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 385 |     | <span class='unexecuted'>      _path[0],</span>
 386 |     | <span class='unexecuted'>      _path[1],</span>
 387 |     | <span class='neutral'>      _amountIn,</span>
 388 |     | <span class='neutral'>      _amountOutMin,</span>
 389 |     | <span class='unexecuted'>      address(this)</span>
 390 |     | <span class='neutral'>    );</span>
 391 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 392 |     | <span class='neutral'>  }</span>
 393 |     | <span class='neutral'></span>
 394 |     | <span class='unexecuted'>  function setZapMap(</span>
 395 |     | <span class='neutral'>    address _in,</span>
 396 |     | <span class='neutral'>    address _out,</span>
 397 |     | <span class='neutral'>    Pools memory _pools</span>
 398 |     | <span class='neutral'>  ) external onlyOwner {</span>
 399 |     | <span class='unexecuted'>    swapMaps[_in][_out] = _pools;</span>
 400 |     | <span class='neutral'>  }</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='unexecuted'>  function setPod(IDecentralizedIndex _pod) external onlyOwner {</span>
 403 |     | <span class='unexecuted'>    require(address(pod) == address(0), &#39;S&#39;);</span>
 404 |     | <span class='unexecuted'>    pod = _pod;</span>
 405 |     | <span class='neutral'>  }</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>  function setIndexUtils(IIndexUtils _utils) external onlyOwner {</span>
 408 |     | <span class='unexecuted'>    indexUtils = _utils;</span>
 409 |     | <span class='neutral'>  }</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='unexecuted'>  function setRewardsWhitelister(IRewardsWhitelister _wl) external onlyOwner {</span>
 412 |     | <span class='unexecuted'>    rewardsWhitelister = _wl;</span>
 413 |     | <span class='neutral'>  }</span>
 414 |     | <span class='neutral'></span>
 415 |     | <span class='unexecuted'>  function setYieldConvEnabled(bool _enabled) external onlyOwner {</span>
 416 |     | <span class='unexecuted'>    require(yieldConvEnabled != _enabled, &#39;T&#39;);</span>
 417 |     | <span class='unexecuted'>    yieldConvEnabled = _enabled;</span>
 418 |     | <span class='neutral'>  }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='unexecuted'>  function setProtocolFee(uint16 _newFee) external onlyOwner {</span>
 421 |     | <span class='unexecuted'>    require(_newFee &lt;= 1000, &#39;MAX&#39;);</span>
 422 |     | <span class='unexecuted'>    protocolFee = _newFee;</span>
 423 |     | <span class='neutral'>  }</span>
 424 |     | <span class='neutral'>}</span>
 425 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/AutoCompoundingPodLpFactory.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./AutoCompoundingPodLp.sol&#39;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='unexecuted'>contract AutoCompoundingPodLpFactory is Ownable {</span>
  10 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>  uint256 minimumDepositAtCreation = 10 ** 3;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>  event Create(address newAspTkn);</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>  function create(</span>
  17 |     | <span class='neutral'>    string memory _name,</span>
  18 |     | <span class='neutral'>    string memory _symbol,</span>
  19 |     | <span class='neutral'>    IDecentralizedIndex _pod,</span>
  20 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  21 |     | <span class='neutral'>    IIndexUtils _utils,</span>
  22 |     | <span class='neutral'>    IRewardsWhitelister _whitelist,</span>
  23 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  24 |     | <span class='neutral'>    uint256 _salt</span>
  25 |     | <span class='unexecuted'>  ) external onlyOwner {</span>
  26 |     | <span class='unexecuted'>    address _aspAddy = _deploy(</span>
  27 |     | <span class='unexecuted'>      getBytecode(</span>
  28 |     | <span class='unexecuted'>        _name,</span>
  29 |     | <span class='unexecuted'>        _symbol,</span>
  30 |     | <span class='unexecuted'>        _pod,</span>
  31 |     | <span class='unexecuted'>        _dexAdapter,</span>
  32 |     | <span class='unexecuted'>        _utils,</span>
  33 |     | <span class='unexecuted'>        _whitelist,</span>
  34 |     | <span class='unexecuted'>        _v3TwapUtilities</span>
  35 |     | <span class='neutral'>      ),</span>
  36 |     | <span class='unexecuted'>      _getFullSalt(_salt)</span>
  37 |     | <span class='neutral'>    );</span>
  38 |     | <span class='unexecuted'>    if (address(_pod) != address(0) &amp;&amp; minimumDepositAtCreation &gt; 0) {</span>
  39 |     | <span class='unexecuted'>      _depositMin(_aspAddy, _pod);</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='unexecuted'>    AutoCompoundingPodLp(_aspAddy).transferOwnership(_msgSender());</span>
  42 |     | <span class='unexecuted'>    emit Create(_aspAddy);</span>
  43 |     | <span class='neutral'>  }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>  function _depositMin(address _aspAddy, IDecentralizedIndex _pod) internal {</span>
  46 |     | <span class='unexecuted'>    address _lpToken = _pod.lpStakingPool();</span>
  47 |     | <span class='unexecuted'>    IERC20(_lpToken).safeTransferFrom(</span>
  48 |     | <span class='neutral'>      _msgSender(),</span>
  49 |     | <span class='unexecuted'>      address(this),</span>
  50 |     | <span class='unexecuted'>      minimumDepositAtCreation</span>
  51 |     | <span class='neutral'>    );</span>
  52 |     | <span class='unexecuted'>    IERC20(_lpToken).safeApprove(_aspAddy, minimumDepositAtCreation);</span>
  53 |     | <span class='unexecuted'>    AutoCompoundingPodLp(_aspAddy).deposit(</span>
  54 |     | <span class='unexecuted'>      minimumDepositAtCreation,</span>
  55 |     | <span class='unexecuted'>      _msgSender()</span>
  56 |     | <span class='neutral'>    );</span>
  57 |     | <span class='neutral'>  }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='unexecuted'>  function getNewCaFromParams(</span>
  60 |     | <span class='neutral'>    string memory _name,</span>
  61 |     | <span class='neutral'>    string memory _symbol,</span>
  62 |     | <span class='neutral'>    IDecentralizedIndex _pod,</span>
  63 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  64 |     | <span class='neutral'>    IIndexUtils _utils,</span>
  65 |     | <span class='neutral'>    IRewardsWhitelister _whitelist,</span>
  66 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  67 |     | <span class='neutral'>    uint256 _salt</span>
  68 |     | <span class='unexecuted'>  ) external view returns (address) {</span>
  69 |     | <span class='unexecuted'>    bytes memory _bytecode = getBytecode(</span>
  70 |     | <span class='unexecuted'>      _name,</span>
  71 |     | <span class='unexecuted'>      _symbol,</span>
  72 |     | <span class='unexecuted'>      _pod,</span>
  73 |     | <span class='unexecuted'>      _dexAdapter,</span>
  74 |     | <span class='unexecuted'>      _utils,</span>
  75 |     | <span class='unexecuted'>      _whitelist,</span>
  76 |     | <span class='unexecuted'>      _v3TwapUtilities</span>
  77 |     | <span class='neutral'>    );</span>
  78 |     | <span class='unexecuted'>    return getNewCaAddress(_bytecode, _salt);</span>
  79 |     | <span class='neutral'>  }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>  function getBytecode(</span>
  82 |     | <span class='neutral'>    string memory _name,</span>
  83 |     | <span class='neutral'>    string memory _symbol,</span>
  84 |     | <span class='neutral'>    IDecentralizedIndex _pod,</span>
  85 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  86 |     | <span class='neutral'>    IIndexUtils _utils,</span>
  87 |     | <span class='neutral'>    IRewardsWhitelister _whitelist,</span>
  88 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities</span>
  89 |     | <span class='unexecuted'>  ) public pure returns (bytes memory) {</span>
  90 |     | <span class='unexecuted'>    bytes memory _bytecode = type(AutoCompoundingPodLp).creationCode;</span>
  91 |     | <span class='unexecuted'>    return</span>
  92 |     | <span class='unexecuted'>      abi.encodePacked(</span>
  93 |     | <span class='unexecuted'>        _bytecode,</span>
  94 |     | <span class='unexecuted'>        abi.encode(</span>
  95 |     | <span class='unexecuted'>          _name,</span>
  96 |     | <span class='unexecuted'>          _symbol,</span>
  97 |     | <span class='unexecuted'>          _pod,</span>
  98 |     | <span class='unexecuted'>          _dexAdapter,</span>
  99 |     | <span class='unexecuted'>          _utils,</span>
 100 |     | <span class='unexecuted'>          _whitelist,</span>
 101 |     | <span class='unexecuted'>          _v3TwapUtilities</span>
 102 |     | <span class='neutral'>        )</span>
 103 |     | <span class='neutral'>      );</span>
 104 |     | <span class='neutral'>  }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>  function getNewCaAddress(</span>
 107 |     | <span class='neutral'>    bytes memory _bytecode,</span>
 108 |     | <span class='neutral'>    uint256 _salt</span>
 109 |     | <span class='unexecuted'>  ) public view returns (address) {</span>
 110 |     | <span class='unexecuted'>    bytes32 _hash = keccak256(</span>
 111 |     | <span class='unexecuted'>      abi.encodePacked(</span>
 112 |     | <span class='neutral'>        bytes1(0xff),</span>
 113 |     | <span class='unexecuted'>        address(this),</span>
 114 |     | <span class='unexecuted'>        _getFullSalt(_salt),</span>
 115 |     | <span class='unexecuted'>        keccak256(_bytecode)</span>
 116 |     | <span class='neutral'>      )</span>
 117 |     | <span class='neutral'>    );</span>
 118 |     | <span class='neutral'>    return address(uint160(uint256(_hash)));</span>
 119 |     | <span class='neutral'>  }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>  function _getFullSalt(uint256 _salt) internal view returns (uint256) {</span>
 122 |     | <span class='unexecuted'>    return uint256(uint160(address(this))) + _salt;</span>
 123 |     | <span class='neutral'>  }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>  function _deploy(</span>
 126 |     | <span class='neutral'>    bytes memory _bytecode,</span>
 127 |     | <span class='neutral'>    uint256 _finalSalt</span>
 128 |     | <span class='unexecuted'>  ) internal returns (address _addr) {</span>
 129 |     | <span class='neutral'>    assembly {</span>
 130 |     | <span class='unexecuted'>      _addr := create2(</span>
 131 |     | <span class='unexecuted'>        callvalue(),</span>
 132 |     | <span class='unexecuted'>        add(_bytecode, 0x20),</span>
 133 |     | <span class='unexecuted'>        mload(_bytecode),</span>
 134 |     | <span class='unexecuted'>        _finalSalt</span>
 135 |     | <span class='neutral'>      )</span>
 136 |     | <span class='unexecuted'>      if iszero(extcodesize(_addr)) {</span>
 137 |     | <span class='unexecuted'>        revert(0, 0)</span>
 138 |     | <span class='neutral'>      }</span>
 139 |     | <span class='neutral'>    }</span>
 140 |     | <span class='neutral'>  }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>  function setMinimumDepositAtCreation(uint256 _minDeposit) external onlyOwner {</span>
 143 |     | <span class='unexecuted'>    minimumDepositAtCreation = _minDeposit;</span>
 144 |     | <span class='neutral'>  }</span>
 145 |     | <span class='neutral'>}</span>
 146 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/DecentralizedIndex.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/IDecentralizedIndex.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/IFlashLoanRecipient.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./interfaces/IProtocolFeeRouter.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./interfaces/IRewardsWhitelister.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./interfaces/ITokenRewards.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./StakingPoolToken.sol&#39;;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>abstract contract DecentralizedIndex is</span>
  17 |     | <span class='neutral'>  IDecentralizedIndex,</span>
  18 |     | <span class='neutral'>  ERC20,</span>
  19 |     | <span class='neutral'>  ERC20Permit</span>
  20 |     | <span class='neutral'>{</span>
  21 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  22 |     | <span class='neutral'></span>
  23 | *   | <span class='executed'>  uint16 constant DEN = 10000;</span>
  24 |     | <span class='unexecuted'>  uint8 constant SWAP_DELAY = 20; // seconds</span>
  25 |     | <span class='unexecuted'>  address constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;</span>
  26 |     | <span class='neutral'>  IProtocolFeeRouter constant PROTOCOL_FEE_ROUTER =</span>
  27 |     | <span class='unexecuted'>    IProtocolFeeRouter(0x7d544DD34ABbE24C8832db27820Ff53C151e949b);</span>
  28 |     | <span class='neutral'>  IRewardsWhitelister constant REWARDS_WHITELIST =</span>
  29 |     | <span class='unexecuted'>    IRewardsWhitelister(0xEc0Eb48d2D638f241c1a7F109e38ef2901E9450F);</span>
  30 |     | <span class='neutral'>  IV3TwapUtilities constant V3_TWAP_UTILS =</span>
  31 |     | <span class='unexecuted'>    IV3TwapUtilities(0x024ff47D552cB222b265D68C7aeB26E586D5229D);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='unexecuted'>  uint256 public immutable override FLASH_FEE_AMOUNT_DAI; // 10 DAI</span>
  34 |     | <span class='unexecuted'>  address public immutable override PAIRED_LP_TOKEN;</span>
  35 |     | <span class='unexecuted'>  IDexAdapter public immutable DEX_HANDLER;</span>
  36 |     | <span class='neutral'>  address immutable V2_ROUTER;</span>
  37 |     | <span class='neutral'>  address immutable V3_ROUTER;</span>
  38 |     | <span class='neutral'>  address immutable WETH;</span>
  39 |     | <span class='neutral'>  address V2_POOL;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>  IndexType public immutable override indexType;</span>
  42 |     | <span class='unexecuted'>  uint256 public immutable override created;</span>
  43 |     | <span class='unexecuted'>  address public immutable override lpRewardsToken;</span>
  44 |     | <span class='unexecuted'>  address public override lpStakingPool;</span>
  45 |     | <span class='unexecuted'>  uint8 public override unlocked = 1;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>  Config public config;</span>
  48 |     | <span class='unexecuted'>  Fees public fees;</span>
  49 |     | <span class='unexecuted'>  IndexAssetInfo[] public indexTokens;</span>
  50 |     | <span class='neutral'>  mapping(address =&gt; bool) _isTokenInIndex;</span>
  51 |     | <span class='neutral'>  mapping(address =&gt; uint8) _fundTokenIdx;</span>
  52 |     | <span class='neutral'>  mapping(address =&gt; bool) _blacklist;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>  uint64 _partnerFirstWrapped;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>  uint64 _lastSwap;</span>
  57 |     | <span class='neutral'>  uint8 _swapping;</span>
  58 |     | <span class='unexecuted'>  uint8 _swapAndFeeOn = 1;</span>
  59 |     | <span class='neutral'>  bool _initialized;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>  event FlashLoan(</span>
  62 |     | <span class='neutral'>    address indexed executor,</span>
  63 |     | <span class='neutral'>    address indexed recipient,</span>
  64 |     | <span class='neutral'>    address token,</span>
  65 |     | <span class='neutral'>    uint256 amount</span>
  66 |     | <span class='neutral'>  );</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>  modifier lock() {</span>
  69 | *   | <span class='executed'>    require(unlocked == 1, &#39;L&#39;);</span>
  70 | *   | <span class='executed'>    unlocked = 0;</span>
  71 |     | <span class='neutral'>    _;</span>
  72 | *   | <span class='executed'>    unlocked = 1;</span>
  73 |     | <span class='neutral'>  }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>  modifier onlyPartner() {</span>
  76 |     | <span class='unexecuted'>    require(_msgSender() == config.partner, &#39;P&#39;);</span>
  77 |     | <span class='neutral'>    _;</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>  modifier noSwapOrFee() {</span>
  81 | *   | <span class='executed'>    _swapAndFeeOn = 0;</span>
  82 |     | <span class='neutral'>    _;</span>
  83 | *   | <span class='executed'>    _swapAndFeeOn = 1;</span>
  84 |     | <span class='neutral'>  }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>  event Debug(string a);</span>
  87 |     | <span class='neutral'>  event DebugUint(string a, uint256 b);</span>
  88 |     | <span class='neutral'>  event DebugAddress(string a, address b);</span>
  89 |     | <span class='neutral'>  event DebugBool(string a, bool b);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>  constructor(</span>
  92 |     | <span class='neutral'>    string memory _name,</span>
  93 |     | <span class='neutral'>    string memory _symbol,</span>
  94 |     | <span class='neutral'>    IndexType _idxType,</span>
  95 |     | <span class='neutral'>    Config memory _config,</span>
  96 |     | <span class='neutral'>    Fees memory _fees,</span>
  97 |     | <span class='neutral'>    address _pairedLpToken,</span>
  98 |     | <span class='neutral'>    address _lpRewardsToken,</span>
  99 |     | <span class='neutral'>    address _dexHandler,</span>
 100 |     | <span class='neutral'>    bool _stakeRestriction</span>
 101 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) ERC20Permit(_name) {</span>
 102 |     | <span class='unexecuted'>    require(_fees.buy &lt;= (uint256(DEN) * 20) / 100);</span>
 103 |     | <span class='unexecuted'>    require(_fees.sell &lt;= (uint256(DEN) * 20) / 100);</span>
 104 |     | <span class='unexecuted'>    require(_fees.burn &lt;= (uint256(DEN) * 70) / 100);</span>
 105 |     | <span class='unexecuted'>    require(_fees.bond &lt;= (uint256(DEN) * 99) / 100);</span>
 106 |     | <span class='unexecuted'>    require(_fees.debond &lt;= (uint256(DEN) * 99) / 100);</span>
 107 |     | <span class='unexecuted'>    require(_fees.partner &lt;= (uint256(DEN) * 5) / 100);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='unexecuted'>    indexType = _idxType;</span>
 111 |     | <span class='unexecuted'>    created = block.timestamp;</span>
 112 |     | <span class='unexecuted'>    fees = _fees;</span>
 113 |     | <span class='unexecuted'>    config = _config;</span>
 114 |     | <span class='unexecuted'>    lpRewardsToken = _lpRewardsToken;</span>
 115 |     | <span class='unexecuted'>    DEX_HANDLER = IDexAdapter(_dexHandler);</span>
 116 |     | <span class='unexecuted'>    address _v2Router = DEX_HANDLER.V2_ROUTER();</span>
 117 |     | <span class='unexecuted'>    V2_ROUTER = _v2Router;</span>
 118 |     | <span class='unexecuted'>    V3_ROUTER = DEX_HANDLER.V3_ROUTER();</span>
 119 |     | <span class='unexecuted'>    address _finalPairedLpToken = _pairedLpToken == address(0)</span>
 120 |     | <span class='neutral'>      ? DAI</span>
 121 |     | <span class='unexecuted'>      : _pairedLpToken;</span>
 122 |     | <span class='unexecuted'>    PAIRED_LP_TOKEN = _finalPairedLpToken;</span>
 123 |     | <span class='unexecuted'>    FLASH_FEE_AMOUNT_DAI = 10 * 10 ** IERC20Metadata(DAI).decimals(); // 10 DAI</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    emit Debug(&quot;BEFORE STAKING POOL TOKEN&quot;);</span>
 126 |     | <span class='neutral'>    </span>
 127 |     | <span class='unexecuted'>    lpStakingPool = address(</span>
 128 |     | <span class='unexecuted'>      new StakingPoolToken(</span>
 129 |     | <span class='unexecuted'>        string.concat(&#39;Staked &#39;, _name),</span>
 130 |     | <span class='unexecuted'>        string.concat(&#39;s&#39;, _symbol),</span>
 131 |     | <span class='unexecuted'>        _finalPairedLpToken,</span>
 132 |     | <span class='unexecuted'>        lpRewardsToken,</span>
 133 |     | <span class='unexecuted'>        _stakeRestriction ? _msgSender() : address(0),</span>
 134 |     | <span class='neutral'>        PROTOCOL_FEE_ROUTER,</span>
 135 |     | <span class='neutral'>        REWARDS_WHITELIST,</span>
 136 |     | <span class='unexecuted'>        DEX_HANDLER,</span>
 137 |     | <span class='neutral'>        V3_TWAP_UTILS</span>
 138 |     | <span class='neutral'>      )</span>
 139 |     | <span class='neutral'>    );</span>
 140 |     | <span class='unexecuted'>    emit Debug(&quot;AFTER STAKING POOL TOKEN&quot;);</span>
 141 |     | <span class='unexecuted'>    if (!DEX_HANDLER.ASYNC_INITIALIZE()) {</span>
 142 |     | <span class='unexecuted'>      _initialize();</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='unexecuted'>    WETH = IDexAdapter(_dexHandler).WETH();</span>
 145 |     | <span class='unexecuted'>    emit Create(address(this), _msgSender());</span>
 146 |     | <span class='neutral'>  }</span>
 147 |     | <span class='neutral'></span>
 148 | *   | <span class='executed'>  function initialize() external {</span>
 149 | *   | <span class='executed'>    _initialize();</span>
 150 |     | <span class='neutral'>  }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>  /// @notice The ```_initialize``` function initialized a new LP pair for the pod + pairedLpAsset</span>
 153 |     | <span class='unexecuted'>  function _initialize() internal {</span>
 154 |     | <span class='unexecuted'>    require(!_initialized, &#39;O&#39;);</span>
 155 |     | <span class='unexecuted'>    _initialized = true;</span>
 156 |     | <span class='unexecuted'>    address _v2Pool = DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN);</span>
 157 |     | <span class='unexecuted'>    if (_v2Pool == address(0)) {</span>
 158 |     | <span class='unexecuted'>      _v2Pool = DEX_HANDLER.createV2Pool(address(this), PAIRED_LP_TOKEN);</span>
 159 |     | <span class='neutral'>    }</span>
 160 |     | <span class='unexecuted'>    StakingPoolToken(lpStakingPool).setStakingToken(_v2Pool);</span>
 161 |     | <span class='unexecuted'>    StakingPoolToken(lpStakingPool).renounceOwnership();</span>
 162 |     | <span class='unexecuted'>    V2_POOL = _v2Pool;</span>
 163 |     | <span class='unexecuted'>    emit Initialize(_msgSender(), _v2Pool);</span>
 164 |     | <span class='neutral'>  }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>  /// @notice The ```_transfer``` function overrides the standard ERC20 _transfer to handle fee processing for a pod</span>
 167 |     | <span class='neutral'>  /// @param _from Where pTKN are being transferred from</span>
 168 |     | <span class='neutral'>  /// @param _to Where pTKN are being transferred to</span>
 169 |     | <span class='neutral'>  /// @param _amount Amount of pTKN being transferred</span>
 170 |     | <span class='unexecuted'>  function _transfer(</span>
 171 |     | <span class='neutral'>    address _from,</span>
 172 |     | <span class='neutral'>    address _to,</span>
 173 |     | <span class='neutral'>    uint256 _amount</span>
 174 |     | <span class='unexecuted'>  ) internal virtual override {</span>
 175 |     | <span class='unexecuted'>    require(!_blacklist[_to], &#39;BK&#39;);</span>
 176 |     | <span class='unexecuted'>    bool _buy = _from == V2_POOL &amp;&amp; _to != V2_ROUTER;</span>
 177 |     | <span class='unexecuted'>    bool _sell = _to == V2_POOL;</span>
 178 |     | <span class='neutral'>    uint256 _fee;</span>
 179 |     | <span class='unexecuted'>    if (_swapping == 0 &amp;&amp; _swapAndFeeOn == 1) {</span>
 180 |     | <span class='unexecuted'>      if (_from != V2_POOL) {</span>
 181 |     | <span class='unexecuted'>        _processPreSwapFeesAndSwap();</span>
 182 |     | <span class='neutral'>      }</span>
 183 |     | <span class='unexecuted'>      if (_buy &amp;&amp; fees.buy &gt; 0) {</span>
 184 |     | <span class='unexecuted'>        _fee = (_amount * fees.buy) / DEN;</span>
 185 |     | <span class='unexecuted'>        super._transfer(_from, address(this), _fee);</span>
 186 |     | <span class='neutral'>      }</span>
 187 |     | <span class='unexecuted'>      if (_sell &amp;&amp; fees.sell &gt; 0) {</span>
 188 |     | <span class='unexecuted'>        _fee = (_amount * fees.sell) / DEN;</span>
 189 |     | <span class='unexecuted'>        super._transfer(_from, address(this), _fee);</span>
 190 |     | <span class='neutral'>      }</span>
 191 |     | <span class='unexecuted'>      if (!_buy &amp;&amp; !_sell &amp;&amp; config.hasTransferTax) {</span>
 192 |     | <span class='unexecuted'>        _fee = _amount / 10000; // 0.01%</span>
 193 |     | <span class='unexecuted'>        _fee = _fee == 0 &amp;&amp; _amount &gt; 0 ? 1 : _fee;</span>
 194 |     | <span class='unexecuted'>        super._transfer(_from, address(this), _fee);</span>
 195 |     | <span class='neutral'>      }</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='unexecuted'>    _processBurnFee(_fee);</span>
 198 |     | <span class='unexecuted'>    super._transfer(_from, _to, _amount - _fee);</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>  /// @notice The ```_processPreSwapFeesAndSwap``` function processes fees that could be pending for a pod</span>
 202 |     | <span class='unexecuted'>  function _processPreSwapFeesAndSwap() internal {</span>
 203 |     | <span class='unexecuted'>    bool _passesSwapDelay = block.timestamp &gt; _lastSwap + SWAP_DELAY;</span>
 204 |     | <span class='unexecuted'>    if (!_passesSwapDelay) {</span>
 205 |     | <span class='unexecuted'>      return;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='unexecuted'>    uint256 _bal = balanceOf(address(this));</span>
 208 |     | <span class='unexecuted'>    if (_bal == 0) {</span>
 209 |     | <span class='unexecuted'>      return;</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='unexecuted'>    uint256 _lpBal = balanceOf(V2_POOL);</span>
 212 |     | <span class='unexecuted'>    uint256 _min = block.chainid == 1 ? _lpBal / 1000 : _lpBal / 4000; // 0.1%/0.025% LP bal</span>
 213 |     | <span class='unexecuted'>    uint256 _max = _lpBal / 100; // 1%</span>
 214 |     | <span class='unexecuted'>    if (_bal &gt;= _min &amp;&amp; _lpBal &gt; 0) {</span>
 215 |     | <span class='unexecuted'>      _swapping = 1;</span>
 216 |     | <span class='unexecuted'>      _lastSwap = uint64(block.timestamp);</span>
 217 |     | <span class='unexecuted'>      uint256 _totalAmt = _bal &gt; _max ? _max : _bal;</span>
 218 |     | <span class='unexecuted'>      uint256 _partnerAmt;</span>
 219 |     | <span class='unexecuted'>      if (</span>
 220 |     | <span class='unexecuted'>        fees.partner &gt; 0 &amp;&amp;</span>
 221 |     | <span class='unexecuted'>        config.partner != address(0) &amp;&amp;</span>
 222 |     | <span class='unexecuted'>        !_blacklist[config.partner]</span>
 223 |     | <span class='neutral'>      ) {</span>
 224 |     | <span class='unexecuted'>        _partnerAmt = (_totalAmt * fees.partner) / DEN;</span>
 225 |     | <span class='unexecuted'>        super._transfer(address(this), config.partner, _partnerAmt);</span>
 226 |     | <span class='neutral'>      }</span>
 227 |     | <span class='unexecuted'>      _feeSwap(_totalAmt - _partnerAmt);</span>
 228 |     | <span class='unexecuted'>      _swapping = 0;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'>  }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>  /// @notice The ```_processBurnFee``` function burns pTKN based on the burn fee, which turns the pod</span>
 233 |     | <span class='neutral'>  /// @notice into a vault where holders have more underlying TKN to pTKN as burn fees process over time</span>
 234 |     | <span class='neutral'>  /// @param _amtToProcess Number of pTKN being burned</span>
 235 | *   | <span class='executed'>  function _processBurnFee(uint256 _amtToProcess) internal {</span>
 236 | *   | <span class='executed'>    if (_amtToProcess == 0 || fees.burn == 0) {</span>
 237 |     | <span class='neutral'>      return;</span>
 238 |     | <span class='neutral'>    }</span>
 239 | *   | <span class='executed'>    _burn(address(this), (_amtToProcess * fees.burn) / DEN);</span>
 240 |     | <span class='neutral'>  }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>  /// @notice The ```_feeSwap``` function processes built up fees by converting to pairedLpToken</span>
 243 |     | <span class='neutral'>  /// @param _amount Number of pTKN being processed for yield</span>
 244 |     | <span class='unexecuted'>  function _feeSwap(uint256 _amount) internal {</span>
 245 |     | <span class='unexecuted'>    _approve(address(this), address(DEX_HANDLER), _amount);</span>
 246 |     | <span class='unexecuted'>    address _rewards = StakingPoolToken(lpStakingPool).POOL_REWARDS();</span>
 247 |     | <span class='unexecuted'>    uint256 _pairedLpBalBefore = IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards);</span>
 248 |     | <span class='unexecuted'>    DEX_HANDLER.swapV2Single(</span>
 249 |     | <span class='unexecuted'>      address(this),</span>
 250 |     | <span class='unexecuted'>      PAIRED_LP_TOKEN,</span>
 251 |     | <span class='neutral'>      _amount,</span>
 252 |     | <span class='neutral'>      0,</span>
 253 |     | <span class='neutral'>      _rewards</span>
 254 |     | <span class='neutral'>    );</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>    if (PAIRED_LP_TOKEN == lpRewardsToken) {</span>
 257 |     | <span class='unexecuted'>      uint256 _newPairedLpTkns = IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards) -</span>
 258 |     | <span class='unexecuted'>        _pairedLpBalBefore;</span>
 259 |     | <span class='unexecuted'>      if (_newPairedLpTkns &gt; 0) {</span>
 260 |     | <span class='unexecuted'>        ITokenRewards(_rewards).depositRewardsNoTransfer(</span>
 261 |     | <span class='unexecuted'>          PAIRED_LP_TOKEN,</span>
 262 |     | <span class='neutral'>          _newPairedLpTkns</span>
 263 |     | <span class='neutral'>        );</span>
 264 |     | <span class='neutral'>      }</span>
 265 |     | <span class='unexecuted'>    } else if (IERC20(PAIRED_LP_TOKEN).balanceOf(_rewards) &gt; 0) {</span>
 266 |     | <span class='unexecuted'>      ITokenRewards(_rewards).depositFromPairedLpToken(0);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'>  }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>  /// @notice The ```_transferFromAndValidate``` function is basically the _transfer with hardcoded _to to this CA and executes</span>
 271 |     | <span class='neutral'>  /// @notice a token transfer with balance validation to revert if balances aren&#39;t updated as expected</span>
 272 |     | <span class='neutral'>  /// @notice on transfer (i.e. transfer fees, etc.)</span>
 273 |     | <span class='neutral'>  /// @param _token The token we&#39;re transferring</span>
 274 |     | <span class='neutral'>  /// @param _sender The token we&#39;re transferring</span>
 275 |     | <span class='neutral'>  /// @param _amount Number of tokens to transfer</span>
 276 | *   | <span class='executed'>  function _transferFromAndValidate(</span>
 277 |     | <span class='neutral'>    IERC20 _token,</span>
 278 |     | <span class='neutral'>    address _sender,</span>
 279 |     | <span class='neutral'>    uint256 _amount</span>
 280 |     | <span class='neutral'>  ) internal {</span>
 281 | *   | <span class='executed'>    uint256 _balanceBefore = _token.balanceOf(address(this));</span>
 282 | *   | <span class='executed'>    _token.safeTransferFrom(_sender, address(this), _amount);</span>
 283 | *   | <span class='executed'>    require(_token.balanceOf(address(this)) &gt;= _balanceBefore + _amount, &#39;TV&#39;);</span>
 284 |     | <span class='neutral'>  }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>  /// @notice The ```_bond``` function should be called from external bond() to handle validation and partner logic</span>
 287 | *   | <span class='executed'>  function _bond() internal {</span>
 288 | *   | <span class='executed'>    require(_initialized, &#39;I&#39;);</span>
 289 | *   | <span class='executed'>    if (_partnerFirstWrapped == 0 &amp;&amp; _msgSender() == config.partner) {</span>
 290 |     | <span class='unexecuted'>      _partnerFirstWrapped = uint64(block.timestamp);</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>  }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>  /// @notice The ```_canWrapFeeFree``` function checks if the wrapping user can wrap without fees</span>
 295 |     | <span class='neutral'>  /// @param _wrapper The user wrapping into the pod</span>
 296 |     | <span class='neutral'>  /// @return bool Whether the user can wrap fee free</span>
 297 | *   | <span class='executed'>  function _canWrapFeeFree(address _wrapper) internal view returns (bool) {</span>
 298 |     | <span class='unexecuted'>    return</span>
 299 | *   | <span class='executed'>      _isFirstIn() ||</span>
 300 | *   | <span class='executed'>      (_wrapper == config.partner &amp;&amp;</span>
 301 |     | <span class='unexecuted'>        _partnerFirstWrapped == 0 &amp;&amp;</span>
 302 |     | <span class='unexecuted'>        block.timestamp &lt;= created + 7 days);</span>
 303 |     | <span class='neutral'>  }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>  /// @notice The ```_isFirstIn``` function confirms if the user is the first to wrap</span>
 306 |     | <span class='neutral'>  /// @return bool Whether the user is the first one in</span>
 307 | *   | <span class='executed'>  function _isFirstIn() internal view returns (bool) {</span>
 308 | *   | <span class='executed'>    return totalSupply() == 0;</span>
 309 |     | <span class='neutral'>  }</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='neutral'>  /// @notice The ```_isLastOut``` function checks if the user is the last one out</span>
 312 |     | <span class='neutral'>  /// @param _debondAmount Number of pTKN being unwrapped</span>
 313 |     | <span class='neutral'>  /// @return bool Whether the user is the last one out</span>
 314 |     | <span class='unexecuted'>  function _isLastOut(uint256 _debondAmount) internal view returns (bool) {</span>
 315 |     | <span class='unexecuted'>    return _debondAmount &gt;= (totalSupply() * 98) / 100;</span>
 316 |     | <span class='neutral'>  }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>  /// @notice The ```processPreSwapFeesAndSwap``` function allows the rewards CA for the pod to process fees as needed</span>
 319 |     | <span class='unexecuted'>  function processPreSwapFeesAndSwap() external override {</span>
 320 |     | <span class='unexecuted'>    require(</span>
 321 |     | <span class='unexecuted'>      _msgSender() == StakingPoolToken(lpStakingPool).POOL_REWARDS(),</span>
 322 |     | <span class='neutral'>      &#39;R&#39;</span>
 323 |     | <span class='neutral'>    );</span>
 324 |     | <span class='unexecuted'>    _processPreSwapFeesAndSwap();</span>
 325 |     | <span class='neutral'>  }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='unexecuted'>  function partner() external view override returns (address) {</span>
 328 |     | <span class='unexecuted'>    return config.partner;</span>
 329 |     | <span class='neutral'>  }</span>
 330 |     | <span class='neutral'></span>
 331 |     | <span class='unexecuted'>  function BOND_FEE() external view override returns (uint16) {</span>
 332 |     | <span class='unexecuted'>    return fees.bond;</span>
 333 |     | <span class='neutral'>  }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='unexecuted'>  function DEBOND_FEE() external view override returns (uint16) {</span>
 336 |     | <span class='unexecuted'>    return fees.debond;</span>
 337 |     | <span class='neutral'>  }</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='unexecuted'>  function isAsset(address _token) public view override returns (bool) {</span>
 340 |     | <span class='unexecuted'>    return _isTokenInIndex[_token];</span>
 341 |     | <span class='neutral'>  }</span>
 342 |     | <span class='neutral'></span>
 343 | *   | <span class='executed'>  function getAllAssets()</span>
 344 |     | <span class='neutral'>    external</span>
 345 |     | <span class='neutral'>    view</span>
 346 |     | <span class='neutral'>    override</span>
 347 | *   | <span class='executed'>    returns (IndexAssetInfo[] memory)</span>
 348 |     | <span class='neutral'>  {</span>
 349 | *   | <span class='executed'>    return indexTokens;</span>
 350 |     | <span class='neutral'>  }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>  /// @notice The ```burn``` function allows any user to burn an amount of their pTKN</span>
 353 |     | <span class='neutral'>  /// @param _amount Number of pTKN to burn</span>
 354 |     | <span class='unexecuted'>  function burn(uint256 _amount) external lock {</span>
 355 |     | <span class='unexecuted'>    _burn(_msgSender(), _amount);</span>
 356 |     | <span class='neutral'>  }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>  /// @notice The ```addLiquidityV2``` function mints new liquidity for the pod</span>
 359 |     | <span class='neutral'>  /// @param _idxLPTokens Number pTKN to add to liquidity</span>
 360 |     | <span class='neutral'>  /// @param _pairedLPTokens Number of pairedLpToken to add to liquidity</span>
 361 |     | <span class='neutral'>  /// @param _slippage LP slippage with 1000 precision</span>
 362 |     | <span class='neutral'>  /// @param _deadline LP validation deadline</span>
 363 |     | <span class='neutral'>  /// @return _liquidity Number of new liquidity tokens minted</span>
 364 |     | <span class='unexecuted'>  function addLiquidityV2(</span>
 365 |     | <span class='neutral'>    uint256 _idxLPTokens,</span>
 366 |     | <span class='neutral'>    uint256 _pairedLPTokens,</span>
 367 |     | <span class='neutral'>    uint256 _slippage, // 100 == 10%, 1000 == 100%</span>
 368 |     | <span class='neutral'>    uint256 _deadline</span>
 369 |     | <span class='unexecuted'>  ) external override lock noSwapOrFee returns (uint256) {</span>
 370 |     | <span class='unexecuted'>    uint256 _idxTokensBefore = balanceOf(address(this));</span>
 371 |     | <span class='unexecuted'>    uint256 _pairedBefore = IERC20(PAIRED_LP_TOKEN).balanceOf(address(this));</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='unexecuted'>    super._transfer(_msgSender(), address(this), _idxLPTokens);</span>
 374 |     | <span class='unexecuted'>    _approve(address(this), address(DEX_HANDLER), _idxLPTokens);</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='unexecuted'>    emit DebugUint(&quot;PAIRED_LP_TOKEN BALANCE&quot;, IERC20(PAIRED_LP_TOKEN).balanceOf(_msgSender()));</span>
 377 |     | <span class='unexecuted'>    emit DebugAddress(&quot;PAIRED_LP_TOKEN&quot;, PAIRED_LP_TOKEN);</span>
 378 |     | <span class='unexecuted'>    emit DebugAddress(&quot;ms.sender&quot;, _msgSender());</span>
 379 |     | <span class='unexecuted'>    emit DebugBool(&quot;PAIRED_LP_TOKEN is DAI&quot;, PAIRED_LP_TOKEN == 0x6B175474E89094C44Da98b954EedeAC495271d0F);</span>
 380 |     | <span class='unexecuted'>    IERC20(PAIRED_LP_TOKEN).safeTransferFrom(</span>
 381 |     | <span class='neutral'>      _msgSender(),</span>
 382 |     | <span class='unexecuted'>      address(this),</span>
 383 |     | <span class='unexecuted'>      _pairedLPTokens</span>
 384 |     | <span class='neutral'>    );</span>
 385 |     | <span class='unexecuted'>    IERC20(PAIRED_LP_TOKEN).safeIncreaseAllowance(</span>
 386 |     | <span class='unexecuted'>      address(DEX_HANDLER),</span>
 387 |     | <span class='unexecuted'>      _pairedLPTokens</span>
 388 |     | <span class='neutral'>    );</span>
 389 |     | <span class='neutral'></span>
 390 |     | <span class='unexecuted'>    uint256 _poolBalBefore = IERC20(</span>
 391 |     | <span class='unexecuted'>      DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN)</span>
 392 |     | <span class='neutral'>    ).balanceOf(_msgSender());</span>
 393 |     | <span class='unexecuted'>    DEX_HANDLER.addLiquidity(</span>
 394 |     | <span class='unexecuted'>      address(this),</span>
 395 |     | <span class='unexecuted'>      PAIRED_LP_TOKEN,</span>
 396 |     | <span class='unexecuted'>      _idxLPTokens,</span>
 397 |     | <span class='unexecuted'>      _pairedLPTokens,</span>
 398 |     | <span class='unexecuted'>      (_idxLPTokens * (1000 - _slippage)) / 1000,</span>
 399 |     | <span class='unexecuted'>      (_pairedLPTokens * (1000 - _slippage)) / 1000,</span>
 400 |     | <span class='neutral'>      _msgSender(),</span>
 401 |     | <span class='neutral'>      _deadline</span>
 402 |     | <span class='neutral'>    );</span>
 403 |     | <span class='unexecuted'>    IERC20(PAIRED_LP_TOKEN).safeApprove(address(DEX_HANDLER), 0);</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='neutral'>    // check &amp; refund excess tokens from LPing</span>
 406 |     | <span class='unexecuted'>    if (balanceOf(address(this)) &gt; _idxTokensBefore) {</span>
 407 |     | <span class='unexecuted'>      super._transfer(</span>
 408 |     | <span class='unexecuted'>        address(this),</span>
 409 |     | <span class='neutral'>        _msgSender(),</span>
 410 |     | <span class='unexecuted'>        balanceOf(address(this)) - _idxTokensBefore</span>
 411 |     | <span class='neutral'>      );</span>
 412 |     | <span class='neutral'>    }</span>
 413 |     | <span class='unexecuted'>    if (IERC20(PAIRED_LP_TOKEN).balanceOf(address(this)) &gt; _pairedBefore) {</span>
 414 |     | <span class='unexecuted'>      IERC20(PAIRED_LP_TOKEN).safeTransfer(</span>
 415 |     | <span class='neutral'>        _msgSender(),</span>
 416 |     | <span class='unexecuted'>        IERC20(PAIRED_LP_TOKEN).balanceOf(address(this)) - _pairedBefore</span>
 417 |     | <span class='neutral'>      );</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='unexecuted'>    emit AddLiquidity(_msgSender(), _idxLPTokens, _pairedLPTokens);</span>
 420 |     | <span class='unexecuted'>    return</span>
 421 |     | <span class='unexecuted'>      IERC20(DEX_HANDLER.getV2Pool(address(this), PAIRED_LP_TOKEN)).balanceOf(</span>
 422 |     | <span class='neutral'>        _msgSender()</span>
 423 |     | <span class='unexecuted'>      ) - _poolBalBefore;</span>
 424 |     | <span class='neutral'>  }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='neutral'>  /// @notice The ```removeLiquidityV2``` function burns pod liquidity</span>
 427 |     | <span class='neutral'>  /// @param _lpTokens Number of liquidity tokens to burn/remove</span>
 428 |     | <span class='neutral'>  /// @param _minIdxTokens Number of pTKN to receive at a minimum, slippage</span>
 429 |     | <span class='neutral'>  /// @param _minPairedLpToken Number of pairedLpToken to receive at a minimum, slippage</span>
 430 |     | <span class='neutral'>  /// @param _deadline LP validation deadline</span>
 431 |     | <span class='unexecuted'>  function removeLiquidityV2(</span>
 432 |     | <span class='neutral'>    uint256 _lpTokens,</span>
 433 |     | <span class='neutral'>    uint256 _minIdxTokens, // 0 == 100% slippage</span>
 434 |     | <span class='neutral'>    uint256 _minPairedLpToken, // 0 == 100% slippage</span>
 435 |     | <span class='neutral'>    uint256 _deadline</span>
 436 |     | <span class='neutral'>  ) external override lock noSwapOrFee {</span>
 437 |     | <span class='unexecuted'>    _lpTokens = _lpTokens == 0</span>
 438 |     | <span class='unexecuted'>      ? IERC20(V2_POOL).balanceOf(_msgSender())</span>
 439 |     | <span class='unexecuted'>      : _lpTokens;</span>
 440 |     | <span class='unexecuted'>    require(_lpTokens &gt; 0, &#39;LT&#39;);</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='unexecuted'>    IERC20(V2_POOL).safeTransferFrom(_msgSender(), address(this), _lpTokens);</span>
 443 |     | <span class='unexecuted'>    IERC20(V2_POOL).safeIncreaseAllowance(address(DEX_HANDLER), _lpTokens);</span>
 444 |     | <span class='unexecuted'>    DEX_HANDLER.removeLiquidity(</span>
 445 |     | <span class='unexecuted'>      address(this),</span>
 446 |     | <span class='unexecuted'>      PAIRED_LP_TOKEN,</span>
 447 |     | <span class='neutral'>      _lpTokens,</span>
 448 |     | <span class='neutral'>      _minIdxTokens,</span>
 449 |     | <span class='neutral'>      _minPairedLpToken,</span>
 450 |     | <span class='neutral'>      _msgSender(),</span>
 451 |     | <span class='neutral'>      _deadline</span>
 452 |     | <span class='neutral'>    );</span>
 453 |     | <span class='unexecuted'>    emit RemoveLiquidity(_msgSender(), _lpTokens);</span>
 454 |     | <span class='neutral'>  }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>  /// @notice The ```flash``` function allows to flash loan underlying TKN from the pod</span>
 457 |     | <span class='neutral'>  /// @param _recipient User to receive underlying TKN for the flash loan</span>
 458 |     | <span class='neutral'>  /// @param _token TKN to borrow</span>
 459 |     | <span class='neutral'>  /// @param _amount Number of underying TKN to borrow</span>
 460 |     | <span class='neutral'>  /// @param _data Any data the recipient wants to be passed on the flash loan callback callback</span>
 461 |     | <span class='unexecuted'>  function flash(</span>
 462 |     | <span class='neutral'>    address _recipient,</span>
 463 |     | <span class='neutral'>    address _token,</span>
 464 |     | <span class='neutral'>    uint256 _amount,</span>
 465 |     | <span class='neutral'>    bytes calldata _data</span>
 466 |     | <span class='neutral'>  ) external override lock {</span>
 467 |     | <span class='unexecuted'>    require(_isTokenInIndex[_token], &#39;X&#39;);</span>
 468 |     | <span class='unexecuted'>    address _rewards = StakingPoolToken(lpStakingPool).POOL_REWARDS();</span>
 469 |     | <span class='unexecuted'>    address _feeRecipient = lpRewardsToken == DAI</span>
 470 |     | <span class='unexecuted'>      ? address(this)</span>
 471 |     | <span class='unexecuted'>      : PAIRED_LP_TOKEN == DAI</span>
 472 |     | <span class='unexecuted'>        ? _rewards</span>
 473 |     | <span class='unexecuted'>        : Ownable(address(V3_TWAP_UTILS)).owner();</span>
 474 |     | <span class='unexecuted'>    IERC20(DAI).safeTransferFrom(</span>
 475 |     | <span class='neutral'>      _msgSender(),</span>
 476 |     | <span class='neutral'>      _feeRecipient,</span>
 477 |     | <span class='unexecuted'>      FLASH_FEE_AMOUNT_DAI</span>
 478 |     | <span class='neutral'>    );</span>
 479 |     | <span class='unexecuted'>    if (lpRewardsToken == DAI) {</span>
 480 |     | <span class='unexecuted'>      IERC20(DAI).safeIncreaseAllowance(_rewards, FLASH_FEE_AMOUNT_DAI);</span>
 481 |     | <span class='unexecuted'>      ITokenRewards(_rewards).depositRewards(DAI, FLASH_FEE_AMOUNT_DAI);</span>
 482 |     | <span class='neutral'>    }</span>
 483 |     | <span class='unexecuted'>    uint256 _balance = IERC20(_token).balanceOf(address(this));</span>
 484 |     | <span class='unexecuted'>    IERC20(_token).safeTransfer(_recipient, _amount);</span>
 485 |     | <span class='unexecuted'>    IFlashLoanRecipient(_recipient).callback(_data);</span>
 486 |     | <span class='unexecuted'>    require(IERC20(_token).balanceOf(address(this)) &gt;= _balance, &#39;FA&#39;);</span>
 487 |     | <span class='unexecuted'>    emit FlashLoan(_msgSender(), _recipient, _token, _amount);</span>
 488 |     | <span class='neutral'>  }</span>
 489 |     | <span class='neutral'></span>
 490 |     | <span class='unexecuted'>  function setPartner(address _partner) external onlyPartner {</span>
 491 |     | <span class='unexecuted'>    config.partner = _partner;</span>
 492 |     | <span class='unexecuted'>    emit SetPartner(_msgSender(), _partner);</span>
 493 |     | <span class='neutral'>  }</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>  function setPartnerFee(uint16 _fee) external onlyPartner {</span>
 496 |     | <span class='unexecuted'>    require(_fee &lt; fees.partner, &#39;L&#39;);</span>
 497 |     | <span class='unexecuted'>    fees.partner = _fee;</span>
 498 |     | <span class='unexecuted'>    emit SetPartnerFee(_msgSender(), _fee);</span>
 499 |     | <span class='neutral'>  }</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='unexecuted'>  function rescueERC20(address _token) external lock {</span>
 502 |     | <span class='neutral'>    // cannot withdraw tokens/assets that belong to the index</span>
 503 |     | <span class='unexecuted'>    require(!isAsset(_token) &amp;&amp; _token != address(this), &#39;U&#39;);</span>
 504 |     | <span class='unexecuted'>    IERC20(_token).safeTransfer(</span>
 505 |     | <span class='unexecuted'>      Ownable(address(V3_TWAP_UTILS)).owner(),</span>
 506 |     | <span class='unexecuted'>      IERC20(_token).balanceOf(address(this))</span>
 507 |     | <span class='neutral'>    );</span>
 508 |     | <span class='neutral'>  }</span>
 509 |     | <span class='neutral'></span>
 510 | *   | <span class='executed'>  function rescueETH() external lock {</span>
 511 |     | <span class='unexecuted'>    require(address(this).balance &gt; 0, &#39;E&#39;);</span>
 512 |     | <span class='unexecuted'>    (bool _sent, ) = Ownable(address(V3_TWAP_UTILS)).owner().call{</span>
 513 |     | <span class='unexecuted'>      value: address(this).balance</span>
 514 |     | <span class='neutral'>    }(&#39;&#39;);</span>
 515 |     | <span class='unexecuted'>    require(_sent, &#39;S&#39;);</span>
 516 |     | <span class='neutral'>  }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>  receive() external payable {}</span>
 519 |     | <span class='neutral'>}</span>
 520 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/IndexUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/IDecentralizedIndex.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./interfaces/IIndexUtils.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./interfaces/IStakingPoolToken.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./interfaces/ITokenRewards.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV2Factory.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Pool.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV2Router02.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./interfaces/IWETH.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./Zapper.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract IndexUtils is Context, IIndexUtils, Zapper {</span>
  21 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>  constructor(</span>
  24 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  25 |     | <span class='neutral'>    IDexAdapter _dexAdapter</span>
  26 |     | <span class='unexecuted'>  ) Zapper(_v3TwapUtilities, _dexAdapter) {}</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>  function bond(</span>
  29 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
  30 |     | <span class='neutral'>    address _token,</span>
  31 |     | <span class='neutral'>    uint256 _amount,</span>
  32 |     | <span class='neutral'>    uint256 _amountMintMin</span>
  33 |     | <span class='unexecuted'>  ) external {</span>
  34 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund</span>
  35 |     | <span class='neutral'>      .getAllAssets();</span>
  36 |     | <span class='unexecuted'>    uint256[] memory _balsBefore = new uint256[](_assets.length);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(_indexFund));</span>
  39 |     | <span class='unexecuted'>    uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0</span>
  40 |     | <span class='neutral'>      ? FixedPoint96.Q96</span>
  41 |     | <span class='unexecuted'>      : (_amount * FixedPoint96.Q96) / _tokenCurSupply;</span>
  42 |     | <span class='unexecuted'>    uint256 _al = _assets.length;</span>
  43 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
  44 |     | <span class='unexecuted'>      uint256 _amountNeeded = _indexFund.totalSupply() == 0</span>
  45 |     | <span class='unexecuted'>        ? _indexFund.getInitialAmount(_token, _amount, _assets[_i].token)</span>
  46 |     | <span class='unexecuted'>        : (IERC20(_assets[_i].token).balanceOf(address(_indexFund)) *</span>
  47 |     | <span class='unexecuted'>          _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;</span>
  48 |     | <span class='unexecuted'>      _balsBefore[_i] = IERC20(_assets[_i].token).balanceOf(address(this));</span>
  49 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeTransferFrom(</span>
  50 |     | <span class='neutral'>        _msgSender(),</span>
  51 |     | <span class='unexecuted'>        address(this),</span>
  52 |     | <span class='unexecuted'>        _amountNeeded</span>
  53 |     | <span class='neutral'>      );</span>
  54 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeIncreaseAllowance(</span>
  55 |     | <span class='unexecuted'>        address(_indexFund),</span>
  56 |     | <span class='unexecuted'>        _amountNeeded</span>
  57 |     | <span class='neutral'>      );</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='unexecuted'>    uint256 _idxBalBefore = IERC20(_indexFund).balanceOf(address(this));</span>
  60 |     | <span class='unexecuted'>    _indexFund.bond(_token, _amount, _amountMintMin);</span>
  61 |     | <span class='unexecuted'>    IERC20(_indexFund).safeTransfer(</span>
  62 |     | <span class='unexecuted'>      _msgSender(),</span>
  63 |     | <span class='neutral'>      IERC20(_indexFund).balanceOf(address(this)) - _idxBalBefore</span>
  64 |     | <span class='neutral'>    );</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // refund any excess tokens to user we didn&#39;t use to bond</span>
  67 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
  68 |     | <span class='unexecuted'>      _checkAndRefundERC20(_msgSender(), _assets[_i].token, _balsBefore[_i]);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'>  }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>  function bondWeightedFromNative(</span>
  73 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
  74 |     | <span class='neutral'>    uint256 _assetIdx,</span>
  75 |     | <span class='neutral'>    uint256 _amountTokensForAssetIdx,</span>
  76 |     | <span class='neutral'>    uint256 _amountMintMin,</span>
  77 |     | <span class='neutral'>    uint256 _amountPairedLpTokenMin,</span>
  78 |     | <span class='neutral'>    uint256 _slippage, // 1 == 0.1%, 10 == 1%, 1000 == 100%</span>
  79 |     | <span class='neutral'>    uint256 _deadline,</span>
  80 |     | <span class='neutral'>    bool _stakeAsWell</span>
  81 |     | <span class='unexecuted'>  ) external payable {</span>
  82 |     | <span class='unexecuted'>    require(msg.value &gt; 0, &#39;NATIVE&#39;);</span>
  83 |     | <span class='unexecuted'>    uint256 _ethBalBefore = address(this).balance - msg.value;</span>
  84 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund</span>
  85 |     | <span class='neutral'>      .getAllAssets();</span>
  86 |     | <span class='unexecuted'>    (</span>
  87 |     | <span class='unexecuted'>      uint256[] memory _balancesBefore,</span>
  88 |     | <span class='unexecuted'>      uint256[] memory _amountsReceived</span>
  89 |     | <span class='unexecuted'>    ) = _swapNativeForTokensWeightedV2(</span>
  90 |     | <span class='unexecuted'>        _indexFund,</span>
  91 |     | <span class='unexecuted'>        _stakeAsWell ? msg.value / 2 : msg.value,</span>
  92 |     | <span class='unexecuted'>        _assets,</span>
  93 |     | <span class='unexecuted'>        _assetIdx,</span>
  94 |     | <span class='unexecuted'>        _amountTokensForAssetIdx</span>
  95 |     | <span class='neutral'>      );</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // allowance for _assetIdx is increased in _bondToRecipient below,</span>
  98 |     | <span class='neutral'>    // we just need to increase allowance for any other index tokens here first</span>
  99 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _assets.length; _i++) {</span>
 100 |     | <span class='unexecuted'>      if (_i == _assetIdx) {</span>
 101 |     | <span class='unexecuted'>        continue;</span>
 102 |     | <span class='neutral'>      }</span>
 103 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeIncreaseAllowance(</span>
 104 |     | <span class='unexecuted'>        address(_indexFund),</span>
 105 |     | <span class='unexecuted'>        _amountsReceived[_i]</span>
 106 |     | <span class='neutral'>      );</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='unexecuted'>    uint256 _idxTokensGained = _bondToRecipient(</span>
 109 |     | <span class='unexecuted'>      _indexFund,</span>
 110 |     | <span class='unexecuted'>      _assets[_assetIdx].token,</span>
 111 |     | <span class='unexecuted'>      _amountsReceived[_assetIdx],</span>
 112 |     | <span class='unexecuted'>      _amountMintMin,</span>
 113 |     | <span class='unexecuted'>      _stakeAsWell ? address(this) : _msgSender()</span>
 114 |     | <span class='neutral'>    );</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    if (_stakeAsWell) {</span>
 117 |     | <span class='unexecuted'>      _zapIndexTokensAndNative(</span>
 118 |     | <span class='neutral'>        _msgSender(),</span>
 119 |     | <span class='unexecuted'>        _indexFund,</span>
 120 |     | <span class='unexecuted'>        _idxTokensGained,</span>
 121 |     | <span class='unexecuted'>        msg.value / 2,</span>
 122 |     | <span class='unexecuted'>        _amountPairedLpTokenMin,</span>
 123 |     | <span class='unexecuted'>        _slippage,</span>
 124 |     | <span class='unexecuted'>        _deadline</span>
 125 |     | <span class='neutral'>      );</span>
 126 |     | <span class='neutral'>    }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    // refund any excess tokens to user we didn&#39;t use to bond</span>
 129 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _assets.length; _i++) {</span>
 130 |     | <span class='unexecuted'>      _checkAndRefundERC20(</span>
 131 |     | <span class='neutral'>        _msgSender(),</span>
 132 |     | <span class='unexecuted'>        _assets[_i].token,</span>
 133 |     | <span class='unexecuted'>        _balancesBefore[_i]</span>
 134 |     | <span class='neutral'>      );</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    // refund excess ETH</span>
 138 |     | <span class='unexecuted'>    if (address(this).balance &gt; _ethBalBefore) {</span>
 139 |     | <span class='unexecuted'>      (bool _s, ) = payable(_msgSender()).call{</span>
 140 |     | <span class='unexecuted'>        value: address(this).balance - _ethBalBefore</span>
 141 |     | <span class='neutral'>      }(&#39;&#39;);</span>
 142 |     | <span class='unexecuted'>      require(_s, &#39;ETHREFUND&#39;);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'>  }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>  function addLPAndStake(</span>
 147 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 148 |     | <span class='neutral'>    uint256 _amountIdxTokens,</span>
 149 |     | <span class='neutral'>    address _pairedLpTokenProvided,</span>
 150 |     | <span class='neutral'>    uint256 _amtPairedLpTokenProvided,</span>
 151 |     | <span class='neutral'>    uint256 _amountPairedLpTokenMin,</span>
 152 |     | <span class='neutral'>    uint256 _slippage,</span>
 153 |     | <span class='neutral'>    uint256 _deadline</span>
 154 |     | <span class='unexecuted'>  ) external payable override returns (uint256 _amountOut) {</span>
 155 |     | <span class='unexecuted'>    address _indexFundAddy = address(_indexFund);</span>
 156 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 157 |     | <span class='unexecuted'>    uint256 _idxTokensBefore = IERC20(_indexFundAddy).balanceOf(address(this));</span>
 158 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 159 |     | <span class='unexecuted'>      address(this)</span>
 160 |     | <span class='neutral'>    );</span>
 161 |     | <span class='unexecuted'>    uint256 _ethBefore = address(this).balance - msg.value;</span>
 162 |     | <span class='unexecuted'>    IERC20(_indexFundAddy).safeTransferFrom(</span>
 163 |     | <span class='neutral'>      _msgSender(),</span>
 164 |     | <span class='unexecuted'>      address(this),</span>
 165 |     | <span class='unexecuted'>      _amountIdxTokens</span>
 166 |     | <span class='neutral'>    );</span>
 167 |     | <span class='unexecuted'>    if (_pairedLpTokenProvided == address(0)) {</span>
 168 |     | <span class='unexecuted'>      require(msg.value &gt; 0, &#39;NEEDETH&#39;);</span>
 169 |     | <span class='unexecuted'>      _amtPairedLpTokenProvided = msg.value;</span>
 170 |     | <span class='neutral'>    } else {</span>
 171 |     | <span class='unexecuted'>      IERC20(_pairedLpTokenProvided).safeTransferFrom(</span>
 172 |     | <span class='neutral'>        _msgSender(),</span>
 173 |     | <span class='unexecuted'>        address(this),</span>
 174 |     | <span class='unexecuted'>        _amtPairedLpTokenProvided</span>
 175 |     | <span class='neutral'>      );</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='unexecuted'>    if (_pairedLpTokenProvided != _pairedLpToken) {</span>
 178 |     | <span class='unexecuted'>      _zap(</span>
 179 |     | <span class='unexecuted'>        _pairedLpTokenProvided,</span>
 180 |     | <span class='unexecuted'>        _pairedLpToken,</span>
 181 |     | <span class='unexecuted'>        _amtPairedLpTokenProvided,</span>
 182 |     | <span class='unexecuted'>        _amountPairedLpTokenMin</span>
 183 |     | <span class='neutral'>      );</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(</span>
 187 |     | <span class='unexecuted'>      _indexFundAddy,</span>
 188 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 189 |     | <span class='neutral'>    );</span>
 190 |     | <span class='unexecuted'>    _amountOut = _indexFund.addLiquidityV2(</span>
 191 |     | <span class='unexecuted'>      IERC20(_indexFundAddy).balanceOf(address(this)) - _idxTokensBefore,</span>
 192 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,</span>
 193 |     | <span class='neutral'>      _slippage,</span>
 194 |     | <span class='neutral'>      _deadline</span>
 195 |     | <span class='neutral'>    );</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='unexecuted'>    IERC20(DEX_ADAPTER.getV2Pool(_indexFundAddy, _pairedLpToken))</span>
 198 |     | <span class='unexecuted'>      .safeIncreaseAllowance(_indexFund.lpStakingPool(), _amountOut);</span>
 199 |     | <span class='unexecuted'>    IStakingPoolToken(_indexFund.lpStakingPool()).stake(</span>
 200 |     | <span class='neutral'>      _msgSender(),</span>
 201 |     | <span class='neutral'>      _amountOut</span>
 202 |     | <span class='neutral'>    );</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='neutral'>    // refunds if needed for index tokens and pairedLpToken</span>
 205 |     | <span class='unexecuted'>    if (address(this).balance &gt; _ethBefore) {</span>
 206 |     | <span class='unexecuted'>      (bool _s, ) = payable(_msgSender()).call{</span>
 207 |     | <span class='unexecuted'>        value: address(this).balance - _ethBefore</span>
 208 |     | <span class='neutral'>      }(&#39;&#39;);</span>
 209 |     | <span class='unexecuted'>      require(_s &amp;&amp; address(this).balance &gt;= _ethBefore, &#39;TOOMUCH&#39;);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='unexecuted'>    _checkAndRefundERC20(_msgSender(), _indexFundAddy, _idxTokensBefore);</span>
 212 |     | <span class='unexecuted'>    _checkAndRefundERC20(_msgSender(), _pairedLpToken, _pairedLpTokenBefore);</span>
 213 |     | <span class='neutral'>  }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='unexecuted'>  function unstakeAndRemoveLP(</span>
 216 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 217 |     | <span class='neutral'>    uint256 _amountStakedTokens,</span>
 218 |     | <span class='neutral'>    uint256 _minLPTokens,</span>
 219 |     | <span class='neutral'>    uint256 _minPairedLpToken,</span>
 220 |     | <span class='neutral'>    uint256 _deadline</span>
 221 |     | <span class='unexecuted'>  ) external override {</span>
 222 |     | <span class='unexecuted'>    address _stakingPool = _indexFund.lpStakingPool();</span>
 223 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 224 |     | <span class='unexecuted'>    uint256 _stakingBalBefore = IERC20(_stakingPool).balanceOf(address(this));</span>
 225 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 226 |     | <span class='unexecuted'>      address(this)</span>
 227 |     | <span class='neutral'>    );</span>
 228 |     | <span class='unexecuted'>    IERC20(_stakingPool).safeTransferFrom(</span>
 229 |     | <span class='neutral'>      _msgSender(),</span>
 230 |     | <span class='unexecuted'>      address(this),</span>
 231 |     | <span class='unexecuted'>      _amountStakedTokens</span>
 232 |     | <span class='neutral'>    );</span>
 233 |     | <span class='unexecuted'>    uint256 _indexBalBefore = _unstakeAndRemoveLP(</span>
 234 |     | <span class='unexecuted'>      _indexFund,</span>
 235 |     | <span class='unexecuted'>      _stakingPool,</span>
 236 |     | <span class='unexecuted'>      IERC20(_stakingPool).balanceOf(address(this)) - _stakingBalBefore,</span>
 237 |     | <span class='unexecuted'>      _minLPTokens,</span>
 238 |     | <span class='unexecuted'>      _minPairedLpToken,</span>
 239 |     | <span class='unexecuted'>      _deadline</span>
 240 |     | <span class='neutral'>    );</span>
 241 |     | <span class='unexecuted'>    if (</span>
 242 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).balanceOf(address(this)) &gt; _indexBalBefore</span>
 243 |     | <span class='neutral'>    ) {</span>
 244 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(</span>
 245 |     | <span class='unexecuted'>        _msgSender(),</span>
 246 |     | <span class='unexecuted'>        IERC20(address(_indexFund)).balanceOf(address(this)) - _indexBalBefore</span>
 247 |     | <span class='neutral'>      );</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='unexecuted'>    if (</span>
 250 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) &gt; _pairedLpTokenBefore</span>
 251 |     | <span class='neutral'>    ) {</span>
 252 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).safeTransfer(</span>
 253 |     | <span class='neutral'>        _msgSender(),</span>
 254 |     | <span class='unexecuted'>        IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 255 |     | <span class='neutral'>      );</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'>  }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='unexecuted'>  function claimRewardsMulti(address[] memory _rewards) external {</span>
 260 |     | <span class='unexecuted'>    uint256 _rl = _rewards.length;</span>
 261 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _rl; _i++) {</span>
 262 |     | <span class='unexecuted'>      ITokenRewards(_rewards[_i]).claimReward(_msgSender());</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'>  }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>  function _swapNativeForTokensWeightedV2(</span>
 267 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 268 |     | <span class='neutral'>    uint256 _amountNative,</span>
 269 |     | <span class='neutral'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets,</span>
 270 |     | <span class='neutral'>    uint256 _poolIdx,</span>
 271 |     | <span class='neutral'>    uint256 _amountForPoolIdx</span>
 272 |     | <span class='unexecuted'>  ) internal returns (uint256[] memory, uint256[] memory) {</span>
 273 |     | <span class='unexecuted'>    uint256[] memory _amountBefore = new uint256[](_assets.length);</span>
 274 |     | <span class='unexecuted'>    uint256[] memory _amountReceived = new uint256[](_assets.length);</span>
 275 |     | <span class='unexecuted'>    uint256 _tokenCurSupply = IERC20(_assets[_poolIdx].token).balanceOf(</span>
 276 |     | <span class='neutral'>      address(_indexFund)</span>
 277 |     | <span class='neutral'>    );</span>
 278 |     | <span class='unexecuted'>    uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0</span>
 279 |     | <span class='neutral'>      ? FixedPoint96.Q96</span>
 280 |     | <span class='unexecuted'>      : (_amountForPoolIdx * FixedPoint96.Q96) / _tokenCurSupply;</span>
 281 |     | <span class='unexecuted'>    uint256 _nativeLeft = _amountNative;</span>
 282 |     | <span class='unexecuted'>    uint256 _al = _assets.length;</span>
 283 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
 284 |     | <span class='unexecuted'>      (_nativeLeft, _amountBefore[_i], _amountReceived[_i]) = _swapForIdxToken(</span>
 285 |     | <span class='unexecuted'>        _indexFund,</span>
 286 |     | <span class='unexecuted'>        _assets[_poolIdx].token,</span>
 287 |     | <span class='unexecuted'>        _amountForPoolIdx,</span>
 288 |     | <span class='unexecuted'>        _assets[_i].token,</span>
 289 |     | <span class='unexecuted'>        _tokenAmtSupplyRatioX96,</span>
 290 |     | <span class='unexecuted'>        _nativeLeft</span>
 291 |     | <span class='neutral'>      );</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='unexecuted'>    return (_amountBefore, _amountReceived);</span>
 294 |     | <span class='neutral'>  }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>  function _swapForIdxToken(</span>
 297 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 298 |     | <span class='neutral'>    address _initToken,</span>
 299 |     | <span class='neutral'>    uint256 _initTokenAmount,</span>
 300 |     | <span class='neutral'>    address _outToken,</span>
 301 |     | <span class='neutral'>    uint256 _tokenAmtSupplyRatioX96,</span>
 302 |     | <span class='neutral'>    uint256 _nativeLeft</span>
 303 |     | <span class='neutral'>  )</span>
 304 |     | <span class='neutral'>    internal</span>
 305 |     | <span class='neutral'>    returns (</span>
 306 |     | <span class='unexecuted'>      uint256 _newNativeLeft,</span>
 307 |     | <span class='unexecuted'>      uint256 _amountBefore,</span>
 308 |     | <span class='unexecuted'>      uint256 _amountReceived</span>
 309 |     | <span class='neutral'>    )</span>
 310 |     | <span class='unexecuted'>  {</span>
 311 |     | <span class='unexecuted'>    address _weth = DEX_ADAPTER.WETH();</span>
 312 |     | <span class='unexecuted'>    if (address(this).balance &gt; 0) {</span>
 313 |     | <span class='unexecuted'>      IWETH(WETH).deposit{ value: address(this).balance }();</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='unexecuted'>    uint256 _nativeBefore = IERC20(_weth).balanceOf(address(this));</span>
 316 |     | <span class='unexecuted'>    _amountBefore = IERC20(_outToken).balanceOf(address(this));</span>
 317 |     | <span class='unexecuted'>    uint256 _amountOut = _indexFund.totalSupply() == 0</span>
 318 |     | <span class='unexecuted'>      ? _indexFund.getInitialAmount(_initToken, _initTokenAmount, _outToken)</span>
 319 |     | <span class='unexecuted'>      : (IERC20(_outToken).balanceOf(address(_indexFund)) *</span>
 320 |     | <span class='unexecuted'>        _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;</span>
 321 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 322 |     | <span class='neutral'>      _weth,</span>
 323 |     | <span class='neutral'>      _outToken,</span>
 324 |     | <span class='neutral'>      _nativeLeft,</span>
 325 |     | <span class='neutral'>      _amountOut,</span>
 326 |     | <span class='unexecuted'>      address(this)</span>
 327 |     | <span class='neutral'>    );</span>
 328 |     | <span class='unexecuted'>    _newNativeLeft =</span>
 329 |     | <span class='unexecuted'>      _nativeLeft -</span>
 330 |     | <span class='unexecuted'>      (_nativeBefore - IERC20(_weth).balanceOf(address(this)));</span>
 331 |     | <span class='unexecuted'>    _amountReceived =</span>
 332 |     | <span class='unexecuted'>      IERC20(_outToken).balanceOf(address(this)) -</span>
 333 |     | <span class='unexecuted'>      _amountBefore;</span>
 334 |     | <span class='neutral'>  }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>  function _unstakeAndRemoveLP(</span>
 337 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 338 |     | <span class='neutral'>    address _stakingPool,</span>
 339 |     | <span class='neutral'>    uint256 _unstakeAmount,</span>
 340 |     | <span class='neutral'>    uint256 _minLPTokens,</span>
 341 |     | <span class='neutral'>    uint256 _minPairedLpTokens,</span>
 342 |     | <span class='neutral'>    uint256 _deadline</span>
 343 |     | <span class='unexecuted'>  ) internal returns (uint256 _fundTokensBefore) {</span>
 344 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 345 |     | <span class='unexecuted'>    address _v2Pool = DEX_ADAPTER.getV2Pool(</span>
 346 |     | <span class='neutral'>      address(_indexFund),</span>
 347 |     | <span class='neutral'>      _pairedLpToken</span>
 348 |     | <span class='neutral'>    );</span>
 349 |     | <span class='unexecuted'>    uint256 _v2TokensBefore = IERC20(_v2Pool).balanceOf(address(this));</span>
 350 |     | <span class='unexecuted'>    IStakingPoolToken(_stakingPool).unstake(_unstakeAmount);</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>    _fundTokensBefore = _indexFund.balanceOf(address(this));</span>
 353 |     | <span class='unexecuted'>    IERC20(_v2Pool).safeIncreaseAllowance(</span>
 354 |     | <span class='unexecuted'>      address(_indexFund),</span>
 355 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore</span>
 356 |     | <span class='neutral'>    );</span>
 357 |     | <span class='unexecuted'>    _indexFund.removeLiquidityV2(</span>
 358 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore,</span>
 359 |     | <span class='neutral'>      _minLPTokens,</span>
 360 |     | <span class='neutral'>      _minPairedLpTokens,</span>
 361 |     | <span class='neutral'>      _deadline</span>
 362 |     | <span class='neutral'>    );</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>  function _bondToRecipient(</span>
 366 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 367 |     | <span class='neutral'>    address _indexToken,</span>
 368 |     | <span class='neutral'>    uint256 _bondTokens,</span>
 369 |     | <span class='neutral'>    uint256 _amountMintMin,</span>
 370 |     | <span class='neutral'>    address _recipient</span>
 371 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 372 |     | <span class='unexecuted'>    uint256 _idxTokensBefore = IERC20(address(_indexFund)).balanceOf(</span>
 373 |     | <span class='unexecuted'>      address(this)</span>
 374 |     | <span class='neutral'>    );</span>
 375 |     | <span class='unexecuted'>    IERC20(_indexToken).safeIncreaseAllowance(address(_indexFund), _bondTokens);</span>
 376 |     | <span class='unexecuted'>    _indexFund.bond(_indexToken, _bondTokens, _amountMintMin);</span>
 377 |     | <span class='unexecuted'>    uint256 _idxTokensGained = IERC20(address(_indexFund)).balanceOf(</span>
 378 |     | <span class='unexecuted'>      address(this)</span>
 379 |     | <span class='unexecuted'>    ) - _idxTokensBefore;</span>
 380 |     | <span class='unexecuted'>    if (_recipient != address(this)) {</span>
 381 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(_recipient, _idxTokensGained);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='unexecuted'>    return _idxTokensGained;</span>
 384 |     | <span class='neutral'>  }</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>  function _zapIndexTokensAndNative(</span>
 387 |     | <span class='neutral'>    address _user,</span>
 388 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 389 |     | <span class='neutral'>    uint256 _amountTokens,</span>
 390 |     | <span class='neutral'>    uint256 _amountETH,</span>
 391 |     | <span class='neutral'>    uint256 _amtPairedLpTokenMin,</span>
 392 |     | <span class='neutral'>    uint256 _slippage,</span>
 393 |     | <span class='neutral'>    uint256 _deadline</span>
 394 |     | <span class='neutral'>  ) internal {</span>
 395 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 396 |     | <span class='unexecuted'>    uint256 _tokensBefore = IERC20(address(_indexFund)).balanceOf(</span>
 397 |     | <span class='unexecuted'>      address(this)</span>
 398 |     | <span class='unexecuted'>    ) - _amountTokens;</span>
 399 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 400 |     | <span class='unexecuted'>      address(this)</span>
 401 |     | <span class='neutral'>    );</span>
 402 |     | <span class='unexecuted'>    address _stakingPool = _indexFund.lpStakingPool();</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='unexecuted'>    _zap(address(0), _pairedLpToken, _amountETH, _amtPairedLpTokenMin);</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='unexecuted'>    address _v2Pool = DEX_ADAPTER.getV2Pool(</span>
 407 |     | <span class='neutral'>      address(_indexFund),</span>
 408 |     | <span class='neutral'>      _pairedLpToken</span>
 409 |     | <span class='neutral'>    );</span>
 410 |     | <span class='unexecuted'>    uint256 _lpTokensBefore = IERC20(_v2Pool).balanceOf(address(this));</span>
 411 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(</span>
 412 |     | <span class='unexecuted'>      address(_indexFund),</span>
 413 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 414 |     | <span class='neutral'>    );</span>
 415 |     | <span class='unexecuted'>    _indexFund.addLiquidityV2(</span>
 416 |     | <span class='unexecuted'>      _amountTokens,</span>
 417 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,</span>
 418 |     | <span class='neutral'>      _slippage,</span>
 419 |     | <span class='neutral'>      _deadline</span>
 420 |     | <span class='neutral'>    );</span>
 421 |     | <span class='unexecuted'>    IERC20(_v2Pool).safeIncreaseAllowance(</span>
 422 |     | <span class='unexecuted'>      _stakingPool,</span>
 423 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore</span>
 424 |     | <span class='neutral'>    );</span>
 425 |     | <span class='unexecuted'>    IStakingPoolToken(_stakingPool).stake(</span>
 426 |     | <span class='unexecuted'>      _user,</span>
 427 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore</span>
 428 |     | <span class='neutral'>    );</span>
 429 |     | <span class='neutral'></span>
 430 |     | <span class='neutral'>    // check &amp; refund excess tokens from LPing as needed</span>
 431 |     | <span class='unexecuted'>    if (IERC20(address(_indexFund)).balanceOf(address(this)) &gt; _tokensBefore) {</span>
 432 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(</span>
 433 |     | <span class='unexecuted'>        _user,</span>
 434 |     | <span class='unexecuted'>        IERC20(address(_indexFund)).balanceOf(address(this)) - _tokensBefore</span>
 435 |     | <span class='neutral'>      );</span>
 436 |     | <span class='neutral'>    }</span>
 437 |     | <span class='unexecuted'>    if (</span>
 438 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) &gt; _pairedLpTokenBefore</span>
 439 |     | <span class='neutral'>    ) {</span>
 440 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).safeTransfer(</span>
 441 |     | <span class='unexecuted'>        _user,</span>
 442 |     | <span class='unexecuted'>        IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 443 |     | <span class='neutral'>      );</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'>  }</span>
 446 |     | <span class='neutral'></span>
 447 |     | <span class='unexecuted'>  function _checkAndRefundERC20(</span>
 448 |     | <span class='neutral'>    address _user,</span>
 449 |     | <span class='neutral'>    address _asset,</span>
 450 |     | <span class='neutral'>    uint256 _beforeBal</span>
 451 |     | <span class='neutral'>  ) internal {</span>
 452 |     | <span class='unexecuted'>    uint256 _curBal = IERC20(_asset).balanceOf(address(this));</span>
 453 |     | <span class='unexecuted'>    if (_curBal &gt; _beforeBal) {</span>
 454 |     | <span class='unexecuted'>      IERC20(_asset).safeTransfer(_user, _curBal - _beforeBal);</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'>  }</span>
 457 |     | <span class='neutral'>}</span>
 458 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/LendingAssetVault.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/ILendingAssetVault.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>interface IVaultInterestUpdate {</span>
  12 |     | <span class='neutral'>  function addInterest() external;</span>
  13 |     | <span class='neutral'>}</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>contract LendingAssetVault is</span>
  16 |     | <span class='neutral'>  IERC4626,</span>
  17 |     | <span class='neutral'>  ILendingAssetVault,</span>
  18 |     | <span class='neutral'>  ERC20,</span>
  19 |     | <span class='neutral'>  ERC20Permit,</span>
  20 |     | <span class='neutral'>  Ownable</span>
  21 |     | <span class='neutral'>{</span>
  22 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>  uint16 constant PERCENTAGE_PRECISION = 10000;</span>
  25 |     | <span class='unexecuted'>  uint256 constant PRECISION = 10 ** 27;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>  address _asset;</span>
  28 |     | <span class='neutral'>  uint256 _totalAssets;</span>
  29 |     | <span class='neutral'>  uint256 _totalAssetsUtilized;</span>
  30 |     | <span class='unexecuted'>  bool _updateInterestOnVaults = true;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>  uint8 public maxVaults = 12;</span>
  33 |     | <span class='unexecuted'>  uint256 public lastAssetChange;</span>
  34 |     | <span class='unexecuted'>  mapping(address =&gt; bool) public vaultWhitelist;</span>
  35 |     | <span class='unexecuted'>  mapping(address =&gt; uint256) public vaultUtilization;</span>
  36 |     | <span class='neutral'>  mapping(address =&gt; uint256) _vaultMaxPerc;</span>
  37 |     | <span class='neutral'>  mapping(address =&gt; uint256) _vaultWhitelistCbr;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>  address[] _vaultWhitelistAry;</span>
  40 |     | <span class='neutral'>  // vault address =&gt; idx in _vaultWhitelistAry</span>
  41 |     | <span class='neutral'>  mapping(address =&gt; uint256) _vaultWhitelistAryIdx;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>  modifier onlyWhitelist() {</span>
  44 |     | <span class='unexecuted'>    require(vaultWhitelist[_msgSender()], &#39;WL&#39;);</span>
  45 |     | <span class='neutral'>    _;</span>
  46 |     | <span class='neutral'>  }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>  constructor(</span>
  49 |     | <span class='neutral'>    string memory _name,</span>
  50 |     | <span class='neutral'>    string memory _symbol,</span>
  51 |     | <span class='neutral'>    address __asset</span>
  52 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) ERC20Permit(_name) {</span>
  53 |     | <span class='unexecuted'>    _asset = __asset;</span>
  54 |     | <span class='neutral'>  }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>  function asset() external view override returns (address) {</span>
  57 |     | <span class='unexecuted'>    return _asset;</span>
  58 |     | <span class='neutral'>  }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='unexecuted'>  function totalAssets() public view override returns (uint256) {</span>
  61 |     | <span class='unexecuted'>    return _totalAssets;</span>
  62 |     | <span class='neutral'>  }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='unexecuted'>  function totalAvailableAssets() public view override returns (uint256) {</span>
  65 |     | <span class='unexecuted'>    return _totalAssets - _totalAssetsUtilized;</span>
  66 |     | <span class='neutral'>  }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>  function convertToShares(</span>
  69 |     | <span class='neutral'>    uint256 _assets</span>
  70 |     | <span class='unexecuted'>  ) public view override returns (uint256 _shares) {</span>
  71 |     | <span class='unexecuted'>    _shares = (_assets * PRECISION) / _cbr();</span>
  72 |     | <span class='neutral'>  }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>  function convertToAssets(</span>
  75 |     | <span class='neutral'>    uint256 _shares</span>
  76 |     | <span class='unexecuted'>  ) public view override returns (uint256 _assets) {</span>
  77 |     | <span class='unexecuted'>    _assets = (_shares * _cbr()) / PRECISION;</span>
  78 |     | <span class='neutral'>  }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>  function maxDeposit(</span>
  81 |     | <span class='neutral'>    address</span>
  82 |     | <span class='unexecuted'>  ) external pure override returns (uint256 maxAssets) {</span>
  83 |     | <span class='unexecuted'>    maxAssets = type(uint256).max - 1;</span>
  84 |     | <span class='neutral'>  }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>  function previewDeposit(</span>
  87 |     | <span class='neutral'>    uint256 _assets</span>
  88 |     | <span class='neutral'>  ) external view override returns (uint256 _shares) {</span>
  89 |     | <span class='neutral'>    _shares = convertToShares(_assets);</span>
  90 |     | <span class='neutral'>  }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>  function deposit(</span>
  93 |     | <span class='neutral'>    uint256 _assets,</span>
  94 |     | <span class='neutral'>    address _receiver</span>
  95 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
  96 |     | <span class='unexecuted'>    _shares = _deposit(_assets, _receiver);</span>
  97 |     | <span class='neutral'>  }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>  function _deposit(</span>
 100 |     | <span class='neutral'>    uint256 _assets,</span>
 101 |     | <span class='neutral'>    address _receiver</span>
 102 |     | <span class='unexecuted'>  ) internal returns (uint256 _shares) {</span>
 103 |     | <span class='unexecuted'>    lastAssetChange = block.timestamp;</span>
 104 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 105 |     | <span class='unexecuted'>    _totalAssets += _assets;</span>
 106 |     | <span class='unexecuted'>    _mint(_receiver, _shares);</span>
 107 |     | <span class='unexecuted'>    IERC20(_asset).safeTransferFrom(_msgSender(), address(this), _assets);</span>
 108 |     | <span class='unexecuted'>    _updateInterestInAllVaults();</span>
 109 |     | <span class='unexecuted'>    emit Deposit(_msgSender(), _receiver, _assets, _shares);</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>  function maxMint(address) external pure override returns (uint256 maxShares) {</span>
 113 |     | <span class='neutral'>    maxShares = type(uint256).max - 1;</span>
 114 |     | <span class='neutral'>  }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>  function previewMint(</span>
 117 |     | <span class='neutral'>    uint256 _shares</span>
 118 |     | <span class='neutral'>  ) external view override returns (uint256 _assets) {</span>
 119 |     | <span class='neutral'>    _assets = convertToAssets(_shares);</span>
 120 |     | <span class='neutral'>  }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>  function mint(</span>
 123 |     | <span class='neutral'>    uint256 _shares,</span>
 124 |     | <span class='neutral'>    address _receiver</span>
 125 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 126 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 127 |     | <span class='unexecuted'>    _deposit(_assets, _receiver);</span>
 128 |     | <span class='neutral'>  }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>  function maxWithdraw(</span>
 131 |     | <span class='neutral'>    address _owner</span>
 132 |     | <span class='unexecuted'>  ) external view override returns (uint256 _maxAssets) {</span>
 133 |     | <span class='unexecuted'>    _maxAssets = (balanceOf(_owner) * _cbr()) / PRECISION;</span>
 134 |     | <span class='neutral'>  }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>  function previewWithdraw(</span>
 137 |     | <span class='neutral'>    uint256 _assets</span>
 138 |     | <span class='unexecuted'>  ) external view override returns (uint256 _shares) {</span>
 139 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 140 |     | <span class='neutral'>  }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>  function withdraw(</span>
 143 |     | <span class='neutral'>    uint256 _assets,</span>
 144 |     | <span class='neutral'>    address _receiver,</span>
 145 |     | <span class='neutral'>    address</span>
 146 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
 147 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 148 |     | <span class='unexecuted'>    _withdraw(_shares, _receiver);</span>
 149 |     | <span class='neutral'>  }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='unexecuted'>  function maxRedeem(</span>
 152 |     | <span class='neutral'>    address _owner</span>
 153 |     | <span class='unexecuted'>  ) external view override returns (uint256 _maxShares) {</span>
 154 |     | <span class='unexecuted'>    _maxShares = balanceOf(_owner);</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>  function previewRedeem(</span>
 158 |     | <span class='neutral'>    uint256 _shares</span>
 159 |     | <span class='unexecuted'>  ) external view override returns (uint256 _assets) {</span>
 160 |     | <span class='unexecuted'>    return convertToAssets(_shares);</span>
 161 |     | <span class='neutral'>  }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='unexecuted'>  function redeem(</span>
 164 |     | <span class='neutral'>    uint256 _shares,</span>
 165 |     | <span class='neutral'>    address _receiver,</span>
 166 |     | <span class='neutral'>    address</span>
 167 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 168 |     | <span class='unexecuted'>    _assets = _withdraw(_shares, _receiver);</span>
 169 |     | <span class='neutral'>  }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>  function donate(uint256 _assetAmt) external {</span>
 172 |     | <span class='unexecuted'>    _deposit(_assetAmt, address(this));</span>
 173 |     | <span class='unexecuted'>    _burn(address(this), convertToShares(_assetAmt));</span>
 174 |     | <span class='unexecuted'>    emit DonateAssets(_msgSender(), _assetAmt);</span>
 175 |     | <span class='neutral'>  }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>  /// @notice The ```whitelistWithdraw``` is called by any whitelisted vault to withdraw assets.</span>
 178 |     | <span class='neutral'>  /// @param _assetAmt the amount of underlying assets to withdraw</span>
 179 |     | <span class='unexecuted'>  function whitelistWithdraw(</span>
 180 |     | <span class='neutral'>    uint256 _assetAmt</span>
 181 |     | <span class='neutral'>  ) external override onlyWhitelist {</span>
 182 |     | <span class='neutral'>    address _vault = _msgSender();</span>
 183 |     | <span class='unexecuted'>    _updateAssetMetadataFromVault(_vault);</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    // validate that our new vault utilization does not exceed our max. Since we</span>
 186 |     | <span class='neutral'>    // call this after updating _totalAssets above it reflects the latest total,</span>
 187 |     | <span class='neutral'>    // but this is okay since we should validate total utilization after we account</span>
 188 |     | <span class='neutral'>    // for changes from this vault anyways</span>
 189 |     | <span class='unexecuted'>    require(</span>
 190 |     | <span class='unexecuted'>      (PERCENTAGE_PRECISION * (vaultUtilization[_vault] + _assetAmt)) /</span>
 191 |     | <span class='unexecuted'>        _totalAssets &lt;=</span>
 192 |     | <span class='unexecuted'>        _vaultMaxPerc[_vault],</span>
 193 |     | <span class='neutral'>      &#39;MAX&#39;</span>
 194 |     | <span class='neutral'>    );</span>
 195 |     | <span class='unexecuted'>    vaultUtilization[_vault] += _assetAmt;</span>
 196 |     | <span class='unexecuted'>    _totalAssetsUtilized += _assetAmt;</span>
 197 |     | <span class='unexecuted'>    IERC20(_asset).safeTransfer(_vault, _assetAmt);</span>
 198 |     | <span class='unexecuted'>    emit WhitelistWithdraw(_vault, _assetAmt);</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>  /// @notice The ```whitelistDeposit``` is called by any whitelisted target vault to deposit assets back into this vault.</span>
 202 |     | <span class='neutral'>  /// @notice need this instead of direct depositing in order to handle accounting for used assets and validation</span>
 203 |     | <span class='neutral'>  /// @param _assetAmt the amount of underlying assets to deposit</span>
 204 |     | <span class='unexecuted'>  function whitelistDeposit(uint256 _assetAmt) external override onlyWhitelist {</span>
 205 |     | <span class='neutral'>    address _vault = _msgSender();</span>
 206 |     | <span class='unexecuted'>    _updateAssetMetadataFromVault(_vault);</span>
 207 |     | <span class='unexecuted'>    vaultUtilization[_vault] -= _assetAmt;</span>
 208 |     | <span class='unexecuted'>    _totalAssetsUtilized -= _assetAmt;</span>
 209 |     | <span class='unexecuted'>    IERC20(_asset).safeTransferFrom(_vault, address(this), _assetAmt);</span>
 210 |     | <span class='unexecuted'>    emit WhitelistDeposit(_vault, _assetAmt);</span>
 211 |     | <span class='neutral'>  }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>  /// @notice The ```_updateAssetMetadataFromVault``` updates _totalAssets based on  the current ratio</span>
 214 |     | <span class='neutral'>  /// @notice of assets in the target vault to previously recorded ratio</span>
 215 |     | <span class='neutral'>  /// @notice to correctly calculate the change in total assets here based on how the vault share</span>
 216 |     | <span class='neutral'>  /// @notice has changed over time</span>
 217 |     | <span class='neutral'>  /// @param _vault the vault we&#39;re adjusting _totalAssets from based on it&#39;s CBR updates from last check</span>
 218 |     | <span class='unexecuted'>  function _updateAssetMetadataFromVault(address _vault) internal {</span>
 219 |     | <span class='unexecuted'>    uint256 _prevVaultCbr = _vaultWhitelistCbr[_vault];</span>
 220 |     | <span class='unexecuted'>    _vaultWhitelistCbr[_vault] = IERC4626(_vault).convertToAssets(PRECISION);</span>
 221 |     | <span class='unexecuted'>    if (_prevVaultCbr == 0) {</span>
 222 |     | <span class='unexecuted'>      return;</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='unexecuted'>    uint256 _vaultAssetRatioChange = _prevVaultCbr &gt; _vaultWhitelistCbr[_vault]</span>
 225 |     | <span class='unexecuted'>      ? ((PRECISION * _prevVaultCbr) / _vaultWhitelistCbr[_vault]) - PRECISION</span>
 226 |     | <span class='unexecuted'>      : ((PRECISION * _vaultWhitelistCbr[_vault]) / _prevVaultCbr) - PRECISION;</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    uint256 _currentAssetsUtilized = vaultUtilization[_vault];</span>
 229 |     | <span class='unexecuted'>    vaultUtilization[_vault] = _prevVaultCbr &gt; _vaultWhitelistCbr[_vault]</span>
 230 |     | <span class='unexecuted'>      ? _currentAssetsUtilized -</span>
 231 |     | <span class='unexecuted'>        (_currentAssetsUtilized * _vaultAssetRatioChange) /</span>
 232 |     | <span class='neutral'>        PRECISION</span>
 233 |     | <span class='unexecuted'>      : _currentAssetsUtilized +</span>
 234 |     | <span class='unexecuted'>        (_currentAssetsUtilized * _vaultAssetRatioChange) /</span>
 235 |     | <span class='neutral'>        PRECISION;</span>
 236 |     | <span class='unexecuted'>    _totalAssetsUtilized =</span>
 237 |     | <span class='unexecuted'>      _totalAssetsUtilized -</span>
 238 |     | <span class='unexecuted'>      _currentAssetsUtilized +</span>
 239 |     | <span class='neutral'>      vaultUtilization[_vault];</span>
 240 |     | <span class='unexecuted'>    _totalAssets =</span>
 241 |     | <span class='unexecuted'>      _totalAssets -</span>
 242 |     | <span class='unexecuted'>      _currentAssetsUtilized +</span>
 243 |     | <span class='unexecuted'>      vaultUtilization[_vault];</span>
 244 |     | <span class='neutral'>  }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='unexecuted'>  function _withdraw(</span>
 247 |     | <span class='neutral'>    uint256 _shares,</span>
 248 |     | <span class='neutral'>    address _receiver</span>
 249 |     | <span class='unexecuted'>  ) internal returns (uint256 _assets) {</span>
 250 |     | <span class='unexecuted'>    lastAssetChange = block.timestamp;</span>
 251 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 252 |     | <span class='unexecuted'>    _burn(_msgSender(), _shares);</span>
 253 |     | <span class='unexecuted'>    IERC20(_asset).safeTransfer(_receiver, _assets);</span>
 254 |     | <span class='unexecuted'>    _totalAssets -= _assets;</span>
 255 |     | <span class='unexecuted'>    _updateInterestInAllVaults();</span>
 256 |     | <span class='unexecuted'>    emit Withdraw(_msgSender(), _receiver, _receiver, _assets, _shares);</span>
 257 |     | <span class='neutral'>  }</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>  /// @notice Assumes underlying vault asset has decimals == 18</span>
 260 |     | <span class='unexecuted'>  function _cbr() internal view returns (uint256) {</span>
 261 |     | <span class='unexecuted'>    uint256 _supply = totalSupply();</span>
 262 |     | <span class='unexecuted'>    return _supply == 0 ? PRECISION : (PRECISION * _totalAssets) / _supply;</span>
 263 |     | <span class='neutral'>  }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>  function _assetDecimals() internal view returns (uint8) {</span>
 266 |     | <span class='neutral'>    return IERC20Metadata(_asset).decimals();</span>
 267 |     | <span class='neutral'>  }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='unexecuted'>  function _updateInterestInAllVaults() internal {</span>
 270 |     | <span class='unexecuted'>    if (!_updateInterestOnVaults) {</span>
 271 |     | <span class='neutral'>      return;</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _vaultWhitelistAry.length; _i++) {</span>
 274 |     | <span class='unexecuted'>      IVaultInterestUpdate(_vaultWhitelistAry[_i]).addInterest();</span>
 275 |     | <span class='neutral'>    }</span>
 276 |     | <span class='neutral'>  }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>  function setMaxVaults(uint8 _newMax) external onlyOwner {</span>
 279 |     | <span class='unexecuted'>    require(_newMax &lt;= 20, &#39;M&#39;);</span>
 280 |     | <span class='unexecuted'>    maxVaults = _newMax;</span>
 281 |     | <span class='neutral'>  }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>  function setUpdateInterestOnVaults(bool _exec) external onlyOwner {</span>
 284 |     | <span class='unexecuted'>    require(_updateInterestOnVaults != _exec, &#39;T&#39;);</span>
 285 |     | <span class='unexecuted'>    _updateInterestOnVaults = _exec;</span>
 286 |     | <span class='neutral'>  }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>  function setVaultWhitelist(address _vault, bool _allowed) external onlyOwner {</span>
 289 |     | <span class='unexecuted'>    require(vaultWhitelist[_vault] != _allowed, &#39;T&#39;);</span>
 290 |     | <span class='unexecuted'>    vaultWhitelist[_vault] = _allowed;</span>
 291 |     | <span class='unexecuted'>    if (_allowed) {</span>
 292 |     | <span class='unexecuted'>      require(_vaultWhitelistAry.length &lt;= maxVaults, &#39;M&#39;);</span>
 293 |     | <span class='unexecuted'>      _vaultWhitelistAryIdx[_vault] = _vaultWhitelistAry.length;</span>
 294 |     | <span class='unexecuted'>      _vaultWhitelistAry.push(_vault);</span>
 295 |     | <span class='neutral'>    } else {</span>
 296 |     | <span class='unexecuted'>      uint256 _idx = _vaultWhitelistAryIdx[_vault];</span>
 297 |     | <span class='unexecuted'>      address _movingVault = _vaultWhitelistAry[_vaultWhitelistAry.length - 1];</span>
 298 |     | <span class='unexecuted'>      _vaultWhitelistAry[_idx] = _movingVault;</span>
 299 |     | <span class='unexecuted'>      _vaultWhitelistAryIdx[_movingVault] = _idx;</span>
 300 |     | <span class='unexecuted'>      _vaultWhitelistAry.pop();</span>
 301 |     | <span class='neutral'>    }</span>
 302 |     | <span class='unexecuted'>    emit SetVaultWhitelist(_vault, _allowed);</span>
 303 |     | <span class='neutral'>  }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>  /// @notice The ```setVaultMaxPerc``` sets the maximum amount of vault assets allowed to be allocated to a whitelisted vault</span>
 306 |     | <span class='neutral'>  /// @param _vault the vault we&#39;re allocating to</span>
 307 |     | <span class='neutral'>  /// @param _percentage the percentage, up to PERCENTAGE_PRECISION (100%), of assets we can allocate to this vault</span>
 308 |     | <span class='unexecuted'>  function setVaultMaxPerc(</span>
 309 |     | <span class='neutral'>    address _vault,</span>
 310 |     | <span class='neutral'>    uint256 _percentage</span>
 311 |     | <span class='neutral'>  ) external onlyOwner {</span>
 312 |     | <span class='unexecuted'>    require(_percentage &lt;= PERCENTAGE_PRECISION, &#39;MAX&#39;);</span>
 313 |     | <span class='unexecuted'>    _vaultMaxPerc[_vault] = _percentage;</span>
 314 |     | <span class='unexecuted'>    emit SetVaultMaxAlloPercentage(_vault, _percentage);</span>
 315 |     | <span class='neutral'>  }</span>
 316 |     | <span class='neutral'>}</span>
 317 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/PEAS.sol</b>
<code>
  1 |     | <span class='neutral'>// https://peapods.finance</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;./interfaces/IPEAS.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 | *   | <span class='executed'>contract PEAS is IPEAS, ERC20 {</span>
 10 |     | <span class='unexecuted'>  constructor(</span>
 11 |     | <span class='neutral'>    string memory _name,</span>
 12 |     | <span class='neutral'>    string memory _symbol</span>
 13 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) {</span>
 14 |     | <span class='unexecuted'>    _mint(_msgSender(), 10_000_000 * 10 ** 18);</span>
 15 |     | <span class='neutral'>  }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>  function burn(uint256 _amount) external virtual override {</span>
 18 |     | <span class='unexecuted'>    _burn(_msgSender(), _amount);</span>
 19 |     | <span class='unexecuted'>    emit Burn(_msgSender(), _amount);</span>
 20 |     | <span class='neutral'>  }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/RewardsWhitelist.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./interfaces/IRewardsWhitelister.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract RewardsWhitelist is IRewardsWhitelister, Ownable {</span>
  8 |     | <span class='unexecuted'>  mapping(address =&gt; bool) public override whitelist;</span>
  9 |     | <span class='unexecuted'>  address[] public _whitelistAry;</span>
 10 |     | <span class='neutral'>  mapping(address =&gt; uint256) _whitelistAryIdx;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  event ToggleToken(address indexed token, bool isWhitelisted);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>  function getFullWhitelist()</span>
 15 |     | <span class='neutral'>    external</span>
 16 |     | <span class='neutral'>    view</span>
 17 |     | <span class='neutral'>    override</span>
 18 |     | <span class='unexecuted'>    returns (address[] memory)</span>
 19 |     | <span class='neutral'>  {</span>
 20 |     | <span class='unexecuted'>    return _whitelistAry;</span>
 21 |     | <span class='neutral'>  }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>  function toggleRewardsToken(</span>
 24 |     | <span class='neutral'>    address _token,</span>
 25 |     | <span class='neutral'>    bool _isWhitelisted</span>
 26 |     | <span class='neutral'>  ) external onlyOwner {</span>
 27 |     | <span class='unexecuted'>    require(whitelist[_token] != _isWhitelisted, &#39;OPP&#39;);</span>
 28 |     | <span class='unexecuted'>    whitelist[_token] = _isWhitelisted;</span>
 29 |     | <span class='unexecuted'>    if (_isWhitelisted) {</span>
 30 |     | <span class='unexecuted'>      _whitelistAryIdx[_token] = _whitelistAry.length;</span>
 31 |     | <span class='unexecuted'>      _whitelistAry.push(_token);</span>
 32 |     | <span class='neutral'>    } else {</span>
 33 |     | <span class='unexecuted'>      uint256 _idx = _whitelistAryIdx[_token];</span>
 34 |     | <span class='unexecuted'>      _whitelistAry[_idx] = _whitelistAry[_whitelistAry.length - 1];</span>
 35 |     | <span class='unexecuted'>      _whitelistAryIdx[_whitelistAry[_idx]] = _idx;</span>
 36 |     | <span class='unexecuted'>      _whitelistAry.pop();</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='unexecuted'>    emit ToggleToken(_token, _isWhitelisted);</span>
 39 |     | <span class='neutral'>  }</span>
 40 |     | <span class='neutral'>}</span>
 41 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/StakingPoolToken.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/IRewardsWhitelister.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/IProtocolFeeRouter.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/IStakingPoolToken.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./TokenRewards.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract StakingPoolToken is IStakingPoolToken, ERC20, Ownable {</span>
  14 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>  address public immutable override INDEX_FUND;</span>
  17 |     | <span class='unexecuted'>  address public immutable override POOL_REWARDS;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>  address public override stakeUserRestriction;</span>
  20 |     | <span class='unexecuted'>  address public override stakingToken;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>  IDexAdapter immutable DEX_ADAPTER;</span>
  23 |     | <span class='neutral'>  IV3TwapUtilities immutable V3_TWAP_UTILS;</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>  modifier onlyRestricted() {</span>
  26 |     | <span class='unexecuted'>    require(_msgSender() == stakeUserRestriction, &#39;R&#39;);</span>
  27 |     | <span class='neutral'>    _;</span>
  28 |     | <span class='neutral'>  }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>  event Debug(string a);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>  constructor(</span>
  33 |     | <span class='neutral'>    string memory _name,</span>
  34 |     | <span class='neutral'>    string memory _symbol,</span>
  35 |     | <span class='neutral'>    address _pairedLpToken,</span>
  36 |     | <span class='neutral'>    address _rewardsToken,</span>
  37 |     | <span class='neutral'>    address _stakeUserRestriction,</span>
  38 |     | <span class='neutral'>    IProtocolFeeRouter _feeRouter,</span>
  39 |     | <span class='neutral'>    IRewardsWhitelister _rewardsWhitelist,</span>
  40 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  41 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities</span>
  42 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) {</span>
  43 |     | <span class='unexecuted'>    emit Debug(&quot;BEFORE TOKEN REWARDS&quot;);</span>
  44 |     | <span class='unexecuted'>    stakeUserRestriction = _stakeUserRestriction;</span>
  45 |     | <span class='unexecuted'>    INDEX_FUND = _msgSender();</span>
  46 |     | <span class='unexecuted'>    DEX_ADAPTER = _dexAdapter;</span>
  47 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    emit Debug(&quot;BEFORE TOKEN REWARDS&quot;);</span>
  50 |     | <span class='unexecuted'>    POOL_REWARDS = address(</span>
  51 |     | <span class='unexecuted'>      new TokenRewards(</span>
  52 |     | <span class='unexecuted'>        _feeRouter,</span>
  53 |     | <span class='unexecuted'>        _rewardsWhitelist,</span>
  54 |     | <span class='unexecuted'>        _dexAdapter,</span>
  55 |     | <span class='unexecuted'>        _v3TwapUtilities,</span>
  56 |     | <span class='unexecuted'>        INDEX_FUND,</span>
  57 |     | <span class='unexecuted'>        _pairedLpToken,</span>
  58 |     | <span class='unexecuted'>        address(this),</span>
  59 |     | <span class='unexecuted'>        _rewardsToken</span>
  60 |     | <span class='neutral'>      )</span>
  61 |     | <span class='neutral'>    );</span>
  62 |     | <span class='unexecuted'>    emit Debug(&quot;AFTER TOKEN REWARDS&quot;);</span>
  63 |     | <span class='neutral'>  }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>  /// @dev backwards compatibility</span>
  66 |     | <span class='unexecuted'>  function indexFund() external view override returns (address) {</span>
  67 |     | <span class='unexecuted'>    return INDEX_FUND;</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>  /// @dev backwards compatibility</span>
  71 |     | <span class='unexecuted'>  function poolRewards() external view override returns (address) {</span>
  72 |     | <span class='unexecuted'>    return POOL_REWARDS;</span>
  73 |     | <span class='neutral'>  }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>  function stake(address _user, uint256 _amount) external override {</span>
  76 |     | <span class='unexecuted'>    require(stakingToken != address(0), &#39;I&#39;);</span>
  77 |     | <span class='unexecuted'>    if (stakeUserRestriction != address(0)) {</span>
  78 |     | <span class='unexecuted'>      require(_user == stakeUserRestriction, &#39;U&#39;);</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='unexecuted'>    _mint(_user, _amount);</span>
  81 |     | <span class='unexecuted'>    IERC20(stakingToken).safeTransferFrom(_msgSender(), address(this), _amount);</span>
  82 |     | <span class='unexecuted'>    emit Stake(_msgSender(), _user, _amount);</span>
  83 |     | <span class='neutral'>  }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>  function unstake(uint256 _amount) external override {</span>
  86 |     | <span class='unexecuted'>    _burn(_msgSender(), _amount);</span>
  87 |     | <span class='unexecuted'>    IERC20(stakingToken).safeTransfer(_msgSender(), _amount);</span>
  88 |     | <span class='unexecuted'>    emit Unstake(_msgSender(), _amount);</span>
  89 |     | <span class='neutral'>  }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>  function externalRewardHook(</span>
  92 |     | <span class='neutral'>    address _token0,</span>
  93 |     | <span class='neutral'>    address _token1</span>
  94 |     | <span class='unexecuted'>  ) external override {</span>
  95 |     | <span class='unexecuted'>    (bool _success, bytes memory _data) = address(DEX_ADAPTER).delegatecall(</span>
  96 |     | <span class='unexecuted'>      abi.encodeWithSignature(</span>
  97 |     | <span class='neutral'>        &#39;extraRewardsHook(address,address)&#39;,</span>
  98 |     | <span class='neutral'>        _token0,</span>
  99 |     | <span class='neutral'>        _token1</span>
 100 |     | <span class='neutral'>      )</span>
 101 |     | <span class='neutral'>    );</span>
 102 |     | <span class='unexecuted'>    require(_success, &#39;UNS&#39;);</span>
 103 |     | <span class='unexecuted'>    (address[] memory _tokens, uint256[] memory _amounts) = abi.decode(</span>
 104 |     | <span class='unexecuted'>      _data,</span>
 105 |     | <span class='neutral'>      (address[], uint256[])</span>
 106 |     | <span class='neutral'>    );</span>
 107 |     | <span class='unexecuted'>    address _receiver = Ownable(address(V3_TWAP_UTILS)).owner();</span>
 108 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _tokens.length; _i++) {</span>
 109 |     | <span class='unexecuted'>      if (_tokens[_i] == address(0)) {</span>
 110 |     | <span class='unexecuted'>        (bool _s, ) = payable(_receiver).call{ value: _amounts[_i] }(&#39;&#39;);</span>
 111 |     | <span class='unexecuted'>        require(_s, &#39;ES&#39;);</span>
 112 |     | <span class='neutral'>      } else {</span>
 113 |     | <span class='unexecuted'>        IERC20(_tokens[_i]).safeTransfer(_receiver, _amounts[_i]);</span>
 114 |     | <span class='neutral'>      }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'>  }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>  function setStakingToken(address _stakingToken) external onlyOwner {</span>
 119 |     | <span class='unexecuted'>    require(stakingToken == address(0), &#39;S&#39;);</span>
 120 |     | <span class='unexecuted'>    stakingToken = _stakingToken;</span>
 121 |     | <span class='neutral'>  }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>  function removeStakeUserRestriction() external onlyRestricted {</span>
 124 |     | <span class='unexecuted'>    stakeUserRestriction = address(0);</span>
 125 |     | <span class='neutral'>  }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>  function setStakeUserRestriction(address _user) external onlyRestricted {</span>
 128 |     | <span class='unexecuted'>    stakeUserRestriction = _user;</span>
 129 |     | <span class='neutral'>  }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>  function _afterTokenTransfer(</span>
 132 |     | <span class='neutral'>    address _from,</span>
 133 |     | <span class='neutral'>    address _to,</span>
 134 |     | <span class='neutral'>    uint256 _amount</span>
 135 |     | <span class='neutral'>  ) internal override {</span>
 136 |     | <span class='unexecuted'>    if (_from != address(0) &amp;&amp; _from != address(0xdead)) {</span>
 137 |     | <span class='unexecuted'>      TokenRewards(POOL_REWARDS).setShares(_from, _amount, true);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='unexecuted'>    if (_to != address(0) &amp;&amp; _to != address(0xdead)) {</span>
 140 |     | <span class='unexecuted'>      TokenRewards(POOL_REWARDS).setShares(_to, _amount, false);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'>  }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/TokenRewards.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/utils/Context.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./interfaces/IDecentralizedIndex.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./interfaces/IPEAS.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./interfaces/IRewardsWhitelister.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./interfaces/IProtocolFees.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./interfaces/IProtocolFeeRouter.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./interfaces/ITokenRewards.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./interfaces/IV3TwapUtilities.sol&#39;;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>contract TokenRewards is ITokenRewards, Context {</span>
  19 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>  uint256 constant PRECISION = 10 ** 36;</span>
  22 |     | <span class='unexecuted'>  uint256 constant REWARDS_SWAP_SLIPPAGE = 20; // 2%</span>
  23 |     | <span class='unexecuted'>  uint24 constant REWARDS_POOL_FEE = 10000; // 1%</span>
  24 |     | <span class='unexecuted'>  int24 constant REWARDS_TICK_SPACING = 200;</span>
  25 |     | <span class='neutral'>  address immutable INDEX_FUND;</span>
  26 |     | <span class='neutral'>  address immutable PAIRED_LP_TOKEN;</span>
  27 |     | <span class='neutral'>  IProtocolFeeRouter immutable PROTOCOL_FEE_ROUTER;</span>
  28 |     | <span class='neutral'>  IRewardsWhitelister immutable REWARDS_WHITELISTER;</span>
  29 |     | <span class='neutral'>  IDexAdapter immutable DEX_ADAPTER;</span>
  30 |     | <span class='neutral'>  IV3TwapUtilities immutable V3_TWAP_UTILS;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>  struct Reward {</span>
  33 |     | <span class='neutral'>    uint256 excluded;</span>
  34 |     | <span class='neutral'>    uint256 realized;</span>
  35 |     | <span class='neutral'>  }</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='unexecuted'>  address public immutable override trackingToken;</span>
  38 |     | <span class='unexecuted'>  address public immutable override rewardsToken; // main rewards token</span>
  39 |     | <span class='unexecuted'>  uint256 public override totalShares;</span>
  40 |     | <span class='unexecuted'>  uint256 public override totalStakers;</span>
  41 |     | <span class='unexecuted'>  mapping(address =&gt; uint256) public shares;</span>
  42 |     | <span class='neutral'>  // reward token =&gt; user =&gt; Reward</span>
  43 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; Reward)) public rewards;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>  uint256 _rewardsSwapAmountInOverride;</span>
  46 |     | <span class='neutral'>  // reward token =&gt; amount</span>
  47 |     | <span class='neutral'>  mapping(address =&gt; uint256) _rewardsPerShare;</span>
  48 |     | <span class='neutral'>  // reward token =&gt; amount</span>
  49 |     | <span class='unexecuted'>  mapping(address =&gt; uint256) public rewardsDistributed;</span>
  50 |     | <span class='neutral'>  // reward token =&gt; amount</span>
  51 |     | <span class='unexecuted'>  mapping(address =&gt; uint256) public rewardsDeposited;</span>
  52 |     | <span class='neutral'>  // all deposited rewards tokens</span>
  53 |     | <span class='neutral'>  address[] _allRewardsTokens;</span>
  54 |     | <span class='neutral'>  mapping(address =&gt; bool) _depositedRewardsToken;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    event Debug(string a);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>  constructor(</span>
  59 |     | <span class='neutral'>    IProtocolFeeRouter _feeRouter,</span>
  60 |     | <span class='neutral'>    IRewardsWhitelister _rewardsWhitelist,</span>
  61 |     | <span class='neutral'>    IDexAdapter _dexHandler,</span>
  62 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  63 |     | <span class='neutral'>    address _indexFund,</span>
  64 |     | <span class='neutral'>    address _pairedLpToken,</span>
  65 |     | <span class='neutral'>    address _trackingToken,</span>
  66 |     | <span class='neutral'>    address _rewardsToken</span>
  67 |     | <span class='neutral'>  ) {</span>
  68 |     | <span class='unexecuted'>    emit Debug(&quot;WTF&quot;);</span>
  69 |     | <span class='unexecuted'>    PROTOCOL_FEE_ROUTER = _feeRouter;</span>
  70 |     | <span class='unexecuted'>    REWARDS_WHITELISTER = _rewardsWhitelist;</span>
  71 |     | <span class='unexecuted'>    DEX_ADAPTER = _dexHandler;</span>
  72 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  73 |     | <span class='unexecuted'>    INDEX_FUND = _indexFund;</span>
  74 |     | <span class='unexecuted'>    PAIRED_LP_TOKEN = _pairedLpToken;</span>
  75 |     | <span class='unexecuted'>    trackingToken = _trackingToken;</span>
  76 |     | <span class='unexecuted'>    rewardsToken = _rewardsToken;</span>
  77 |     | <span class='neutral'>  }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>  function setShares(</span>
  80 |     | <span class='neutral'>    address _wallet,</span>
  81 |     | <span class='neutral'>    uint256 _amount,</span>
  82 |     | <span class='neutral'>    bool _sharesRemoving</span>
  83 |     | <span class='neutral'>  ) external override {</span>
  84 |     | <span class='unexecuted'>    require(_msgSender() == trackingToken, &#39;UNAUTHORIZED&#39;);</span>
  85 |     | <span class='unexecuted'>    _setShares(_wallet, _amount, _sharesRemoving);</span>
  86 |     | <span class='neutral'>  }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>  function _setShares(</span>
  89 |     | <span class='neutral'>    address _wallet,</span>
  90 |     | <span class='neutral'>    uint256 _amount,</span>
  91 |     | <span class='neutral'>    bool _sharesRemoving</span>
  92 |     | <span class='neutral'>  ) internal {</span>
  93 |     | <span class='unexecuted'>    _processFeesIfApplicable();</span>
  94 |     | <span class='unexecuted'>    if (_sharesRemoving) {</span>
  95 |     | <span class='unexecuted'>      _removeShares(_wallet, _amount);</span>
  96 |     | <span class='unexecuted'>      emit RemoveShares(_wallet, _amount);</span>
  97 |     | <span class='neutral'>    } else {</span>
  98 |     | <span class='unexecuted'>      _addShares(_wallet, _amount);</span>
  99 |     | <span class='unexecuted'>      emit AddShares(_wallet, _amount);</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'>  }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='unexecuted'>  function _addShares(address _wallet, uint256 _amount) internal {</span>
 104 |     | <span class='unexecuted'>    if (shares[_wallet] &gt; 0) {</span>
 105 |     | <span class='unexecuted'>      _distributeReward(_wallet);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='unexecuted'>    uint256 sharesBefore = shares[_wallet];</span>
 108 |     | <span class='unexecuted'>    totalShares += _amount;</span>
 109 |     | <span class='unexecuted'>    shares[_wallet] += _amount;</span>
 110 |     | <span class='unexecuted'>    if (sharesBefore == 0 &amp;&amp; shares[_wallet] &gt; 0) {</span>
 111 |     | <span class='unexecuted'>      totalStakers++;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='unexecuted'>    _resetExcluded(_wallet);</span>
 114 |     | <span class='neutral'>  }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>  function _removeShares(address _wallet, uint256 _amount) internal {</span>
 117 |     | <span class='unexecuted'>    require(shares[_wallet] &gt; 0 &amp;&amp; _amount &lt;= shares[_wallet], &#39;RE&#39;);</span>
 118 |     | <span class='unexecuted'>    _distributeReward(_wallet);</span>
 119 |     | <span class='unexecuted'>    totalShares -= _amount;</span>
 120 |     | <span class='unexecuted'>    shares[_wallet] -= _amount;</span>
 121 |     | <span class='unexecuted'>    if (shares[_wallet] == 0) {</span>
 122 |     | <span class='unexecuted'>      totalStakers--;</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='unexecuted'>    _resetExcluded(_wallet);</span>
 125 |     | <span class='neutral'>  }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='unexecuted'>  function _processFeesIfApplicable() internal {</span>
 128 |     | <span class='unexecuted'>    IDecentralizedIndex(INDEX_FUND).processPreSwapFeesAndSwap();</span>
 129 |     | <span class='neutral'>  }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='unexecuted'>  function depositFromPairedLpToken(</span>
 132 |     | <span class='neutral'>    uint256 _amountTknDepositing</span>
 133 |     | <span class='unexecuted'>  ) public override {</span>
 134 |     | <span class='unexecuted'>    require(PAIRED_LP_TOKEN != rewardsToken, &#39;R&#39;);</span>
 135 |     | <span class='unexecuted'>    if (_amountTknDepositing &gt; 0) {</span>
 136 |     | <span class='unexecuted'>      IERC20(PAIRED_LP_TOKEN).safeTransferFrom(</span>
 137 |     | <span class='neutral'>        _msgSender(),</span>
 138 |     | <span class='unexecuted'>        address(this),</span>
 139 |     | <span class='unexecuted'>        _amountTknDepositing</span>
 140 |     | <span class='neutral'>      );</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='unexecuted'>    uint256 _amountTkn = IERC20(PAIRED_LP_TOKEN).balanceOf(address(this));</span>
 143 |     | <span class='unexecuted'>    require(_amountTkn &gt; 0, &#39;A&#39;);</span>
 144 |     | <span class='unexecuted'>    uint256 _adminAmt = _getAdminFeeFromAmount(_amountTkn);</span>
 145 |     | <span class='unexecuted'>    _amountTkn -= _adminAmt;</span>
 146 |     | <span class='unexecuted'>    (address _token0, address _token1) = PAIRED_LP_TOKEN &lt; rewardsToken</span>
 147 |     | <span class='unexecuted'>      ? (PAIRED_LP_TOKEN, rewardsToken)</span>
 148 |     | <span class='unexecuted'>      : (rewardsToken, PAIRED_LP_TOKEN);</span>
 149 |     | <span class='unexecuted'>    address _pool;</span>
 150 |     | <span class='unexecuted'>    try DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_POOL_FEE) returns (</span>
 151 |     | <span class='neutral'>      address __pool</span>
 152 |     | <span class='neutral'>    ) {</span>
 153 |     | <span class='unexecuted'>      _pool = __pool;</span>
 154 |     | <span class='neutral'>    } catch {</span>
 155 |     | <span class='unexecuted'>      _pool = DEX_ADAPTER.getV3Pool(_token0, _token1, REWARDS_TICK_SPACING);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='unexecuted'>    uint160 _rewardsSqrtPriceX96 = V3_TWAP_UTILS</span>
 158 |     | <span class='neutral'>      .sqrtPriceX96FromPoolAndInterval(_pool);</span>
 159 |     | <span class='unexecuted'>    uint256 _rewardsPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(</span>
 160 |     | <span class='neutral'>      _rewardsSqrtPriceX96</span>
 161 |     | <span class='neutral'>    );</span>
 162 |     | <span class='unexecuted'>    uint256 _amountOut = _token0 == PAIRED_LP_TOKEN</span>
 163 |     | <span class='unexecuted'>      ? (_rewardsPriceX96 * _amountTkn) / FixedPoint96.Q96</span>
 164 |     | <span class='unexecuted'>      : (_amountTkn * FixedPoint96.Q96) / _rewardsPriceX96;</span>
 165 |     | <span class='unexecuted'>    _swapForRewards(_amountTkn, _amountOut, _adminAmt);</span>
 166 |     | <span class='neutral'>  }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>  function depositRewards(address _token, uint256 _amount) external override {</span>
 169 |     | <span class='unexecuted'>    _depositRewardsFromToken(_msgSender(), _token, _amount, true);</span>
 170 |     | <span class='neutral'>  }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>  function depositRewardsNoTransfer(</span>
 173 |     | <span class='neutral'>    address _token,</span>
 174 |     | <span class='neutral'>    uint256 _amount</span>
 175 |     | <span class='neutral'>  ) external override {</span>
 176 |     | <span class='unexecuted'>    require(_msgSender() == INDEX_FUND, &#39;AUTH&#39;);</span>
 177 |     | <span class='unexecuted'>    _depositRewardsFromToken(_msgSender(), _token, _amount, false);</span>
 178 |     | <span class='neutral'>  }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>  function _depositRewardsFromToken(</span>
 181 |     | <span class='neutral'>    address _user,</span>
 182 |     | <span class='neutral'>    address _token,</span>
 183 |     | <span class='neutral'>    uint256 _amount,</span>
 184 |     | <span class='neutral'>    bool _shouldTransfer</span>
 185 |     | <span class='unexecuted'>  ) internal {</span>
 186 |     | <span class='unexecuted'>    require(_amount &gt; 0, &#39;A&#39;);</span>
 187 |     | <span class='unexecuted'>    require(_isValidRewardsToken(_token), &#39;V&#39;);</span>
 188 |     | <span class='unexecuted'>    uint256 _finalAmt = _amount;</span>
 189 |     | <span class='unexecuted'>    if (_shouldTransfer) {</span>
 190 |     | <span class='unexecuted'>      uint256 _balBefore = IERC20(_token).balanceOf(address(this));</span>
 191 |     | <span class='unexecuted'>      IERC20(_token).safeTransferFrom(_user, address(this), _finalAmt);</span>
 192 |     | <span class='unexecuted'>      _finalAmt = IERC20(_token).balanceOf(address(this)) - _balBefore;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='unexecuted'>    uint256 _adminAmt = _getAdminFeeFromAmount(_finalAmt);</span>
 195 |     | <span class='unexecuted'>    if (_adminAmt &gt; 0) {</span>
 196 |     | <span class='unexecuted'>      IERC20(_token).safeTransfer(</span>
 197 |     | <span class='unexecuted'>        Ownable(address(V3_TWAP_UTILS)).owner(),</span>
 198 |     | <span class='unexecuted'>        _adminAmt</span>
 199 |     | <span class='neutral'>      );</span>
 200 |     | <span class='unexecuted'>      _finalAmt -= _adminAmt;</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='unexecuted'>    _depositRewards(_token, _finalAmt);</span>
 203 |     | <span class='neutral'>  }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>  function _depositRewards(address _token, uint256 _amountTotal) internal {</span>
 206 |     | <span class='unexecuted'>    if (!_depositedRewardsToken[_token]) {</span>
 207 |     | <span class='unexecuted'>      _depositedRewardsToken[_token] = true;</span>
 208 |     | <span class='unexecuted'>      _allRewardsTokens.push(_token);</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='unexecuted'>    if (_amountTotal == 0) {</span>
 211 |     | <span class='neutral'>      return;</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='unexecuted'>    if (totalShares == 0) {</span>
 214 |     | <span class='unexecuted'>      require(_token == rewardsToken, &#39;R&#39;);</span>
 215 |     | <span class='unexecuted'>      _burnRewards(_amountTotal);</span>
 216 |     | <span class='neutral'>      return;</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>    uint256 _depositAmount = _amountTotal;</span>
 220 |     | <span class='unexecuted'>    if (_token == rewardsToken) {</span>
 221 |     | <span class='unexecuted'>      (, uint256 _yieldBurnFee) = _getYieldFees();</span>
 222 |     | <span class='unexecuted'>      if (_yieldBurnFee &gt; 0) {</span>
 223 |     | <span class='unexecuted'>        uint256 _burnAmount = (_amountTotal * _yieldBurnFee) /</span>
 224 |     | <span class='unexecuted'>          PROTOCOL_FEE_ROUTER.protocolFees().DEN();</span>
 225 |     | <span class='unexecuted'>        if (_burnAmount &gt; 0) {</span>
 226 |     | <span class='unexecuted'>          _burnRewards(_burnAmount);</span>
 227 |     | <span class='unexecuted'>          _depositAmount -= _burnAmount;</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>      }</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='unexecuted'>    rewardsDeposited[_token] += _depositAmount;</span>
 232 |     | <span class='unexecuted'>    _rewardsPerShare[_token] += (PRECISION * _depositAmount) / totalShares;</span>
 233 |     | <span class='unexecuted'>    emit DepositRewards(_msgSender(), _token, _depositAmount);</span>
 234 |     | <span class='neutral'>  }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='unexecuted'>  function _distributeReward(address _wallet) internal {</span>
 237 |     | <span class='unexecuted'>    if (shares[_wallet] == 0) {</span>
 238 |     | <span class='neutral'>      return;</span>
 239 |     | <span class='neutral'>    }</span>
 240 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _allRewardsTokens.length; _i++) {</span>
 241 |     | <span class='unexecuted'>      address _token = _allRewardsTokens[_i];</span>
 242 |     | <span class='unexecuted'>      uint256 _amount = getUnpaid(_token, _wallet);</span>
 243 |     | <span class='unexecuted'>      rewards[_token][_wallet].realized += _amount;</span>
 244 |     | <span class='unexecuted'>      rewards[_token][_wallet].excluded = _cumulativeRewards(</span>
 245 |     | <span class='unexecuted'>        _token,</span>
 246 |     | <span class='unexecuted'>        shares[_wallet]</span>
 247 |     | <span class='neutral'>      );</span>
 248 |     | <span class='unexecuted'>      if (_amount &gt; 0) {</span>
 249 |     | <span class='unexecuted'>        rewardsDistributed[_token] += _amount;</span>
 250 |     | <span class='unexecuted'>        IERC20(_token).safeTransfer(_wallet, _amount);</span>
 251 |     | <span class='unexecuted'>        emit DistributeReward(_wallet, _token, _amount);</span>
 252 |     | <span class='neutral'>      }</span>
 253 |     | <span class='neutral'>    }</span>
 254 |     | <span class='neutral'>  }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>  function _resetExcluded(address _wallet) internal {</span>
 257 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _allRewardsTokens.length; _i++) {</span>
 258 |     | <span class='unexecuted'>      address _token = _allRewardsTokens[_i];</span>
 259 |     | <span class='unexecuted'>      rewards[_token][_wallet].excluded = _cumulativeRewards(</span>
 260 |     | <span class='neutral'>        _token,</span>
 261 |     | <span class='unexecuted'>        shares[_wallet]</span>
 262 |     | <span class='neutral'>      );</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'>  }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>  function _burnRewards(uint256 _burnAmount) internal {</span>
 267 |     | <span class='unexecuted'>    try IPEAS(rewardsToken).burn(_burnAmount) {} catch {</span>
 268 |     | <span class='unexecuted'>      IERC20(rewardsToken).safeTransfer(address(0xdead), _burnAmount);</span>
 269 |     | <span class='neutral'>    }</span>
 270 |     | <span class='neutral'>  }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>  function _isValidRewardsToken(address _token) internal view returns (bool) {</span>
 273 |     | <span class='unexecuted'>    return _token == rewardsToken || REWARDS_WHITELISTER.whitelist(_token);</span>
 274 |     | <span class='neutral'>  }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>  function _getAdminFeeFromAmount(</span>
 277 |     | <span class='neutral'>    uint256 _amount</span>
 278 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 279 |     | <span class='unexecuted'>    (uint256 _yieldAdminFee, ) = _getYieldFees();</span>
 280 |     | <span class='unexecuted'>    if (_yieldAdminFee == 0) {</span>
 281 |     | <span class='unexecuted'>      return 0;</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='unexecuted'>    return</span>
 284 |     | <span class='unexecuted'>      (_amount * _yieldAdminFee) / PROTOCOL_FEE_ROUTER.protocolFees().DEN();</span>
 285 |     | <span class='neutral'>  }</span>
 286 |     | <span class='neutral'></span>
 287 |     | <span class='unexecuted'>  function _getYieldFees()</span>
 288 |     | <span class='neutral'>    internal</span>
 289 |     | <span class='neutral'>    view</span>
 290 |     | <span class='unexecuted'>    returns (uint256 _admin, uint256 _burn)</span>
 291 |     | <span class='unexecuted'>  {</span>
 292 |     | <span class='unexecuted'>    IProtocolFees _fees = PROTOCOL_FEE_ROUTER.protocolFees();</span>
 293 |     | <span class='unexecuted'>    if (address(_fees) != address(0)) {</span>
 294 |     | <span class='unexecuted'>      _admin = _fees.yieldAdmin();</span>
 295 |     | <span class='unexecuted'>      _burn = _fees.yieldBurn();</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'>  }</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>  function _swapForRewards(</span>
 300 |     | <span class='neutral'>    uint256 _amountIn,</span>
 301 |     | <span class='neutral'>    uint256 _amountOut,</span>
 302 |     | <span class='neutral'>    uint256 _adminAmt</span>
 303 |     | <span class='neutral'>  ) internal {</span>
 304 |     | <span class='unexecuted'>    _amountIn = _rewardsSwapAmountInOverride &gt; 0</span>
 305 |     | <span class='unexecuted'>      ? _rewardsSwapAmountInOverride</span>
 306 |     | <span class='unexecuted'>      : _amountIn;</span>
 307 |     | <span class='unexecuted'>    uint256 _balBefore = IERC20(rewardsToken).balanceOf(address(this));</span>
 308 |     | <span class='unexecuted'>    IERC20(PAIRED_LP_TOKEN).safeIncreaseAllowance(</span>
 309 |     | <span class='unexecuted'>      address(DEX_ADAPTER),</span>
 310 |     | <span class='unexecuted'>      _amountIn</span>
 311 |     | <span class='neutral'>    );</span>
 312 |     | <span class='unexecuted'>    try</span>
 313 |     | <span class='unexecuted'>      DEX_ADAPTER.swapV3Single(</span>
 314 |     | <span class='unexecuted'>        PAIRED_LP_TOKEN,</span>
 315 |     | <span class='unexecuted'>        rewardsToken,</span>
 316 |     | <span class='neutral'>        REWARDS_POOL_FEE,</span>
 317 |     | <span class='unexecuted'>        _amountIn,</span>
 318 |     | <span class='unexecuted'>        (_amountOut * (1000 - REWARDS_SWAP_SLIPPAGE)) / 1000,</span>
 319 |     | <span class='unexecuted'>        address(this)</span>
 320 |     | <span class='neutral'>      )</span>
 321 |     | <span class='neutral'>    {</span>
 322 |     | <span class='unexecuted'>      _rewardsSwapAmountInOverride = 0;</span>
 323 |     | <span class='unexecuted'>      if (_adminAmt &gt; 0) {</span>
 324 |     | <span class='unexecuted'>        IERC20(PAIRED_LP_TOKEN).safeTransfer(</span>
 325 |     | <span class='unexecuted'>          Ownable(address(V3_TWAP_UTILS)).owner(),</span>
 326 |     | <span class='unexecuted'>          _adminAmt</span>
 327 |     | <span class='neutral'>        );</span>
 328 |     | <span class='neutral'>      }</span>
 329 |     | <span class='unexecuted'>      _depositRewards(</span>
 330 |     | <span class='unexecuted'>        rewardsToken,</span>
 331 |     | <span class='unexecuted'>        IERC20(rewardsToken).balanceOf(address(this)) - _balBefore</span>
 332 |     | <span class='neutral'>      );</span>
 333 |     | <span class='neutral'>    } catch {</span>
 334 |     | <span class='unexecuted'>      _rewardsSwapAmountInOverride = _amountIn / 2;</span>
 335 |     | <span class='unexecuted'>      IERC20(PAIRED_LP_TOKEN).safeDecreaseAllowance(</span>
 336 |     | <span class='unexecuted'>        address(DEX_ADAPTER),</span>
 337 |     | <span class='unexecuted'>        _amountIn</span>
 338 |     | <span class='neutral'>      );</span>
 339 |     | <span class='unexecuted'>      emit RewardSwapError(_amountIn);</span>
 340 |     | <span class='neutral'>    }</span>
 341 |     | <span class='neutral'>  }</span>
 342 |     | <span class='neutral'></span>
 343 |     | <span class='unexecuted'>  function claimReward(address _wallet) external override {</span>
 344 |     | <span class='unexecuted'>    _distributeReward(_wallet);</span>
 345 |     | <span class='unexecuted'>    emit ClaimReward(_wallet);</span>
 346 |     | <span class='neutral'>  }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='unexecuted'>  function getUnpaid(</span>
 349 |     | <span class='neutral'>    address _token,</span>
 350 |     | <span class='neutral'>    address _wallet</span>
 351 |     | <span class='unexecuted'>  ) public view returns (uint256) {</span>
 352 |     | <span class='unexecuted'>    if (shares[_wallet] == 0) {</span>
 353 |     | <span class='unexecuted'>      return 0;</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='unexecuted'>    uint256 earnedRewards = _cumulativeRewards(_token, shares[_wallet]);</span>
 356 |     | <span class='unexecuted'>    uint256 rewardsExcluded = rewards[_token][_wallet].excluded;</span>
 357 |     | <span class='unexecuted'>    if (earnedRewards &lt;= rewardsExcluded) {</span>
 358 |     | <span class='unexecuted'>      return 0;</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='unexecuted'>    return earnedRewards - rewardsExcluded;</span>
 361 |     | <span class='neutral'>  }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='unexecuted'>  function _cumulativeRewards(</span>
 364 |     | <span class='neutral'>    address _token,</span>
 365 |     | <span class='neutral'>    uint256 _share</span>
 366 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 367 |     | <span class='unexecuted'>    return (_share * _rewardsPerShare[_token]) / PRECISION;</span>
 368 |     | <span class='neutral'>  }</span>
 369 |     | <span class='neutral'>}</span>
 370 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/WeightedIndex.sol</b>
<code>
   1 |     | <span class='neutral'>// https://peapods.finance</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV2Pair.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./interfaces/IV3TwapUtilities.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./DecentralizedIndex.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 | *   | <span class='executed'>contract WeightedIndex is DecentralizedIndex {</span>
  12 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>  uint256 _totalWeights;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>  constructor(</span>
  17 |     | <span class='neutral'>    string memory _name,</span>
  18 |     | <span class='neutral'>    string memory _symbol,</span>
  19 |     | <span class='neutral'>    Config memory _config,</span>
  20 |     | <span class='neutral'>    Fees memory _fees,</span>
  21 |     | <span class='neutral'>    address[] memory _tokens,</span>
  22 |     | <span class='neutral'>    uint256[] memory _weights,</span>
  23 |     | <span class='neutral'>    address _pairedLpToken,</span>
  24 |     | <span class='neutral'>    address _lpRewardsToken,</span>
  25 |     | <span class='neutral'>    address _dexHandler,</span>
  26 |     | <span class='neutral'>    bool _stakeRestriction</span>
  27 |     | <span class='neutral'>  )</span>
  28 |     | <span class='neutral'>    DecentralizedIndex(</span>
  29 |     | <span class='unexecuted'>      _name,</span>
  30 |     | <span class='unexecuted'>      _symbol,</span>
  31 |     | <span class='unexecuted'>      IndexType.WEIGHTED,</span>
  32 |     | <span class='unexecuted'>      _config,</span>
  33 |     | <span class='unexecuted'>      _fees,</span>
  34 |     | <span class='unexecuted'>      _pairedLpToken,</span>
  35 |     | <span class='unexecuted'>      _lpRewardsToken,</span>
  36 |     | <span class='unexecuted'>      _dexHandler,</span>
  37 |     | <span class='unexecuted'>      _stakeRestriction</span>
  38 |     | <span class='neutral'>    )</span>
  39 |     | <span class='unexecuted'>  {</span>
  40 |     | <span class='unexecuted'>    require(_tokens.length == _weights.length, &#39;V&#39;);</span>
  41 |     | <span class='unexecuted'>    uint256 _tl = _tokens.length;</span>
  42 |     | <span class='unexecuted'>    for (uint8 _i; _i &lt; _tl; _i++) {</span>
  43 |     | <span class='unexecuted'>      require(!_isTokenInIndex[_tokens[_i]], &#39;D&#39;);</span>
  44 |     | <span class='unexecuted'>      require(_weights[_i] &gt; 0, &#39;W&#39;);</span>
  45 |     | <span class='unexecuted'>      indexTokens.push(</span>
  46 |     | <span class='unexecuted'>        IndexAssetInfo({</span>
  47 |     | <span class='unexecuted'>          token: _tokens[_i],</span>
  48 |     | <span class='unexecuted'>          basePriceUSDX96: 0,</span>
  49 |     | <span class='unexecuted'>          weighting: _weights[_i],</span>
  50 |     | <span class='neutral'>          c1: address(0),</span>
  51 |     | <span class='neutral'>          q1: 0 // amountsPerIdxTokenX96</span>
  52 |     | <span class='neutral'>        })</span>
  53 |     | <span class='neutral'>      );</span>
  54 |     | <span class='unexecuted'>      _totalWeights += _weights[_i];</span>
  55 |     | <span class='unexecuted'>      _fundTokenIdx[_tokens[_i]] = _i;</span>
  56 |     | <span class='unexecuted'>      _isTokenInIndex[_tokens[_i]] = true;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>      if (_config.blacklistTKNpTKNPoolV2 &amp;&amp; _tokens[_i] != _pairedLpToken) {</span>
  59 |     | <span class='unexecuted'>        address _blkPool = IDexAdapter(_dexHandler).createV2Pool(</span>
  60 |     | <span class='unexecuted'>          address(this),</span>
  61 |     | <span class='unexecuted'>          _tokens[_i]</span>
  62 |     | <span class='neutral'>        );</span>
  63 |     | <span class='unexecuted'>        _blacklist[_blkPool] = true;</span>
  64 |     | <span class='neutral'>      }</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'>    // at idx == 0, need to find X in [1/X = tokenWeightAtIdx/totalWeights]</span>
  67 |     | <span class='neutral'>    // at idx &gt; 0, need to find Y in (Y/X = tokenWeightAtIdx/totalWeights)</span>
  68 |     | <span class='unexecuted'>    uint256 _xX96 = (FixedPoint96.Q96 * _totalWeights) / _weights[0];</span>
  69 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _tl; _i++) {</span>
  70 |     | <span class='unexecuted'>      indexTokens[_i].q1 =</span>
  71 |     | <span class='unexecuted'>        (_weights[_i] * _xX96 * 10 ** IERC20Metadata(_tokens[_i]).decimals()) /</span>
  72 |     | <span class='unexecuted'>        _totalWeights;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'>  }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>  /// @notice The ```_getNativePriceUSDX96``` function gets an *unsafe* native tkn (ETH) price from a UniswapV2 pool</span>
  77 |     | <span class='neutral'>  /// @return _priceX96 USD/native price scaled by Q96</span>
  78 |     | <span class='unexecuted'>  function _getNativePriceUSDX96() internal view returns (uint256) {</span>
  79 |     | <span class='unexecuted'>    IUniswapV2Pair _nativeStablePool = IUniswapV2Pair(</span>
  80 |     | <span class='unexecuted'>      DEX_HANDLER.getV2Pool(DAI, WETH)</span>
  81 |     | <span class='neutral'>    );</span>
  82 |     | <span class='unexecuted'>    address _token0 = _nativeStablePool.token0();</span>
  83 |     | <span class='unexecuted'>    (uint8 _decimals0, uint8 _decimals1) = (</span>
  84 |     | <span class='unexecuted'>      IERC20Metadata(_token0).decimals(),</span>
  85 |     | <span class='unexecuted'>      IERC20Metadata(_nativeStablePool.token1()).decimals()</span>
  86 |     | <span class='neutral'>    );</span>
  87 |     | <span class='unexecuted'>    (uint112 _res0, uint112 _res1, ) = _nativeStablePool.getReserves();</span>
  88 |     | <span class='unexecuted'>    return</span>
  89 |     | <span class='unexecuted'>      _token0 == DAI</span>
  90 |     | <span class='unexecuted'>        ? (FixedPoint96.Q96 * _res0 * 10 ** _decimals1) /</span>
  91 |     | <span class='neutral'>          _res1 /</span>
  92 |     | <span class='unexecuted'>          10 ** _decimals0</span>
  93 |     | <span class='unexecuted'>        : (FixedPoint96.Q96 * _res1 * 10 ** _decimals0) /</span>
  94 |     | <span class='neutral'>          _res0 /</span>
  95 |     | <span class='unexecuted'>          10 ** _decimals1;</span>
  96 |     | <span class='neutral'>  }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>  /// @notice The ```_getTokenPriceUSDX96``` function gets an *unsafe* tkn price from a UniswapV2 pool</span>
  99 |     | <span class='neutral'>  /// @param _token token we&#39;re getting the price for</span>
 100 |     | <span class='neutral'>  /// @return _priceX96 USD/TKN price scaled by Q96</span>
 101 |     | <span class='unexecuted'>  function _getTokenPriceUSDX96(</span>
 102 |     | <span class='neutral'>    address _token</span>
 103 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 104 |     | <span class='unexecuted'>    if (_token == WETH) {</span>
 105 |     | <span class='unexecuted'>      return _getNativePriceUSDX96();</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='unexecuted'>    IUniswapV2Pair _pool = IUniswapV2Pair(DEX_HANDLER.getV2Pool(_token, WETH));</span>
 108 |     | <span class='unexecuted'>    address _token0 = _pool.token0();</span>
 109 |     | <span class='unexecuted'>    uint8 _decimals0 = IERC20Metadata(_token0).decimals();</span>
 110 |     | <span class='unexecuted'>    uint8 _decimals1 = IERC20Metadata(_pool.token1()).decimals();</span>
 111 |     | <span class='unexecuted'>    (uint112 _res0, uint112 _res1, ) = _pool.getReserves();</span>
 112 |     | <span class='unexecuted'>    uint256 _nativePriceUSDX96 = _getNativePriceUSDX96();</span>
 113 |     | <span class='unexecuted'>    return</span>
 114 |     | <span class='unexecuted'>      _token0 == WETH</span>
 115 |     | <span class='unexecuted'>        ? (_nativePriceUSDX96 * _res0 * 10 ** _decimals1) /</span>
 116 |     | <span class='neutral'>          _res1 /</span>
 117 |     | <span class='unexecuted'>          10 ** _decimals0</span>
 118 |     | <span class='unexecuted'>        : (_nativePriceUSDX96 * _res1 * 10 ** _decimals0) /</span>
 119 |     | <span class='neutral'>          _res0 /</span>
 120 |     | <span class='unexecuted'>          10 ** _decimals1;</span>
 121 |     | <span class='neutral'>  }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>  /// @notice The ```bond``` function wraps a user into a pod and mints new pTKN</span>
 124 |     | <span class='neutral'>  /// @param _token The token used to calculate the amount of pTKN minted</span>
 125 |     | <span class='neutral'>  /// @param _amount Number of _tokens used to wrap into the pod</span>
 126 |     | <span class='neutral'>  /// @param _amountMintMin Number of pTKN minimum that should be minted (slippage)</span>
 127 | *   | <span class='executed'>  function bond(</span>
 128 |     | <span class='neutral'>    address _token,</span>
 129 |     | <span class='neutral'>    uint256 _amount,</span>
 130 |     | <span class='neutral'>    uint256 _amountMintMin</span>
 131 |     | <span class='neutral'>  ) external override lock noSwapOrFee {</span>
 132 | *   | <span class='executed'>    require(_isTokenInIndex[_token], &#39;IT&#39;);</span>
 133 | *   | <span class='executed'>    uint256 _tokenIdx = _fundTokenIdx[_token];</span>
 134 | *   | <span class='executed'>    uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(this));</span>
 135 | *   | <span class='executed'>    bool _firstIn = _isFirstIn();</span>
 136 | *   | <span class='executed'>    uint256 _tokenAmtSupplyRatioX96 = _firstIn</span>
 137 |     | <span class='neutral'>      ? FixedPoint96.Q96</span>
 138 | *   | <span class='executed'>      : (_amount * FixedPoint96.Q96) / _tokenCurSupply;</span>
 139 | *   | <span class='executed'>    uint256 _tokensMinted;</span>
 140 | *   | <span class='executed'>    if (_firstIn) {</span>
 141 |     | <span class='unexecuted'>      _tokensMinted =</span>
 142 |     | <span class='unexecuted'>        (_amount * FixedPoint96.Q96 * 10 ** decimals()) /</span>
 143 |     | <span class='unexecuted'>        indexTokens[_tokenIdx].q1;</span>
 144 |     | <span class='neutral'>    } else {</span>
 145 | *   | <span class='executed'>      _tokensMinted =</span>
 146 | *   | <span class='executed'>        (totalSupply() * _tokenAmtSupplyRatioX96) /</span>
 147 |     | <span class='neutral'>        FixedPoint96.Q96;</span>
 148 |     | <span class='neutral'>    }</span>
 149 | *   | <span class='executed'>    uint256 _feeTokens = _canWrapFeeFree(_msgSender())</span>
 150 |     | <span class='unexecuted'>      ? 0</span>
 151 | *   | <span class='executed'>      : (_tokensMinted * fees.bond) / DEN;</span>
 152 | *   | <span class='executed'>    require(_tokensMinted - _feeTokens &gt;= _amountMintMin, &#39;M&#39;);</span>
 153 | *   | <span class='executed'>    _mint(_msgSender(), _tokensMinted - _feeTokens);</span>
 154 | *   | <span class='executed'>    if (_feeTokens &gt; 0) {</span>
 155 | *   | <span class='executed'>      _mint(address(this), _feeTokens);</span>
 156 | *   | <span class='executed'>      _processBurnFee(_feeTokens);</span>
 157 |     | <span class='neutral'>    }</span>
 158 | *   | <span class='executed'>    uint256 _il = indexTokens.length;</span>
 159 | *   | <span class='executed'>    for (uint256 _i; _i &lt; _il; _i++) {</span>
 160 | *   | <span class='executed'>      uint256 _transferAmt = _firstIn</span>
 161 | *   | <span class='executed'>        ? getInitialAmount(_token, _amount, indexTokens[_i].token)</span>
 162 | *   | <span class='executed'>        : (IERC20(indexTokens[_i].token).balanceOf(address(this)) *</span>
 163 | *   | <span class='executed'>          _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;</span>
 164 | *   | <span class='executed'>      _transferFromAndValidate(</span>
 165 | *   | <span class='executed'>        IERC20(indexTokens[_i].token),</span>
 166 |     | <span class='neutral'>        _msgSender(),</span>
 167 | *   | <span class='executed'>        _transferAmt</span>
 168 |     | <span class='neutral'>      );</span>
 169 |     | <span class='neutral'>    }</span>
 170 | *   | <span class='executed'>    _bond();</span>
 171 | *   | <span class='executed'>    emit Bond(_msgSender(), _token, _amount, _tokensMinted);</span>
 172 |     | <span class='neutral'>  }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>  /// @notice The ```debond``` function unwraps a user out of a pod and burns pTKN</span>
 175 |     | <span class='neutral'>  /// @param _amount Number of pTKN to burn</span>
 176 |     | <span class='unexecuted'>  function debond(</span>
 177 |     | <span class='neutral'>    uint256 _amount,</span>
 178 |     | <span class='neutral'>    address[] memory,</span>
 179 |     | <span class='neutral'>    uint8[] memory</span>
 180 |     | <span class='neutral'>  ) external override lock noSwapOrFee {</span>
 181 |     | <span class='unexecuted'>    uint256 _amountAfterFee = _isLastOut(_amount)</span>
 182 |     | <span class='unexecuted'>      ? _amount</span>
 183 |     | <span class='unexecuted'>      : (_amount * (DEN - fees.debond)) / DEN;</span>
 184 |     | <span class='unexecuted'>    uint256 _percAfterFeeX96 = (_amountAfterFee * FixedPoint96.Q96) /</span>
 185 |     | <span class='unexecuted'>      totalSupply();</span>
 186 |     | <span class='unexecuted'>    super._transfer(_msgSender(), address(this), _amount);</span>
 187 |     | <span class='unexecuted'>    _burn(address(this), _amountAfterFee);</span>
 188 |     | <span class='unexecuted'>    _processBurnFee(_amount - _amountAfterFee);</span>
 189 |     | <span class='unexecuted'>    uint256 _il = indexTokens.length;</span>
 190 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _il; _i++) {</span>
 191 |     | <span class='unexecuted'>      uint256 _tokenSupply = IERC20(indexTokens[_i].token).balanceOf(</span>
 192 |     | <span class='unexecuted'>        address(this)</span>
 193 |     | <span class='neutral'>      );</span>
 194 |     | <span class='unexecuted'>      uint256 _debondAmount = (_tokenSupply * _percAfterFeeX96) /</span>
 195 |     | <span class='neutral'>        FixedPoint96.Q96;</span>
 196 |     | <span class='unexecuted'>      if (_debondAmount &gt; 0) {</span>
 197 |     | <span class='unexecuted'>        IERC20(indexTokens[_i].token).safeTransfer(_msgSender(), _debondAmount);</span>
 198 |     | <span class='neutral'>      }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'>    // an arbitrage path of buy pTKN &gt; debond &gt; sell TKN does not trigger rewards</span>
 201 |     | <span class='neutral'>    // so let&#39;s trigger processing here at debond to keep things moving along</span>
 202 |     | <span class='unexecuted'>    _processPreSwapFeesAndSwap();</span>
 203 |     | <span class='unexecuted'>    emit Debond(_msgSender(), _amount);</span>
 204 |     | <span class='neutral'>  }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>  /// @notice The ```getInitialAmount``` function determines the initial amount of TKN2 needed</span>
 207 |     | <span class='neutral'>  /// @notice based on an amount of TKN1 to wrap with. After an initial bond, vault share takes over</span>
 208 |     | <span class='neutral'>  /// @param _sourceToken TKN we&#39;re referencing</span>
 209 |     | <span class='neutral'>  /// @param _sourceAmount Amount of TKN we&#39;re referencing</span>
 210 |     | <span class='neutral'>  /// @param _targetToken Target TKN we will return the amount that is needed</span>
 211 |     | <span class='neutral'>  /// @return _amtTargetTkn Amount of _targetToken needed to wrap with</span>
 212 | *   | <span class='executed'>  function getInitialAmount(</span>
 213 |     | <span class='neutral'>    address _sourceToken,</span>
 214 |     | <span class='neutral'>    uint256 _sourceAmount,</span>
 215 |     | <span class='neutral'>    address _targetToken</span>
 216 | *   | <span class='executed'>  ) public view override returns (uint256) {</span>
 217 | *   | <span class='executed'>    uint256 _sourceTokenIdx = _fundTokenIdx[_sourceToken];</span>
 218 | *   | <span class='executed'>    uint256 _targetTokenIdx = _fundTokenIdx[_targetToken];</span>
 219 | *   | <span class='executed'>    return</span>
 220 | *   | <span class='executed'>      (_sourceAmount *</span>
 221 | *   | <span class='executed'>        indexTokens[_targetTokenIdx].weighting *</span>
 222 | *   | <span class='executed'>        10 ** IERC20Metadata(_targetToken).decimals()) /</span>
 223 | *   | <span class='executed'>      indexTokens[_sourceTokenIdx].weighting /</span>
 224 | *   | <span class='executed'>      10 ** IERC20Metadata(_sourceToken).decimals();</span>
 225 |     | <span class='neutral'>  }</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>  /// @notice The ```getTokenPriceUSDX96``` function is an external version of _getTokenPriceUSDX96, which gets an *unsafe* tkn price from a UniswapV2 pool</span>
 228 |     | <span class='neutral'>  /// @notice This is used as a frontend helper but is NOT safe to be used as an oracle.</span>
 229 |     | <span class='neutral'>  /// @param _token token we&#39;re getting the price for</span>
 230 |     | <span class='neutral'>  /// @return _priceX96 USD/TKN price scaled by Q96</span>
 231 |     | <span class='unexecuted'>  function getTokenPriceUSDX96(</span>
 232 |     | <span class='neutral'>    address _token</span>
 233 |     | <span class='unexecuted'>  ) external view override returns (uint256) {</span>
 234 |     | <span class='unexecuted'>    return _getTokenPriceUSDX96(_token);</span>
 235 |     | <span class='neutral'>  }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>  /// @notice The ```getIdxPriceUSDX96``` function gets an *unsafe* pTKN price from all TKNs using UniswapV2 pools</span>
 238 |     | <span class='neutral'>  /// @notice This is used as a frontend helper but is NOT safe to be used as an oracle.</span>
 239 |     | <span class='neutral'>  /// @return _priceX96 USD/TKN price scaled by Q96</span>
 240 |     | <span class='unexecuted'>  function getIdxPriceUSDX96()</span>
 241 |     | <span class='neutral'>    external</span>
 242 |     | <span class='neutral'>    view</span>
 243 |     | <span class='neutral'>    override</span>
 244 |     | <span class='unexecuted'>    returns (uint256, uint256)</span>
 245 |     | <span class='neutral'>  {</span>
 246 |     | <span class='neutral'>    uint256 _priceX96;</span>
 247 |     | <span class='unexecuted'>    uint256 _X96_2 = 2 ** (96 / 2);</span>
 248 |     | <span class='unexecuted'>    uint256 _il = indexTokens.length;</span>
 249 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _il; _i++) {</span>
 250 |     | <span class='unexecuted'>      uint256 _tokenPriceUSDX96_2 = _getTokenPriceUSDX96(</span>
 251 |     | <span class='unexecuted'>        indexTokens[_i].token</span>
 252 |     | <span class='unexecuted'>      ) / _X96_2;</span>
 253 |     | <span class='unexecuted'>      _priceX96 +=</span>
 254 |     | <span class='unexecuted'>        (_tokenPriceUSDX96_2 * indexTokens[_i].q1) /</span>
 255 |     | <span class='unexecuted'>        10 ** IERC20Metadata(indexTokens[_i].token).decimals() /</span>
 256 |     | <span class='unexecuted'>        _X96_2;</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='unexecuted'>    return (0, _priceX96);</span>
 259 |     | <span class='neutral'>  }</span>
 260 |     | <span class='neutral'>}</span>
 261 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/Zapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./interfaces/ICurvePool.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./interfaces/IDecentralizedIndex.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./interfaces/IDexAdapter.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV2Pair.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Pool.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./interfaces/IV3TwapUtilities.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./interfaces/IWETH.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./interfaces/IZapper.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract Zapper is IZapper, Context, Ownable {</span>
  21 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>  address constant STYETH = 0x583019fF0f430721aDa9cfb4fac8F06cA104d0B4;</span>
  24 |     | <span class='unexecuted'>  address constant YETH = 0x1BED97CBC3c24A4fb5C069C6E311a967386131f7;</span>
  25 |     | <span class='unexecuted'>  address constant WETH_YETH_POOL = 0x69ACcb968B19a53790f43e57558F5E443A91aF22;</span>
  26 |     | <span class='unexecuted'>  address constant V3_ROUTER = 0xE592427A0AEce92De3Edee1F18E0157C05861564;</span>
  27 |     | <span class='neutral'>  address immutable V2_ROUTER;</span>
  28 |     | <span class='neutral'>  address immutable WETH;</span>
  29 |     | <span class='neutral'>  IV3TwapUtilities immutable V3_TWAP_UTILS;</span>
  30 |     | <span class='neutral'>  IDexAdapter immutable DEX_ADAPTER;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>  uint256 _slippage = 30; // 3%</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>  address public OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;</span>
  35 |     | <span class='unexecuted'>  address public pOHM;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>  // token in =&gt; token out =&gt; swap pool(s)</span>
  38 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; Pools)) public zapMap;</span>
  39 |     | <span class='neutral'>  // curve pool =&gt; token =&gt; idx</span>
  40 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; int128)) public curveTokenIdx;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>  event Message(string a);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>  constructor(IV3TwapUtilities _v3TwapUtilities, IDexAdapter _dexAdapter) {</span>
  45 |     | <span class='unexecuted'>    V2_ROUTER = _dexAdapter.V2_ROUTER();</span>
  46 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  47 |     | <span class='unexecuted'>    DEX_ADAPTER = _dexAdapter;</span>
  48 |     | <span class='unexecuted'>    WETH = _dexAdapter.WETH();</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    emit Message(&quot;Here&quot;);</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    if (block.chainid == 1) {</span>
  53 |     | <span class='neutral'>      // WETH/YETH</span>
  54 |     | <span class='unexecuted'>      _setZapMapFromPoolSingle(</span>
  55 |     | <span class='unexecuted'>        PoolType.CURVE,</span>
  56 |     | <span class='unexecuted'>        0x69ACcb968B19a53790f43e57558F5E443A91aF22</span>
  57 |     | <span class='neutral'>      );</span>
  58 |     | <span class='neutral'>      // WETH/DAI</span>
  59 |     | <span class='unexecuted'>      _setZapMapFromPoolSingle(</span>
  60 |     | <span class='unexecuted'>        PoolType.V3,</span>
  61 |     | <span class='unexecuted'>        0x60594a405d53811d3BC4766596EFD80fd545A270</span>
  62 |     | <span class='neutral'>      );</span>
  63 |     | <span class='neutral'>      // WETH/USDC</span>
  64 |     | <span class='unexecuted'>      _setZapMapFromPoolSingle(</span>
  65 |     | <span class='unexecuted'>        PoolType.V3,</span>
  66 |     | <span class='unexecuted'>        0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640</span>
  67 |     | <span class='neutral'>      );</span>
  68 |     | <span class='neutral'>      // WETH/OHM</span>
  69 |     | <span class='unexecuted'>      _setZapMapFromPoolSingle(</span>
  70 |     | <span class='unexecuted'>        PoolType.V3,</span>
  71 |     | <span class='unexecuted'>        0x88051B0eea095007D3bEf21aB287Be961f3d8598</span>
  72 |     | <span class='neutral'>      );</span>
  73 |     | <span class='neutral'>      // USDC/OHM</span>
  74 |     | <span class='unexecuted'>      _setZapMapFromPoolSingle(</span>
  75 |     | <span class='unexecuted'>        PoolType.V3,</span>
  76 |     | <span class='unexecuted'>        0x893f503FaC2Ee1e5B78665db23F9c94017Aae97D</span>
  77 |     | <span class='neutral'>      );</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'>  }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>  function _zap(</span>
  82 |     | <span class='neutral'>    address _in,</span>
  83 |     | <span class='neutral'>    address _out,</span>
  84 |     | <span class='neutral'>    uint256 _amountIn,</span>
  85 |     | <span class='neutral'>    uint256 _amountOutMin</span>
  86 |     | <span class='unexecuted'>  ) internal returns (uint256 _amountOut) {</span>
  87 |     | <span class='unexecuted'>    if (_in == address(0)) {</span>
  88 |     | <span class='unexecuted'>      _amountIn = _ethToWETH(_amountIn);</span>
  89 |     | <span class='unexecuted'>      _in = WETH;</span>
  90 |     | <span class='unexecuted'>      if (_out == WETH) {</span>
  91 |     | <span class='unexecuted'>        return _amountIn;</span>
  92 |     | <span class='neutral'>      }</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'>    // handle pOHM separately through pod, modularize later</span>
  95 |     | <span class='unexecuted'>    bool _isOutPOHM;</span>
  96 |     | <span class='unexecuted'>    if (pOHM == _out) {</span>
  97 |     | <span class='unexecuted'>      _isOutPOHM = true;</span>
  98 |     | <span class='unexecuted'>      _out = OHM;</span>
  99 |     | <span class='neutral'>    }</span>
 100 |     | <span class='neutral'>    // handle yETH and st-yETH special through curve pool, modularize later</span>
 101 |     | <span class='unexecuted'>    if (_out == YETH || _out == STYETH) {</span>
 102 |     | <span class='unexecuted'>      require(_in == WETH, &#39;YETHIN&#39;);</span>
 103 |     | <span class='unexecuted'>      return _wethToYeth(_amountIn, _amountOutMin, _out == STYETH);</span>
 104 |     | <span class='unexecuted'>    } else if (_in == YETH || _in == STYETH) {</span>
 105 |     | <span class='unexecuted'>      require(_out == WETH, &#39;YETHOUT&#39;);</span>
 106 |     | <span class='unexecuted'>      return _styethToWeth(_amountIn, _amountOutMin, _in == YETH);</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='unexecuted'>    Pools memory _poolInfo = zapMap[_in][_out];</span>
 109 |     | <span class='neutral'>    // no pool so just try to swap over one path univ2</span>
 110 |     | <span class='unexecuted'>    if (_poolInfo.pool1 == address(0)) {</span>
 111 |     | <span class='unexecuted'>      address[] memory _path = new address[](2);</span>
 112 |     | <span class='unexecuted'>      _path[0] = _in;</span>
 113 |     | <span class='unexecuted'>      _path[1] = _out;</span>
 114 |     | <span class='unexecuted'>      _amountOut = _swapV2(_path, _amountIn, _amountOutMin);</span>
 115 |     | <span class='unexecuted'>    } else {</span>
 116 |     | <span class='unexecuted'>      bool _twoHops = _poolInfo.pool2 != address(0);</span>
 117 |     | <span class='unexecuted'>      if (_poolInfo.poolType == PoolType.CURVE) {</span>
 118 |     | <span class='neutral'>        // curve</span>
 119 |     | <span class='unexecuted'>        _amountOut = _swapCurve(</span>
 120 |     | <span class='unexecuted'>          _poolInfo.pool1,</span>
 121 |     | <span class='unexecuted'>          curveTokenIdx[_poolInfo.pool1][_in],</span>
 122 |     | <span class='unexecuted'>          curveTokenIdx[_poolInfo.pool1][_out],</span>
 123 |     | <span class='unexecuted'>          _amountIn,</span>
 124 |     | <span class='unexecuted'>          _amountOutMin</span>
 125 |     | <span class='neutral'>        );</span>
 126 |     | <span class='unexecuted'>      } else if (_poolInfo.poolType == PoolType.V2) {</span>
 127 |     | <span class='neutral'>        // univ2</span>
 128 |     | <span class='unexecuted'>        address _token0 = IUniswapV2Pair(_poolInfo.pool1).token0();</span>
 129 |     | <span class='unexecuted'>        address[] memory _path = new address[](_twoHops ? 3 : 2);</span>
 130 |     | <span class='unexecuted'>        _path[0] = _in;</span>
 131 |     | <span class='unexecuted'>        _path[1] = !_twoHops ? _out : _token0 == _in</span>
 132 |     | <span class='unexecuted'>          ? IUniswapV2Pair(_poolInfo.pool1).token1()</span>
 133 |     | <span class='unexecuted'>          : _token0;</span>
 134 |     | <span class='unexecuted'>        if (_twoHops) {</span>
 135 |     | <span class='unexecuted'>          _path[2] = _out;</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='unexecuted'>        _amountOut = _swapV2(_path, _amountIn, _amountOutMin);</span>
 138 |     | <span class='neutral'>      } else {</span>
 139 |     | <span class='neutral'>        // univ3</span>
 140 |     | <span class='unexecuted'>        if (_twoHops) {</span>
 141 |     | <span class='unexecuted'>          address _t0 = IUniswapV3Pool(_poolInfo.pool1).token0();</span>
 142 |     | <span class='unexecuted'>          _amountOut = _swapV3Multi(</span>
 143 |     | <span class='unexecuted'>            _in,</span>
 144 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool1),</span>
 145 |     | <span class='unexecuted'>            _t0 == _in ? IUniswapV3Pool(_poolInfo.pool1).token1() : _t0,</span>
 146 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool2),</span>
 147 |     | <span class='unexecuted'>            _out,</span>
 148 |     | <span class='unexecuted'>            _amountIn,</span>
 149 |     | <span class='unexecuted'>            _amountOutMin</span>
 150 |     | <span class='neutral'>          );</span>
 151 |     | <span class='neutral'>        } else {</span>
 152 |     | <span class='unexecuted'>          _amountOut = _swapV3Single(</span>
 153 |     | <span class='unexecuted'>            _in,</span>
 154 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool1),</span>
 155 |     | <span class='unexecuted'>            _out,</span>
 156 |     | <span class='unexecuted'>            _amountIn,</span>
 157 |     | <span class='unexecuted'>            _amountOutMin</span>
 158 |     | <span class='neutral'>          );</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>      }</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='unexecuted'>    if (!_isOutPOHM) {</span>
 163 |     | <span class='unexecuted'>      return _amountOut;</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='unexecuted'>    uint256 _pOHMBefore = IERC20(pOHM).balanceOf(address(this));</span>
 166 |     | <span class='unexecuted'>    IERC20(OHM).safeIncreaseAllowance(pOHM, _amountOut);</span>
 167 |     | <span class='unexecuted'>    IDecentralizedIndex(pOHM).bond(OHM, _amountOut, 0);</span>
 168 |     | <span class='unexecuted'>    return IERC20(pOHM).balanceOf(address(this)) - _pOHMBefore;</span>
 169 |     | <span class='neutral'>  }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>  function _getPoolFee(address _pool) internal view returns (uint24) {</span>
 172 |     | <span class='unexecuted'>    return block.chainid == 42161 ? 0 : IUniswapV3Pool(_pool).fee();</span>
 173 |     | <span class='neutral'>  }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>  function _ethToWETH(uint256 _amountETH) internal returns (uint256) {</span>
 176 |     | <span class='unexecuted'>    uint256 _wethBal = IERC20(WETH).balanceOf(address(this));</span>
 177 |     | <span class='unexecuted'>    IWETH(WETH).deposit{ value: _amountETH }();</span>
 178 |     | <span class='unexecuted'>    return IERC20(WETH).balanceOf(address(this)) - _wethBal;</span>
 179 |     | <span class='neutral'>  }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>  function _swapV3Single(</span>
 182 |     | <span class='neutral'>    address _in,</span>
 183 |     | <span class='neutral'>    uint24 _fee,</span>
 184 |     | <span class='neutral'>    address _out,</span>
 185 |     | <span class='neutral'>    uint256 _amountIn,</span>
 186 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 187 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 188 |     | <span class='unexecuted'>    if (_amountOutMin == 0) {</span>
 189 |     | <span class='unexecuted'>      address _v3Pool;</span>
 190 |     | <span class='unexecuted'>      try DEX_ADAPTER.getV3Pool(_in, _out, uint24(10000)) returns (</span>
 191 |     | <span class='neutral'>        address __v3Pool</span>
 192 |     | <span class='neutral'>      ) {</span>
 193 |     | <span class='unexecuted'>        _v3Pool = __v3Pool;</span>
 194 |     | <span class='neutral'>      } catch {</span>
 195 |     | <span class='unexecuted'>        _v3Pool = DEX_ADAPTER.getV3Pool(_in, _out, int24(200));</span>
 196 |     | <span class='neutral'>      }</span>
 197 |     | <span class='unexecuted'>      address _token0 = _in &lt; _out ? _in : _out;</span>
 198 |     | <span class='unexecuted'>      uint256 _poolPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(</span>
 199 |     | <span class='unexecuted'>        V3_TWAP_UTILS.sqrtPriceX96FromPoolAndInterval(_v3Pool)</span>
 200 |     | <span class='neutral'>      );</span>
 201 |     | <span class='unexecuted'>      _amountOutMin = _in == _token0</span>
 202 |     | <span class='unexecuted'>        ? (_poolPriceX96 * _amountIn) / FixedPoint96.Q96</span>
 203 |     | <span class='unexecuted'>        : (_amountIn * FixedPoint96.Q96) / _poolPriceX96;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 207 |     | <span class='unexecuted'>    IERC20(_in).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);</span>
 208 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV3Single(</span>
 209 |     | <span class='unexecuted'>      _in,</span>
 210 |     | <span class='unexecuted'>      _out,</span>
 211 |     | <span class='unexecuted'>      _fee,</span>
 212 |     | <span class='unexecuted'>      _amountIn,</span>
 213 |     | <span class='unexecuted'>      (_amountOutMin * (1000 - _slippage)) / 1000,</span>
 214 |     | <span class='unexecuted'>      address(this)</span>
 215 |     | <span class='neutral'>    );</span>
 216 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 217 |     | <span class='neutral'>  }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>  function _swapV3Multi(</span>
 220 |     | <span class='neutral'>    address _in,</span>
 221 |     | <span class='neutral'>    uint24 _fee1,</span>
 222 |     | <span class='neutral'>    address _in2,</span>
 223 |     | <span class='neutral'>    uint24 _fee2,</span>
 224 |     | <span class='neutral'>    address _out,</span>
 225 |     | <span class='neutral'>    uint256 _amountIn,</span>
 226 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 227 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 228 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 229 |     | <span class='unexecuted'>    IERC20(_in).safeIncreaseAllowance(V3_ROUTER, _amountIn);</span>
 230 |     | <span class='unexecuted'>    bytes memory _path = abi.encodePacked(_in, _fee1, _in2, _fee2, _out);</span>
 231 |     | <span class='unexecuted'>    ISwapRouter(V3_ROUTER).exactInput(</span>
 232 |     | <span class='unexecuted'>      ISwapRouter.ExactInputParams({</span>
 233 |     | <span class='neutral'>        path: _path,</span>
 234 |     | <span class='unexecuted'>        recipient: address(this),</span>
 235 |     | <span class='unexecuted'>        deadline: block.timestamp,</span>
 236 |     | <span class='neutral'>        amountIn: _amountIn,</span>
 237 |     | <span class='neutral'>        amountOutMinimum: _amountOutMin</span>
 238 |     | <span class='neutral'>      })</span>
 239 |     | <span class='neutral'>    );</span>
 240 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 241 |     | <span class='neutral'>  }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>  function _swapV2(</span>
 244 |     | <span class='neutral'>    address[] memory _path,</span>
 245 |     | <span class='neutral'>    uint256 _amountIn,</span>
 246 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 247 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 248 |     | <span class='unexecuted'>    address _out = _path.length == 3 ? _path[2] : _path[1];</span>
 249 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 250 |     | <span class='unexecuted'>    IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);</span>
 251 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 252 |     | <span class='unexecuted'>      _path[0],</span>
 253 |     | <span class='unexecuted'>      _path[1],</span>
 254 |     | <span class='neutral'>      _amountIn,</span>
 255 |     | <span class='neutral'>      _amountOutMin,</span>
 256 |     | <span class='unexecuted'>      address(this)</span>
 257 |     | <span class='neutral'>    );</span>
 258 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 259 |     | <span class='neutral'>  }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>  function _swapCurve(</span>
 262 |     | <span class='neutral'>    address _pool,</span>
 263 |     | <span class='neutral'>    int128 _i,</span>
 264 |     | <span class='neutral'>    int128 _j,</span>
 265 |     | <span class='neutral'>    uint256 _amountIn,</span>
 266 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 267 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 268 |     | <span class='unexecuted'>    IERC20(ICurvePool(_pool).coins(uint128(_i))).safeIncreaseAllowance(</span>
 269 |     | <span class='unexecuted'>      _pool,</span>
 270 |     | <span class='unexecuted'>      _amountIn</span>
 271 |     | <span class='neutral'>    );</span>
 272 |     | <span class='neutral'>    return</span>
 273 |     | <span class='unexecuted'>      ICurvePool(_pool).exchange(</span>
 274 |     | <span class='neutral'>        _i,</span>
 275 |     | <span class='neutral'>        _j,</span>
 276 |     | <span class='neutral'>        _amountIn,</span>
 277 |     | <span class='neutral'>        _amountOutMin,</span>
 278 |     | <span class='unexecuted'>        address(this)</span>
 279 |     | <span class='neutral'>      );</span>
 280 |     | <span class='neutral'>  }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>  function _wethToYeth(</span>
 283 |     | <span class='neutral'>    uint256 _ethAmount,</span>
 284 |     | <span class='neutral'>    uint256 _minYethAmount,</span>
 285 |     | <span class='neutral'>    bool _stakeToStyeth</span>
 286 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 287 |     | <span class='unexecuted'>    uint256 _boughtYeth = _swapCurve(</span>
 288 |     | <span class='neutral'>      WETH_YETH_POOL,</span>
 289 |     | <span class='unexecuted'>      0,</span>
 290 |     | <span class='unexecuted'>      1,</span>
 291 |     | <span class='unexecuted'>      _ethAmount,</span>
 292 |     | <span class='unexecuted'>      _minYethAmount</span>
 293 |     | <span class='neutral'>    );</span>
 294 |     | <span class='unexecuted'>    if (_stakeToStyeth) {</span>
 295 |     | <span class='unexecuted'>      IERC20(YETH).safeIncreaseAllowance(STYETH, _boughtYeth);</span>
 296 |     | <span class='unexecuted'>      return IERC4626(STYETH).deposit(_boughtYeth, address(this));</span>
 297 |     | <span class='neutral'>    }</span>
 298 |     | <span class='neutral'>    return _boughtYeth;</span>
 299 |     | <span class='neutral'>  }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='unexecuted'>  function _styethToWeth(</span>
 302 |     | <span class='neutral'>    uint256 _stYethAmount,</span>
 303 |     | <span class='neutral'>    uint256 _minWethAmount,</span>
 304 |     | <span class='neutral'>    bool _isYethOnly</span>
 305 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 306 |     | <span class='unexecuted'>    uint256 _yethAmount;</span>
 307 |     | <span class='unexecuted'>    if (_isYethOnly) {</span>
 308 |     | <span class='unexecuted'>      _yethAmount = _stYethAmount;</span>
 309 |     | <span class='neutral'>    } else {</span>
 310 |     | <span class='unexecuted'>      _yethAmount = IERC4626(STYETH).redeem(</span>
 311 |     | <span class='neutral'>        _stYethAmount,</span>
 312 |     | <span class='unexecuted'>        address(this),</span>
 313 |     | <span class='neutral'>        address(this)</span>
 314 |     | <span class='neutral'>      );</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='unexecuted'>    return _swapCurve(WETH_YETH_POOL, 1, 0, _yethAmount, _minWethAmount);</span>
 317 |     | <span class='neutral'>  }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='unexecuted'>  function _setZapMapFromPoolSingle(PoolType _type, address _pool) internal {</span>
 320 |     | <span class='unexecuted'>    address _t0;</span>
 321 |     | <span class='neutral'>    address _t1;</span>
 322 |     | <span class='unexecuted'>    if (_type == PoolType.CURVE) {</span>
 323 |     | <span class='unexecuted'>      _t0 = ICurvePool(_pool).coins(0);</span>
 324 |     | <span class='unexecuted'>      _t1 = ICurvePool(_pool).coins(1);</span>
 325 |     | <span class='unexecuted'>      curveTokenIdx[_pool][_t0] = 0;</span>
 326 |     | <span class='unexecuted'>      curveTokenIdx[_pool][_t1] = 1;</span>
 327 |     | <span class='neutral'>    } else {</span>
 328 |     | <span class='unexecuted'>      _t0 = IUniswapV3Pool(_pool).token0();</span>
 329 |     | <span class='unexecuted'>      _t1 = IUniswapV3Pool(_pool).token1();</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='unexecuted'>    Pools memory _poolConf = Pools({</span>
 332 |     | <span class='unexecuted'>      poolType: _type,</span>
 333 |     | <span class='neutral'>      pool1: _pool,</span>
 334 |     | <span class='neutral'>      pool2: address(0)</span>
 335 |     | <span class='neutral'>    });</span>
 336 |     | <span class='unexecuted'>    zapMap[_t0][_t1] = _poolConf;</span>
 337 |     | <span class='unexecuted'>    zapMap[_t1][_t0] = _poolConf;</span>
 338 |     | <span class='neutral'>  }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='unexecuted'>  function setOHM(address _OHM, address _pOHM) external onlyOwner {</span>
 341 |     | <span class='unexecuted'>    OHM = _OHM == address(0) ? OHM : _OHM;</span>
 342 |     | <span class='unexecuted'>    pOHM = _pOHM == address(0) ? pOHM : _pOHM;</span>
 343 |     | <span class='neutral'>  }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='unexecuted'>  function setSlippage(uint256 _slip) external onlyOwner {</span>
 346 |     | <span class='unexecuted'>    require(_slip &gt;= 0 &amp;&amp; _slip &lt;= 1000, &#39;BOUNDS&#39;);</span>
 347 |     | <span class='unexecuted'>    _slippage = _slip;</span>
 348 |     | <span class='neutral'>  }</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='unexecuted'>  function setZapMap(</span>
 351 |     | <span class='neutral'>    address _in,</span>
 352 |     | <span class='neutral'>    address _out,</span>
 353 |     | <span class='neutral'>    Pools memory _pools</span>
 354 |     | <span class='neutral'>  ) external onlyOwner {</span>
 355 |     | <span class='unexecuted'>    zapMap[_in][_out] = _pools;</span>
 356 |     | <span class='neutral'>  }</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='unexecuted'>  function setZapMapFromPoolSingle(</span>
 359 |     | <span class='neutral'>    PoolType _type,</span>
 360 |     | <span class='neutral'>    address _pool</span>
 361 |     | <span class='neutral'>  ) external onlyOwner {</span>
 362 |     | <span class='unexecuted'>    _setZapMapFromPoolSingle(_type, _pool);</span>
 363 |     | <span class='neutral'>  }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='unexecuted'>  function rescueETH() external onlyOwner {</span>
 366 |     | <span class='unexecuted'>    (bool _sent, ) = payable(owner()).call{ value: address(this).balance }(&#39;&#39;);</span>
 367 |     | <span class='unexecuted'>    require(_sent);</span>
 368 |     | <span class='neutral'>  }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='unexecuted'>  function rescueERC20(IERC20 _token) external onlyOwner {</span>
 371 |     | <span class='unexecuted'>    require(_token.balanceOf(address(this)) &gt; 0);</span>
 372 |     | <span class='unexecuted'>    _token.safeTransfer(owner(), _token.balanceOf(address(this)));</span>
 373 |     | <span class='neutral'>  }</span>
 374 |     | <span class='neutral'></span>
 375 |     | <span class='neutral'>  receive() external payable {}</span>
 376 |     | <span class='neutral'>}</span>
 377 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/dex/UniswapDexAdapter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/utils/Context.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IDexAdapter.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/ISwapRouter02.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Factory.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Router02.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../interfaces/IV3TwapUtilities.sol&#39;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>contract UniswapDexAdapter is IDexAdapter, Context {</span>
  15 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>  IV3TwapUtilities public immutable V3_TWAP_UTILS;</span>
  18 |     | <span class='unexecuted'>  address public immutable override V2_ROUTER;</span>
  19 |     | <span class='unexecuted'>  address public immutable override V3_ROUTER;</span>
  20 |     | <span class='unexecuted'>  bool public immutable override ASYNC_INITIALIZE;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>  constructor(</span>
  23 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  24 |     | <span class='neutral'>    address _v2Router,</span>
  25 |     | <span class='neutral'>    address _v3Router,</span>
  26 |     | <span class='neutral'>    bool _asyncInit</span>
  27 |     | <span class='neutral'>  ) {</span>
  28 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  29 |     | <span class='unexecuted'>    V2_ROUTER = _v2Router;</span>
  30 |     | <span class='unexecuted'>    V3_ROUTER = _v3Router;</span>
  31 |     | <span class='unexecuted'>    ASYNC_INITIALIZE = _asyncInit;</span>
  32 |     | <span class='neutral'>  }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>  function WETH() external view virtual override returns (address) {</span>
  35 |     | <span class='unexecuted'>    return IUniswapV2Router02(V2_ROUTER).WETH();</span>
  36 |     | <span class='neutral'>  }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>  function getV3Pool(</span>
  39 |     | <span class='neutral'>    address,</span>
  40 |     | <span class='neutral'>    address,</span>
  41 |     | <span class='neutral'>    int24</span>
  42 |     | <span class='unexecuted'>  ) external view virtual override returns (address _p) {</span>
  43 |     | <span class='neutral'>    _p;</span>
  44 |     | <span class='unexecuted'>    require(false, &#39;I0&#39;);</span>
  45 |     | <span class='neutral'>  }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>  function getV3Pool(</span>
  48 |     | <span class='neutral'>    address _token0,</span>
  49 |     | <span class='neutral'>    address _token1,</span>
  50 |     | <span class='neutral'>    uint24 _poolFee</span>
  51 |     | <span class='unexecuted'>  ) external view virtual override returns (address) {</span>
  52 |     | <span class='unexecuted'>    return</span>
  53 |     | <span class='unexecuted'>      V3_TWAP_UTILS.getV3Pool(</span>
  54 |     | <span class='unexecuted'>        IPeripheryImmutableState(V3_ROUTER).factory(),</span>
  55 |     | <span class='neutral'>        _token0,</span>
  56 |     | <span class='neutral'>        _token1,</span>
  57 |     | <span class='neutral'>        _poolFee</span>
  58 |     | <span class='neutral'>      );</span>
  59 |     | <span class='neutral'>  }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>  function getV2Pool(</span>
  62 |     | <span class='neutral'>    address _token0,</span>
  63 |     | <span class='neutral'>    address _token1</span>
  64 |     | <span class='unexecuted'>  ) external view virtual override returns (address) {</span>
  65 |     | <span class='unexecuted'>    return</span>
  66 |     | <span class='unexecuted'>      IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory()).getPair(</span>
  67 |     | <span class='neutral'>        _token0,</span>
  68 |     | <span class='neutral'>        _token1</span>
  69 |     | <span class='neutral'>      );</span>
  70 |     | <span class='neutral'>  }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='unexecuted'>  function createV2Pool(</span>
  73 |     | <span class='neutral'>    address _token0,</span>
  74 |     | <span class='neutral'>    address _token1</span>
  75 |     | <span class='unexecuted'>  ) external virtual override returns (address) {</span>
  76 |     | <span class='neutral'>    return</span>
  77 |     | <span class='unexecuted'>      IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory()).createPair(</span>
  78 |     | <span class='neutral'>        _token0,</span>
  79 |     | <span class='neutral'>        _token1</span>
  80 |     | <span class='neutral'>      );</span>
  81 |     | <span class='neutral'>  }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>  function swapV2Single(</span>
  84 |     | <span class='neutral'>    address _tokenIn,</span>
  85 |     | <span class='neutral'>    address _tokenOut,</span>
  86 |     | <span class='neutral'>    uint256 _amountIn,</span>
  87 |     | <span class='neutral'>    uint256 _amountOutMin,</span>
  88 |     | <span class='neutral'>    address _recipient</span>
  89 |     | <span class='unexecuted'>  ) external virtual override returns (uint256 _amountOut) {</span>
  90 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_tokenOut).balanceOf(_recipient);</span>
  91 |     | <span class='unexecuted'>    if (_amountIn == 0) {</span>
  92 |     | <span class='unexecuted'>      _amountIn = IERC20(_tokenIn).balanceOf(address(this));</span>
  93 |     | <span class='neutral'>    } else {</span>
  94 |     | <span class='unexecuted'>      IERC20(_tokenIn).safeTransferFrom(_msgSender(), address(this), _amountIn);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='unexecuted'>    address[] memory _path = new address[](2);</span>
  97 |     | <span class='unexecuted'>    _path[0] = _tokenIn;</span>
  98 |     | <span class='unexecuted'>    _path[1] = _tokenOut;</span>
  99 |     | <span class='unexecuted'>    IERC20(_tokenIn).safeIncreaseAllowance(V2_ROUTER, _amountIn);</span>
 100 |     | <span class='unexecuted'>    IUniswapV2Router02(V2_ROUTER)</span>
 101 |     | <span class='neutral'>      .swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 102 |     | <span class='unexecuted'>        _amountIn,</span>
 103 |     | <span class='unexecuted'>        _amountOutMin,</span>
 104 |     | <span class='unexecuted'>        _path,</span>
 105 |     | <span class='unexecuted'>        _recipient,</span>
 106 |     | <span class='unexecuted'>        block.timestamp</span>
 107 |     | <span class='neutral'>      );</span>
 108 |     | <span class='unexecuted'>    return IERC20(_tokenOut).balanceOf(_recipient) - _outBefore;</span>
 109 |     | <span class='neutral'>  }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>  function swapV2SingleExactOut(</span>
 112 |     | <span class='neutral'>    address _tokenIn,</span>
 113 |     | <span class='neutral'>    address _tokenOut,</span>
 114 |     | <span class='neutral'>    uint256 _amountInMax,</span>
 115 |     | <span class='neutral'>    uint256 _amountOut,</span>
 116 |     | <span class='neutral'>    address _recipient</span>
 117 |     | <span class='unexecuted'>  ) external virtual override returns (uint256 _amountInUsed) {</span>
 118 |     | <span class='unexecuted'>    uint256 _inBefore = IERC20(_tokenIn).balanceOf(address(this));</span>
 119 |     | <span class='unexecuted'>    if (_amountInMax == 0) {</span>
 120 |     | <span class='unexecuted'>      _amountInMax = IERC20(_tokenIn).balanceOf(address(this));</span>
 121 |     | <span class='neutral'>    } else {</span>
 122 |     | <span class='unexecuted'>      IERC20(_tokenIn).safeTransferFrom(</span>
 123 |     | <span class='unexecuted'>        _msgSender(),</span>
 124 |     | <span class='neutral'>        address(this),</span>
 125 |     | <span class='neutral'>        _amountInMax</span>
 126 |     | <span class='neutral'>      );</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='unexecuted'>    address[] memory _path = new address[](2);</span>
 129 |     | <span class='unexecuted'>    _path[0] = _tokenIn;</span>
 130 |     | <span class='unexecuted'>    _path[1] = _tokenOut;</span>
 131 |     | <span class='unexecuted'>    IERC20(_tokenIn).safeIncreaseAllowance(V2_ROUTER, _amountInMax);</span>
 132 |     | <span class='unexecuted'>    IUniswapV2Router02(V2_ROUTER).swapTokensForExactTokens(</span>
 133 |     | <span class='unexecuted'>      _amountOut,</span>
 134 |     | <span class='unexecuted'>      _amountInMax,</span>
 135 |     | <span class='unexecuted'>      _path,</span>
 136 |     | <span class='unexecuted'>      _recipient,</span>
 137 |     | <span class='unexecuted'>      block.timestamp</span>
 138 |     | <span class='neutral'>    );</span>
 139 |     | <span class='unexecuted'>    uint256 _inRemaining = IERC20(_tokenIn).balanceOf(address(this)) -</span>
 140 |     | <span class='unexecuted'>      _inBefore;</span>
 141 |     | <span class='unexecuted'>    if (_inRemaining &gt; 0) {</span>
 142 |     | <span class='unexecuted'>      IERC20(_tokenIn).safeTransfer(_msgSender(), _inRemaining);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='unexecuted'>    _amountInUsed = _amountInMax - _inRemaining;</span>
 145 |     | <span class='neutral'>  }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>  function swapV3Single(</span>
 148 |     | <span class='neutral'>    address _tokenIn,</span>
 149 |     | <span class='neutral'>    address _tokenOut,</span>
 150 |     | <span class='neutral'>    uint24 _fee,</span>
 151 |     | <span class='neutral'>    uint256 _amountIn,</span>
 152 |     | <span class='neutral'>    uint256 _amountOutMin,</span>
 153 |     | <span class='neutral'>    address _recipient</span>
 154 |     | <span class='unexecuted'>  ) external virtual override returns (uint256 _amountOut) {</span>
 155 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_tokenOut).balanceOf(_recipient);</span>
 156 |     | <span class='unexecuted'>    if (_amountIn == 0) {</span>
 157 |     | <span class='unexecuted'>      _amountIn = IERC20(_tokenIn).balanceOf(address(this));</span>
 158 |     | <span class='neutral'>    } else {</span>
 159 |     | <span class='unexecuted'>      IERC20(_tokenIn).safeTransferFrom(_msgSender(), address(this), _amountIn);</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='unexecuted'>    IERC20(_tokenIn).safeIncreaseAllowance(V3_ROUTER, _amountIn);</span>
 162 |     | <span class='unexecuted'>    ISwapRouter02(V3_ROUTER).exactInputSingle(</span>
 163 |     | <span class='unexecuted'>      ISwapRouter02.ExactInputSingleParams({</span>
 164 |     | <span class='neutral'>        tokenIn: _tokenIn,</span>
 165 |     | <span class='neutral'>        tokenOut: _tokenOut,</span>
 166 |     | <span class='neutral'>        fee: _fee,</span>
 167 |     | <span class='neutral'>        recipient: _recipient,</span>
 168 |     | <span class='neutral'>        amountIn: _amountIn,</span>
 169 |     | <span class='neutral'>        amountOutMinimum: _amountOutMin,</span>
 170 |     | <span class='neutral'>        sqrtPriceLimitX96: 0</span>
 171 |     | <span class='neutral'>      })</span>
 172 |     | <span class='neutral'>    );</span>
 173 |     | <span class='unexecuted'>    return IERC20(_tokenOut).balanceOf(_recipient) - _outBefore;</span>
 174 |     | <span class='neutral'>  }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>  function addLiquidity(</span>
 177 |     | <span class='neutral'>    address _tokenA,</span>
 178 |     | <span class='neutral'>    address _tokenB,</span>
 179 |     | <span class='neutral'>    uint256 _amountADesired,</span>
 180 |     | <span class='neutral'>    uint256 _amountBDesired,</span>
 181 |     | <span class='neutral'>    uint256 _amountAMin,</span>
 182 |     | <span class='neutral'>    uint256 _amountBMin,</span>
 183 |     | <span class='neutral'>    address _to,</span>
 184 |     | <span class='neutral'>    uint256 _deadline</span>
 185 |     | <span class='unexecuted'>  ) external virtual override {</span>
 186 |     | <span class='unexecuted'>    uint256 _aBefore = IERC20(_tokenA).balanceOf(address(this));</span>
 187 |     | <span class='unexecuted'>    uint256 _bBefore = IERC20(_tokenB).balanceOf(address(this));</span>
 188 |     | <span class='unexecuted'>    IERC20(_tokenA).safeTransferFrom(</span>
 189 |     | <span class='neutral'>      _msgSender(),</span>
 190 |     | <span class='unexecuted'>      address(this),</span>
 191 |     | <span class='unexecuted'>      _amountADesired</span>
 192 |     | <span class='neutral'>    );</span>
 193 |     | <span class='unexecuted'>    IERC20(_tokenB).safeTransferFrom(</span>
 194 |     | <span class='neutral'>      _msgSender(),</span>
 195 |     | <span class='unexecuted'>      address(this),</span>
 196 |     | <span class='unexecuted'>      _amountBDesired</span>
 197 |     | <span class='neutral'>    );</span>
 198 |     | <span class='unexecuted'>    IERC20(_tokenA).safeIncreaseAllowance(V2_ROUTER, _amountADesired);</span>
 199 |     | <span class='unexecuted'>    IERC20(_tokenB).safeIncreaseAllowance(V2_ROUTER, _amountBDesired);</span>
 200 |     | <span class='unexecuted'>    IUniswapV2Router02(V2_ROUTER).addLiquidity(</span>
 201 |     | <span class='neutral'>      _tokenA,</span>
 202 |     | <span class='neutral'>      _tokenB,</span>
 203 |     | <span class='neutral'>      _amountADesired,</span>
 204 |     | <span class='neutral'>      _amountBDesired,</span>
 205 |     | <span class='neutral'>      _amountAMin,</span>
 206 |     | <span class='neutral'>      _amountBMin,</span>
 207 |     | <span class='neutral'>      _to,</span>
 208 |     | <span class='neutral'>      _deadline</span>
 209 |     | <span class='neutral'>    );</span>
 210 |     | <span class='unexecuted'>    if (IERC20(_tokenA).balanceOf(address(this)) &gt; _aBefore) {</span>
 211 |     | <span class='unexecuted'>      IERC20(_tokenA).safeTransfer(</span>
 212 |     | <span class='unexecuted'>        _to,</span>
 213 |     | <span class='unexecuted'>        IERC20(_tokenA).balanceOf(address(this)) - _aBefore</span>
 214 |     | <span class='neutral'>      );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='unexecuted'>    if (IERC20(_tokenB).balanceOf(address(this)) &gt; _bBefore) {</span>
 217 |     | <span class='unexecuted'>      IERC20(_tokenB).safeTransfer(</span>
 218 |     | <span class='unexecuted'>        _to,</span>
 219 |     | <span class='unexecuted'>        IERC20(_tokenB).balanceOf(address(this)) - _bBefore</span>
 220 |     | <span class='neutral'>      );</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'>  }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='unexecuted'>  function removeLiquidity(</span>
 225 |     | <span class='neutral'>    address _tokenA,</span>
 226 |     | <span class='neutral'>    address _tokenB,</span>
 227 |     | <span class='neutral'>    uint256 _liquidity,</span>
 228 |     | <span class='neutral'>    uint256 _amountAMin,</span>
 229 |     | <span class='neutral'>    uint256 _amountBMin,</span>
 230 |     | <span class='neutral'>    address _to,</span>
 231 |     | <span class='neutral'>    uint256 _deadline</span>
 232 |     | <span class='unexecuted'>  ) external virtual override {</span>
 233 |     | <span class='unexecuted'>    address _pool = IUniswapV2Factory(IUniswapV2Router02(V2_ROUTER).factory())</span>
 234 |     | <span class='neutral'>      .getPair(_tokenA, _tokenB);</span>
 235 |     | <span class='unexecuted'>    uint256 _lpBefore = IERC20(_pool).balanceOf(address(this));</span>
 236 |     | <span class='unexecuted'>    IERC20(_pool).safeTransferFrom(_msgSender(), address(this), _liquidity);</span>
 237 |     | <span class='unexecuted'>    IERC20(_pool).safeIncreaseAllowance(V2_ROUTER, _liquidity);</span>
 238 |     | <span class='unexecuted'>    IUniswapV2Router02(V2_ROUTER).removeLiquidity(</span>
 239 |     | <span class='neutral'>      _tokenA,</span>
 240 |     | <span class='neutral'>      _tokenB,</span>
 241 |     | <span class='neutral'>      _liquidity,</span>
 242 |     | <span class='neutral'>      _amountAMin,</span>
 243 |     | <span class='neutral'>      _amountBMin,</span>
 244 |     | <span class='neutral'>      _to,</span>
 245 |     | <span class='neutral'>      _deadline</span>
 246 |     | <span class='neutral'>    );</span>
 247 |     | <span class='unexecuted'>    if (IERC20(_pool).balanceOf(address(this)) &gt; _lpBefore) {</span>
 248 |     | <span class='unexecuted'>      IERC20(_pool).safeTransfer(</span>
 249 |     | <span class='unexecuted'>        _to,</span>
 250 |     | <span class='unexecuted'>        IERC20(_pool).balanceOf(address(this)) - _lpBefore</span>
 251 |     | <span class='neutral'>      );</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'>  }</span>
 254 |     | <span class='neutral'></span>
 255 |     | <span class='unexecuted'>  function extraRewardsHook(</span>
 256 |     | <span class='neutral'>    address,</span>
 257 |     | <span class='neutral'>    address</span>
 258 |     | <span class='neutral'>  )</span>
 259 |     | <span class='neutral'>    external</span>
 260 |     | <span class='neutral'>    virtual</span>
 261 |     | <span class='neutral'>    override</span>
 262 |     | <span class='unexecuted'>    returns (address[] memory _t, uint256[] memory _a)</span>
 263 |     | <span class='neutral'>  {</span>
 264 |     | <span class='neutral'>    _t;</span>
 265 |     | <span class='neutral'>    _a;</span>
 266 |     | <span class='neutral'>  }</span>
 267 |     | <span class='neutral'>}</span>
 268 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ICurvePool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ICurvePool {</span>
  5 |     | <span class='neutral'>  function coins(uint256 _idx) external returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function exchange(</span>
  8 |     | <span class='neutral'>    int128 i,</span>
  9 |     | <span class='neutral'>    int128 j,</span>
 10 |     | <span class='neutral'>    uint256 dx,</span>
 11 |     | <span class='neutral'>    uint256 minDy,</span>
 12 |     | <span class='neutral'>    address receiver</span>
 13 |     | <span class='neutral'>  ) external returns (uint256);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IDecentralizedIndex.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>interface IDecentralizedIndex is IERC20 {</span>
   7 |     | <span class='neutral'>  enum IndexType {</span>
   8 |     | <span class='neutral'>    WEIGHTED,</span>
   9 |     | <span class='neutral'>    UNWEIGHTED</span>
  10 |     | <span class='neutral'>  }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>  struct Config {</span>
  13 |     | <span class='neutral'>    address partner;</span>
  14 |     | <span class='neutral'>    bool hasTransferTax;</span>
  15 |     | <span class='neutral'>    bool blacklistTKNpTKNPoolV2;</span>
  16 |     | <span class='neutral'>  }</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>  // all fees: 1 == 0.01%, 10 == 0.1%, 100 == 1%</span>
  19 |     | <span class='neutral'>  struct Fees {</span>
  20 |     | <span class='neutral'>    uint16 burn;</span>
  21 |     | <span class='neutral'>    uint16 bond;</span>
  22 |     | <span class='neutral'>    uint16 debond;</span>
  23 |     | <span class='neutral'>    uint16 buy;</span>
  24 |     | <span class='neutral'>    uint16 sell;</span>
  25 |     | <span class='neutral'>    uint16 partner;</span>
  26 |     | <span class='neutral'>  }</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>  struct IndexAssetInfo {</span>
  29 |     | <span class='neutral'>    address token;</span>
  30 |     | <span class='neutral'>    uint256 weighting;</span>
  31 |     | <span class='neutral'>    uint256 basePriceUSDX96;</span>
  32 |     | <span class='neutral'>    address c1; // arbitrary contract/address field we can use for an index</span>
  33 |     | <span class='neutral'>    uint256 q1; // arbitrary quantity/number field we can use for an index</span>
  34 |     | <span class='neutral'>  }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>  /// @notice The ```Create``` event fires when a new decentralized index has been created</span>
  37 |     | <span class='neutral'>  /// @param newIdx The CA of the new index contract</span>
  38 |     | <span class='neutral'>  /// @param wallet The creator of the new index</span>
  39 |     | <span class='neutral'>  event Create(address indexed newIdx, address indexed wallet);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>  /// @notice The ```Initialize``` event fires when the new pod has been initialized,</span>
  42 |     | <span class='neutral'>  /// @notice which is at creation on some and in another txn for others (gas limits)</span>
  43 |     | <span class='neutral'>  /// @param wallet The wallet that initialized</span>
  44 |     | <span class='neutral'>  /// @param v2Pool The new UniV2 derivative pool that was created at initialization</span>
  45 |     | <span class='neutral'>  event Initialize(address indexed wallet, address v2Pool);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>  /// @notice The ```Bond``` event fires when someone wraps into the pod which mints new pod tokens</span>
  48 |     | <span class='neutral'>  /// @param wallet The wallet that wrapped</span>
  49 |     | <span class='neutral'>  /// @param token The token that was used as a ref to wrap into, representing an underlying tkn</span>
  50 |     | <span class='neutral'>  /// @param amountTokensBonded Amount of underlying tkns used to wrap/bond</span>
  51 |     | <span class='neutral'>  /// @param amountTokensMinted Amount of new pod tokens (pTKN) minted</span>
  52 |     | <span class='neutral'>  event Bond(</span>
  53 |     | <span class='neutral'>    address indexed wallet,</span>
  54 |     | <span class='neutral'>    address indexed token,</span>
  55 |     | <span class='neutral'>    uint256 amountTokensBonded,</span>
  56 |     | <span class='neutral'>    uint256 amountTokensMinted</span>
  57 |     | <span class='neutral'>  );</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>  /// @notice The ```Debond``` event fires when someone unwraps from a pod and redeems underlying tkn(s)</span>
  60 |     | <span class='neutral'>  /// @param wallet The wallet that unwrapped/debond</span>
  61 |     | <span class='neutral'>  /// @param amountDebonded Amount of pTKNs burned/unwrapped</span>
  62 |     | <span class='neutral'>  event Debond(address indexed wallet, uint256 amountDebonded);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>  /// @notice The ```AddLiquidity``` event fires when new liquidity (LP) for a pod is added</span>
  65 |     | <span class='neutral'>  /// @param wallet The wallet that added LP</span>
  66 |     | <span class='neutral'>  /// @param amountTokens Amount of pTKNs used for LP</span>
  67 |     | <span class='neutral'>  /// @param amountDAI Amount of pairedLpAsset used for LP</span>
  68 |     | <span class='neutral'>  event AddLiquidity(</span>
  69 |     | <span class='neutral'>    address indexed wallet,</span>
  70 |     | <span class='neutral'>    uint256 amountTokens,</span>
  71 |     | <span class='neutral'>    uint256 amountDAI</span>
  72 |     | <span class='neutral'>  );</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>  /// @notice The ```RemoveLiquidity``` event fires when LP is removed for a pod</span>
  75 |     | <span class='neutral'>  /// @param wallet The wallet that removed LP</span>
  76 |     | <span class='neutral'>  /// @param amountLiquidity Amount of liquidity removed</span>
  77 |     | <span class='neutral'>  event RemoveLiquidity(address indexed wallet, uint256 amountLiquidity);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>  event SetPartner(address indexed wallet, address newPartner);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>  event SetPartnerFee(address indexed wallet, uint16 newFee);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>  function BOND_FEE() external view returns (uint16);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>  function DEBOND_FEE() external view returns (uint16);</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>  function FLASH_FEE_AMOUNT_DAI() external view returns (uint256);</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>  function PAIRED_LP_TOKEN() external view returns (address);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>  function unlocked() external view returns (uint8);</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>  function indexType() external view returns (IndexType);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>  function created() external view returns (uint256);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>  function lpStakingPool() external view returns (address);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>  function lpRewardsToken() external view returns (address);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>  function partner() external view returns (address);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>  function getIdxPriceUSDX96() external view returns (uint256, uint256);</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>  function isAsset(address token) external view returns (bool);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>  function getAllAssets() external view returns (IndexAssetInfo[] memory);</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>  function getInitialAmount(</span>
 110 |     | <span class='neutral'>    address sToken,</span>
 111 |     | <span class='neutral'>    uint256 sAmount,</span>
 112 |     | <span class='neutral'>    address tToken</span>
 113 |     | <span class='neutral'>  ) external view returns (uint256);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>  function getTokenPriceUSDX96(address token) external view returns (uint256);</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>  function processPreSwapFeesAndSwap() external;</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>  function bond(address token, uint256 amount, uint256 amountMintMin) external;</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>  function debond(</span>
 122 |     | <span class='neutral'>    uint256 amount,</span>
 123 |     | <span class='neutral'>    address[] memory token,</span>
 124 |     | <span class='neutral'>    uint8[] memory percentage</span>
 125 |     | <span class='neutral'>  ) external;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>  function addLiquidityV2(</span>
 128 |     | <span class='neutral'>    uint256 idxTokens,</span>
 129 |     | <span class='neutral'>    uint256 daiTokens,</span>
 130 |     | <span class='neutral'>    uint256 slippage,</span>
 131 |     | <span class='neutral'>    uint256 deadline</span>
 132 |     | <span class='neutral'>  ) external returns (uint256);</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>  function removeLiquidityV2(</span>
 135 |     | <span class='neutral'>    uint256 lpTokens,</span>
 136 |     | <span class='neutral'>    uint256 minTokens,</span>
 137 |     | <span class='neutral'>    uint256 minDAI,</span>
 138 |     | <span class='neutral'>    uint256 deadline</span>
 139 |     | <span class='neutral'>  ) external;</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='neutral'>  function flash(</span>
 142 |     | <span class='neutral'>    address recipient,</span>
 143 |     | <span class='neutral'>    address token,</span>
 144 |     | <span class='neutral'>    uint256 amount,</span>
 145 |     | <span class='neutral'>    bytes calldata data</span>
 146 |     | <span class='neutral'>  ) external;</span>
 147 |     | <span class='neutral'>}</span>
 148 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IDexAdapter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IDexAdapter {</span>
  5 |     | <span class='neutral'>  function ASYNC_INITIALIZE() external view returns (bool);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function V2_ROUTER() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function V3_ROUTER() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  function WETH() external view returns (address);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  function getV3Pool(</span>
 14 |     | <span class='neutral'>    address _token0,</span>
 15 |     | <span class='neutral'>    address _token1,</span>
 16 |     | <span class='neutral'>    int24 _tickSpacing</span>
 17 |     | <span class='neutral'>  ) external view returns (address _pool);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>  function getV3Pool(</span>
 20 |     | <span class='neutral'>    address _token0,</span>
 21 |     | <span class='neutral'>    address _token1,</span>
 22 |     | <span class='neutral'>    uint24 _poolFee</span>
 23 |     | <span class='neutral'>  ) external view returns (address _pool);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>  function getV2Pool(</span>
 26 |     | <span class='neutral'>    address _token0,</span>
 27 |     | <span class='neutral'>    address _token1</span>
 28 |     | <span class='neutral'>  ) external view returns (address _pool);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  function createV2Pool(</span>
 31 |     | <span class='neutral'>    address _token0,</span>
 32 |     | <span class='neutral'>    address _token1</span>
 33 |     | <span class='neutral'>  ) external returns (address _pool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>  function swapV2Single(</span>
 36 |     | <span class='neutral'>    address _tokenIn,</span>
 37 |     | <span class='neutral'>    address _tokenOut,</span>
 38 |     | <span class='neutral'>    uint256 _amountIn,</span>
 39 |     | <span class='neutral'>    uint256 _amountOutMin,</span>
 40 |     | <span class='neutral'>    address _recipient</span>
 41 |     | <span class='neutral'>  ) external returns (uint256 _amountOut);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>  function swapV2SingleExactOut(</span>
 44 |     | <span class='neutral'>    address _tokenIn,</span>
 45 |     | <span class='neutral'>    address _tokenOut,</span>
 46 |     | <span class='neutral'>    uint256 _amountInMax,</span>
 47 |     | <span class='neutral'>    uint256 _amountOut,</span>
 48 |     | <span class='neutral'>    address _recipient</span>
 49 |     | <span class='neutral'>  ) external returns (uint256 _amountInUsed);</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>  function swapV3Single(</span>
 52 |     | <span class='neutral'>    address _tokenIn,</span>
 53 |     | <span class='neutral'>    address _tokenOut,</span>
 54 |     | <span class='neutral'>    uint24 _fee,</span>
 55 |     | <span class='neutral'>    uint256 _amountIn,</span>
 56 |     | <span class='neutral'>    uint256 _amountOutMin,</span>
 57 |     | <span class='neutral'>    address _recipient</span>
 58 |     | <span class='neutral'>  ) external returns (uint256 _amountOut);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>  function addLiquidity(</span>
 61 |     | <span class='neutral'>    address tokenA,</span>
 62 |     | <span class='neutral'>    address tokenB,</span>
 63 |     | <span class='neutral'>    uint256 amountADesired,</span>
 64 |     | <span class='neutral'>    uint256 amountBDesired,</span>
 65 |     | <span class='neutral'>    uint256 amountAMin,</span>
 66 |     | <span class='neutral'>    uint256 amountBMin,</span>
 67 |     | <span class='neutral'>    address to,</span>
 68 |     | <span class='neutral'>    uint256 deadline</span>
 69 |     | <span class='neutral'>  ) external;</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='neutral'>  function removeLiquidity(</span>
 72 |     | <span class='neutral'>    address tokenA,</span>
 73 |     | <span class='neutral'>    address tokenB,</span>
 74 |     | <span class='neutral'>    uint256 liquidity,</span>
 75 |     | <span class='neutral'>    uint256 amountAMin,</span>
 76 |     | <span class='neutral'>    uint256 amountBMin,</span>
 77 |     | <span class='neutral'>    address to,</span>
 78 |     | <span class='neutral'>    uint256 deadline</span>
 79 |     | <span class='neutral'>  ) external;</span>
 80 |     | <span class='neutral'></span>
 81 |     | <span class='neutral'>  function extraRewardsHook(</span>
 82 |     | <span class='neutral'>    address _token0,</span>
 83 |     | <span class='neutral'>    address _token1</span>
 84 |     | <span class='neutral'>  ) external returns (address[] memory tokens, uint256[] memory amounts);</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IERC20Metadata.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IERC20Metadata {</span>
 5 |     | <span class='neutral'>  function decimals() external view returns (uint8);</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFlashLoanRecipient.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IFlashLoanRecipient {</span>
 5 |     | <span class='neutral'>  function callback(bytes calldata data) external;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFlashLoanSource.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IFlashLoanSource {</span>
  5 |     | <span class='neutral'>  struct FlashData {</span>
  6 |     | <span class='neutral'>    address recipient;</span>
  7 |     | <span class='neutral'>    address token;</span>
  8 |     | <span class='neutral'>    uint256 amount;</span>
  9 |     | <span class='neutral'>    bytes data;</span>
 10 |     | <span class='neutral'>    uint256 fee;</span>
 11 |     | <span class='neutral'>  }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  function source() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  function paymentToken() external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  function paymentAmount() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>  function flash(</span>
 20 |     | <span class='neutral'>    address token,</span>
 21 |     | <span class='neutral'>    uint256 amount,</span>
 22 |     | <span class='neutral'>    address recipient,</span>
 23 |     | <span class='neutral'>    bytes calldata data</span>
 24 |     | <span class='neutral'>  ) external;</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IFraxlendPair.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import { VaultAccount } from &#39;../libraries/VaultAccount.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>interface IFraxlendPair is IERC20 {</span>
  8 |     | <span class='neutral'>  function totalBorrow() external view returns (VaultAccount memory);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>  function asset() external view returns (address);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  function collateralContract() external view returns (address);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>  function userCollateralBalance(address user) external view returns (uint256); // amount of collateral each user is backed</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>  function userBorrowShares(address user) external view returns (uint256); // represents the shares held by individuals</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  function deposit(</span>
 19 |     | <span class='neutral'>    uint256 _amount,</span>
 20 |     | <span class='neutral'>    address _receiver</span>
 21 |     | <span class='neutral'>  ) external returns (uint256 _sharesReceived);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>  function redeem(</span>
 24 |     | <span class='neutral'>    uint256 _shares,</span>
 25 |     | <span class='neutral'>    address _receiver,</span>
 26 |     | <span class='neutral'>    address _owner</span>
 27 |     | <span class='neutral'>  ) external returns (uint256 _amountToReturn);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>  function borrowAsset(</span>
 30 |     | <span class='neutral'>    uint256 _borrowAmount,</span>
 31 |     | <span class='neutral'>    uint256 _collateralAmount,</span>
 32 |     | <span class='neutral'>    address _receiver</span>
 33 |     | <span class='neutral'>  ) external returns (uint256 _shares);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>  function repayAsset(</span>
 36 |     | <span class='neutral'>    uint256 _shares,</span>
 37 |     | <span class='neutral'>    address _borrower</span>
 38 |     | <span class='neutral'>  ) external returns (uint256 _amountToRepay);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>  function addCollateral(uint256 _collateralAmount, address _borrower) external;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>  function removeCollateral(</span>
 43 |     | <span class='neutral'>    uint256 _collateralAmount,</span>
 44 |     | <span class='neutral'>    address _receiver</span>
 45 |     | <span class='neutral'>  ) external;</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IIndexUtils.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IDecentralizedIndex.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IIndexUtils {</span>
  7 |     | <span class='neutral'>  function addLPAndStake(</span>
  8 |     | <span class='neutral'>    IDecentralizedIndex indexFund,</span>
  9 |     | <span class='neutral'>    uint256 amountIdxTokens,</span>
 10 |     | <span class='neutral'>    address pairedLpTokenProvided,</span>
 11 |     | <span class='neutral'>    uint256 amtPairedLpTokenProvided,</span>
 12 |     | <span class='neutral'>    uint256 amountPairedLpTokenMin,</span>
 13 |     | <span class='neutral'>    uint256 slippage,</span>
 14 |     | <span class='neutral'>    uint256 deadline</span>
 15 |     | <span class='neutral'>  ) external payable returns (uint256 amountOut);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  function unstakeAndRemoveLP(</span>
 18 |     | <span class='neutral'>    IDecentralizedIndex indexFund,</span>
 19 |     | <span class='neutral'>    uint256 amountStakedTokens,</span>
 20 |     | <span class='neutral'>    uint256 minLPTokens,</span>
 21 |     | <span class='neutral'>    uint256 minPairedLpToken,</span>
 22 |     | <span class='neutral'>    uint256 deadline</span>
 23 |     | <span class='neutral'>  ) external;</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IIndexUtils_LEGACY.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IDecentralizedIndex.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IIndexUtils_LEGACY {</span>
  7 |     | <span class='neutral'>  function addLPAndStake(</span>
  8 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
  9 |     | <span class='neutral'>    uint256 _amountIdxTokens,</span>
 10 |     | <span class='neutral'>    address _pairedLpTokenProvided,</span>
 11 |     | <span class='neutral'>    uint256 _amtPairedLpTokenProvided,</span>
 12 |     | <span class='neutral'>    uint256 _amountPairedLpTokenMin,</span>
 13 |     | <span class='neutral'>    uint256 _slippage,</span>
 14 |     | <span class='neutral'>    uint256 _deadline</span>
 15 |     | <span class='neutral'>  ) external payable;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  function unstakeAndRemoveLP(</span>
 18 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 19 |     | <span class='neutral'>    uint256 _amountStakedTokens,</span>
 20 |     | <span class='neutral'>    uint256 _minLPTokens,</span>
 21 |     | <span class='neutral'>    uint256 _minPairedLpToken,</span>
 22 |     | <span class='neutral'>    uint256 _deadline</span>
 23 |     | <span class='neutral'>  ) external;</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ILendingAssetVault.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ILendingAssetVault {</span>
  5 |     | <span class='neutral'>  event DonateAssets(address indexed user, uint256 amount);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  event PayBackUsedAssets(address indexed user, uint256 amount);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  event SetVaultWhitelist(address indexed vault, bool isWhitelisted);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  event SetVaultMaxAlloPercentage(address indexed vault, uint256 percentage);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  event WhitelistDeposit(address indexed user, uint256 amount);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  event WhitelistWithdraw(address indexed user, uint256 amount);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  function totalAvailableAssets() external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>  function whitelistDeposit(uint256 amount) external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>  function whitelistWithdraw(uint256 amount) external;</span>
 22 |     | <span class='neutral'>}</span>
 23 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ILeverageManager.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ILeverageManager {</span>
  5 |     | <span class='neutral'>  enum FlashCallbackMethod {</span>
  6 |     | <span class='neutral'>    ADD,</span>
  7 |     | <span class='neutral'>    REMOVE</span>
  8 |     | <span class='neutral'>  }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>  struct LeverageFlashProps {</span>
 11 |     | <span class='neutral'>    FlashCallbackMethod method;</span>
 12 |     | <span class='neutral'>    uint256 positionId;</span>
 13 |     | <span class='neutral'>    address user;</span>
 14 |     | <span class='neutral'>    address pod;</span>
 15 |     | <span class='neutral'>    uint256 podAmount;</span>
 16 |     | <span class='neutral'>    uint256 pairedLpDesired;</span>
 17 |     | <span class='neutral'>    uint256 pairedLpAmtMin;</span>
 18 |     | <span class='neutral'>    uint256 overrideBorrowAmt;</span>
 19 |     | <span class='neutral'>    uint256 slippage;</span>
 20 |     | <span class='neutral'>    uint256 deadline;</span>
 21 |     | <span class='neutral'>    address selfLendingPairPod;</span>
 22 |     | <span class='neutral'>  }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>  struct LeveragePositionProps {</span>
 25 |     | <span class='neutral'>    address pod;</span>
 26 |     | <span class='neutral'>    address lendingPair;</span>
 27 |     | <span class='neutral'>    address custodian;</span>
 28 |     | <span class='neutral'>    address selfLendingPod;</span>
 29 |     | <span class='neutral'>  }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>  function initializePosition(</span>
 32 |     | <span class='neutral'>    address _pod,</span>
 33 |     | <span class='neutral'>    address _recipient,</span>
 34 |     | <span class='neutral'>    address _selfLendingPairPod</span>
 35 |     | <span class='neutral'>  ) external;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>  function addLeverage(</span>
 38 |     | <span class='neutral'>    uint256 _positionId,</span>
 39 |     | <span class='neutral'>    address _pod,</span>
 40 |     | <span class='neutral'>    uint256 _podAmount,</span>
 41 |     | <span class='neutral'>    uint256 _pairedLpDesired,</span>
 42 |     | <span class='neutral'>    uint256 _pairedLpAmtMin,</span>
 43 |     | <span class='neutral'>    uint256 _overrideBorrowAmt,</span>
 44 |     | <span class='neutral'>    uint256 _slippage,</span>
 45 |     | <span class='neutral'>    uint256 _deadline,</span>
 46 |     | <span class='neutral'>    address _selfLendingPairPod</span>
 47 |     | <span class='neutral'>  ) external;</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>  function removeLeverage(</span>
 50 |     | <span class='neutral'>    uint256 _positionId,</span>
 51 |     | <span class='neutral'>    uint256 _borrowAssetAmt,</span>
 52 |     | <span class='neutral'>    uint256 _collateralAssetAmtRemove,</span>
 53 |     | <span class='neutral'>    uint256 _podAmtMin,</span>
 54 |     | <span class='neutral'>    uint256 _pairedAssetAmtMin,</span>
 55 |     | <span class='neutral'>    address _dexAdapter,</span>
 56 |     | <span class='neutral'>    uint256 _userProvidedDebtAmtMax</span>
 57 |     | <span class='neutral'>  ) external;</span>
 58 |     | <span class='neutral'>}</span>
 59 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IMinimalOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMinimalOracle {</span>
  5 |     | <span class='neutral'>  function getPrices()</span>
  6 |     | <span class='neutral'>    external</span>
  7 |     | <span class='neutral'>    view</span>
  8 |     | <span class='neutral'>    returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IMinimalSinglePriceOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IMinimalSinglePriceOracle {</span>
  5 |     | <span class='neutral'>  function getPriceUSD18(</span>
  6 |     | <span class='neutral'>    address base,</span>
  7 |     | <span class='neutral'>    address quote,</span>
  8 |     | <span class='neutral'>    address a1, // any extra address parameter an implementation may need</span>
  9 |     | <span class='neutral'>    uint256 q1 // any extra uint256 parameter an implementation may need</span>
 10 |     | <span class='neutral'>  ) external view returns (bool isBadData, uint256 price18);</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IPEAS.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IPEAS is IERC20 {</span>
  7 |     | <span class='neutral'>  event Burn(address indexed user, uint256 amount);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function burn(uint256 amount) external;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IProtocolFeeRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./IProtocolFees.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IProtocolFeeRouter {</span>
  7 |     | <span class='neutral'>  function protocolFees() external view returns (IProtocolFees);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IProtocolFees.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IProtocolFees {</span>
  5 |     | <span class='neutral'>  event SetYieldAdmin(uint256 newFee);</span>
  6 |     | <span class='neutral'>  event SetYieldBurn(uint256 newFee);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>  function DEN() external view returns (uint256);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>  function yieldAdmin() external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  function yieldBurn() external view returns (uint256);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IRewardsWhitelister.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IRewardsWhitelister {</span>
  5 |     | <span class='neutral'>  function whitelist(address token) external view returns (bool);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function getFullWhitelist() external view returns (address[] memory);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IStakingPoolToken.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IStakingPoolToken {</span>
  5 |     | <span class='neutral'>  event Stake(address indexed executor, address indexed user, uint256 amount);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  event Unstake(address indexed user, uint256 amount);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function INDEX_FUND() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  function indexFund() external view returns (address);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  function POOL_REWARDS() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  function poolRewards() external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  function stakingToken() external view returns (address);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>  function stakeUserRestriction() external view returns (address);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>  function stake(address user, uint256 amount) external;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>  function unstake(uint256 amount) external;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>  function externalRewardHook(address token0, address token1) external;</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ISwapRouter02.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ISwapRouter02 {</span>
  5 |     | <span class='neutral'>  struct ExactInputSingleParams {</span>
  6 |     | <span class='neutral'>    address tokenIn;</span>
  7 |     | <span class='neutral'>    address tokenOut;</span>
  8 |     | <span class='neutral'>    uint24 fee;</span>
  9 |     | <span class='neutral'>    address recipient;</span>
 10 |     | <span class='neutral'>    uint256 amountIn;</span>
 11 |     | <span class='neutral'>    uint256 amountOutMinimum;</span>
 12 |     | <span class='neutral'>    uint160 sqrtPriceLimitX96;</span>
 13 |     | <span class='neutral'>  }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>  function exactInputSingle(</span>
 16 |     | <span class='neutral'>    ExactInputSingleParams calldata params</span>
 17 |     | <span class='neutral'>  ) external payable returns (uint256 amountOut);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>  struct ExactInputParams {</span>
 20 |     | <span class='neutral'>    bytes path;</span>
 21 |     | <span class='neutral'>    address recipient;</span>
 22 |     | <span class='neutral'>    uint256 amountIn;</span>
 23 |     | <span class='neutral'>    uint256 amountOutMinimum;</span>
 24 |     | <span class='neutral'>  }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>  function exactInput(</span>
 27 |     | <span class='neutral'>    ExactInputParams calldata params</span>
 28 |     | <span class='neutral'>  ) external payable returns (uint256 amountOut);</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/ITokenRewards.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ITokenRewards {</span>
  5 |     | <span class='neutral'>  event AddShares(address indexed wallet, uint256 amount);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  event RemoveShares(address indexed wallet, uint256 amount);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  event ClaimReward(address indexed wallet);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  event DistributeReward(</span>
 12 |     | <span class='neutral'>    address indexed wallet,</span>
 13 |     | <span class='neutral'>    address indexed token,</span>
 14 |     | <span class='neutral'>    uint256 amount</span>
 15 |     | <span class='neutral'>  );</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  event DepositRewards(</span>
 18 |     | <span class='neutral'>    address indexed wallet,</span>
 19 |     | <span class='neutral'>    address indexed token,</span>
 20 |     | <span class='neutral'>    uint256 amount</span>
 21 |     | <span class='neutral'>  );</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>  event RewardSwapError(uint256 amountIn);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>  function totalShares() external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>  function totalStakers() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>  function rewardsToken() external view returns (address);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>  function trackingToken() external view returns (address);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>  function depositFromPairedLpToken(uint256 amount) external;</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>  function depositRewards(address token, uint256 amount) external;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>  function depositRewardsNoTransfer(address token, uint256 amount) external;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>  function claimReward(address wallet) external;</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>  function setShares(</span>
 42 |     | <span class='neutral'>    address wallet,</span>
 43 |     | <span class='neutral'>    uint256 amount,</span>
 44 |     | <span class='neutral'>    bool sharesRemoving</span>
 45 |     | <span class='neutral'>  ) external;</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV2Factory {</span>
  5 |     | <span class='neutral'>  function createPair(</span>
  6 |     | <span class='neutral'>    address tokenA,</span>
  7 |     | <span class='neutral'>    address tokenB</span>
  8 |     | <span class='neutral'>  ) external returns (address pair);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>  function getPair(</span>
 11 |     | <span class='neutral'>    address tokenA,</span>
 12 |     | <span class='neutral'>    address tokenB</span>
 13 |     | <span class='neutral'>  ) external view returns (address pair);</span>
 14 |     | <span class='neutral'>}</span>
 15 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Pair.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV2Pair {</span>
  5 |     | <span class='neutral'>  function token0() external view returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function token1() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function getReserves()</span>
 10 |     | <span class='neutral'>    external</span>
 11 |     | <span class='neutral'>    view</span>
 12 |     | <span class='neutral'>    returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV2Router02.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV2Router02 {</span>
  5 |     | <span class='neutral'>  function factory() external view returns (address);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function WETH() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  function addLiquidity(</span>
 10 |     | <span class='neutral'>    address tokenA,</span>
 11 |     | <span class='neutral'>    address tokenB,</span>
 12 |     | <span class='neutral'>    uint amountADesired,</span>
 13 |     | <span class='neutral'>    uint amountBDesired,</span>
 14 |     | <span class='neutral'>    uint amountAMin,</span>
 15 |     | <span class='neutral'>    uint amountBMin,</span>
 16 |     | <span class='neutral'>    address to,</span>
 17 |     | <span class='neutral'>    uint deadline</span>
 18 |     | <span class='neutral'>  ) external returns (uint amountA, uint amountB, uint liquidity);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>  function removeLiquidity(</span>
 21 |     | <span class='neutral'>    address tokenA,</span>
 22 |     | <span class='neutral'>    address tokenB,</span>
 23 |     | <span class='neutral'>    uint liquidity,</span>
 24 |     | <span class='neutral'>    uint amountAMin,</span>
 25 |     | <span class='neutral'>    uint amountBMin,</span>
 26 |     | <span class='neutral'>    address to,</span>
 27 |     | <span class='neutral'>    uint deadline</span>
 28 |     | <span class='neutral'>  ) external returns (uint amountA, uint amountB);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  function swapETHForExactTokens(</span>
 31 |     | <span class='neutral'>    uint256 amountOut,</span>
 32 |     | <span class='neutral'>    address[] calldata path,</span>
 33 |     | <span class='neutral'>    address to,</span>
 34 |     | <span class='neutral'>    uint256 deadline</span>
 35 |     | <span class='neutral'>  ) external payable returns (uint256[] memory amounts);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>  function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 38 |     | <span class='neutral'>    uint amountIn,</span>
 39 |     | <span class='neutral'>    uint amountOutMin,</span>
 40 |     | <span class='neutral'>    address[] calldata path,</span>
 41 |     | <span class='neutral'>    address to,</span>
 42 |     | <span class='neutral'>    uint deadline</span>
 43 |     | <span class='neutral'>  ) external returns (uint[] memory amounts);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>  function swapTokensForExactTokens(</span>
 46 |     | <span class='neutral'>    uint amountOut,</span>
 47 |     | <span class='neutral'>    uint amountInMax,</span>
 48 |     | <span class='neutral'>    address[] calldata path,</span>
 49 |     | <span class='neutral'>    address to,</span>
 50 |     | <span class='neutral'>    uint deadline</span>
 51 |     | <span class='neutral'>  ) external returns (uint[] memory amounts);</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IUniswapV3Pool {</span>
  5 |     | <span class='neutral'>  /// @notice The first of the two tokens of the pool, sorted by address</span>
  6 |     | <span class='neutral'>  /// @return The token contract address</span>
  7 |     | <span class='neutral'>  function token0() external view returns (address);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  /// @notice The second of the two tokens of the pool, sorted by address</span>
 10 |     | <span class='neutral'>  /// @return The token contract address</span>
 11 |     | <span class='neutral'>  function token1() external view returns (address);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 14 |     | <span class='neutral'>  /// @return The fee</span>
 15 |     | <span class='neutral'>  function fee() external view returns (uint24);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
 18 |     | <span class='neutral'>  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 19 |     | <span class='neutral'>  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 20 |     | <span class='neutral'>  /// you must call it with secondsAgos = [3600, 0].</span>
 21 |     | <span class='neutral'>  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 22 |     | <span class='neutral'>  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 23 |     | <span class='neutral'>  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 24 |     | <span class='neutral'>  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 25 |     | <span class='neutral'>  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 26 |     | <span class='neutral'>  /// timestamp</span>
 27 |     | <span class='neutral'>  function observe(</span>
 28 |     | <span class='neutral'>    uint32[] calldata secondsAgos</span>
 29 |     | <span class='neutral'>  )</span>
 30 |     | <span class='neutral'>    external</span>
 31 |     | <span class='neutral'>    view</span>
 32 |     | <span class='neutral'>    returns (</span>
 33 |     | <span class='neutral'>      int56[] memory tickCumulatives,</span>
 34 |     | <span class='neutral'>      uint160[] memory secondsPerLiquidityCumulativeX128s</span>
 35 |     | <span class='neutral'>    );</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
 38 |     | <span class='neutral'>  /// when accessed externally.</span>
 39 |     | <span class='neutral'>  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
 40 |     | <span class='neutral'>  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
 41 |     | <span class='neutral'>  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
 42 |     | <span class='neutral'>  /// boundary.</span>
 43 |     | <span class='neutral'>  /// observationIndex The index of the last oracle observation that was written,</span>
 44 |     | <span class='neutral'>  /// observationCardinality The current maximum number of observations stored in the pool,</span>
 45 |     | <span class='neutral'>  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
 46 |     | <span class='neutral'>  /// feeProtocol The protocol fee for both tokens of the pool.</span>
 47 |     | <span class='neutral'>  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
 48 |     | <span class='neutral'>  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
 49 |     | <span class='neutral'>  /// unlocked Whether the pool is currently locked to reentrancy</span>
 50 |     | <span class='neutral'>  function slot0()</span>
 51 |     | <span class='neutral'>    external</span>
 52 |     | <span class='neutral'>    view</span>
 53 |     | <span class='neutral'>    returns (</span>
 54 |     | <span class='neutral'>      uint160 sqrtPriceX96,</span>
 55 |     | <span class='neutral'>      int24 tick,</span>
 56 |     | <span class='neutral'>      uint16 observationIndex,</span>
 57 |     | <span class='neutral'>      uint16 observationCardinality,</span>
 58 |     | <span class='neutral'>      uint16 observationCardinalityNext,</span>
 59 |     | <span class='neutral'>      uint8 feeProtocol,</span>
 60 |     | <span class='neutral'>      bool unlocked</span>
 61 |     | <span class='neutral'>    );</span>
 62 |     | <span class='neutral'>}</span>
 63 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IV2Reserves.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IV2Reserves {</span>
  5 |     | <span class='neutral'>  function getReserves(</span>
  6 |     | <span class='neutral'>    address _pair</span>
  7 |     | <span class='neutral'>  ) external view returns (uint112 reserve0, uint112 reserve1);</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IV3TwapUtilities.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IV3TwapUtilities {</span>
  5 |     | <span class='neutral'>  function getV3Pool(</span>
  6 |     | <span class='neutral'>    address v3Factory,</span>
  7 |     | <span class='neutral'>    address token0,</span>
  8 |     | <span class='neutral'>    address token1</span>
  9 |     | <span class='neutral'>  ) external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  function getV3Pool(</span>
 12 |     | <span class='neutral'>    address v3Factory,</span>
 13 |     | <span class='neutral'>    address token0,</span>
 14 |     | <span class='neutral'>    address token1,</span>
 15 |     | <span class='neutral'>    uint24 poolFee</span>
 16 |     | <span class='neutral'>  ) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>  function getV3Pool(</span>
 19 |     | <span class='neutral'>    address v3Factory,</span>
 20 |     | <span class='neutral'>    address token0,</span>
 21 |     | <span class='neutral'>    address token1,</span>
 22 |     | <span class='neutral'>    int24 tickSpacing</span>
 23 |     | <span class='neutral'>  ) external view returns (address);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>  function getPoolPriceUSDX96(</span>
 26 |     | <span class='neutral'>    address pricePool,</span>
 27 |     | <span class='neutral'>    address nativeStablePool,</span>
 28 |     | <span class='neutral'>    address WETH9</span>
 29 |     | <span class='neutral'>  ) external view returns (uint256);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>  function sqrtPriceX96FromPoolAndInterval(</span>
 32 |     | <span class='neutral'>    address pool</span>
 33 |     | <span class='neutral'>  ) external view returns (uint160);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>  function sqrtPriceX96FromPoolAndPassedInterval(</span>
 36 |     | <span class='neutral'>    address pool,</span>
 37 |     | <span class='neutral'>    uint32 interval</span>
 38 |     | <span class='neutral'>  ) external view returns (uint160);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>  function priceX96FromSqrtPriceX96(</span>
 41 |     | <span class='neutral'>    uint160 sqrtPriceX96</span>
 42 |     | <span class='neutral'>  ) external pure returns (uint256);</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IWETH {</span>
  5 |     | <span class='neutral'>  function deposit() external payable;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>  function withdraw(uint256 _amount) external;</span>
  8 |     | <span class='neutral'>}</span>
  9 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/interfaces/IZapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IZapper {</span>
  5 |     | <span class='neutral'>  enum PoolType {</span>
  6 |     | <span class='neutral'>    CURVE,</span>
  7 |     | <span class='neutral'>    V2,</span>
  8 |     | <span class='neutral'>    V3</span>
  9 |     | <span class='neutral'>  }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>  struct Pools {</span>
 12 |     | <span class='neutral'>    PoolType poolType; // assume same for both pool1 and pool2</span>
 13 |     | <span class='neutral'>    address pool1;</span>
 14 |     | <span class='neutral'>    address pool2;</span>
 15 |     | <span class='neutral'>  }</span>
 16 |     | <span class='neutral'>}</span>
 17 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/FullMath.sol</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   7 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   8 |     | <span class='neutral'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   9 |     | <span class='unexecuted'>library FullMath {</span>
  10 |     | <span class='neutral'>  /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  11 |     | <span class='neutral'>  /// @param a The multiplicand</span>
  12 |     | <span class='neutral'>  /// @param b The multiplier</span>
  13 |     | <span class='neutral'>  /// @param denominator The divisor</span>
  14 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
  15 |     | <span class='neutral'>  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  16 |     | <span class='unexecuted'>  function mulDiv(</span>
  17 |     | <span class='neutral'>    uint256 a,</span>
  18 |     | <span class='neutral'>    uint256 b,</span>
  19 |     | <span class='neutral'>    uint256 denominator</span>
  20 |     | <span class='unexecuted'>  ) internal pure returns (uint256 result) {</span>
  21 |     | <span class='neutral'>    unchecked {</span>
  22 |     | <span class='neutral'>      // 512-bit multiply [prod1 prod0] = a * b</span>
  23 |     | <span class='neutral'>      // Compute the product mod 2**256 and mod 2**256 - 1</span>
  24 |     | <span class='neutral'>      // then use the Chinese Remainder Theorem to reconstruct</span>
  25 |     | <span class='neutral'>      // the 512 bit result. The result is stored in two 256</span>
  26 |     | <span class='neutral'>      // variables such that product = prod1 * 2**256 + prod0</span>
  27 |     | <span class='neutral'>      uint256 prod0; // Least significant 256 bits of the product</span>
  28 |     | <span class='neutral'>      uint256 prod1; // Most significant 256 bits of the product</span>
  29 |     | <span class='neutral'>      assembly {</span>
  30 |     | <span class='unexecuted'>        let mm := mulmod(a, b, not(0))</span>
  31 |     | <span class='unexecuted'>        prod0 := mul(a, b)</span>
  32 |     | <span class='unexecuted'>        prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  33 |     | <span class='neutral'>      }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>      // Handle non-overflow cases, 256 by 256 division</span>
  36 |     | <span class='unexecuted'>      if (prod1 == 0) {</span>
  37 |     | <span class='unexecuted'>        require(denominator &gt; 0);</span>
  38 |     | <span class='neutral'>        assembly {</span>
  39 |     | <span class='unexecuted'>          result := div(prod0, denominator)</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='unexecuted'>        return result;</span>
  42 |     | <span class='neutral'>      }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>      // Make sure the result is less than 2**256.</span>
  45 |     | <span class='neutral'>      // Also prevents denominator == 0</span>
  46 |     | <span class='unexecuted'>      require(denominator &gt; prod1);</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
  49 |     | <span class='neutral'>      // 512 by 256 division.</span>
  50 |     | <span class='neutral'>      ///////////////////////////////////////////////</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>      // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  53 |     | <span class='neutral'>      // Compute remainder using mulmod</span>
  54 |     | <span class='unexecuted'>      uint256 remainder;</span>
  55 |     | <span class='neutral'>      assembly {</span>
  56 |     | <span class='unexecuted'>        remainder := mulmod(a, b, denominator)</span>
  57 |     | <span class='neutral'>      }</span>
  58 |     | <span class='neutral'>      // Subtract 256 bit number from 512 bit number</span>
  59 |     | <span class='neutral'>      assembly {</span>
  60 |     | <span class='unexecuted'>        prod1 := sub(prod1, gt(remainder, prod0))</span>
  61 |     | <span class='unexecuted'>        prod0 := sub(prod0, remainder)</span>
  62 |     | <span class='neutral'>      }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>      // Factor powers of two out of denominator</span>
  65 |     | <span class='neutral'>      // Compute largest power of two divisor of denominator.</span>
  66 |     | <span class='neutral'>      // Always &gt;= 1.</span>
  67 |     | <span class='unexecuted'>      uint256 twos = (0 - denominator) &amp; denominator;</span>
  68 |     | <span class='neutral'>      // Divide denominator by power of two</span>
  69 |     | <span class='neutral'>      assembly {</span>
  70 |     | <span class='unexecuted'>        denominator := div(denominator, twos)</span>
  71 |     | <span class='neutral'>      }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>      // Divide [prod1 prod0] by the factors of two</span>
  74 |     | <span class='neutral'>      assembly {</span>
  75 |     | <span class='unexecuted'>        prod0 := div(prod0, twos)</span>
  76 |     | <span class='neutral'>      }</span>
  77 |     | <span class='neutral'>      // Shift in bits from prod1 into prod0. For this we need</span>
  78 |     | <span class='neutral'>      // to flip `twos` such that it is 2**256 / twos.</span>
  79 |     | <span class='neutral'>      // If twos is zero, then it becomes one</span>
  80 |     | <span class='neutral'>      assembly {</span>
  81 |     | <span class='unexecuted'>        twos := add(div(sub(0, twos), twos), 1)</span>
  82 |     | <span class='neutral'>      }</span>
  83 |     | <span class='unexecuted'>      prod0 |= prod1 * twos;</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>      // Invert denominator mod 2**256</span>
  86 |     | <span class='neutral'>      // Now that denominator is an odd number, it has an inverse</span>
  87 |     | <span class='neutral'>      // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  88 |     | <span class='neutral'>      // Compute the inverse by starting with a seed that is correct</span>
  89 |     | <span class='neutral'>      // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  90 |     | <span class='unexecuted'>      uint256 inv = (3 * denominator) ^ 2;</span>
  91 |     | <span class='neutral'>      // Now use Newton-Raphson iteration to improve the precision.</span>
  92 |     | <span class='neutral'>      // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  93 |     | <span class='neutral'>      // arithmetic, doubling the correct bits in each step.</span>
  94 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  95 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  96 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  97 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**64</span>
  98 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**128</span>
  99 |     | <span class='unexecuted'>      inv *= 2 - denominator * inv; // inverse mod 2**256</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>      // Because the division is now exact we can divide by multiplying</span>
 102 |     | <span class='neutral'>      // with the modular inverse of denominator. This will give us the</span>
 103 |     | <span class='neutral'>      // correct result modulo 2**256. Since the precoditions guarantee</span>
 104 |     | <span class='neutral'>      // that the outcome is less than 2**256, this is the final result.</span>
 105 |     | <span class='neutral'>      // We don&#39;t need to compute the high bits of the result and prod1</span>
 106 |     | <span class='neutral'>      // is no longer required.</span>
 107 |     | <span class='unexecuted'>      result = prod0 * inv;</span>
 108 |     | <span class='neutral'>      return result;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'>  }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>  /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 113 |     | <span class='neutral'>  /// @param a The multiplicand</span>
 114 |     | <span class='neutral'>  /// @param b The multiplier</span>
 115 |     | <span class='neutral'>  /// @param denominator The divisor</span>
 116 |     | <span class='neutral'>  /// @return result The 256-bit result</span>
 117 |     | <span class='neutral'>  function mulDivRoundingUp(</span>
 118 |     | <span class='neutral'>    uint256 a,</span>
 119 |     | <span class='neutral'>    uint256 b,</span>
 120 |     | <span class='neutral'>    uint256 denominator</span>
 121 |     | <span class='neutral'>  ) internal pure returns (uint256 result) {</span>
 122 |     | <span class='neutral'>    unchecked {</span>
 123 |     | <span class='neutral'>      result = mulDiv(a, b, denominator);</span>
 124 |     | <span class='neutral'>      if (mulmod(a, b, denominator) &gt; 0) {</span>
 125 |     | <span class='neutral'>        require(result &lt; type(uint256).max);</span>
 126 |     | <span class='neutral'>        result++;</span>
 127 |     | <span class='neutral'>      }</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'>  }</span>
 130 |     | <span class='neutral'>}</span>
 131 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/PoolAddress.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee</span>
  5 |     | <span class='unexecuted'>library PoolAddress {</span>
  6 |     | <span class='neutral'>  bytes32 internal constant POOL_INIT_CODE_HASH =</span>
  7 |     | <span class='unexecuted'>    0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>  /// @notice The identifying key of the pool</span>
 10 |     | <span class='neutral'>  struct PoolKey {</span>
 11 |     | <span class='neutral'>    address token0;</span>
 12 |     | <span class='neutral'>    address token1;</span>
 13 |     | <span class='neutral'>    uint24 fee;</span>
 14 |     | <span class='neutral'>  }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>  /// @notice Returns PoolKey: the ordered tokens with the matched fee levels</span>
 17 |     | <span class='neutral'>  /// @param tokenA The first token of a pool, unsorted</span>
 18 |     | <span class='neutral'>  /// @param tokenB The second token of a pool, unsorted</span>
 19 |     | <span class='neutral'>  /// @param fee The fee level of the pool</span>
 20 |     | <span class='neutral'>  /// @return Poolkey The pool details with ordered token0 and token1 assignments</span>
 21 |     | <span class='neutral'>  function getPoolKey(</span>
 22 |     | <span class='neutral'>    address tokenA,</span>
 23 |     | <span class='neutral'>    address tokenB,</span>
 24 |     | <span class='neutral'>    uint24 fee</span>
 25 |     | <span class='neutral'>  ) internal pure returns (PoolKey memory) {</span>
 26 |     | <span class='neutral'>    if (tokenA &gt; tokenB) (tokenA, tokenB) = (tokenB, tokenA);</span>
 27 |     | <span class='neutral'>    return PoolKey({ token0: tokenA, token1: tokenB, fee: fee });</span>
 28 |     | <span class='neutral'>  }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>  /// @notice Deterministically computes the pool address given the factory and PoolKey</span>
 31 |     | <span class='neutral'>  /// @param factory The Uniswap V3 factory contract address</span>
 32 |     | <span class='neutral'>  /// @param key The PoolKey</span>
 33 |     | <span class='neutral'>  /// @return pool The contract address of the V3 pool</span>
 34 |     | <span class='unexecuted'>  function computeAddress(</span>
 35 |     | <span class='neutral'>    address factory,</span>
 36 |     | <span class='neutral'>    PoolKey memory key</span>
 37 |     | <span class='unexecuted'>  ) internal pure returns (address pool) {</span>
 38 |     | <span class='unexecuted'>    require(key.token0 &lt; key.token1);</span>
 39 |     | <span class='neutral'>    pool = address(</span>
 40 |     | <span class='neutral'>      uint160(</span>
 41 |     | <span class='neutral'>        uint256(</span>
 42 |     | <span class='unexecuted'>          keccak256(</span>
 43 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 44 |     | <span class='neutral'>              hex&#39;ff&#39;,</span>
 45 |     | <span class='neutral'>              factory,</span>
 46 |     | <span class='unexecuted'>              keccak256(abi.encode(key.token0, key.token1, key.fee)),</span>
 47 |     | <span class='neutral'>              POOL_INIT_CODE_HASH</span>
 48 |     | <span class='neutral'>            )</span>
 49 |     | <span class='neutral'>          )</span>
 50 |     | <span class='neutral'>        )</span>
 51 |     | <span class='neutral'>      )</span>
 52 |     | <span class='neutral'>    );</span>
 53 |     | <span class='neutral'>  }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// https://github.com/Uniswap/v3-core/blob/0.8/contracts/libraries/TickMath.sol</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title Math library for computing sqrt prices from ticks and vice versa</span>
   7 |     | <span class='neutral'>/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
   8 |     | <span class='neutral'>/// prices between 2**-128 and 2**128</span>
   9 |     | <span class='unexecuted'>library TickMath {</span>
  10 |     | <span class='neutral'>  error T();</span>
  11 |     | <span class='neutral'>  error R();</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
  14 |     | <span class='neutral'>  int24 internal constant MIN_TICK = -887272;</span>
  15 |     | <span class='neutral'>  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  16 |     | <span class='unexecuted'>  int24 internal constant MAX_TICK = -MIN_TICK;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  19 |     | <span class='neutral'>  uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  20 |     | <span class='neutral'>  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  21 |     | <span class='neutral'>  uint160 internal constant MAX_SQRT_RATIO =</span>
  22 |     | <span class='neutral'>    1461446703485210103287273052203988822378723970342;</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>  /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  25 |     | <span class='neutral'>  /// @dev Throws if |tick| &gt; max tick</span>
  26 |     | <span class='neutral'>  /// @param tick The input tick for the above formula</span>
  27 |     | <span class='neutral'>  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  28 |     | <span class='neutral'>  /// at the given tick</span>
  29 |     | <span class='unexecuted'>  function getSqrtRatioAtTick(</span>
  30 |     | <span class='neutral'>    int24 tick</span>
  31 |     | <span class='unexecuted'>  ) internal pure returns (uint160 sqrtPriceX96) {</span>
  32 |     | <span class='unexecuted'>    unchecked {</span>
  33 |     | <span class='unexecuted'>      uint256 absTick = tick &lt; 0</span>
  34 |     | <span class='unexecuted'>        ? uint256(-int256(tick))</span>
  35 |     | <span class='unexecuted'>        : uint256(int256(tick));</span>
  36 |     | <span class='unexecuted'>      if (absTick &gt; uint256(int256(MAX_TICK))) revert T();</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>      uint256 ratio = absTick &amp; 0x1 != 0</span>
  39 |     | <span class='unexecuted'>        ? 0xfffcb933bd6fad37aa2d162d1a594001</span>
  40 |     | <span class='neutral'>        : 0x100000000000000000000000000000000;</span>
  41 |     | <span class='unexecuted'>      if (absTick &amp; 0x2 != 0)</span>
  42 |     | <span class='unexecuted'>        ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  43 |     | <span class='unexecuted'>      if (absTick &amp; 0x4 != 0)</span>
  44 |     | <span class='unexecuted'>        ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  45 |     | <span class='unexecuted'>      if (absTick &amp; 0x8 != 0)</span>
  46 |     | <span class='unexecuted'>        ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  47 |     | <span class='unexecuted'>      if (absTick &amp; 0x10 != 0)</span>
  48 |     | <span class='unexecuted'>        ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  49 |     | <span class='unexecuted'>      if (absTick &amp; 0x20 != 0)</span>
  50 |     | <span class='unexecuted'>        ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  51 |     | <span class='unexecuted'>      if (absTick &amp; 0x40 != 0)</span>
  52 |     | <span class='unexecuted'>        ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  53 |     | <span class='unexecuted'>      if (absTick &amp; 0x80 != 0)</span>
  54 |     | <span class='unexecuted'>        ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  55 |     | <span class='unexecuted'>      if (absTick &amp; 0x100 != 0)</span>
  56 |     | <span class='unexecuted'>        ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  57 |     | <span class='unexecuted'>      if (absTick &amp; 0x200 != 0)</span>
  58 |     | <span class='unexecuted'>        ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  59 |     | <span class='unexecuted'>      if (absTick &amp; 0x400 != 0)</span>
  60 |     | <span class='unexecuted'>        ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  61 |     | <span class='unexecuted'>      if (absTick &amp; 0x800 != 0)</span>
  62 |     | <span class='unexecuted'>        ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  63 |     | <span class='unexecuted'>      if (absTick &amp; 0x1000 != 0)</span>
  64 |     | <span class='unexecuted'>        ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  65 |     | <span class='unexecuted'>      if (absTick &amp; 0x2000 != 0)</span>
  66 |     | <span class='unexecuted'>        ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  67 |     | <span class='unexecuted'>      if (absTick &amp; 0x4000 != 0)</span>
  68 |     | <span class='unexecuted'>        ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  69 |     | <span class='unexecuted'>      if (absTick &amp; 0x8000 != 0)</span>
  70 |     | <span class='unexecuted'>        ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  71 |     | <span class='unexecuted'>      if (absTick &amp; 0x10000 != 0)</span>
  72 |     | <span class='unexecuted'>        ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  73 |     | <span class='unexecuted'>      if (absTick &amp; 0x20000 != 0)</span>
  74 |     | <span class='unexecuted'>        ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  75 |     | <span class='unexecuted'>      if (absTick &amp; 0x40000 != 0)</span>
  76 |     | <span class='unexecuted'>        ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  77 |     | <span class='unexecuted'>      if (absTick &amp; 0x80000 != 0)</span>
  78 |     | <span class='unexecuted'>        ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>      if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>      // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  83 |     | <span class='neutral'>      // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  84 |     | <span class='neutral'>      // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  85 |     | <span class='unexecuted'>      sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'>  }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</span>
  90 |     | <span class='neutral'>  /// @dev Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may</span>
  91 |     | <span class='neutral'>  /// ever return.</span>
  92 |     | <span class='neutral'>  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96</span>
  93 |     | <span class='neutral'>  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio</span>
  94 |     | <span class='neutral'>  function getTickAtSqrtRatio(</span>
  95 |     | <span class='neutral'>    uint160 sqrtPriceX96</span>
  96 |     | <span class='neutral'>  ) internal pure returns (int24 tick) {</span>
  97 |     | <span class='neutral'>    unchecked {</span>
  98 |     | <span class='neutral'>      // second inequality must be &lt; because the price can never reach the price at the max tick</span>
  99 |     | <span class='neutral'>      if (!(sqrtPriceX96 &gt;= MIN_SQRT_RATIO &amp;&amp; sqrtPriceX96 &lt; MAX_SQRT_RATIO))</span>
 100 |     | <span class='neutral'>        revert R();</span>
 101 |     | <span class='neutral'>      uint256 ratio = uint256(sqrtPriceX96) &lt;&lt; 32;</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>      uint256 r = ratio;</span>
 104 |     | <span class='neutral'>      uint256 msb = 0;</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>      assembly {</span>
 107 |     | <span class='neutral'>        let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
 108 |     | <span class='neutral'>        msb := or(msb, f)</span>
 109 |     | <span class='neutral'>        r := shr(f, r)</span>
 110 |     | <span class='neutral'>      }</span>
 111 |     | <span class='neutral'>      assembly {</span>
 112 |     | <span class='neutral'>        let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
 113 |     | <span class='neutral'>        msb := or(msb, f)</span>
 114 |     | <span class='neutral'>        r := shr(f, r)</span>
 115 |     | <span class='neutral'>      }</span>
 116 |     | <span class='neutral'>      assembly {</span>
 117 |     | <span class='neutral'>        let f := shl(5, gt(r, 0xFFFFFFFF))</span>
 118 |     | <span class='neutral'>        msb := or(msb, f)</span>
 119 |     | <span class='neutral'>        r := shr(f, r)</span>
 120 |     | <span class='neutral'>      }</span>
 121 |     | <span class='neutral'>      assembly {</span>
 122 |     | <span class='neutral'>        let f := shl(4, gt(r, 0xFFFF))</span>
 123 |     | <span class='neutral'>        msb := or(msb, f)</span>
 124 |     | <span class='neutral'>        r := shr(f, r)</span>
 125 |     | <span class='neutral'>      }</span>
 126 |     | <span class='neutral'>      assembly {</span>
 127 |     | <span class='neutral'>        let f := shl(3, gt(r, 0xFF))</span>
 128 |     | <span class='neutral'>        msb := or(msb, f)</span>
 129 |     | <span class='neutral'>        r := shr(f, r)</span>
 130 |     | <span class='neutral'>      }</span>
 131 |     | <span class='neutral'>      assembly {</span>
 132 |     | <span class='neutral'>        let f := shl(2, gt(r, 0xF))</span>
 133 |     | <span class='neutral'>        msb := or(msb, f)</span>
 134 |     | <span class='neutral'>        r := shr(f, r)</span>
 135 |     | <span class='neutral'>      }</span>
 136 |     | <span class='neutral'>      assembly {</span>
 137 |     | <span class='neutral'>        let f := shl(1, gt(r, 0x3))</span>
 138 |     | <span class='neutral'>        msb := or(msb, f)</span>
 139 |     | <span class='neutral'>        r := shr(f, r)</span>
 140 |     | <span class='neutral'>      }</span>
 141 |     | <span class='neutral'>      assembly {</span>
 142 |     | <span class='neutral'>        let f := gt(r, 0x1)</span>
 143 |     | <span class='neutral'>        msb := or(msb, f)</span>
 144 |     | <span class='neutral'>      }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>      if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 147 |     | <span class='neutral'>      else r = ratio &lt;&lt; (127 - msb);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>      int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>      assembly {</span>
 152 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 153 |     | <span class='neutral'>        let f := shr(128, r)</span>
 154 |     | <span class='neutral'>        log_2 := or(log_2, shl(63, f))</span>
 155 |     | <span class='neutral'>        r := shr(f, r)</span>
 156 |     | <span class='neutral'>      }</span>
 157 |     | <span class='neutral'>      assembly {</span>
 158 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 159 |     | <span class='neutral'>        let f := shr(128, r)</span>
 160 |     | <span class='neutral'>        log_2 := or(log_2, shl(62, f))</span>
 161 |     | <span class='neutral'>        r := shr(f, r)</span>
 162 |     | <span class='neutral'>      }</span>
 163 |     | <span class='neutral'>      assembly {</span>
 164 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 165 |     | <span class='neutral'>        let f := shr(128, r)</span>
 166 |     | <span class='neutral'>        log_2 := or(log_2, shl(61, f))</span>
 167 |     | <span class='neutral'>        r := shr(f, r)</span>
 168 |     | <span class='neutral'>      }</span>
 169 |     | <span class='neutral'>      assembly {</span>
 170 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 171 |     | <span class='neutral'>        let f := shr(128, r)</span>
 172 |     | <span class='neutral'>        log_2 := or(log_2, shl(60, f))</span>
 173 |     | <span class='neutral'>        r := shr(f, r)</span>
 174 |     | <span class='neutral'>      }</span>
 175 |     | <span class='neutral'>      assembly {</span>
 176 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 177 |     | <span class='neutral'>        let f := shr(128, r)</span>
 178 |     | <span class='neutral'>        log_2 := or(log_2, shl(59, f))</span>
 179 |     | <span class='neutral'>        r := shr(f, r)</span>
 180 |     | <span class='neutral'>      }</span>
 181 |     | <span class='neutral'>      assembly {</span>
 182 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 183 |     | <span class='neutral'>        let f := shr(128, r)</span>
 184 |     | <span class='neutral'>        log_2 := or(log_2, shl(58, f))</span>
 185 |     | <span class='neutral'>        r := shr(f, r)</span>
 186 |     | <span class='neutral'>      }</span>
 187 |     | <span class='neutral'>      assembly {</span>
 188 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 189 |     | <span class='neutral'>        let f := shr(128, r)</span>
 190 |     | <span class='neutral'>        log_2 := or(log_2, shl(57, f))</span>
 191 |     | <span class='neutral'>        r := shr(f, r)</span>
 192 |     | <span class='neutral'>      }</span>
 193 |     | <span class='neutral'>      assembly {</span>
 194 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 195 |     | <span class='neutral'>        let f := shr(128, r)</span>
 196 |     | <span class='neutral'>        log_2 := or(log_2, shl(56, f))</span>
 197 |     | <span class='neutral'>        r := shr(f, r)</span>
 198 |     | <span class='neutral'>      }</span>
 199 |     | <span class='neutral'>      assembly {</span>
 200 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 201 |     | <span class='neutral'>        let f := shr(128, r)</span>
 202 |     | <span class='neutral'>        log_2 := or(log_2, shl(55, f))</span>
 203 |     | <span class='neutral'>        r := shr(f, r)</span>
 204 |     | <span class='neutral'>      }</span>
 205 |     | <span class='neutral'>      assembly {</span>
 206 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 207 |     | <span class='neutral'>        let f := shr(128, r)</span>
 208 |     | <span class='neutral'>        log_2 := or(log_2, shl(54, f))</span>
 209 |     | <span class='neutral'>        r := shr(f, r)</span>
 210 |     | <span class='neutral'>      }</span>
 211 |     | <span class='neutral'>      assembly {</span>
 212 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 213 |     | <span class='neutral'>        let f := shr(128, r)</span>
 214 |     | <span class='neutral'>        log_2 := or(log_2, shl(53, f))</span>
 215 |     | <span class='neutral'>        r := shr(f, r)</span>
 216 |     | <span class='neutral'>      }</span>
 217 |     | <span class='neutral'>      assembly {</span>
 218 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 219 |     | <span class='neutral'>        let f := shr(128, r)</span>
 220 |     | <span class='neutral'>        log_2 := or(log_2, shl(52, f))</span>
 221 |     | <span class='neutral'>        r := shr(f, r)</span>
 222 |     | <span class='neutral'>      }</span>
 223 |     | <span class='neutral'>      assembly {</span>
 224 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 225 |     | <span class='neutral'>        let f := shr(128, r)</span>
 226 |     | <span class='neutral'>        log_2 := or(log_2, shl(51, f))</span>
 227 |     | <span class='neutral'>        r := shr(f, r)</span>
 228 |     | <span class='neutral'>      }</span>
 229 |     | <span class='neutral'>      assembly {</span>
 230 |     | <span class='neutral'>        r := shr(127, mul(r, r))</span>
 231 |     | <span class='neutral'>        let f := shr(128, r)</span>
 232 |     | <span class='neutral'>        log_2 := or(log_2, shl(50, f))</span>
 233 |     | <span class='neutral'>      }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>      int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>      int24 tickLow = int24(</span>
 238 |     | <span class='neutral'>        (log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128</span>
 239 |     | <span class='neutral'>      );</span>
 240 |     | <span class='neutral'>      int24 tickHi = int24(</span>
 241 |     | <span class='neutral'>        (log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128</span>
 242 |     | <span class='neutral'>      );</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>      tick = tickLow == tickHi</span>
 245 |     | <span class='neutral'>        ? tickLow</span>
 246 |     | <span class='neutral'>        : getSqrtRatioAtTick(tickHi) &lt;= sqrtPriceX96</span>
 247 |     | <span class='neutral'>        ? tickHi</span>
 248 |     | <span class='neutral'>        : tickLow;</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'>  }</span>
 251 |     | <span class='neutral'>}</span>
 252 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/libraries/VaultAccount.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>struct VaultAccount {</span>
  5 |     | <span class='neutral'>    uint128 amount; // Total amount, analogous to market cap</span>
  6 |     | <span class='neutral'>    uint128 shares; // Total shares, analogous to shares outstanding</span>
  7 |     | <span class='neutral'>}</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @title VaultAccount Library</span>
 10 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto</span>
 11 |     | <span class='neutral'>/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations</span>
 12 |     | <span class='neutral'>/// @dev Uses uint128 to save on storage</span>
 13 |     | <span class='unexecuted'>library VaultAccountingLibrary {</span>
 14 |     | <span class='neutral'>    /// @notice Calculates the shares value in relationship to `amount` and `total`</span>
 15 |     | <span class='neutral'>    /// @dev Given an amount, return the appropriate number of shares</span>
 16 |     | <span class='unexecuted'>    function toShares(VaultAccount memory total, uint256 amount, bool roundUp) internal pure returns (uint256 shares) {</span>
 17 |     | <span class='unexecuted'>        if (total.amount == 0) {</span>
 18 |     | <span class='unexecuted'>            shares = amount;</span>
 19 |     | <span class='neutral'>        } else {</span>
 20 |     | <span class='unexecuted'>            shares = (amount * total.shares) / total.amount;</span>
 21 |     | <span class='unexecuted'>            if (roundUp &amp;&amp; (shares * total.amount) / total.shares &lt; amount) {</span>
 22 |     | <span class='unexecuted'>                shares = shares + 1;</span>
 23 |     | <span class='neutral'>            }</span>
 24 |     | <span class='neutral'>        }</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Calculates the amount value in relationship to `shares` and `total`</span>
 28 |     | <span class='neutral'>    /// @dev Given a number of shares, returns the appropriate amount</span>
 29 |     | <span class='neutral'>    function toAmount(VaultAccount memory total, uint256 shares, bool roundUp) internal pure returns (uint256 amount) {</span>
 30 |     | <span class='neutral'>        if (total.shares == 0) {</span>
 31 |     | <span class='neutral'>            amount = shares;</span>
 32 |     | <span class='neutral'>        } else {</span>
 33 |     | <span class='neutral'>            amount = (shares * total.amount) / total.shares;</span>
 34 |     | <span class='neutral'>            if (roundUp &amp;&amp; (amount * total.shares) / total.amount &lt; shares) {</span>
 35 |     | <span class='neutral'>                amount = amount + 1;</span>
 36 |     | <span class='neutral'>            }</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'>}</span>
 40 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeverageManager.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/utils/Context.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IDecentralizedIndex.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/IDexAdapter.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../interfaces/IFlashLoanRecipient.sol&#39;;</span>
  11 |     | <span class='neutral'>// import &#39;../interfaces/IIndexUtils.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../interfaces/IIndexUtils_LEGACY.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../interfaces/ILeverageManager.sol&#39;;</span>
  14 |     | <span class='neutral'>import { VaultAccount, VaultAccountingLibrary } from &#39;../libraries/VaultAccount.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;../AutoCompoundingPodLp.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./LeverageManagerAccessControl.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./LeveragePositions.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./LeveragePositionCustodian.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract LeverageManager is</span>
  21 |     | <span class='neutral'>  ILeverageManager,</span>
  22 |     | <span class='neutral'>  IFlashLoanRecipient,</span>
  23 |     | <span class='neutral'>  Context,</span>
  24 |     | <span class='neutral'>  LeverageManagerAccessControl</span>
  25 |     | <span class='neutral'>{</span>
  26 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  27 |     | <span class='neutral'>  using VaultAccountingLibrary for VaultAccount;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>  IIndexUtils_LEGACY public indexUtils;</span>
  30 |     | <span class='unexecuted'>  LeveragePositions public positionNFT;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>  uint16 public openFeePerc; // 1000 precision</span>
  33 |     | <span class='unexecuted'>  uint16 public closeFeePerc; // 1000 precision</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>  // positionId =&gt; position props</span>
  36 |     | <span class='unexecuted'>  mapping(uint256 =&gt; LeveragePositionProps) public positionProps;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>  event AddLeverage(uint256 indexed positionId, address indexed user);</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>  modifier onlyPositionOwner(uint256 _positionId) {</span>
  41 |     | <span class='unexecuted'>    require(positionNFT.ownerOf(_positionId) == _msgSender(), &#39;AUTH&#39;);</span>
  42 |     | <span class='unexecuted'>    _;</span>
  43 |     | <span class='neutral'>  }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>  bool _initialised;</span>
  46 |     | <span class='neutral'>  modifier workflow(bool _starting) {</span>
  47 |     | <span class='neutral'>    if (_starting) {</span>
  48 |     | <span class='unexecuted'>      require(!_initialised, &#39;W0&#39;);</span>
  49 |     | <span class='unexecuted'>      _initialised = true;</span>
  50 |     | <span class='neutral'>    } else {</span>
  51 |     | <span class='unexecuted'>      require(_initialised, &#39;W1&#39;);</span>
  52 |     | <span class='unexecuted'>      _initialised = false;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'>    _;</span>
  55 |     | <span class='neutral'>  }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>  constructor(</span>
  58 |     | <span class='neutral'>    string memory _positionName,</span>
  59 |     | <span class='neutral'>    string memory _positionSymbol,</span>
  60 |     | <span class='neutral'>    IIndexUtils_LEGACY _idxUtils</span>
  61 |     | <span class='neutral'>  ) {</span>
  62 |     | <span class='unexecuted'>    indexUtils = _idxUtils;</span>
  63 |     | <span class='unexecuted'>    positionNFT = new LeveragePositions(_positionName, _positionSymbol);</span>
  64 |     | <span class='neutral'>  }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>  /// @notice The ```initializePosition``` function initializes a new position and mints a new position NFT</span>
  67 |     | <span class='neutral'>  /// @param _pod The pod to leverage against for the new position</span>
  68 |     | <span class='neutral'>  /// @param _recipient User to receive the position NFT</span>
  69 |     | <span class='neutral'>  /// @param _selfLendingPod Optional self lending pod, use address(0) if not applicable</span>
  70 |     | <span class='unexecuted'>  function initializePosition(</span>
  71 |     | <span class='neutral'>    address _pod,</span>
  72 |     | <span class='neutral'>    address _recipient,</span>
  73 |     | <span class='neutral'>    address _selfLendingPod</span>
  74 |     | <span class='neutral'>  ) external override {</span>
  75 |     | <span class='unexecuted'>    _initializePosition(_pod, _recipient, _selfLendingPod);</span>
  76 |     | <span class='neutral'>  }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>  /// @notice The ```addLeverage``` function adds leverage to a position (or creates a new one and adds leverage)</span>
  79 |     | <span class='neutral'>  /// @param _positionId The NFT ID of an existing position to add leverage to, or 0 if a new position should be created</span>
  80 |     | <span class='neutral'>  /// @param _pod The pod to leverage against for the position</span>
  81 |     | <span class='neutral'>  /// @param _podAmount Amount of pTKN to use to leverage against</span>
  82 |     | <span class='neutral'>  /// @param _pairedLpDesired Number of pairedLpTkn for the pod to use to add LP for the new position</span>
  83 |     | <span class='neutral'>  /// @param _pairedLpAmtMin Minimum number of pairedLpTkn for LP, slippage</span>
  84 |     | <span class='neutral'>  /// @param _overrideBorrowAmt Override amount to borrow from the lending pair, only matters if max LTV is &gt;50% on the lending pair</span>
  85 |     | <span class='neutral'>  /// @param _slippage Slippage for the LP execution with 1000 precision (1000 == 100%)</span>
  86 |     | <span class='neutral'>  /// @param _deadline LP deadline for the UniswapV2 implementation</span>
  87 |     | <span class='neutral'>  /// @param _selfLendingPairPod Advanced implementation parameter that is a pod to wrap pairedLpTkn into before adding leverage, or address(0) if not applicable</span>
  88 |     | <span class='unexecuted'>  function addLeverage(</span>
  89 |     | <span class='neutral'>    uint256 _positionId,</span>
  90 |     | <span class='neutral'>    address _pod,</span>
  91 |     | <span class='neutral'>    uint256 _podAmount,</span>
  92 |     | <span class='neutral'>    uint256 _pairedLpDesired,</span>
  93 |     | <span class='neutral'>    uint256 _pairedLpAmtMin,</span>
  94 |     | <span class='neutral'>    uint256 _overrideBorrowAmt,</span>
  95 |     | <span class='neutral'>    uint256 _slippage,</span>
  96 |     | <span class='neutral'>    uint256 _deadline,</span>
  97 |     | <span class='neutral'>    address _selfLendingPairPod</span>
  98 |     | <span class='unexecuted'>  ) external override workflow(true) {</span>
  99 |     | <span class='unexecuted'>    address _sender = _msgSender();</span>
 100 |     | <span class='unexecuted'>    if (_positionId == 0) {</span>
 101 |     | <span class='unexecuted'>      _positionId = _initializePosition(_pod, _sender, _selfLendingPairPod);</span>
 102 |     | <span class='unexecuted'>    } else {</span>
 103 |     | <span class='unexecuted'>      address _owner = positionNFT.ownerOf(_positionId);</span>
 104 |     | <span class='unexecuted'>      address _approvedAddress = positionNFT.getApproved(_positionId);</span>
 105 |     | <span class='unexecuted'>      bool _isApprovedAll = positionNFT.isApprovedForAll(_owner, _sender);</span>
 106 |     | <span class='unexecuted'>      require(</span>
 107 |     | <span class='unexecuted'>        _owner == _sender || _approvedAddress == _sender || _isApprovedAll,</span>
 108 |     | <span class='neutral'>        &#39;AUTH&#39;</span>
 109 |     | <span class='neutral'>      );</span>
 110 |     | <span class='unexecuted'>      _pod = positionProps[_positionId].pod;</span>
 111 |     | <span class='unexecuted'>      require(_pod != address(0), &#39;PV&#39;);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='unexecuted'>    require(flashSource[_pod] != address(0), &#39;FSV&#39;);</span>
 114 |     | <span class='unexecuted'>    require(lendingPairs[_pod] != address(0), &#39;LVP&#39;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>    IERC20(_pod).safeTransferFrom(_sender, address(this), _podAmount);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    // if additional fees required for flash source, handle that here</span>
 119 |     | <span class='unexecuted'>    _processExtraFlashLoanPayment(_pod, _sender);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    bytes memory _noop;</span>
 122 |     | <span class='unexecuted'>    bytes memory _leverageData = abi.encode(</span>
 123 |     | <span class='unexecuted'>      LeverageFlashProps({</span>
 124 |     | <span class='unexecuted'>        method: FlashCallbackMethod.ADD,</span>
 125 |     | <span class='unexecuted'>        positionId: _positionId,</span>
 126 |     | <span class='unexecuted'>        user: _sender,</span>
 127 |     | <span class='unexecuted'>        pod: _pod,</span>
 128 |     | <span class='unexecuted'>        podAmount: _podAmount,</span>
 129 |     | <span class='unexecuted'>        pairedLpDesired: _pairedLpDesired,</span>
 130 |     | <span class='unexecuted'>        pairedLpAmtMin: _pairedLpAmtMin,</span>
 131 |     | <span class='unexecuted'>        overrideBorrowAmt: _overrideBorrowAmt,</span>
 132 |     | <span class='unexecuted'>        slippage: _slippage,</span>
 133 |     | <span class='unexecuted'>        deadline: _deadline,</span>
 134 |     | <span class='unexecuted'>        selfLendingPairPod: _selfLendingPairPod</span>
 135 |     | <span class='neutral'>      }),</span>
 136 |     | <span class='unexecuted'>      _noop</span>
 137 |     | <span class='neutral'>    );</span>
 138 |     | <span class='unexecuted'>    IFlashLoanSource(flashSource[_pod]).flash(</span>
 139 |     | <span class='unexecuted'>      _getBorrowTknForPod(_pod),</span>
 140 |     | <span class='unexecuted'>      _pairedLpDesired,</span>
 141 |     | <span class='unexecuted'>      address(this),</span>
 142 |     | <span class='unexecuted'>      _leverageData</span>
 143 |     | <span class='neutral'>    );</span>
 144 |     | <span class='neutral'>  }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>  /// @notice The ```removeLeverage``` function removes leverage from a position</span>
 147 |     | <span class='neutral'>  /// @param _positionId The NFT ID for the position</span>
 148 |     | <span class='neutral'>  /// @param _borrowAssetAmt Amount of borrowed assets to flash loan and use pay back and remove leverage</span>
 149 |     | <span class='neutral'>  /// @param _collateralAssetRemoveAmt Amount of collateral asset to remvoe from the position</span>
 150 |     | <span class='neutral'>  /// @param _podAmtMin Minimum amount of pTKN to receive on remove LP transaction (slippage)</span>
 151 |     | <span class='neutral'>  /// @param _pairedAssetAmtMin Minimum amount of pairedLpTkn to receive on remove LP transaction (slippage)</span>
 152 |     | <span class='neutral'>  /// @param _dexAdapter Adapter to use to optionally swap pod token into borrow token if not received enough to pay back flash loan</span>
 153 |     | <span class='neutral'>  /// @param _userProvidedDebtAmtMax Amt of borrow token a user will allow to transfer from their wallet to pay back flash loan</span>
 154 |     | <span class='unexecuted'>  function removeLeverage(</span>
 155 |     | <span class='neutral'>    uint256 _positionId,</span>
 156 |     | <span class='neutral'>    uint256 _borrowAssetAmt,</span>
 157 |     | <span class='neutral'>    uint256 _collateralAssetRemoveAmt,</span>
 158 |     | <span class='neutral'>    uint256 _podAmtMin,</span>
 159 |     | <span class='neutral'>    uint256 _pairedAssetAmtMin,</span>
 160 |     | <span class='neutral'>    address _dexAdapter,</span>
 161 |     | <span class='neutral'>    uint256 _userProvidedDebtAmtMax</span>
 162 |     | <span class='unexecuted'>  ) external override onlyPositionOwner(_positionId) workflow(true) {</span>
 163 |     | <span class='unexecuted'>    LeveragePositionProps memory _props = positionProps[_positionId];</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    // if additional fees required for flash source, handle that here</span>
 166 |     | <span class='unexecuted'>    _processExtraFlashLoanPayment(_props.pod, _msgSender());</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>    address _borrowTkn = _getBorrowTknForPod(_props.pod);</span>
 169 |     | <span class='unexecuted'>    uint256 _borrowSharesToRepay = IFraxlendPair(lendingPairs[_props.pod])</span>
 170 |     | <span class='neutral'>      .totalBorrow()</span>
 171 |     | <span class='unexecuted'>      .toShares(_borrowAssetAmt, true);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    // needed to repay flash loaned asset in lending pair</span>
 174 |     | <span class='neutral'>    // before removing collateral and unwinding</span>
 175 |     | <span class='unexecuted'>    IERC20(_borrowTkn).safeIncreaseAllowance(</span>
 176 |     | <span class='unexecuted'>      lendingPairs[_props.pod],</span>
 177 |     | <span class='unexecuted'>      _borrowAssetAmt</span>
 178 |     | <span class='neutral'>    );</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    LeverageFlashProps memory _position;</span>
 181 |     | <span class='unexecuted'>    _position.method = FlashCallbackMethod.REMOVE;</span>
 182 |     | <span class='unexecuted'>    _position.positionId = _positionId;</span>
 183 |     | <span class='unexecuted'>    _position.user = _msgSender();</span>
 184 |     | <span class='unexecuted'>    _position.pod = _props.pod;</span>
 185 |     | <span class='unexecuted'>    bytes memory _additionalInfo = abi.encode(</span>
 186 |     | <span class='neutral'>      _borrowSharesToRepay,</span>
 187 |     | <span class='neutral'>      _collateralAssetRemoveAmt,</span>
 188 |     | <span class='neutral'>      _podAmtMin,</span>
 189 |     | <span class='neutral'>      _pairedAssetAmtMin,</span>
 190 |     | <span class='neutral'>      _dexAdapter,</span>
 191 |     | <span class='neutral'>      _userProvidedDebtAmtMax</span>
 192 |     | <span class='neutral'>    );</span>
 193 |     | <span class='unexecuted'>    IFlashLoanSource(flashSource[_props.pod]).flash(</span>
 194 |     | <span class='unexecuted'>      _borrowTkn,</span>
 195 |     | <span class='unexecuted'>      _borrowAssetAmt,</span>
 196 |     | <span class='unexecuted'>      address(this),</span>
 197 |     | <span class='unexecuted'>      abi.encode(_position, _additionalInfo)</span>
 198 |     | <span class='neutral'>    );</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>  /// @notice The ```withdrawAssets``` function allows a position owner to withdraw any assets in the position custodian</span>
 202 |     | <span class='neutral'>  /// @param _positionId The NFT ID for the position</span>
 203 |     | <span class='neutral'>  /// @param _token The token to withdraw assets from</span>
 204 |     | <span class='neutral'>  /// @param _recipient Where the received assets should go</span>
 205 |     | <span class='neutral'>  /// @param _amount How much to withdraw</span>
 206 |     | <span class='unexecuted'>  function withdrawAssets(</span>
 207 |     | <span class='neutral'>    uint256 _positionId,</span>
 208 |     | <span class='neutral'>    address _token,</span>
 209 |     | <span class='neutral'>    address _recipient,</span>
 210 |     | <span class='neutral'>    uint256 _amount</span>
 211 |     | <span class='unexecuted'>  ) external onlyPositionOwner(_positionId) {</span>
 212 |     | <span class='unexecuted'>    LeveragePositionCustodian(positionProps[_positionId].custodian).withdraw(</span>
 213 |     | <span class='neutral'>      _token,</span>
 214 |     | <span class='neutral'>      _recipient,</span>
 215 |     | <span class='neutral'>      _amount</span>
 216 |     | <span class='neutral'>    );</span>
 217 |     | <span class='neutral'>  }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>  /// @notice The ```callback``` function can only be called within the addLeverage or removeLeverage workflow,</span>
 220 |     | <span class='neutral'>  /// @notice and is called by the flash source implementation used to borrow assets to initiate adding or removing lev</span>
 221 |     | <span class='neutral'>  /// @param _userData Config/info to unpack and extract individual pieces when adding/removing leverage, see addLeverage and removeLeverage</span>
 222 |     | <span class='unexecuted'>  function callback(bytes memory _userData) external override workflow(false) {</span>
 223 |     | <span class='unexecuted'>    IFlashLoanSource.FlashData memory _d = abi.decode(</span>
 224 |     | <span class='unexecuted'>      _userData,</span>
 225 |     | <span class='neutral'>      (IFlashLoanSource.FlashData)</span>
 226 |     | <span class='neutral'>    );</span>
 227 |     | <span class='unexecuted'>    (LeverageFlashProps memory _posProps, ) = abi.decode(</span>
 228 |     | <span class='unexecuted'>      _d.data,</span>
 229 |     | <span class='neutral'>      (LeverageFlashProps, bytes)</span>
 230 |     | <span class='neutral'>    );</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='unexecuted'>    require(flashSource[_posProps.pod] == _msgSender(), &#39;AUTH&#39;);</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='unexecuted'>    if (_posProps.method == FlashCallbackMethod.ADD) {</span>
 235 |     | <span class='unexecuted'>      uint256 _podRefundAmt = _addLeverage(_userData);</span>
 236 |     | <span class='unexecuted'>      if (_podRefundAmt &gt; 0) {</span>
 237 |     | <span class='unexecuted'>        IERC20(_posProps.pod).safeTransfer(_posProps.user, _podRefundAmt);</span>
 238 |     | <span class='neutral'>      }</span>
 239 |     | <span class='unexecuted'>    } else if (_posProps.method == FlashCallbackMethod.REMOVE) {</span>
 240 |     | <span class='unexecuted'>      (uint256 _podAmtToUser, uint256 _pairedLpToUser) = _removeLeverage(</span>
 241 |     | <span class='unexecuted'>        _userData</span>
 242 |     | <span class='neutral'>      );</span>
 243 |     | <span class='unexecuted'>      if (_podAmtToUser &gt; 0) {</span>
 244 |     | <span class='neutral'>        // if there&#39;s a close fee send returned pod tokens for fee to protocol</span>
 245 |     | <span class='unexecuted'>        if (closeFeePerc &gt; 0) {</span>
 246 |     | <span class='unexecuted'>          uint256 _closeFeeAmt = (_podAmtToUser * closeFeePerc) / 1000;</span>
 247 |     | <span class='unexecuted'>          IERC20(_posProps.pod).safeTransfer(owner(), _closeFeeAmt);</span>
 248 |     | <span class='unexecuted'>          _podAmtToUser -= _closeFeeAmt;</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='unexecuted'>        IERC20(_posProps.pod).safeTransfer(_posProps.user, _podAmtToUser);</span>
 251 |     | <span class='neutral'>      }</span>
 252 |     | <span class='unexecuted'>      if (_pairedLpToUser &gt; 0) {</span>
 253 |     | <span class='unexecuted'>        IERC20(IDecentralizedIndex(_posProps.pod).PAIRED_LP_TOKEN())</span>
 254 |     | <span class='unexecuted'>          .safeTransfer(_posProps.user, _pairedLpToUser);</span>
 255 |     | <span class='neutral'>      }</span>
 256 |     | <span class='neutral'>    } else {</span>
 257 |     | <span class='unexecuted'>      require(false, &#39;NI&#39;);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'>  }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='unexecuted'>  function _initializePosition(</span>
 262 |     | <span class='neutral'>    address _pod,</span>
 263 |     | <span class='neutral'>    address _recipient,</span>
 264 |     | <span class='neutral'>    address _selfLendingPod</span>
 265 |     | <span class='unexecuted'>  ) internal returns (uint256 _positionId) {</span>
 266 |     | <span class='unexecuted'>    require(lendingPairs[_pod] != address(0), &#39;LVP&#39;);</span>
 267 |     | <span class='unexecuted'>    _positionId = positionNFT.mint(_recipient);</span>
 268 |     | <span class='unexecuted'>    LeveragePositionCustodian _custodian = new LeveragePositionCustodian();</span>
 269 |     | <span class='unexecuted'>    positionProps[_positionId] = LeveragePositionProps({</span>
 270 |     | <span class='neutral'>      pod: _pod,</span>
 271 |     | <span class='unexecuted'>      lendingPair: lendingPairs[_pod],</span>
 272 |     | <span class='neutral'>      custodian: address(_custodian),</span>
 273 |     | <span class='neutral'>      selfLendingPod: _selfLendingPod</span>
 274 |     | <span class='neutral'>    });</span>
 275 |     | <span class='neutral'>  }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>  function _processExtraFlashLoanPayment(address _pod, address _user) internal {</span>
 278 |     | <span class='unexecuted'>    IFlashLoanSource _flashLoanSource = IFlashLoanSource(flashSource[_pod]);</span>
 279 |     | <span class='unexecuted'>    uint256 _flashPaymentAmount = _flashLoanSource.paymentAmount();</span>
 280 |     | <span class='unexecuted'>    if (_flashPaymentAmount &gt; 0) {</span>
 281 |     | <span class='unexecuted'>      address _paymentAsset = _flashLoanSource.paymentToken();</span>
 282 |     | <span class='unexecuted'>      IERC20(_paymentAsset).safeTransferFrom(</span>
 283 |     | <span class='unexecuted'>        _user,</span>
 284 |     | <span class='unexecuted'>        address(this),</span>
 285 |     | <span class='unexecuted'>        _flashPaymentAmount</span>
 286 |     | <span class='neutral'>      );</span>
 287 |     | <span class='unexecuted'>      IERC20(_paymentAsset).safeIncreaseAllowance(</span>
 288 |     | <span class='unexecuted'>        flashSource[_pod],</span>
 289 |     | <span class='unexecuted'>        _flashPaymentAmount</span>
 290 |     | <span class='neutral'>      );</span>
 291 |     | <span class='neutral'>    }</span>
 292 |     | <span class='neutral'>  }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>  function _addLeverage(</span>
 295 |     | <span class='neutral'>    bytes memory _data</span>
 296 |     | <span class='unexecuted'>  ) internal returns (uint256 _refundAmt) {</span>
 297 |     | <span class='unexecuted'>    IFlashLoanSource.FlashData memory _d = abi.decode(</span>
 298 |     | <span class='unexecuted'>      _data,</span>
 299 |     | <span class='neutral'>      (IFlashLoanSource.FlashData)</span>
 300 |     | <span class='neutral'>    );</span>
 301 |     | <span class='unexecuted'>    (LeverageFlashProps memory _props, ) = abi.decode(</span>
 302 |     | <span class='unexecuted'>      _d.data,</span>
 303 |     | <span class='neutral'>      (LeverageFlashProps, bytes)</span>
 304 |     | <span class='neutral'>    );</span>
 305 |     | <span class='unexecuted'>    (uint256 _aspTknCollateralBal, uint256 _podAmountUsed, ) = _lpAndStakeInPod(</span>
 306 |     | <span class='unexecuted'>      IDecentralizedIndex(_props.pod).lpStakingPool(),</span>
 307 |     | <span class='unexecuted'>      _d,</span>
 308 |     | <span class='unexecuted'>      _props</span>
 309 |     | <span class='neutral'>    );</span>
 310 |     | <span class='unexecuted'>    _refundAmt = _props.podAmount - _podAmountUsed;</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    // if there&#39;s an open fee send aspTKN generated to protocol</span>
 313 |     | <span class='unexecuted'>    address _aspTkn = _getAspTkn(_props.pod);</span>
 314 |     | <span class='unexecuted'>    if (openFeePerc &gt; 0) {</span>
 315 |     | <span class='unexecuted'>      uint256 _openFeeAmt = (_aspTknCollateralBal * openFeePerc) / 1000;</span>
 316 |     | <span class='unexecuted'>      IERC20(_aspTkn).safeTransfer(owner(), _openFeeAmt);</span>
 317 |     | <span class='unexecuted'>      _aspTknCollateralBal -= _openFeeAmt;</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>    IERC20(_aspTkn).safeTransfer(</span>
 321 |     | <span class='unexecuted'>      positionProps[_props.positionId].custodian,</span>
 322 |     | <span class='unexecuted'>      _aspTknCollateralBal</span>
 323 |     | <span class='neutral'>    );</span>
 324 |     | <span class='unexecuted'>    LeveragePositionCustodian(positionProps[_props.positionId].custodian)</span>
 325 |     | <span class='neutral'>      .borrowAsset(</span>
 326 |     | <span class='unexecuted'>        lendingPairs[_props.pod],</span>
 327 |     | <span class='unexecuted'>        _props.overrideBorrowAmt &gt; _props.pairedLpDesired</span>
 328 |     | <span class='unexecuted'>          ? _props.overrideBorrowAmt</span>
 329 |     | <span class='unexecuted'>          : _props.pairedLpDesired,</span>
 330 |     | <span class='neutral'>        _aspTknCollateralBal,</span>
 331 |     | <span class='unexecuted'>        address(this)</span>
 332 |     | <span class='neutral'>      );</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    // pay back flash loan and send remaining to borrower</span>
 335 |     | <span class='unexecuted'>    uint256 _flashPaybackAmt = _d.amount + _d.fee;</span>
 336 |     | <span class='unexecuted'>    IERC20(_d.token).safeTransfer(</span>
 337 |     | <span class='unexecuted'>      IFlashLoanSource(flashSource[_props.pod]).source(),</span>
 338 |     | <span class='unexecuted'>      _flashPaybackAmt</span>
 339 |     | <span class='neutral'>    );</span>
 340 |     | <span class='unexecuted'>    uint256 _remaining = IERC20(_d.token).balanceOf(address(this));</span>
 341 |     | <span class='unexecuted'>    if (_remaining != 0) {</span>
 342 |     | <span class='unexecuted'>      IERC20(_d.token).safeTransfer(_props.user, _remaining);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='unexecuted'>    emit AddLeverage(_props.positionId, _props.user);</span>
 345 |     | <span class='neutral'>  }</span>
 346 |     | <span class='neutral'></span>
 347 |     | <span class='unexecuted'>  function _removeLeverage(</span>
 348 |     | <span class='neutral'>    bytes memory _userData</span>
 349 |     | <span class='unexecuted'>  ) internal returns (uint256 _podAmtRemaining, uint256 _borrowAmtRemaining) {</span>
 350 |     | <span class='unexecuted'>    IFlashLoanSource.FlashData memory _d = abi.decode(</span>
 351 |     | <span class='unexecuted'>      _userData,</span>
 352 |     | <span class='neutral'>      (IFlashLoanSource.FlashData)</span>
 353 |     | <span class='neutral'>    );</span>
 354 |     | <span class='unexecuted'>    (LeverageFlashProps memory _props, bytes memory _additionalInfo) = abi</span>
 355 |     | <span class='unexecuted'>      .decode(_d.data, (LeverageFlashProps, bytes));</span>
 356 |     | <span class='unexecuted'>    (</span>
 357 |     | <span class='unexecuted'>      uint256 _borrowSharesToRepay,</span>
 358 |     | <span class='unexecuted'>      uint256 _collateralAssetRemoveAmt,</span>
 359 |     | <span class='unexecuted'>      uint256 _podAmtMin,</span>
 360 |     | <span class='unexecuted'>      uint256 _pairedAssetAmtMin,</span>
 361 |     | <span class='unexecuted'>      address _dexAdapter,</span>
 362 |     | <span class='unexecuted'>      uint256 _userProvidedDebtAmtMax</span>
 363 |     | <span class='unexecuted'>    ) = abi.decode(</span>
 364 |     | <span class='unexecuted'>        _additionalInfo,</span>
 365 |     | <span class='neutral'>        (uint256, uint256, uint256, uint256, address, uint256)</span>
 366 |     | <span class='neutral'>      );</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='unexecuted'>    address _lendingPair = lendingPairs[_props.pod];</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='neutral'>    // allowance increases for _borrowAssetAmt prior to flash loaning asset</span>
 371 |     | <span class='unexecuted'>    IFraxlendPair(_lendingPair).repayAsset(</span>
 372 |     | <span class='unexecuted'>      _borrowSharesToRepay,</span>
 373 |     | <span class='unexecuted'>      positionProps[_props.positionId].custodian</span>
 374 |     | <span class='neutral'>    );</span>
 375 |     | <span class='unexecuted'>    LeveragePositionCustodian(positionProps[_props.positionId].custodian)</span>
 376 |     | <span class='unexecuted'>      .removeCollateral(_lendingPair, _collateralAssetRemoveAmt, address(this));</span>
 377 |     | <span class='unexecuted'>    (uint256 _podAmtReceived, uint256 _pairedAmtReceived) = _unstakeAndRemoveLP(</span>
 378 |     | <span class='unexecuted'>      _props.pod,</span>
 379 |     | <span class='unexecuted'>      _collateralAssetRemoveAmt,</span>
 380 |     | <span class='unexecuted'>      _podAmtMin,</span>
 381 |     | <span class='unexecuted'>      _pairedAssetAmtMin</span>
 382 |     | <span class='neutral'>    );</span>
 383 |     | <span class='unexecuted'>    _podAmtRemaining = _podAmtReceived;</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    // redeem borrow asset from lending pair for self lending positions</span>
 386 |     | <span class='unexecuted'>    if (_isSelfLendingAndOrPodded(_props.pod)) {</span>
 387 |     | <span class='neutral'>      // unwrap from self lending pod for lending pair asset</span>
 388 |     | <span class='unexecuted'>      if (positionProps[_props.positionId].selfLendingPod != address(0)) {</span>
 389 |     | <span class='unexecuted'>        _pairedAmtReceived = _debondFromSelfLendingPod(</span>
 390 |     | <span class='unexecuted'>          positionProps[_props.positionId].selfLendingPod,</span>
 391 |     | <span class='unexecuted'>          _pairedAmtReceived</span>
 392 |     | <span class='neutral'>        );</span>
 393 |     | <span class='neutral'>      }</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='unexecuted'>      IFraxlendPair(_lendingPair).redeem(</span>
 396 |     | <span class='neutral'>        _pairedAmtReceived,</span>
 397 |     | <span class='unexecuted'>        address(this),</span>
 398 |     | <span class='neutral'>        address(this)</span>
 399 |     | <span class='neutral'>      );</span>
 400 |     | <span class='unexecuted'>      _pairedAmtReceived = IERC20(_d.token).balanceOf(address(this));</span>
 401 |     | <span class='neutral'>    }</span>
 402 |     | <span class='neutral'></span>
 403 |     | <span class='neutral'>    // pay back flash loan and send remaining to borrower</span>
 404 |     | <span class='unexecuted'>    uint256 _repayAmount = _d.amount + _d.fee;</span>
 405 |     | <span class='unexecuted'>    if (_pairedAmtReceived &lt; _repayAmount) {</span>
 406 |     | <span class='unexecuted'>      _podAmtRemaining = _acquireBorrowTokenForRepayment(</span>
 407 |     | <span class='unexecuted'>        _props.pod,</span>
 408 |     | <span class='unexecuted'>        _props.user,</span>
 409 |     | <span class='unexecuted'>        _d.token,</span>
 410 |     | <span class='unexecuted'>        _dexAdapter,</span>
 411 |     | <span class='unexecuted'>        _repayAmount,</span>
 412 |     | <span class='unexecuted'>        _pairedAmtReceived,</span>
 413 |     | <span class='unexecuted'>        _podAmtReceived,</span>
 414 |     | <span class='unexecuted'>        _userProvidedDebtAmtMax</span>
 415 |     | <span class='neutral'>      );</span>
 416 |     | <span class='neutral'>    }</span>
 417 |     | <span class='unexecuted'>    IERC20(_d.token).safeTransfer(</span>
 418 |     | <span class='unexecuted'>      IFlashLoanSource(flashSource[_props.pod]).source(),</span>
 419 |     | <span class='unexecuted'>      _repayAmount</span>
 420 |     | <span class='neutral'>    );</span>
 421 |     | <span class='unexecuted'>    _borrowAmtRemaining = _pairedAmtReceived &gt; _repayAmount</span>
 422 |     | <span class='unexecuted'>      ? _pairedAmtReceived - _repayAmount</span>
 423 |     | <span class='unexecuted'>      : 0;</span>
 424 |     | <span class='neutral'>  }</span>
 425 |     | <span class='neutral'></span>
 426 |     | <span class='unexecuted'>  function _debondFromSelfLendingPod(</span>
 427 |     | <span class='neutral'>    address _pod,</span>
 428 |     | <span class='neutral'>    uint256 _amount</span>
 429 |     | <span class='unexecuted'>  ) internal returns (uint256 _amtOut) {</span>
 430 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[]</span>
 431 |     | <span class='unexecuted'>      memory _podAssets = IDecentralizedIndex(_pod).getAllAssets();</span>
 432 |     | <span class='unexecuted'>    address[] memory _tokens = new address[](1);</span>
 433 |     | <span class='unexecuted'>    uint8[] memory _percentages = new uint8[](1);</span>
 434 |     | <span class='unexecuted'>    _tokens[0] = _podAssets[0].token;</span>
 435 |     | <span class='unexecuted'>    _percentages[0] = 100;</span>
 436 |     | <span class='unexecuted'>    IDecentralizedIndex(_pod).debond(_amount, _tokens, _percentages);</span>
 437 |     | <span class='unexecuted'>    _amtOut = IERC20(_tokens[0]).balanceOf(address(this));</span>
 438 |     | <span class='neutral'>  }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='unexecuted'>  function _acquireBorrowTokenForRepayment(</span>
 441 |     | <span class='neutral'>    address _pod,</span>
 442 |     | <span class='neutral'>    address _user,</span>
 443 |     | <span class='neutral'>    address _borrowToken,</span>
 444 |     | <span class='neutral'>    address _dexAdapter,</span>
 445 |     | <span class='neutral'>    uint256 _repayAmount,</span>
 446 |     | <span class='neutral'>    uint256 _pairedAmtReceived,</span>
 447 |     | <span class='neutral'>    uint256 _podAmtReceived,</span>
 448 |     | <span class='neutral'>    uint256 _userProvidedDebtAmtMax</span>
 449 |     | <span class='unexecuted'>  ) internal returns (uint256 _podAmtRemaining) {</span>
 450 |     | <span class='unexecuted'>    _podAmtRemaining = _podAmtReceived;</span>
 451 |     | <span class='unexecuted'>    uint256 _borrowNeeded = _repayAmount - _pairedAmtReceived;</span>
 452 |     | <span class='neutral'>    uint256 _borrowAmtNeededToSwap = _borrowNeeded;</span>
 453 |     | <span class='unexecuted'>    if (_userProvidedDebtAmtMax &gt; 0) {</span>
 454 |     | <span class='unexecuted'>      uint256 _borrowAmtFromUser = _userProvidedDebtAmtMax &gt;= _borrowNeeded</span>
 455 |     | <span class='unexecuted'>        ? _borrowNeeded</span>
 456 |     | <span class='unexecuted'>        : _userProvidedDebtAmtMax;</span>
 457 |     | <span class='unexecuted'>      _borrowAmtNeededToSwap -= _borrowAmtFromUser;</span>
 458 |     | <span class='unexecuted'>      IERC20(_borrowToken).safeTransferFrom(</span>
 459 |     | <span class='unexecuted'>        _user,</span>
 460 |     | <span class='unexecuted'>        address(this),</span>
 461 |     | <span class='unexecuted'>        _borrowAmtFromUser</span>
 462 |     | <span class='neutral'>      );</span>
 463 |     | <span class='neutral'>    }</span>
 464 |     | <span class='unexecuted'>    if (_borrowAmtNeededToSwap &gt; 0) {</span>
 465 |     | <span class='neutral'>      // sell pod token into LP for enough borrow token to get enough to repay</span>
 466 |     | <span class='unexecuted'>      _podAmtRemaining = _swapPodForBorrowToken(</span>
 467 |     | <span class='unexecuted'>        IDexAdapter(_dexAdapter),</span>
 468 |     | <span class='unexecuted'>        _pod,</span>
 469 |     | <span class='unexecuted'>        _borrowToken,</span>
 470 |     | <span class='unexecuted'>        _podAmtReceived,</span>
 471 |     | <span class='unexecuted'>        _borrowAmtNeededToSwap</span>
 472 |     | <span class='neutral'>      );</span>
 473 |     | <span class='neutral'>    }</span>
 474 |     | <span class='neutral'>  }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='unexecuted'>  function _swapPodForBorrowToken(</span>
 477 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
 478 |     | <span class='neutral'>    address _sourceToken,</span>
 479 |     | <span class='neutral'>    address _targetToken,</span>
 480 |     | <span class='neutral'>    uint256 _sourceAmt,</span>
 481 |     | <span class='neutral'>    uint256 _targetNeededAmt</span>
 482 |     | <span class='unexecuted'>  ) internal returns (uint256 _podRemainingAmt) {</span>
 483 |     | <span class='unexecuted'>    uint256 _balBefore = IERC20(_sourceToken).balanceOf(address(this));</span>
 484 |     | <span class='unexecuted'>    IERC20(_sourceToken).safeIncreaseAllowance(</span>
 485 |     | <span class='unexecuted'>      address(_dexAdapter),</span>
 486 |     | <span class='unexecuted'>      _sourceAmt</span>
 487 |     | <span class='neutral'>    );</span>
 488 |     | <span class='unexecuted'>    _dexAdapter.swapV2SingleExactOut(</span>
 489 |     | <span class='neutral'>      _sourceToken,</span>
 490 |     | <span class='neutral'>      _targetToken,</span>
 491 |     | <span class='neutral'>      _sourceAmt,</span>
 492 |     | <span class='neutral'>      _targetNeededAmt,</span>
 493 |     | <span class='unexecuted'>      address(this)</span>
 494 |     | <span class='neutral'>    );</span>
 495 |     | <span class='unexecuted'>    _podRemainingAmt =</span>
 496 |     | <span class='unexecuted'>      _sourceAmt -</span>
 497 |     | <span class='unexecuted'>      (_balBefore - IERC20(_sourceToken).balanceOf(address(this)));</span>
 498 |     | <span class='neutral'>  }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='unexecuted'>  function _lpAndStakeInPod(</span>
 501 |     | <span class='neutral'>    address _spTKN,</span>
 502 |     | <span class='neutral'>    IFlashLoanSource.FlashData memory _d,</span>
 503 |     | <span class='neutral'>    LeverageFlashProps memory _props</span>
 504 |     | <span class='neutral'>  )</span>
 505 |     | <span class='neutral'>    internal</span>
 506 |     | <span class='unexecuted'>    returns (uint256 _newAspTkns, uint256 _podAmountUsed, uint256 _pairedLpUsed)</span>
 507 |     | <span class='unexecuted'>  {</span>
 508 |     | <span class='unexecuted'>    (address _pairedLpForPod, uint256 _pairedLpAmt) = _getPairedTknAndAmt(</span>
 509 |     | <span class='unexecuted'>      _props.pod,</span>
 510 |     | <span class='unexecuted'>      _d.token,</span>
 511 |     | <span class='unexecuted'>      _d.amount,</span>
 512 |     | <span class='unexecuted'>      _props.selfLendingPairPod</span>
 513 |     | <span class='neutral'>    );</span>
 514 |     | <span class='unexecuted'>    uint256 _podBalBefore = IERC20(_props.pod).balanceOf(address(this));</span>
 515 |     | <span class='unexecuted'>    uint256 _pairedLpBalBefore = IERC20(_pairedLpForPod).balanceOf(</span>
 516 |     | <span class='unexecuted'>      address(this)</span>
 517 |     | <span class='neutral'>    );</span>
 518 |     | <span class='unexecuted'>    IERC20(_props.pod).safeIncreaseAllowance(</span>
 519 |     | <span class='unexecuted'>      address(indexUtils),</span>
 520 |     | <span class='unexecuted'>      _props.podAmount</span>
 521 |     | <span class='neutral'>    );</span>
 522 |     | <span class='unexecuted'>    IERC20(_pairedLpForPod).safeIncreaseAllowance(</span>
 523 |     | <span class='unexecuted'>      address(indexUtils),</span>
 524 |     | <span class='unexecuted'>      _pairedLpAmt</span>
 525 |     | <span class='neutral'>    );</span>
 526 |     | <span class='unexecuted'>    indexUtils.addLPAndStake(</span>
 527 |     | <span class='unexecuted'>      IDecentralizedIndex(_props.pod),</span>
 528 |     | <span class='unexecuted'>      _props.podAmount,</span>
 529 |     | <span class='neutral'>      _pairedLpForPod,</span>
 530 |     | <span class='neutral'>      _pairedLpAmt,</span>
 531 |     | <span class='unexecuted'>      _props.pairedLpAmtMin,</span>
 532 |     | <span class='unexecuted'>      _props.slippage,</span>
 533 |     | <span class='unexecuted'>      _props.deadline</span>
 534 |     | <span class='neutral'>    );</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='unexecuted'>    address _aspTkn = _getAspTkn(_props.pod);</span>
 537 |     | <span class='unexecuted'>    uint256 _stakingBal = IERC20(_spTKN).balanceOf(address(this));</span>
 538 |     | <span class='unexecuted'>    IERC20(_spTKN).safeIncreaseAllowance(_aspTkn, _stakingBal);</span>
 539 |     | <span class='unexecuted'>    _newAspTkns = IERC4626(_aspTkn).deposit(_stakingBal, address(this));</span>
 540 |     | <span class='unexecuted'>    _podAmountUsed =</span>
 541 |     | <span class='unexecuted'>      _podBalBefore -</span>
 542 |     | <span class='unexecuted'>      IERC20(_props.pod).balanceOf(address(this));</span>
 543 |     | <span class='unexecuted'>    _pairedLpUsed =</span>
 544 |     | <span class='unexecuted'>      _pairedLpBalBefore -</span>
 545 |     | <span class='unexecuted'>      IERC20(_pairedLpForPod).balanceOf(address(this));</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    // for self lending pods redeem any extra paired LP asset back into main asset</span>
 548 |     | <span class='unexecuted'>    uint256 _pairedLeftover = _pairedLpBalBefore - _pairedLpUsed;</span>
 549 |     | <span class='unexecuted'>    if (_isSelfLendingAndOrPodded(_props.pod) &amp;&amp; _pairedLeftover &gt; 0) {</span>
 550 |     | <span class='unexecuted'>      if (_props.selfLendingPairPod != address(0)) {</span>
 551 |     | <span class='unexecuted'>        address[] memory _noop1 = new address[](0);</span>
 552 |     | <span class='unexecuted'>        uint8[] memory _noop2 = new uint8[](0);</span>
 553 |     | <span class='unexecuted'>        IDecentralizedIndex(_props.selfLendingPairPod).debond(</span>
 554 |     | <span class='unexecuted'>          _pairedLeftover,</span>
 555 |     | <span class='neutral'>          _noop1,</span>
 556 |     | <span class='neutral'>          _noop2</span>
 557 |     | <span class='neutral'>        );</span>
 558 |     | <span class='unexecuted'>        _pairedLeftover = IERC20(lendingPairs[_props.pod]).balanceOf(</span>
 559 |     | <span class='unexecuted'>          address(this)</span>
 560 |     | <span class='neutral'>        );</span>
 561 |     | <span class='neutral'>      }</span>
 562 |     | <span class='unexecuted'>      IFraxlendPair(lendingPairs[_props.pod]).redeem(</span>
 563 |     | <span class='neutral'>        _pairedLeftover,</span>
 564 |     | <span class='unexecuted'>        address(this),</span>
 565 |     | <span class='neutral'>        address(this)</span>
 566 |     | <span class='neutral'>      );</span>
 567 |     | <span class='neutral'>    }</span>
 568 |     | <span class='neutral'>  }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='unexecuted'>  function _getPairedTknAndAmt(</span>
 571 |     | <span class='neutral'>    address _pod,</span>
 572 |     | <span class='neutral'>    address _borrowedTkn,</span>
 573 |     | <span class='neutral'>    uint256 _borrowedAmt,</span>
 574 |     | <span class='neutral'>    address _selfLendingPairPod</span>
 575 |     | <span class='neutral'>  ) internal returns (address _finalPairedTkn, uint256 _finalPairedAmt) {</span>
 576 |     | <span class='unexecuted'>    _finalPairedTkn = _borrowedTkn;</span>
 577 |     | <span class='unexecuted'>    _finalPairedAmt = _borrowedAmt;</span>
 578 |     | <span class='unexecuted'>    if (_isSelfLendingAndOrPodded(_pod)) {</span>
 579 |     | <span class='unexecuted'>      _finalPairedTkn = lendingPairs[_pod];</span>
 580 |     | <span class='unexecuted'>      IERC20(_borrowedTkn).safeIncreaseAllowance(</span>
 581 |     | <span class='neutral'>        lendingPairs[_pod],</span>
 582 |     | <span class='unexecuted'>        _finalPairedAmt</span>
 583 |     | <span class='neutral'>      );</span>
 584 |     | <span class='unexecuted'>      _finalPairedAmt = IFraxlendPair(lendingPairs[_pod]).deposit(</span>
 585 |     | <span class='neutral'>        _finalPairedAmt,</span>
 586 |     | <span class='unexecuted'>        address(this)</span>
 587 |     | <span class='neutral'>      );</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='neutral'>      // self lending+podded</span>
 590 |     | <span class='unexecuted'>      if (_selfLendingPairPod != address(0)) {</span>
 591 |     | <span class='unexecuted'>        _finalPairedTkn = _selfLendingPairPod;</span>
 592 |     | <span class='unexecuted'>        IERC20(lendingPairs[_pod]).safeIncreaseAllowance(</span>
 593 |     | <span class='neutral'>          _selfLendingPairPod,</span>
 594 |     | <span class='unexecuted'>          _finalPairedAmt</span>
 595 |     | <span class='neutral'>        );</span>
 596 |     | <span class='unexecuted'>        IDecentralizedIndex(_selfLendingPairPod).bond(</span>
 597 |     | <span class='unexecuted'>          lendingPairs[_pod],</span>
 598 |     | <span class='neutral'>          _finalPairedAmt,</span>
 599 |     | <span class='neutral'>          0</span>
 600 |     | <span class='neutral'>        );</span>
 601 |     | <span class='unexecuted'>        _finalPairedAmt = IERC20(_selfLendingPairPod).balanceOf(address(this));</span>
 602 |     | <span class='neutral'>      }</span>
 603 |     | <span class='neutral'>    }</span>
 604 |     | <span class='neutral'>  }</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='unexecuted'>  function _unstakeAndRemoveLP(</span>
 607 |     | <span class='neutral'>    address _pod,</span>
 608 |     | <span class='neutral'>    uint256 _collateralAssetRemoveAmt,</span>
 609 |     | <span class='neutral'>    uint256 _podAmtMin,</span>
 610 |     | <span class='neutral'>    uint256 _pairedAssetAmtMin</span>
 611 |     | <span class='unexecuted'>  ) internal returns (uint256 _podAmtReceived, uint256 _pairedAmtReceived) {</span>
 612 |     | <span class='unexecuted'>    address _spTKN = IDecentralizedIndex(_pod).lpStakingPool();</span>
 613 |     | <span class='unexecuted'>    address _pairedLpToken = IDecentralizedIndex(_pod).PAIRED_LP_TOKEN();</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='unexecuted'>    uint256 _podAmtBefore = IERC20(_pod).balanceOf(address(this));</span>
 616 |     | <span class='unexecuted'>    uint256 _pairedTokenAmtBefore = IERC20(_pairedLpToken).balanceOf(</span>
 617 |     | <span class='unexecuted'>      address(this)</span>
 618 |     | <span class='neutral'>    );</span>
 619 |     | <span class='neutral'></span>
 620 |     | <span class='unexecuted'>    uint256 _spTKNAmtReceived = IERC4626(_getAspTkn(_pod)).redeem(</span>
 621 |     | <span class='neutral'>      _collateralAssetRemoveAmt,</span>
 622 |     | <span class='unexecuted'>      address(this),</span>
 623 |     | <span class='neutral'>      address(this)</span>
 624 |     | <span class='neutral'>    );</span>
 625 |     | <span class='unexecuted'>    IERC20(_spTKN).safeIncreaseAllowance(</span>
 626 |     | <span class='unexecuted'>      address(indexUtils),</span>
 627 |     | <span class='neutral'>      _spTKNAmtReceived</span>
 628 |     | <span class='neutral'>    );</span>
 629 |     | <span class='unexecuted'>    indexUtils.unstakeAndRemoveLP(</span>
 630 |     | <span class='neutral'>      IDecentralizedIndex(_pod),</span>
 631 |     | <span class='neutral'>      _spTKNAmtReceived,</span>
 632 |     | <span class='neutral'>      _podAmtMin,</span>
 633 |     | <span class='neutral'>      _pairedAssetAmtMin,</span>
 634 |     | <span class='unexecuted'>      block.timestamp</span>
 635 |     | <span class='neutral'>    );</span>
 636 |     | <span class='unexecuted'>    _podAmtReceived = IERC20(_pod).balanceOf(address(this)) - _podAmtBefore;</span>
 637 |     | <span class='unexecuted'>    _pairedAmtReceived =</span>
 638 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) -</span>
 639 |     | <span class='unexecuted'>      _pairedTokenAmtBefore;</span>
 640 |     | <span class='neutral'>  }</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='unexecuted'>  function _isSelfLendingAndOrPodded(</span>
 643 |     | <span class='neutral'>    address _pod</span>
 644 |     | <span class='unexecuted'>  ) internal view returns (bool) {</span>
 645 |     | <span class='neutral'>    return</span>
 646 |     | <span class='unexecuted'>      IDecentralizedIndex(_pod).PAIRED_LP_TOKEN() !=</span>
 647 |     | <span class='unexecuted'>      IFraxlendPair(lendingPairs[_pod]).asset();</span>
 648 |     | <span class='neutral'>  }</span>
 649 |     | <span class='neutral'></span>
 650 |     | <span class='unexecuted'>  function _getBorrowTknForPod(address _pod) internal view returns (address) {</span>
 651 |     | <span class='unexecuted'>    return</span>
 652 |     | <span class='unexecuted'>      _isSelfLendingAndOrPodded(_pod)</span>
 653 |     | <span class='unexecuted'>        ? IFraxlendPair(lendingPairs[_pod]).asset()</span>
 654 |     | <span class='unexecuted'>        : IDecentralizedIndex(_pod).PAIRED_LP_TOKEN();</span>
 655 |     | <span class='neutral'>  }</span>
 656 |     | <span class='neutral'></span>
 657 |     | <span class='unexecuted'>  function _getAspTkn(address _pod) internal view returns (address) {</span>
 658 |     | <span class='unexecuted'>    return IFraxlendPair(lendingPairs[_pod]).collateralContract();</span>
 659 |     | <span class='neutral'>  }</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='unexecuted'>  function setIndexUtils(IIndexUtils_LEGACY _utils) external onlyOwner {</span>
 662 |     | <span class='unexecuted'>    indexUtils = _utils;</span>
 663 |     | <span class='neutral'>  }</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='unexecuted'>  function setOpenFeePerc(uint16 _newFee) external onlyOwner {</span>
 666 |     | <span class='unexecuted'>    require(_newFee &lt;= 250, &#39;MAX&#39;);</span>
 667 |     | <span class='unexecuted'>    openFeePerc = _newFee;</span>
 668 |     | <span class='neutral'>  }</span>
 669 |     | <span class='neutral'></span>
 670 |     | <span class='unexecuted'>  function setCloseFeePerc(uint16 _newFee) external onlyOwner {</span>
 671 |     | <span class='unexecuted'>    require(_newFee &lt;= 250, &#39;MAX&#39;);</span>
 672 |     | <span class='unexecuted'>    closeFeePerc = _newFee;</span>
 673 |     | <span class='neutral'>  }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='unexecuted'>  function rescueETH() external onlyOwner {</span>
 676 |     | <span class='unexecuted'>    (bool _s, ) = payable(_msgSender()).call{ value: address(this).balance }(</span>
 677 |     | <span class='neutral'>      &#39;&#39;</span>
 678 |     | <span class='neutral'>    );</span>
 679 |     | <span class='unexecuted'>    require(_s, &#39;S&#39;);</span>
 680 |     | <span class='neutral'>  }</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='unexecuted'>  function rescueTokens(IERC20 _token) external onlyOwner {</span>
 683 |     | <span class='unexecuted'>    _token.safeTransfer(_msgSender(), _token.balanceOf(address(this)));</span>
 684 |     | <span class='neutral'>  }</span>
 685 |     | <span class='neutral'></span>
 686 |     | <span class='neutral'>  receive() external payable {}</span>
 687 |     | <span class='neutral'>}</span>
 688 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeverageManagerAccessControl.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../interfaces/IFlashLoanSource.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../interfaces/IFraxlendPair.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract LeverageManagerAccessControl is Ownable {</span>
  9 |     | <span class='neutral'>  // pod =&gt; pair</span>
 10 |     | <span class='unexecuted'>  mapping(address =&gt; address) public lendingPairs;</span>
 11 |     | <span class='neutral'>  // pod =&gt; flash source</span>
 12 |     | <span class='unexecuted'>  mapping(address =&gt; address) public flashSource;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>  function setLendingPair(address _pod, address _pair) external onlyOwner {</span>
 15 |     | <span class='unexecuted'>    if (_pair != address(0)) {</span>
 16 |     | <span class='unexecuted'>      require(IFraxlendPair(_pair).collateralContract() != address(0), &#39;AV&#39;);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='unexecuted'>    lendingPairs[_pod] = _pair;</span>
 19 |     | <span class='neutral'>  }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>  function setFlashSource(</span>
 22 |     | <span class='neutral'>    address _pod,</span>
 23 |     | <span class='neutral'>    address _flashSource</span>
 24 |     | <span class='neutral'>  ) external onlyOwner {</span>
 25 |     | <span class='unexecuted'>    if (_flashSource != address(0)) {</span>
 26 |     | <span class='unexecuted'>      require(IFlashLoanSource(_flashSource).source() != address(0), &#39;AFS&#39;);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='unexecuted'>    flashSource[_pod] = _flashSource;</span>
 29 |     | <span class='neutral'>  }</span>
 30 |     | <span class='neutral'>}</span>
 31 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeveragePositionCustodian.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/utils/Context.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;../interfaces/IFraxlendPair.sol&#39;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>contract LeveragePositionCustodian is Context, Ownable {</span>
 11 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='unexecuted'>  function borrowAsset(</span>
 14 |     | <span class='neutral'>    address _pair,</span>
 15 |     | <span class='neutral'>    uint256 _borrowAmount,</span>
 16 |     | <span class='neutral'>    uint256 _collateralAmount,</span>
 17 |     | <span class='neutral'>    address _receiver</span>
 18 |     | <span class='neutral'>  ) external onlyOwner {</span>
 19 |     | <span class='unexecuted'>    IERC20(IFraxlendPair(_pair).collateralContract()).safeIncreaseAllowance(</span>
 20 |     | <span class='unexecuted'>      _pair,</span>
 21 |     | <span class='unexecuted'>      _collateralAmount</span>
 22 |     | <span class='neutral'>    );</span>
 23 |     | <span class='unexecuted'>    IFraxlendPair(_pair).borrowAsset(</span>
 24 |     | <span class='neutral'>      _borrowAmount,</span>
 25 |     | <span class='neutral'>      _collateralAmount,</span>
 26 |     | <span class='neutral'>      _receiver</span>
 27 |     | <span class='neutral'>    );</span>
 28 |     | <span class='neutral'>  }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>  function removeCollateral(</span>
 31 |     | <span class='neutral'>    address _pair,</span>
 32 |     | <span class='neutral'>    uint256 _collateralAmount,</span>
 33 |     | <span class='neutral'>    address _receiver</span>
 34 |     | <span class='neutral'>  ) external onlyOwner {</span>
 35 |     | <span class='unexecuted'>    IFraxlendPair(_pair).removeCollateral(_collateralAmount, _receiver);</span>
 36 |     | <span class='neutral'>  }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>  function withdraw(</span>
 39 |     | <span class='neutral'>    address _token,</span>
 40 |     | <span class='neutral'>    address _recipient,</span>
 41 |     | <span class='neutral'>    uint256 _amount</span>
 42 |     | <span class='neutral'>  ) external onlyOwner {</span>
 43 |     | <span class='unexecuted'>    _amount = _amount == 0 ? IERC20(_token).balanceOf(address(this)) : _amount;</span>
 44 |     | <span class='unexecuted'>    IERC20(_token).safeTransfer(_recipient, _amount);</span>
 45 |     | <span class='neutral'>  }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/lvf/LeveragePositions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/utils/Context.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;erc721a/contracts/ERC721A.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract LeveragePositions is Context, ERC721A {</span>
  8 |     | <span class='neutral'>  address _controller;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>  constructor(</span>
 11 |     | <span class='neutral'>    string memory _name,</span>
 12 |     | <span class='neutral'>    string memory _symbol</span>
 13 |     | <span class='unexecuted'>  ) ERC721A(_name, _symbol) {</span>
 14 |     | <span class='unexecuted'>    _controller = _msgSender();</span>
 15 |     | <span class='neutral'>  }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>  function mint(address _receiver) external returns (uint256 _tokenId) {</span>
 18 |     | <span class='unexecuted'>    require(_msgSender() == _controller, &#39;AUTH&#39;);</span>
 19 |     | <span class='neutral'>    _tokenId = _nextTokenId();</span>
 20 |     | <span class='unexecuted'>    _mint(_receiver, 1);</span>
 21 |     | <span class='neutral'>  }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>  function _startTokenId() internal pure override returns (uint256) {</span>
 24 |     | <span class='unexecuted'>    return 1;</span>
 25 |     | <span class='neutral'>  }</span>
 26 |     | <span class='neutral'>}</span>
 27 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/ChainlinkSinglePriceOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../interfaces/IMinimalSinglePriceOracle.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>contract ChainlinkSinglePriceOracle is IMinimalSinglePriceOracle, Ownable {</span>
  9 |     | <span class='neutral'>  event SetMaxOracleDelay(uint256 _oldDelay, uint256 _newDelay);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>  uint256 public maxOracleDelay = 1 days;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>  /// @notice The ```getPriceUSD18``` function gets the QUOTE/BASE price (mathematically BASE per QUOTE)</span>
 14 |     | <span class='neutral'>  /// @param _priceFeedQuote Chainlink price feed representing the quote token, probably quote/USD (mathematically USD per quote)</span>
 15 |     | <span class='neutral'>  /// @param _priceFeedBase Chainlink price feed representing the base token, probably quote/USD (mathematically USD per base)</span>
 16 |     | <span class='neutral'>  /// @return _isBadData Whether the oracle is returning what we should assume is bad data</span>
 17 |     | <span class='neutral'>  /// @return _price18 Number representing the price with 1e18 precision</span>
 18 |     | <span class='unexecuted'>  function getPriceUSD18(</span>
 19 |     | <span class='neutral'>    address _priceFeedQuote,</span>
 20 |     | <span class='neutral'>    address _priceFeedBase,</span>
 21 |     | <span class='neutral'>    address,</span>
 22 |     | <span class='neutral'>    uint256</span>
 23 |     | <span class='unexecuted'>  ) external view virtual override returns (bool _isBadData, uint256 _price18) {</span>
 24 |     | <span class='unexecuted'>    uint256 _quoteUpdatedAt;</span>
 25 |     | <span class='unexecuted'>    uint256 _isBadTime = block.timestamp - maxOracleDelay;</span>
 26 |     | <span class='unexecuted'>    (_price18, _quoteUpdatedAt) = _getChainlinkPriceFeedPrice18(</span>
 27 |     | <span class='unexecuted'>      _priceFeedQuote</span>
 28 |     | <span class='neutral'>    );</span>
 29 |     | <span class='unexecuted'>    _isBadData = _quoteUpdatedAt &lt; _isBadTime;</span>
 30 |     | <span class='unexecuted'>    if (_priceFeedBase != address(0)) {</span>
 31 |     | <span class='unexecuted'>      (</span>
 32 |     | <span class='unexecuted'>        uint256 _basePrice18,</span>
 33 |     | <span class='unexecuted'>        uint256 _baseUpdatedAt</span>
 34 |     | <span class='unexecuted'>      ) = _getChainlinkPriceFeedPrice18(_priceFeedBase);</span>
 35 |     | <span class='unexecuted'>      _price18 = (10 ** 18 * _price18) / _basePrice18;</span>
 36 |     | <span class='unexecuted'>      _isBadData = _isBadData || _baseUpdatedAt &lt; _isBadTime;</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'>  }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>  function _getChainlinkPriceFeedPrice18(</span>
 41 |     | <span class='neutral'>    address _priceFeed</span>
 42 |     | <span class='unexecuted'>  ) internal view returns (uint256 _price18, uint256 _updatedAt) {</span>
 43 |     | <span class='unexecuted'>    uint8 _decimals = AggregatorV3Interface(_priceFeed).decimals();</span>
 44 |     | <span class='unexecuted'>    (, int256 _price, , uint256 _lastUpdated, ) = AggregatorV3Interface(</span>
 45 |     | <span class='unexecuted'>      _priceFeed</span>
 46 |     | <span class='neutral'>    ).latestRoundData();</span>
 47 |     | <span class='unexecuted'>    _price18 = uint256(_price) * (10 ** 18 / 10 ** _decimals);</span>
 48 |     | <span class='unexecuted'>    _updatedAt = _lastUpdated;</span>
 49 |     | <span class='neutral'>  }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>  function setMaxOracleDelay(uint256 _newDelaySeconds) external onlyOwner {</span>
 52 |     | <span class='unexecuted'>    uint256 _current = maxOracleDelay;</span>
 53 |     | <span class='unexecuted'>    maxOracleDelay = _newDelaySeconds;</span>
 54 |     | <span class='unexecuted'>    emit SetMaxOracleDelay(_current, _newDelaySeconds);</span>
 55 |     | <span class='neutral'>  }</span>
 56 |     | <span class='neutral'>}</span>
 57 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/UniswapV3SinglePriceOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../libraries/FullMath.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;../libraries/TickMath.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;../interfaces/IERC20Metadata.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;../interfaces/IMinimalSinglePriceOracle.sol&#39;;</span>
  9 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV3Pool.sol&#39;;</span>
 10 |     | <span class='neutral'>import &#39;./ChainlinkSinglePriceOracle.sol&#39;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='unexecuted'>contract UniswapV3SinglePriceOracle is ChainlinkSinglePriceOracle {</span>
 13 |     | <span class='unexecuted'>  function getPriceUSD18(</span>
 14 |     | <span class='neutral'>    address _clBaseConversionPoolPriceFeed,</span>
 15 |     | <span class='neutral'>    address _quoteToken,</span>
 16 |     | <span class='neutral'>    address _quoteV3Pool,</span>
 17 |     | <span class='neutral'>    uint256 _twapInterval</span>
 18 |     | <span class='unexecuted'>  ) external view virtual override returns (bool _isBadData, uint256 _price18) {</span>
 19 |     | <span class='unexecuted'>    uint256 _quotePriceX96 = _getPoolPriceTokenDenomenator(</span>
 20 |     | <span class='unexecuted'>      _quoteToken,</span>
 21 |     | <span class='unexecuted'>      _quoteV3Pool,</span>
 22 |     | <span class='unexecuted'>      uint32(_twapInterval)</span>
 23 |     | <span class='neutral'>    );</span>
 24 |     | <span class='neutral'>    // default base price to 1, which just means return only quote pool price without any base conversion</span>
 25 |     | <span class='unexecuted'>    uint256 _basePrice18 = 10 ** 18;</span>
 26 |     | <span class='unexecuted'>    uint256 _updatedAt = block.timestamp;</span>
 27 |     | <span class='unexecuted'>    if (_clBaseConversionPoolPriceFeed != address(0)) {</span>
 28 |     | <span class='unexecuted'>      (_basePrice18, _updatedAt) = _getChainlinkPriceFeedPrice18(</span>
 29 |     | <span class='unexecuted'>        _clBaseConversionPoolPriceFeed</span>
 30 |     | <span class='neutral'>      );</span>
 31 |     | <span class='neutral'>    }</span>
 32 |     | <span class='unexecuted'>    _price18 = (_quotePriceX96 * _basePrice18) / FixedPoint96.Q96;</span>
 33 |     | <span class='unexecuted'>    _isBadData = _updatedAt &lt; block.timestamp - maxOracleDelay;</span>
 34 |     | <span class='neutral'>  }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='unexecuted'>  function _getPoolPriceTokenDenomenator(</span>
 37 |     | <span class='neutral'>    address _priceToken,</span>
 38 |     | <span class='neutral'>    address _pricePool,</span>
 39 |     | <span class='neutral'>    uint32 _interval</span>
 40 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 41 |     | <span class='unexecuted'>    address _t0 = IUniswapV3Pool(_pricePool).token0();</span>
 42 |     | <span class='unexecuted'>    return</span>
 43 |     | <span class='unexecuted'>      _normalizedPriceX96(</span>
 44 |     | <span class='unexecuted'>        IUniswapV3Pool(_pricePool),</span>
 45 |     | <span class='unexecuted'>        _interval,</span>
 46 |     | <span class='unexecuted'>        _t0 == _priceToken ? IUniswapV3Pool(_pricePool).token1() : _t0</span>
 47 |     | <span class='neutral'>      );</span>
 48 |     | <span class='neutral'>  }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='unexecuted'>  function _getSqrtPriceX96FromPool(</span>
 51 |     | <span class='neutral'>    IUniswapV3Pool _pool,</span>
 52 |     | <span class='neutral'>    uint32 _interval</span>
 53 |     | <span class='unexecuted'>  ) public view returns (uint160 _sqrtPriceX96) {</span>
 54 |     | <span class='unexecuted'>    if (_interval == 0) {</span>
 55 |     | <span class='unexecuted'>      (_sqrtPriceX96, , , , , , ) = _pool.slot0();</span>
 56 |     | <span class='unexecuted'>    } else {</span>
 57 |     | <span class='unexecuted'>      uint32[] memory secondsAgo = new uint32[](2);</span>
 58 |     | <span class='unexecuted'>      secondsAgo[0] = _interval;</span>
 59 |     | <span class='unexecuted'>      secondsAgo[1] = 0; // to (now)</span>
 60 |     | <span class='unexecuted'>      (int56[] memory tickCumulatives, ) = _pool.observe(secondsAgo);</span>
 61 |     | <span class='unexecuted'>      _sqrtPriceX96 = TickMath.getSqrtRatioAtTick(</span>
 62 |     | <span class='unexecuted'>        int24((tickCumulatives[1] - tickCumulatives[0]) / int32(_interval))</span>
 63 |     | <span class='neutral'>      );</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>  }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>  function _normalizedPriceX96(</span>
 68 |     | <span class='neutral'>    IUniswapV3Pool _pool,</span>
 69 |     | <span class='neutral'>    uint32 _twapInterval,</span>
 70 |     | <span class='neutral'>    address _numeratorToken</span>
 71 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 72 |     | <span class='unexecuted'>    address _token1 = _pool.token1();</span>
 73 |     | <span class='unexecuted'>    uint8 _decimals0 = IERC20Metadata(_pool.token0()).decimals();</span>
 74 |     | <span class='unexecuted'>    uint8 _decimals1 = IERC20Metadata(_token1).decimals();</span>
 75 |     | <span class='unexecuted'>    uint160 _sqrtPriceX96 = _getSqrtPriceX96FromPool(_pool, _twapInterval);</span>
 76 |     | <span class='unexecuted'>    uint256 _priceX96 = FullMath.mulDiv(</span>
 77 |     | <span class='neutral'>      _sqrtPriceX96,</span>
 78 |     | <span class='neutral'>      _sqrtPriceX96,</span>
 79 |     | <span class='neutral'>      FixedPoint96.Q96</span>
 80 |     | <span class='neutral'>    );</span>
 81 |     | <span class='unexecuted'>    uint256 _correctedPriceX96 = _token1 == _numeratorToken</span>
 82 |     | <span class='unexecuted'>      ? _priceX96</span>
 83 |     | <span class='unexecuted'>      : FixedPoint96.Q96 ** 2 / _priceX96;</span>
 84 |     | <span class='unexecuted'>    return</span>
 85 |     | <span class='unexecuted'>      _token1 == _numeratorToken</span>
 86 |     | <span class='unexecuted'>        ? (_correctedPriceX96 * 10 ** _decimals0) / 10 ** _decimals1</span>
 87 |     | <span class='unexecuted'>        : (_correctedPriceX96 * 10 ** _decimals1) / 10 ** _decimals0;</span>
 88 |     | <span class='neutral'>  }</span>
 89 |     | <span class='neutral'>}</span>
 90 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/V2ReservesUniswap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Pair.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;../interfaces/IV2Reserves.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract V2ReservesUniswap is IV2Reserves {</span>
  8 |     | <span class='unexecuted'>  function getReserves(</span>
  9 |     | <span class='neutral'>    address _pair</span>
 10 |     | <span class='neutral'>  )</span>
 11 |     | <span class='neutral'>    external</span>
 12 |     | <span class='neutral'>    view</span>
 13 |     | <span class='neutral'>    virtual</span>
 14 |     | <span class='neutral'>    override</span>
 15 |     | <span class='unexecuted'>    returns (uint112 _reserve0, uint112 _reserve1)</span>
 16 |     | <span class='neutral'>  {</span>
 17 |     | <span class='unexecuted'>    (_reserve0, _reserve1, ) = IUniswapV2Pair(_pair).getReserves();</span>
 18 |     | <span class='neutral'>  }</span>
 19 |     | <span class='neutral'>}</span>
 20 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/aspTKNMinimalOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./spTKNMinimalOracle.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract aspTKNMinimalOracle is spTKNMinimalOracle {</span>
  8 |     | <span class='unexecuted'>  address public immutable ASP_TKN; // QUOTE_TOKEN</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>  constructor(</span>
 11 |     | <span class='neutral'>    address _aspTKN,</span>
 12 |     | <span class='neutral'>    address _baseToken,</span>
 13 |     | <span class='neutral'>    bool _baseIsPod,</span>
 14 |     | <span class='neutral'>    address _spTKN,</span>
 15 |     | <span class='neutral'>    address _underlyingClPool,</span>
 16 |     | <span class='neutral'>    address _baseConversionChainlinkFeed,</span>
 17 |     | <span class='neutral'>    address _baseConversionClPool,</span>
 18 |     | <span class='neutral'>    address _clBaseFeed,</span>
 19 |     | <span class='neutral'>    address _clQuoteFeed,</span>
 20 |     | <span class='neutral'>    address _clSinglePriceOracle,</span>
 21 |     | <span class='neutral'>    address _uniswapSinglePriceOracle,</span>
 22 |     | <span class='neutral'>    address _v2Reserves</span>
 23 |     | <span class='neutral'>  )</span>
 24 |     | <span class='neutral'>    spTKNMinimalOracle(</span>
 25 |     | <span class='unexecuted'>      _baseToken,</span>
 26 |     | <span class='unexecuted'>      _baseIsPod,</span>
 27 |     | <span class='unexecuted'>      _spTKN,</span>
 28 |     | <span class='unexecuted'>      _underlyingClPool,</span>
 29 |     | <span class='unexecuted'>      _baseConversionChainlinkFeed,</span>
 30 |     | <span class='unexecuted'>      _baseConversionClPool,</span>
 31 |     | <span class='unexecuted'>      _clBaseFeed,</span>
 32 |     | <span class='unexecuted'>      _clQuoteFeed,</span>
 33 |     | <span class='unexecuted'>      _clSinglePriceOracle,</span>
 34 |     | <span class='unexecuted'>      _uniswapSinglePriceOracle,</span>
 35 |     | <span class='unexecuted'>      _v2Reserves</span>
 36 |     | <span class='neutral'>    )</span>
 37 |     | <span class='neutral'>  {</span>
 38 |     | <span class='unexecuted'>    ASP_TKN = _aspTKN;</span>
 39 |     | <span class='neutral'>  }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='unexecuted'>  function getPrices()</span>
 42 |     | <span class='neutral'>    public</span>
 43 |     | <span class='neutral'>    view</span>
 44 |     | <span class='neutral'>    virtual</span>
 45 |     | <span class='neutral'>    override</span>
 46 |     | <span class='unexecuted'>    returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)</span>
 47 |     | <span class='unexecuted'>  {</span>
 48 |     | <span class='unexecuted'>    uint256 _assetFactor = 10 ** 18;</span>
 49 |     | <span class='unexecuted'>    uint256 _aspTknPerSpTkn = IERC4626(ASP_TKN).convertToShares(_assetFactor);</span>
 50 |     | <span class='unexecuted'>    (_isBadData, _priceLow, _priceHigh) = super.getPrices();</span>
 51 |     | <span class='unexecuted'>    _priceLow = (_priceLow * _assetFactor) / _aspTknPerSpTkn;</span>
 52 |     | <span class='unexecuted'>    _priceHigh = (_priceHigh * _assetFactor) / _aspTknPerSpTkn;</span>
 53 |     | <span class='neutral'>  }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/oracle/spTKNMinimalOracle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/IDecentralizedIndex.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/IStakingPoolToken.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV2Pair.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../interfaces/IMinimalOracle.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../interfaces/IMinimalSinglePriceOracle.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../interfaces/IV2Reserves.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract spTKNMinimalOracle is IMinimalOracle, Ownable {</span>
  14 |     | <span class='neutral'>  /// @dev The base token we will price against in the oracle. Will be either pairedLpAsset</span>
  15 |     | <span class='neutral'>  /// @dev or the borrow token in a lending pair</span>
  16 |     | <span class='unexecuted'>  address public immutable BASE_TOKEN;</span>
  17 |     | <span class='unexecuted'>  bool public immutable BASE_IS_POD;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>  /// @dev The pod stake token and oracle quote token that custodies UniV2 LP tokens</span>
  20 |     | <span class='unexecuted'>  address public immutable SP_TKN; // QUOTE_TOKEN</span>
  21 |     | <span class='unexecuted'>  address public immutable POD;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>  /// @dev The concentrated liquidity UniV3 pool where we get the TWAP to price the underlying TKN</span>
  24 |     | <span class='neutral'>  /// @dev of the pod represented through SP_TKN and then convert it to the spTKN price</span>
  25 |     | <span class='unexecuted'>  address public immutable UNDERLYING_TKN_CL_POOL;</span>
  26 |     | <span class='unexecuted'>  address public immutable UNDERLYING_TKN;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>  /// @dev The Chainlink price feed we can use to convert the price we fetch through UNDERLYING_TKN_CL_POOL</span>
  29 |     | <span class='neutral'>  /// @dev into a BASE_TOKEN normalized price,</span>
  30 |     | <span class='neutral'>  /// @dev NOTE: only needed if the paired token of the CL_POOL is not BASE_TOKEN</span>
  31 |     | <span class='unexecuted'>  address public immutable BASE_CONVERSION_CHAINLINK_FEED;</span>
  32 |     | <span class='unexecuted'>  address public immutable BASE_CONVERSION_CL_POOL;</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>  /// @dev Chainlink config to fetch a 2nd price for the oracle</span>
  35 |     | <span class='neutral'>  /// @dev The assumption would be that the paired asset of both oracles are the same</span>
  36 |     | <span class='neutral'>  /// @dev For example, if base=ETH, quote=BTC, the feeds we could use would be ETH/USD &amp; BTC/USD</span>
  37 |     | <span class='unexecuted'>  address public immutable CHAINLINK_BASE_PRICE_FEED;</span>
  38 |     | <span class='unexecuted'>  address public immutable CHAINLINK_QUOTE_PRICE_FEED;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>  /// @dev Single price oracle helpers to get already formatted prices that are easy to convert/use</span>
  41 |     | <span class='unexecuted'>  address public immutable CHAINLINK_SINGLE_PRICE_ORACLE;</span>
  42 |     | <span class='unexecuted'>  address public immutable UNISWAP_V3_SINGLE_PRICE_ORACLE;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>  /// @dev Different networks will use different forked implementations of UniswapV2, so</span>
  45 |     | <span class='neutral'>  /// @dev this allows us to define a uniform interface to fetch the reserves of each asset in a pair</span>
  46 |     | <span class='unexecuted'>  IV2Reserves public immutable V2_RESERVES;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>  uint32 twapInterval = 10 minutes;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>  constructor(</span>
  51 |     | <span class='neutral'>    address _baseToken,</span>
  52 |     | <span class='neutral'>    bool _baseIsPod,</span>
  53 |     | <span class='neutral'>    address _spTKN,</span>
  54 |     | <span class='neutral'>    address _underlyingClPool,</span>
  55 |     | <span class='neutral'>    address _baseConversionChainlinkFeed,</span>
  56 |     | <span class='neutral'>    address _baseConversionClPool,</span>
  57 |     | <span class='neutral'>    address _clBaseFeed,</span>
  58 |     | <span class='neutral'>    address _clQuoteFeed,</span>
  59 |     | <span class='neutral'>    address _clSinglePriceOracle,</span>
  60 |     | <span class='neutral'>    address _uniswapSinglePriceOracle,</span>
  61 |     | <span class='neutral'>    address _v2Reserves</span>
  62 |     | <span class='unexecuted'>  ) {</span>
  63 |     | <span class='neutral'>    // only one (or neither) of the base conversion config should be populated</span>
  64 |     | <span class='unexecuted'>    require(</span>
  65 |     | <span class='unexecuted'>      _baseConversionChainlinkFeed == address(0) ||</span>
  66 |     | <span class='unexecuted'>        _baseConversionClPool == address(0),</span>
  67 |     | <span class='neutral'>      &#39;CONV&#39;</span>
  68 |     | <span class='neutral'>    );</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    BASE_TOKEN = _baseToken;</span>
  71 |     | <span class='unexecuted'>    BASE_IS_POD = _baseIsPod;</span>
  72 |     | <span class='unexecuted'>    SP_TKN = _spTKN;</span>
  73 |     | <span class='unexecuted'>    UNDERLYING_TKN_CL_POOL = _underlyingClPool;</span>
  74 |     | <span class='unexecuted'>    BASE_CONVERSION_CHAINLINK_FEED = _baseConversionChainlinkFeed;</span>
  75 |     | <span class='unexecuted'>    BASE_CONVERSION_CL_POOL = _baseConversionClPool;</span>
  76 |     | <span class='unexecuted'>    CHAINLINK_BASE_PRICE_FEED = _clBaseFeed;</span>
  77 |     | <span class='unexecuted'>    CHAINLINK_QUOTE_PRICE_FEED = _clQuoteFeed;</span>
  78 |     | <span class='unexecuted'>    CHAINLINK_SINGLE_PRICE_ORACLE = _clSinglePriceOracle;</span>
  79 |     | <span class='unexecuted'>    UNISWAP_V3_SINGLE_PRICE_ORACLE = _uniswapSinglePriceOracle;</span>
  80 |     | <span class='unexecuted'>    V2_RESERVES = IV2Reserves(_v2Reserves);</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>    address _pod = IStakingPoolToken(_spTKN).indexFund();</span>
  83 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(</span>
  84 |     | <span class='unexecuted'>      _pod</span>
  85 |     | <span class='neutral'>    ).getAllAssets();</span>
  86 |     | <span class='unexecuted'>    POD = _pod;</span>
  87 |     | <span class='unexecuted'>    UNDERLYING_TKN = _assets[0].token;</span>
  88 |     | <span class='neutral'>  }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>  /// @notice The ```getPrices``` function gets the mathematical price of SP_TKN / BASE_TOKEN, so in plain english will</span>
  91 |     | <span class='neutral'>  /// @notice be the number of SP_TKN per every BASE_TOKEN</span>
  92 |     | <span class='neutral'>  /// @return _isBadData Whether the price(s) returned should be considered bad</span>
  93 |     | <span class='neutral'>  /// @return _priceLow The lower of the dual prices returned</span>
  94 |     | <span class='neutral'>  /// @return _priceHigh The higher of the dual prices returned</span>
  95 |     | <span class='unexecuted'>  function getPrices()</span>
  96 |     | <span class='neutral'>    public</span>
  97 |     | <span class='neutral'>    view</span>
  98 |     | <span class='neutral'>    virtual</span>
  99 |     | <span class='neutral'>    override</span>
 100 |     | <span class='unexecuted'>    returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh)</span>
 101 |     | <span class='unexecuted'>  {</span>
 102 |     | <span class='unexecuted'>    uint256 _priceBaseSpTKN = _calculateBasePerSpTkn(0);</span>
 103 |     | <span class='unexecuted'>    _isBadData = _priceBaseSpTKN == 0;</span>
 104 |     | <span class='unexecuted'>    uint256 _priceOne18 = _priceBaseSpTKN *</span>
 105 |     | <span class='unexecuted'>      10 ** (18 - IERC20Metadata(BASE_TOKEN).decimals());</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    uint256 _priceTwo18 = _priceOne18;</span>
 108 |     | <span class='unexecuted'>    if (</span>
 109 |     | <span class='unexecuted'>      CHAINLINK_BASE_PRICE_FEED != address(0) &amp;&amp;</span>
 110 |     | <span class='unexecuted'>      CHAINLINK_QUOTE_PRICE_FEED != address(0)</span>
 111 |     | <span class='unexecuted'>    ) {</span>
 112 |     | <span class='unexecuted'>      uint256 _clPrice18 = _chainlinkBasePerPaired18();</span>
 113 |     | <span class='unexecuted'>      uint256 _clPriceBaseSpTKN = _calculateBasePerSpTkn(_clPrice18);</span>
 114 |     | <span class='unexecuted'>      _priceTwo18 =</span>
 115 |     | <span class='unexecuted'>        _clPriceBaseSpTKN *</span>
 116 |     | <span class='unexecuted'>        10 ** (18 - IERC20Metadata(BASE_TOKEN).decimals());</span>
 117 |     | <span class='unexecuted'>      _isBadData = _isBadData || _clPrice18 == 0;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    // If the prices are the same it means the CL price was pulled as the UniV3 price</span>
 121 |     | <span class='unexecuted'>    _priceLow = _priceOne18 &gt; _priceTwo18 ? _priceTwo18 : _priceOne18;</span>
 122 |     | <span class='unexecuted'>    _priceHigh = _priceOne18 &gt; _priceTwo18 ? _priceOne18 : _priceTwo18;</span>
 123 |     | <span class='neutral'>  }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>  function _calculateBasePerSpTkn(</span>
 126 |     | <span class='neutral'>    uint256 _price18</span>
 127 |     | <span class='unexecuted'>  ) internal view returns (uint256 _spTknBasePrice18) {</span>
 128 |     | <span class='neutral'>    // pull from UniV3 TWAP if passed as 0</span>
 129 |     | <span class='unexecuted'>    address _baseInCl = _getBaseTokenInClPool();</span>
 130 |     | <span class='unexecuted'>    if (_price18 == 0) {</span>
 131 |     | <span class='unexecuted'>      bool _isBadData;</span>
 132 |     | <span class='unexecuted'>      (_isBadData, _price18) = IMinimalSinglePriceOracle(</span>
 133 |     | <span class='unexecuted'>        UNISWAP_V3_SINGLE_PRICE_ORACLE</span>
 134 |     | <span class='neutral'>      ).getPriceUSD18(</span>
 135 |     | <span class='unexecuted'>          BASE_CONVERSION_CHAINLINK_FEED,</span>
 136 |     | <span class='unexecuted'>          UNDERLYING_TKN,</span>
 137 |     | <span class='unexecuted'>          UNDERLYING_TKN_CL_POOL,</span>
 138 |     | <span class='unexecuted'>          twapInterval</span>
 139 |     | <span class='neutral'>        );</span>
 140 |     | <span class='unexecuted'>      if (_isBadData) {</span>
 141 |     | <span class='unexecuted'>        return 0;</span>
 142 |     | <span class='neutral'>      }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>      if (BASE_CONVERSION_CL_POOL != address(0)) {</span>
 145 |     | <span class='unexecuted'>        (</span>
 146 |     | <span class='unexecuted'>          bool _subBadData,</span>
 147 |     | <span class='neutral'>          uint256 _baseConvPrice18</span>
 148 |     | <span class='unexecuted'>        ) = IMinimalSinglePriceOracle(UNISWAP_V3_SINGLE_PRICE_ORACLE)</span>
 149 |     | <span class='neutral'>            .getPriceUSD18(</span>
 150 |     | <span class='neutral'>              address(0),</span>
 151 |     | <span class='neutral'>              _baseInCl,</span>
 152 |     | <span class='unexecuted'>              BASE_CONVERSION_CL_POOL,</span>
 153 |     | <span class='unexecuted'>              twapInterval</span>
 154 |     | <span class='neutral'>            );</span>
 155 |     | <span class='unexecuted'>        if (_subBadData) {</span>
 156 |     | <span class='unexecuted'>          return 0;</span>
 157 |     | <span class='neutral'>        }</span>
 158 |     | <span class='unexecuted'>        _price18 = (10 ** 18 * _baseConvPrice18) / _price18;</span>
 159 |     | <span class='neutral'>      }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='unexecuted'>    address _pair = _getPair();</span>
 162 |     | <span class='unexecuted'>    address _clT0 = IUniswapV2Pair(UNDERLYING_TKN_CL_POOL).token0();</span>
 163 |     | <span class='unexecuted'>    uint8 _clT0Decimals = IERC20Metadata(_clT0).decimals();</span>
 164 |     | <span class='unexecuted'>    address _clT1 = IUniswapV2Pair(UNDERLYING_TKN_CL_POOL).token1();</span>
 165 |     | <span class='unexecuted'>    uint8 _clT1Decimals = IERC20Metadata(_clT1).decimals();</span>
 166 |     | <span class='unexecuted'>    uint256 _pricePTKNPerBase18 = _clT1 == _baseInCl</span>
 167 |     | <span class='unexecuted'>      ? _accountForCBRInPrice(POD, UNDERLYING_TKN, _price18)</span>
 168 |     | <span class='unexecuted'>      : 10 ** (18 * 2) / _accountForCBRInPrice(POD, UNDERLYING_TKN, _price18);</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    // adjust current price for spTKN pod unwrap fee, which will end up making the end price</span>
 171 |     | <span class='neutral'>    // (spTKN per base) higher, meaning it will take more spTKN to equal the value</span>
 172 |     | <span class='neutral'>    // of base token. This will more accurately ensure healthy LTVs when lending since</span>
 173 |     | <span class='neutral'>    // a liquidation path will need to account for unwrap fees</span>
 174 |     | <span class='unexecuted'>    _pricePTKNPerBase18 = _accountForUnwrapFeeInPrice(POD, _pricePTKNPerBase18);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>    (uint112 _reserve0, uint112 _reserve1) = V2_RESERVES.getReserves(_pair);</span>
 177 |     | <span class='unexecuted'>    uint256 _k = uint256(_reserve0) * _reserve1;</span>
 178 |     | <span class='unexecuted'>    uint256 _kDec = 10 **</span>
 179 |     | <span class='unexecuted'>      IERC20Metadata(IUniswapV2Pair(_pair).token0()).decimals() *</span>
 180 |     | <span class='unexecuted'>      10 ** IERC20Metadata(IUniswapV2Pair(_pair).token1()).decimals();</span>
 181 |     | <span class='unexecuted'>    uint256 _avgBaseAssetInLp18 = _sqrt((_pricePTKNPerBase18 * _k) / _kDec) *</span>
 182 |     | <span class='unexecuted'>      10 ** (18 / 2);</span>
 183 |     | <span class='unexecuted'>    uint256 _pairPrice18 = (2 *</span>
 184 |     | <span class='unexecuted'>      _avgBaseAssetInLp18 *</span>
 185 |     | <span class='unexecuted'>      10 ** ((_clT0Decimals + _clT1Decimals) / 2)) /</span>
 186 |     | <span class='unexecuted'>      IERC20(_pair).totalSupply();</span>
 187 |     | <span class='unexecuted'>    uint256 _baseTDecimals = _clT1 == _baseInCl ? _clT1Decimals : _clT0Decimals;</span>
 188 |     | <span class='unexecuted'>    _spTknBasePrice18 =</span>
 189 |     | <span class='unexecuted'>      10 ** (18 * 2) /</span>
 190 |     | <span class='unexecuted'>      ((_pairPrice18 * 10 ** _baseTDecimals) / 10 ** 18);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    // if the base asset is a pod, we will assume that the CL/chainlink pool(s) are</span>
 193 |     | <span class='neutral'>    // pricing the underlying asset of the base asset pod, and therefore we will</span>
 194 |     | <span class='neutral'>    // adjust the output price by CBR and unwrap fee for this pod for more accuracy and</span>
 195 |     | <span class='neutral'>    // better handling accounting for liquidation path</span>
 196 |     | <span class='unexecuted'>    if (BASE_IS_POD) {</span>
 197 |     | <span class='unexecuted'>      _spTknBasePrice18 = _checkAndHandleBaseTokenPodConfig(_spTknBasePrice18);</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'>  }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='unexecuted'>  function _getBaseTokenInClPool() internal view returns (address _base) {</span>
 202 |     | <span class='unexecuted'>    _base = BASE_TOKEN;</span>
 203 |     | <span class='unexecuted'>    if (BASE_IS_POD) {</span>
 204 |     | <span class='unexecuted'>      IDecentralizedIndex.IndexAssetInfo[]</span>
 205 |     | <span class='unexecuted'>        memory _baseAssets = IDecentralizedIndex(BASE_TOKEN).getAllAssets();</span>
 206 |     | <span class='unexecuted'>      _base = _baseAssets[0].token;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'>  }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>  function _checkAndHandleBaseTokenPodConfig(</span>
 211 |     | <span class='neutral'>    uint256 _currentPrice18</span>
 212 |     | <span class='unexecuted'>  ) internal view returns (uint256 _finalPrice18) {</span>
 213 |     | <span class='unexecuted'>    _finalPrice18 = _accountForCBRInPrice(</span>
 214 |     | <span class='unexecuted'>      BASE_TOKEN,</span>
 215 |     | <span class='unexecuted'>      address(0),</span>
 216 |     | <span class='unexecuted'>      _currentPrice18</span>
 217 |     | <span class='neutral'>    );</span>
 218 |     | <span class='unexecuted'>    _finalPrice18 = _accountForUnwrapFeeInPrice(BASE_TOKEN, _finalPrice18);</span>
 219 |     | <span class='neutral'>  }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>  function _chainlinkBasePerPaired18()</span>
 222 |     | <span class='neutral'>    internal</span>
 223 |     | <span class='neutral'>    view</span>
 224 |     | <span class='neutral'>    returns (uint256 _price18)</span>
 225 |     | <span class='neutral'>  {</span>
 226 |     | <span class='unexecuted'>    (bool _isBadData, uint256 _basePerPaired18) = IMinimalSinglePriceOracle(</span>
 227 |     | <span class='unexecuted'>      CHAINLINK_SINGLE_PRICE_ORACLE</span>
 228 |     | <span class='neutral'>    ).getPriceUSD18(</span>
 229 |     | <span class='unexecuted'>        CHAINLINK_QUOTE_PRICE_FEED,</span>
 230 |     | <span class='unexecuted'>        CHAINLINK_BASE_PRICE_FEED,</span>
 231 |     | <span class='neutral'>        address(0),</span>
 232 |     | <span class='neutral'>        0</span>
 233 |     | <span class='neutral'>      );</span>
 234 |     | <span class='unexecuted'>    if (_isBadData) {</span>
 235 |     | <span class='unexecuted'>      return 0;</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='unexecuted'>    _price18 = _basePerPaired18;</span>
 238 |     | <span class='neutral'>  }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>  function _getPair() private view returns (address) {</span>
 241 |     | <span class='unexecuted'>    return IStakingPoolToken(SP_TKN).stakingToken();</span>
 242 |     | <span class='neutral'>  }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>  function _accountForCBRInPrice(</span>
 245 |     | <span class='neutral'>    address _pod,</span>
 246 |     | <span class='neutral'>    address _underlying,</span>
 247 |     | <span class='neutral'>    uint256 _amtUnderlying</span>
 248 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 249 |     | <span class='unexecuted'>    require(IDecentralizedIndex(_pod).unlocked() == 1, &#39;OU&#39;);</span>
 250 |     | <span class='unexecuted'>    if (_underlying == address(0)) {</span>
 251 |     | <span class='unexecuted'>      IDecentralizedIndex.IndexAssetInfo[] memory _assets = IDecentralizedIndex(</span>
 252 |     | <span class='unexecuted'>        _pod</span>
 253 |     | <span class='neutral'>      ).getAllAssets();</span>
 254 |     | <span class='unexecuted'>      _underlying = _assets[0].token;</span>
 255 |     | <span class='neutral'>    }</span>
 256 |     | <span class='unexecuted'>    return</span>
 257 |     | <span class='unexecuted'>      (_amtUnderlying *</span>
 258 |     | <span class='unexecuted'>        IERC20(_underlying).balanceOf(_pod) *</span>
 259 |     | <span class='unexecuted'>        10 ** IERC20Metadata(_pod).decimals()) /</span>
 260 |     | <span class='unexecuted'>      IERC20(_pod).totalSupply() /</span>
 261 |     | <span class='unexecuted'>      10 ** IERC20Metadata(_underlying).decimals();</span>
 262 |     | <span class='neutral'>  }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='unexecuted'>  function _accountForUnwrapFeeInPrice(</span>
 265 |     | <span class='neutral'>    address _pod,</span>
 266 |     | <span class='neutral'>    uint256 _currentPrice</span>
 267 |     | <span class='unexecuted'>  ) internal view returns (uint256 _newPrice) {</span>
 268 |     | <span class='unexecuted'>    uint16 _unwrapFee = IDecentralizedIndex(_pod).DEBOND_FEE();</span>
 269 |     | <span class='unexecuted'>    _newPrice = _currentPrice - (_currentPrice * _unwrapFee) / 10000;</span>
 270 |     | <span class='neutral'>  }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='unexecuted'>  function _sqrt(uint256 x) private pure returns (uint256 y) {</span>
 273 |     | <span class='unexecuted'>    uint256 z = (x + 1) / 2;</span>
 274 |     | <span class='unexecuted'>    y = x;</span>
 275 |     | <span class='unexecuted'>    while (z &lt; y) {</span>
 276 |     | <span class='unexecuted'>      y = z;</span>
 277 |     | <span class='unexecuted'>      z = (x / z + z) / 2;</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'>  }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>  function setTwapInterval(uint32 _interval) external onlyOwner {</span>
 282 |     | <span class='unexecuted'>    twapInterval = _interval;</span>
 283 |     | <span class='neutral'>  }</span>
 284 |     | <span class='neutral'>}</span>
 285 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/test/TestERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract TestERC20 is ERC20 {</span>
  7 |     | <span class='unexecuted'>  constructor(</span>
  8 |     | <span class='neutral'>    string memory _name,</span>
  9 |     | <span class='neutral'>    string memory _symbol</span>
 10 |     | <span class='unexecuted'>  ) ERC20(_name, _symbol) {</span>
 11 |     | <span class='unexecuted'>    _mint(_msgSender(), 10_000_000 * 10 ** 18);</span>
 12 |     | <span class='neutral'>  }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>  function burn(uint256 _amount) external {</span>
 15 |     | <span class='unexecuted'>    _burn(_msgSender(), _amount);</span>
 16 |     | <span class='neutral'>  }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/test/TestERC4626Vault.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/ERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/ILendingAssetVault.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract TestERC4626Vault is IERC4626, ERC20, ERC20Permit {</span>
  11 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>  uint256 constant PRECISION = 10 ** 18;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>  address _asset;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>  constructor(</span>
  18 |     | <span class='neutral'>    address __asset</span>
  19 |     | <span class='neutral'>  ) ERC20(&#39;Test Vault&#39;, &#39;tVAULT&#39;) ERC20Permit(&#39;Test Vault&#39;) {</span>
  20 |     | <span class='unexecuted'>    _asset = __asset;</span>
  21 |     | <span class='neutral'>  }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>  // Needed for LendingAssetVault</span>
  24 |     | <span class='unexecuted'>  function addInterest() external {}</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>  function asset() external view override returns (address) {</span>
  27 |     | <span class='unexecuted'>    return _asset;</span>
  28 |     | <span class='neutral'>  }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>  function totalAssets() public view override returns (uint256) {</span>
  31 |     | <span class='unexecuted'>    return IERC20(_asset).balanceOf(address(this));</span>
  32 |     | <span class='neutral'>  }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>  function convertToShares(</span>
  35 |     | <span class='neutral'>    uint256 _assets</span>
  36 |     | <span class='unexecuted'>  ) public view override returns (uint256 _shares) {</span>
  37 |     | <span class='unexecuted'>    _shares = (_assets * PRECISION) / _cbr();</span>
  38 |     | <span class='neutral'>  }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>  function convertToAssets(</span>
  41 |     | <span class='neutral'>    uint256 _shares</span>
  42 |     | <span class='unexecuted'>  ) public view override returns (uint256 _assets) {</span>
  43 |     | <span class='unexecuted'>    _assets = (_shares * _cbr()) / PRECISION;</span>
  44 |     | <span class='neutral'>  }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>  function maxDeposit(</span>
  47 |     | <span class='neutral'>    address</span>
  48 |     | <span class='unexecuted'>  ) external pure override returns (uint256 maxAssets) {</span>
  49 |     | <span class='unexecuted'>    maxAssets = type(uint256).max - 1;</span>
  50 |     | <span class='neutral'>  }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>  function previewDeposit(</span>
  53 |     | <span class='neutral'>    uint256 _assets</span>
  54 |     | <span class='neutral'>  ) external view override returns (uint256 _shares) {</span>
  55 |     | <span class='neutral'>    _shares = convertToShares(_assets);</span>
  56 |     | <span class='neutral'>  }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>  function deposit(</span>
  59 |     | <span class='neutral'>    uint256 _assets,</span>
  60 |     | <span class='neutral'>    address _receiver</span>
  61 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
  62 |     | <span class='unexecuted'>    _shares = _deposit(_assets, _receiver, _msgSender());</span>
  63 |     | <span class='neutral'>  }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='unexecuted'>  function depositFromLendingAssetVault(</span>
  66 |     | <span class='neutral'>    address _vault,</span>
  67 |     | <span class='neutral'>    uint256 _amountAssets</span>
  68 |     | <span class='unexecuted'>  ) external {</span>
  69 |     | <span class='unexecuted'>    ILendingAssetVault(_vault).whitelistWithdraw(_amountAssets);</span>
  70 |     | <span class='unexecuted'>    uint256 _newShares = _deposit(_amountAssets, address(this), address(this));</span>
  71 |     | <span class='unexecuted'>    _transfer(address(this), _vault, _newShares);</span>
  72 |     | <span class='neutral'>  }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='unexecuted'>  function withdrawToLendingAssetVault(</span>
  75 |     | <span class='neutral'>    address _vault,</span>
  76 |     | <span class='neutral'>    uint256 _amountAssets</span>
  77 |     | <span class='unexecuted'>  ) external {</span>
  78 |     | <span class='unexecuted'>    uint256 _shares = convertToShares(_amountAssets);</span>
  79 |     | <span class='unexecuted'>    _transfer(_vault, address(this), _shares);</span>
  80 |     | <span class='unexecuted'>    IERC20(_asset).approve(_vault, _amountAssets);</span>
  81 |     | <span class='unexecuted'>    ILendingAssetVault(_vault).whitelistDeposit(_amountAssets);</span>
  82 |     | <span class='unexecuted'>    _withdraw(_shares, address(this), address(this));</span>
  83 |     | <span class='neutral'>  }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='unexecuted'>  function _deposit(</span>
  86 |     | <span class='neutral'>    uint256 _assets,</span>
  87 |     | <span class='neutral'>    address _receiver,</span>
  88 |     | <span class='neutral'>    address _owner</span>
  89 |     | <span class='unexecuted'>  ) internal returns (uint256 _shares) {</span>
  90 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
  91 |     | <span class='unexecuted'>    _mint(_receiver, _shares);</span>
  92 |     | <span class='unexecuted'>    if (_owner != address(this)) {</span>
  93 |     | <span class='unexecuted'>      IERC20(_asset).safeTransferFrom(_owner, address(this), _assets);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='unexecuted'>    emit Deposit(_owner, _receiver, _assets, _shares);</span>
  96 |     | <span class='neutral'>  }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>  function maxMint(address) external pure override returns (uint256 maxShares) {</span>
  99 |     | <span class='neutral'>    maxShares = type(uint256).max - 1;</span>
 100 |     | <span class='neutral'>  }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>  function previewMint(</span>
 103 |     | <span class='neutral'>    uint256 _shares</span>
 104 |     | <span class='neutral'>  ) external view override returns (uint256 _assets) {</span>
 105 |     | <span class='neutral'>    _assets = convertToAssets(_shares);</span>
 106 |     | <span class='neutral'>  }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='unexecuted'>  function mint(</span>
 109 |     | <span class='neutral'>    uint256 _shares,</span>
 110 |     | <span class='neutral'>    address _receiver</span>
 111 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 112 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 113 |     | <span class='unexecuted'>    _deposit(_assets, _receiver, _msgSender());</span>
 114 |     | <span class='neutral'>  }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>  function maxWithdraw(</span>
 117 |     | <span class='neutral'>    address _owner</span>
 118 |     | <span class='unexecuted'>  ) external view override returns (uint256 _maxAssets) {</span>
 119 |     | <span class='unexecuted'>    _maxAssets = (balanceOf(_owner) * _cbr()) / PRECISION;</span>
 120 |     | <span class='neutral'>  }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>  function previewWithdraw(</span>
 123 |     | <span class='neutral'>    uint256 _assets</span>
 124 |     | <span class='unexecuted'>  ) external view override returns (uint256 _shares) {</span>
 125 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 126 |     | <span class='neutral'>  }</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>  function withdraw(</span>
 129 |     | <span class='neutral'>    uint256 _assets,</span>
 130 |     | <span class='neutral'>    address _receiver,</span>
 131 |     | <span class='neutral'>    address</span>
 132 |     | <span class='unexecuted'>  ) external override returns (uint256 _shares) {</span>
 133 |     | <span class='unexecuted'>    _shares = convertToShares(_assets);</span>
 134 |     | <span class='unexecuted'>    _withdraw(_shares, _receiver, _msgSender());</span>
 135 |     | <span class='neutral'>  }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='unexecuted'>  function maxRedeem(</span>
 138 |     | <span class='neutral'>    address _owner</span>
 139 |     | <span class='unexecuted'>  ) external view override returns (uint256 _maxShares) {</span>
 140 |     | <span class='unexecuted'>    _maxShares = balanceOf(_owner);</span>
 141 |     | <span class='neutral'>  }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>  function previewRedeem(</span>
 144 |     | <span class='neutral'>    uint256 _shares</span>
 145 |     | <span class='unexecuted'>  ) external view override returns (uint256 _assets) {</span>
 146 |     | <span class='unexecuted'>    return convertToAssets(_shares);</span>
 147 |     | <span class='neutral'>  }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='unexecuted'>  function redeem(</span>
 150 |     | <span class='neutral'>    uint256 _shares,</span>
 151 |     | <span class='neutral'>    address _receiver,</span>
 152 |     | <span class='neutral'>    address</span>
 153 |     | <span class='unexecuted'>  ) external override returns (uint256 _assets) {</span>
 154 |     | <span class='unexecuted'>    _assets = _withdraw(_shares, _receiver, _msgSender());</span>
 155 |     | <span class='neutral'>  }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>  function _withdraw(</span>
 158 |     | <span class='neutral'>    uint256 _shares,</span>
 159 |     | <span class='neutral'>    address _receiver,</span>
 160 |     | <span class='neutral'>    address _owner</span>
 161 |     | <span class='unexecuted'>  ) internal returns (uint256 _assets) {</span>
 162 |     | <span class='unexecuted'>    _assets = convertToAssets(_shares);</span>
 163 |     | <span class='unexecuted'>    _burn(_owner, _shares);</span>
 164 |     | <span class='unexecuted'>    IERC20(_asset).safeTransfer(_receiver, _assets);</span>
 165 |     | <span class='unexecuted'>    emit Withdraw(_owner, _receiver, _receiver, _assets, _shares);</span>
 166 |     | <span class='neutral'>  }</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>  function _cbr() internal view returns (uint256) {</span>
 169 |     | <span class='unexecuted'>    uint256 _supply = totalSupply();</span>
 170 |     | <span class='unexecuted'>    return _supply == 0 ? PRECISION : (PRECISION * totalAssets()) / _supply;</span>
 171 |     | <span class='neutral'>  }</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>  function _assetDecimals() internal view returns (uint8) {</span>
 174 |     | <span class='neutral'>    return IERC20Metadata(_asset).decimals();</span>
 175 |     | <span class='neutral'>  }</span>
 176 |     | <span class='neutral'>}</span>
 177 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/contracts/twaputils/V3TwapUtilities.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;../interfaces/IERC20Metadata.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;../interfaces/IUniswapV3Pool.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;../interfaces/IV3TwapUtilities.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../libraries/FullMath.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../libraries/PoolAddress.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../libraries/TickMath.sol&#39;;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>contract V3TwapUtilities is IV3TwapUtilities, Ownable {</span>
  14 |     | <span class='unexecuted'>  uint32 constant INTERVAL = 10 minutes;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='unexecuted'>  function getV3Pool(</span>
  17 |     | <span class='neutral'>    address _v3Factory,</span>
  18 |     | <span class='neutral'>    address _t0,</span>
  19 |     | <span class='neutral'>    address _t1,</span>
  20 |     | <span class='neutral'>    uint24 _poolFee</span>
  21 |     | <span class='unexecuted'>  ) external pure override returns (address) {</span>
  22 |     | <span class='unexecuted'>    (address _token0, address _token1) = _t0 &lt; _t1 ? (_t0, _t1) : (_t1, _t0);</span>
  23 |     | <span class='unexecuted'>    PoolAddress.PoolKey memory _key = PoolAddress.PoolKey({</span>
  24 |     | <span class='unexecuted'>      token0: _token0,</span>
  25 |     | <span class='unexecuted'>      token1: _token1,</span>
  26 |     | <span class='unexecuted'>      fee: _poolFee</span>
  27 |     | <span class='neutral'>    });</span>
  28 |     | <span class='unexecuted'>    return PoolAddress.computeAddress(_v3Factory, _key);</span>
  29 |     | <span class='neutral'>  }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='unexecuted'>  function getV3Pool(</span>
  32 |     | <span class='neutral'>    address,</span>
  33 |     | <span class='neutral'>    address,</span>
  34 |     | <span class='neutral'>    address,</span>
  35 |     | <span class='neutral'>    int24</span>
  36 |     | <span class='unexecuted'>  ) external pure override returns (address) {</span>
  37 |     | <span class='unexecuted'>    require(false, &#39;I0&#39;);</span>
  38 |     | <span class='neutral'>    return address(0);</span>
  39 |     | <span class='neutral'>  }</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>  function getV3Pool(</span>
  42 |     | <span class='neutral'>    address,</span>
  43 |     | <span class='neutral'>    address,</span>
  44 |     | <span class='neutral'>    address</span>
  45 |     | <span class='unexecuted'>  ) external pure override returns (address) {</span>
  46 |     | <span class='unexecuted'>    require(false, &#39;I1&#39;);</span>
  47 |     | <span class='neutral'>    return address(0);</span>
  48 |     | <span class='neutral'>  }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>  function getPoolPriceUSDX96(</span>
  51 |     | <span class='neutral'>    address _pricePool,</span>
  52 |     | <span class='neutral'>    address _nativeStablePool,</span>
  53 |     | <span class='neutral'>    address _WETH9</span>
  54 |     | <span class='unexecuted'>  ) public view override returns (uint256) {</span>
  55 |     | <span class='unexecuted'>    address _token0 = IUniswapV3Pool(_nativeStablePool).token0();</span>
  56 |     | <span class='unexecuted'>    uint256 _priceStableWETH9X96 = _adjustedPriceX96(</span>
  57 |     | <span class='unexecuted'>      IUniswapV3Pool(_nativeStablePool),</span>
  58 |     | <span class='unexecuted'>      _token0 == _WETH9 ? IUniswapV3Pool(_nativeStablePool).token1() : _token0</span>
  59 |     | <span class='neutral'>    );</span>
  60 |     | <span class='unexecuted'>    if (_pricePool == _nativeStablePool) {</span>
  61 |     | <span class='unexecuted'>      return _priceStableWETH9X96;</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='unexecuted'>    uint256 _priceMainX96 = _adjustedPriceX96(</span>
  64 |     | <span class='unexecuted'>      IUniswapV3Pool(_pricePool),</span>
  65 |     | <span class='unexecuted'>      _WETH9</span>
  66 |     | <span class='neutral'>    );</span>
  67 |     | <span class='unexecuted'>    return (_priceStableWETH9X96 * _priceMainX96) / FixedPoint96.Q96;</span>
  68 |     | <span class='neutral'>  }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>  function sqrtPriceX96FromPoolAndInterval(</span>
  71 |     | <span class='neutral'>    address _poolAddress</span>
  72 |     | <span class='unexecuted'>  ) public view override returns (uint160 sqrtPriceX96) {</span>
  73 |     | <span class='unexecuted'>    sqrtPriceX96 = _sqrtPriceX96FromPoolAndInterval(_poolAddress, INTERVAL);</span>
  74 |     | <span class='neutral'>  }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>  function sqrtPriceX96FromPoolAndPassedInterval(</span>
  77 |     | <span class='neutral'>    address _poolAddress,</span>
  78 |     | <span class='neutral'>    uint32 _interval</span>
  79 |     | <span class='unexecuted'>  ) external view override returns (uint160 sqrtPriceX96) {</span>
  80 |     | <span class='unexecuted'>    sqrtPriceX96 = _sqrtPriceX96FromPoolAndInterval(_poolAddress, _interval);</span>
  81 |     | <span class='neutral'>  }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>  function _sqrtPriceX96FromPoolAndInterval(</span>
  84 |     | <span class='neutral'>    address _poolAddress,</span>
  85 |     | <span class='neutral'>    uint32 _interval</span>
  86 |     | <span class='unexecuted'>  ) internal view returns (uint160 sqrtPriceX96) {</span>
  87 |     | <span class='unexecuted'>    IUniswapV3Pool _pool = IUniswapV3Pool(_poolAddress);</span>
  88 |     | <span class='unexecuted'>    if (_interval == 0) {</span>
  89 |     | <span class='unexecuted'>      (sqrtPriceX96, , , , , , ) = _pool.slot0();</span>
  90 |     | <span class='unexecuted'>    } else {</span>
  91 |     | <span class='unexecuted'>      uint32[] memory secondsAgo = new uint32[](2);</span>
  92 |     | <span class='unexecuted'>      secondsAgo[0] = _interval;</span>
  93 |     | <span class='unexecuted'>      secondsAgo[1] = 0;</span>
  94 |     | <span class='unexecuted'>      (int56[] memory tickCumulatives, ) = _pool.observe(secondsAgo);</span>
  95 |     | <span class='unexecuted'>      sqrtPriceX96 = TickMath.getSqrtRatioAtTick(</span>
  96 |     | <span class='unexecuted'>        int24((tickCumulatives[1] - tickCumulatives[0]) / int32(_interval))</span>
  97 |     | <span class='neutral'>      );</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>  }</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>  function priceX96FromSqrtPriceX96(</span>
 102 |     | <span class='neutral'>    uint160 sqrtPriceX96</span>
 103 |     | <span class='unexecuted'>  ) public pure override returns (uint256 priceX96) {</span>
 104 |     | <span class='unexecuted'>    return FullMath.mulDiv(sqrtPriceX96, sqrtPriceX96, FixedPoint96.Q96);</span>
 105 |     | <span class='neutral'>  }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='unexecuted'>  function _adjustedPriceX96(</span>
 108 |     | <span class='neutral'>    IUniswapV3Pool _pool,</span>
 109 |     | <span class='neutral'>    address _numeratorToken</span>
 110 |     | <span class='unexecuted'>  ) internal view returns (uint256) {</span>
 111 |     | <span class='unexecuted'>    address _token1 = _pool.token1();</span>
 112 |     | <span class='unexecuted'>    uint8 _decimals0 = IERC20Metadata(_pool.token0()).decimals();</span>
 113 |     | <span class='unexecuted'>    uint8 _decimals1 = IERC20Metadata(_token1).decimals();</span>
 114 |     | <span class='unexecuted'>    uint160 _sqrtPriceX96 = sqrtPriceX96FromPoolAndInterval(address(_pool));</span>
 115 |     | <span class='unexecuted'>    uint256 _priceX96 = priceX96FromSqrtPriceX96(_sqrtPriceX96);</span>
 116 |     | <span class='unexecuted'>    uint256 _ratioPriceX96 = _token1 == _numeratorToken</span>
 117 |     | <span class='unexecuted'>      ? _priceX96</span>
 118 |     | <span class='unexecuted'>      : FixedPoint96.Q96 ** 2 / _priceX96;</span>
 119 |     | <span class='unexecuted'>    return</span>
 120 |     | <span class='unexecuted'>      _token1 == _numeratorToken</span>
 121 |     | <span class='unexecuted'>        ? (_ratioPriceX96 * 10 ** _decimals0) / 10 ** _decimals1</span>
 122 |     | <span class='unexecuted'>        : (_ratioPriceX96 * 10 ** _decimals1) / 10 ** _decimals0;</span>
 123 |     | <span class='neutral'>  }</span>
 124 |     | <span class='neutral'>}</span>
 125 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Base.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {StdStorage} from &quot;./StdStorage.sol&quot;;</span>
  5 |     | <span class='neutral'>import {Vm, VmSafe} from &quot;./Vm.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract CommonBase {</span>
  8 |     | <span class='neutral'>    // Cheat code address, 0x7109709ECfa91a80626fF3989D68f67F5b1DD12D.</span>
  9 |     | <span class='neutral'>    address internal constant VM_ADDRESS = address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;))));</span>
 10 |     | <span class='neutral'>    // console.sol and console2.sol work by executing a staticcall to this address.</span>
 11 |     | <span class='neutral'>    address internal constant CONSOLE = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 12 |     | <span class='neutral'>    // Used when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
 13 |     | <span class='neutral'>    address internal constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
 14 |     | <span class='neutral'>    // Default address for tx.origin and msg.sender, 0x1804c8AB1F12E6bbf3894d4083f33e07309d1f38.</span>
 15 |     | <span class='neutral'>    address internal constant DEFAULT_SENDER = address(uint160(uint256(keccak256(&quot;foundry default caller&quot;))));</span>
 16 |     | <span class='neutral'>    // Address of the test contract, deployed by the DEFAULT_SENDER.</span>
 17 |     | <span class='neutral'>    address internal constant DEFAULT_TEST_CONTRACT = 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f;</span>
 18 |     | <span class='neutral'>    // Deterministic deployment address of the Multicall3 contract.</span>
 19 |     | <span class='neutral'>    address internal constant MULTICALL3_ADDRESS = 0xcA11bde05977b3631167028862bE2a173976CA11;</span>
 20 |     | <span class='neutral'>    // The order of the secp256k1 curve.</span>
 21 |     | <span class='neutral'>    uint256 internal constant SECP256K1_ORDER =</span>
 22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    uint256 internal constant UINT256_MAX =</span>
 25 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    Vm internal constant vm = Vm(VM_ADDRESS);</span>
 28 |     | <span class='neutral'>    StdStorage internal stdstore;</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>abstract contract TestBase is CommonBase {}</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>abstract contract ScriptBase is CommonBase {</span>
 34 |     | <span class='neutral'>    VmSafe internal constant vmSafe = VmSafe(VM_ADDRESS);</span>
 35 |     | <span class='neutral'>}</span>
 36 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdAssertions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>abstract contract StdAssertions {</span>
   8 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    event log(string);</span>
  11 |     | <span class='neutral'>    event logs(bytes);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    event log_address(address);</span>
  14 |     | <span class='neutral'>    event log_bytes32(bytes32);</span>
  15 |     | <span class='neutral'>    event log_int(int256);</span>
  16 |     | <span class='neutral'>    event log_uint(uint256);</span>
  17 |     | <span class='neutral'>    event log_bytes(bytes);</span>
  18 |     | <span class='neutral'>    event log_string(string);</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>    event log_named_address(string key, address val);</span>
  21 |     | <span class='neutral'>    event log_named_bytes32(string key, bytes32 val);</span>
  22 |     | <span class='neutral'>    event log_named_decimal_int(string key, int256 val, uint256 decimals);</span>
  23 |     | <span class='neutral'>    event log_named_decimal_uint(string key, uint256 val, uint256 decimals);</span>
  24 |     | <span class='neutral'>    event log_named_int(string key, int256 val);</span>
  25 |     | <span class='neutral'>    event log_named_uint(string key, uint256 val);</span>
  26 |     | <span class='neutral'>    event log_named_bytes(string key, bytes val);</span>
  27 |     | <span class='neutral'>    event log_named_string(string key, string val);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    event log_array(uint256[] val);</span>
  30 |     | <span class='neutral'>    event log_array(int256[] val);</span>
  31 |     | <span class='neutral'>    event log_array(address[] val);</span>
  32 |     | <span class='neutral'>    event log_named_array(string key, uint256[] val);</span>
  33 |     | <span class='neutral'>    event log_named_array(string key, int256[] val);</span>
  34 |     | <span class='neutral'>    event log_named_array(string key, address[] val);</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    bool private _failed;</span>
  37 |     | <span class='neutral'></span>
  38 | *   | <span class='executed'>    function failed() public view returns (bool) {</span>
  39 | *   | <span class='executed'>        if (_failed) {</span>
  40 |     | <span class='unexecuted'>            return _failed;</span>
  41 |     | <span class='neutral'>        } else {</span>
  42 | *   | <span class='executed'>            return vm.load(address(vm), bytes32(&quot;failed&quot;)) != bytes32(0);</span>
  43 |     | <span class='neutral'>        }</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function fail() internal virtual {</span>
  47 |     | <span class='neutral'>        vm.store(address(vm), bytes32(&quot;failed&quot;), bytes32(uint256(1)));</span>
  48 |     | <span class='neutral'>        _failed = true;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    function assertTrue(bool data) internal pure virtual {</span>
  52 |     | <span class='neutral'>        vm.assertTrue(data);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    function assertTrue(bool data, string memory err) internal pure virtual {</span>
  56 |     | <span class='neutral'>        vm.assertTrue(data, err);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    function assertFalse(bool data) internal pure virtual {</span>
  60 |     | <span class='neutral'>        vm.assertFalse(data);</span>
  61 |     | <span class='neutral'>    }</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    function assertFalse(bool data, string memory err) internal pure virtual {</span>
  64 |     | <span class='neutral'>        vm.assertFalse(data, err);</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    function assertEq(bool left, bool right) internal pure virtual {</span>
  68 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    function assertEq(bool left, bool right, string memory err) internal pure virtual {</span>
  72 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) internal pure virtual {</span>
  76 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
  80 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
  84 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
  88 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) internal pure virtual {</span>
  92 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
  96 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 100 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 104 |     | <span class='neutral'>        vm.assertEqDecimal(left, right, decimals, err);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function assertEq(address left, address right) internal pure virtual {</span>
 108 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    function assertEq(address left, address right, string memory err) internal pure virtual {</span>
 112 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 116 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 120 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 124 |     | <span class='neutral'>        assertEq(left, right);</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    function assertEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 128 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    function assertEq(string memory left, string memory right) internal pure virtual {</span>
 132 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function assertEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 136 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 140 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    function assertEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 144 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 148 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function assertEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 152 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 156 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    function assertEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 160 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 164 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    function assertEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 168 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 172 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='neutral'>    function assertEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 176 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 180 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function assertEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 184 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 188 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function assertEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 192 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 196 |     | <span class='neutral'>        vm.assertEq(left, right);</span>
 197 |     | <span class='neutral'>    }</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function assertEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 200 |     | <span class='neutral'>        vm.assertEq(left, right, err);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // Legacy helper</span>
 204 |     | <span class='neutral'>    function assertEqUint(uint256 left, uint256 right) internal pure virtual {</span>
 205 |     | <span class='neutral'>        assertEq(left, right);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) internal pure virtual {</span>
 209 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string memory err) internal pure virtual {</span>
 213 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) internal pure virtual {</span>
 217 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 221 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 225 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string memory err)</span>
 229 |     | <span class='neutral'>        internal</span>
 230 |     | <span class='neutral'>        pure</span>
 231 |     | <span class='neutral'>        virtual</span>
 232 |     | <span class='neutral'>    {</span>
 233 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 234 |     | <span class='neutral'>    }</span>
 235 |     | <span class='neutral'></span>
 236 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) internal pure virtual {</span>
 237 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string memory err) internal pure virtual {</span>
 241 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 242 |     | <span class='neutral'>    }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 245 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals);</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 249 |     | <span class='neutral'>        vm.assertNotEqDecimal(left, right, decimals, err);</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    function assertNotEq(address left, address right) internal pure virtual {</span>
 253 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assertNotEq(address left, address right, string memory err) internal pure virtual {</span>
 257 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) internal pure virtual {</span>
 261 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 262 |     | <span class='neutral'>    }</span>
 263 |     | <span class='neutral'></span>
 264 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 265 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right) internal pure virtual {</span>
 269 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 270 |     | <span class='neutral'>    }</span>
 271 |     | <span class='neutral'></span>
 272 |     | <span class='neutral'>    function assertNotEq32(bytes32 left, bytes32 right, string memory err) internal pure virtual {</span>
 273 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 274 |     | <span class='neutral'>    }</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right) internal pure virtual {</span>
 277 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    function assertNotEq(string memory left, string memory right, string memory err) internal pure virtual {</span>
 281 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 282 |     | <span class='neutral'>    }</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right) internal pure virtual {</span>
 285 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    function assertNotEq(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 289 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right) internal pure virtual {</span>
 293 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>    function assertNotEq(bool[] memory left, bool[] memory right, string memory err) internal pure virtual {</span>
 297 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'></span>
 300 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right) internal pure virtual {</span>
 301 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    function assertNotEq(uint256[] memory left, uint256[] memory right, string memory err) internal pure virtual {</span>
 305 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right) internal pure virtual {</span>
 309 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 310 |     | <span class='neutral'>    }</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>    function assertNotEq(int256[] memory left, int256[] memory right, string memory err) internal pure virtual {</span>
 313 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right) internal pure virtual {</span>
 317 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='neutral'>    function assertNotEq(address[] memory left, address[] memory right, string memory err) internal pure virtual {</span>
 321 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right) internal pure virtual {</span>
 325 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    function assertNotEq(bytes32[] memory left, bytes32[] memory right, string memory err) internal pure virtual {</span>
 329 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 330 |     | <span class='neutral'>    }</span>
 331 |     | <span class='neutral'></span>
 332 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right) internal pure virtual {</span>
 333 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    function assertNotEq(string[] memory left, string[] memory right, string memory err) internal pure virtual {</span>
 337 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right) internal pure virtual {</span>
 341 |     | <span class='neutral'>        vm.assertNotEq(left, right);</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assertNotEq(bytes[] memory left, bytes[] memory right, string memory err) internal pure virtual {</span>
 345 |     | <span class='neutral'>        vm.assertNotEq(left, right, err);</span>
 346 |     | <span class='neutral'>    }</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) internal pure virtual {</span>
 349 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 353 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 354 |     | <span class='neutral'>    }</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 357 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 361 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 362 |     | <span class='neutral'>    }</span>
 363 |     | <span class='neutral'></span>
 364 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) internal pure virtual {</span>
 365 |     | <span class='neutral'>        vm.assertLt(left, right);</span>
 366 |     | <span class='neutral'>    }</span>
 367 |     | <span class='neutral'></span>
 368 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 369 |     | <span class='neutral'>        vm.assertLt(left, right, err);</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 373 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals);</span>
 374 |     | <span class='neutral'>    }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 377 |     | <span class='neutral'>        vm.assertLtDecimal(left, right, decimals, err);</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) internal pure virtual {</span>
 381 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 382 |     | <span class='neutral'>    }</span>
 383 |     | <span class='neutral'></span>
 384 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 385 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 389 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 390 |     | <span class='neutral'>    }</span>
 391 |     | <span class='neutral'></span>
 392 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 393 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) internal pure virtual {</span>
 397 |     | <span class='neutral'>        vm.assertGt(left, right);</span>
 398 |     | <span class='neutral'>    }</span>
 399 |     | <span class='neutral'></span>
 400 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string memory err) internal pure virtual {</span>
 401 |     | <span class='neutral'>        vm.assertGt(left, right, err);</span>
 402 |     | <span class='neutral'>    }</span>
 403 |     | <span class='neutral'></span>
 404 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 405 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals);</span>
 406 |     | <span class='neutral'>    }</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 409 |     | <span class='neutral'>        vm.assertGtDecimal(left, right, decimals, err);</span>
 410 |     | <span class='neutral'>    }</span>
 411 |     | <span class='neutral'></span>
 412 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) internal pure virtual {</span>
 413 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 417 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 418 |     | <span class='neutral'>    }</span>
 419 |     | <span class='neutral'></span>
 420 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 421 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 425 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 426 |     | <span class='neutral'>    }</span>
 427 |     | <span class='neutral'></span>
 428 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) internal pure virtual {</span>
 429 |     | <span class='neutral'>        vm.assertLe(left, right);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 433 |     | <span class='neutral'>        vm.assertLe(left, right, err);</span>
 434 |     | <span class='neutral'>    }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 437 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 441 |     | <span class='neutral'>        vm.assertLeDecimal(left, right, decimals, err);</span>
 442 |     | <span class='neutral'>    }</span>
 443 |     | <span class='neutral'></span>
 444 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) internal pure virtual {</span>
 445 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string memory err) internal pure virtual {</span>
 449 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 450 |     | <span class='neutral'>    }</span>
 451 |     | <span class='neutral'></span>
 452 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) internal pure virtual {</span>
 453 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 454 |     | <span class='neutral'>    }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 457 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 458 |     | <span class='neutral'>    }</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) internal pure virtual {</span>
 461 |     | <span class='neutral'>        vm.assertGe(left, right);</span>
 462 |     | <span class='neutral'>    }</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string memory err) internal pure virtual {</span>
 465 |     | <span class='neutral'>        vm.assertGe(left, right, err);</span>
 466 |     | <span class='neutral'>    }</span>
 467 |     | <span class='neutral'></span>
 468 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) internal pure virtual {</span>
 469 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals);</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'></span>
 472 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string memory err) internal pure virtual {</span>
 473 |     | <span class='neutral'>        vm.assertGeDecimal(left, right, decimals, err);</span>
 474 |     | <span class='neutral'>    }</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) internal pure virtual {</span>
 477 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 478 |     | <span class='neutral'>    }</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string memory err)</span>
 481 |     | <span class='neutral'>        internal</span>
 482 |     | <span class='neutral'>        pure</span>
 483 |     | <span class='neutral'>        virtual</span>
 484 |     | <span class='neutral'>    {</span>
 485 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 486 |     | <span class='neutral'>    }</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals)</span>
 489 |     | <span class='neutral'>        internal</span>
 490 |     | <span class='neutral'>        pure</span>
 491 |     | <span class='neutral'>        virtual</span>
 492 |     | <span class='neutral'>    {</span>
 493 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 494 |     | <span class='neutral'>    }</span>
 495 |     | <span class='neutral'></span>
 496 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
 497 |     | <span class='neutral'>        uint256 left,</span>
 498 |     | <span class='neutral'>        uint256 right,</span>
 499 |     | <span class='neutral'>        uint256 maxDelta,</span>
 500 |     | <span class='neutral'>        uint256 decimals,</span>
 501 |     | <span class='neutral'>        string memory err</span>
 502 |     | <span class='neutral'>    ) internal pure virtual {</span>
 503 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 504 |     | <span class='neutral'>    }</span>
 505 |     | <span class='neutral'></span>
 506 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) internal pure virtual {</span>
 507 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string memory err) internal pure virtual {</span>
 511 |     | <span class='neutral'>        vm.assertApproxEqAbs(left, right, maxDelta, err);</span>
 512 |     | <span class='neutral'>    }</span>
 513 |     | <span class='neutral'></span>
 514 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals)</span>
 515 |     | <span class='neutral'>        internal</span>
 516 |     | <span class='neutral'>        pure</span>
 517 |     | <span class='neutral'>        virtual</span>
 518 |     | <span class='neutral'>    {</span>
 519 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals);</span>
 520 |     | <span class='neutral'>    }</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals, string memory err)</span>
 523 |     | <span class='neutral'>        internal</span>
 524 |     | <span class='neutral'>        pure</span>
 525 |     | <span class='neutral'>        virtual</span>
 526 |     | <span class='neutral'>    {</span>
 527 |     | <span class='neutral'>        vm.assertApproxEqAbsDecimal(left, right, maxDelta, decimals, err);</span>
 528 |     | <span class='neutral'>    }</span>
 529 |     | <span class='neutral'></span>
 530 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 531 |     | <span class='neutral'>        uint256 left,</span>
 532 |     | <span class='neutral'>        uint256 right,</span>
 533 |     | <span class='neutral'>        uint256 maxPercentDelta // An 18 decimal fixed point number, where 1e18 == 100%</span>
 534 |     | <span class='neutral'>    ) internal pure virtual {</span>
 535 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 539 |     | <span class='neutral'>        uint256 left,</span>
 540 |     | <span class='neutral'>        uint256 right,</span>
 541 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 542 |     | <span class='neutral'>        string memory err</span>
 543 |     | <span class='neutral'>    ) internal pure virtual {</span>
 544 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 545 |     | <span class='neutral'>    }</span>
 546 |     | <span class='neutral'></span>
 547 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 548 |     | <span class='neutral'>        uint256 left,</span>
 549 |     | <span class='neutral'>        uint256 right,</span>
 550 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 551 |     | <span class='neutral'>        uint256 decimals</span>
 552 |     | <span class='neutral'>    ) internal pure virtual {</span>
 553 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 554 |     | <span class='neutral'>    }</span>
 555 |     | <span class='neutral'></span>
 556 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 557 |     | <span class='neutral'>        uint256 left,</span>
 558 |     | <span class='neutral'>        uint256 right,</span>
 559 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 560 |     | <span class='neutral'>        uint256 decimals,</span>
 561 |     | <span class='neutral'>        string memory err</span>
 562 |     | <span class='neutral'>    ) internal pure virtual {</span>
 563 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) internal pure virtual {</span>
 567 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta);</span>
 568 |     | <span class='neutral'>    }</span>
 569 |     | <span class='neutral'></span>
 570 |     | <span class='neutral'>    function assertApproxEqRel(</span>
 571 |     | <span class='neutral'>        int256 left,</span>
 572 |     | <span class='neutral'>        int256 right,</span>
 573 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 574 |     | <span class='neutral'>        string memory err</span>
 575 |     | <span class='neutral'>    ) internal pure virtual {</span>
 576 |     | <span class='neutral'>        vm.assertApproxEqRel(left, right, maxPercentDelta, err);</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 580 |     | <span class='neutral'>        int256 left,</span>
 581 |     | <span class='neutral'>        int256 right,</span>
 582 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 583 |     | <span class='neutral'>        uint256 decimals</span>
 584 |     | <span class='neutral'>    ) internal pure virtual {</span>
 585 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals);</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
 589 |     | <span class='neutral'>        int256 left,</span>
 590 |     | <span class='neutral'>        int256 right,</span>
 591 |     | <span class='neutral'>        uint256 maxPercentDelta, // An 18 decimal fixed point number, where 1e18 == 100%</span>
 592 |     | <span class='neutral'>        uint256 decimals,</span>
 593 |     | <span class='neutral'>        string memory err</span>
 594 |     | <span class='neutral'>    ) internal pure virtual {</span>
 595 |     | <span class='neutral'>        vm.assertApproxEqRelDecimal(left, right, maxPercentDelta, decimals, err);</span>
 596 |     | <span class='neutral'>    }</span>
 597 |     | <span class='neutral'></span>
 598 |     | <span class='neutral'>    // Inherited from DSTest, not used but kept for backwards-compatibility</span>
 599 |     | <span class='neutral'>    function checkEq0(bytes memory left, bytes memory right) internal pure returns (bool) {</span>
 600 |     | <span class='neutral'>        return keccak256(left) == keccak256(right);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 604 |     | <span class='neutral'>        assertEq(left, right);</span>
 605 |     | <span class='neutral'>    }</span>
 606 |     | <span class='neutral'></span>
 607 |     | <span class='neutral'>    function assertEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 608 |     | <span class='neutral'>        assertEq(left, right, err);</span>
 609 |     | <span class='neutral'>    }</span>
 610 |     | <span class='neutral'></span>
 611 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right) internal pure virtual {</span>
 612 |     | <span class='neutral'>        assertNotEq(left, right);</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    function assertNotEq0(bytes memory left, bytes memory right, string memory err) internal pure virtual {</span>
 616 |     | <span class='neutral'>        assertNotEq(left, right, err);</span>
 617 |     | <span class='neutral'>    }</span>
 618 |     | <span class='neutral'></span>
 619 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB) internal virtual {</span>
 620 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, true);</span>
 621 |     | <span class='neutral'>    }</span>
 622 |     | <span class='neutral'></span>
 623 |     | <span class='neutral'>    function assertEqCall(address targetA, bytes memory callDataA, address targetB, bytes memory callDataB)</span>
 624 |     | <span class='neutral'>        internal</span>
 625 |     | <span class='neutral'>        virtual</span>
 626 |     | <span class='neutral'>    {</span>
 627 |     | <span class='neutral'>        assertEqCall(targetA, callDataA, targetB, callDataB, true);</span>
 628 |     | <span class='neutral'>    }</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>    function assertEqCall(address target, bytes memory callDataA, bytes memory callDataB, bool strictRevertData)</span>
 631 |     | <span class='neutral'>        internal</span>
 632 |     | <span class='neutral'>        virtual</span>
 633 |     | <span class='neutral'>    {</span>
 634 |     | <span class='neutral'>        assertEqCall(target, callDataA, target, callDataB, strictRevertData);</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'></span>
 637 |     | <span class='neutral'>    function assertEqCall(</span>
 638 |     | <span class='neutral'>        address targetA,</span>
 639 |     | <span class='neutral'>        bytes memory callDataA,</span>
 640 |     | <span class='neutral'>        address targetB,</span>
 641 |     | <span class='neutral'>        bytes memory callDataB,</span>
 642 |     | <span class='neutral'>        bool strictRevertData</span>
 643 |     | <span class='neutral'>    ) internal virtual {</span>
 644 |     | <span class='neutral'>        (bool successA, bytes memory returnDataA) = address(targetA).call(callDataA);</span>
 645 |     | <span class='neutral'>        (bool successB, bytes memory returnDataB) = address(targetB).call(callDataB);</span>
 646 |     | <span class='neutral'></span>
 647 |     | <span class='neutral'>        if (successA &amp;&amp; successB) {</span>
 648 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call return data does not match&quot;);</span>
 649 |     | <span class='neutral'>        }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>        if (!successA &amp;&amp; !successB &amp;&amp; strictRevertData) {</span>
 652 |     | <span class='neutral'>            assertEq(returnDataA, returnDataB, &quot;Call revert data does not match&quot;);</span>
 653 |     | <span class='neutral'>        }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>        if (!successA &amp;&amp; successB) {</span>
 656 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 657 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call revert data&quot;, returnDataA);</span>
 658 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call return data&quot;, returnDataB);</span>
 659 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 660 |     | <span class='neutral'>        }</span>
 661 |     | <span class='neutral'></span>
 662 |     | <span class='neutral'>        if (successA &amp;&amp; !successB) {</span>
 663 |     | <span class='neutral'>            emit log(&quot;Error: Calls were not equal&quot;);</span>
 664 |     | <span class='neutral'>            emit log_named_bytes(&quot;  Left call return data&quot;, returnDataA);</span>
 665 |     | <span class='neutral'>            emit log_named_bytes(&quot; Right call revert data&quot;, returnDataB);</span>
 666 |     | <span class='neutral'>            revert(&quot;assertion failed&quot;);</span>
 667 |     | <span class='neutral'>        }</span>
 668 |     | <span class='neutral'>    }</span>
 669 |     | <span class='neutral'>}</span>
 670 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdChains.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * StdChains provides information about EVM compatible chains that can be used in scripts/tests.</span>
   8 |     | <span class='neutral'> * For each chain, the chain&#39;s name, chain ID, and a default RPC URL are provided. Chains are</span>
   9 |     | <span class='neutral'> * identified by their alias, which is the same as the alias in the `[rpc_endpoints]` section of</span>
  10 |     | <span class='neutral'> * the `foundry.toml` file. For best UX, ensure the alias in the `foundry.toml` file match the</span>
  11 |     | <span class='neutral'> * alias used in this contract, which can be found as the first argument to the</span>
  12 |     | <span class='neutral'> * `setChainWithDefaultRpcUrl` call in the `initializeStdChains` function.</span>
  13 |     | <span class='neutral'> *</span>
  14 |     | <span class='neutral'> * There are two main ways to use this contract:</span>
  15 |     | <span class='neutral'> *   1. Set a chain with `setChain(string memory chainAlias, ChainData memory chain)` or</span>
  16 |     | <span class='neutral'> *      `setChain(string memory chainAlias, Chain memory chain)`</span>
  17 |     | <span class='neutral'> *   2. Get a chain with `getChain(string memory chainAlias)` or `getChain(uint256 chainId)`.</span>
  18 |     | <span class='neutral'> *</span>
  19 |     | <span class='neutral'> * The first time either of those are used, chains are initialized with the default set of RPC URLs.</span>
  20 |     | <span class='neutral'> * This is done in `initializeStdChains`, which uses `setChainWithDefaultRpcUrl`. Defaults are recorded in</span>
  21 |     | <span class='neutral'> * `defaultRpcUrls`.</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * The `setChain` function is straightforward, and it simply saves off the given chain data.</span>
  24 |     | <span class='neutral'> *</span>
  25 |     | <span class='neutral'> * The `getChain` methods use `getChainWithUpdatedRpcUrl` to return a chain. For example, let&#39;s say</span>
  26 |     | <span class='neutral'> * we want to retrieve the RPC URL for `mainnet`:</span>
  27 |     | <span class='neutral'> *   - If you have specified data with `setChain`, it will return that.</span>
  28 |     | <span class='neutral'> *   - If you have configured a mainnet RPC URL in `foundry.toml`, it will return the URL, provided it</span>
  29 |     | <span class='neutral'> *     is valid (e.g. a URL is specified, or an environment variable is given and exists).</span>
  30 |     | <span class='neutral'> *   - If neither of the above conditions is met, the default data is returned.</span>
  31 |     | <span class='neutral'> *</span>
  32 |     | <span class='neutral'> * Summarizing the above, the prioritization hierarchy is `setChain` -&gt; `foundry.toml` -&gt; environment variable -&gt; defaults.</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='neutral'>abstract contract StdChains {</span>
  35 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    bool private stdChainsInitialized;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct ChainData {</span>
  40 |     | <span class='neutral'>        string name;</span>
  41 |     | <span class='neutral'>        uint256 chainId;</span>
  42 |     | <span class='neutral'>        string rpcUrl;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    struct Chain {</span>
  46 |     | <span class='neutral'>        // The chain name.</span>
  47 |     | <span class='neutral'>        string name;</span>
  48 |     | <span class='neutral'>        // The chain&#39;s Chain ID.</span>
  49 |     | <span class='neutral'>        uint256 chainId;</span>
  50 |     | <span class='neutral'>        // The chain&#39;s alias. (i.e. what gets specified in `foundry.toml`).</span>
  51 |     | <span class='neutral'>        string chainAlias;</span>
  52 |     | <span class='neutral'>        // A default RPC endpoint for this chain.</span>
  53 |     | <span class='neutral'>        // NOTE: This default RPC URL is included for convenience to facilitate quick tests and</span>
  54 |     | <span class='neutral'>        // experimentation. Do not use this RPC URL for production test suites, CI, or other heavy</span>
  55 |     | <span class='neutral'>        // usage as you will be throttled and this is a disservice to others who need this endpoint.</span>
  56 |     | <span class='neutral'>        string rpcUrl;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    // Maps from the chain&#39;s alias (matching the alias in the `foundry.toml` file) to chain data.</span>
  60 |     | <span class='neutral'>    mapping(string =&gt; Chain) private chains;</span>
  61 |     | <span class='neutral'>    // Maps from the chain&#39;s alias to it&#39;s default RPC URL.</span>
  62 |     | <span class='neutral'>    mapping(string =&gt; string) private defaultRpcUrls;</span>
  63 |     | <span class='neutral'>    // Maps from a chain ID to it&#39;s alias.</span>
  64 |     | <span class='neutral'>    mapping(uint256 =&gt; string) private idToAlias;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    bool private fallbackToDefaultRpcUrls = true;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    // The RPC URL will be fetched from config or defaultRpcUrls if possible.</span>
  69 |     | <span class='neutral'>    function getChain(string memory chainAlias) internal virtual returns (Chain memory chain) {</span>
  70 |     | <span class='neutral'>        require(bytes(chainAlias).length != 0, &quot;StdChains getChain(string): Chain alias cannot be the empty string.&quot;);</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>        initializeStdChains();</span>
  73 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  74 |     | <span class='neutral'>        require(</span>
  75 |     | <span class='neutral'>            chain.chainId != 0,</span>
  76 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(string): Chain with alias \&quot;&quot;, chainAlias, &quot;\&quot; not found.&quot;))</span>
  77 |     | <span class='neutral'>        );</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function getChain(uint256 chainId) internal virtual returns (Chain memory chain) {</span>
  83 |     | <span class='neutral'>        require(chainId != 0, &quot;StdChains getChain(uint256): Chain ID cannot be 0.&quot;);</span>
  84 |     | <span class='neutral'>        initializeStdChains();</span>
  85 |     | <span class='neutral'>        string memory chainAlias = idToAlias[chainId];</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>        chain = chains[chainAlias];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        require(</span>
  90 |     | <span class='neutral'>            chain.chainId != 0,</span>
  91 |     | <span class='neutral'>            string(abi.encodePacked(&quot;StdChains getChain(uint256): Chain with ID &quot;, vm.toString(chainId), &quot; not found.&quot;))</span>
  92 |     | <span class='neutral'>        );</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        chain = getChainWithUpdatedRpcUrl(chainAlias, chain);</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
  98 |     | <span class='neutral'>    function setChain(string memory chainAlias, ChainData memory chain) internal virtual {</span>
  99 |     | <span class='neutral'>        require(</span>
 100 |     | <span class='neutral'>            bytes(chainAlias).length != 0,</span>
 101 |     | <span class='neutral'>            &quot;StdChains setChain(string,ChainData): Chain alias cannot be the empty string.&quot;</span>
 102 |     | <span class='neutral'>        );</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>        require(chain.chainId != 0, &quot;StdChains setChain(string,ChainData): Chain ID cannot be 0.&quot;);</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>        initializeStdChains();</span>
 107 |     | <span class='neutral'>        string memory foundAlias = idToAlias[chain.chainId];</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        require(</span>
 110 |     | <span class='neutral'>            bytes(foundAlias).length == 0 || keccak256(bytes(foundAlias)) == keccak256(bytes(chainAlias)),</span>
 111 |     | <span class='neutral'>            string(</span>
 112 |     | <span class='neutral'>                abi.encodePacked(</span>
 113 |     | <span class='neutral'>                    &quot;StdChains setChain(string,ChainData): Chain ID &quot;,</span>
 114 |     | <span class='neutral'>                    vm.toString(chain.chainId),</span>
 115 |     | <span class='neutral'>                    &quot; already used by \&quot;&quot;,</span>
 116 |     | <span class='neutral'>                    foundAlias,</span>
 117 |     | <span class='neutral'>                    &quot;\&quot;.&quot;</span>
 118 |     | <span class='neutral'>                )</span>
 119 |     | <span class='neutral'>            )</span>
 120 |     | <span class='neutral'>        );</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>        uint256 oldChainId = chains[chainAlias].chainId;</span>
 123 |     | <span class='neutral'>        delete idToAlias[oldChainId];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>        chains[chainAlias] =</span>
 126 |     | <span class='neutral'>            Chain({name: chain.name, chainId: chain.chainId, chainAlias: chainAlias, rpcUrl: chain.rpcUrl});</span>
 127 |     | <span class='neutral'>        idToAlias[chain.chainId] = chainAlias;</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    // set chain info, with priority to argument&#39;s rpcUrl field.</span>
 131 |     | <span class='neutral'>    function setChain(string memory chainAlias, Chain memory chain) internal virtual {</span>
 132 |     | <span class='neutral'>        setChain(chainAlias, ChainData({name: chain.name, chainId: chain.chainId, rpcUrl: chain.rpcUrl}));</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    function _toUpper(string memory str) private pure returns (string memory) {</span>
 136 |     | <span class='neutral'>        bytes memory strb = bytes(str);</span>
 137 |     | <span class='neutral'>        bytes memory copy = new bytes(strb.length);</span>
 138 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; strb.length; i++) {</span>
 139 |     | <span class='neutral'>            bytes1 b = strb[i];</span>
 140 |     | <span class='neutral'>            if (b &gt;= 0x61 &amp;&amp; b &lt;= 0x7A) {</span>
 141 |     | <span class='neutral'>                copy[i] = bytes1(uint8(b) - 32);</span>
 142 |     | <span class='neutral'>            } else {</span>
 143 |     | <span class='neutral'>                copy[i] = b;</span>
 144 |     | <span class='neutral'>            }</span>
 145 |     | <span class='neutral'>        }</span>
 146 |     | <span class='neutral'>        return string(copy);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // lookup rpcUrl, in descending order of priority:</span>
 150 |     | <span class='neutral'>    // current -&gt; config (foundry.toml) -&gt; environment variable -&gt; default</span>
 151 |     | <span class='neutral'>    function getChainWithUpdatedRpcUrl(string memory chainAlias, Chain memory chain)</span>
 152 |     | <span class='neutral'>        private</span>
 153 |     | <span class='neutral'>        view</span>
 154 |     | <span class='neutral'>        returns (Chain memory)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        if (bytes(chain.rpcUrl).length == 0) {</span>
 157 |     | <span class='neutral'>            try vm.rpcUrl(chainAlias) returns (string memory configRpcUrl) {</span>
 158 |     | <span class='neutral'>                chain.rpcUrl = configRpcUrl;</span>
 159 |     | <span class='neutral'>            } catch (bytes memory err) {</span>
 160 |     | <span class='neutral'>                string memory envName = string(abi.encodePacked(_toUpper(chainAlias), &quot;_RPC_URL&quot;));</span>
 161 |     | <span class='neutral'>                if (fallbackToDefaultRpcUrls) {</span>
 162 |     | <span class='neutral'>                    chain.rpcUrl = vm.envOr(envName, defaultRpcUrls[chainAlias]);</span>
 163 |     | <span class='neutral'>                } else {</span>
 164 |     | <span class='neutral'>                    chain.rpcUrl = vm.envString(envName);</span>
 165 |     | <span class='neutral'>                }</span>
 166 |     | <span class='neutral'>                // Distinguish &#39;not found&#39; from &#39;cannot read&#39;</span>
 167 |     | <span class='neutral'>                // The upstream error thrown by forge for failing cheats changed so we check both the old and new versions</span>
 168 |     | <span class='neutral'>                bytes memory oldNotFoundError =</span>
 169 |     | <span class='neutral'>                    abi.encodeWithSignature(&quot;CheatCodeError&quot;, string(abi.encodePacked(&quot;invalid rpc url &quot;, chainAlias)));</span>
 170 |     | <span class='neutral'>                bytes memory newNotFoundError = abi.encodeWithSignature(</span>
 171 |     | <span class='neutral'>                    &quot;CheatcodeError(string)&quot;, string(abi.encodePacked(&quot;invalid rpc url: &quot;, chainAlias))</span>
 172 |     | <span class='neutral'>                );</span>
 173 |     | <span class='neutral'>                bytes32 errHash = keccak256(err);</span>
 174 |     | <span class='neutral'>                if (</span>
 175 |     | <span class='neutral'>                    (errHash != keccak256(oldNotFoundError) &amp;&amp; errHash != keccak256(newNotFoundError))</span>
 176 |     | <span class='neutral'>                        || bytes(chain.rpcUrl).length == 0</span>
 177 |     | <span class='neutral'>                ) {</span>
 178 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 179 |     | <span class='neutral'>                    assembly {</span>
 180 |     | <span class='neutral'>                        revert(add(32, err), mload(err))</span>
 181 |     | <span class='neutral'>                    }</span>
 182 |     | <span class='neutral'>                }</span>
 183 |     | <span class='neutral'>            }</span>
 184 |     | <span class='neutral'>        }</span>
 185 |     | <span class='neutral'>        return chain;</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    function setFallbackToDefaultRpcUrls(bool useDefault) internal {</span>
 189 |     | <span class='neutral'>        fallbackToDefaultRpcUrls = useDefault;</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    function initializeStdChains() private {</span>
 193 |     | <span class='neutral'>        if (stdChainsInitialized) return;</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>        stdChainsInitialized = true;</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>        // If adding an RPC here, make sure to test the default RPC URL in `test_Rpcs` in `StdChains.t.sol`</span>
 198 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;anvil&quot;, ChainData(&quot;Anvil&quot;, 31337, &quot;http://127.0.0.1:8545&quot;));</span>
 199 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 200 |     | <span class='neutral'>            &quot;mainnet&quot;, ChainData(&quot;Mainnet&quot;, 1, &quot;https://eth-mainnet.alchemyapi.io/v2/pwc5rmJhrdoaSEfimoKEmsvOjKSmPDrP&quot;)</span>
 201 |     | <span class='neutral'>        );</span>
 202 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 203 |     | <span class='neutral'>            &quot;sepolia&quot;, ChainData(&quot;Sepolia&quot;, 11155111, &quot;https://sepolia.infura.io/v3/b9794ad1ddf84dfb8c34d6bb5dca2001&quot;)</span>
 204 |     | <span class='neutral'>        );</span>
 205 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;holesky&quot;, ChainData(&quot;Holesky&quot;, 17000, &quot;https://rpc.holesky.ethpandaops.io&quot;));</span>
 206 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;optimism&quot;, ChainData(&quot;Optimism&quot;, 10, &quot;https://mainnet.optimism.io&quot;));</span>
 207 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 208 |     | <span class='neutral'>            &quot;optimism_sepolia&quot;, ChainData(&quot;Optimism Sepolia&quot;, 11155420, &quot;https://sepolia.optimism.io&quot;)</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_one&quot;, ChainData(&quot;Arbitrum One&quot;, 42161, &quot;https://arb1.arbitrum.io/rpc&quot;));</span>
 211 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 212 |     | <span class='neutral'>            &quot;arbitrum_one_sepolia&quot;, ChainData(&quot;Arbitrum One Sepolia&quot;, 421614, &quot;https://sepolia-rollup.arbitrum.io/rpc&quot;)</span>
 213 |     | <span class='neutral'>        );</span>
 214 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;arbitrum_nova&quot;, ChainData(&quot;Arbitrum Nova&quot;, 42170, &quot;https://nova.arbitrum.io/rpc&quot;));</span>
 215 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;polygon&quot;, ChainData(&quot;Polygon&quot;, 137, &quot;https://polygon-rpc.com&quot;));</span>
 216 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 217 |     | <span class='neutral'>            &quot;polygon_amoy&quot;, ChainData(&quot;Polygon Amoy&quot;, 80002, &quot;https://rpc-amoy.polygon.technology&quot;)</span>
 218 |     | <span class='neutral'>        );</span>
 219 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;avalanche&quot;, ChainData(&quot;Avalanche&quot;, 43114, &quot;https://api.avax.network/ext/bc/C/rpc&quot;));</span>
 220 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 221 |     | <span class='neutral'>            &quot;avalanche_fuji&quot;, ChainData(&quot;Avalanche Fuji&quot;, 43113, &quot;https://api.avax-test.network/ext/bc/C/rpc&quot;)</span>
 222 |     | <span class='neutral'>        );</span>
 223 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 224 |     | <span class='neutral'>            &quot;bnb_smart_chain&quot;, ChainData(&quot;BNB Smart Chain&quot;, 56, &quot;https://bsc-dataseed1.binance.org&quot;)</span>
 225 |     | <span class='neutral'>        );</span>
 226 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 227 |     | <span class='neutral'>            &quot;bnb_smart_chain_testnet&quot;,</span>
 228 |     | <span class='neutral'>            ChainData(&quot;BNB Smart Chain Testnet&quot;, 97, &quot;https://rpc.ankr.com/bsc_testnet_chapel&quot;)</span>
 229 |     | <span class='neutral'>        );</span>
 230 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;gnosis_chain&quot;, ChainData(&quot;Gnosis Chain&quot;, 100, &quot;https://rpc.gnosischain.com&quot;));</span>
 231 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbeam&quot;, ChainData(&quot;Moonbeam&quot;, 1284, &quot;https://rpc.api.moonbeam.network&quot;));</span>
 232 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 233 |     | <span class='neutral'>            &quot;moonriver&quot;, ChainData(&quot;Moonriver&quot;, 1285, &quot;https://rpc.api.moonriver.moonbeam.network&quot;)</span>
 234 |     | <span class='neutral'>        );</span>
 235 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;moonbase&quot;, ChainData(&quot;Moonbase&quot;, 1287, &quot;https://rpc.testnet.moonbeam.network&quot;));</span>
 236 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base_sepolia&quot;, ChainData(&quot;Base Sepolia&quot;, 84532, &quot;https://sepolia.base.org&quot;));</span>
 237 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;base&quot;, ChainData(&quot;Base&quot;, 8453, &quot;https://mainnet.base.org&quot;));</span>
 238 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast_sepolia&quot;, ChainData(&quot;Blast Sepolia&quot;, 168587773, &quot;https://sepolia.blast.io&quot;));</span>
 239 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;blast&quot;, ChainData(&quot;Blast&quot;, 81457, &quot;https://rpc.blast.io&quot;));</span>
 240 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fantom_opera&quot;, ChainData(&quot;Fantom Opera&quot;, 250, &quot;https://rpc.ankr.com/fantom/&quot;));</span>
 241 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 242 |     | <span class='neutral'>            &quot;fantom_opera_testnet&quot;, ChainData(&quot;Fantom Opera Testnet&quot;, 4002, &quot;https://rpc.ankr.com/fantom_testnet/&quot;)</span>
 243 |     | <span class='neutral'>        );</span>
 244 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal&quot;, ChainData(&quot;Fraxtal&quot;, 252, &quot;https://rpc.frax.com&quot;));</span>
 245 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(&quot;fraxtal_testnet&quot;, ChainData(&quot;Fraxtal Testnet&quot;, 2522, &quot;https://rpc.testnet.frax.com&quot;));</span>
 246 |     | <span class='neutral'>        setChainWithDefaultRpcUrl(</span>
 247 |     | <span class='neutral'>            &quot;berachain_bartio_testnet&quot;, ChainData(&quot;Berachain bArtio Testnet&quot;, 80084, &quot;https://bartio.rpc.berachain.com&quot;)</span>
 248 |     | <span class='neutral'>        );</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    // set chain info, with priority to chainAlias&#39; rpc url in foundry.toml</span>
 252 |     | <span class='neutral'>    function setChainWithDefaultRpcUrl(string memory chainAlias, ChainData memory chain) private {</span>
 253 |     | <span class='neutral'>        string memory rpcUrl = chain.rpcUrl;</span>
 254 |     | <span class='neutral'>        defaultRpcUrls[chainAlias] = rpcUrl;</span>
 255 |     | <span class='neutral'>        chain.rpcUrl = &quot;&quot;;</span>
 256 |     | <span class='neutral'>        setChain(chainAlias, chain);</span>
 257 |     | <span class='neutral'>        chain.rpcUrl = rpcUrl; // restore argument</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'>}</span>
 260 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdCheats.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
   7 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
   8 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>abstract contract StdCheatsSafe {</span>
  11 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  14 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    bool private gasMeteringOff;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  19 |     | <span class='neutral'>    // that conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  20 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    struct RawTx1559 {</span>
  23 |     | <span class='neutral'>        string[] arguments;</span>
  24 |     | <span class='neutral'>        address contractAddress;</span>
  25 |     | <span class='neutral'>        string contractName;</span>
  26 |     | <span class='neutral'>        // json value name = function</span>
  27 |     | <span class='neutral'>        string functionSig;</span>
  28 |     | <span class='neutral'>        bytes32 hash;</span>
  29 |     | <span class='neutral'>        // json value name = tx</span>
  30 |     | <span class='neutral'>        RawTx1559Detail txDetail;</span>
  31 |     | <span class='neutral'>        // json value name = type</span>
  32 |     | <span class='neutral'>        string opcode;</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    struct RawTx1559Detail {</span>
  36 |     | <span class='neutral'>        AccessList[] accessList;</span>
  37 |     | <span class='neutral'>        bytes data;</span>
  38 |     | <span class='neutral'>        address from;</span>
  39 |     | <span class='neutral'>        bytes gas;</span>
  40 |     | <span class='neutral'>        bytes nonce;</span>
  41 |     | <span class='neutral'>        address to;</span>
  42 |     | <span class='neutral'>        bytes txType;</span>
  43 |     | <span class='neutral'>        bytes value;</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    struct Tx1559 {</span>
  47 |     | <span class='neutral'>        string[] arguments;</span>
  48 |     | <span class='neutral'>        address contractAddress;</span>
  49 |     | <span class='neutral'>        string contractName;</span>
  50 |     | <span class='neutral'>        string functionSig;</span>
  51 |     | <span class='neutral'>        bytes32 hash;</span>
  52 |     | <span class='neutral'>        Tx1559Detail txDetail;</span>
  53 |     | <span class='neutral'>        string opcode;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Tx1559Detail {</span>
  57 |     | <span class='neutral'>        AccessList[] accessList;</span>
  58 |     | <span class='neutral'>        bytes data;</span>
  59 |     | <span class='neutral'>        address from;</span>
  60 |     | <span class='neutral'>        uint256 gas;</span>
  61 |     | <span class='neutral'>        uint256 nonce;</span>
  62 |     | <span class='neutral'>        address to;</span>
  63 |     | <span class='neutral'>        uint256 txType;</span>
  64 |     | <span class='neutral'>        uint256 value;</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Data structures to parse Transaction objects from the broadcast artifact</span>
  68 |     | <span class='neutral'>    // that DO NOT conform to EIP1559. The Raw structs is what is parsed from the JSON</span>
  69 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    struct TxLegacy {</span>
  72 |     | <span class='neutral'>        string[] arguments;</span>
  73 |     | <span class='neutral'>        address contractAddress;</span>
  74 |     | <span class='neutral'>        string contractName;</span>
  75 |     | <span class='neutral'>        string functionSig;</span>
  76 |     | <span class='neutral'>        string hash;</span>
  77 |     | <span class='neutral'>        string opcode;</span>
  78 |     | <span class='neutral'>        TxDetailLegacy transaction;</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    struct TxDetailLegacy {</span>
  82 |     | <span class='neutral'>        AccessList[] accessList;</span>
  83 |     | <span class='neutral'>        uint256 chainId;</span>
  84 |     | <span class='neutral'>        bytes data;</span>
  85 |     | <span class='neutral'>        address from;</span>
  86 |     | <span class='neutral'>        uint256 gas;</span>
  87 |     | <span class='neutral'>        uint256 gasPrice;</span>
  88 |     | <span class='neutral'>        bytes32 hash;</span>
  89 |     | <span class='neutral'>        uint256 nonce;</span>
  90 |     | <span class='neutral'>        bytes1 opcode;</span>
  91 |     | <span class='neutral'>        bytes32 r;</span>
  92 |     | <span class='neutral'>        bytes32 s;</span>
  93 |     | <span class='neutral'>        uint256 txType;</span>
  94 |     | <span class='neutral'>        address to;</span>
  95 |     | <span class='neutral'>        uint8 v;</span>
  96 |     | <span class='neutral'>        uint256 value;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    struct AccessList {</span>
 100 |     | <span class='neutral'>        address accessAddress;</span>
 101 |     | <span class='neutral'>        bytes32[] storageKeys;</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // Data structures to parse Receipt objects from the broadcast artifact.</span>
 105 |     | <span class='neutral'>    // The Raw structs is what is parsed from the JSON</span>
 106 |     | <span class='neutral'>    // and then converted to the one that is used by the user for better UX.</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    struct RawReceipt {</span>
 109 |     | <span class='neutral'>        bytes32 blockHash;</span>
 110 |     | <span class='neutral'>        bytes blockNumber;</span>
 111 |     | <span class='neutral'>        address contractAddress;</span>
 112 |     | <span class='neutral'>        bytes cumulativeGasUsed;</span>
 113 |     | <span class='neutral'>        bytes effectiveGasPrice;</span>
 114 |     | <span class='neutral'>        address from;</span>
 115 |     | <span class='neutral'>        bytes gasUsed;</span>
 116 |     | <span class='neutral'>        RawReceiptLog[] logs;</span>
 117 |     | <span class='neutral'>        bytes logsBloom;</span>
 118 |     | <span class='neutral'>        bytes status;</span>
 119 |     | <span class='neutral'>        address to;</span>
 120 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 121 |     | <span class='neutral'>        bytes transactionIndex;</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    struct Receipt {</span>
 125 |     | <span class='neutral'>        bytes32 blockHash;</span>
 126 |     | <span class='neutral'>        uint256 blockNumber;</span>
 127 |     | <span class='neutral'>        address contractAddress;</span>
 128 |     | <span class='neutral'>        uint256 cumulativeGasUsed;</span>
 129 |     | <span class='neutral'>        uint256 effectiveGasPrice;</span>
 130 |     | <span class='neutral'>        address from;</span>
 131 |     | <span class='neutral'>        uint256 gasUsed;</span>
 132 |     | <span class='neutral'>        ReceiptLog[] logs;</span>
 133 |     | <span class='neutral'>        bytes logsBloom;</span>
 134 |     | <span class='neutral'>        uint256 status;</span>
 135 |     | <span class='neutral'>        address to;</span>
 136 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 137 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    // Data structures to parse the entire broadcast artifact, assuming the</span>
 141 |     | <span class='neutral'>    // transactions conform to EIP1559.</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    struct EIP1559ScriptArtifact {</span>
 144 |     | <span class='neutral'>        string[] libraries;</span>
 145 |     | <span class='neutral'>        string path;</span>
 146 |     | <span class='neutral'>        string[] pending;</span>
 147 |     | <span class='neutral'>        Receipt[] receipts;</span>
 148 |     | <span class='neutral'>        uint256 timestamp;</span>
 149 |     | <span class='neutral'>        Tx1559[] transactions;</span>
 150 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 151 |     | <span class='neutral'>    }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    struct RawEIP1559ScriptArtifact {</span>
 154 |     | <span class='neutral'>        string[] libraries;</span>
 155 |     | <span class='neutral'>        string path;</span>
 156 |     | <span class='neutral'>        string[] pending;</span>
 157 |     | <span class='neutral'>        RawReceipt[] receipts;</span>
 158 |     | <span class='neutral'>        TxReturn[] txReturns;</span>
 159 |     | <span class='neutral'>        uint256 timestamp;</span>
 160 |     | <span class='neutral'>        RawTx1559[] transactions;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    struct RawReceiptLog {</span>
 164 |     | <span class='neutral'>        // json value = address</span>
 165 |     | <span class='neutral'>        address logAddress;</span>
 166 |     | <span class='neutral'>        bytes32 blockHash;</span>
 167 |     | <span class='neutral'>        bytes blockNumber;</span>
 168 |     | <span class='neutral'>        bytes data;</span>
 169 |     | <span class='neutral'>        bytes logIndex;</span>
 170 |     | <span class='neutral'>        bool removed;</span>
 171 |     | <span class='neutral'>        bytes32[] topics;</span>
 172 |     | <span class='neutral'>        bytes32 transactionHash;</span>
 173 |     | <span class='neutral'>        bytes transactionIndex;</span>
 174 |     | <span class='neutral'>        bytes transactionLogIndex;</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    struct ReceiptLog {</span>
 178 |     | <span class='neutral'>        // json value = address</span>
 179 |     | <span class='neutral'>        address logAddress;</span>
 180 |     | <span class='neutral'>        bytes32 blockHash;</span>
 181 |     | <span class='neutral'>        uint256 blockNumber;</span>
 182 |     | <span class='neutral'>        bytes data;</span>
 183 |     | <span class='neutral'>        uint256 logIndex;</span>
 184 |     | <span class='neutral'>        bytes32[] topics;</span>
 185 |     | <span class='neutral'>        uint256 transactionIndex;</span>
 186 |     | <span class='neutral'>        uint256 transactionLogIndex;</span>
 187 |     | <span class='neutral'>        bool removed;</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    struct TxReturn {</span>
 191 |     | <span class='neutral'>        string internalType;</span>
 192 |     | <span class='neutral'>        string value;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    struct Account {</span>
 196 |     | <span class='neutral'>        address addr;</span>
 197 |     | <span class='neutral'>        uint256 key;</span>
 198 |     | <span class='neutral'>    }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    enum AddressType {</span>
 201 |     | <span class='neutral'>        Payable,</span>
 202 |     | <span class='neutral'>        NonPayable,</span>
 203 |     | <span class='neutral'>        ZeroAddress,</span>
 204 |     | <span class='neutral'>        Precompile,</span>
 205 |     | <span class='neutral'>        ForgeAddress</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 209 |     | <span class='neutral'>    function assumeNotBlacklisted(address token, address addr) internal view virtual {</span>
 210 |     | <span class='neutral'>        // Nothing to check if `token` is not a contract.</span>
 211 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 212 |     | <span class='neutral'>        assembly {</span>
 213 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 214 |     | <span class='neutral'>        }</span>
 215 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdCheats assumeNotBlacklisted(address,address): Token address is not a contract.&quot;);</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>        bool success;</span>
 218 |     | <span class='neutral'>        bytes memory returnData;</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>        // 4-byte selector for `isBlacklisted(address)`, used by USDC.</span>
 221 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xfe575a87, addr));</span>
 222 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // 4-byte selector for `isBlackListed(address)`, used by USDT.</span>
 225 |     | <span class='neutral'>        (success, returnData) = token.staticcall(abi.encodeWithSelector(0xe47d6060, addr));</span>
 226 |     | <span class='neutral'>        vm.assume(!success || abi.decode(returnData, (bool)) == false);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='neutral'>    // Checks that `addr` is not blacklisted by token contracts that have a blacklist.</span>
 230 |     | <span class='neutral'>    // This is identical to `assumeNotBlacklisted(address,address)` but with a different name, for</span>
 231 |     | <span class='neutral'>    // backwards compatibility, since this name was used in the original PR which has already has</span>
 232 |     | <span class='neutral'>    // a release. This function can be removed in a future release once we want a breaking change.</span>
 233 |     | <span class='neutral'>    function assumeNoBlacklisted(address token, address addr) internal view virtual {</span>
 234 |     | <span class='neutral'>        assumeNotBlacklisted(token, addr);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType) internal virtual {</span>
 238 |     | <span class='neutral'>        if (addressType == AddressType.Payable) {</span>
 239 |     | <span class='neutral'>            assumeNotPayable(addr);</span>
 240 |     | <span class='neutral'>        } else if (addressType == AddressType.NonPayable) {</span>
 241 |     | <span class='neutral'>            assumePayable(addr);</span>
 242 |     | <span class='neutral'>        } else if (addressType == AddressType.ZeroAddress) {</span>
 243 |     | <span class='neutral'>            assumeNotZeroAddress(addr);</span>
 244 |     | <span class='neutral'>        } else if (addressType == AddressType.Precompile) {</span>
 245 |     | <span class='neutral'>            assumeNotPrecompile(addr);</span>
 246 |     | <span class='neutral'>        } else if (addressType == AddressType.ForgeAddress) {</span>
 247 |     | <span class='neutral'>            assumeNotForgeAddress(addr);</span>
 248 |     | <span class='neutral'>        }</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='neutral'></span>
 251 |     | <span class='neutral'>    function assumeAddressIsNot(address addr, AddressType addressType1, AddressType addressType2) internal virtual {</span>
 252 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 253 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 254 |     | <span class='neutral'>    }</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 257 |     | <span class='neutral'>        address addr,</span>
 258 |     | <span class='neutral'>        AddressType addressType1,</span>
 259 |     | <span class='neutral'>        AddressType addressType2,</span>
 260 |     | <span class='neutral'>        AddressType addressType3</span>
 261 |     | <span class='neutral'>    ) internal virtual {</span>
 262 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 263 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 264 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 265 |     | <span class='neutral'>    }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>    function assumeAddressIsNot(</span>
 268 |     | <span class='neutral'>        address addr,</span>
 269 |     | <span class='neutral'>        AddressType addressType1,</span>
 270 |     | <span class='neutral'>        AddressType addressType2,</span>
 271 |     | <span class='neutral'>        AddressType addressType3,</span>
 272 |     | <span class='neutral'>        AddressType addressType4</span>
 273 |     | <span class='neutral'>    ) internal virtual {</span>
 274 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType1);</span>
 275 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType2);</span>
 276 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType3);</span>
 277 |     | <span class='neutral'>        assumeAddressIsNot(addr, addressType4);</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    // This function checks whether an address, `addr`, is payable. It works by sending 1 wei to</span>
 281 |     | <span class='neutral'>    // `addr` and checking the `success` return value.</span>
 282 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 283 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used.</span>
 284 |     | <span class='neutral'>    function _isPayable(address addr) private returns (bool) {</span>
 285 |     | <span class='neutral'>        require(</span>
 286 |     | <span class='neutral'>            addr.balance &lt; UINT256_MAX,</span>
 287 |     | <span class='neutral'>            &quot;StdCheats _isPayable(address): Balance equals max uint256, so it cannot receive any more funds&quot;</span>
 288 |     | <span class='neutral'>        );</span>
 289 |     | <span class='neutral'>        uint256 origBalanceTest = address(this).balance;</span>
 290 |     | <span class='neutral'>        uint256 origBalanceAddr = address(addr).balance;</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>        vm.deal(address(this), 1);</span>
 293 |     | <span class='neutral'>        (bool success,) = payable(addr).call{value: 1}(&quot;&quot;);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>        // reset balances</span>
 296 |     | <span class='neutral'>        vm.deal(address(this), origBalanceTest);</span>
 297 |     | <span class='neutral'>        vm.deal(addr, origBalanceAddr);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>        return success;</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    // NOTE: This function may result in state changes depending on the fallback/receive logic</span>
 303 |     | <span class='neutral'>    // implemented by `addr`, which should be taken into account when this function is used. See the</span>
 304 |     | <span class='neutral'>    // `_isPayable` method for more information.</span>
 305 |     | <span class='neutral'>    function assumePayable(address addr) internal virtual {</span>
 306 |     | <span class='neutral'>        vm.assume(_isPayable(addr));</span>
 307 |     | <span class='neutral'>    }</span>
 308 |     | <span class='neutral'></span>
 309 |     | <span class='neutral'>    function assumeNotPayable(address addr) internal virtual {</span>
 310 |     | <span class='neutral'>        vm.assume(!_isPayable(addr));</span>
 311 |     | <span class='neutral'>    }</span>
 312 |     | <span class='neutral'></span>
 313 |     | <span class='neutral'>    function assumeNotZeroAddress(address addr) internal pure virtual {</span>
 314 |     | <span class='neutral'>        vm.assume(addr != address(0));</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>    function assumeNotPrecompile(address addr) internal pure virtual {</span>
 318 |     | <span class='neutral'>        assumeNotPrecompile(addr, _pureChainId());</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='neutral'>    function assumeNotPrecompile(address addr, uint256 chainId) internal pure virtual {</span>
 322 |     | <span class='neutral'>        // Note: For some chains like Optimism these are technically predeploys (i.e. bytecode placed at a specific</span>
 323 |     | <span class='neutral'>        // address), but the same rationale for excluding them applies so we include those too.</span>
 324 |     | <span class='neutral'></span>
 325 |     | <span class='neutral'>        // These should be present on all EVM-compatible chains.</span>
 326 |     | <span class='neutral'>        vm.assume(addr &lt; address(0x1) || addr &gt; address(0x9));</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>        // forgefmt: disable-start</span>
 329 |     | <span class='neutral'>        if (chainId == 10 || chainId == 420) {</span>
 330 |     | <span class='neutral'>            // https://github.com/ethereum-optimism/optimism/blob/eaa371a0184b56b7ca6d9eb9cb0a2b78b2ccd864/op-bindings/predeploys/addresses.go#L6-L21</span>
 331 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x4200000000000000000000000000000000000000) || addr &gt; address(0x4200000000000000000000000000000000000800));</span>
 332 |     | <span class='neutral'>        } else if (chainId == 42161 || chainId == 421613) {</span>
 333 |     | <span class='neutral'>            // https://developer.arbitrum.io/useful-addresses#arbitrum-precompiles-l2-same-on-all-arb-chains</span>
 334 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0000000000000000000000000000000000000064) || addr &gt; address(0x0000000000000000000000000000000000000068));</span>
 335 |     | <span class='neutral'>        } else if (chainId == 43114 || chainId == 43113) {</span>
 336 |     | <span class='neutral'>            // https://github.com/ava-labs/subnet-evm/blob/47c03fd007ecaa6de2c52ea081596e0a88401f58/precompile/params.go#L18-L59</span>
 337 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0100000000000000000000000000000000000000) || addr &gt; address(0x01000000000000000000000000000000000000ff));</span>
 338 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0200000000000000000000000000000000000000) || addr &gt; address(0x02000000000000000000000000000000000000FF));</span>
 339 |     | <span class='neutral'>            vm.assume(addr &lt; address(0x0300000000000000000000000000000000000000) || addr &gt; address(0x03000000000000000000000000000000000000Ff));</span>
 340 |     | <span class='neutral'>        }</span>
 341 |     | <span class='neutral'>        // forgefmt: disable-end</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='neutral'>    function assumeNotForgeAddress(address addr) internal pure virtual {</span>
 345 |     | <span class='neutral'>        // vm, console, and Create2Deployer addresses</span>
 346 |     | <span class='neutral'>        vm.assume(</span>
 347 |     | <span class='neutral'>            addr != address(vm) &amp;&amp; addr != 0x000000000000000000636F6e736F6c652e6c6f67</span>
 348 |     | <span class='neutral'>                &amp;&amp; addr != 0x4e59b44847b379578588920cA78FbF26c0B4956C</span>
 349 |     | <span class='neutral'>        );</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function readEIP1559ScriptArtifact(string memory path)</span>
 353 |     | <span class='neutral'>        internal</span>
 354 |     | <span class='neutral'>        view</span>
 355 |     | <span class='neutral'>        virtual</span>
 356 |     | <span class='neutral'>        returns (EIP1559ScriptArtifact memory)</span>
 357 |     | <span class='neutral'>    {</span>
 358 |     | <span class='neutral'>        string memory data = vm.readFile(path);</span>
 359 |     | <span class='neutral'>        bytes memory parsedData = vm.parseJson(data);</span>
 360 |     | <span class='neutral'>        RawEIP1559ScriptArtifact memory rawArtifact = abi.decode(parsedData, (RawEIP1559ScriptArtifact));</span>
 361 |     | <span class='neutral'>        EIP1559ScriptArtifact memory artifact;</span>
 362 |     | <span class='neutral'>        artifact.libraries = rawArtifact.libraries;</span>
 363 |     | <span class='neutral'>        artifact.path = rawArtifact.path;</span>
 364 |     | <span class='neutral'>        artifact.timestamp = rawArtifact.timestamp;</span>
 365 |     | <span class='neutral'>        artifact.pending = rawArtifact.pending;</span>
 366 |     | <span class='neutral'>        artifact.txReturns = rawArtifact.txReturns;</span>
 367 |     | <span class='neutral'>        artifact.receipts = rawToConvertedReceipts(rawArtifact.receipts);</span>
 368 |     | <span class='neutral'>        artifact.transactions = rawToConvertedEIPTx1559s(rawArtifact.transactions);</span>
 369 |     | <span class='neutral'>        return artifact;</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    function rawToConvertedEIPTx1559s(RawTx1559[] memory rawTxs) internal pure virtual returns (Tx1559[] memory) {</span>
 373 |     | <span class='neutral'>        Tx1559[] memory txs = new Tx1559[](rawTxs.length);</span>
 374 |     | <span class='neutral'>        for (uint256 i; i &lt; rawTxs.length; i++) {</span>
 375 |     | <span class='neutral'>            txs[i] = rawToConvertedEIPTx1559(rawTxs[i]);</span>
 376 |     | <span class='neutral'>        }</span>
 377 |     | <span class='neutral'>        return txs;</span>
 378 |     | <span class='neutral'>    }</span>
 379 |     | <span class='neutral'></span>
 380 |     | <span class='neutral'>    function rawToConvertedEIPTx1559(RawTx1559 memory rawTx) internal pure virtual returns (Tx1559 memory) {</span>
 381 |     | <span class='neutral'>        Tx1559 memory transaction;</span>
 382 |     | <span class='neutral'>        transaction.arguments = rawTx.arguments;</span>
 383 |     | <span class='neutral'>        transaction.contractName = rawTx.contractName;</span>
 384 |     | <span class='neutral'>        transaction.functionSig = rawTx.functionSig;</span>
 385 |     | <span class='neutral'>        transaction.hash = rawTx.hash;</span>
 386 |     | <span class='neutral'>        transaction.txDetail = rawToConvertedEIP1559Detail(rawTx.txDetail);</span>
 387 |     | <span class='neutral'>        transaction.opcode = rawTx.opcode;</span>
 388 |     | <span class='neutral'>        return transaction;</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    function rawToConvertedEIP1559Detail(RawTx1559Detail memory rawDetail)</span>
 392 |     | <span class='neutral'>        internal</span>
 393 |     | <span class='neutral'>        pure</span>
 394 |     | <span class='neutral'>        virtual</span>
 395 |     | <span class='neutral'>        returns (Tx1559Detail memory)</span>
 396 |     | <span class='neutral'>    {</span>
 397 |     | <span class='neutral'>        Tx1559Detail memory txDetail;</span>
 398 |     | <span class='neutral'>        txDetail.data = rawDetail.data;</span>
 399 |     | <span class='neutral'>        txDetail.from = rawDetail.from;</span>
 400 |     | <span class='neutral'>        txDetail.to = rawDetail.to;</span>
 401 |     | <span class='neutral'>        txDetail.nonce = _bytesToUint(rawDetail.nonce);</span>
 402 |     | <span class='neutral'>        txDetail.txType = _bytesToUint(rawDetail.txType);</span>
 403 |     | <span class='neutral'>        txDetail.value = _bytesToUint(rawDetail.value);</span>
 404 |     | <span class='neutral'>        txDetail.gas = _bytesToUint(rawDetail.gas);</span>
 405 |     | <span class='neutral'>        txDetail.accessList = rawDetail.accessList;</span>
 406 |     | <span class='neutral'>        return txDetail;</span>
 407 |     | <span class='neutral'>    }</span>
 408 |     | <span class='neutral'></span>
 409 |     | <span class='neutral'>    function readTx1559s(string memory path) internal view virtual returns (Tx1559[] memory) {</span>
 410 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 411 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.transactions&quot;);</span>
 412 |     | <span class='neutral'>        RawTx1559[] memory rawTxs = abi.decode(parsedDeployData, (RawTx1559[]));</span>
 413 |     | <span class='neutral'>        return rawToConvertedEIPTx1559s(rawTxs);</span>
 414 |     | <span class='neutral'>    }</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>    function readTx1559(string memory path, uint256 index) internal view virtual returns (Tx1559 memory) {</span>
 417 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 418 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.transactions[&quot;, vm.toString(index), &quot;]&quot;));</span>
 419 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 420 |     | <span class='neutral'>        RawTx1559 memory rawTx = abi.decode(parsedDeployData, (RawTx1559));</span>
 421 |     | <span class='neutral'>        return rawToConvertedEIPTx1559(rawTx);</span>
 422 |     | <span class='neutral'>    }</span>
 423 |     | <span class='neutral'></span>
 424 |     | <span class='neutral'>    // Analogous to readTransactions, but for receipts.</span>
 425 |     | <span class='neutral'>    function readReceipts(string memory path) internal view virtual returns (Receipt[] memory) {</span>
 426 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 427 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, &quot;.receipts&quot;);</span>
 428 |     | <span class='neutral'>        RawReceipt[] memory rawReceipts = abi.decode(parsedDeployData, (RawReceipt[]));</span>
 429 |     | <span class='neutral'>        return rawToConvertedReceipts(rawReceipts);</span>
 430 |     | <span class='neutral'>    }</span>
 431 |     | <span class='neutral'></span>
 432 |     | <span class='neutral'>    function readReceipt(string memory path, uint256 index) internal view virtual returns (Receipt memory) {</span>
 433 |     | <span class='neutral'>        string memory deployData = vm.readFile(path);</span>
 434 |     | <span class='neutral'>        string memory key = string(abi.encodePacked(&quot;.receipts[&quot;, vm.toString(index), &quot;]&quot;));</span>
 435 |     | <span class='neutral'>        bytes memory parsedDeployData = vm.parseJson(deployData, key);</span>
 436 |     | <span class='neutral'>        RawReceipt memory rawReceipt = abi.decode(parsedDeployData, (RawReceipt));</span>
 437 |     | <span class='neutral'>        return rawToConvertedReceipt(rawReceipt);</span>
 438 |     | <span class='neutral'>    }</span>
 439 |     | <span class='neutral'></span>
 440 |     | <span class='neutral'>    function rawToConvertedReceipts(RawReceipt[] memory rawReceipts) internal pure virtual returns (Receipt[] memory) {</span>
 441 |     | <span class='neutral'>        Receipt[] memory receipts = new Receipt[](rawReceipts.length);</span>
 442 |     | <span class='neutral'>        for (uint256 i; i &lt; rawReceipts.length; i++) {</span>
 443 |     | <span class='neutral'>            receipts[i] = rawToConvertedReceipt(rawReceipts[i]);</span>
 444 |     | <span class='neutral'>        }</span>
 445 |     | <span class='neutral'>        return receipts;</span>
 446 |     | <span class='neutral'>    }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='neutral'>    function rawToConvertedReceipt(RawReceipt memory rawReceipt) internal pure virtual returns (Receipt memory) {</span>
 449 |     | <span class='neutral'>        Receipt memory receipt;</span>
 450 |     | <span class='neutral'>        receipt.blockHash = rawReceipt.blockHash;</span>
 451 |     | <span class='neutral'>        receipt.to = rawReceipt.to;</span>
 452 |     | <span class='neutral'>        receipt.from = rawReceipt.from;</span>
 453 |     | <span class='neutral'>        receipt.contractAddress = rawReceipt.contractAddress;</span>
 454 |     | <span class='neutral'>        receipt.effectiveGasPrice = _bytesToUint(rawReceipt.effectiveGasPrice);</span>
 455 |     | <span class='neutral'>        receipt.cumulativeGasUsed = _bytesToUint(rawReceipt.cumulativeGasUsed);</span>
 456 |     | <span class='neutral'>        receipt.gasUsed = _bytesToUint(rawReceipt.gasUsed);</span>
 457 |     | <span class='neutral'>        receipt.status = _bytesToUint(rawReceipt.status);</span>
 458 |     | <span class='neutral'>        receipt.transactionIndex = _bytesToUint(rawReceipt.transactionIndex);</span>
 459 |     | <span class='neutral'>        receipt.blockNumber = _bytesToUint(rawReceipt.blockNumber);</span>
 460 |     | <span class='neutral'>        receipt.logs = rawToConvertedReceiptLogs(rawReceipt.logs);</span>
 461 |     | <span class='neutral'>        receipt.logsBloom = rawReceipt.logsBloom;</span>
 462 |     | <span class='neutral'>        receipt.transactionHash = rawReceipt.transactionHash;</span>
 463 |     | <span class='neutral'>        return receipt;</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function rawToConvertedReceiptLogs(RawReceiptLog[] memory rawLogs)</span>
 467 |     | <span class='neutral'>        internal</span>
 468 |     | <span class='neutral'>        pure</span>
 469 |     | <span class='neutral'>        virtual</span>
 470 |     | <span class='neutral'>        returns (ReceiptLog[] memory)</span>
 471 |     | <span class='neutral'>    {</span>
 472 |     | <span class='neutral'>        ReceiptLog[] memory logs = new ReceiptLog[](rawLogs.length);</span>
 473 |     | <span class='neutral'>        for (uint256 i; i &lt; rawLogs.length; i++) {</span>
 474 |     | <span class='neutral'>            logs[i].logAddress = rawLogs[i].logAddress;</span>
 475 |     | <span class='neutral'>            logs[i].blockHash = rawLogs[i].blockHash;</span>
 476 |     | <span class='neutral'>            logs[i].blockNumber = _bytesToUint(rawLogs[i].blockNumber);</span>
 477 |     | <span class='neutral'>            logs[i].data = rawLogs[i].data;</span>
 478 |     | <span class='neutral'>            logs[i].logIndex = _bytesToUint(rawLogs[i].logIndex);</span>
 479 |     | <span class='neutral'>            logs[i].topics = rawLogs[i].topics;</span>
 480 |     | <span class='neutral'>            logs[i].transactionIndex = _bytesToUint(rawLogs[i].transactionIndex);</span>
 481 |     | <span class='neutral'>            logs[i].transactionLogIndex = _bytesToUint(rawLogs[i].transactionLogIndex);</span>
 482 |     | <span class='neutral'>            logs[i].removed = rawLogs[i].removed;</span>
 483 |     | <span class='neutral'>        }</span>
 484 |     | <span class='neutral'>        return logs;</span>
 485 |     | <span class='neutral'>    }</span>
 486 |     | <span class='neutral'></span>
 487 |     | <span class='neutral'>    // Deploy a contract by fetching the contract bytecode from</span>
 488 |     | <span class='neutral'>    // the artifacts directory</span>
 489 |     | <span class='neutral'>    // e.g. `deployCode(code, abi.encode(arg1,arg2,arg3))`</span>
 490 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args) internal virtual returns (address addr) {</span>
 491 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 492 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 493 |     | <span class='neutral'>        assembly {</span>
 494 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 495 |     | <span class='neutral'>        }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes): Deployment failed.&quot;);</span>
 498 |     | <span class='neutral'>    }</span>
 499 |     | <span class='neutral'></span>
 500 |     | <span class='neutral'>    function deployCode(string memory what) internal virtual returns (address addr) {</span>
 501 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 502 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 503 |     | <span class='neutral'>        assembly {</span>
 504 |     | <span class='neutral'>            addr := create(0, add(bytecode, 0x20), mload(bytecode))</span>
 505 |     | <span class='neutral'>        }</span>
 506 |     | <span class='neutral'></span>
 507 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string): Deployment failed.&quot;);</span>
 508 |     | <span class='neutral'>    }</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>    /// @dev deploy contract with value on construction</span>
 511 |     | <span class='neutral'>    function deployCode(string memory what, bytes memory args, uint256 val) internal virtual returns (address addr) {</span>
 512 |     | <span class='neutral'>        bytes memory bytecode = abi.encodePacked(vm.getCode(what), args);</span>
 513 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 514 |     | <span class='neutral'>        assembly {</span>
 515 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 516 |     | <span class='neutral'>        }</span>
 517 |     | <span class='neutral'></span>
 518 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,bytes,uint256): Deployment failed.&quot;);</span>
 519 |     | <span class='neutral'>    }</span>
 520 |     | <span class='neutral'></span>
 521 |     | <span class='neutral'>    function deployCode(string memory what, uint256 val) internal virtual returns (address addr) {</span>
 522 |     | <span class='neutral'>        bytes memory bytecode = vm.getCode(what);</span>
 523 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 524 |     | <span class='neutral'>        assembly {</span>
 525 |     | <span class='neutral'>            addr := create(val, add(bytecode, 0x20), mload(bytecode))</span>
 526 |     | <span class='neutral'>        }</span>
 527 |     | <span class='neutral'></span>
 528 |     | <span class='neutral'>        require(addr != address(0), &quot;StdCheats deployCode(string,uint256): Deployment failed.&quot;);</span>
 529 |     | <span class='neutral'>    }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='neutral'>    // creates a labeled address and the corresponding private key</span>
 532 |     | <span class='neutral'>    function makeAddrAndKey(string memory name) internal virtual returns (address addr, uint256 privateKey) {</span>
 533 |     | <span class='neutral'>        privateKey = uint256(keccak256(abi.encodePacked(name)));</span>
 534 |     | <span class='neutral'>        addr = vm.addr(privateKey);</span>
 535 |     | <span class='neutral'>        vm.label(addr, name);</span>
 536 |     | <span class='neutral'>    }</span>
 537 |     | <span class='neutral'></span>
 538 |     | <span class='neutral'>    // creates a labeled address</span>
 539 |     | <span class='neutral'>    function makeAddr(string memory name) internal virtual returns (address addr) {</span>
 540 |     | <span class='neutral'>        (addr,) = makeAddrAndKey(name);</span>
 541 |     | <span class='neutral'>    }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='neutral'>    // Destroys an account immediately, sending the balance to beneficiary.</span>
 544 |     | <span class='neutral'>    // Destroying means: balance will be zero, code will be empty, and nonce will be 0</span>
 545 |     | <span class='neutral'>    // This is similar to selfdestruct but not identical: selfdestruct destroys code and nonce</span>
 546 |     | <span class='neutral'>    // only after tx ends, this will run immediately.</span>
 547 |     | <span class='neutral'>    function destroyAccount(address who, address beneficiary) internal virtual {</span>
 548 |     | <span class='neutral'>        uint256 currBalance = who.balance;</span>
 549 |     | <span class='neutral'>        vm.etch(who, abi.encode());</span>
 550 |     | <span class='neutral'>        vm.deal(who, 0);</span>
 551 |     | <span class='neutral'>        vm.resetNonce(who);</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>        uint256 beneficiaryBalance = beneficiary.balance;</span>
 554 |     | <span class='neutral'>        vm.deal(beneficiary, currBalance + beneficiaryBalance);</span>
 555 |     | <span class='neutral'>    }</span>
 556 |     | <span class='neutral'></span>
 557 |     | <span class='neutral'>    // creates a struct containing both a labeled address and the corresponding private key</span>
 558 |     | <span class='neutral'>    function makeAccount(string memory name) internal virtual returns (Account memory account) {</span>
 559 |     | <span class='neutral'>        (account.addr, account.key) = makeAddrAndKey(name);</span>
 560 |     | <span class='neutral'>    }</span>
 561 |     | <span class='neutral'></span>
 562 |     | <span class='neutral'>    function deriveRememberKey(string memory mnemonic, uint32 index)</span>
 563 |     | <span class='neutral'>        internal</span>
 564 |     | <span class='neutral'>        virtual</span>
 565 |     | <span class='neutral'>        returns (address who, uint256 privateKey)</span>
 566 |     | <span class='neutral'>    {</span>
 567 |     | <span class='neutral'>        privateKey = vm.deriveKey(mnemonic, index);</span>
 568 |     | <span class='neutral'>        who = vm.rememberKey(privateKey);</span>
 569 |     | <span class='neutral'>    }</span>
 570 |     | <span class='neutral'></span>
 571 |     | <span class='neutral'>    function _bytesToUint(bytes memory b) private pure returns (uint256) {</span>
 572 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdCheats _bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
 573 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
 574 |     | <span class='neutral'>    }</span>
 575 |     | <span class='neutral'></span>
 576 |     | <span class='neutral'>    function isFork() internal view virtual returns (bool status) {</span>
 577 |     | <span class='neutral'>        try vm.activeFork() {</span>
 578 |     | <span class='neutral'>            status = true;</span>
 579 |     | <span class='neutral'>        } catch (bytes memory) {}</span>
 580 |     | <span class='neutral'>    }</span>
 581 |     | <span class='neutral'></span>
 582 |     | <span class='neutral'>    modifier skipWhenForking() {</span>
 583 |     | <span class='neutral'>        if (!isFork()) {</span>
 584 |     | <span class='neutral'>            _;</span>
 585 |     | <span class='neutral'>        }</span>
 586 |     | <span class='neutral'>    }</span>
 587 |     | <span class='neutral'></span>
 588 |     | <span class='neutral'>    modifier skipWhenNotForking() {</span>
 589 |     | <span class='neutral'>        if (isFork()) {</span>
 590 |     | <span class='neutral'>            _;</span>
 591 |     | <span class='neutral'>        }</span>
 592 |     | <span class='neutral'>    }</span>
 593 |     | <span class='neutral'></span>
 594 |     | <span class='neutral'>    modifier noGasMetering() {</span>
 595 |     | <span class='neutral'>        vm.pauseGasMetering();</span>
 596 |     | <span class='neutral'>        // To prevent turning gas monitoring back on with nested functions that use this modifier,</span>
 597 |     | <span class='neutral'>        // we check if gasMetering started in the off position. If it did, we don&#39;t want to turn</span>
 598 |     | <span class='neutral'>        // it back on until we exit the top level function that used the modifier</span>
 599 |     | <span class='neutral'>        //</span>
 600 |     | <span class='neutral'>        // i.e. funcA() noGasMetering { funcB() }, where funcB has noGasMetering as well.</span>
 601 |     | <span class='neutral'>        // funcA will have `gasStartedOff` as false, funcB will have it as true,</span>
 602 |     | <span class='neutral'>        // so we only turn metering back on at the end of the funcA</span>
 603 |     | <span class='neutral'>        bool gasStartedOff = gasMeteringOff;</span>
 604 |     | <span class='neutral'>        gasMeteringOff = true;</span>
 605 |     | <span class='neutral'></span>
 606 |     | <span class='neutral'>        _;</span>
 607 |     | <span class='neutral'></span>
 608 |     | <span class='neutral'>        // if gas metering was on when this modifier was called, turn it back on at the end</span>
 609 |     | <span class='neutral'>        if (!gasStartedOff) {</span>
 610 |     | <span class='neutral'>            gasMeteringOff = false;</span>
 611 |     | <span class='neutral'>            vm.resumeGasMetering();</span>
 612 |     | <span class='neutral'>        }</span>
 613 |     | <span class='neutral'>    }</span>
 614 |     | <span class='neutral'></span>
 615 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 616 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 617 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 618 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 619 |     | <span class='neutral'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 620 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 621 |     | <span class='neutral'>        assembly {</span>
 622 |     | <span class='neutral'>            chainId := chainid()</span>
 623 |     | <span class='neutral'>        }</span>
 624 |     | <span class='neutral'></span>
 625 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 626 |     | <span class='neutral'>    }</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='neutral'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 629 |     | <span class='neutral'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 630 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 631 |     | <span class='neutral'>        assembly {</span>
 632 |     | <span class='neutral'>            pureChainId := fnIn</span>
 633 |     | <span class='neutral'>        }</span>
 634 |     | <span class='neutral'>        chainId = pureChainId();</span>
 635 |     | <span class='neutral'>    }</span>
 636 |     | <span class='neutral'>}</span>
 637 |     | <span class='neutral'></span>
 638 |     | <span class='neutral'>// Wrappers around cheatcodes to avoid footguns</span>
 639 |     | <span class='neutral'>abstract contract StdCheats is StdCheatsSafe {</span>
 640 |     | <span class='neutral'>    using stdStorage for StdStorage;</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='neutral'>    StdStorage private stdstore;</span>
 643 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 644 |     | <span class='neutral'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
 645 |     | <span class='neutral'></span>
 646 |     | <span class='neutral'>    // Skip forward or rewind time by the specified number of seconds</span>
 647 |     | <span class='neutral'>    function skip(uint256 time) internal virtual {</span>
 648 |     | <span class='neutral'>        vm.warp(block.timestamp + time);</span>
 649 |     | <span class='neutral'>    }</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>    function rewind(uint256 time) internal virtual {</span>
 652 |     | <span class='neutral'>        vm.warp(block.timestamp - time);</span>
 653 |     | <span class='neutral'>    }</span>
 654 |     | <span class='neutral'></span>
 655 |     | <span class='neutral'>    // Setup a prank from an address that has some ether</span>
 656 |     | <span class='neutral'>    function hoax(address msgSender) internal virtual {</span>
 657 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 658 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 659 |     | <span class='neutral'>    }</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='neutral'>    function hoax(address msgSender, uint256 give) internal virtual {</span>
 662 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 663 |     | <span class='neutral'>        vm.prank(msgSender);</span>
 664 |     | <span class='neutral'>    }</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='neutral'>    function hoax(address msgSender, address origin) internal virtual {</span>
 667 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 668 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 669 |     | <span class='neutral'>    }</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>    function hoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 672 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 673 |     | <span class='neutral'>        vm.prank(msgSender, origin);</span>
 674 |     | <span class='neutral'>    }</span>
 675 |     | <span class='neutral'></span>
 676 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 677 |     | <span class='neutral'>    function startHoax(address msgSender) internal virtual {</span>
 678 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 679 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 680 |     | <span class='neutral'>    }</span>
 681 |     | <span class='neutral'></span>
 682 |     | <span class='neutral'>    function startHoax(address msgSender, uint256 give) internal virtual {</span>
 683 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 684 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 685 |     | <span class='neutral'>    }</span>
 686 |     | <span class='neutral'></span>
 687 |     | <span class='neutral'>    // Start perpetual prank from an address that has some ether</span>
 688 |     | <span class='neutral'>    // tx.origin is set to the origin parameter</span>
 689 |     | <span class='neutral'>    function startHoax(address msgSender, address origin) internal virtual {</span>
 690 |     | <span class='neutral'>        vm.deal(msgSender, 1 &lt;&lt; 128);</span>
 691 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 692 |     | <span class='neutral'>    }</span>
 693 |     | <span class='neutral'></span>
 694 |     | <span class='neutral'>    function startHoax(address msgSender, address origin, uint256 give) internal virtual {</span>
 695 |     | <span class='neutral'>        vm.deal(msgSender, give);</span>
 696 |     | <span class='neutral'>        vm.startPrank(msgSender, origin);</span>
 697 |     | <span class='neutral'>    }</span>
 698 |     | <span class='neutral'></span>
 699 |     | <span class='neutral'>    function changePrank(address msgSender) internal virtual {</span>
 700 |     | <span class='neutral'>        console2_log_StdCheats(&quot;changePrank is deprecated. Please use vm.startPrank instead.&quot;);</span>
 701 |     | <span class='neutral'>        vm.stopPrank();</span>
 702 |     | <span class='neutral'>        vm.startPrank(msgSender);</span>
 703 |     | <span class='neutral'>    }</span>
 704 |     | <span class='neutral'></span>
 705 |     | <span class='neutral'>    function changePrank(address msgSender, address txOrigin) internal virtual {</span>
 706 |     | <span class='neutral'>        vm.stopPrank();</span>
 707 |     | <span class='neutral'>        vm.startPrank(msgSender, txOrigin);</span>
 708 |     | <span class='neutral'>    }</span>
 709 |     | <span class='neutral'></span>
 710 |     | <span class='neutral'>    // The same as Vm&#39;s `deal`</span>
 711 |     | <span class='neutral'>    // Use the alternative signature for ERC20 tokens</span>
 712 |     | <span class='neutral'>    function deal(address to, uint256 give) internal virtual {</span>
 713 |     | <span class='neutral'>        vm.deal(to, give);</span>
 714 |     | <span class='neutral'>    }</span>
 715 |     | <span class='neutral'></span>
 716 |     | <span class='neutral'>    // Set the balance of an account for any ERC20 token</span>
 717 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 718 |     | <span class='neutral'>    function deal(address token, address to, uint256 give) internal virtual {</span>
 719 |     | <span class='neutral'>        deal(token, to, give, false);</span>
 720 |     | <span class='neutral'>    }</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>    // Set the balance of an account for any ERC1155 token</span>
 723 |     | <span class='neutral'>    // Use the alternative signature to update `totalSupply`</span>
 724 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give) internal virtual {</span>
 725 |     | <span class='neutral'>        dealERC1155(token, to, id, give, false);</span>
 726 |     | <span class='neutral'>    }</span>
 727 |     | <span class='neutral'></span>
 728 |     | <span class='neutral'>    function deal(address token, address to, uint256 give, bool adjust) internal virtual {</span>
 729 |     | <span class='neutral'>        // get current balance</span>
 730 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 731 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 732 |     | <span class='neutral'></span>
 733 |     | <span class='neutral'>        // update balance</span>
 734 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(give);</span>
 735 |     | <span class='neutral'></span>
 736 |     | <span class='neutral'>        // update total supply</span>
 737 |     | <span class='neutral'>        if (adjust) {</span>
 738 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0x18160ddd));</span>
 739 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 740 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 741 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 742 |     | <span class='neutral'>            } else {</span>
 743 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 744 |     | <span class='neutral'>            }</span>
 745 |     | <span class='neutral'>            stdstore.target(token).sig(0x18160ddd).checked_write(totSup);</span>
 746 |     | <span class='neutral'>        }</span>
 747 |     | <span class='neutral'>    }</span>
 748 |     | <span class='neutral'></span>
 749 |     | <span class='neutral'>    function dealERC1155(address token, address to, uint256 id, uint256 give, bool adjust) internal virtual {</span>
 750 |     | <span class='neutral'>        // get current balance</span>
 751 |     | <span class='neutral'>        (, bytes memory balData) = token.staticcall(abi.encodeWithSelector(0x00fdd58e, to, id));</span>
 752 |     | <span class='neutral'>        uint256 prevBal = abi.decode(balData, (uint256));</span>
 753 |     | <span class='neutral'></span>
 754 |     | <span class='neutral'>        // update balance</span>
 755 |     | <span class='neutral'>        stdstore.target(token).sig(0x00fdd58e).with_key(to).with_key(id).checked_write(give);</span>
 756 |     | <span class='neutral'></span>
 757 |     | <span class='neutral'>        // update total supply</span>
 758 |     | <span class='neutral'>        if (adjust) {</span>
 759 |     | <span class='neutral'>            (, bytes memory totSupData) = token.staticcall(abi.encodeWithSelector(0xbd85b039, id));</span>
 760 |     | <span class='neutral'>            require(</span>
 761 |     | <span class='neutral'>                totSupData.length != 0,</span>
 762 |     | <span class='neutral'>                &quot;StdCheats deal(address,address,uint,uint,bool): target contract is not ERC1155Supply.&quot;</span>
 763 |     | <span class='neutral'>            );</span>
 764 |     | <span class='neutral'>            uint256 totSup = abi.decode(totSupData, (uint256));</span>
 765 |     | <span class='neutral'>            if (give &lt; prevBal) {</span>
 766 |     | <span class='neutral'>                totSup -= (prevBal - give);</span>
 767 |     | <span class='neutral'>            } else {</span>
 768 |     | <span class='neutral'>                totSup += (give - prevBal);</span>
 769 |     | <span class='neutral'>            }</span>
 770 |     | <span class='neutral'>            stdstore.target(token).sig(0xbd85b039).with_key(id).checked_write(totSup);</span>
 771 |     | <span class='neutral'>        }</span>
 772 |     | <span class='neutral'>    }</span>
 773 |     | <span class='neutral'></span>
 774 |     | <span class='neutral'>    function dealERC721(address token, address to, uint256 id) internal virtual {</span>
 775 |     | <span class='neutral'>        // check if token id is already minted and the actual owner.</span>
 776 |     | <span class='neutral'>        (bool successMinted, bytes memory ownerData) = token.staticcall(abi.encodeWithSelector(0x6352211e, id));</span>
 777 |     | <span class='neutral'>        require(successMinted, &quot;StdCheats deal(address,address,uint,bool): id not minted.&quot;);</span>
 778 |     | <span class='neutral'></span>
 779 |     | <span class='neutral'>        // get owner current balance</span>
 780 |     | <span class='neutral'>        (, bytes memory fromBalData) =</span>
 781 |     | <span class='neutral'>            token.staticcall(abi.encodeWithSelector(0x70a08231, abi.decode(ownerData, (address))));</span>
 782 |     | <span class='neutral'>        uint256 fromPrevBal = abi.decode(fromBalData, (uint256));</span>
 783 |     | <span class='neutral'></span>
 784 |     | <span class='neutral'>        // get new user current balance</span>
 785 |     | <span class='neutral'>        (, bytes memory toBalData) = token.staticcall(abi.encodeWithSelector(0x70a08231, to));</span>
 786 |     | <span class='neutral'>        uint256 toPrevBal = abi.decode(toBalData, (uint256));</span>
 787 |     | <span class='neutral'></span>
 788 |     | <span class='neutral'>        // update balances</span>
 789 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(abi.decode(ownerData, (address))).checked_write(--fromPrevBal);</span>
 790 |     | <span class='neutral'>        stdstore.target(token).sig(0x70a08231).with_key(to).checked_write(++toPrevBal);</span>
 791 |     | <span class='neutral'></span>
 792 |     | <span class='neutral'>        // update owner</span>
 793 |     | <span class='neutral'>        stdstore.target(token).sig(0x6352211e).with_key(id).checked_write(to);</span>
 794 |     | <span class='neutral'>    }</span>
 795 |     | <span class='neutral'></span>
 796 |     | <span class='neutral'>    function deployCodeTo(string memory what, address where) internal virtual {</span>
 797 |     | <span class='neutral'>        deployCodeTo(what, &quot;&quot;, 0, where);</span>
 798 |     | <span class='neutral'>    }</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, address where) internal virtual {</span>
 801 |     | <span class='neutral'>        deployCodeTo(what, args, 0, where);</span>
 802 |     | <span class='neutral'>    }</span>
 803 |     | <span class='neutral'></span>
 804 |     | <span class='neutral'>    function deployCodeTo(string memory what, bytes memory args, uint256 value, address where) internal virtual {</span>
 805 |     | <span class='neutral'>        bytes memory creationCode = vm.getCode(what);</span>
 806 |     | <span class='neutral'>        vm.etch(where, abi.encodePacked(creationCode, args));</span>
 807 |     | <span class='neutral'>        (bool success, bytes memory runtimeBytecode) = where.call{value: value}(&quot;&quot;);</span>
 808 |     | <span class='neutral'>        require(success, &quot;StdCheats deployCodeTo(string,bytes,uint256,address): Failed to create runtime bytecode.&quot;);</span>
 809 |     | <span class='neutral'>        vm.etch(where, runtimeBytecode);</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    // Used to prevent the compilation of console, which shortens the compilation time when console is not used elsewhere.</span>
 813 |     | <span class='neutral'>    function console2_log_StdCheats(string memory p0) private view {</span>
 814 |     | <span class='neutral'>        (bool status,) = address(CONSOLE2_ADDRESS).staticcall(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 815 |     | <span class='neutral'>        status;</span>
 816 |     | <span class='neutral'>    }</span>
 817 |     | <span class='neutral'>}</span>
 818 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdError.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// Panics work for versions &gt;=0.8.0, but we lowered the pragma to make this compatible with Test</span>
  3 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library stdError {</span>
  6 |     | <span class='unexecuted'>    bytes public constant assertionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x01);</span>
  7 |     | <span class='unexecuted'>    bytes public constant arithmeticError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x11);</span>
  8 |     | <span class='unexecuted'>    bytes public constant divisionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x12);</span>
  9 |     | <span class='unexecuted'>    bytes public constant enumConversionError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x21);</span>
 10 |     | <span class='unexecuted'>    bytes public constant encodeStorageError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x22);</span>
 11 |     | <span class='unexecuted'>    bytes public constant popError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x31);</span>
 12 |     | <span class='unexecuted'>    bytes public constant indexOOBError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x32);</span>
 13 |     | <span class='unexecuted'>    bytes public constant memOverflowError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x41);</span>
 14 |     | <span class='unexecuted'>    bytes public constant zeroVarError = abi.encodeWithSignature(&quot;Panic(uint256)&quot;, 0x51);</span>
 15 |     | <span class='neutral'>}</span>
 16 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdInvariant.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>abstract contract StdInvariant {</span>
   7 |     | <span class='neutral'>    struct FuzzSelector {</span>
   8 |     | <span class='neutral'>        address addr;</span>
   9 |     | <span class='neutral'>        bytes4[] selectors;</span>
  10 |     | <span class='neutral'>    }</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    struct FuzzArtifactSelector {</span>
  13 |     | <span class='neutral'>        string artifact;</span>
  14 |     | <span class='neutral'>        bytes4[] selectors;</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    struct FuzzInterface {</span>
  18 |     | <span class='neutral'>        address addr;</span>
  19 |     | <span class='neutral'>        string[] artifacts;</span>
  20 |     | <span class='neutral'>    }</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    address[] private _excludedContracts;</span>
  23 |     | <span class='neutral'>    address[] private _excludedSenders;</span>
  24 |     | <span class='neutral'>    address[] private _targetedContracts;</span>
  25 |     | <span class='neutral'>    address[] private _targetedSenders;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    string[] private _excludedArtifacts;</span>
  28 |     | <span class='neutral'>    string[] private _targetedArtifacts;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    FuzzArtifactSelector[] private _targetedArtifactSelectors;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    FuzzSelector[] private _excludedSelectors;</span>
  33 |     | <span class='neutral'>    FuzzSelector[] private _targetedSelectors;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    FuzzInterface[] private _targetedInterfaces;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    // Functions for users:</span>
  38 |     | <span class='neutral'>    // These are intended to be called in tests.</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function excludeContract(address newExcludedContract_) internal {</span>
  41 |     | <span class='neutral'>        _excludedContracts.push(newExcludedContract_);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function excludeSelector(FuzzSelector memory newExcludedSelector_) internal {</span>
  45 |     | <span class='neutral'>        _excludedSelectors.push(newExcludedSelector_);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function excludeSender(address newExcludedSender_) internal {</span>
  49 |     | <span class='neutral'>        _excludedSenders.push(newExcludedSender_);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function excludeArtifact(string memory newExcludedArtifact_) internal {</span>
  53 |     | <span class='neutral'>        _excludedArtifacts.push(newExcludedArtifact_);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function targetArtifact(string memory newTargetedArtifact_) internal {</span>
  57 |     | <span class='neutral'>        _targetedArtifacts.push(newTargetedArtifact_);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function targetArtifactSelector(FuzzArtifactSelector memory newTargetedArtifactSelector_) internal {</span>
  61 |     | <span class='neutral'>        _targetedArtifactSelectors.push(newTargetedArtifactSelector_);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function targetContract(address newTargetedContract_) internal {</span>
  65 |     | <span class='neutral'>        _targetedContracts.push(newTargetedContract_);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function targetSelector(FuzzSelector memory newTargetedSelector_) internal {</span>
  69 |     | <span class='neutral'>        _targetedSelectors.push(newTargetedSelector_);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function targetSender(address newTargetedSender_) internal {</span>
  73 |     | <span class='neutral'>        _targetedSenders.push(newTargetedSender_);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function targetInterface(FuzzInterface memory newTargetedInterface_) internal {</span>
  77 |     | <span class='neutral'>        _targetedInterfaces.push(newTargetedInterface_);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // Functions for forge:</span>
  81 |     | <span class='neutral'>    // These are called by forge to run invariant tests and don&#39;t need to be called in tests.</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function excludeArtifacts() public view returns (string[] memory excludedArtifacts_) {</span>
  84 | *   | <span class='executed'>        excludedArtifacts_ = _excludedArtifacts;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 | *   | <span class='executed'>    function excludeContracts() public view returns (address[] memory excludedContracts_) {</span>
  88 | *   | <span class='executed'>        excludedContracts_ = _excludedContracts;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 | *   | <span class='executed'>    function excludeSelectors() public view returns (FuzzSelector[] memory excludedSelectors_) {</span>
  92 | *   | <span class='executed'>        excludedSelectors_ = _excludedSelectors;</span>
  93 |     | <span class='neutral'>    }</span>
  94 |     | <span class='neutral'></span>
  95 | *   | <span class='executed'>    function excludeSenders() public view returns (address[] memory excludedSenders_) {</span>
  96 | *   | <span class='executed'>        excludedSenders_ = _excludedSenders;</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 | *   | <span class='executed'>    function targetArtifacts() public view returns (string[] memory targetedArtifacts_) {</span>
 100 | *   | <span class='executed'>        targetedArtifacts_ = _targetedArtifacts;</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 | *   | <span class='executed'>    function targetArtifactSelectors() public view returns (FuzzArtifactSelector[] memory targetedArtifactSelectors_) {</span>
 104 | *   | <span class='executed'>        targetedArtifactSelectors_ = _targetedArtifactSelectors;</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 | *   | <span class='executed'>    function targetContracts() public view returns (address[] memory targetedContracts_) {</span>
 108 | *   | <span class='executed'>        targetedContracts_ = _targetedContracts;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>    function targetSelectors() public view returns (FuzzSelector[] memory targetedSelectors_) {</span>
 112 | *   | <span class='executed'>        targetedSelectors_ = _targetedSelectors;</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 | *   | <span class='executed'>    function targetSenders() public view returns (address[] memory targetedSenders_) {</span>
 116 | *   | <span class='executed'>        targetedSenders_ = _targetedSenders;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 | *   | <span class='executed'>    function targetInterfaces() public view returns (FuzzInterface[] memory targetedInterfaces_) {</span>
 120 | *   | <span class='executed'>        targetedInterfaces_ = _targetedInterfaces;</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdJson.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing JSON files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdJson for string;</span>
  12 |     | <span class='neutral'>// string memory json = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// json.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdJson for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdJson {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function parseRaw(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  29 |     | <span class='neutral'>        return vm.parseJson(json, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function readUint(string memory json, string memory key) internal pure returns (uint256) {</span>
  33 |     | <span class='neutral'>        return vm.parseJsonUint(json, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUintArray(string memory json, string memory key) internal pure returns (uint256[] memory) {</span>
  37 |     | <span class='neutral'>        return vm.parseJsonUintArray(json, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readInt(string memory json, string memory key) internal pure returns (int256) {</span>
  41 |     | <span class='neutral'>        return vm.parseJsonInt(json, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readIntArray(string memory json, string memory key) internal pure returns (int256[] memory) {</span>
  45 |     | <span class='neutral'>        return vm.parseJsonIntArray(json, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readBytes32(string memory json, string memory key) internal pure returns (bytes32) {</span>
  49 |     | <span class='neutral'>        return vm.parseJsonBytes32(json, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32Array(string memory json, string memory key) internal pure returns (bytes32[] memory) {</span>
  53 |     | <span class='neutral'>        return vm.parseJsonBytes32Array(json, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readString(string memory json, string memory key) internal pure returns (string memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseJsonString(json, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readStringArray(string memory json, string memory key) internal pure returns (string[] memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseJsonStringArray(json, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readAddress(string memory json, string memory key) internal pure returns (address) {</span>
  65 |     | <span class='neutral'>        return vm.parseJsonAddress(json, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddressArray(string memory json, string memory key) internal pure returns (address[] memory) {</span>
  69 |     | <span class='neutral'>        return vm.parseJsonAddressArray(json, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readBool(string memory json, string memory key) internal pure returns (bool) {</span>
  73 |     | <span class='neutral'>        return vm.parseJsonBool(json, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBoolArray(string memory json, string memory key) internal pure returns (bool[] memory) {</span>
  77 |     | <span class='neutral'>        return vm.parseJsonBoolArray(json, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBytes(string memory json, string memory key) internal pure returns (bytes memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseJsonBytes(json, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytesArray(string memory json, string memory key) internal pure returns (bytes[] memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseJsonBytesArray(json, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
  89 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeJson(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeJson(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library stdMath {</span>
  5 |     | <span class='neutral'>    int256 private constant INT256_MIN = -57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function abs(int256 a) internal pure returns (uint256) {</span>
  8 |     | <span class='neutral'>        // Required or it will fail when `a = type(int256).min`</span>
  9 |     | <span class='neutral'>        if (a == INT256_MIN) {</span>
 10 |     | <span class='neutral'>            return 57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
 11 |     | <span class='neutral'>        }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>        return uint256(a &gt; 0 ? a : -a);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function delta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 17 |     | <span class='neutral'>        return a &gt; b ? a - b : b - a;</span>
 18 |     | <span class='neutral'>    }</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function delta(int256 a, int256 b) internal pure returns (uint256) {</span>
 21 |     | <span class='neutral'>        // a and b are of the same sign</span>
 22 |     | <span class='neutral'>        // this works thanks to two&#39;s complement, the left-most bit is the sign bit</span>
 23 |     | <span class='neutral'>        if ((a ^ b) &gt; -1) {</span>
 24 |     | <span class='neutral'>            return delta(abs(a), abs(b));</span>
 25 |     | <span class='neutral'>        }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>        // a and b are of opposite signs</span>
 28 |     | <span class='neutral'>        return abs(a) + abs(b);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function percentDelta(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 32 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>        return absDelta * 1e18 / b;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function percentDelta(int256 a, int256 b) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        uint256 absDelta = delta(a, b);</span>
 39 |     | <span class='neutral'>        uint256 absB = abs(b);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>        return absDelta * 1e18 / absB;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdStorage.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>struct FindData {</span>
   7 |     | <span class='neutral'>    uint256 slot;</span>
   8 |     | <span class='neutral'>    uint256 offsetLeft;</span>
   9 |     | <span class='neutral'>    uint256 offsetRight;</span>
  10 |     | <span class='neutral'>    bool found;</span>
  11 |     | <span class='neutral'>}</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>struct StdStorage {</span>
  14 |     | <span class='neutral'>    mapping(address =&gt; mapping(bytes4 =&gt; mapping(bytes32 =&gt; FindData))) finds;</span>
  15 |     | <span class='neutral'>    bytes32[] _keys;</span>
  16 |     | <span class='neutral'>    bytes4 _sig;</span>
  17 |     | <span class='neutral'>    uint256 _depth;</span>
  18 |     | <span class='neutral'>    address _target;</span>
  19 |     | <span class='neutral'>    bytes32 _set;</span>
  20 |     | <span class='neutral'>    bool _enable_packed_slots;</span>
  21 |     | <span class='neutral'>    bytes _calldata;</span>
  22 |     | <span class='neutral'>}</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='unexecuted'>library stdStorageSafe {</span>
  25 |     | <span class='neutral'>    event SlotFound(address who, bytes4 fsig, bytes32 keysHash, uint256 slot);</span>
  26 |     | <span class='neutral'>    event WARNING_UninitedSlot(address who, uint256 slot);</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  29 |     | <span class='neutral'>    uint256 constant UINT256_MAX = 115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
  32 |     | <span class='neutral'>        return bytes4(keccak256(bytes(sigStr)));</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    function getCallParams(StdStorage storage self) internal view returns (bytes memory) {</span>
  36 |     | <span class='neutral'>        if (self._calldata.length == 0) {</span>
  37 |     | <span class='neutral'>            return flatten(self._keys);</span>
  38 |     | <span class='neutral'>        } else {</span>
  39 |     | <span class='neutral'>            return self._calldata;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    // Calls target contract with configured parameters</span>
  44 |     | <span class='neutral'>    function callTarget(StdStorage storage self) internal view returns (bool, bytes32) {</span>
  45 |     | <span class='neutral'>        bytes memory cald = abi.encodePacked(self._sig, getCallParams(self));</span>
  46 |     | <span class='neutral'>        (bool success, bytes memory rdat) = self._target.staticcall(cald);</span>
  47 |     | <span class='neutral'>        bytes32 result = bytesToBytes32(rdat, 32 * self._depth);</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>        return (success, result);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    // Tries mutating slot value to determine if the targeted value is stored in it.</span>
  53 |     | <span class='neutral'>    // If current value is 0, then we are setting slot value to type(uint256).max</span>
  54 |     | <span class='neutral'>    // Otherwise, we set it to 0. That way, return value should always be affected.</span>
  55 |     | <span class='neutral'>    function checkSlotMutatesCall(StdStorage storage self, bytes32 slot) internal returns (bool) {</span>
  56 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  57 |     | <span class='neutral'>        (bool success, bytes32 prevReturnValue) = callTarget(self);</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>        bytes32 testVal = prevReturnValue == bytes32(0) ? bytes32(UINT256_MAX) : bytes32(0);</span>
  60 |     | <span class='neutral'>        vm.store(self._target, slot, testVal);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        (, bytes32 newReturnValue) = callTarget(self);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        return (success &amp;&amp; (prevReturnValue != newReturnValue));</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    // Tries setting one of the bits in slot to 1 until return value changes.</span>
  70 |     | <span class='neutral'>    // Index of resulted bit is an offset packed slot has from left/right side</span>
  71 |     | <span class='neutral'>    function findOffset(StdStorage storage self, bytes32 slot, bool left) internal returns (bool, uint256) {</span>
  72 |     | <span class='neutral'>        for (uint256 offset = 0; offset &lt; 256; offset++) {</span>
  73 |     | <span class='neutral'>            uint256 valueToPut = left ? (1 &lt;&lt; (255 - offset)) : (1 &lt;&lt; offset);</span>
  74 |     | <span class='neutral'>            vm.store(self._target, slot, bytes32(valueToPut));</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            (bool success, bytes32 data) = callTarget(self);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>            if (success &amp;&amp; (uint256(data) &gt; 0)) {</span>
  79 |     | <span class='neutral'>                return (true, offset);</span>
  80 |     | <span class='neutral'>            }</span>
  81 |     | <span class='neutral'>        }</span>
  82 |     | <span class='neutral'>        return (false, 0);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function findOffsets(StdStorage storage self, bytes32 slot) internal returns (bool, uint256, uint256) {</span>
  86 |     | <span class='neutral'>        bytes32 prevSlotValue = vm.load(self._target, slot);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>        (bool foundLeft, uint256 offsetLeft) = findOffset(self, slot, true);</span>
  89 |     | <span class='neutral'>        (bool foundRight, uint256 offsetRight) = findOffset(self, slot, false);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>        // `findOffset` may mutate slot value, so we are setting it to initial value</span>
  92 |     | <span class='neutral'>        vm.store(self._target, slot, prevSlotValue);</span>
  93 |     | <span class='neutral'>        return (foundLeft &amp;&amp; foundRight, offsetLeft, offsetRight);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (FindData storage) {</span>
  97 |     | <span class='neutral'>        return find(self, true);</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice find an arbitrary storage slot given a function sig, input data, address of the contract and a value to check against</span>
 101 |     | <span class='neutral'>    // slot complexity:</span>
 102 |     | <span class='neutral'>    //  if flat, will be bytes32(uint256(uint));</span>
 103 |     | <span class='neutral'>    //  if map, will be keccak256(abi.encode(key, uint(slot)));</span>
 104 |     | <span class='neutral'>    //  if deep map, will be keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))));</span>
 105 |     | <span class='neutral'>    //  if map struct, will be bytes32(uint256(keccak256(abi.encode(key1, keccak256(abi.encode(key0, uint(slot)))))) + structFieldDepth);</span>
 106 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (FindData storage) {</span>
 107 |     | <span class='neutral'>        address who = self._target;</span>
 108 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 109 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 110 |     | <span class='neutral'>        bytes memory params = getCallParams(self);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>        // calldata to test against</span>
 113 |     | <span class='neutral'>        if (self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 114 |     | <span class='neutral'>            if (_clear) {</span>
 115 |     | <span class='neutral'>                clear(self);</span>
 116 |     | <span class='neutral'>            }</span>
 117 |     | <span class='neutral'>            return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 118 |     | <span class='neutral'>        }</span>
 119 |     | <span class='neutral'>        vm.record();</span>
 120 |     | <span class='neutral'>        (, bytes32 callResult) = callTarget(self);</span>
 121 |     | <span class='neutral'>        (bytes32[] memory reads,) = vm.accesses(address(who));</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>        if (reads.length == 0) {</span>
 124 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): No storage use detected for target.&quot;);</span>
 125 |     | <span class='neutral'>        } else {</span>
 126 |     | <span class='neutral'>            for (uint256 i = 0; i &lt; reads.length; i++) {</span>
 127 |     | <span class='neutral'>                bytes32 prev = vm.load(who, reads[i]);</span>
 128 |     | <span class='neutral'>                if (prev == bytes32(0)) {</span>
 129 |     | <span class='neutral'>                    emit WARNING_UninitedSlot(who, uint256(reads[i]));</span>
 130 |     | <span class='neutral'>                }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>                if (!checkSlotMutatesCall(self, reads[i])) {</span>
 133 |     | <span class='neutral'>                    continue;</span>
 134 |     | <span class='neutral'>                }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>                (uint256 offsetLeft, uint256 offsetRight) = (0, 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>                if (self._enable_packed_slots) {</span>
 139 |     | <span class='neutral'>                    bool found;</span>
 140 |     | <span class='neutral'>                    (found, offsetLeft, offsetRight) = findOffsets(self, reads[i]);</span>
 141 |     | <span class='neutral'>                    if (!found) {</span>
 142 |     | <span class='neutral'>                        continue;</span>
 143 |     | <span class='neutral'>                    }</span>
 144 |     | <span class='neutral'>                }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>                // Check that value between found offsets is equal to the current call result</span>
 147 |     | <span class='neutral'>                uint256 curVal = (uint256(prev) &amp; getMaskByOffsets(offsetLeft, offsetRight)) &gt;&gt; offsetRight;</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>                if (uint256(callResult) != curVal) {</span>
 150 |     | <span class='neutral'>                    continue;</span>
 151 |     | <span class='neutral'>                }</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>                emit SlotFound(who, fsig, keccak256(abi.encodePacked(params, field_depth)), uint256(reads[i]));</span>
 154 |     | <span class='neutral'>                self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))] =</span>
 155 |     | <span class='neutral'>                    FindData(uint256(reads[i]), offsetLeft, offsetRight, true);</span>
 156 |     | <span class='neutral'>                break;</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>        }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>        require(</span>
 161 |     | <span class='neutral'>            self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found,</span>
 162 |     | <span class='neutral'>            &quot;stdStorage find(StdStorage): Slot(s) not found.&quot;</span>
 163 |     | <span class='neutral'>        );</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>        if (_clear) {</span>
 166 |     | <span class='neutral'>            clear(self);</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        return self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 172 |     | <span class='neutral'>        self._target = _target;</span>
 173 |     | <span class='neutral'>        return self;</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 177 |     | <span class='neutral'>        self._sig = _sig;</span>
 178 |     | <span class='neutral'>        return self;</span>
 179 |     | <span class='neutral'>    }</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 182 |     | <span class='neutral'>        self._sig = sigs(_sig);</span>
 183 |     | <span class='neutral'>        return self;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 187 |     | <span class='neutral'>        self._calldata = _calldata;</span>
 188 |     | <span class='neutral'>        return self;</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 192 |     | <span class='neutral'>        self._keys.push(bytes32(uint256(uint160(who))));</span>
 193 |     | <span class='neutral'>        return self;</span>
 194 |     | <span class='neutral'>    }</span>
 195 |     | <span class='neutral'></span>
 196 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 197 |     | <span class='neutral'>        self._keys.push(bytes32(amt));</span>
 198 |     | <span class='neutral'>        return self;</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 202 |     | <span class='neutral'>        self._keys.push(key);</span>
 203 |     | <span class='neutral'>        return self;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 207 |     | <span class='neutral'>        self._enable_packed_slots = true;</span>
 208 |     | <span class='neutral'>        return self;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 212 |     | <span class='neutral'>        self._depth = _depth;</span>
 213 |     | <span class='neutral'>        return self;</span>
 214 |     | <span class='neutral'>    }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='neutral'>    function read(StdStorage storage self) private returns (bytes memory) {</span>
 217 |     | <span class='neutral'>        FindData storage data = find(self, false);</span>
 218 |     | <span class='neutral'>        uint256 mask = getMaskByOffsets(data.offsetLeft, data.offsetRight);</span>
 219 |     | <span class='neutral'>        uint256 value = (uint256(vm.load(self._target, bytes32(data.slot))) &amp; mask) &gt;&gt; data.offsetRight;</span>
 220 |     | <span class='neutral'>        clear(self);</span>
 221 |     | <span class='neutral'>        return abi.encode(value);</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 225 |     | <span class='neutral'>        return abi.decode(read(self), (bytes32));</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 229 |     | <span class='neutral'>        int256 v = read_int(self);</span>
 230 |     | <span class='neutral'>        if (v == 0) return false;</span>
 231 |     | <span class='neutral'>        if (v == 1) return true;</span>
 232 |     | <span class='neutral'>        revert(&quot;stdStorage read_bool(StdStorage): Cannot decode. Make sure you are reading a bool.&quot;);</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 236 |     | <span class='neutral'>        return abi.decode(read(self), (address));</span>
 237 |     | <span class='neutral'>    }</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 240 |     | <span class='neutral'>        return abi.decode(read(self), (uint256));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 244 |     | <span class='neutral'>        return abi.decode(read(self), (int256));</span>
 245 |     | <span class='neutral'>    }</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 248 |     | <span class='neutral'>        address who = self._target;</span>
 249 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 250 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 251 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 252 |     | <span class='neutral'>        (bool found, bytes32 key, bytes32 parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 253 |     | <span class='neutral'>        if (!found) {</span>
 254 |     | <span class='neutral'>            revert(</span>
 255 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 256 |     | <span class='neutral'>            );</span>
 257 |     | <span class='neutral'>        }</span>
 258 |     | <span class='neutral'>        return (uint256(parent_slot), key);</span>
 259 |     | <span class='neutral'>    }</span>
 260 |     | <span class='neutral'></span>
 261 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 262 |     | <span class='neutral'>        address who = self._target;</span>
 263 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 264 |     | <span class='neutral'>        vm.startMappingRecording();</span>
 265 |     | <span class='neutral'>        uint256 child = find(self, true).slot - field_depth;</span>
 266 |     | <span class='neutral'>        bool found;</span>
 267 |     | <span class='neutral'>        bytes32 root_slot;</span>
 268 |     | <span class='neutral'>        bytes32 parent_slot;</span>
 269 |     | <span class='neutral'>        (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(child));</span>
 270 |     | <span class='neutral'>        if (!found) {</span>
 271 |     | <span class='neutral'>            revert(</span>
 272 |     | <span class='neutral'>                &quot;stdStorage read_bool(StdStorage): Cannot find parent. Make sure you give a slot and startMappingRecording() has been called.&quot;</span>
 273 |     | <span class='neutral'>            );</span>
 274 |     | <span class='neutral'>        }</span>
 275 |     | <span class='neutral'>        while (found) {</span>
 276 |     | <span class='neutral'>            root_slot = parent_slot;</span>
 277 |     | <span class='neutral'>            (found,, parent_slot) = vm.getMappingKeyAndParentOf(who, bytes32(root_slot));</span>
 278 |     | <span class='neutral'>        }</span>
 279 |     | <span class='neutral'>        return uint256(root_slot);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function bytesToBytes32(bytes memory b, uint256 offset) private pure returns (bytes32) {</span>
 283 |     | <span class='neutral'>        bytes32 out;</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        uint256 max = b.length &gt; 32 ? 32 : b.length;</span>
 286 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; max; i++) {</span>
 287 |     | <span class='neutral'>            out |= bytes32(b[offset + i] &amp; 0xFF) &gt;&gt; (i * 8);</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'>        return out;</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='neutral'>    function flatten(bytes32[] memory b) private pure returns (bytes memory) {</span>
 293 |     | <span class='neutral'>        bytes memory result = new bytes(b.length * 32);</span>
 294 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; b.length; i++) {</span>
 295 |     | <span class='neutral'>            bytes32 k = b[i];</span>
 296 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 297 |     | <span class='neutral'>            assembly {</span>
 298 |     | <span class='neutral'>                mstore(add(result, add(32, mul(32, i))), k)</span>
 299 |     | <span class='neutral'>            }</span>
 300 |     | <span class='neutral'>        }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        return result;</span>
 303 |     | <span class='neutral'>    }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 306 |     | <span class='neutral'>        delete self._target;</span>
 307 |     | <span class='neutral'>        delete self._sig;</span>
 308 |     | <span class='neutral'>        delete self._keys;</span>
 309 |     | <span class='neutral'>        delete self._depth;</span>
 310 |     | <span class='neutral'>        delete self._enable_packed_slots;</span>
 311 |     | <span class='neutral'>        delete self._calldata;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    // Returns mask which contains non-zero bits for values between `offsetLeft` and `offsetRight`</span>
 315 |     | <span class='neutral'>    // (slotValue &amp; mask) &gt;&gt; offsetRight will be the value of the given packed variable</span>
 316 |     | <span class='neutral'>    function getMaskByOffsets(uint256 offsetLeft, uint256 offsetRight) internal pure returns (uint256 mask) {</span>
 317 |     | <span class='neutral'>        // mask = ((1 &lt;&lt; (256 - (offsetRight + offsetLeft))) - 1) &lt;&lt; offsetRight;</span>
 318 |     | <span class='neutral'>        // using assembly because (1 &lt;&lt; 256) causes overflow</span>
 319 |     | <span class='neutral'>        assembly {</span>
 320 |     | <span class='neutral'>            mask := shl(offsetRight, sub(shl(sub(256, add(offsetRight, offsetLeft)), 1), 1))</span>
 321 |     | <span class='neutral'>        }</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='neutral'>    // Returns slot value with updated packed variable.</span>
 325 |     | <span class='neutral'>    function getUpdatedSlotValue(bytes32 curValue, uint256 varValue, uint256 offsetLeft, uint256 offsetRight)</span>
 326 |     | <span class='neutral'>        internal</span>
 327 |     | <span class='neutral'>        pure</span>
 328 |     | <span class='neutral'>        returns (bytes32 newValue)</span>
 329 |     | <span class='neutral'>    {</span>
 330 |     | <span class='neutral'>        return bytes32((uint256(curValue) &amp; ~getMaskByOffsets(offsetLeft, offsetRight)) | (varValue &lt;&lt; offsetRight));</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='neutral'>}</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>library stdStorage {</span>
 335 |     | <span class='neutral'>    Vm private constant vm = Vm(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>    function sigs(string memory sigStr) internal pure returns (bytes4) {</span>
 338 |     | <span class='neutral'>        return stdStorageSafe.sigs(sigStr);</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function find(StdStorage storage self) internal returns (uint256) {</span>
 342 |     | <span class='neutral'>        return find(self, true);</span>
 343 |     | <span class='neutral'>    }</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    function find(StdStorage storage self, bool _clear) internal returns (uint256) {</span>
 346 |     | <span class='neutral'>        return stdStorageSafe.find(self, _clear).slot;</span>
 347 |     | <span class='neutral'>    }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>    function target(StdStorage storage self, address _target) internal returns (StdStorage storage) {</span>
 350 |     | <span class='neutral'>        return stdStorageSafe.target(self, _target);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='neutral'>    function sig(StdStorage storage self, bytes4 _sig) internal returns (StdStorage storage) {</span>
 354 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    function sig(StdStorage storage self, string memory _sig) internal returns (StdStorage storage) {</span>
 358 |     | <span class='neutral'>        return stdStorageSafe.sig(self, _sig);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    function with_key(StdStorage storage self, address who) internal returns (StdStorage storage) {</span>
 362 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, who);</span>
 363 |     | <span class='neutral'>    }</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    function with_key(StdStorage storage self, uint256 amt) internal returns (StdStorage storage) {</span>
 366 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, amt);</span>
 367 |     | <span class='neutral'>    }</span>
 368 |     | <span class='neutral'></span>
 369 |     | <span class='neutral'>    function with_key(StdStorage storage self, bytes32 key) internal returns (StdStorage storage) {</span>
 370 |     | <span class='neutral'>        return stdStorageSafe.with_key(self, key);</span>
 371 |     | <span class='neutral'>    }</span>
 372 |     | <span class='neutral'></span>
 373 |     | <span class='neutral'>    function with_calldata(StdStorage storage self, bytes memory _calldata) internal returns (StdStorage storage) {</span>
 374 |     | <span class='neutral'>        return stdStorageSafe.with_calldata(self, _calldata);</span>
 375 |     | <span class='neutral'>    }</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    function enable_packed_slots(StdStorage storage self) internal returns (StdStorage storage) {</span>
 378 |     | <span class='neutral'>        return stdStorageSafe.enable_packed_slots(self);</span>
 379 |     | <span class='neutral'>    }</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>    function depth(StdStorage storage self, uint256 _depth) internal returns (StdStorage storage) {</span>
 382 |     | <span class='neutral'>        return stdStorageSafe.depth(self, _depth);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function clear(StdStorage storage self) internal {</span>
 386 |     | <span class='neutral'>        stdStorageSafe.clear(self);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    function checked_write(StdStorage storage self, address who) internal {</span>
 390 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(uint160(who))));</span>
 391 |     | <span class='neutral'>    }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>    function checked_write(StdStorage storage self, uint256 amt) internal {</span>
 394 |     | <span class='neutral'>        checked_write(self, bytes32(amt));</span>
 395 |     | <span class='neutral'>    }</span>
 396 |     | <span class='neutral'></span>
 397 |     | <span class='neutral'>    function checked_write_int(StdStorage storage self, int256 val) internal {</span>
 398 |     | <span class='neutral'>        checked_write(self, bytes32(uint256(val)));</span>
 399 |     | <span class='neutral'>    }</span>
 400 |     | <span class='neutral'></span>
 401 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bool write) internal {</span>
 402 |     | <span class='neutral'>        bytes32 t;</span>
 403 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 404 |     | <span class='neutral'>        assembly {</span>
 405 |     | <span class='neutral'>            t := write</span>
 406 |     | <span class='neutral'>        }</span>
 407 |     | <span class='neutral'>        checked_write(self, t);</span>
 408 |     | <span class='neutral'>    }</span>
 409 |     | <span class='neutral'></span>
 410 |     | <span class='neutral'>    function checked_write(StdStorage storage self, bytes32 set) internal {</span>
 411 |     | <span class='neutral'>        address who = self._target;</span>
 412 |     | <span class='neutral'>        bytes4 fsig = self._sig;</span>
 413 |     | <span class='neutral'>        uint256 field_depth = self._depth;</span>
 414 |     | <span class='neutral'>        bytes memory params = stdStorageSafe.getCallParams(self);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        if (!self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))].found) {</span>
 417 |     | <span class='neutral'>            find(self, false);</span>
 418 |     | <span class='neutral'>        }</span>
 419 |     | <span class='neutral'>        FindData storage data = self.finds[who][fsig][keccak256(abi.encodePacked(params, field_depth))];</span>
 420 |     | <span class='neutral'>        if ((data.offsetLeft + data.offsetRight) &gt; 0) {</span>
 421 |     | <span class='neutral'>            uint256 maxVal = 2 ** (256 - (data.offsetLeft + data.offsetRight));</span>
 422 |     | <span class='neutral'>            require(</span>
 423 |     | <span class='neutral'>                uint256(set) &lt; maxVal,</span>
 424 |     | <span class='neutral'>                string(</span>
 425 |     | <span class='neutral'>                    abi.encodePacked(</span>
 426 |     | <span class='neutral'>                        &quot;stdStorage find(StdStorage): Packed slot. We can&#39;t fit value greater than &quot;,</span>
 427 |     | <span class='neutral'>                        vm.toString(maxVal)</span>
 428 |     | <span class='neutral'>                    )</span>
 429 |     | <span class='neutral'>                )</span>
 430 |     | <span class='neutral'>            );</span>
 431 |     | <span class='neutral'>        }</span>
 432 |     | <span class='neutral'>        bytes32 curVal = vm.load(who, bytes32(data.slot));</span>
 433 |     | <span class='neutral'>        bytes32 valToSet = stdStorageSafe.getUpdatedSlotValue(curVal, uint256(set), data.offsetLeft, data.offsetRight);</span>
 434 |     | <span class='neutral'></span>
 435 |     | <span class='neutral'>        vm.store(who, bytes32(data.slot), valToSet);</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>        (bool success, bytes32 callResult) = stdStorageSafe.callTarget(self);</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>        if (!success || callResult != set) {</span>
 440 |     | <span class='neutral'>            vm.store(who, bytes32(data.slot), curVal);</span>
 441 |     | <span class='neutral'>            revert(&quot;stdStorage find(StdStorage): Failed to write value.&quot;);</span>
 442 |     | <span class='neutral'>        }</span>
 443 |     | <span class='neutral'>        clear(self);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='neutral'>    function read_bytes32(StdStorage storage self) internal returns (bytes32) {</span>
 447 |     | <span class='neutral'>        return stdStorageSafe.read_bytes32(self);</span>
 448 |     | <span class='neutral'>    }</span>
 449 |     | <span class='neutral'></span>
 450 |     | <span class='neutral'>    function read_bool(StdStorage storage self) internal returns (bool) {</span>
 451 |     | <span class='neutral'>        return stdStorageSafe.read_bool(self);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    function read_address(StdStorage storage self) internal returns (address) {</span>
 455 |     | <span class='neutral'>        return stdStorageSafe.read_address(self);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>    function read_uint(StdStorage storage self) internal returns (uint256) {</span>
 459 |     | <span class='neutral'>        return stdStorageSafe.read_uint(self);</span>
 460 |     | <span class='neutral'>    }</span>
 461 |     | <span class='neutral'></span>
 462 |     | <span class='neutral'>    function read_int(StdStorage storage self) internal returns (int256) {</span>
 463 |     | <span class='neutral'>        return stdStorageSafe.read_int(self);</span>
 464 |     | <span class='neutral'>    }</span>
 465 |     | <span class='neutral'></span>
 466 |     | <span class='neutral'>    function parent(StdStorage storage self) internal returns (uint256, bytes32) {</span>
 467 |     | <span class='neutral'>        return stdStorageSafe.parent(self);</span>
 468 |     | <span class='neutral'>    }</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    function root(StdStorage storage self) internal returns (uint256) {</span>
 471 |     | <span class='neutral'>        return stdStorageSafe.root(self);</span>
 472 |     | <span class='neutral'>    }</span>
 473 |     | <span class='neutral'>}</span>
 474 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdStyle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='unexecuted'>library StdStyle {</span>
   7 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    string constant RED = &quot;\u001b[91m&quot;;</span>
  10 |     | <span class='neutral'>    string constant GREEN = &quot;\u001b[92m&quot;;</span>
  11 |     | <span class='neutral'>    string constant YELLOW = &quot;\u001b[93m&quot;;</span>
  12 |     | <span class='neutral'>    string constant BLUE = &quot;\u001b[94m&quot;;</span>
  13 |     | <span class='neutral'>    string constant MAGENTA = &quot;\u001b[95m&quot;;</span>
  14 |     | <span class='neutral'>    string constant CYAN = &quot;\u001b[96m&quot;;</span>
  15 |     | <span class='neutral'>    string constant BOLD = &quot;\u001b[1m&quot;;</span>
  16 |     | <span class='neutral'>    string constant DIM = &quot;\u001b[2m&quot;;</span>
  17 |     | <span class='neutral'>    string constant ITALIC = &quot;\u001b[3m&quot;;</span>
  18 |     | <span class='neutral'>    string constant UNDERLINE = &quot;\u001b[4m&quot;;</span>
  19 |     | <span class='neutral'>    string constant INVERSE = &quot;\u001b[7m&quot;;</span>
  20 |     | <span class='neutral'>    string constant RESET = &quot;\u001b[0m&quot;;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    function styleConcat(string memory style, string memory self) private pure returns (string memory) {</span>
  23 |     | <span class='neutral'>        return string(abi.encodePacked(style, self, RESET));</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    function red(string memory self) internal pure returns (string memory) {</span>
  27 |     | <span class='neutral'>        return styleConcat(RED, self);</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    function red(uint256 self) internal pure returns (string memory) {</span>
  31 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  32 |     | <span class='neutral'>    }</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function red(int256 self) internal pure returns (string memory) {</span>
  35 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    function red(address self) internal pure returns (string memory) {</span>
  39 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  40 |     | <span class='neutral'>    }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    function red(bool self) internal pure returns (string memory) {</span>
  43 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    function redBytes(bytes memory self) internal pure returns (string memory) {</span>
  47 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    function redBytes32(bytes32 self) internal pure returns (string memory) {</span>
  51 |     | <span class='neutral'>        return red(vm.toString(self));</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function green(string memory self) internal pure returns (string memory) {</span>
  55 |     | <span class='neutral'>        return styleConcat(GREEN, self);</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function green(uint256 self) internal pure returns (string memory) {</span>
  59 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  60 |     | <span class='neutral'>    }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function green(int256 self) internal pure returns (string memory) {</span>
  63 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function green(address self) internal pure returns (string memory) {</span>
  67 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function green(bool self) internal pure returns (string memory) {</span>
  71 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    function greenBytes(bytes memory self) internal pure returns (string memory) {</span>
  75 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function greenBytes32(bytes32 self) internal pure returns (string memory) {</span>
  79 |     | <span class='neutral'>        return green(vm.toString(self));</span>
  80 |     | <span class='neutral'>    }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function yellow(string memory self) internal pure returns (string memory) {</span>
  83 |     | <span class='neutral'>        return styleConcat(YELLOW, self);</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function yellow(uint256 self) internal pure returns (string memory) {</span>
  87 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function yellow(int256 self) internal pure returns (string memory) {</span>
  91 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function yellow(address self) internal pure returns (string memory) {</span>
  95 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function yellow(bool self) internal pure returns (string memory) {</span>
  99 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    function yellowBytes(bytes memory self) internal pure returns (string memory) {</span>
 103 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function yellowBytes32(bytes32 self) internal pure returns (string memory) {</span>
 107 |     | <span class='neutral'>        return yellow(vm.toString(self));</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    function blue(string memory self) internal pure returns (string memory) {</span>
 111 |     | <span class='neutral'>        return styleConcat(BLUE, self);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function blue(uint256 self) internal pure returns (string memory) {</span>
 115 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function blue(int256 self) internal pure returns (string memory) {</span>
 119 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    function blue(address self) internal pure returns (string memory) {</span>
 123 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function blue(bool self) internal pure returns (string memory) {</span>
 127 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    function blueBytes(bytes memory self) internal pure returns (string memory) {</span>
 131 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    function blueBytes32(bytes32 self) internal pure returns (string memory) {</span>
 135 |     | <span class='neutral'>        return blue(vm.toString(self));</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    function magenta(string memory self) internal pure returns (string memory) {</span>
 139 |     | <span class='neutral'>        return styleConcat(MAGENTA, self);</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function magenta(uint256 self) internal pure returns (string memory) {</span>
 143 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function magenta(int256 self) internal pure returns (string memory) {</span>
 147 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function magenta(address self) internal pure returns (string memory) {</span>
 151 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 152 |     | <span class='neutral'>    }</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function magenta(bool self) internal pure returns (string memory) {</span>
 155 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function magentaBytes(bytes memory self) internal pure returns (string memory) {</span>
 159 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function magentaBytes32(bytes32 self) internal pure returns (string memory) {</span>
 163 |     | <span class='neutral'>        return magenta(vm.toString(self));</span>
 164 |     | <span class='neutral'>    }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function cyan(string memory self) internal pure returns (string memory) {</span>
 167 |     | <span class='neutral'>        return styleConcat(CYAN, self);</span>
 168 |     | <span class='neutral'>    }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function cyan(uint256 self) internal pure returns (string memory) {</span>
 171 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function cyan(int256 self) internal pure returns (string memory) {</span>
 175 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 176 |     | <span class='neutral'>    }</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    function cyan(address self) internal pure returns (string memory) {</span>
 179 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 180 |     | <span class='neutral'>    }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>    function cyan(bool self) internal pure returns (string memory) {</span>
 183 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    function cyanBytes(bytes memory self) internal pure returns (string memory) {</span>
 187 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 188 |     | <span class='neutral'>    }</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>    function cyanBytes32(bytes32 self) internal pure returns (string memory) {</span>
 191 |     | <span class='neutral'>        return cyan(vm.toString(self));</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    function bold(string memory self) internal pure returns (string memory) {</span>
 195 |     | <span class='neutral'>        return styleConcat(BOLD, self);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>    function bold(uint256 self) internal pure returns (string memory) {</span>
 199 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    function bold(int256 self) internal pure returns (string memory) {</span>
 203 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function bold(address self) internal pure returns (string memory) {</span>
 207 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>    function bold(bool self) internal pure returns (string memory) {</span>
 211 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    function boldBytes(bytes memory self) internal pure returns (string memory) {</span>
 215 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'></span>
 218 |     | <span class='neutral'>    function boldBytes32(bytes32 self) internal pure returns (string memory) {</span>
 219 |     | <span class='neutral'>        return bold(vm.toString(self));</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    function dim(string memory self) internal pure returns (string memory) {</span>
 223 |     | <span class='neutral'>        return styleConcat(DIM, self);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    function dim(uint256 self) internal pure returns (string memory) {</span>
 227 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    function dim(int256 self) internal pure returns (string memory) {</span>
 231 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 232 |     | <span class='neutral'>    }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>    function dim(address self) internal pure returns (string memory) {</span>
 235 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='neutral'>    function dim(bool self) internal pure returns (string memory) {</span>
 239 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    function dimBytes(bytes memory self) internal pure returns (string memory) {</span>
 243 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'></span>
 246 |     | <span class='neutral'>    function dimBytes32(bytes32 self) internal pure returns (string memory) {</span>
 247 |     | <span class='neutral'>        return dim(vm.toString(self));</span>
 248 |     | <span class='neutral'>    }</span>
 249 |     | <span class='neutral'></span>
 250 |     | <span class='neutral'>    function italic(string memory self) internal pure returns (string memory) {</span>
 251 |     | <span class='neutral'>        return styleConcat(ITALIC, self);</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    function italic(uint256 self) internal pure returns (string memory) {</span>
 255 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='neutral'>    function italic(int256 self) internal pure returns (string memory) {</span>
 259 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 260 |     | <span class='neutral'>    }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>    function italic(address self) internal pure returns (string memory) {</span>
 263 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    function italic(bool self) internal pure returns (string memory) {</span>
 267 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 268 |     | <span class='neutral'>    }</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>    function italicBytes(bytes memory self) internal pure returns (string memory) {</span>
 271 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='neutral'>    function italicBytes32(bytes32 self) internal pure returns (string memory) {</span>
 275 |     | <span class='neutral'>        return italic(vm.toString(self));</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    function underline(string memory self) internal pure returns (string memory) {</span>
 279 |     | <span class='neutral'>        return styleConcat(UNDERLINE, self);</span>
 280 |     | <span class='neutral'>    }</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    function underline(uint256 self) internal pure returns (string memory) {</span>
 283 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    function underline(int256 self) internal pure returns (string memory) {</span>
 287 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    function underline(address self) internal pure returns (string memory) {</span>
 291 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 292 |     | <span class='neutral'>    }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    function underline(bool self) internal pure returns (string memory) {</span>
 295 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 296 |     | <span class='neutral'>    }</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>    function underlineBytes(bytes memory self) internal pure returns (string memory) {</span>
 299 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 300 |     | <span class='neutral'>    }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    function underlineBytes32(bytes32 self) internal pure returns (string memory) {</span>
 303 |     | <span class='neutral'>        return underline(vm.toString(self));</span>
 304 |     | <span class='neutral'>    }</span>
 305 |     | <span class='neutral'></span>
 306 |     | <span class='neutral'>    function inverse(string memory self) internal pure returns (string memory) {</span>
 307 |     | <span class='neutral'>        return styleConcat(INVERSE, self);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    function inverse(uint256 self) internal pure returns (string memory) {</span>
 311 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    function inverse(int256 self) internal pure returns (string memory) {</span>
 315 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    function inverse(address self) internal pure returns (string memory) {</span>
 319 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    function inverse(bool self) internal pure returns (string memory) {</span>
 323 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'></span>
 326 |     | <span class='neutral'>    function inverseBytes(bytes memory self) internal pure returns (string memory) {</span>
 327 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function inverseBytes32(bytes32 self) internal pure returns (string memory) {</span>
 331 |     | <span class='neutral'>        return inverse(vm.toString(self));</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'>}</span>
 334 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdToml.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.0 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// Helpers for parsing and writing TOML files</span>
   9 |     | <span class='neutral'>// To parse:</span>
  10 |     | <span class='neutral'>// ```</span>
  11 |     | <span class='neutral'>// using stdToml for string;</span>
  12 |     | <span class='neutral'>// string memory toml = vm.readFile(&quot;&lt;some_path&gt;&quot;);</span>
  13 |     | <span class='neutral'>// toml.readUint(&quot;&lt;json_path&gt;&quot;);</span>
  14 |     | <span class='neutral'>// ```</span>
  15 |     | <span class='neutral'>// To write:</span>
  16 |     | <span class='neutral'>// ```</span>
  17 |     | <span class='neutral'>// using stdToml for string;</span>
  18 |     | <span class='neutral'>// string memory json = &quot;json&quot;;</span>
  19 |     | <span class='neutral'>// json.serialize(&quot;a&quot;, uint256(123));</span>
  20 |     | <span class='neutral'>// string memory semiFinal = json.serialize(&quot;b&quot;, string(&quot;test&quot;));</span>
  21 |     | <span class='neutral'>// string memory finalJson = json.serialize(&quot;c&quot;, semiFinal);</span>
  22 |     | <span class='neutral'>// finalJson.write(&quot;&lt;some_path&gt;&quot;);</span>
  23 |     | <span class='neutral'>// ```</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>library stdToml {</span>
  26 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>    function parseRaw(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  29 |     | <span class='neutral'>        return vm.parseToml(toml, key);</span>
  30 |     | <span class='neutral'>    }</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    function readUint(string memory toml, string memory key) internal pure returns (uint256) {</span>
  33 |     | <span class='neutral'>        return vm.parseTomlUint(toml, key);</span>
  34 |     | <span class='neutral'>    }</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    function readUintArray(string memory toml, string memory key) internal pure returns (uint256[] memory) {</span>
  37 |     | <span class='neutral'>        return vm.parseTomlUintArray(toml, key);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    function readInt(string memory toml, string memory key) internal pure returns (int256) {</span>
  41 |     | <span class='neutral'>        return vm.parseTomlInt(toml, key);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    function readIntArray(string memory toml, string memory key) internal pure returns (int256[] memory) {</span>
  45 |     | <span class='neutral'>        return vm.parseTomlIntArray(toml, key);</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    function readBytes32(string memory toml, string memory key) internal pure returns (bytes32) {</span>
  49 |     | <span class='neutral'>        return vm.parseTomlBytes32(toml, key);</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    function readBytes32Array(string memory toml, string memory key) internal pure returns (bytes32[] memory) {</span>
  53 |     | <span class='neutral'>        return vm.parseTomlBytes32Array(toml, key);</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    function readString(string memory toml, string memory key) internal pure returns (string memory) {</span>
  57 |     | <span class='neutral'>        return vm.parseTomlString(toml, key);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function readStringArray(string memory toml, string memory key) internal pure returns (string[] memory) {</span>
  61 |     | <span class='neutral'>        return vm.parseTomlStringArray(toml, key);</span>
  62 |     | <span class='neutral'>    }</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function readAddress(string memory toml, string memory key) internal pure returns (address) {</span>
  65 |     | <span class='neutral'>        return vm.parseTomlAddress(toml, key);</span>
  66 |     | <span class='neutral'>    }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function readAddressArray(string memory toml, string memory key) internal pure returns (address[] memory) {</span>
  69 |     | <span class='neutral'>        return vm.parseTomlAddressArray(toml, key);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    function readBool(string memory toml, string memory key) internal pure returns (bool) {</span>
  73 |     | <span class='neutral'>        return vm.parseTomlBool(toml, key);</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    function readBoolArray(string memory toml, string memory key) internal pure returns (bool[] memory) {</span>
  77 |     | <span class='neutral'>        return vm.parseTomlBoolArray(toml, key);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    function readBytes(string memory toml, string memory key) internal pure returns (bytes memory) {</span>
  81 |     | <span class='neutral'>        return vm.parseTomlBytes(toml, key);</span>
  82 |     | <span class='neutral'>    }</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    function readBytesArray(string memory toml, string memory key) internal pure returns (bytes[] memory) {</span>
  85 |     | <span class='neutral'>        return vm.parseTomlBytesArray(toml, key);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory rootObject) internal returns (string memory) {</span>
  89 |     | <span class='neutral'>        return vm.serializeJson(jsonKey, rootObject);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool value) internal returns (string memory) {</span>
  93 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bool[] memory value)</span>
  97 |     | <span class='neutral'>        internal</span>
  98 |     | <span class='neutral'>        returns (string memory)</span>
  99 |     | <span class='neutral'>    {</span>
 100 |     | <span class='neutral'>        return vm.serializeBool(jsonKey, key, value);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256 value) internal returns (string memory) {</span>
 104 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, uint256[] memory value)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        returns (string memory)</span>
 110 |     | <span class='neutral'>    {</span>
 111 |     | <span class='neutral'>        return vm.serializeUint(jsonKey, key, value);</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256 value) internal returns (string memory) {</span>
 115 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, int256[] memory value)</span>
 119 |     | <span class='neutral'>        internal</span>
 120 |     | <span class='neutral'>        returns (string memory)</span>
 121 |     | <span class='neutral'>    {</span>
 122 |     | <span class='neutral'>        return vm.serializeInt(jsonKey, key, value);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address value) internal returns (string memory) {</span>
 126 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, address[] memory value)</span>
 130 |     | <span class='neutral'>        internal</span>
 131 |     | <span class='neutral'>        returns (string memory)</span>
 132 |     | <span class='neutral'>    {</span>
 133 |     | <span class='neutral'>        return vm.serializeAddress(jsonKey, key, value);</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32 value) internal returns (string memory) {</span>
 137 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes32[] memory value)</span>
 141 |     | <span class='neutral'>        internal</span>
 142 |     | <span class='neutral'>        returns (string memory)</span>
 143 |     | <span class='neutral'>    {</span>
 144 |     | <span class='neutral'>        return vm.serializeBytes32(jsonKey, key, value);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes memory value) internal returns (string memory) {</span>
 148 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 149 |     | <span class='neutral'>    }</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, bytes[] memory value)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        returns (string memory)</span>
 154 |     | <span class='neutral'>    {</span>
 155 |     | <span class='neutral'>        return vm.serializeBytes(jsonKey, key, value);</span>
 156 |     | <span class='neutral'>    }</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string memory value)</span>
 159 |     | <span class='neutral'>        internal</span>
 160 |     | <span class='neutral'>        returns (string memory)</span>
 161 |     | <span class='neutral'>    {</span>
 162 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    function serialize(string memory jsonKey, string memory key, string[] memory value)</span>
 166 |     | <span class='neutral'>        internal</span>
 167 |     | <span class='neutral'>        returns (string memory)</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='neutral'>        return vm.serializeString(jsonKey, key, value);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path) internal {</span>
 173 |     | <span class='neutral'>        vm.writeToml(jsonKey, path);</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    function write(string memory jsonKey, string memory path, string memory valueKey) internal {</span>
 177 |     | <span class='neutral'>        vm.writeToml(jsonKey, path, valueKey);</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'>}</span>
 180 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/StdUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import {IMulticall3} from &quot;./interfaces/IMulticall3.sol&quot;;</span>
   7 |     | <span class='neutral'>import {MockERC20} from &quot;./mocks/MockERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import {MockERC721} from &quot;./mocks/MockERC721.sol&quot;;</span>
   9 |     | <span class='neutral'>import {VmSafe} from &quot;./Vm.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>abstract contract StdUtils {</span>
  12 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  13 |     | <span class='neutral'>                                     CONSTANTS</span>
  14 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    IMulticall3 private constant multicall = IMulticall3(0xcA11bde05977b3631167028862bE2a173976CA11);</span>
  17 |     | <span class='neutral'>    VmSafe private constant vm = VmSafe(address(uint160(uint256(keccak256(&quot;hevm cheat code&quot;)))));</span>
  18 | *   | <span class='executed'>    address private constant CONSOLE2_ADDRESS = 0x000000000000000000636F6e736F6c652e6c6f67;</span>
  19 |     | <span class='neutral'>    uint256 private constant INT256_MIN_ABS =</span>
  20 |     | <span class='neutral'>        57896044618658097711785492504343953926634992332820282019728792003956564819968;</span>
  21 |     | <span class='neutral'>    uint256 private constant SECP256K1_ORDER =</span>
  22 |     | <span class='neutral'>        115792089237316195423570985008687907852837564279074904382605163141518161494337;</span>
  23 |     | <span class='neutral'>    uint256 private constant UINT256_MAX =</span>
  24 |     | <span class='neutral'>        115792089237316195423570985008687907853269984665640564039457584007913129639935;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Used by default when deploying with create2, https://github.com/Arachnid/deterministic-deployment-proxy.</span>
  27 |     | <span class='neutral'>    address private constant CREATE2_FACTORY = 0x4e59b44847b379578588920cA78FbF26c0B4956C;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
  30 |     | <span class='neutral'>                                 INTERNAL FUNCTIONS</span>
  31 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
  32 |     | <span class='neutral'></span>
  33 | *   | <span class='executed'>    function _bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  34 | *   | <span class='executed'>        require(min &lt;= max, &quot;StdUtils bound(uint256,uint256,uint256): Max is less than min.&quot;);</span>
  35 |     | <span class='neutral'>        // If x is between min and max, return x directly. This is to ensure that dictionary values</span>
  36 |     | <span class='neutral'>        // do not get shifted if the min is nonzero. More info: https://github.com/foundry-rs/forge-std/issues/188</span>
  37 | *   | <span class='executed'>        if (x &gt;= min &amp;&amp; x &lt;= max) return x;</span>
  38 |     | <span class='neutral'></span>
  39 | *   | <span class='executed'>        uint256 size = max - min + 1;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>        // If the value is 0, 1, 2, 3, wrap that to min, min+1, min+2, min+3. Similarly for the UINT256_MAX side.</span>
  42 |     | <span class='neutral'>        // This helps ensure coverage of the min/max values.</span>
  43 | *   | <span class='executed'>        if (x &lt;= 3 &amp;&amp; size &gt; x) return min + x;</span>
  44 | *   | <span class='executed'>        if (x &gt;= UINT256_MAX - 3 &amp;&amp; size &gt; UINT256_MAX - x) return max - (UINT256_MAX - x);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        // Otherwise, wrap x into the range [min, max], i.e. the range is inclusive.</span>
  47 | *   | <span class='executed'>        if (x &gt; max) {</span>
  48 | *   | <span class='executed'>            uint256 diff = x - max;</span>
  49 | *   | <span class='executed'>            uint256 rem = diff % size;</span>
  50 | *   | <span class='executed'>            if (rem == 0) return max;</span>
  51 | *   | <span class='executed'>            result = min + rem - 1;</span>
  52 | *   | <span class='executed'>        } else if (x &lt; min) {</span>
  53 |     | <span class='unexecuted'>            uint256 diff = min - x;</span>
  54 |     | <span class='unexecuted'>            uint256 rem = diff % size;</span>
  55 |     | <span class='unexecuted'>            if (rem == 0) return min;</span>
  56 |     | <span class='unexecuted'>            result = max - rem + 1;</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 | *   | <span class='executed'>    function bound(uint256 x, uint256 min, uint256 max) internal pure virtual returns (uint256 result) {</span>
  61 | *   | <span class='executed'>        result = _bound(x, min, max);</span>
  62 | *   | <span class='executed'>        console2_log_StdUtils(&quot;Bound result&quot;, result);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    function _bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  66 |     | <span class='neutral'>        require(min &lt;= max, &quot;StdUtils bound(int256,int256,int256): Max is less than min.&quot;);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        // Shifting all int256 values to uint256 to use _bound function. The range of two types are:</span>
  69 |     | <span class='neutral'>        // int256 : -(2**255) ~ (2**255 - 1)</span>
  70 |     | <span class='neutral'>        // uint256:     0     ~ (2**256 - 1)</span>
  71 |     | <span class='neutral'>        // So, add 2**255, INT256_MIN_ABS to the integer values.</span>
  72 |     | <span class='neutral'>        //</span>
  73 |     | <span class='neutral'>        // If the given integer value is -2**255, we cannot use `-uint256(-x)` because of the overflow.</span>
  74 |     | <span class='neutral'>        // So, use `~uint256(x) + 1` instead.</span>
  75 |     | <span class='neutral'>        uint256 _x = x &lt; 0 ? (INT256_MIN_ABS - ~uint256(x) - 1) : (uint256(x) + INT256_MIN_ABS);</span>
  76 |     | <span class='neutral'>        uint256 _min = min &lt; 0 ? (INT256_MIN_ABS - ~uint256(min) - 1) : (uint256(min) + INT256_MIN_ABS);</span>
  77 |     | <span class='neutral'>        uint256 _max = max &lt; 0 ? (INT256_MIN_ABS - ~uint256(max) - 1) : (uint256(max) + INT256_MIN_ABS);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>        uint256 y = _bound(_x, _min, _max);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        // To move it back to int256 value, subtract INT256_MIN_ABS at here.</span>
  82 |     | <span class='neutral'>        result = y &lt; INT256_MIN_ABS ? int256(~(INT256_MIN_ABS - y) + 1) : int256(y - INT256_MIN_ABS);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    function bound(int256 x, int256 min, int256 max) internal pure virtual returns (int256 result) {</span>
  86 |     | <span class='neutral'>        result = _bound(x, min, max);</span>
  87 |     | <span class='neutral'>        console2_log_StdUtils(&quot;Bound result&quot;, vm.toString(result));</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    function boundPrivateKey(uint256 privateKey) internal pure virtual returns (uint256 result) {</span>
  91 |     | <span class='neutral'>        result = _bound(privateKey, 1, SECP256K1_ORDER - 1);</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    function bytesToUint(bytes memory b) internal pure virtual returns (uint256) {</span>
  95 |     | <span class='neutral'>        require(b.length &lt;= 32, &quot;StdUtils bytesToUint(bytes): Bytes length exceeds 32.&quot;);</span>
  96 |     | <span class='neutral'>        return abi.decode(abi.encodePacked(new bytes(32 - b.length), b), (uint256));</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @dev Compute the address a contract will be deployed at for a given deployer address and nonce</span>
 100 |     | <span class='neutral'>    /// @notice adapted from Solmate implementation (https://github.com/Rari-Capital/solmate/blob/main/src/utils/LibRLP.sol)</span>
 101 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) internal pure virtual returns (address) {</span>
 102 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreateAddress is deprecated. Please use vm.computeCreateAddress instead.&quot;);</span>
 103 |     | <span class='neutral'>        return vm.computeCreateAddress(deployer, nonce);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initcodeHash, address deployer)</span>
 107 |     | <span class='neutral'>        internal</span>
 108 |     | <span class='neutral'>        pure</span>
 109 |     | <span class='neutral'>        virtual</span>
 110 |     | <span class='neutral'>        returns (address)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 113 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initcodeHash, deployer);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @dev returns the address of a contract created with CREATE2 using the default CREATE2 deployer</span>
 117 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) internal pure returns (address) {</span>
 118 |     | <span class='neutral'>        console2_log_StdUtils(&quot;computeCreate2Address is deprecated. Please use vm.computeCreate2Address instead.&quot;);</span>
 119 |     | <span class='neutral'>        return vm.computeCreate2Address(salt, initCodeHash);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC20 contract</span>
 123 |     | <span class='neutral'>    function deployMockERC20(string memory name, string memory symbol, uint8 decimals)</span>
 124 |     | <span class='neutral'>        internal</span>
 125 |     | <span class='neutral'>        returns (MockERC20 mock)</span>
 126 |     | <span class='neutral'>    {</span>
 127 |     | <span class='neutral'>        mock = new MockERC20();</span>
 128 |     | <span class='neutral'>        mock.initialize(name, symbol, decimals);</span>
 129 |     | <span class='neutral'>    }</span>
 130 |     | <span class='neutral'></span>
 131 |     | <span class='neutral'>    /// @dev returns an initialized mock ERC721 contract</span>
 132 |     | <span class='neutral'>    function deployMockERC721(string memory name, string memory symbol) internal returns (MockERC721 mock) {</span>
 133 |     | <span class='neutral'>        mock = new MockERC721();</span>
 134 |     | <span class='neutral'>        mock.initialize(name, symbol);</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + no args) used in CREATE2 with no constructor arguments</span>
 138 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 139 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode) internal pure returns (bytes32) {</span>
 140 |     | <span class='neutral'>        return hashInitCode(creationCode, &quot;&quot;);</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @dev returns the hash of the init code (creation code + ABI-encoded args) used in CREATE2</span>
 144 |     | <span class='neutral'>    /// @param creationCode the creation code of a contract C, as returned by type(C).creationCode</span>
 145 |     | <span class='neutral'>    /// @param args the ABI-encoded arguments to the constructor of C</span>
 146 |     | <span class='neutral'>    function hashInitCode(bytes memory creationCode, bytes memory args) internal pure returns (bytes32) {</span>
 147 |     | <span class='neutral'>        return keccak256(abi.encodePacked(creationCode, args));</span>
 148 |     | <span class='neutral'>    }</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    // Performs a single call with Multicall3 to query the ERC-20 token balances of the given addresses.</span>
 151 |     | <span class='neutral'>    function getTokenBalances(address token, address[] memory addresses)</span>
 152 |     | <span class='neutral'>        internal</span>
 153 |     | <span class='neutral'>        virtual</span>
 154 |     | <span class='neutral'>        returns (uint256[] memory balances)</span>
 155 |     | <span class='neutral'>    {</span>
 156 |     | <span class='neutral'>        uint256 tokenCodeSize;</span>
 157 |     | <span class='neutral'>        assembly {</span>
 158 |     | <span class='neutral'>            tokenCodeSize := extcodesize(token)</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        require(tokenCodeSize &gt; 0, &quot;StdUtils getTokenBalances(address,address[]): Token address is not a contract.&quot;);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>        // ABI encode the aggregate call to Multicall3.</span>
 163 |     | <span class='neutral'>        uint256 length = addresses.length;</span>
 164 |     | <span class='neutral'>        IMulticall3.Call[] memory calls = new IMulticall3.Call[](length);</span>
 165 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 166 |     | <span class='neutral'>            // 0x70a08231 = bytes4(&quot;balanceOf(address)&quot;))</span>
 167 |     | <span class='neutral'>            calls[i] = IMulticall3.Call({target: token, callData: abi.encodeWithSelector(0x70a08231, (addresses[i]))});</span>
 168 |     | <span class='neutral'>        }</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        // Make the aggregate call.</span>
 171 |     | <span class='neutral'>        (, bytes[] memory returnData) = multicall.aggregate(calls);</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>        // ABI decode the return data and return the balances.</span>
 174 |     | <span class='neutral'>        balances = new uint256[](length);</span>
 175 |     | <span class='neutral'>        for (uint256 i = 0; i &lt; length; ++i) {</span>
 176 |     | <span class='neutral'>            balances[i] = abi.decode(returnData[i], (uint256));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='neutral'>    }</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////////////////</span>
 181 |     | <span class='neutral'>                                 PRIVATE FUNCTIONS</span>
 182 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////////////////*/</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>    function addressFromLast20Bytes(bytes32 bytesValue) private pure returns (address) {</span>
 185 |     | <span class='neutral'>        return address(uint160(uint256(bytesValue)));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    // This section is used to prevent the compilation of console, which shortens the compilation time when console is</span>
 189 |     | <span class='neutral'>    // not used elsewhere. We also trick the compiler into letting us make the console log methods as `pure` to avoid</span>
 190 |     | <span class='neutral'>    // any breaking changes to function signatures.</span>
 191 |     | <span class='neutral'>    function _castLogPayloadViewToPure(function(bytes memory) internal view fnIn)</span>
 192 |     | <span class='neutral'>        internal</span>
 193 |     | <span class='neutral'>        pure</span>
 194 |     | <span class='neutral'>        returns (function(bytes memory) internal pure fnOut)</span>
 195 |     | <span class='neutral'>    {</span>
 196 |     | <span class='neutral'>        assembly {</span>
 197 |     | <span class='neutral'>            fnOut := fnIn</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'>    }</span>
 200 |     | <span class='neutral'></span>
 201 | *   | <span class='executed'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
 202 | *   | <span class='executed'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 | *   | <span class='executed'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
 206 | *   | <span class='executed'>        uint256 payloadLength = payload.length;</span>
 207 |     | <span class='neutral'>        address consoleAddress = CONSOLE2_ADDRESS;</span>
 208 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 209 | *   | <span class='executed'>        assembly {</span>
 210 | *   | <span class='executed'>            let payloadStart := add(payload, 32)</span>
 211 | *   | <span class='executed'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
 212 |     | <span class='neutral'>        }</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0) private pure {</span>
 216 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 | *   | <span class='executed'>    function console2_log_StdUtils(string memory p0, uint256 p1) private pure {</span>
 220 | *   | <span class='executed'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint256)&quot;, p0, p1));</span>
 221 |     | <span class='neutral'>    }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function console2_log_StdUtils(string memory p0, string memory p1) private pure {</span>
 224 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
 225 |     | <span class='neutral'>    }</span>
 226 |     | <span class='neutral'>}</span>
 227 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Test.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>//  ABOUT</span>
  7 |     | <span class='neutral'>// Forge Std&#39;s default Test.</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>//  MODULES</span>
 10 |     | <span class='neutral'>import {console} from &quot;./console.sol&quot;;</span>
 11 |     | <span class='neutral'>import {console2} from &quot;./console2.sol&quot;;</span>
 12 |     | <span class='neutral'>import {safeconsole} from &quot;./safeconsole.sol&quot;;</span>
 13 |     | <span class='neutral'>import {StdAssertions} from &quot;./StdAssertions.sol&quot;;</span>
 14 |     | <span class='neutral'>import {StdChains} from &quot;./StdChains.sol&quot;;</span>
 15 |     | <span class='neutral'>import {StdCheats} from &quot;./StdCheats.sol&quot;;</span>
 16 |     | <span class='neutral'>import {stdError} from &quot;./StdError.sol&quot;;</span>
 17 |     | <span class='neutral'>import {StdInvariant} from &quot;./StdInvariant.sol&quot;;</span>
 18 |     | <span class='neutral'>import {stdJson} from &quot;./StdJson.sol&quot;;</span>
 19 |     | <span class='neutral'>import {stdMath} from &quot;./StdMath.sol&quot;;</span>
 20 |     | <span class='neutral'>import {StdStorage, stdStorage} from &quot;./StdStorage.sol&quot;;</span>
 21 |     | <span class='neutral'>import {StdStyle} from &quot;./StdStyle.sol&quot;;</span>
 22 |     | <span class='neutral'>import {stdToml} from &quot;./StdToml.sol&quot;;</span>
 23 |     | <span class='neutral'>import {StdUtils} from &quot;./StdUtils.sol&quot;;</span>
 24 |     | <span class='neutral'>import {Vm} from &quot;./Vm.sol&quot;;</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>//  BOILERPLATE</span>
 27 |     | <span class='neutral'>import {TestBase} from &quot;./Base.sol&quot;;</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>//  TEST</span>
 30 |     | <span class='neutral'>abstract contract Test is TestBase, StdAssertions, StdChains, StdCheats, StdInvariant, StdUtils {</span>
 31 |     | <span class='neutral'>    // Note: IS_TEST() must return true.</span>
 32 | *   | <span class='executed'>    bool public IS_TEST = true;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/Vm.sol</b>
<code>
    1 |     | <span class='neutral'>// Automatically @generated by scripts/vm.py. Do not modify manually.</span>
    2 |     | <span class='neutral'></span>
    3 |     | <span class='neutral'>// SPDX-License-Identifier: MIT OR Apache-2.0</span>
    4 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
    5 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/// The `VmSafe` interface does not allow manipulation of the EVM state or other actions that may</span>
    8 |     | <span class='neutral'>/// result in Script simulations differing from on-chain execution. It is recommended to only use</span>
    9 |     | <span class='neutral'>/// these cheats in scripts.</span>
   10 |     | <span class='neutral'>interface VmSafe {</span>
   11 |     | <span class='neutral'>    /// A modification applied to either `msg.sender` or `tx.origin`. Returned by `readCallers`.</span>
   12 |     | <span class='neutral'>    enum CallerMode {</span>
   13 |     | <span class='neutral'>        // No caller modification is currently active.</span>
   14 |     | <span class='neutral'>        None,</span>
   15 |     | <span class='neutral'>        // A one time broadcast triggered by a `vm.broadcast()` call is currently active.</span>
   16 |     | <span class='neutral'>        Broadcast,</span>
   17 |     | <span class='neutral'>        // A recurrent broadcast triggered by a `vm.startBroadcast()` call is currently active.</span>
   18 |     | <span class='neutral'>        RecurrentBroadcast,</span>
   19 |     | <span class='neutral'>        // A one time prank triggered by a `vm.prank()` call is currently active.</span>
   20 |     | <span class='neutral'>        Prank,</span>
   21 |     | <span class='neutral'>        // A recurrent prank triggered by a `vm.startPrank()` call is currently active.</span>
   22 |     | <span class='neutral'>        RecurrentPrank</span>
   23 |     | <span class='neutral'>    }</span>
   24 |     | <span class='neutral'></span>
   25 |     | <span class='neutral'>    /// The kind of account access that occurred.</span>
   26 |     | <span class='neutral'>    enum AccountAccessKind {</span>
   27 |     | <span class='neutral'>        // The account was called.</span>
   28 |     | <span class='neutral'>        Call,</span>
   29 |     | <span class='neutral'>        // The account was called via delegatecall.</span>
   30 |     | <span class='neutral'>        DelegateCall,</span>
   31 |     | <span class='neutral'>        // The account was called via callcode.</span>
   32 |     | <span class='neutral'>        CallCode,</span>
   33 |     | <span class='neutral'>        // The account was called via staticcall.</span>
   34 |     | <span class='neutral'>        StaticCall,</span>
   35 |     | <span class='neutral'>        // The account was created.</span>
   36 |     | <span class='neutral'>        Create,</span>
   37 |     | <span class='neutral'>        // The account was selfdestructed.</span>
   38 |     | <span class='neutral'>        SelfDestruct,</span>
   39 |     | <span class='neutral'>        // Synthetic access indicating the current context has resumed after a previous sub-context (AccountAccess).</span>
   40 |     | <span class='neutral'>        Resume,</span>
   41 |     | <span class='neutral'>        // The account&#39;s balance was read.</span>
   42 |     | <span class='neutral'>        Balance,</span>
   43 |     | <span class='neutral'>        // The account&#39;s codesize was read.</span>
   44 |     | <span class='neutral'>        Extcodesize,</span>
   45 |     | <span class='neutral'>        // The account&#39;s codehash was read.</span>
   46 |     | <span class='neutral'>        Extcodehash,</span>
   47 |     | <span class='neutral'>        // The account&#39;s code was copied.</span>
   48 |     | <span class='neutral'>        Extcodecopy</span>
   49 |     | <span class='neutral'>    }</span>
   50 |     | <span class='neutral'></span>
   51 |     | <span class='neutral'>    /// Forge execution contexts.</span>
   52 |     | <span class='neutral'>    enum ForgeContext {</span>
   53 |     | <span class='neutral'>        // Test group execution context (test, coverage or snapshot).</span>
   54 |     | <span class='neutral'>        TestGroup,</span>
   55 |     | <span class='neutral'>        // `forge test` execution context.</span>
   56 |     | <span class='neutral'>        Test,</span>
   57 |     | <span class='neutral'>        // `forge coverage` execution context.</span>
   58 |     | <span class='neutral'>        Coverage,</span>
   59 |     | <span class='neutral'>        // `forge snapshot` execution context.</span>
   60 |     | <span class='neutral'>        Snapshot,</span>
   61 |     | <span class='neutral'>        // Script group execution context (dry run, broadcast or resume).</span>
   62 |     | <span class='neutral'>        ScriptGroup,</span>
   63 |     | <span class='neutral'>        // `forge script` execution context.</span>
   64 |     | <span class='neutral'>        ScriptDryRun,</span>
   65 |     | <span class='neutral'>        // `forge script --broadcast` execution context.</span>
   66 |     | <span class='neutral'>        ScriptBroadcast,</span>
   67 |     | <span class='neutral'>        // `forge script --resume` execution context.</span>
   68 |     | <span class='neutral'>        ScriptResume,</span>
   69 |     | <span class='neutral'>        // Unknown `forge` execution context.</span>
   70 |     | <span class='neutral'>        Unknown</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    /// An Ethereum log. Returned by `getRecordedLogs`.</span>
   74 |     | <span class='neutral'>    struct Log {</span>
   75 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   76 |     | <span class='neutral'>        bytes32[] topics;</span>
   77 |     | <span class='neutral'>        // The raw data of the log.</span>
   78 |     | <span class='neutral'>        bytes data;</span>
   79 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   80 |     | <span class='neutral'>        address emitter;</span>
   81 |     | <span class='neutral'>    }</span>
   82 |     | <span class='neutral'></span>
   83 |     | <span class='neutral'>    /// An RPC URL and its alias. Returned by `rpcUrlStructs`.</span>
   84 |     | <span class='neutral'>    struct Rpc {</span>
   85 |     | <span class='neutral'>        // The alias of the RPC URL.</span>
   86 |     | <span class='neutral'>        string key;</span>
   87 |     | <span class='neutral'>        // The RPC URL.</span>
   88 |     | <span class='neutral'>        string url;</span>
   89 |     | <span class='neutral'>    }</span>
   90 |     | <span class='neutral'></span>
   91 |     | <span class='neutral'>    /// An RPC log object. Returned by `eth_getLogs`.</span>
   92 |     | <span class='neutral'>    struct EthGetLogs {</span>
   93 |     | <span class='neutral'>        // The address of the log&#39;s emitter.</span>
   94 |     | <span class='neutral'>        address emitter;</span>
   95 |     | <span class='neutral'>        // The topics of the log, including the signature, if any.</span>
   96 |     | <span class='neutral'>        bytes32[] topics;</span>
   97 |     | <span class='neutral'>        // The raw data of the log.</span>
   98 |     | <span class='neutral'>        bytes data;</span>
   99 |     | <span class='neutral'>        // The block hash.</span>
  100 |     | <span class='neutral'>        bytes32 blockHash;</span>
  101 |     | <span class='neutral'>        // The block number.</span>
  102 |     | <span class='neutral'>        uint64 blockNumber;</span>
  103 |     | <span class='neutral'>        // The transaction hash.</span>
  104 |     | <span class='neutral'>        bytes32 transactionHash;</span>
  105 |     | <span class='neutral'>        // The transaction index in the block.</span>
  106 |     | <span class='neutral'>        uint64 transactionIndex;</span>
  107 |     | <span class='neutral'>        // The log index.</span>
  108 |     | <span class='neutral'>        uint256 logIndex;</span>
  109 |     | <span class='neutral'>        // Whether the log was removed.</span>
  110 |     | <span class='neutral'>        bool removed;</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    /// A single entry in a directory listing. Returned by `readDir`.</span>
  114 |     | <span class='neutral'>    struct DirEntry {</span>
  115 |     | <span class='neutral'>        // The error message, if any.</span>
  116 |     | <span class='neutral'>        string errorMessage;</span>
  117 |     | <span class='neutral'>        // The path of the entry.</span>
  118 |     | <span class='neutral'>        string path;</span>
  119 |     | <span class='neutral'>        // The depth of the entry.</span>
  120 |     | <span class='neutral'>        uint64 depth;</span>
  121 |     | <span class='neutral'>        // Whether the entry is a directory.</span>
  122 |     | <span class='neutral'>        bool isDir;</span>
  123 |     | <span class='neutral'>        // Whether the entry is a symlink.</span>
  124 |     | <span class='neutral'>        bool isSymlink;</span>
  125 |     | <span class='neutral'>    }</span>
  126 |     | <span class='neutral'></span>
  127 |     | <span class='neutral'>    /// Metadata information about a file.</span>
  128 |     | <span class='neutral'>    /// This structure is returned from the `fsMetadata` function and represents known</span>
  129 |     | <span class='neutral'>    /// metadata about a file such as its permissions, size, modification</span>
  130 |     | <span class='neutral'>    /// times, etc.</span>
  131 |     | <span class='neutral'>    struct FsMetadata {</span>
  132 |     | <span class='neutral'>        // True if this metadata is for a directory.</span>
  133 |     | <span class='neutral'>        bool isDir;</span>
  134 |     | <span class='neutral'>        // True if this metadata is for a symlink.</span>
  135 |     | <span class='neutral'>        bool isSymlink;</span>
  136 |     | <span class='neutral'>        // The size of the file, in bytes, this metadata is for.</span>
  137 |     | <span class='neutral'>        uint256 length;</span>
  138 |     | <span class='neutral'>        // True if this metadata is for a readonly (unwritable) file.</span>
  139 |     | <span class='neutral'>        bool readOnly;</span>
  140 |     | <span class='neutral'>        // The last modification time listed in this metadata.</span>
  141 |     | <span class='neutral'>        uint256 modified;</span>
  142 |     | <span class='neutral'>        // The last access time of this metadata.</span>
  143 |     | <span class='neutral'>        uint256 accessed;</span>
  144 |     | <span class='neutral'>        // The creation time listed in this metadata.</span>
  145 |     | <span class='neutral'>        uint256 created;</span>
  146 |     | <span class='neutral'>    }</span>
  147 |     | <span class='neutral'></span>
  148 |     | <span class='neutral'>    /// A wallet with a public and private key.</span>
  149 |     | <span class='neutral'>    struct Wallet {</span>
  150 |     | <span class='neutral'>        // The wallet&#39;s address.</span>
  151 |     | <span class='neutral'>        address addr;</span>
  152 |     | <span class='neutral'>        // The wallet&#39;s public key `X`.</span>
  153 |     | <span class='neutral'>        uint256 publicKeyX;</span>
  154 |     | <span class='neutral'>        // The wallet&#39;s public key `Y`.</span>
  155 |     | <span class='neutral'>        uint256 publicKeyY;</span>
  156 |     | <span class='neutral'>        // The wallet&#39;s private key.</span>
  157 |     | <span class='neutral'>        uint256 privateKey;</span>
  158 |     | <span class='neutral'>    }</span>
  159 |     | <span class='neutral'></span>
  160 |     | <span class='neutral'>    /// The result of a `tryFfi` call.</span>
  161 |     | <span class='neutral'>    struct FfiResult {</span>
  162 |     | <span class='neutral'>        // The exit code of the call.</span>
  163 |     | <span class='neutral'>        int32 exitCode;</span>
  164 |     | <span class='neutral'>        // The optionally hex-decoded `stdout` data.</span>
  165 |     | <span class='neutral'>        bytes stdout;</span>
  166 |     | <span class='neutral'>        // The `stderr` data.</span>
  167 |     | <span class='neutral'>        bytes stderr;</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /// Information on the chain and fork.</span>
  171 |     | <span class='neutral'>    struct ChainInfo {</span>
  172 |     | <span class='neutral'>        // The fork identifier. Set to zero if no fork is active.</span>
  173 |     | <span class='neutral'>        uint256 forkId;</span>
  174 |     | <span class='neutral'>        // The chain ID of the current fork.</span>
  175 |     | <span class='neutral'>        uint256 chainId;</span>
  176 |     | <span class='neutral'>    }</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>    /// The result of a `stopAndReturnStateDiff` call.</span>
  179 |     | <span class='neutral'>    struct AccountAccess {</span>
  180 |     | <span class='neutral'>        // The chain and fork the access occurred.</span>
  181 |     | <span class='neutral'>        ChainInfo chainInfo;</span>
  182 |     | <span class='neutral'>        // The kind of account access that determines what the account is.</span>
  183 |     | <span class='neutral'>        // If kind is Call, DelegateCall, StaticCall or CallCode, then the account is the callee.</span>
  184 |     | <span class='neutral'>        // If kind is Create, then the account is the newly created account.</span>
  185 |     | <span class='neutral'>        // If kind is SelfDestruct, then the account is the selfdestruct recipient.</span>
  186 |     | <span class='neutral'>        // If kind is a Resume, then account represents a account context that has resumed.</span>
  187 |     | <span class='neutral'>        AccountAccessKind kind;</span>
  188 |     | <span class='neutral'>        // The account that was accessed.</span>
  189 |     | <span class='neutral'>        // It&#39;s either the account created, callee or a selfdestruct recipient for CREATE, CALL or SELFDESTRUCT.</span>
  190 |     | <span class='neutral'>        address account;</span>
  191 |     | <span class='neutral'>        // What accessed the account.</span>
  192 |     | <span class='neutral'>        address accessor;</span>
  193 |     | <span class='neutral'>        // If the account was initialized or empty prior to the access.</span>
  194 |     | <span class='neutral'>        // An account is considered initialized if it has code, a</span>
  195 |     | <span class='neutral'>        // non-zero nonce, or a non-zero balance.</span>
  196 |     | <span class='neutral'>        bool initialized;</span>
  197 |     | <span class='neutral'>        // The previous balance of the accessed account.</span>
  198 |     | <span class='neutral'>        uint256 oldBalance;</span>
  199 |     | <span class='neutral'>        // The potential new balance of the accessed account.</span>
  200 |     | <span class='neutral'>        // That is, all balance changes are recorded here, even if reverts occurred.</span>
  201 |     | <span class='neutral'>        uint256 newBalance;</span>
  202 |     | <span class='neutral'>        // Code of the account deployed by CREATE.</span>
  203 |     | <span class='neutral'>        bytes deployedCode;</span>
  204 |     | <span class='neutral'>        // Value passed along with the account access</span>
  205 |     | <span class='neutral'>        uint256 value;</span>
  206 |     | <span class='neutral'>        // Input data provided to the CREATE or CALL</span>
  207 |     | <span class='neutral'>        bytes data;</span>
  208 |     | <span class='neutral'>        // If this access reverted in either the current or parent context.</span>
  209 |     | <span class='neutral'>        bool reverted;</span>
  210 |     | <span class='neutral'>        // An ordered list of storage accesses made during an account access operation.</span>
  211 |     | <span class='neutral'>        StorageAccess[] storageAccesses;</span>
  212 |     | <span class='neutral'>        // Call depth traversed during the recording of state differences</span>
  213 |     | <span class='neutral'>        uint64 depth;</span>
  214 |     | <span class='neutral'>    }</span>
  215 |     | <span class='neutral'></span>
  216 |     | <span class='neutral'>    /// The storage accessed during an `AccountAccess`.</span>
  217 |     | <span class='neutral'>    struct StorageAccess {</span>
  218 |     | <span class='neutral'>        // The account whose storage was accessed.</span>
  219 |     | <span class='neutral'>        address account;</span>
  220 |     | <span class='neutral'>        // The slot that was accessed.</span>
  221 |     | <span class='neutral'>        bytes32 slot;</span>
  222 |     | <span class='neutral'>        // If the access was a write.</span>
  223 |     | <span class='neutral'>        bool isWrite;</span>
  224 |     | <span class='neutral'>        // The previous value of the slot.</span>
  225 |     | <span class='neutral'>        bytes32 previousValue;</span>
  226 |     | <span class='neutral'>        // The new value of the slot.</span>
  227 |     | <span class='neutral'>        bytes32 newValue;</span>
  228 |     | <span class='neutral'>        // If the access was reverted.</span>
  229 |     | <span class='neutral'>        bool reverted;</span>
  230 |     | <span class='neutral'>    }</span>
  231 |     | <span class='neutral'></span>
  232 |     | <span class='neutral'>    /// Gas used. Returned by `lastCallGas`.</span>
  233 |     | <span class='neutral'>    struct Gas {</span>
  234 |     | <span class='neutral'>        // The gas limit of the call.</span>
  235 |     | <span class='neutral'>        uint64 gasLimit;</span>
  236 |     | <span class='neutral'>        // The total gas used.</span>
  237 |     | <span class='neutral'>        uint64 gasTotalUsed;</span>
  238 |     | <span class='neutral'>        // DEPRECATED: The amount of gas used for memory expansion. Ref: &lt;https://github.com/foundry-rs/foundry/pull/7934#pullrequestreview-2069236939&gt;</span>
  239 |     | <span class='neutral'>        uint64 gasMemoryUsed;</span>
  240 |     | <span class='neutral'>        // The amount of gas refunded.</span>
  241 |     | <span class='neutral'>        int64 gasRefunded;</span>
  242 |     | <span class='neutral'>        // The amount of gas remaining.</span>
  243 |     | <span class='neutral'>        uint64 gasRemaining;</span>
  244 |     | <span class='neutral'>    }</span>
  245 |     | <span class='neutral'></span>
  246 |     | <span class='neutral'>    // ======== Environment ========</span>
  247 |     | <span class='neutral'></span>
  248 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  249 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  250 |     | <span class='neutral'>    function envAddress(string calldata name) external view returns (address value);</span>
  251 |     | <span class='neutral'></span>
  252 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  253 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  254 |     | <span class='neutral'>    function envAddress(string calldata name, string calldata delim) external view returns (address[] memory value);</span>
  255 |     | <span class='neutral'></span>
  256 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  257 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  258 |     | <span class='neutral'>    function envBool(string calldata name) external view returns (bool value);</span>
  259 |     | <span class='neutral'></span>
  260 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  261 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  262 |     | <span class='neutral'>    function envBool(string calldata name, string calldata delim) external view returns (bool[] memory value);</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  265 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  266 |     | <span class='neutral'>    function envBytes32(string calldata name) external view returns (bytes32 value);</span>
  267 |     | <span class='neutral'></span>
  268 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  269 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  270 |     | <span class='neutral'>    function envBytes32(string calldata name, string calldata delim) external view returns (bytes32[] memory value);</span>
  271 |     | <span class='neutral'></span>
  272 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  273 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  274 |     | <span class='neutral'>    function envBytes(string calldata name) external view returns (bytes memory value);</span>
  275 |     | <span class='neutral'></span>
  276 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  277 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  278 |     | <span class='neutral'>    function envBytes(string calldata name, string calldata delim) external view returns (bytes[] memory value);</span>
  279 |     | <span class='neutral'></span>
  280 |     | <span class='neutral'>    /// Gets the environment variable `name` and returns true if it exists, else returns false.</span>
  281 |     | <span class='neutral'>    function envExists(string calldata name) external view returns (bool result);</span>
  282 |     | <span class='neutral'></span>
  283 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  284 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  285 |     | <span class='neutral'>    function envInt(string calldata name) external view returns (int256 value);</span>
  286 |     | <span class='neutral'></span>
  287 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  288 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  289 |     | <span class='neutral'>    function envInt(string calldata name, string calldata delim) external view returns (int256[] memory value);</span>
  290 |     | <span class='neutral'></span>
  291 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bool`.</span>
  292 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  293 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  294 |     | <span class='neutral'>    function envOr(string calldata name, bool defaultValue) external view returns (bool value);</span>
  295 |     | <span class='neutral'></span>
  296 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  297 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  298 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  299 |     | <span class='neutral'>    function envOr(string calldata name, uint256 defaultValue) external view returns (uint256 value);</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `address`, delimited by `delim`.</span>
  302 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  303 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  304 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, address[] calldata defaultValue)</span>
  305 |     | <span class='neutral'>        external</span>
  306 |     | <span class='neutral'>        view</span>
  307 |     | <span class='neutral'>        returns (address[] memory value);</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes32`, delimited by `delim`.</span>
  310 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  311 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  312 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes32[] calldata defaultValue)</span>
  313 |     | <span class='neutral'>        external</span>
  314 |     | <span class='neutral'>        view</span>
  315 |     | <span class='neutral'>        returns (bytes32[] memory value);</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  318 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  319 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  320 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, string[] calldata defaultValue)</span>
  321 |     | <span class='neutral'>        external</span>
  322 |     | <span class='neutral'>        view</span>
  323 |     | <span class='neutral'>        returns (string[] memory value);</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bytes`, delimited by `delim`.</span>
  326 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  327 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  328 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bytes[] calldata defaultValue)</span>
  329 |     | <span class='neutral'>        external</span>
  330 |     | <span class='neutral'>        view</span>
  331 |     | <span class='neutral'>        returns (bytes[] memory value);</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `int256`.</span>
  334 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  335 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  336 |     | <span class='neutral'>    function envOr(string calldata name, int256 defaultValue) external view returns (int256 value);</span>
  337 |     | <span class='neutral'></span>
  338 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `address`.</span>
  339 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  340 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  341 |     | <span class='neutral'>    function envOr(string calldata name, address defaultValue) external view returns (address value);</span>
  342 |     | <span class='neutral'></span>
  343 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes32`.</span>
  344 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  345 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  346 |     | <span class='neutral'>    function envOr(string calldata name, bytes32 defaultValue) external view returns (bytes32 value);</span>
  347 |     | <span class='neutral'></span>
  348 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  349 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  350 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  351 |     | <span class='neutral'>    function envOr(string calldata name, string calldata defaultValue) external view returns (string memory value);</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `bytes`.</span>
  354 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  355 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  356 |     | <span class='neutral'>    function envOr(string calldata name, bytes calldata defaultValue) external view returns (bytes memory value);</span>
  357 |     | <span class='neutral'></span>
  358 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `bool`, delimited by `delim`.</span>
  359 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  360 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  361 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, bool[] calldata defaultValue)</span>
  362 |     | <span class='neutral'>        external</span>
  363 |     | <span class='neutral'>        view</span>
  364 |     | <span class='neutral'>        returns (bool[] memory value);</span>
  365 |     | <span class='neutral'></span>
  366 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  367 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  368 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  369 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, uint256[] calldata defaultValue)</span>
  370 |     | <span class='neutral'>        external</span>
  371 |     | <span class='neutral'>        view</span>
  372 |     | <span class='neutral'>        returns (uint256[] memory value);</span>
  373 |     | <span class='neutral'></span>
  374 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `int256`, delimited by `delim`.</span>
  375 |     | <span class='neutral'>    /// Reverts if the variable could not be parsed.</span>
  376 |     | <span class='neutral'>    /// Returns `defaultValue` if the variable was not found.</span>
  377 |     | <span class='neutral'>    function envOr(string calldata name, string calldata delim, int256[] calldata defaultValue)</span>
  378 |     | <span class='neutral'>        external</span>
  379 |     | <span class='neutral'>        view</span>
  380 |     | <span class='neutral'>        returns (int256[] memory value);</span>
  381 |     | <span class='neutral'></span>
  382 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `string`.</span>
  383 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  384 |     | <span class='neutral'>    function envString(string calldata name) external view returns (string memory value);</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `string`, delimited by `delim`.</span>
  387 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  388 |     | <span class='neutral'>    function envString(string calldata name, string calldata delim) external view returns (string[] memory value);</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as `uint256`.</span>
  391 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  392 |     | <span class='neutral'>    function envUint(string calldata name) external view returns (uint256 value);</span>
  393 |     | <span class='neutral'></span>
  394 |     | <span class='neutral'>    /// Gets the environment variable `name` and parses it as an array of `uint256`, delimited by `delim`.</span>
  395 |     | <span class='neutral'>    /// Reverts if the variable was not found or could not be parsed.</span>
  396 |     | <span class='neutral'>    function envUint(string calldata name, string calldata delim) external view returns (uint256[] memory value);</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>    /// Returns true if `forge` command was executed in given context.</span>
  399 |     | <span class='neutral'>    function isContext(ForgeContext context) external view returns (bool result);</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    /// Sets environment variables.</span>
  402 |     | <span class='neutral'>    function setEnv(string calldata name, string calldata value) external;</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='neutral'>    // ======== EVM ========</span>
  405 |     | <span class='neutral'></span>
  406 |     | <span class='neutral'>    /// Gets all accessed reads and write slot from a `vm.record` session, for a given address.</span>
  407 |     | <span class='neutral'>    function accesses(address target) external returns (bytes32[] memory readSlots, bytes32[] memory writeSlots);</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    /// Gets the address for a given private key.</span>
  410 |     | <span class='neutral'>    function addr(uint256 privateKey) external pure returns (address keyAddr);</span>
  411 |     | <span class='neutral'></span>
  412 |     | <span class='neutral'>    /// Gets all the logs according to specified filter.</span>
  413 |     | <span class='neutral'>    function eth_getLogs(uint256 fromBlock, uint256 toBlock, address target, bytes32[] calldata topics)</span>
  414 |     | <span class='neutral'>        external</span>
  415 |     | <span class='neutral'>        returns (EthGetLogs[] memory logs);</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    /// Gets the current `block.blobbasefee`.</span>
  418 |     | <span class='neutral'>    /// You should use this instead of `block.blobbasefee` if you use `vm.blobBaseFee`, as `block.blobbasefee` is assumed to be constant across a transaction,</span>
  419 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  420 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  421 |     | <span class='neutral'>    function getBlobBaseFee() external view returns (uint256 blobBaseFee);</span>
  422 |     | <span class='neutral'></span>
  423 |     | <span class='neutral'>    /// Gets the current `block.number`.</span>
  424 |     | <span class='neutral'>    /// You should use this instead of `block.number` if you use `vm.roll`, as `block.number` is assumed to be constant across a transaction,</span>
  425 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  426 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  427 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 height);</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    /// Gets the current `block.timestamp`.</span>
  430 |     | <span class='neutral'>    /// You should use this instead of `block.timestamp` if you use `vm.warp`, as `block.timestamp` is assumed to be constant across a transaction,</span>
  431 |     | <span class='neutral'>    /// and as a result will get optimized out by the compiler.</span>
  432 |     | <span class='neutral'>    /// See https://github.com/foundry-rs/foundry/issues/6180</span>
  433 |     | <span class='neutral'>    function getBlockTimestamp() external view returns (uint256 timestamp);</span>
  434 |     | <span class='neutral'></span>
  435 |     | <span class='neutral'>    /// Gets the map key and parent of a mapping at a given slot, for a given address.</span>
  436 |     | <span class='neutral'>    function getMappingKeyAndParentOf(address target, bytes32 elementSlot)</span>
  437 |     | <span class='neutral'>        external</span>
  438 |     | <span class='neutral'>        returns (bool found, bytes32 key, bytes32 parent);</span>
  439 |     | <span class='neutral'></span>
  440 |     | <span class='neutral'>    /// Gets the number of elements in the mapping at the given slot, for a given address.</span>
  441 |     | <span class='neutral'>    function getMappingLength(address target, bytes32 mappingSlot) external returns (uint256 length);</span>
  442 |     | <span class='neutral'></span>
  443 |     | <span class='neutral'>    /// Gets the elements at index idx of the mapping at the given slot, for a given address. The</span>
  444 |     | <span class='neutral'>    /// index must be less than the length of the mapping (i.e. the number of keys in the mapping).</span>
  445 |     | <span class='neutral'>    function getMappingSlotAt(address target, bytes32 mappingSlot, uint256 idx) external returns (bytes32 value);</span>
  446 |     | <span class='neutral'></span>
  447 |     | <span class='neutral'>    /// Gets the nonce of an account.</span>
  448 |     | <span class='neutral'>    function getNonce(address account) external view returns (uint64 nonce);</span>
  449 |     | <span class='neutral'></span>
  450 |     | <span class='neutral'>    /// Gets all the recorded logs.</span>
  451 |     | <span class='neutral'>    function getRecordedLogs() external returns (Log[] memory logs);</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    /// Gets the gas used in the last call.</span>
  454 |     | <span class='neutral'>    function lastCallGas() external view returns (Gas memory gas);</span>
  455 |     | <span class='neutral'></span>
  456 |     | <span class='neutral'>    /// Loads a storage slot from an address.</span>
  457 |     | <span class='neutral'>    function load(address target, bytes32 slot) external view returns (bytes32 data);</span>
  458 |     | <span class='neutral'></span>
  459 |     | <span class='neutral'>    /// Pauses gas metering (i.e. gas usage is not counted). Noop if already paused.</span>
  460 |     | <span class='neutral'>    function pauseGasMetering() external;</span>
  461 |     | <span class='neutral'></span>
  462 |     | <span class='neutral'>    /// Records all storage reads and writes.</span>
  463 |     | <span class='neutral'>    function record() external;</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    /// Record all the transaction logs.</span>
  466 |     | <span class='neutral'>    function recordLogs() external;</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>    /// Resumes gas metering (i.e. gas usage is counted again). Noop if already on.</span>
  469 |     | <span class='neutral'>    function resumeGasMetering() external;</span>
  470 |     | <span class='neutral'></span>
  471 |     | <span class='neutral'>    /// Performs an Ethereum JSON-RPC request to the current fork URL.</span>
  472 |     | <span class='neutral'>    function rpc(string calldata method, string calldata params) external returns (bytes memory data);</span>
  473 |     | <span class='neutral'></span>
  474 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256r1 curve.</span>
  475 |     | <span class='neutral'>    function signP256(uint256 privateKey, bytes32 digest) external pure returns (bytes32 r, bytes32 s);</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    /// Signs `digest` with `privateKey` using the secp256k1 curve.</span>
  478 |     | <span class='neutral'>    function sign(uint256 privateKey, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  479 |     | <span class='neutral'></span>
  480 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  481 |     | <span class='neutral'>    /// If `--sender` is provided, the signer with provided address is used, otherwise,</span>
  482 |     | <span class='neutral'>    /// if exactly one signer is provided to the script, that signer is used.</span>
  483 |     | <span class='neutral'>    /// Raises error if signer passed through `--sender` does not match any unlocked signers or</span>
  484 |     | <span class='neutral'>    /// if `--sender` is not provided and not exactly one signer is passed to the script.</span>
  485 |     | <span class='neutral'>    function sign(bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  486 |     | <span class='neutral'></span>
  487 |     | <span class='neutral'>    /// Signs `digest` with signer provided to script using the secp256k1 curve.</span>
  488 |     | <span class='neutral'>    /// Raises error if none of the signers passed into the script have provided address.</span>
  489 |     | <span class='neutral'>    function sign(address signer, bytes32 digest) external pure returns (uint8 v, bytes32 r, bytes32 s);</span>
  490 |     | <span class='neutral'></span>
  491 |     | <span class='neutral'>    /// Starts recording all map SSTOREs for later retrieval.</span>
  492 |     | <span class='neutral'>    function startMappingRecording() external;</span>
  493 |     | <span class='neutral'></span>
  494 |     | <span class='neutral'>    /// Record all account accesses as part of CREATE, CALL or SELFDESTRUCT opcodes in order,</span>
  495 |     | <span class='neutral'>    /// along with the context of the calls</span>
  496 |     | <span class='neutral'>    function startStateDiffRecording() external;</span>
  497 |     | <span class='neutral'></span>
  498 |     | <span class='neutral'>    /// Returns an ordered array of all account accesses from a `vm.startStateDiffRecording` session.</span>
  499 |     | <span class='neutral'>    function stopAndReturnStateDiff() external returns (AccountAccess[] memory accountAccesses);</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    /// Stops recording all map SSTOREs for later retrieval and clears the recorded data.</span>
  502 |     | <span class='neutral'>    function stopMappingRecording() external;</span>
  503 |     | <span class='neutral'></span>
  504 |     | <span class='neutral'>    // ======== Filesystem ========</span>
  505 |     | <span class='neutral'></span>
  506 |     | <span class='neutral'>    /// Closes file for reading, resetting the offset and allowing to read it from beginning with readLine.</span>
  507 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  508 |     | <span class='neutral'>    function closeFile(string calldata path) external;</span>
  509 |     | <span class='neutral'></span>
  510 |     | <span class='neutral'>    /// Copies the contents of one file to another. This function will **overwrite** the contents of `to`.</span>
  511 |     | <span class='neutral'>    /// On success, the total number of bytes copied is returned and it is equal to the length of the `to` file as reported by `metadata`.</span>
  512 |     | <span class='neutral'>    /// Both `from` and `to` are relative to the project root.</span>
  513 |     | <span class='neutral'>    function copyFile(string calldata from, string calldata to) external returns (uint64 copied);</span>
  514 |     | <span class='neutral'></span>
  515 |     | <span class='neutral'>    /// Creates a new, empty directory at the provided path.</span>
  516 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  517 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  518 |     | <span class='neutral'>    /// - A parent of the given path doesn&#39;t exist and `recursive` is false.</span>
  519 |     | <span class='neutral'>    /// - `path` already exists and `recursive` is false.</span>
  520 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  521 |     | <span class='neutral'>    function createDir(string calldata path, bool recursive) external;</span>
  522 |     | <span class='neutral'></span>
  523 |     | <span class='neutral'>    /// Returns true if the given path points to an existing entity, else returns false.</span>
  524 |     | <span class='neutral'>    function exists(string calldata path) external returns (bool result);</span>
  525 |     | <span class='neutral'></span>
  526 |     | <span class='neutral'>    /// Performs a foreign function call via the terminal.</span>
  527 |     | <span class='neutral'>    function ffi(string[] calldata commandInput) external returns (bytes memory result);</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    /// Given a path, query the file system to get information about a file, directory, etc.</span>
  530 |     | <span class='neutral'>    function fsMetadata(string calldata path) external view returns (FsMetadata memory metadata);</span>
  531 |     | <span class='neutral'></span>
  532 |     | <span class='neutral'>    /// Gets the creation bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  533 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  534 |     | <span class='neutral'>    function getCode(string calldata artifactPath) external view returns (bytes memory creationBytecode);</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>    /// Gets the deployed bytecode from an artifact file. Takes in the relative path to the json file or the path to the</span>
  537 |     | <span class='neutral'>    /// artifact in the form of &lt;path&gt;:&lt;contract&gt;:&lt;version&gt; where &lt;contract&gt; and &lt;version&gt; parts are optional.</span>
  538 |     | <span class='neutral'>    function getDeployedCode(string calldata artifactPath) external view returns (bytes memory runtimeBytecode);</span>
  539 |     | <span class='neutral'></span>
  540 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a directory, else returns false.</span>
  541 |     | <span class='neutral'>    function isDir(string calldata path) external returns (bool result);</span>
  542 |     | <span class='neutral'></span>
  543 |     | <span class='neutral'>    /// Returns true if the path exists on disk and is pointing at a regular file, else returns false.</span>
  544 |     | <span class='neutral'>    function isFile(string calldata path) external returns (bool result);</span>
  545 |     | <span class='neutral'></span>
  546 |     | <span class='neutral'>    /// Get the path of the current project root.</span>
  547 |     | <span class='neutral'>    function projectRoot() external view returns (string memory path);</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    /// Prompts the user for a string value in the terminal.</span>
  550 |     | <span class='neutral'>    function prompt(string calldata promptText) external returns (string memory input);</span>
  551 |     | <span class='neutral'></span>
  552 |     | <span class='neutral'>    /// Prompts the user for an address in the terminal.</span>
  553 |     | <span class='neutral'>    function promptAddress(string calldata promptText) external returns (address);</span>
  554 |     | <span class='neutral'></span>
  555 |     | <span class='neutral'>    /// Prompts the user for a hidden string value in the terminal.</span>
  556 |     | <span class='neutral'>    function promptSecret(string calldata promptText) external returns (string memory input);</span>
  557 |     | <span class='neutral'></span>
  558 |     | <span class='neutral'>    /// Prompts the user for hidden uint256 in the terminal (usually pk).</span>
  559 |     | <span class='neutral'>    function promptSecretUint(string calldata promptText) external returns (uint256);</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    /// Prompts the user for uint256 in the terminal.</span>
  562 |     | <span class='neutral'>    function promptUint(string calldata promptText) external returns (uint256);</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>    /// Reads the directory at the given path recursively, up to `maxDepth`.</span>
  565 |     | <span class='neutral'>    /// `maxDepth` defaults to 1, meaning only the direct children of the given directory will be returned.</span>
  566 |     | <span class='neutral'>    /// Follows symbolic links if `followLinks` is true.</span>
  567 |     | <span class='neutral'>    function readDir(string calldata path) external view returns (DirEntry[] memory entries);</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  570 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth) external view returns (DirEntry[] memory entries);</span>
  571 |     | <span class='neutral'></span>
  572 |     | <span class='neutral'>    /// See `readDir(string)`.</span>
  573 |     | <span class='neutral'>    function readDir(string calldata path, uint64 maxDepth, bool followLinks)</span>
  574 |     | <span class='neutral'>        external</span>
  575 |     | <span class='neutral'>        view</span>
  576 |     | <span class='neutral'>        returns (DirEntry[] memory entries);</span>
  577 |     | <span class='neutral'></span>
  578 |     | <span class='neutral'>    /// Reads the entire content of file to string. `path` is relative to the project root.</span>
  579 |     | <span class='neutral'>    function readFile(string calldata path) external view returns (string memory data);</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    /// Reads the entire content of file as binary. `path` is relative to the project root.</span>
  582 |     | <span class='neutral'>    function readFileBinary(string calldata path) external view returns (bytes memory data);</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>    /// Reads next line of file to string.</span>
  585 |     | <span class='neutral'>    function readLine(string calldata path) external view returns (string memory line);</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='neutral'>    /// Reads a symbolic link, returning the path that the link points to.</span>
  588 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  589 |     | <span class='neutral'>    /// - `path` is not a symbolic link.</span>
  590 |     | <span class='neutral'>    /// - `path` does not exist.</span>
  591 |     | <span class='neutral'>    function readLink(string calldata linkPath) external view returns (string memory targetPath);</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    /// Removes a directory at the provided path.</span>
  594 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  595 |     | <span class='neutral'>    /// - `path` doesn&#39;t exist.</span>
  596 |     | <span class='neutral'>    /// - `path` isn&#39;t a directory.</span>
  597 |     | <span class='neutral'>    /// - User lacks permissions to modify `path`.</span>
  598 |     | <span class='neutral'>    /// - The directory is not empty and `recursive` is false.</span>
  599 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  600 |     | <span class='neutral'>    function removeDir(string calldata path, bool recursive) external;</span>
  601 |     | <span class='neutral'></span>
  602 |     | <span class='neutral'>    /// Removes a file from the filesystem.</span>
  603 |     | <span class='neutral'>    /// This cheatcode will revert in the following situations, but is not limited to just these cases:</span>
  604 |     | <span class='neutral'>    /// - `path` points to a directory.</span>
  605 |     | <span class='neutral'>    /// - The file doesn&#39;t exist.</span>
  606 |     | <span class='neutral'>    /// - The user lacks permissions to remove the file.</span>
  607 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  608 |     | <span class='neutral'>    function removeFile(string calldata path) external;</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>    /// Performs a foreign function call via terminal and returns the exit code, stdout, and stderr.</span>
  611 |     | <span class='neutral'>    function tryFfi(string[] calldata commandInput) external returns (FfiResult memory result);</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    /// Returns the time since unix epoch in milliseconds.</span>
  614 |     | <span class='neutral'>    function unixTime() external returns (uint256 milliseconds);</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>    /// Writes data to file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  617 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  618 |     | <span class='neutral'>    function writeFile(string calldata path, string calldata data) external;</span>
  619 |     | <span class='neutral'></span>
  620 |     | <span class='neutral'>    /// Writes binary data to a file, creating a file if it does not exist, and entirely replacing its contents if it does.</span>
  621 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  622 |     | <span class='neutral'>    function writeFileBinary(string calldata path, bytes calldata data) external;</span>
  623 |     | <span class='neutral'></span>
  624 |     | <span class='neutral'>    /// Writes line to file, creating a file if it does not exist.</span>
  625 |     | <span class='neutral'>    /// `path` is relative to the project root.</span>
  626 |     | <span class='neutral'>    function writeLine(string calldata path, string calldata data) external;</span>
  627 |     | <span class='neutral'></span>
  628 |     | <span class='neutral'>    // ======== JSON ========</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object</span>
  631 |     | <span class='neutral'>    /// `keyExists` is being deprecated in favor of `keyExistsJson`. It will be removed in future versions.</span>
  632 |     | <span class='neutral'>    function keyExists(string calldata json, string calldata key) external view returns (bool);</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>    /// Checks if `key` exists in a JSON object.</span>
  635 |     | <span class='neutral'>    function keyExistsJson(string calldata json, string calldata key) external view returns (bool);</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address`.</span>
  638 |     | <span class='neutral'>    function parseJsonAddress(string calldata json, string calldata key) external pure returns (address);</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `address[]`.</span>
  641 |     | <span class='neutral'>    function parseJsonAddressArray(string calldata json, string calldata key)</span>
  642 |     | <span class='neutral'>        external</span>
  643 |     | <span class='neutral'>        pure</span>
  644 |     | <span class='neutral'>        returns (address[] memory);</span>
  645 |     | <span class='neutral'></span>
  646 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool`.</span>
  647 |     | <span class='neutral'>    function parseJsonBool(string calldata json, string calldata key) external pure returns (bool);</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bool[]`.</span>
  650 |     | <span class='neutral'>    function parseJsonBoolArray(string calldata json, string calldata key) external pure returns (bool[] memory);</span>
  651 |     | <span class='neutral'></span>
  652 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes`.</span>
  653 |     | <span class='neutral'>    function parseJsonBytes(string calldata json, string calldata key) external pure returns (bytes memory);</span>
  654 |     | <span class='neutral'></span>
  655 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32`.</span>
  656 |     | <span class='neutral'>    function parseJsonBytes32(string calldata json, string calldata key) external pure returns (bytes32);</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes32[]`.</span>
  659 |     | <span class='neutral'>    function parseJsonBytes32Array(string calldata json, string calldata key)</span>
  660 |     | <span class='neutral'>        external</span>
  661 |     | <span class='neutral'>        pure</span>
  662 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
  663 |     | <span class='neutral'></span>
  664 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `bytes[]`.</span>
  665 |     | <span class='neutral'>    function parseJsonBytesArray(string calldata json, string calldata key) external pure returns (bytes[] memory);</span>
  666 |     | <span class='neutral'></span>
  667 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256`.</span>
  668 |     | <span class='neutral'>    function parseJsonInt(string calldata json, string calldata key) external pure returns (int256);</span>
  669 |     | <span class='neutral'></span>
  670 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `int256[]`.</span>
  671 |     | <span class='neutral'>    function parseJsonIntArray(string calldata json, string calldata key) external pure returns (int256[] memory);</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    /// Returns an array of all the keys in a JSON object.</span>
  674 |     | <span class='neutral'>    function parseJsonKeys(string calldata json, string calldata key) external pure returns (string[] memory keys);</span>
  675 |     | <span class='neutral'></span>
  676 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string`.</span>
  677 |     | <span class='neutral'>    function parseJsonString(string calldata json, string calldata key) external pure returns (string memory);</span>
  678 |     | <span class='neutral'></span>
  679 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `string[]`.</span>
  680 |     | <span class='neutral'>    function parseJsonStringArray(string calldata json, string calldata key) external pure returns (string[] memory);</span>
  681 |     | <span class='neutral'></span>
  682 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256`.</span>
  683 |     | <span class='neutral'>    function parseJsonUint(string calldata json, string calldata key) external pure returns (uint256);</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    /// Parses a string of JSON data at `key` and coerces it to `uint256[]`.</span>
  686 |     | <span class='neutral'>    function parseJsonUintArray(string calldata json, string calldata key) external pure returns (uint256[] memory);</span>
  687 |     | <span class='neutral'></span>
  688 |     | <span class='neutral'>    /// ABI-encodes a JSON object.</span>
  689 |     | <span class='neutral'>    function parseJson(string calldata json) external pure returns (bytes memory abiEncodedData);</span>
  690 |     | <span class='neutral'></span>
  691 |     | <span class='neutral'>    /// ABI-encodes a JSON object at `key`.</span>
  692 |     | <span class='neutral'>    function parseJson(string calldata json, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
  693 |     | <span class='neutral'></span>
  694 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  695 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address value)</span>
  696 |     | <span class='neutral'>        external</span>
  697 |     | <span class='neutral'>        returns (string memory json);</span>
  698 |     | <span class='neutral'></span>
  699 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  700 |     | <span class='neutral'>    function serializeAddress(string calldata objectKey, string calldata valueKey, address[] calldata values)</span>
  701 |     | <span class='neutral'>        external</span>
  702 |     | <span class='neutral'>        returns (string memory json);</span>
  703 |     | <span class='neutral'></span>
  704 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  705 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool value)</span>
  706 |     | <span class='neutral'>        external</span>
  707 |     | <span class='neutral'>        returns (string memory json);</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  710 |     | <span class='neutral'>    function serializeBool(string calldata objectKey, string calldata valueKey, bool[] calldata values)</span>
  711 |     | <span class='neutral'>        external</span>
  712 |     | <span class='neutral'>        returns (string memory json);</span>
  713 |     | <span class='neutral'></span>
  714 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  715 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32 value)</span>
  716 |     | <span class='neutral'>        external</span>
  717 |     | <span class='neutral'>        returns (string memory json);</span>
  718 |     | <span class='neutral'></span>
  719 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  720 |     | <span class='neutral'>    function serializeBytes32(string calldata objectKey, string calldata valueKey, bytes32[] calldata values)</span>
  721 |     | <span class='neutral'>        external</span>
  722 |     | <span class='neutral'>        returns (string memory json);</span>
  723 |     | <span class='neutral'></span>
  724 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  725 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes calldata value)</span>
  726 |     | <span class='neutral'>        external</span>
  727 |     | <span class='neutral'>        returns (string memory json);</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  730 |     | <span class='neutral'>    function serializeBytes(string calldata objectKey, string calldata valueKey, bytes[] calldata values)</span>
  731 |     | <span class='neutral'>        external</span>
  732 |     | <span class='neutral'>        returns (string memory json);</span>
  733 |     | <span class='neutral'></span>
  734 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  735 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256 value)</span>
  736 |     | <span class='neutral'>        external</span>
  737 |     | <span class='neutral'>        returns (string memory json);</span>
  738 |     | <span class='neutral'></span>
  739 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  740 |     | <span class='neutral'>    function serializeInt(string calldata objectKey, string calldata valueKey, int256[] calldata values)</span>
  741 |     | <span class='neutral'>        external</span>
  742 |     | <span class='neutral'>        returns (string memory json);</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>    /// Serializes a key and value to a JSON object stored in-memory that can be later written to a file.</span>
  745 |     | <span class='neutral'>    /// Returns the stringified version of the specific JSON file up to that moment.</span>
  746 |     | <span class='neutral'>    function serializeJson(string calldata objectKey, string calldata value) external returns (string memory json);</span>
  747 |     | <span class='neutral'></span>
  748 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  749 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string calldata value)</span>
  750 |     | <span class='neutral'>        external</span>
  751 |     | <span class='neutral'>        returns (string memory json);</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  754 |     | <span class='neutral'>    function serializeString(string calldata objectKey, string calldata valueKey, string[] calldata values)</span>
  755 |     | <span class='neutral'>        external</span>
  756 |     | <span class='neutral'>        returns (string memory json);</span>
  757 |     | <span class='neutral'></span>
  758 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  759 |     | <span class='neutral'>    function serializeUintToHex(string calldata objectKey, string calldata valueKey, uint256 value)</span>
  760 |     | <span class='neutral'>        external</span>
  761 |     | <span class='neutral'>        returns (string memory json);</span>
  762 |     | <span class='neutral'></span>
  763 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  764 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256 value)</span>
  765 |     | <span class='neutral'>        external</span>
  766 |     | <span class='neutral'>        returns (string memory json);</span>
  767 |     | <span class='neutral'></span>
  768 |     | <span class='neutral'>    /// See `serializeJson`.</span>
  769 |     | <span class='neutral'>    function serializeUint(string calldata objectKey, string calldata valueKey, uint256[] calldata values)</span>
  770 |     | <span class='neutral'>        external</span>
  771 |     | <span class='neutral'>        returns (string memory json);</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    /// Write a serialized JSON object to a file. If the file exists, it will be overwritten.</span>
  774 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path) external;</span>
  775 |     | <span class='neutral'></span>
  776 |     | <span class='neutral'>    /// Write a serialized JSON object to an **existing** JSON file, replacing a value with key = &lt;value_key.&gt;</span>
  777 |     | <span class='neutral'>    /// This is useful to replace a specific value of a JSON file, without having to parse the entire thing.</span>
  778 |     | <span class='neutral'>    function writeJson(string calldata json, string calldata path, string calldata valueKey) external;</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>    // ======== Scripting ========</span>
  781 |     | <span class='neutral'></span>
  782 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create transactions that can later be signed and sent onchain.</span>
  783 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
  784 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
  785 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
  786 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
  787 |     | <span class='neutral'>    function broadcast() external;</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the address provided</span>
  790 |     | <span class='neutral'>    /// as the sender that can later be signed and sent onchain.</span>
  791 |     | <span class='neutral'>    function broadcast(address signer) external;</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    /// Has the next call (at this call depth only) create a transaction with the private key</span>
  794 |     | <span class='neutral'>    /// provided as the sender that can later be signed and sent onchain.</span>
  795 |     | <span class='neutral'>    function broadcast(uint256 privateKey) external;</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions that can later be signed and sent onchain.</span>
  798 |     | <span class='neutral'>    /// Broadcasting address is determined by checking the following in order:</span>
  799 |     | <span class='neutral'>    /// 1. If `--sender` argument was provided, that address is used.</span>
  800 |     | <span class='neutral'>    /// 2. If exactly one signer (e.g. private key, hw wallet, keystore) is set when `forge broadcast` is invoked, that signer is used.</span>
  801 |     | <span class='neutral'>    /// 3. Otherwise, default foundry sender (1804c8AB1F12E6bbf3894d4083f33e07309d1f38) is used.</span>
  802 |     | <span class='neutral'>    function startBroadcast() external;</span>
  803 |     | <span class='neutral'></span>
  804 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the address</span>
  805 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
  806 |     | <span class='neutral'>    function startBroadcast(address signer) external;</span>
  807 |     | <span class='neutral'></span>
  808 |     | <span class='neutral'>    /// Has all subsequent calls (at this call depth only) create transactions with the private key</span>
  809 |     | <span class='neutral'>    /// provided that can later be signed and sent onchain.</span>
  810 |     | <span class='neutral'>    function startBroadcast(uint256 privateKey) external;</span>
  811 |     | <span class='neutral'></span>
  812 |     | <span class='neutral'>    /// Stops collecting onchain transactions.</span>
  813 |     | <span class='neutral'>    function stopBroadcast() external;</span>
  814 |     | <span class='neutral'></span>
  815 |     | <span class='neutral'>    // ======== String ========</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    /// Returns the index of the first occurrence of a `key` in an `input` string.</span>
  818 |     | <span class='neutral'>    /// Returns `NOT_FOUND` (i.e. `type(uint256).max`) if the `key` is not found.</span>
  819 |     | <span class='neutral'>    /// Returns 0 in case of an empty `key`.</span>
  820 |     | <span class='neutral'>    function indexOf(string calldata input, string calldata key) external pure returns (uint256);</span>
  821 |     | <span class='neutral'></span>
  822 |     | <span class='neutral'>    /// Parses the given `string` into an `address`.</span>
  823 |     | <span class='neutral'>    function parseAddress(string calldata stringifiedValue) external pure returns (address parsedValue);</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    /// Parses the given `string` into a `bool`.</span>
  826 |     | <span class='neutral'>    function parseBool(string calldata stringifiedValue) external pure returns (bool parsedValue);</span>
  827 |     | <span class='neutral'></span>
  828 |     | <span class='neutral'>    /// Parses the given `string` into `bytes`.</span>
  829 |     | <span class='neutral'>    function parseBytes(string calldata stringifiedValue) external pure returns (bytes memory parsedValue);</span>
  830 |     | <span class='neutral'></span>
  831 |     | <span class='neutral'>    /// Parses the given `string` into a `bytes32`.</span>
  832 |     | <span class='neutral'>    function parseBytes32(string calldata stringifiedValue) external pure returns (bytes32 parsedValue);</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    /// Parses the given `string` into a `int256`.</span>
  835 |     | <span class='neutral'>    function parseInt(string calldata stringifiedValue) external pure returns (int256 parsedValue);</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    /// Parses the given `string` into a `uint256`.</span>
  838 |     | <span class='neutral'>    function parseUint(string calldata stringifiedValue) external pure returns (uint256 parsedValue);</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>    /// Replaces occurrences of `from` in the given `string` with `to`.</span>
  841 |     | <span class='neutral'>    function replace(string calldata input, string calldata from, string calldata to)</span>
  842 |     | <span class='neutral'>        external</span>
  843 |     | <span class='neutral'>        pure</span>
  844 |     | <span class='neutral'>        returns (string memory output);</span>
  845 |     | <span class='neutral'></span>
  846 |     | <span class='neutral'>    /// Splits the given `string` into an array of strings divided by the `delimiter`.</span>
  847 |     | <span class='neutral'>    function split(string calldata input, string calldata delimiter) external pure returns (string[] memory outputs);</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    /// Converts the given `string` value to Lowercase.</span>
  850 |     | <span class='neutral'>    function toLowercase(string calldata input) external pure returns (string memory output);</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  853 |     | <span class='neutral'>    function toString(address value) external pure returns (string memory stringifiedValue);</span>
  854 |     | <span class='neutral'></span>
  855 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  856 |     | <span class='neutral'>    function toString(bytes calldata value) external pure returns (string memory stringifiedValue);</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  859 |     | <span class='neutral'>    function toString(bytes32 value) external pure returns (string memory stringifiedValue);</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  862 |     | <span class='neutral'>    function toString(bool value) external pure returns (string memory stringifiedValue);</span>
  863 |     | <span class='neutral'></span>
  864 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  865 |     | <span class='neutral'>    function toString(uint256 value) external pure returns (string memory stringifiedValue);</span>
  866 |     | <span class='neutral'></span>
  867 |     | <span class='neutral'>    /// Converts the given value to a `string`.</span>
  868 |     | <span class='neutral'>    function toString(int256 value) external pure returns (string memory stringifiedValue);</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    /// Converts the given `string` value to Uppercase.</span>
  871 |     | <span class='neutral'>    function toUppercase(string calldata input) external pure returns (string memory output);</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    /// Trims leading and trailing whitespace from the given `string` value.</span>
  874 |     | <span class='neutral'>    function trim(string calldata input) external pure returns (string memory output);</span>
  875 |     | <span class='neutral'></span>
  876 |     | <span class='neutral'>    // ======== Testing ========</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  879 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  880 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(uint256 left, uint256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  883 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  884 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
  885 |     | <span class='neutral'>        uint256 left,</span>
  886 |     | <span class='neutral'>        uint256 right,</span>
  887 |     | <span class='neutral'>        uint256 maxDelta,</span>
  888 |     | <span class='neutral'>        uint256 decimals,</span>
  889 |     | <span class='neutral'>        string calldata error</span>
  890 |     | <span class='neutral'>    ) external pure;</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  893 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  894 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(int256 left, int256 right, uint256 maxDelta, uint256 decimals) external pure;</span>
  895 |     | <span class='neutral'></span>
  896 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  897 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  898 |     | <span class='neutral'>    function assertApproxEqAbsDecimal(</span>
  899 |     | <span class='neutral'>        int256 left,</span>
  900 |     | <span class='neutral'>        int256 right,</span>
  901 |     | <span class='neutral'>        uint256 maxDelta,</span>
  902 |     | <span class='neutral'>        uint256 decimals,</span>
  903 |     | <span class='neutral'>        string calldata error</span>
  904 |     | <span class='neutral'>    ) external pure;</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  907 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta) external pure;</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  910 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  911 |     | <span class='neutral'>    function assertApproxEqAbs(uint256 left, uint256 right, uint256 maxDelta, string calldata error) external pure;</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  914 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta) external pure;</span>
  915 |     | <span class='neutral'></span>
  916 |     | <span class='neutral'>    /// Compares two `int256` values. Expects difference to be less than or equal to `maxDelta`.</span>
  917 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  918 |     | <span class='neutral'>    function assertApproxEqAbs(int256 left, int256 right, uint256 maxDelta, string calldata error) external pure;</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  921 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  922 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  923 |     | <span class='neutral'>    function assertApproxEqRelDecimal(uint256 left, uint256 right, uint256 maxPercentDelta, uint256 decimals)</span>
  924 |     | <span class='neutral'>        external</span>
  925 |     | <span class='neutral'>        pure;</span>
  926 |     | <span class='neutral'></span>
  927 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  928 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  929 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  930 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
  931 |     | <span class='neutral'>        uint256 left,</span>
  932 |     | <span class='neutral'>        uint256 right,</span>
  933 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
  934 |     | <span class='neutral'>        uint256 decimals,</span>
  935 |     | <span class='neutral'>        string calldata error</span>
  936 |     | <span class='neutral'>    ) external pure;</span>
  937 |     | <span class='neutral'></span>
  938 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  939 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  940 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
  941 |     | <span class='neutral'>    function assertApproxEqRelDecimal(int256 left, int256 right, uint256 maxPercentDelta, uint256 decimals)</span>
  942 |     | <span class='neutral'>        external</span>
  943 |     | <span class='neutral'>        pure;</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  946 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  947 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
  948 |     | <span class='neutral'>    function assertApproxEqRelDecimal(</span>
  949 |     | <span class='neutral'>        int256 left,</span>
  950 |     | <span class='neutral'>        int256 right,</span>
  951 |     | <span class='neutral'>        uint256 maxPercentDelta,</span>
  952 |     | <span class='neutral'>        uint256 decimals,</span>
  953 |     | <span class='neutral'>        string calldata error</span>
  954 |     | <span class='neutral'>    ) external pure;</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  957 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  958 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta) external pure;</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  961 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  962 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  963 |     | <span class='neutral'>    function assertApproxEqRel(uint256 left, uint256 right, uint256 maxPercentDelta, string calldata error)</span>
  964 |     | <span class='neutral'>        external</span>
  965 |     | <span class='neutral'>        pure;</span>
  966 |     | <span class='neutral'></span>
  967 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  968 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  969 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta) external pure;</span>
  970 |     | <span class='neutral'></span>
  971 |     | <span class='neutral'>    /// Compares two `int256` values. Expects relative difference in percents to be less than or equal to `maxPercentDelta`.</span>
  972 |     | <span class='neutral'>    /// `maxPercentDelta` is an 18 decimal fixed point number, where 1e18 == 100%</span>
  973 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  974 |     | <span class='neutral'>    function assertApproxEqRel(int256 left, int256 right, uint256 maxPercentDelta, string calldata error)</span>
  975 |     | <span class='neutral'>        external</span>
  976 |     | <span class='neutral'>        pure;</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
  979 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal, formatting them with decimals in failure message.</span>
  982 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  983 |     | <span class='neutral'>    function assertEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
  986 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
  987 |     | <span class='neutral'></span>
  988 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal, formatting them with decimals in failure message.</span>
  989 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
  990 |     | <span class='neutral'>    function assertEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
  991 |     | <span class='neutral'></span>
  992 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal.</span>
  993 |     | <span class='neutral'>    function assertEq(bool left, bool right) external pure;</span>
  994 |     | <span class='neutral'></span>
  995 |     | <span class='neutral'>    /// Asserts that two `bool` values are equal and includes error message into revert string on failure.</span>
  996 |     | <span class='neutral'>    function assertEq(bool left, bool right, string calldata error) external pure;</span>
  997 |     | <span class='neutral'></span>
  998 |     | <span class='neutral'>    /// Asserts that two `string` values are equal.</span>
  999 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right) external pure;</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    /// Asserts that two `string` values are equal and includes error message into revert string on failure.</span>
 1002 |     | <span class='neutral'>    function assertEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal.</span>
 1005 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right) external pure;</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>    /// Asserts that two `bytes` values are equal and includes error message into revert string on failure.</span>
 1008 |     | <span class='neutral'>    function assertEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1009 |     | <span class='neutral'></span>
 1010 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal.</span>
 1011 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are equal and includes error message into revert string on failure.</span>
 1014 |     | <span class='neutral'>    function assertEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1015 |     | <span class='neutral'></span>
 1016 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256 values are equal.</span>
 1017 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1018 |     | <span class='neutral'></span>
 1019 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are equal and includes error message into revert string on failure.</span>
 1020 |     | <span class='neutral'>    function assertEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal.</span>
 1023 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are equal and includes error message into revert string on failure.</span>
 1026 |     | <span class='neutral'>    function assertEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal.</span>
 1029 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right) external pure;</span>
 1030 |     | <span class='neutral'></span>
 1031 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal.</span>
 1032 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right) external pure;</span>
 1033 |     | <span class='neutral'></span>
 1034 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are equal and includes error message into revert string on failure.</span>
 1035 |     | <span class='neutral'>    function assertEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal.</span>
 1038 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1039 |     | <span class='neutral'></span>
 1040 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are equal and includes error message into revert string on failure.</span>
 1041 |     | <span class='neutral'>    function assertEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1042 |     | <span class='neutral'></span>
 1043 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal.</span>
 1044 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right) external pure;</span>
 1045 |     | <span class='neutral'></span>
 1046 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are equal and includes error message into revert string on failure.</span>
 1047 |     | <span class='neutral'>    function assertEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal.</span>
 1050 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1051 |     | <span class='neutral'></span>
 1052 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are equal and includes error message into revert string on failure.</span>
 1053 |     | <span class='neutral'>    function assertEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1054 |     | <span class='neutral'></span>
 1055 |     | <span class='neutral'>    /// Asserts that two `uint256` values are equal and includes error message into revert string on failure.</span>
 1056 |     | <span class='neutral'>    function assertEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1057 |     | <span class='neutral'></span>
 1058 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal.</span>
 1059 |     | <span class='neutral'>    function assertEq(int256 left, int256 right) external pure;</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    /// Asserts that two `int256` values are equal and includes error message into revert string on failure.</span>
 1062 |     | <span class='neutral'>    function assertEq(int256 left, int256 right, string calldata error) external pure;</span>
 1063 |     | <span class='neutral'></span>
 1064 |     | <span class='neutral'>    /// Asserts that two `address` values are equal.</span>
 1065 |     | <span class='neutral'>    function assertEq(address left, address right) external pure;</span>
 1066 |     | <span class='neutral'></span>
 1067 |     | <span class='neutral'>    /// Asserts that two `address` values are equal and includes error message into revert string on failure.</span>
 1068 |     | <span class='neutral'>    function assertEq(address left, address right, string calldata error) external pure;</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal.</span>
 1071 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right) external pure;</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are equal and includes error message into revert string on failure.</span>
 1074 |     | <span class='neutral'>    function assertEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>    /// Asserts that the given condition is false.</span>
 1077 |     | <span class='neutral'>    function assertFalse(bool condition) external pure;</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>    /// Asserts that the given condition is false and includes error message into revert string on failure.</span>
 1080 |     | <span class='neutral'>    function assertFalse(bool condition, string calldata error) external pure;</span>
 1081 |     | <span class='neutral'></span>
 1082 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1083 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1084 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1087 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1088 |     | <span class='neutral'>    function assertGeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1089 |     | <span class='neutral'></span>
 1090 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1091 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1092 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1093 |     | <span class='neutral'></span>
 1094 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1095 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1096 |     | <span class='neutral'>    function assertGeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1099 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right) external pure;</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than or equal to second.</span>
 1102 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1103 |     | <span class='neutral'>    function assertGe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1106 |     | <span class='neutral'>    function assertGe(int256 left, int256 right) external pure;</span>
 1107 |     | <span class='neutral'></span>
 1108 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than or equal to second.</span>
 1109 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1110 |     | <span class='neutral'>    function assertGe(int256 left, int256 right, string calldata error) external pure;</span>
 1111 |     | <span class='neutral'></span>
 1112 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1113 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1114 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1115 |     | <span class='neutral'></span>
 1116 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1117 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1118 |     | <span class='neutral'>    function assertGtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1119 |     | <span class='neutral'></span>
 1120 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1121 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1122 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1123 |     | <span class='neutral'></span>
 1124 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1125 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1126 |     | <span class='neutral'>    function assertGtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1127 |     | <span class='neutral'></span>
 1128 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1129 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right) external pure;</span>
 1130 |     | <span class='neutral'></span>
 1131 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be greater than second.</span>
 1132 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1133 |     | <span class='neutral'>    function assertGt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1136 |     | <span class='neutral'>    function assertGt(int256 left, int256 right) external pure;</span>
 1137 |     | <span class='neutral'></span>
 1138 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be greater than second.</span>
 1139 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1140 |     | <span class='neutral'>    function assertGt(int256 left, int256 right, string calldata error) external pure;</span>
 1141 |     | <span class='neutral'></span>
 1142 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1143 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1144 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1145 |     | <span class='neutral'></span>
 1146 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1147 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1148 |     | <span class='neutral'>    function assertLeDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1149 |     | <span class='neutral'></span>
 1150 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1151 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1152 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1153 |     | <span class='neutral'></span>
 1154 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1155 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1156 |     | <span class='neutral'>    function assertLeDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1157 |     | <span class='neutral'></span>
 1158 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1159 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right) external pure;</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than or equal to second.</span>
 1162 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1163 |     | <span class='neutral'>    function assertLe(uint256 left, uint256 right, string calldata error) external pure;</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1166 |     | <span class='neutral'>    function assertLe(int256 left, int256 right) external pure;</span>
 1167 |     | <span class='neutral'></span>
 1168 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than or equal to second.</span>
 1169 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1170 |     | <span class='neutral'>    function assertLe(int256 left, int256 right, string calldata error) external pure;</span>
 1171 |     | <span class='neutral'></span>
 1172 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1173 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1174 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1175 |     | <span class='neutral'></span>
 1176 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1177 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1178 |     | <span class='neutral'>    function assertLtDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1179 |     | <span class='neutral'></span>
 1180 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1181 |     | <span class='neutral'>    /// Formats values with decimals in failure message.</span>
 1182 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1183 |     | <span class='neutral'></span>
 1184 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1185 |     | <span class='neutral'>    /// Formats values with decimals in failure message. Includes error message into revert string on failure.</span>
 1186 |     | <span class='neutral'>    function assertLtDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1187 |     | <span class='neutral'></span>
 1188 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1189 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right) external pure;</span>
 1190 |     | <span class='neutral'></span>
 1191 |     | <span class='neutral'>    /// Compares two `uint256` values. Expects first value to be less than second.</span>
 1192 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1193 |     | <span class='neutral'>    function assertLt(uint256 left, uint256 right, string calldata error) external pure;</span>
 1194 |     | <span class='neutral'></span>
 1195 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1196 |     | <span class='neutral'>    function assertLt(int256 left, int256 right) external pure;</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    /// Compares two `int256` values. Expects first value to be less than second.</span>
 1199 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1200 |     | <span class='neutral'>    function assertLt(int256 left, int256 right, string calldata error) external pure;</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1203 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals) external pure;</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal, formatting them with decimals in failure message.</span>
 1206 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1207 |     | <span class='neutral'>    function assertNotEqDecimal(uint256 left, uint256 right, uint256 decimals, string calldata error) external pure;</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1210 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals) external pure;</span>
 1211 |     | <span class='neutral'></span>
 1212 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal, formatting them with decimals in failure message.</span>
 1213 |     | <span class='neutral'>    /// Includes error message into revert string on failure.</span>
 1214 |     | <span class='neutral'>    function assertNotEqDecimal(int256 left, int256 right, uint256 decimals, string calldata error) external pure;</span>
 1215 |     | <span class='neutral'></span>
 1216 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal.</span>
 1217 |     | <span class='neutral'>    function assertNotEq(bool left, bool right) external pure;</span>
 1218 |     | <span class='neutral'></span>
 1219 |     | <span class='neutral'>    /// Asserts that two `bool` values are not equal and includes error message into revert string on failure.</span>
 1220 |     | <span class='neutral'>    function assertNotEq(bool left, bool right, string calldata error) external pure;</span>
 1221 |     | <span class='neutral'></span>
 1222 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal.</span>
 1223 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right) external pure;</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    /// Asserts that two `string` values are not equal and includes error message into revert string on failure.</span>
 1226 |     | <span class='neutral'>    function assertNotEq(string calldata left, string calldata right, string calldata error) external pure;</span>
 1227 |     | <span class='neutral'></span>
 1228 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal.</span>
 1229 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right) external pure;</span>
 1230 |     | <span class='neutral'></span>
 1231 |     | <span class='neutral'>    /// Asserts that two `bytes` values are not equal and includes error message into revert string on failure.</span>
 1232 |     | <span class='neutral'>    function assertNotEq(bytes calldata left, bytes calldata right, string calldata error) external pure;</span>
 1233 |     | <span class='neutral'></span>
 1234 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal.</span>
 1235 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right) external pure;</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    /// Asserts that two arrays of `bool` values are not equal and includes error message into revert string on failure.</span>
 1238 |     | <span class='neutral'>    function assertNotEq(bool[] calldata left, bool[] calldata right, string calldata error) external pure;</span>
 1239 |     | <span class='neutral'></span>
 1240 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal.</span>
 1241 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right) external pure;</span>
 1242 |     | <span class='neutral'></span>
 1243 |     | <span class='neutral'>    /// Asserts that two arrays of `uint256` values are not equal and includes error message into revert string on failure.</span>
 1244 |     | <span class='neutral'>    function assertNotEq(uint256[] calldata left, uint256[] calldata right, string calldata error) external pure;</span>
 1245 |     | <span class='neutral'></span>
 1246 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal.</span>
 1247 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right) external pure;</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    /// Asserts that two arrays of `int256` values are not equal and includes error message into revert string on failure.</span>
 1250 |     | <span class='neutral'>    function assertNotEq(int256[] calldata left, int256[] calldata right, string calldata error) external pure;</span>
 1251 |     | <span class='neutral'></span>
 1252 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal.</span>
 1253 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right) external pure;</span>
 1254 |     | <span class='neutral'></span>
 1255 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal.</span>
 1256 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right) external pure;</span>
 1257 |     | <span class='neutral'></span>
 1258 |     | <span class='neutral'>    /// Asserts that two arrays of `address` values are not equal and includes error message into revert string on failure.</span>
 1259 |     | <span class='neutral'>    function assertNotEq(address[] calldata left, address[] calldata right, string calldata error) external pure;</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal.</span>
 1262 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right) external pure;</span>
 1263 |     | <span class='neutral'></span>
 1264 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1265 |     | <span class='neutral'>    function assertNotEq(bytes32[] calldata left, bytes32[] calldata right, string calldata error) external pure;</span>
 1266 |     | <span class='neutral'></span>
 1267 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal.</span>
 1268 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right) external pure;</span>
 1269 |     | <span class='neutral'></span>
 1270 |     | <span class='neutral'>    /// Asserts that two arrays of `string` values are not equal and includes error message into revert string on failure.</span>
 1271 |     | <span class='neutral'>    function assertNotEq(string[] calldata left, string[] calldata right, string calldata error) external pure;</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal.</span>
 1274 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right) external pure;</span>
 1275 |     | <span class='neutral'></span>
 1276 |     | <span class='neutral'>    /// Asserts that two arrays of `bytes` values are not equal and includes error message into revert string on failure.</span>
 1277 |     | <span class='neutral'>    function assertNotEq(bytes[] calldata left, bytes[] calldata right, string calldata error) external pure;</span>
 1278 |     | <span class='neutral'></span>
 1279 |     | <span class='neutral'>    /// Asserts that two `uint256` values are not equal and includes error message into revert string on failure.</span>
 1280 |     | <span class='neutral'>    function assertNotEq(uint256 left, uint256 right, string calldata error) external pure;</span>
 1281 |     | <span class='neutral'></span>
 1282 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal.</span>
 1283 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right) external pure;</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    /// Asserts that two `int256` values are not equal and includes error message into revert string on failure.</span>
 1286 |     | <span class='neutral'>    function assertNotEq(int256 left, int256 right, string calldata error) external pure;</span>
 1287 |     | <span class='neutral'></span>
 1288 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal.</span>
 1289 |     | <span class='neutral'>    function assertNotEq(address left, address right) external pure;</span>
 1290 |     | <span class='neutral'></span>
 1291 |     | <span class='neutral'>    /// Asserts that two `address` values are not equal and includes error message into revert string on failure.</span>
 1292 |     | <span class='neutral'>    function assertNotEq(address left, address right, string calldata error) external pure;</span>
 1293 |     | <span class='neutral'></span>
 1294 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal.</span>
 1295 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right) external pure;</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    /// Asserts that two `bytes32` values are not equal and includes error message into revert string on failure.</span>
 1298 |     | <span class='neutral'>    function assertNotEq(bytes32 left, bytes32 right, string calldata error) external pure;</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>    /// Asserts that the given condition is true.</span>
 1301 |     | <span class='neutral'>    function assertTrue(bool condition) external pure;</span>
 1302 |     | <span class='neutral'></span>
 1303 |     | <span class='neutral'>    /// Asserts that the given condition is true and includes error message into revert string on failure.</span>
 1304 |     | <span class='neutral'>    function assertTrue(bool condition, string calldata error) external pure;</span>
 1305 |     | <span class='neutral'></span>
 1306 |     | <span class='neutral'>    /// If the condition is false, discard this run&#39;s fuzz inputs and generate new ones.</span>
 1307 |     | <span class='neutral'>    function assume(bool condition) external pure;</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    /// Writes a breakpoint to jump to in the debugger.</span>
 1310 |     | <span class='neutral'>    function breakpoint(string calldata char) external;</span>
 1311 |     | <span class='neutral'></span>
 1312 |     | <span class='neutral'>    /// Writes a conditional breakpoint to jump to in the debugger.</span>
 1313 |     | <span class='neutral'>    function breakpoint(string calldata char, bool value) external;</span>
 1314 |     | <span class='neutral'></span>
 1315 |     | <span class='neutral'>    /// Returns the RPC url for the given alias.</span>
 1316 |     | <span class='neutral'>    function rpcUrl(string calldata rpcAlias) external view returns (string memory json);</span>
 1317 |     | <span class='neutral'></span>
 1318 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases as structs.</span>
 1319 |     | <span class='neutral'>    function rpcUrlStructs() external view returns (Rpc[] memory urls);</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    /// Returns all rpc urls and their aliases `[alias, url][]`.</span>
 1322 |     | <span class='neutral'>    function rpcUrls() external view returns (string[2][] memory urls);</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>    /// Suspends execution of the main thread for `duration` milliseconds.</span>
 1325 |     | <span class='neutral'>    function sleep(uint256 duration) external;</span>
 1326 |     | <span class='neutral'></span>
 1327 |     | <span class='neutral'>    // ======== Toml ========</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    /// Checks if `key` exists in a TOML table.</span>
 1330 |     | <span class='neutral'>    function keyExistsToml(string calldata toml, string calldata key) external view returns (bool);</span>
 1331 |     | <span class='neutral'></span>
 1332 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address`.</span>
 1333 |     | <span class='neutral'>    function parseTomlAddress(string calldata toml, string calldata key) external pure returns (address);</span>
 1334 |     | <span class='neutral'></span>
 1335 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `address[]`.</span>
 1336 |     | <span class='neutral'>    function parseTomlAddressArray(string calldata toml, string calldata key)</span>
 1337 |     | <span class='neutral'>        external</span>
 1338 |     | <span class='neutral'>        pure</span>
 1339 |     | <span class='neutral'>        returns (address[] memory);</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool`.</span>
 1342 |     | <span class='neutral'>    function parseTomlBool(string calldata toml, string calldata key) external pure returns (bool);</span>
 1343 |     | <span class='neutral'></span>
 1344 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bool[]`.</span>
 1345 |     | <span class='neutral'>    function parseTomlBoolArray(string calldata toml, string calldata key) external pure returns (bool[] memory);</span>
 1346 |     | <span class='neutral'></span>
 1347 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes`.</span>
 1348 |     | <span class='neutral'>    function parseTomlBytes(string calldata toml, string calldata key) external pure returns (bytes memory);</span>
 1349 |     | <span class='neutral'></span>
 1350 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32`.</span>
 1351 |     | <span class='neutral'>    function parseTomlBytes32(string calldata toml, string calldata key) external pure returns (bytes32);</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes32[]`.</span>
 1354 |     | <span class='neutral'>    function parseTomlBytes32Array(string calldata toml, string calldata key)</span>
 1355 |     | <span class='neutral'>        external</span>
 1356 |     | <span class='neutral'>        pure</span>
 1357 |     | <span class='neutral'>        returns (bytes32[] memory);</span>
 1358 |     | <span class='neutral'></span>
 1359 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `bytes[]`.</span>
 1360 |     | <span class='neutral'>    function parseTomlBytesArray(string calldata toml, string calldata key) external pure returns (bytes[] memory);</span>
 1361 |     | <span class='neutral'></span>
 1362 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256`.</span>
 1363 |     | <span class='neutral'>    function parseTomlInt(string calldata toml, string calldata key) external pure returns (int256);</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `int256[]`.</span>
 1366 |     | <span class='neutral'>    function parseTomlIntArray(string calldata toml, string calldata key) external pure returns (int256[] memory);</span>
 1367 |     | <span class='neutral'></span>
 1368 |     | <span class='neutral'>    /// Returns an array of all the keys in a TOML table.</span>
 1369 |     | <span class='neutral'>    function parseTomlKeys(string calldata toml, string calldata key) external pure returns (string[] memory keys);</span>
 1370 |     | <span class='neutral'></span>
 1371 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string`.</span>
 1372 |     | <span class='neutral'>    function parseTomlString(string calldata toml, string calldata key) external pure returns (string memory);</span>
 1373 |     | <span class='neutral'></span>
 1374 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `string[]`.</span>
 1375 |     | <span class='neutral'>    function parseTomlStringArray(string calldata toml, string calldata key) external pure returns (string[] memory);</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256`.</span>
 1378 |     | <span class='neutral'>    function parseTomlUint(string calldata toml, string calldata key) external pure returns (uint256);</span>
 1379 |     | <span class='neutral'></span>
 1380 |     | <span class='neutral'>    /// Parses a string of TOML data at `key` and coerces it to `uint256[]`.</span>
 1381 |     | <span class='neutral'>    function parseTomlUintArray(string calldata toml, string calldata key) external pure returns (uint256[] memory);</span>
 1382 |     | <span class='neutral'></span>
 1383 |     | <span class='neutral'>    /// ABI-encodes a TOML table.</span>
 1384 |     | <span class='neutral'>    function parseToml(string calldata toml) external pure returns (bytes memory abiEncodedData);</span>
 1385 |     | <span class='neutral'></span>
 1386 |     | <span class='neutral'>    /// ABI-encodes a TOML table at `key`.</span>
 1387 |     | <span class='neutral'>    function parseToml(string calldata toml, string calldata key) external pure returns (bytes memory abiEncodedData);</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML to a file.</span>
 1390 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path) external;</span>
 1391 |     | <span class='neutral'></span>
 1392 |     | <span class='neutral'>    /// Takes serialized JSON, converts to TOML and write a serialized TOML table to an **existing** TOML file, replacing a value with key = &lt;value_key.&gt;</span>
 1393 |     | <span class='neutral'>    /// This is useful to replace a specific value of a TOML file, without having to parse the entire thing.</span>
 1394 |     | <span class='neutral'>    function writeToml(string calldata json, string calldata path, string calldata valueKey) external;</span>
 1395 |     | <span class='neutral'></span>
 1396 |     | <span class='neutral'>    // ======== Utilities ========</span>
 1397 |     | <span class='neutral'></span>
 1398 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the given CREATE2 deployer.</span>
 1399 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash, address deployer)</span>
 1400 |     | <span class='neutral'>        external</span>
 1401 |     | <span class='neutral'>        pure</span>
 1402 |     | <span class='neutral'>        returns (address);</span>
 1403 |     | <span class='neutral'></span>
 1404 |     | <span class='neutral'>    /// Compute the address of a contract created with CREATE2 using the default CREATE2 deployer.</span>
 1405 |     | <span class='neutral'>    function computeCreate2Address(bytes32 salt, bytes32 initCodeHash) external pure returns (address);</span>
 1406 |     | <span class='neutral'></span>
 1407 |     | <span class='neutral'>    /// Compute the address a contract will be deployed at for a given deployer address and nonce.</span>
 1408 |     | <span class='neutral'>    function computeCreateAddress(address deployer, uint256 nonce) external pure returns (address);</span>
 1409 |     | <span class='neutral'></span>
 1410 |     | <span class='neutral'>    /// Derives a private key from the name, labels the account with that name, and returns the wallet.</span>
 1411 |     | <span class='neutral'>    function createWallet(string calldata walletLabel) external returns (Wallet memory wallet);</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    /// Generates a wallet from the private key and returns the wallet.</span>
 1414 |     | <span class='neutral'>    function createWallet(uint256 privateKey) external returns (Wallet memory wallet);</span>
 1415 |     | <span class='neutral'></span>
 1416 |     | <span class='neutral'>    /// Generates a wallet from the private key, labels the account with that name, and returns the wallet.</span>
 1417 |     | <span class='neutral'>    function createWallet(uint256 privateKey, string calldata walletLabel) external returns (Wallet memory wallet);</span>
 1418 |     | <span class='neutral'></span>
 1419 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
 1420 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
 1421 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index) external pure returns (uint256 privateKey);</span>
 1422 |     | <span class='neutral'></span>
 1423 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path)</span>
 1424 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
 1425 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index)</span>
 1426 |     | <span class='neutral'>        external</span>
 1427 |     | <span class='neutral'>        pure</span>
 1428 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1429 |     | <span class='neutral'></span>
 1430 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
 1431 |     | <span class='neutral'>    /// at the derivation path `m/44&#39;/60&#39;/0&#39;/0/{index}`.</span>
 1432 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, uint32 index, string calldata language)</span>
 1433 |     | <span class='neutral'>        external</span>
 1434 |     | <span class='neutral'>        pure</span>
 1435 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    /// Derive a private key from a provided mnenomic string (or mnenomic file path) in the specified language</span>
 1438 |     | <span class='neutral'>    /// at `{derivationPath}{index}`.</span>
 1439 |     | <span class='neutral'>    function deriveKey(string calldata mnemonic, string calldata derivationPath, uint32 index, string calldata language)</span>
 1440 |     | <span class='neutral'>        external</span>
 1441 |     | <span class='neutral'>        pure</span>
 1442 |     | <span class='neutral'>        returns (uint256 privateKey);</span>
 1443 |     | <span class='neutral'></span>
 1444 |     | <span class='neutral'>    /// Returns ENS namehash for provided string.</span>
 1445 |     | <span class='neutral'>    function ensNamehash(string calldata name) external pure returns (bytes32);</span>
 1446 |     | <span class='neutral'></span>
 1447 |     | <span class='neutral'>    /// Gets the label for the specified address.</span>
 1448 |     | <span class='neutral'>    function getLabel(address account) external view returns (string memory currentLabel);</span>
 1449 |     | <span class='neutral'></span>
 1450 |     | <span class='neutral'>    /// Get a `Wallet`&#39;s nonce.</span>
 1451 |     | <span class='neutral'>    function getNonce(Wallet calldata wallet) external returns (uint64 nonce);</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    /// Labels an address in call traces.</span>
 1454 |     | <span class='neutral'>    function label(address account, string calldata newLabel) external;</span>
 1455 |     | <span class='neutral'></span>
 1456 |     | <span class='neutral'>    /// Returns a random `address`.</span>
 1457 |     | <span class='neutral'>    function randomAddress() external returns (address);</span>
 1458 |     | <span class='neutral'></span>
 1459 |     | <span class='neutral'>    /// Returns a random uint256 value.</span>
 1460 |     | <span class='neutral'>    function randomUint() external returns (uint256);</span>
 1461 |     | <span class='neutral'></span>
 1462 |     | <span class='neutral'>    /// Returns random uin256 value between the provided range (=min..=max).</span>
 1463 |     | <span class='neutral'>    function randomUint(uint256 min, uint256 max) external returns (uint256);</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    /// Adds a private key to the local forge wallet and returns the address.</span>
 1466 |     | <span class='neutral'>    function rememberKey(uint256 privateKey) external returns (address keyAddr);</span>
 1467 |     | <span class='neutral'></span>
 1468 |     | <span class='neutral'>    /// Signs data with a `Wallet`.</span>
 1469 |     | <span class='neutral'>    function sign(Wallet calldata wallet, bytes32 digest) external returns (uint8 v, bytes32 r, bytes32 s);</span>
 1470 |     | <span class='neutral'></span>
 1471 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64url string.</span>
 1472 |     | <span class='neutral'>    function toBase64URL(bytes calldata data) external pure returns (string memory);</span>
 1473 |     | <span class='neutral'></span>
 1474 |     | <span class='neutral'>    /// Encodes a `string` value to a base64url string.</span>
 1475 |     | <span class='neutral'>    function toBase64URL(string calldata data) external pure returns (string memory);</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    /// Encodes a `bytes` value to a base64 string.</span>
 1478 |     | <span class='neutral'>    function toBase64(bytes calldata data) external pure returns (string memory);</span>
 1479 |     | <span class='neutral'></span>
 1480 |     | <span class='neutral'>    /// Encodes a `string` value to a base64 string.</span>
 1481 |     | <span class='neutral'>    function toBase64(string calldata data) external pure returns (string memory);</span>
 1482 |     | <span class='neutral'>}</span>
 1483 |     | <span class='neutral'></span>
 1484 |     | <span class='neutral'>/// The `Vm` interface does allow manipulation of the EVM state. These are all intended to be used</span>
 1485 |     | <span class='neutral'>/// in tests, but it is not recommended to use these cheats in scripts.</span>
 1486 |     | <span class='neutral'>interface Vm is VmSafe {</span>
 1487 |     | <span class='neutral'>    // ======== EVM ========</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    /// Returns the identifier of the currently active fork. Reverts if no fork is currently active.</span>
 1490 |     | <span class='neutral'>    function activeFork() external view returns (uint256 forkId);</span>
 1491 |     | <span class='neutral'></span>
 1492 |     | <span class='neutral'>    /// In forking mode, explicitly grant the given address cheatcode access.</span>
 1493 |     | <span class='neutral'>    function allowCheatcodes(address account) external;</span>
 1494 |     | <span class='neutral'></span>
 1495 |     | <span class='neutral'>    /// Sets `block.blobbasefee`</span>
 1496 |     | <span class='neutral'>    function blobBaseFee(uint256 newBlobBaseFee) external;</span>
 1497 |     | <span class='neutral'></span>
 1498 |     | <span class='neutral'>    /// Sets the blobhashes in the transaction.</span>
 1499 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1500 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1501 |     | <span class='neutral'>    function blobhashes(bytes32[] calldata hashes) external;</span>
 1502 |     | <span class='neutral'></span>
 1503 |     | <span class='neutral'>    /// Sets `block.chainid`.</span>
 1504 |     | <span class='neutral'>    function chainId(uint256 newChainId) external;</span>
 1505 |     | <span class='neutral'></span>
 1506 |     | <span class='neutral'>    /// Clears all mocked calls.</span>
 1507 |     | <span class='neutral'>    function clearMockedCalls() external;</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    /// Sets `block.coinbase`.</span>
 1510 |     | <span class='neutral'>    function coinbase(address newCoinbase) external;</span>
 1511 |     | <span class='neutral'></span>
 1512 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and the _latest_ block and returns the identifier of the fork.</span>
 1513 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1514 |     | <span class='neutral'></span>
 1515 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1516 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1517 |     | <span class='neutral'></span>
 1518 |     | <span class='neutral'>    /// Creates a new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1519 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, and returns the identifier of the fork.</span>
 1520 |     | <span class='neutral'>    function createFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1521 |     | <span class='neutral'></span>
 1522 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and the latest block and returns the identifier of the fork.</span>
 1523 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias) external returns (uint256 forkId);</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    /// Creates and also selects a new fork with the given endpoint and block and returns the identifier of the fork.</span>
 1526 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, uint256 blockNumber) external returns (uint256 forkId);</span>
 1527 |     | <span class='neutral'></span>
 1528 |     | <span class='neutral'>    /// Creates and also selects new fork with the given endpoint and at the block the given transaction was mined in,</span>
 1529 |     | <span class='neutral'>    /// replays all transaction mined in the block before the transaction, returns the identifier of the fork.</span>
 1530 |     | <span class='neutral'>    function createSelectFork(string calldata urlOrAlias, bytes32 txHash) external returns (uint256 forkId);</span>
 1531 |     | <span class='neutral'></span>
 1532 |     | <span class='neutral'>    /// Sets an address&#39; balance.</span>
 1533 |     | <span class='neutral'>    function deal(address account, uint256 newBalance) external;</span>
 1534 |     | <span class='neutral'></span>
 1535 |     | <span class='neutral'>    /// Removes the snapshot with the given ID created by `snapshot`.</span>
 1536 |     | <span class='neutral'>    /// Takes the snapshot ID to delete.</span>
 1537 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully deleted.</span>
 1538 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1539 |     | <span class='neutral'>    function deleteSnapshot(uint256 snapshotId) external returns (bool success);</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    /// Removes _all_ snapshots previously created by `snapshot`.</span>
 1542 |     | <span class='neutral'>    function deleteSnapshots() external;</span>
 1543 |     | <span class='neutral'></span>
 1544 |     | <span class='neutral'>    /// Sets `block.difficulty`.</span>
 1545 |     | <span class='neutral'>    /// Not available on EVM versions from Paris onwards. Use `prevrandao` instead.</span>
 1546 |     | <span class='neutral'>    /// Reverts if used on unsupported EVM versions.</span>
 1547 |     | <span class='neutral'>    function difficulty(uint256 newDifficulty) external;</span>
 1548 |     | <span class='neutral'></span>
 1549 |     | <span class='neutral'>    /// Dump a genesis JSON file&#39;s `allocs` to disk.</span>
 1550 |     | <span class='neutral'>    function dumpState(string calldata pathToStateJson) external;</span>
 1551 |     | <span class='neutral'></span>
 1552 |     | <span class='neutral'>    /// Sets an address&#39; code.</span>
 1553 |     | <span class='neutral'>    function etch(address target, bytes calldata newRuntimeBytecode) external;</span>
 1554 |     | <span class='neutral'></span>
 1555 |     | <span class='neutral'>    /// Sets `block.basefee`.</span>
 1556 |     | <span class='neutral'>    function fee(uint256 newBasefee) external;</span>
 1557 |     | <span class='neutral'></span>
 1558 |     | <span class='neutral'>    /// Gets the blockhashes from the current transaction.</span>
 1559 |     | <span class='neutral'>    /// Not available on EVM versions before Cancun.</span>
 1560 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1561 |     | <span class='neutral'>    function getBlobhashes() external view returns (bytes32[] memory hashes);</span>
 1562 |     | <span class='neutral'></span>
 1563 |     | <span class='neutral'>    /// Returns true if the account is marked as persistent.</span>
 1564 |     | <span class='neutral'>    function isPersistent(address account) external view returns (bool persistent);</span>
 1565 |     | <span class='neutral'></span>
 1566 |     | <span class='neutral'>    /// Load a genesis JSON file&#39;s `allocs` into the in-memory revm state.</span>
 1567 |     | <span class='neutral'>    function loadAllocs(string calldata pathToAllocsJson) external;</span>
 1568 |     | <span class='neutral'></span>
 1569 |     | <span class='neutral'>    /// Marks that the account(s) should use persistent storage across fork swaps in a multifork setup</span>
 1570 |     | <span class='neutral'>    /// Meaning, changes made to the state of this account will be kept when switching forks.</span>
 1571 |     | <span class='neutral'>    function makePersistent(address account) external;</span>
 1572 |     | <span class='neutral'></span>
 1573 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1574 |     | <span class='neutral'>    function makePersistent(address account0, address account1) external;</span>
 1575 |     | <span class='neutral'></span>
 1576 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1577 |     | <span class='neutral'>    function makePersistent(address account0, address account1, address account2) external;</span>
 1578 |     | <span class='neutral'></span>
 1579 |     | <span class='neutral'>    /// See `makePersistent(address)`.</span>
 1580 |     | <span class='neutral'>    function makePersistent(address[] calldata accounts) external;</span>
 1581 |     | <span class='neutral'></span>
 1582 |     | <span class='neutral'>    /// Reverts a call to an address with specified revert data.</span>
 1583 |     | <span class='neutral'>    function mockCallRevert(address callee, bytes calldata data, bytes calldata revertData) external;</span>
 1584 |     | <span class='neutral'></span>
 1585 |     | <span class='neutral'>    /// Reverts a call to an address with a specific `msg.value`, with specified revert data.</span>
 1586 |     | <span class='neutral'>    function mockCallRevert(address callee, uint256 msgValue, bytes calldata data, bytes calldata revertData)</span>
 1587 |     | <span class='neutral'>        external;</span>
 1588 |     | <span class='neutral'></span>
 1589 |     | <span class='neutral'>    /// Mocks a call to an address, returning specified data.</span>
 1590 |     | <span class='neutral'>    /// Calldata can either be strict or a partial match, e.g. if you only</span>
 1591 |     | <span class='neutral'>    /// pass a Solidity selector to the expected calldata, then the entire Solidity</span>
 1592 |     | <span class='neutral'>    /// function will be mocked.</span>
 1593 |     | <span class='neutral'>    function mockCall(address callee, bytes calldata data, bytes calldata returnData) external;</span>
 1594 |     | <span class='neutral'></span>
 1595 |     | <span class='neutral'>    /// Mocks a call to an address with a specific `msg.value`, returning specified data.</span>
 1596 |     | <span class='neutral'>    /// Calldata match takes precedence over `msg.value` in case of ambiguity.</span>
 1597 |     | <span class='neutral'>    function mockCall(address callee, uint256 msgValue, bytes calldata data, bytes calldata returnData) external;</span>
 1598 |     | <span class='neutral'></span>
 1599 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address.</span>
 1600 |     | <span class='neutral'>    function prank(address msgSender) external;</span>
 1601 |     | <span class='neutral'></span>
 1602 |     | <span class='neutral'>    /// Sets the *next* call&#39;s `msg.sender` to be the input address, and the `tx.origin` to be the second input.</span>
 1603 |     | <span class='neutral'>    function prank(address msgSender, address txOrigin) external;</span>
 1604 |     | <span class='neutral'></span>
 1605 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1606 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1607 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1608 |     | <span class='neutral'>    function prevrandao(bytes32 newPrevrandao) external;</span>
 1609 |     | <span class='neutral'></span>
 1610 |     | <span class='neutral'>    /// Sets `block.prevrandao`.</span>
 1611 |     | <span class='neutral'>    /// Not available on EVM versions before Paris. Use `difficulty` instead.</span>
 1612 |     | <span class='neutral'>    /// If used on unsupported EVM versions it will revert.</span>
 1613 |     | <span class='neutral'>    function prevrandao(uint256 newPrevrandao) external;</span>
 1614 |     | <span class='neutral'></span>
 1615 |     | <span class='neutral'>    /// Reads the current `msg.sender` and `tx.origin` from state and reports if there is any active caller modification.</span>
 1616 |     | <span class='neutral'>    function readCallers() external returns (CallerMode callerMode, address msgSender, address txOrigin);</span>
 1617 |     | <span class='neutral'></span>
 1618 |     | <span class='neutral'>    /// Resets the nonce of an account to 0 for EOAs and 1 for contract accounts.</span>
 1619 |     | <span class='neutral'>    function resetNonce(address account) external;</span>
 1620 |     | <span class='neutral'></span>
 1621 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot</span>
 1622 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1623 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted.</span>
 1624 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1625 |     | <span class='neutral'>    /// **Note:** This does not automatically delete the snapshot. To delete the snapshot use `deleteSnapshot`.</span>
 1626 |     | <span class='neutral'>    function revertTo(uint256 snapshotId) external returns (bool success);</span>
 1627 |     | <span class='neutral'></span>
 1628 |     | <span class='neutral'>    /// Revert the state of the EVM to a previous snapshot and automatically deletes the snapshots</span>
 1629 |     | <span class='neutral'>    /// Takes the snapshot ID to revert to.</span>
 1630 |     | <span class='neutral'>    /// Returns `true` if the snapshot was successfully reverted and deleted.</span>
 1631 |     | <span class='neutral'>    /// Returns `false` if the snapshot does not exist.</span>
 1632 |     | <span class='neutral'>    function revertToAndDelete(uint256 snapshotId) external returns (bool success);</span>
 1633 |     | <span class='neutral'></span>
 1634 |     | <span class='neutral'>    /// Revokes persistent status from the address, previously added via `makePersistent`.</span>
 1635 |     | <span class='neutral'>    function revokePersistent(address account) external;</span>
 1636 |     | <span class='neutral'></span>
 1637 |     | <span class='neutral'>    /// See `revokePersistent(address)`.</span>
 1638 |     | <span class='neutral'>    function revokePersistent(address[] calldata accounts) external;</span>
 1639 |     | <span class='neutral'></span>
 1640 |     | <span class='neutral'>    /// Sets `block.height`.</span>
 1641 |     | <span class='neutral'>    function roll(uint256 newHeight) external;</span>
 1642 |     | <span class='neutral'></span>
 1643 |     | <span class='neutral'>    /// Updates the currently active fork to given block number</span>
 1644 |     | <span class='neutral'>    /// This is similar to `roll` but for the currently active fork.</span>
 1645 |     | <span class='neutral'>    function rollFork(uint256 blockNumber) external;</span>
 1646 |     | <span class='neutral'></span>
 1647 |     | <span class='neutral'>    /// Updates the currently active fork to given transaction. This will `rollFork` with the number</span>
 1648 |     | <span class='neutral'>    /// of the block the transaction was mined in and replays all transaction mined before it in the block.</span>
 1649 |     | <span class='neutral'>    function rollFork(bytes32 txHash) external;</span>
 1650 |     | <span class='neutral'></span>
 1651 |     | <span class='neutral'>    /// Updates the given fork to given block number.</span>
 1652 |     | <span class='neutral'>    function rollFork(uint256 forkId, uint256 blockNumber) external;</span>
 1653 |     | <span class='neutral'></span>
 1654 |     | <span class='neutral'>    /// Updates the given fork to block number of the given transaction and replays all transaction mined before it in the block.</span>
 1655 |     | <span class='neutral'>    function rollFork(uint256 forkId, bytes32 txHash) external;</span>
 1656 |     | <span class='neutral'></span>
 1657 |     | <span class='neutral'>    /// Takes a fork identifier created by `createFork` and sets the corresponding forked state as active.</span>
 1658 |     | <span class='neutral'>    function selectFork(uint256 forkId) external;</span>
 1659 |     | <span class='neutral'></span>
 1660 |     | <span class='neutral'>    /// Sets the nonce of an account. Must be higher than the current nonce of the account.</span>
 1661 |     | <span class='neutral'>    function setNonce(address account, uint64 newNonce) external;</span>
 1662 |     | <span class='neutral'></span>
 1663 |     | <span class='neutral'>    /// Sets the nonce of an account to an arbitrary value.</span>
 1664 |     | <span class='neutral'>    function setNonceUnsafe(address account, uint64 newNonce) external;</span>
 1665 |     | <span class='neutral'></span>
 1666 |     | <span class='neutral'>    /// Snapshot the current state of the evm.</span>
 1667 |     | <span class='neutral'>    /// Returns the ID of the snapshot that was created.</span>
 1668 |     | <span class='neutral'>    /// To revert a snapshot use `revertTo`.</span>
 1669 |     | <span class='neutral'>    function snapshot() external returns (uint256 snapshotId);</span>
 1670 |     | <span class='neutral'></span>
 1671 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called.</span>
 1672 |     | <span class='neutral'>    function startPrank(address msgSender) external;</span>
 1673 |     | <span class='neutral'></span>
 1674 |     | <span class='neutral'>    /// Sets all subsequent calls&#39; `msg.sender` to be the input address until `stopPrank` is called, and the `tx.origin` to be the second input.</span>
 1675 |     | <span class='neutral'>    function startPrank(address msgSender, address txOrigin) external;</span>
 1676 |     | <span class='neutral'></span>
 1677 |     | <span class='neutral'>    /// Resets subsequent calls&#39; `msg.sender` to be `address(this)`.</span>
 1678 |     | <span class='neutral'>    function stopPrank() external;</span>
 1679 |     | <span class='neutral'></span>
 1680 |     | <span class='neutral'>    /// Stores a value to an address&#39; storage slot.</span>
 1681 |     | <span class='neutral'>    function store(address target, bytes32 slot, bytes32 value) external;</span>
 1682 |     | <span class='neutral'></span>
 1683 |     | <span class='neutral'>    /// Fetches the given transaction from the active fork and executes it on the current state.</span>
 1684 |     | <span class='neutral'>    function transact(bytes32 txHash) external;</span>
 1685 |     | <span class='neutral'></span>
 1686 |     | <span class='neutral'>    /// Fetches the given transaction from the given fork and executes it on the current state.</span>
 1687 |     | <span class='neutral'>    function transact(uint256 forkId, bytes32 txHash) external;</span>
 1688 |     | <span class='neutral'></span>
 1689 |     | <span class='neutral'>    /// Sets `tx.gasprice`.</span>
 1690 |     | <span class='neutral'>    function txGasPrice(uint256 newGasPrice) external;</span>
 1691 |     | <span class='neutral'></span>
 1692 |     | <span class='neutral'>    /// Sets `block.timestamp`.</span>
 1693 |     | <span class='neutral'>    function warp(uint256 newTimestamp) external;</span>
 1694 |     | <span class='neutral'></span>
 1695 |     | <span class='neutral'>    // ======== Testing ========</span>
 1696 |     | <span class='neutral'></span>
 1697 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 1698 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data) external;</span>
 1699 |     | <span class='neutral'></span>
 1700 |     | <span class='neutral'>    /// Expect given number of calls to an address with the specified `msg.value` and calldata, and a *minimum* amount of gas.</span>
 1701 |     | <span class='neutral'>    function expectCallMinGas(address callee, uint256 msgValue, uint64 minGas, bytes calldata data, uint64 count)</span>
 1702 |     | <span class='neutral'>        external;</span>
 1703 |     | <span class='neutral'></span>
 1704 |     | <span class='neutral'>    /// Expects a call to an address with the specified calldata.</span>
 1705 |     | <span class='neutral'>    /// Calldata can either be a strict or a partial match.</span>
 1706 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data) external;</span>
 1707 |     | <span class='neutral'></span>
 1708 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified calldata.</span>
 1709 |     | <span class='neutral'>    function expectCall(address callee, bytes calldata data, uint64 count) external;</span>
 1710 |     | <span class='neutral'></span>
 1711 |     | <span class='neutral'>    /// Expects a call to an address with the specified `msg.value` and calldata.</span>
 1712 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data) external;</span>
 1713 |     | <span class='neutral'></span>
 1714 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value` and calldata.</span>
 1715 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, bytes calldata data, uint64 count) external;</span>
 1716 |     | <span class='neutral'></span>
 1717 |     | <span class='neutral'>    /// Expect a call to an address with the specified `msg.value`, gas, and calldata.</span>
 1718 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data) external;</span>
 1719 |     | <span class='neutral'></span>
 1720 |     | <span class='neutral'>    /// Expects given number of calls to an address with the specified `msg.value`, gas, and calldata.</span>
 1721 |     | <span class='neutral'>    function expectCall(address callee, uint256 msgValue, uint64 gas, bytes calldata data, uint64 count) external;</span>
 1722 |     | <span class='neutral'></span>
 1723 |     | <span class='neutral'>    /// Prepare an expected log with (bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData.).</span>
 1724 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 1725 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data (as specified by the booleans).</span>
 1726 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData) external;</span>
 1727 |     | <span class='neutral'></span>
 1728 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 1729 |     | <span class='neutral'>    function expectEmit(bool checkTopic1, bool checkTopic2, bool checkTopic3, bool checkData, address emitter)</span>
 1730 |     | <span class='neutral'>        external;</span>
 1731 |     | <span class='neutral'></span>
 1732 |     | <span class='neutral'>    /// Prepare an expected log with all topic and data checks enabled.</span>
 1733 |     | <span class='neutral'>    /// Call this function, then emit an event, then call a function. Internally after the call, we check if</span>
 1734 |     | <span class='neutral'>    /// logs were emitted in the expected order with the expected topics and data.</span>
 1735 |     | <span class='neutral'>    function expectEmit() external;</span>
 1736 |     | <span class='neutral'></span>
 1737 |     | <span class='neutral'>    /// Same as the previous method, but also checks supplied address against emitting contract.</span>
 1738 |     | <span class='neutral'>    function expectEmit(address emitter) external;</span>
 1739 |     | <span class='neutral'></span>
 1740 |     | <span class='neutral'>    /// Expects an error on next call with any revert data.</span>
 1741 |     | <span class='neutral'>    function expectRevert() external;</span>
 1742 |     | <span class='neutral'></span>
 1743 |     | <span class='neutral'>    /// Expects an error on next call that starts with the revert data.</span>
 1744 |     | <span class='neutral'>    function expectRevert(bytes4 revertData) external;</span>
 1745 |     | <span class='neutral'></span>
 1746 |     | <span class='neutral'>    /// Expects an error on next call that exactly matches the revert data.</span>
 1747 |     | <span class='neutral'>    function expectRevert(bytes calldata revertData) external;</span>
 1748 |     | <span class='neutral'></span>
 1749 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the current subcontext. If any other</span>
 1750 |     | <span class='neutral'>    /// memory is written to, the test will fail. Can be called multiple times to add more ranges to the set.</span>
 1751 |     | <span class='neutral'>    function expectSafeMemory(uint64 min, uint64 max) external;</span>
 1752 |     | <span class='neutral'></span>
 1753 |     | <span class='neutral'>    /// Only allows memory writes to offsets [0x00, 0x60)  [min, max) in the next created subcontext.</span>
 1754 |     | <span class='neutral'>    /// If any other memory is written to, the test will fail. Can be called multiple times to add more ranges</span>
 1755 |     | <span class='neutral'>    /// to the set.</span>
 1756 |     | <span class='neutral'>    function expectSafeMemoryCall(uint64 min, uint64 max) external;</span>
 1757 |     | <span class='neutral'></span>
 1758 |     | <span class='neutral'>    /// Marks a test as skipped. Must be called at the top of the test.</span>
 1759 |     | <span class='neutral'>    function skip(bool skipTest) external;</span>
 1760 |     | <span class='neutral'></span>
 1761 |     | <span class='neutral'>    /// Stops all safe memory expectation in the current subcontext.</span>
 1762 |     | <span class='neutral'>    function stopExpectSafeMemory() external;</span>
 1763 |     | <span class='neutral'>}</span>
 1764 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/console.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='unexecuted'>library console {</span>
    5 |     | <span class='neutral'>    address constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>    function _castLogPayloadViewToPure(</span>
    8 |     | <span class='neutral'>        function(bytes memory) internal view fnIn</span>
    9 |     | <span class='neutral'>    ) internal pure returns (function(bytes memory) internal pure fnOut) {</span>
   10 |     | <span class='neutral'>        assembly {</span>
   11 |     | <span class='neutral'>            fnOut := fnIn</span>
   12 |     | <span class='neutral'>        }</span>
   13 |     | <span class='neutral'>    }</span>
   14 |     | <span class='neutral'></span>
   15 |     | <span class='neutral'>    function _sendLogPayload(bytes memory payload) internal pure {</span>
   16 |     | <span class='neutral'>        _castLogPayloadViewToPure(_sendLogPayloadView)(payload);</span>
   17 |     | <span class='neutral'>    }</span>
   18 |     | <span class='neutral'></span>
   19 |     | <span class='neutral'>    function _sendLogPayloadView(bytes memory payload) private view {</span>
   20 |     | <span class='neutral'>        uint256 payloadLength = payload.length;</span>
   21 |     | <span class='neutral'>        address consoleAddress = CONSOLE_ADDRESS;</span>
   22 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
   23 |     | <span class='neutral'>        assembly {</span>
   24 |     | <span class='neutral'>            let payloadStart := add(payload, 32)</span>
   25 |     | <span class='neutral'>            let r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)</span>
   26 |     | <span class='neutral'>        }</span>
   27 |     | <span class='neutral'>    }</span>
   28 |     | <span class='neutral'></span>
   29 |     | <span class='neutral'>    function log() internal pure {</span>
   30 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log()&quot;));</span>
   31 |     | <span class='neutral'>    }</span>
   32 |     | <span class='neutral'></span>
   33 |     | <span class='neutral'>    function logInt(int p0) internal pure {</span>
   34 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(int)&quot;, p0));</span>
   35 |     | <span class='neutral'>    }</span>
   36 |     | <span class='neutral'></span>
   37 |     | <span class='neutral'>    function logUint(uint p0) internal pure {</span>
   38 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
   39 |     | <span class='neutral'>    }</span>
   40 |     | <span class='neutral'></span>
   41 |     | <span class='neutral'>    function logString(string memory p0) internal pure {</span>
   42 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    function logBool(bool p0) internal pure {</span>
   46 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
   47 |     | <span class='neutral'>    }</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    function logAddress(address p0) internal pure {</span>
   50 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
   51 |     | <span class='neutral'>    }</span>
   52 |     | <span class='neutral'></span>
   53 |     | <span class='neutral'>    function logBytes(bytes memory p0) internal pure {</span>
   54 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes)&quot;, p0));</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    function logBytes1(bytes1 p0) internal pure {</span>
   58 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes1)&quot;, p0));</span>
   59 |     | <span class='neutral'>    }</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    function logBytes2(bytes2 p0) internal pure {</span>
   62 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes2)&quot;, p0));</span>
   63 |     | <span class='neutral'>    }</span>
   64 |     | <span class='neutral'></span>
   65 |     | <span class='neutral'>    function logBytes3(bytes3 p0) internal pure {</span>
   66 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes3)&quot;, p0));</span>
   67 |     | <span class='neutral'>    }</span>
   68 |     | <span class='neutral'></span>
   69 |     | <span class='neutral'>    function logBytes4(bytes4 p0) internal pure {</span>
   70 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes4)&quot;, p0));</span>
   71 |     | <span class='neutral'>    }</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    function logBytes5(bytes5 p0) internal pure {</span>
   74 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes5)&quot;, p0));</span>
   75 |     | <span class='neutral'>    }</span>
   76 |     | <span class='neutral'></span>
   77 |     | <span class='neutral'>    function logBytes6(bytes6 p0) internal pure {</span>
   78 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes6)&quot;, p0));</span>
   79 |     | <span class='neutral'>    }</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    function logBytes7(bytes7 p0) internal pure {</span>
   82 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes7)&quot;, p0));</span>
   83 |     | <span class='neutral'>    }</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    function logBytes8(bytes8 p0) internal pure {</span>
   86 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes8)&quot;, p0));</span>
   87 |     | <span class='neutral'>    }</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    function logBytes9(bytes9 p0) internal pure {</span>
   90 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes9)&quot;, p0));</span>
   91 |     | <span class='neutral'>    }</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    function logBytes10(bytes10 p0) internal pure {</span>
   94 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes10)&quot;, p0));</span>
   95 |     | <span class='neutral'>    }</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    function logBytes11(bytes11 p0) internal pure {</span>
   98 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes11)&quot;, p0));</span>
   99 |     | <span class='neutral'>    }</span>
  100 |     | <span class='neutral'></span>
  101 |     | <span class='neutral'>    function logBytes12(bytes12 p0) internal pure {</span>
  102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes12)&quot;, p0));</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    function logBytes13(bytes13 p0) internal pure {</span>
  106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes13)&quot;, p0));</span>
  107 |     | <span class='neutral'>    }</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    function logBytes14(bytes14 p0) internal pure {</span>
  110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes14)&quot;, p0));</span>
  111 |     | <span class='neutral'>    }</span>
  112 |     | <span class='neutral'></span>
  113 |     | <span class='neutral'>    function logBytes15(bytes15 p0) internal pure {</span>
  114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes15)&quot;, p0));</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    function logBytes16(bytes16 p0) internal pure {</span>
  118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes16)&quot;, p0));</span>
  119 |     | <span class='neutral'>    }</span>
  120 |     | <span class='neutral'></span>
  121 |     | <span class='neutral'>    function logBytes17(bytes17 p0) internal pure {</span>
  122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes17)&quot;, p0));</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    function logBytes18(bytes18 p0) internal pure {</span>
  126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes18)&quot;, p0));</span>
  127 |     | <span class='neutral'>    }</span>
  128 |     | <span class='neutral'></span>
  129 |     | <span class='neutral'>    function logBytes19(bytes19 p0) internal pure {</span>
  130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes19)&quot;, p0));</span>
  131 |     | <span class='neutral'>    }</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    function logBytes20(bytes20 p0) internal pure {</span>
  134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes20)&quot;, p0));</span>
  135 |     | <span class='neutral'>    }</span>
  136 |     | <span class='neutral'></span>
  137 |     | <span class='neutral'>    function logBytes21(bytes21 p0) internal pure {</span>
  138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes21)&quot;, p0));</span>
  139 |     | <span class='neutral'>    }</span>
  140 |     | <span class='neutral'></span>
  141 |     | <span class='neutral'>    function logBytes22(bytes22 p0) internal pure {</span>
  142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes22)&quot;, p0));</span>
  143 |     | <span class='neutral'>    }</span>
  144 |     | <span class='neutral'></span>
  145 |     | <span class='neutral'>    function logBytes23(bytes23 p0) internal pure {</span>
  146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes23)&quot;, p0));</span>
  147 |     | <span class='neutral'>    }</span>
  148 |     | <span class='neutral'></span>
  149 |     | <span class='neutral'>    function logBytes24(bytes24 p0) internal pure {</span>
  150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes24)&quot;, p0));</span>
  151 |     | <span class='neutral'>    }</span>
  152 |     | <span class='neutral'></span>
  153 |     | <span class='neutral'>    function logBytes25(bytes25 p0) internal pure {</span>
  154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes25)&quot;, p0));</span>
  155 |     | <span class='neutral'>    }</span>
  156 |     | <span class='neutral'></span>
  157 |     | <span class='neutral'>    function logBytes26(bytes26 p0) internal pure {</span>
  158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes26)&quot;, p0));</span>
  159 |     | <span class='neutral'>    }</span>
  160 |     | <span class='neutral'></span>
  161 |     | <span class='neutral'>    function logBytes27(bytes27 p0) internal pure {</span>
  162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes27)&quot;, p0));</span>
  163 |     | <span class='neutral'>    }</span>
  164 |     | <span class='neutral'></span>
  165 |     | <span class='neutral'>    function logBytes28(bytes28 p0) internal pure {</span>
  166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes28)&quot;, p0));</span>
  167 |     | <span class='neutral'>    }</span>
  168 |     | <span class='neutral'></span>
  169 |     | <span class='neutral'>    function logBytes29(bytes29 p0) internal pure {</span>
  170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes29)&quot;, p0));</span>
  171 |     | <span class='neutral'>    }</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>    function logBytes30(bytes30 p0) internal pure {</span>
  174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes30)&quot;, p0));</span>
  175 |     | <span class='neutral'>    }</span>
  176 |     | <span class='neutral'></span>
  177 |     | <span class='neutral'>    function logBytes31(bytes31 p0) internal pure {</span>
  178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes31)&quot;, p0));</span>
  179 |     | <span class='neutral'>    }</span>
  180 |     | <span class='neutral'></span>
  181 |     | <span class='neutral'>    function logBytes32(bytes32 p0) internal pure {</span>
  182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bytes32)&quot;, p0));</span>
  183 |     | <span class='neutral'>    }</span>
  184 |     | <span class='neutral'></span>
  185 |     | <span class='neutral'>    function log(uint p0) internal pure {</span>
  186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint)&quot;, p0));</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    function log(string memory p0) internal pure {</span>
  190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string)&quot;, p0));</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
  194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool)&quot;, p0));</span>
  195 |     | <span class='neutral'>    }</span>
  196 |     | <span class='neutral'></span>
  197 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
  198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address)&quot;, p0));</span>
  199 |     | <span class='neutral'>    }</span>
  200 |     | <span class='neutral'></span>
  201 |     | <span class='neutral'>    function log(uint p0, uint p1) internal pure {</span>
  202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint)&quot;, p0, p1));</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    function log(uint p0, string memory p1) internal pure {</span>
  206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string)&quot;, p0, p1));</span>
  207 |     | <span class='neutral'>    }</span>
  208 |     | <span class='neutral'></span>
  209 |     | <span class='neutral'>    function log(uint p0, bool p1) internal pure {</span>
  210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool)&quot;, p0, p1));</span>
  211 |     | <span class='neutral'>    }</span>
  212 |     | <span class='neutral'></span>
  213 |     | <span class='neutral'>    function log(uint p0, address p1) internal pure {</span>
  214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address)&quot;, p0, p1));</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    function log(string memory p0, uint p1) internal pure {</span>
  218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint)&quot;, p0, p1));</span>
  219 |     | <span class='neutral'>    }</span>
  220 |     | <span class='neutral'></span>
  221 |     | <span class='neutral'>    function log(string memory p0, string memory p1) internal pure {</span>
  222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string)&quot;, p0, p1));</span>
  223 |     | <span class='neutral'>    }</span>
  224 |     | <span class='neutral'></span>
  225 |     | <span class='neutral'>    function log(string memory p0, bool p1) internal pure {</span>
  226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool)&quot;, p0, p1));</span>
  227 |     | <span class='neutral'>    }</span>
  228 |     | <span class='neutral'></span>
  229 |     | <span class='neutral'>    function log(string memory p0, address p1) internal pure {</span>
  230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address)&quot;, p0, p1));</span>
  231 |     | <span class='neutral'>    }</span>
  232 |     | <span class='neutral'></span>
  233 |     | <span class='neutral'>    function log(bool p0, uint p1) internal pure {</span>
  234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint)&quot;, p0, p1));</span>
  235 |     | <span class='neutral'>    }</span>
  236 |     | <span class='neutral'></span>
  237 |     | <span class='neutral'>    function log(bool p0, string memory p1) internal pure {</span>
  238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string)&quot;, p0, p1));</span>
  239 |     | <span class='neutral'>    }</span>
  240 |     | <span class='neutral'></span>
  241 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
  242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool)&quot;, p0, p1));</span>
  243 |     | <span class='neutral'>    }</span>
  244 |     | <span class='neutral'></span>
  245 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
  246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address)&quot;, p0, p1));</span>
  247 |     | <span class='neutral'>    }</span>
  248 |     | <span class='neutral'></span>
  249 |     | <span class='neutral'>    function log(address p0, uint p1) internal pure {</span>
  250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint)&quot;, p0, p1));</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    function log(address p0, string memory p1) internal pure {</span>
  254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string)&quot;, p0, p1));</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
  258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool)&quot;, p0, p1));</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
  262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address)&quot;, p0, p1));</span>
  263 |     | <span class='neutral'>    }</span>
  264 |     | <span class='neutral'></span>
  265 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2) internal pure {</span>
  266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint)&quot;, p0, p1, p2));</span>
  267 |     | <span class='neutral'>    }</span>
  268 |     | <span class='neutral'></span>
  269 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2) internal pure {</span>
  270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string)&quot;, p0, p1, p2));</span>
  271 |     | <span class='neutral'>    }</span>
  272 |     | <span class='neutral'></span>
  273 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2) internal pure {</span>
  274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool)&quot;, p0, p1, p2));</span>
  275 |     | <span class='neutral'>    }</span>
  276 |     | <span class='neutral'></span>
  277 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2) internal pure {</span>
  278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address)&quot;, p0, p1, p2));</span>
  279 |     | <span class='neutral'>    }</span>
  280 |     | <span class='neutral'></span>
  281 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2) internal pure {</span>
  282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint)&quot;, p0, p1, p2));</span>
  283 |     | <span class='neutral'>    }</span>
  284 |     | <span class='neutral'></span>
  285 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2) internal pure {</span>
  286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string)&quot;, p0, p1, p2));</span>
  287 |     | <span class='neutral'>    }</span>
  288 |     | <span class='neutral'></span>
  289 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2) internal pure {</span>
  290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool)&quot;, p0, p1, p2));</span>
  291 |     | <span class='neutral'>    }</span>
  292 |     | <span class='neutral'></span>
  293 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2) internal pure {</span>
  294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address)&quot;, p0, p1, p2));</span>
  295 |     | <span class='neutral'>    }</span>
  296 |     | <span class='neutral'></span>
  297 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2) internal pure {</span>
  298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint)&quot;, p0, p1, p2));</span>
  299 |     | <span class='neutral'>    }</span>
  300 |     | <span class='neutral'></span>
  301 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2) internal pure {</span>
  302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string)&quot;, p0, p1, p2));</span>
  303 |     | <span class='neutral'>    }</span>
  304 |     | <span class='neutral'></span>
  305 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2) internal pure {</span>
  306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool)&quot;, p0, p1, p2));</span>
  307 |     | <span class='neutral'>    }</span>
  308 |     | <span class='neutral'></span>
  309 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2) internal pure {</span>
  310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address)&quot;, p0, p1, p2));</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2) internal pure {</span>
  314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint)&quot;, p0, p1, p2));</span>
  315 |     | <span class='neutral'>    }</span>
  316 |     | <span class='neutral'></span>
  317 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2) internal pure {</span>
  318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string)&quot;, p0, p1, p2));</span>
  319 |     | <span class='neutral'>    }</span>
  320 |     | <span class='neutral'></span>
  321 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2) internal pure {</span>
  322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool)&quot;, p0, p1, p2));</span>
  323 |     | <span class='neutral'>    }</span>
  324 |     | <span class='neutral'></span>
  325 |     | <span class='neutral'>    function log(uint p0, address p1, address p2) internal pure {</span>
  326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address)&quot;, p0, p1, p2));</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2) internal pure {</span>
  330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint)&quot;, p0, p1, p2));</span>
  331 |     | <span class='neutral'>    }</span>
  332 |     | <span class='neutral'></span>
  333 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2) internal pure {</span>
  334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string)&quot;, p0, p1, p2));</span>
  335 |     | <span class='neutral'>    }</span>
  336 |     | <span class='neutral'></span>
  337 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2) internal pure {</span>
  338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool)&quot;, p0, p1, p2));</span>
  339 |     | <span class='neutral'>    }</span>
  340 |     | <span class='neutral'></span>
  341 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2) internal pure {</span>
  342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address)&quot;, p0, p1, p2));</span>
  343 |     | <span class='neutral'>    }</span>
  344 |     | <span class='neutral'></span>
  345 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2) internal pure {</span>
  346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint)&quot;, p0, p1, p2));</span>
  347 |     | <span class='neutral'>    }</span>
  348 |     | <span class='neutral'></span>
  349 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2) internal pure {</span>
  350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string)&quot;, p0, p1, p2));</span>
  351 |     | <span class='neutral'>    }</span>
  352 |     | <span class='neutral'></span>
  353 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2) internal pure {</span>
  354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool)&quot;, p0, p1, p2));</span>
  355 |     | <span class='neutral'>    }</span>
  356 |     | <span class='neutral'></span>
  357 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2) internal pure {</span>
  358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address)&quot;, p0, p1, p2));</span>
  359 |     | <span class='neutral'>    }</span>
  360 |     | <span class='neutral'></span>
  361 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2) internal pure {</span>
  362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint)&quot;, p0, p1, p2));</span>
  363 |     | <span class='neutral'>    }</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2) internal pure {</span>
  366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string)&quot;, p0, p1, p2));</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2) internal pure {</span>
  370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool)&quot;, p0, p1, p2));</span>
  371 |     | <span class='neutral'>    }</span>
  372 |     | <span class='neutral'></span>
  373 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2) internal pure {</span>
  374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address)&quot;, p0, p1, p2));</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2) internal pure {</span>
  378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint)&quot;, p0, p1, p2));</span>
  379 |     | <span class='neutral'>    }</span>
  380 |     | <span class='neutral'></span>
  381 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2) internal pure {</span>
  382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string)&quot;, p0, p1, p2));</span>
  383 |     | <span class='neutral'>    }</span>
  384 |     | <span class='neutral'></span>
  385 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2) internal pure {</span>
  386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool)&quot;, p0, p1, p2));</span>
  387 |     | <span class='neutral'>    }</span>
  388 |     | <span class='neutral'></span>
  389 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2) internal pure {</span>
  390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address)&quot;, p0, p1, p2));</span>
  391 |     | <span class='neutral'>    }</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2) internal pure {</span>
  394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint)&quot;, p0, p1, p2));</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2) internal pure {</span>
  398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string)&quot;, p0, p1, p2));</span>
  399 |     | <span class='neutral'>    }</span>
  400 |     | <span class='neutral'></span>
  401 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2) internal pure {</span>
  402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool)&quot;, p0, p1, p2));</span>
  403 |     | <span class='neutral'>    }</span>
  404 |     | <span class='neutral'></span>
  405 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2) internal pure {</span>
  406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address)&quot;, p0, p1, p2));</span>
  407 |     | <span class='neutral'>    }</span>
  408 |     | <span class='neutral'></span>
  409 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2) internal pure {</span>
  410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint)&quot;, p0, p1, p2));</span>
  411 |     | <span class='neutral'>    }</span>
  412 |     | <span class='neutral'></span>
  413 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2) internal pure {</span>
  414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string)&quot;, p0, p1, p2));</span>
  415 |     | <span class='neutral'>    }</span>
  416 |     | <span class='neutral'></span>
  417 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2) internal pure {</span>
  418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool)&quot;, p0, p1, p2));</span>
  419 |     | <span class='neutral'>    }</span>
  420 |     | <span class='neutral'></span>
  421 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2) internal pure {</span>
  422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address)&quot;, p0, p1, p2));</span>
  423 |     | <span class='neutral'>    }</span>
  424 |     | <span class='neutral'></span>
  425 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2) internal pure {</span>
  426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint)&quot;, p0, p1, p2));</span>
  427 |     | <span class='neutral'>    }</span>
  428 |     | <span class='neutral'></span>
  429 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2) internal pure {</span>
  430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string)&quot;, p0, p1, p2));</span>
  431 |     | <span class='neutral'>    }</span>
  432 |     | <span class='neutral'></span>
  433 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool)&quot;, p0, p1, p2));</span>
  435 |     | <span class='neutral'>    }</span>
  436 |     | <span class='neutral'></span>
  437 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address)&quot;, p0, p1, p2));</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2) internal pure {</span>
  442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint)&quot;, p0, p1, p2));</span>
  443 |     | <span class='neutral'>    }</span>
  444 |     | <span class='neutral'></span>
  445 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2) internal pure {</span>
  446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string)&quot;, p0, p1, p2));</span>
  447 |     | <span class='neutral'>    }</span>
  448 |     | <span class='neutral'></span>
  449 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool)&quot;, p0, p1, p2));</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address)&quot;, p0, p1, p2));</span>
  455 |     | <span class='neutral'>    }</span>
  456 |     | <span class='neutral'></span>
  457 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2) internal pure {</span>
  458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint)&quot;, p0, p1, p2));</span>
  459 |     | <span class='neutral'>    }</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2) internal pure {</span>
  462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string)&quot;, p0, p1, p2));</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2) internal pure {</span>
  466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool)&quot;, p0, p1, p2));</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    function log(address p0, uint p1, address p2) internal pure {</span>
  470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address)&quot;, p0, p1, p2));</span>
  471 |     | <span class='neutral'>    }</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2) internal pure {</span>
  474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint)&quot;, p0, p1, p2));</span>
  475 |     | <span class='neutral'>    }</span>
  476 |     | <span class='neutral'></span>
  477 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2) internal pure {</span>
  478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string)&quot;, p0, p1, p2));</span>
  479 |     | <span class='neutral'>    }</span>
  480 |     | <span class='neutral'></span>
  481 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2) internal pure {</span>
  482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool)&quot;, p0, p1, p2));</span>
  483 |     | <span class='neutral'>    }</span>
  484 |     | <span class='neutral'></span>
  485 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2) internal pure {</span>
  486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address)&quot;, p0, p1, p2));</span>
  487 |     | <span class='neutral'>    }</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2) internal pure {</span>
  490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint)&quot;, p0, p1, p2));</span>
  491 |     | <span class='neutral'>    }</span>
  492 |     | <span class='neutral'></span>
  493 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2) internal pure {</span>
  494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string)&quot;, p0, p1, p2));</span>
  495 |     | <span class='neutral'>    }</span>
  496 |     | <span class='neutral'></span>
  497 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
  498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool)&quot;, p0, p1, p2));</span>
  499 |     | <span class='neutral'>    }</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
  502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address)&quot;, p0, p1, p2));</span>
  503 |     | <span class='neutral'>    }</span>
  504 |     | <span class='neutral'></span>
  505 |     | <span class='neutral'>    function log(address p0, address p1, uint p2) internal pure {</span>
  506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint)&quot;, p0, p1, p2));</span>
  507 |     | <span class='neutral'>    }</span>
  508 |     | <span class='neutral'></span>
  509 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2) internal pure {</span>
  510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string)&quot;, p0, p1, p2));</span>
  511 |     | <span class='neutral'>    }</span>
  512 |     | <span class='neutral'></span>
  513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
  514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool)&quot;, p0, p1, p2));</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
  518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address)&quot;, p0, p1, p2));</span>
  519 |     | <span class='neutral'>    }</span>
  520 |     | <span class='neutral'></span>
  521 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, uint p3) internal pure {</span>
  522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  523 |     | <span class='neutral'>    }</span>
  524 |     | <span class='neutral'></span>
  525 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, string memory p3) internal pure {</span>
  526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  527 |     | <span class='neutral'>    }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, bool p3) internal pure {</span>
  530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    function log(uint p0, uint p1, uint p2, address p3) internal pure {</span>
  534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, uint p3) internal pure {</span>
  538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  539 |     | <span class='neutral'>    }</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, string memory p3) internal pure {</span>
  542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  543 |     | <span class='neutral'>    }</span>
  544 |     | <span class='neutral'></span>
  545 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, bool p3) internal pure {</span>
  546 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  547 |     | <span class='neutral'>    }</span>
  548 |     | <span class='neutral'></span>
  549 |     | <span class='neutral'>    function log(uint p0, uint p1, string memory p2, address p3) internal pure {</span>
  550 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  551 |     | <span class='neutral'>    }</span>
  552 |     | <span class='neutral'></span>
  553 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, uint p3) internal pure {</span>
  554 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  555 |     | <span class='neutral'>    }</span>
  556 |     | <span class='neutral'></span>
  557 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, string memory p3) internal pure {</span>
  558 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  559 |     | <span class='neutral'>    }</span>
  560 |     | <span class='neutral'></span>
  561 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, bool p3) internal pure {</span>
  562 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    function log(uint p0, uint p1, bool p2, address p3) internal pure {</span>
  566 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  567 |     | <span class='neutral'>    }</span>
  568 |     | <span class='neutral'></span>
  569 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, uint p3) internal pure {</span>
  570 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  571 |     | <span class='neutral'>    }</span>
  572 |     | <span class='neutral'></span>
  573 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, string memory p3) internal pure {</span>
  574 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  575 |     | <span class='neutral'>    }</span>
  576 |     | <span class='neutral'></span>
  577 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, bool p3) internal pure {</span>
  578 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    function log(uint p0, uint p1, address p2, address p3) internal pure {</span>
  582 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  583 |     | <span class='neutral'>    }</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, uint p3) internal pure {</span>
  586 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  587 |     | <span class='neutral'>    }</span>
  588 |     | <span class='neutral'></span>
  589 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, string memory p3) internal pure {</span>
  590 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  591 |     | <span class='neutral'>    }</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, bool p3) internal pure {</span>
  594 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  595 |     | <span class='neutral'>    }</span>
  596 |     | <span class='neutral'></span>
  597 |     | <span class='neutral'>    function log(uint p0, string memory p1, uint p2, address p3) internal pure {</span>
  598 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  599 |     | <span class='neutral'>    }</span>
  600 |     | <span class='neutral'></span>
  601 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, uint p3) internal pure {</span>
  602 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  603 |     | <span class='neutral'>    }</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  606 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,string)&quot;, p0, p1, p2, p3));</span>
  607 |     | <span class='neutral'>    }</span>
  608 |     | <span class='neutral'></span>
  609 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  610 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  611 |     | <span class='neutral'>    }</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>    function log(uint p0, string memory p1, string memory p2, address p3) internal pure {</span>
  614 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,string,address)&quot;, p0, p1, p2, p3));</span>
  615 |     | <span class='neutral'>    }</span>
  616 |     | <span class='neutral'></span>
  617 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, uint p3) internal pure {</span>
  618 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  619 |     | <span class='neutral'>    }</span>
  620 |     | <span class='neutral'></span>
  621 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  622 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  623 |     | <span class='neutral'>    }</span>
  624 |     | <span class='neutral'></span>
  625 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, bool p3) internal pure {</span>
  626 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  627 |     | <span class='neutral'>    }</span>
  628 |     | <span class='neutral'></span>
  629 |     | <span class='neutral'>    function log(uint p0, string memory p1, bool p2, address p3) internal pure {</span>
  630 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  631 |     | <span class='neutral'>    }</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, uint p3) internal pure {</span>
  634 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  635 |     | <span class='neutral'>    }</span>
  636 |     | <span class='neutral'></span>
  637 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, string memory p3) internal pure {</span>
  638 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,string)&quot;, p0, p1, p2, p3));</span>
  639 |     | <span class='neutral'>    }</span>
  640 |     | <span class='neutral'></span>
  641 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, bool p3) internal pure {</span>
  642 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function log(uint p0, string memory p1, address p2, address p3) internal pure {</span>
  646 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,string,address,address)&quot;, p0, p1, p2, p3));</span>
  647 |     | <span class='neutral'>    }</span>
  648 |     | <span class='neutral'></span>
  649 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, uint p3) internal pure {</span>
  650 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  651 |     | <span class='neutral'>    }</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, string memory p3) internal pure {</span>
  654 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  655 |     | <span class='neutral'>    }</span>
  656 |     | <span class='neutral'></span>
  657 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, bool p3) internal pure {</span>
  658 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  659 |     | <span class='neutral'>    }</span>
  660 |     | <span class='neutral'></span>
  661 |     | <span class='neutral'>    function log(uint p0, bool p1, uint p2, address p3) internal pure {</span>
  662 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  663 |     | <span class='neutral'>    }</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, uint p3) internal pure {</span>
  666 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  670 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  671 |     | <span class='neutral'>    }</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, bool p3) internal pure {</span>
  674 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  675 |     | <span class='neutral'>    }</span>
  676 |     | <span class='neutral'></span>
  677 |     | <span class='neutral'>    function log(uint p0, bool p1, string memory p2, address p3) internal pure {</span>
  678 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  679 |     | <span class='neutral'>    }</span>
  680 |     | <span class='neutral'></span>
  681 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, uint p3) internal pure {</span>
  682 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  683 |     | <span class='neutral'>    }</span>
  684 |     | <span class='neutral'></span>
  685 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, string memory p3) internal pure {</span>
  686 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  687 |     | <span class='neutral'>    }</span>
  688 |     | <span class='neutral'></span>
  689 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, bool p3) internal pure {</span>
  690 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  691 |     | <span class='neutral'>    }</span>
  692 |     | <span class='neutral'></span>
  693 |     | <span class='neutral'>    function log(uint p0, bool p1, bool p2, address p3) internal pure {</span>
  694 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  695 |     | <span class='neutral'>    }</span>
  696 |     | <span class='neutral'></span>
  697 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, uint p3) internal pure {</span>
  698 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  699 |     | <span class='neutral'>    }</span>
  700 |     | <span class='neutral'></span>
  701 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, string memory p3) internal pure {</span>
  702 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  703 |     | <span class='neutral'>    }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, bool p3) internal pure {</span>
  706 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  707 |     | <span class='neutral'>    }</span>
  708 |     | <span class='neutral'></span>
  709 |     | <span class='neutral'>    function log(uint p0, bool p1, address p2, address p3) internal pure {</span>
  710 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  711 |     | <span class='neutral'>    }</span>
  712 |     | <span class='neutral'></span>
  713 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, uint p3) internal pure {</span>
  714 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  715 |     | <span class='neutral'>    }</span>
  716 |     | <span class='neutral'></span>
  717 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, string memory p3) internal pure {</span>
  718 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  719 |     | <span class='neutral'>    }</span>
  720 |     | <span class='neutral'></span>
  721 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, bool p3) internal pure {</span>
  722 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  723 |     | <span class='neutral'>    }</span>
  724 |     | <span class='neutral'></span>
  725 |     | <span class='neutral'>    function log(uint p0, address p1, uint p2, address p3) internal pure {</span>
  726 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  727 |     | <span class='neutral'>    }</span>
  728 |     | <span class='neutral'></span>
  729 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, uint p3) internal pure {</span>
  730 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  731 |     | <span class='neutral'>    }</span>
  732 |     | <span class='neutral'></span>
  733 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, string memory p3) internal pure {</span>
  734 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,string)&quot;, p0, p1, p2, p3));</span>
  735 |     | <span class='neutral'>    }</span>
  736 |     | <span class='neutral'></span>
  737 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, bool p3) internal pure {</span>
  738 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    function log(uint p0, address p1, string memory p2, address p3) internal pure {</span>
  742 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,string,address)&quot;, p0, p1, p2, p3));</span>
  743 |     | <span class='neutral'>    }</span>
  744 |     | <span class='neutral'></span>
  745 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, uint p3) internal pure {</span>
  746 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
  747 |     | <span class='neutral'>    }</span>
  748 |     | <span class='neutral'></span>
  749 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, string memory p3) internal pure {</span>
  750 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,string)&quot;, p0, p1, p2, p3));</span>
  751 |     | <span class='neutral'>    }</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, bool p3) internal pure {</span>
  754 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
  755 |     | <span class='neutral'>    }</span>
  756 |     | <span class='neutral'></span>
  757 |     | <span class='neutral'>    function log(uint p0, address p1, bool p2, address p3) internal pure {</span>
  758 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,bool,address)&quot;, p0, p1, p2, p3));</span>
  759 |     | <span class='neutral'>    }</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, uint p3) internal pure {</span>
  762 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,uint)&quot;, p0, p1, p2, p3));</span>
  763 |     | <span class='neutral'>    }</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, string memory p3) internal pure {</span>
  766 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,string)&quot;, p0, p1, p2, p3));</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, bool p3) internal pure {</span>
  770 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,bool)&quot;, p0, p1, p2, p3));</span>
  771 |     | <span class='neutral'>    }</span>
  772 |     | <span class='neutral'></span>
  773 |     | <span class='neutral'>    function log(uint p0, address p1, address p2, address p3) internal pure {</span>
  774 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(uint,address,address,address)&quot;, p0, p1, p2, p3));</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, uint p3) internal pure {</span>
  778 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
  779 |     | <span class='neutral'>    }</span>
  780 |     | <span class='neutral'></span>
  781 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, string memory p3) internal pure {</span>
  782 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
  783 |     | <span class='neutral'>    }</span>
  784 |     | <span class='neutral'></span>
  785 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, bool p3) internal pure {</span>
  786 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
  787 |     | <span class='neutral'>    }</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>    function log(string memory p0, uint p1, uint p2, address p3) internal pure {</span>
  790 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
  791 |     | <span class='neutral'>    }</span>
  792 |     | <span class='neutral'></span>
  793 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, uint p3) internal pure {</span>
  794 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
  795 |     | <span class='neutral'>    }</span>
  796 |     | <span class='neutral'></span>
  797 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, string memory p3) internal pure {</span>
  798 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,string)&quot;, p0, p1, p2, p3));</span>
  799 |     | <span class='neutral'>    }</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, bool p3) internal pure {</span>
  802 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    function log(string memory p0, uint p1, string memory p2, address p3) internal pure {</span>
  806 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,string,address)&quot;, p0, p1, p2, p3));</span>
  807 |     | <span class='neutral'>    }</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, uint p3) internal pure {</span>
  810 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
  811 |     | <span class='neutral'>    }</span>
  812 |     | <span class='neutral'></span>
  813 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, string memory p3) internal pure {</span>
  814 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
  815 |     | <span class='neutral'>    }</span>
  816 |     | <span class='neutral'></span>
  817 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, bool p3) internal pure {</span>
  818 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
  819 |     | <span class='neutral'>    }</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    function log(string memory p0, uint p1, bool p2, address p3) internal pure {</span>
  822 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
  823 |     | <span class='neutral'>    }</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, uint p3) internal pure {</span>
  826 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
  827 |     | <span class='neutral'>    }</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, string memory p3) internal pure {</span>
  830 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,string)&quot;, p0, p1, p2, p3));</span>
  831 |     | <span class='neutral'>    }</span>
  832 |     | <span class='neutral'></span>
  833 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, bool p3) internal pure {</span>
  834 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
  835 |     | <span class='neutral'>    }</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='neutral'>    function log(string memory p0, uint p1, address p2, address p3) internal pure {</span>
  838 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,uint,address,address)&quot;, p0, p1, p2, p3));</span>
  839 |     | <span class='neutral'>    }</span>
  840 |     | <span class='neutral'></span>
  841 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, uint p3) internal pure {</span>
  842 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
  843 |     | <span class='neutral'>    }</span>
  844 |     | <span class='neutral'></span>
  845 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, string memory p3) internal pure {</span>
  846 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,string)&quot;, p0, p1, p2, p3));</span>
  847 |     | <span class='neutral'>    }</span>
  848 |     | <span class='neutral'></span>
  849 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, bool p3) internal pure {</span>
  850 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
  851 |     | <span class='neutral'>    }</span>
  852 |     | <span class='neutral'></span>
  853 |     | <span class='neutral'>    function log(string memory p0, string memory p1, uint p2, address p3) internal pure {</span>
  854 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,uint,address)&quot;, p0, p1, p2, p3));</span>
  855 |     | <span class='neutral'>    }</span>
  856 |     | <span class='neutral'></span>
  857 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, uint p3) internal pure {</span>
  858 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,uint)&quot;, p0, p1, p2, p3));</span>
  859 |     | <span class='neutral'>    }</span>
  860 |     | <span class='neutral'></span>
  861 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
  862 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,string)&quot;, p0, p1, p2, p3));</span>
  863 |     | <span class='neutral'>    }</span>
  864 |     | <span class='neutral'></span>
  865 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {</span>
  866 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,bool)&quot;, p0, p1, p2, p3));</span>
  867 |     | <span class='neutral'>    }</span>
  868 |     | <span class='neutral'></span>
  869 |     | <span class='neutral'>    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {</span>
  870 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,string,address)&quot;, p0, p1, p2, p3));</span>
  871 |     | <span class='neutral'>    }</span>
  872 |     | <span class='neutral'></span>
  873 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, uint p3) internal pure {</span>
  874 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
  875 |     | <span class='neutral'>    }</span>
  876 |     | <span class='neutral'></span>
  877 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {</span>
  878 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,string)&quot;, p0, p1, p2, p3));</span>
  879 |     | <span class='neutral'>    }</span>
  880 |     | <span class='neutral'></span>
  881 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {</span>
  882 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
  883 |     | <span class='neutral'>    }</span>
  884 |     | <span class='neutral'></span>
  885 |     | <span class='neutral'>    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {</span>
  886 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,bool,address)&quot;, p0, p1, p2, p3));</span>
  887 |     | <span class='neutral'>    }</span>
  888 |     | <span class='neutral'></span>
  889 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, uint p3) internal pure {</span>
  890 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,uint)&quot;, p0, p1, p2, p3));</span>
  891 |     | <span class='neutral'>    }</span>
  892 |     | <span class='neutral'></span>
  893 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {</span>
  894 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,string)&quot;, p0, p1, p2, p3));</span>
  895 |     | <span class='neutral'>    }</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {</span>
  898 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,bool)&quot;, p0, p1, p2, p3));</span>
  899 |     | <span class='neutral'>    }</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>    function log(string memory p0, string memory p1, address p2, address p3) internal pure {</span>
  902 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,string,address,address)&quot;, p0, p1, p2, p3));</span>
  903 |     | <span class='neutral'>    }</span>
  904 |     | <span class='neutral'></span>
  905 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, uint p3) internal pure {</span>
  906 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
  907 |     | <span class='neutral'>    }</span>
  908 |     | <span class='neutral'></span>
  909 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, string memory p3) internal pure {</span>
  910 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, bool p3) internal pure {</span>
  914 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
  915 |     | <span class='neutral'>    }</span>
  916 |     | <span class='neutral'></span>
  917 |     | <span class='neutral'>    function log(string memory p0, bool p1, uint p2, address p3) internal pure {</span>
  918 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
  919 |     | <span class='neutral'>    }</span>
  920 |     | <span class='neutral'></span>
  921 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, uint p3) internal pure {</span>
  922 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
  923 |     | <span class='neutral'>    }</span>
  924 |     | <span class='neutral'></span>
  925 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {</span>
  926 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,string)&quot;, p0, p1, p2, p3));</span>
  927 |     | <span class='neutral'>    }</span>
  928 |     | <span class='neutral'></span>
  929 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {</span>
  930 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
  931 |     | <span class='neutral'>    }</span>
  932 |     | <span class='neutral'></span>
  933 |     | <span class='neutral'>    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {</span>
  934 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,string,address)&quot;, p0, p1, p2, p3));</span>
  935 |     | <span class='neutral'>    }</span>
  936 |     | <span class='neutral'></span>
  937 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, uint p3) internal pure {</span>
  938 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
  939 |     | <span class='neutral'>    }</span>
  940 |     | <span class='neutral'></span>
  941 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {</span>
  942 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
  943 |     | <span class='neutral'>    }</span>
  944 |     | <span class='neutral'></span>
  945 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {</span>
  946 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
  947 |     | <span class='neutral'>    }</span>
  948 |     | <span class='neutral'></span>
  949 |     | <span class='neutral'>    function log(string memory p0, bool p1, bool p2, address p3) internal pure {</span>
  950 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, uint p3) internal pure {</span>
  954 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
  955 |     | <span class='neutral'>    }</span>
  956 |     | <span class='neutral'></span>
  957 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {</span>
  958 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,string)&quot;, p0, p1, p2, p3));</span>
  959 |     | <span class='neutral'>    }</span>
  960 |     | <span class='neutral'></span>
  961 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, bool p3) internal pure {</span>
  962 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
  963 |     | <span class='neutral'>    }</span>
  964 |     | <span class='neutral'></span>
  965 |     | <span class='neutral'>    function log(string memory p0, bool p1, address p2, address p3) internal pure {</span>
  966 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,bool,address,address)&quot;, p0, p1, p2, p3));</span>
  967 |     | <span class='neutral'>    }</span>
  968 |     | <span class='neutral'></span>
  969 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, uint p3) internal pure {</span>
  970 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
  971 |     | <span class='neutral'>    }</span>
  972 |     | <span class='neutral'></span>
  973 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, string memory p3) internal pure {</span>
  974 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,string)&quot;, p0, p1, p2, p3));</span>
  975 |     | <span class='neutral'>    }</span>
  976 |     | <span class='neutral'></span>
  977 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, bool p3) internal pure {</span>
  978 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
  979 |     | <span class='neutral'>    }</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>    function log(string memory p0, address p1, uint p2, address p3) internal pure {</span>
  982 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,uint,address)&quot;, p0, p1, p2, p3));</span>
  983 |     | <span class='neutral'>    }</span>
  984 |     | <span class='neutral'></span>
  985 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, uint p3) internal pure {</span>
  986 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,uint)&quot;, p0, p1, p2, p3));</span>
  987 |     | <span class='neutral'>    }</span>
  988 |     | <span class='neutral'></span>
  989 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {</span>
  990 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,string)&quot;, p0, p1, p2, p3));</span>
  991 |     | <span class='neutral'>    }</span>
  992 |     | <span class='neutral'></span>
  993 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {</span>
  994 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,bool)&quot;, p0, p1, p2, p3));</span>
  995 |     | <span class='neutral'>    }</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>    function log(string memory p0, address p1, string memory p2, address p3) internal pure {</span>
  998 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,string,address)&quot;, p0, p1, p2, p3));</span>
  999 |     | <span class='neutral'>    }</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, uint p3) internal pure {</span>
 1002 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1003 |     | <span class='neutral'>    }</span>
 1004 |     | <span class='neutral'></span>
 1005 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {</span>
 1006 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1007 |     | <span class='neutral'>    }</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, bool p3) internal pure {</span>
 1010 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1011 |     | <span class='neutral'>    }</span>
 1012 |     | <span class='neutral'></span>
 1013 |     | <span class='neutral'>    function log(string memory p0, address p1, bool p2, address p3) internal pure {</span>
 1014 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1015 |     | <span class='neutral'>    }</span>
 1016 |     | <span class='neutral'></span>
 1017 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, uint p3) internal pure {</span>
 1018 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1019 |     | <span class='neutral'>    }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, string memory p3) internal pure {</span>
 1022 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1023 |     | <span class='neutral'>    }</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, bool p3) internal pure {</span>
 1026 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1027 |     | <span class='neutral'>    }</span>
 1028 |     | <span class='neutral'></span>
 1029 |     | <span class='neutral'>    function log(string memory p0, address p1, address p2, address p3) internal pure {</span>
 1030 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(string,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1031 |     | <span class='neutral'>    }</span>
 1032 |     | <span class='neutral'></span>
 1033 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, uint p3) internal pure {</span>
 1034 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1035 |     | <span class='neutral'>    }</span>
 1036 |     | <span class='neutral'></span>
 1037 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, string memory p3) internal pure {</span>
 1038 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1039 |     | <span class='neutral'>    }</span>
 1040 |     | <span class='neutral'></span>
 1041 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, bool p3) internal pure {</span>
 1042 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1043 |     | <span class='neutral'>    }</span>
 1044 |     | <span class='neutral'></span>
 1045 |     | <span class='neutral'>    function log(bool p0, uint p1, uint p2, address p3) internal pure {</span>
 1046 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1047 |     | <span class='neutral'>    }</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, uint p3) internal pure {</span>
 1050 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1051 |     | <span class='neutral'>    }</span>
 1052 |     | <span class='neutral'></span>
 1053 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, string memory p3) internal pure {</span>
 1054 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1055 |     | <span class='neutral'>    }</span>
 1056 |     | <span class='neutral'></span>
 1057 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, bool p3) internal pure {</span>
 1058 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1059 |     | <span class='neutral'>    }</span>
 1060 |     | <span class='neutral'></span>
 1061 |     | <span class='neutral'>    function log(bool p0, uint p1, string memory p2, address p3) internal pure {</span>
 1062 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1063 |     | <span class='neutral'>    }</span>
 1064 |     | <span class='neutral'></span>
 1065 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, uint p3) internal pure {</span>
 1066 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, string memory p3) internal pure {</span>
 1070 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1071 |     | <span class='neutral'>    }</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, bool p3) internal pure {</span>
 1074 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1075 |     | <span class='neutral'>    }</span>
 1076 |     | <span class='neutral'></span>
 1077 |     | <span class='neutral'>    function log(bool p0, uint p1, bool p2, address p3) internal pure {</span>
 1078 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1079 |     | <span class='neutral'>    }</span>
 1080 |     | <span class='neutral'></span>
 1081 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, uint p3) internal pure {</span>
 1082 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1083 |     | <span class='neutral'>    }</span>
 1084 |     | <span class='neutral'></span>
 1085 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, string memory p3) internal pure {</span>
 1086 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1087 |     | <span class='neutral'>    }</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, bool p3) internal pure {</span>
 1090 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1091 |     | <span class='neutral'>    }</span>
 1092 |     | <span class='neutral'></span>
 1093 |     | <span class='neutral'>    function log(bool p0, uint p1, address p2, address p3) internal pure {</span>
 1094 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1095 |     | <span class='neutral'>    }</span>
 1096 |     | <span class='neutral'></span>
 1097 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, uint p3) internal pure {</span>
 1098 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1099 |     | <span class='neutral'>    }</span>
 1100 |     | <span class='neutral'></span>
 1101 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, string memory p3) internal pure {</span>
 1102 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1103 |     | <span class='neutral'>    }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, bool p3) internal pure {</span>
 1106 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    function log(bool p0, string memory p1, uint p2, address p3) internal pure {</span>
 1110 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1111 |     | <span class='neutral'>    }</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, uint p3) internal pure {</span>
 1114 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1115 |     | <span class='neutral'>    }</span>
 1116 |     | <span class='neutral'></span>
 1117 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1118 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1119 |     | <span class='neutral'>    }</span>
 1120 |     | <span class='neutral'></span>
 1121 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1122 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1123 |     | <span class='neutral'>    }</span>
 1124 |     | <span class='neutral'></span>
 1125 |     | <span class='neutral'>    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1126 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1127 |     | <span class='neutral'>    }</span>
 1128 |     | <span class='neutral'></span>
 1129 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, uint p3) internal pure {</span>
 1130 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1131 |     | <span class='neutral'>    }</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1134 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1138 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1139 |     | <span class='neutral'>    }</span>
 1140 |     | <span class='neutral'></span>
 1141 |     | <span class='neutral'>    function log(bool p0, string memory p1, bool p2, address p3) internal pure {</span>
 1142 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1143 |     | <span class='neutral'>    }</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, uint p3) internal pure {</span>
 1146 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1147 |     | <span class='neutral'>    }</span>
 1148 |     | <span class='neutral'></span>
 1149 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1150 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1151 |     | <span class='neutral'>    }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, bool p3) internal pure {</span>
 1154 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1155 |     | <span class='neutral'>    }</span>
 1156 |     | <span class='neutral'></span>
 1157 |     | <span class='neutral'>    function log(bool p0, string memory p1, address p2, address p3) internal pure {</span>
 1158 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1159 |     | <span class='neutral'>    }</span>
 1160 |     | <span class='neutral'></span>
 1161 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, uint p3) internal pure {</span>
 1162 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1163 |     | <span class='neutral'>    }</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, string memory p3) internal pure {</span>
 1166 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1167 |     | <span class='neutral'>    }</span>
 1168 |     | <span class='neutral'></span>
 1169 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, bool p3) internal pure {</span>
 1170 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1171 |     | <span class='neutral'>    }</span>
 1172 |     | <span class='neutral'></span>
 1173 |     | <span class='neutral'>    function log(bool p0, bool p1, uint p2, address p3) internal pure {</span>
 1174 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1175 |     | <span class='neutral'>    }</span>
 1176 |     | <span class='neutral'></span>
 1177 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, uint p3) internal pure {</span>
 1178 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1179 |     | <span class='neutral'>    }</span>
 1180 |     | <span class='neutral'></span>
 1181 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1182 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1183 |     | <span class='neutral'>    }</span>
 1184 |     | <span class='neutral'></span>
 1185 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1186 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1187 |     | <span class='neutral'>    }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>    function log(bool p0, bool p1, string memory p2, address p3) internal pure {</span>
 1190 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1191 |     | <span class='neutral'>    }</span>
 1192 |     | <span class='neutral'></span>
 1193 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint p3) internal pure {</span>
 1194 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1195 |     | <span class='neutral'>    }</span>
 1196 |     | <span class='neutral'></span>
 1197 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1198 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1199 |     | <span class='neutral'>    }</span>
 1200 |     | <span class='neutral'></span>
 1201 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
 1202 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1203 |     | <span class='neutral'>    }</span>
 1204 |     | <span class='neutral'></span>
 1205 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
 1206 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1207 |     | <span class='neutral'>    }</span>
 1208 |     | <span class='neutral'></span>
 1209 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint p3) internal pure {</span>
 1210 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1211 |     | <span class='neutral'>    }</span>
 1212 |     | <span class='neutral'></span>
 1213 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, string memory p3) internal pure {</span>
 1214 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
 1218 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1219 |     | <span class='neutral'>    }</span>
 1220 |     | <span class='neutral'></span>
 1221 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
 1222 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1223 |     | <span class='neutral'>    }</span>
 1224 |     | <span class='neutral'></span>
 1225 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, uint p3) internal pure {</span>
 1226 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1227 |     | <span class='neutral'>    }</span>
 1228 |     | <span class='neutral'></span>
 1229 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, string memory p3) internal pure {</span>
 1230 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1231 |     | <span class='neutral'>    }</span>
 1232 |     | <span class='neutral'></span>
 1233 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, bool p3) internal pure {</span>
 1234 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1235 |     | <span class='neutral'>    }</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    function log(bool p0, address p1, uint p2, address p3) internal pure {</span>
 1238 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1239 |     | <span class='neutral'>    }</span>
 1240 |     | <span class='neutral'></span>
 1241 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, uint p3) internal pure {</span>
 1242 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1243 |     | <span class='neutral'>    }</span>
 1244 |     | <span class='neutral'></span>
 1245 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1246 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1247 |     | <span class='neutral'>    }</span>
 1248 |     | <span class='neutral'></span>
 1249 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, bool p3) internal pure {</span>
 1250 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1251 |     | <span class='neutral'>    }</span>
 1252 |     | <span class='neutral'></span>
 1253 |     | <span class='neutral'>    function log(bool p0, address p1, string memory p2, address p3) internal pure {</span>
 1254 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1255 |     | <span class='neutral'>    }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint p3) internal pure {</span>
 1258 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1259 |     | <span class='neutral'>    }</span>
 1260 |     | <span class='neutral'></span>
 1261 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, string memory p3) internal pure {</span>
 1262 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1263 |     | <span class='neutral'>    }</span>
 1264 |     | <span class='neutral'></span>
 1265 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
 1266 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1267 |     | <span class='neutral'>    }</span>
 1268 |     | <span class='neutral'></span>
 1269 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
 1270 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1271 |     | <span class='neutral'>    }</span>
 1272 |     | <span class='neutral'></span>
 1273 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint p3) internal pure {</span>
 1274 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1275 |     | <span class='neutral'>    }</span>
 1276 |     | <span class='neutral'></span>
 1277 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, string memory p3) internal pure {</span>
 1278 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1279 |     | <span class='neutral'>    }</span>
 1280 |     | <span class='neutral'></span>
 1281 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
 1282 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1283 |     | <span class='neutral'>    }</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
 1286 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(bool,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1287 |     | <span class='neutral'>    }</span>
 1288 |     | <span class='neutral'></span>
 1289 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, uint p3) internal pure {</span>
 1290 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1291 |     | <span class='neutral'>    }</span>
 1292 |     | <span class='neutral'></span>
 1293 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, string memory p3) internal pure {</span>
 1294 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,string)&quot;, p0, p1, p2, p3));</span>
 1295 |     | <span class='neutral'>    }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, bool p3) internal pure {</span>
 1298 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1299 |     | <span class='neutral'>    }</span>
 1300 |     | <span class='neutral'></span>
 1301 |     | <span class='neutral'>    function log(address p0, uint p1, uint p2, address p3) internal pure {</span>
 1302 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,uint,address)&quot;, p0, p1, p2, p3));</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, uint p3) internal pure {</span>
 1306 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,uint)&quot;, p0, p1, p2, p3));</span>
 1307 |     | <span class='neutral'>    }</span>
 1308 |     | <span class='neutral'></span>
 1309 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, string memory p3) internal pure {</span>
 1310 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,string)&quot;, p0, p1, p2, p3));</span>
 1311 |     | <span class='neutral'>    }</span>
 1312 |     | <span class='neutral'></span>
 1313 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, bool p3) internal pure {</span>
 1314 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,bool)&quot;, p0, p1, p2, p3));</span>
 1315 |     | <span class='neutral'>    }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>    function log(address p0, uint p1, string memory p2, address p3) internal pure {</span>
 1318 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,string,address)&quot;, p0, p1, p2, p3));</span>
 1319 |     | <span class='neutral'>    }</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, uint p3) internal pure {</span>
 1322 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1323 |     | <span class='neutral'>    }</span>
 1324 |     | <span class='neutral'></span>
 1325 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, string memory p3) internal pure {</span>
 1326 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,string)&quot;, p0, p1, p2, p3));</span>
 1327 |     | <span class='neutral'>    }</span>
 1328 |     | <span class='neutral'></span>
 1329 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, bool p3) internal pure {</span>
 1330 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1331 |     | <span class='neutral'>    }</span>
 1332 |     | <span class='neutral'></span>
 1333 |     | <span class='neutral'>    function log(address p0, uint p1, bool p2, address p3) internal pure {</span>
 1334 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,bool,address)&quot;, p0, p1, p2, p3));</span>
 1335 |     | <span class='neutral'>    }</span>
 1336 |     | <span class='neutral'></span>
 1337 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, uint p3) internal pure {</span>
 1338 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,uint)&quot;, p0, p1, p2, p3));</span>
 1339 |     | <span class='neutral'>    }</span>
 1340 |     | <span class='neutral'></span>
 1341 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, string memory p3) internal pure {</span>
 1342 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,string)&quot;, p0, p1, p2, p3));</span>
 1343 |     | <span class='neutral'>    }</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, bool p3) internal pure {</span>
 1346 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,bool)&quot;, p0, p1, p2, p3));</span>
 1347 |     | <span class='neutral'>    }</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='neutral'>    function log(address p0, uint p1, address p2, address p3) internal pure {</span>
 1350 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,uint,address,address)&quot;, p0, p1, p2, p3));</span>
 1351 |     | <span class='neutral'>    }</span>
 1352 |     | <span class='neutral'></span>
 1353 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, uint p3) internal pure {</span>
 1354 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1355 |     | <span class='neutral'>    }</span>
 1356 |     | <span class='neutral'></span>
 1357 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, string memory p3) internal pure {</span>
 1358 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,string)&quot;, p0, p1, p2, p3));</span>
 1359 |     | <span class='neutral'>    }</span>
 1360 |     | <span class='neutral'></span>
 1361 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, bool p3) internal pure {</span>
 1362 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1363 |     | <span class='neutral'>    }</span>
 1364 |     | <span class='neutral'></span>
 1365 |     | <span class='neutral'>    function log(address p0, string memory p1, uint p2, address p3) internal pure {</span>
 1366 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,uint,address)&quot;, p0, p1, p2, p3));</span>
 1367 |     | <span class='neutral'>    }</span>
 1368 |     | <span class='neutral'></span>
 1369 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, uint p3) internal pure {</span>
 1370 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,uint)&quot;, p0, p1, p2, p3));</span>
 1371 |     | <span class='neutral'>    }</span>
 1372 |     | <span class='neutral'></span>
 1373 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {</span>
 1374 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,string)&quot;, p0, p1, p2, p3));</span>
 1375 |     | <span class='neutral'>    }</span>
 1376 |     | <span class='neutral'></span>
 1377 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {</span>
 1378 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,bool)&quot;, p0, p1, p2, p3));</span>
 1379 |     | <span class='neutral'>    }</span>
 1380 |     | <span class='neutral'></span>
 1381 |     | <span class='neutral'>    function log(address p0, string memory p1, string memory p2, address p3) internal pure {</span>
 1382 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,string,address)&quot;, p0, p1, p2, p3));</span>
 1383 |     | <span class='neutral'>    }</span>
 1384 |     | <span class='neutral'></span>
 1385 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, uint p3) internal pure {</span>
 1386 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1387 |     | <span class='neutral'>    }</span>
 1388 |     | <span class='neutral'></span>
 1389 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {</span>
 1390 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,string)&quot;, p0, p1, p2, p3));</span>
 1391 |     | <span class='neutral'>    }</span>
 1392 |     | <span class='neutral'></span>
 1393 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, bool p3) internal pure {</span>
 1394 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1395 |     | <span class='neutral'>    }</span>
 1396 |     | <span class='neutral'></span>
 1397 |     | <span class='neutral'>    function log(address p0, string memory p1, bool p2, address p3) internal pure {</span>
 1398 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,bool,address)&quot;, p0, p1, p2, p3));</span>
 1399 |     | <span class='neutral'>    }</span>
 1400 |     | <span class='neutral'></span>
 1401 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, uint p3) internal pure {</span>
 1402 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,uint)&quot;, p0, p1, p2, p3));</span>
 1403 |     | <span class='neutral'>    }</span>
 1404 |     | <span class='neutral'></span>
 1405 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, string memory p3) internal pure {</span>
 1406 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,string)&quot;, p0, p1, p2, p3));</span>
 1407 |     | <span class='neutral'>    }</span>
 1408 |     | <span class='neutral'></span>
 1409 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, bool p3) internal pure {</span>
 1410 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,bool)&quot;, p0, p1, p2, p3));</span>
 1411 |     | <span class='neutral'>    }</span>
 1412 |     | <span class='neutral'></span>
 1413 |     | <span class='neutral'>    function log(address p0, string memory p1, address p2, address p3) internal pure {</span>
 1414 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,string,address,address)&quot;, p0, p1, p2, p3));</span>
 1415 |     | <span class='neutral'>    }</span>
 1416 |     | <span class='neutral'></span>
 1417 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, uint p3) internal pure {</span>
 1418 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1419 |     | <span class='neutral'>    }</span>
 1420 |     | <span class='neutral'></span>
 1421 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, string memory p3) internal pure {</span>
 1422 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,string)&quot;, p0, p1, p2, p3));</span>
 1423 |     | <span class='neutral'>    }</span>
 1424 |     | <span class='neutral'></span>
 1425 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, bool p3) internal pure {</span>
 1426 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1427 |     | <span class='neutral'>    }</span>
 1428 |     | <span class='neutral'></span>
 1429 |     | <span class='neutral'>    function log(address p0, bool p1, uint p2, address p3) internal pure {</span>
 1430 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,uint,address)&quot;, p0, p1, p2, p3));</span>
 1431 |     | <span class='neutral'>    }</span>
 1432 |     | <span class='neutral'></span>
 1433 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, uint p3) internal pure {</span>
 1434 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,uint)&quot;, p0, p1, p2, p3));</span>
 1435 |     | <span class='neutral'>    }</span>
 1436 |     | <span class='neutral'></span>
 1437 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {</span>
 1438 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,string)&quot;, p0, p1, p2, p3));</span>
 1439 |     | <span class='neutral'>    }</span>
 1440 |     | <span class='neutral'></span>
 1441 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, bool p3) internal pure {</span>
 1442 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,bool)&quot;, p0, p1, p2, p3));</span>
 1443 |     | <span class='neutral'>    }</span>
 1444 |     | <span class='neutral'></span>
 1445 |     | <span class='neutral'>    function log(address p0, bool p1, string memory p2, address p3) internal pure {</span>
 1446 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,string,address)&quot;, p0, p1, p2, p3));</span>
 1447 |     | <span class='neutral'>    }</span>
 1448 |     | <span class='neutral'></span>
 1449 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint p3) internal pure {</span>
 1450 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1451 |     | <span class='neutral'>    }</span>
 1452 |     | <span class='neutral'></span>
 1453 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, string memory p3) internal pure {</span>
 1454 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,string)&quot;, p0, p1, p2, p3));</span>
 1455 |     | <span class='neutral'>    }</span>
 1456 |     | <span class='neutral'></span>
 1457 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
 1458 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1459 |     | <span class='neutral'>    }</span>
 1460 |     | <span class='neutral'></span>
 1461 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
 1462 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,bool,address)&quot;, p0, p1, p2, p3));</span>
 1463 |     | <span class='neutral'>    }</span>
 1464 |     | <span class='neutral'></span>
 1465 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint p3) internal pure {</span>
 1466 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,uint)&quot;, p0, p1, p2, p3));</span>
 1467 |     | <span class='neutral'>    }</span>
 1468 |     | <span class='neutral'></span>
 1469 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, string memory p3) internal pure {</span>
 1470 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,string)&quot;, p0, p1, p2, p3));</span>
 1471 |     | <span class='neutral'>    }</span>
 1472 |     | <span class='neutral'></span>
 1473 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
 1474 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,bool)&quot;, p0, p1, p2, p3));</span>
 1475 |     | <span class='neutral'>    }</span>
 1476 |     | <span class='neutral'></span>
 1477 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
 1478 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,bool,address,address)&quot;, p0, p1, p2, p3));</span>
 1479 |     | <span class='neutral'>    }</span>
 1480 |     | <span class='neutral'></span>
 1481 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, uint p3) internal pure {</span>
 1482 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,uint)&quot;, p0, p1, p2, p3));</span>
 1483 |     | <span class='neutral'>    }</span>
 1484 |     | <span class='neutral'></span>
 1485 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, string memory p3) internal pure {</span>
 1486 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,string)&quot;, p0, p1, p2, p3));</span>
 1487 |     | <span class='neutral'>    }</span>
 1488 |     | <span class='neutral'></span>
 1489 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, bool p3) internal pure {</span>
 1490 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,bool)&quot;, p0, p1, p2, p3));</span>
 1491 |     | <span class='neutral'>    }</span>
 1492 |     | <span class='neutral'></span>
 1493 |     | <span class='neutral'>    function log(address p0, address p1, uint p2, address p3) internal pure {</span>
 1494 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,uint,address)&quot;, p0, p1, p2, p3));</span>
 1495 |     | <span class='neutral'>    }</span>
 1496 |     | <span class='neutral'></span>
 1497 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, uint p3) internal pure {</span>
 1498 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,uint)&quot;, p0, p1, p2, p3));</span>
 1499 |     | <span class='neutral'>    }</span>
 1500 |     | <span class='neutral'></span>
 1501 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, string memory p3) internal pure {</span>
 1502 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,string)&quot;, p0, p1, p2, p3));</span>
 1503 |     | <span class='neutral'>    }</span>
 1504 |     | <span class='neutral'></span>
 1505 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, bool p3) internal pure {</span>
 1506 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,bool)&quot;, p0, p1, p2, p3));</span>
 1507 |     | <span class='neutral'>    }</span>
 1508 |     | <span class='neutral'></span>
 1509 |     | <span class='neutral'>    function log(address p0, address p1, string memory p2, address p3) internal pure {</span>
 1510 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,string,address)&quot;, p0, p1, p2, p3));</span>
 1511 |     | <span class='neutral'>    }</span>
 1512 |     | <span class='neutral'></span>
 1513 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint p3) internal pure {</span>
 1514 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,uint)&quot;, p0, p1, p2, p3));</span>
 1515 |     | <span class='neutral'>    }</span>
 1516 |     | <span class='neutral'></span>
 1517 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, string memory p3) internal pure {</span>
 1518 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,string)&quot;, p0, p1, p2, p3));</span>
 1519 |     | <span class='neutral'>    }</span>
 1520 |     | <span class='neutral'></span>
 1521 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
 1522 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,bool)&quot;, p0, p1, p2, p3));</span>
 1523 |     | <span class='neutral'>    }</span>
 1524 |     | <span class='neutral'></span>
 1525 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
 1526 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,bool,address)&quot;, p0, p1, p2, p3));</span>
 1527 |     | <span class='neutral'>    }</span>
 1528 |     | <span class='neutral'></span>
 1529 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint p3) internal pure {</span>
 1530 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,uint)&quot;, p0, p1, p2, p3));</span>
 1531 |     | <span class='neutral'>    }</span>
 1532 |     | <span class='neutral'></span>
 1533 |     | <span class='neutral'>    function log(address p0, address p1, address p2, string memory p3) internal pure {</span>
 1534 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,string)&quot;, p0, p1, p2, p3));</span>
 1535 |     | <span class='neutral'>    }</span>
 1536 |     | <span class='neutral'></span>
 1537 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
 1538 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,bool)&quot;, p0, p1, p2, p3));</span>
 1539 |     | <span class='neutral'>    }</span>
 1540 |     | <span class='neutral'></span>
 1541 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
 1542 |     | <span class='neutral'>        _sendLogPayload(abi.encodeWithSignature(&quot;log(address,address,address,address)&quot;, p0, p1, p2, p3));</span>
 1543 |     | <span class='neutral'>    }</span>
 1544 |     | <span class='neutral'>}</span>
 1545 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/console2.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.4.22 &lt;0.9.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {console as console2} from &quot;./console.sol&quot;;</span>
 5 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IERC165 {</span>
  5 |     | <span class='neutral'>    /// @notice Query if a contract implements an interface</span>
  6 |     | <span class='neutral'>    /// @param interfaceID The interface identifier, as specified in ERC-165</span>
  7 |     | <span class='neutral'>    /// @dev Interface identification is specified in ERC-165. This function</span>
  8 |     | <span class='neutral'>    /// uses less than 30,000 gas.</span>
  9 |     | <span class='neutral'>    /// @return `true` if the contract implements `interfaceID` and</span>
 10 |     | <span class='neutral'>    /// `interfaceID` is not 0xffffffff, `false` otherwise</span>
 11 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceID) external view returns (bool);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @dev Interface of the ERC20 standard as defined in the EIP.</span>
  5 |     | <span class='neutral'>/// @dev This includes the optional name, symbol, and decimals metadata.</span>
  6 |     | <span class='neutral'>interface IERC20 {</span>
  7 |     | <span class='neutral'>    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`</span>
 11 |     | <span class='neutral'>    /// is the new allowance.</span>
 12 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Returns the amount of tokens in existence.</span>
 15 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice Returns the amount of tokens owned by `account`.</span>
 18 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns the remaining number of tokens that `spender` is allowed</span>
 24 |     | <span class='neutral'>    /// to spend on behalf of `owner`</span>
 25 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 28 |     | <span class='neutral'>    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 29 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.</span>
 32 |     | <span class='neutral'>    /// `amount` is then deducted from the caller&#39;s allowance.</span>
 33 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @notice Returns the name of the token.</span>
 36 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @notice Returns the symbol of the token.</span>
 39 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Returns the decimals places of the token.</span>
 42 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard</span>
   7 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
   8 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x80ac58cd.</span>
   9 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  10 |     | <span class='neutral'>    /// @dev This emits when ownership of any NFT changes by any mechanism.</span>
  11 |     | <span class='neutral'>    /// This event emits when NFTs are created (`from` == 0) and destroyed</span>
  12 |     | <span class='neutral'>    /// (`to` == 0). Exception: during contract creation, any number of NFTs</span>
  13 |     | <span class='neutral'>    /// may be created and assigned without emitting Transfer. At the time of</span>
  14 |     | <span class='neutral'>    /// any transfer, the approved address for that NFT (if any) is reset to none.</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @dev This emits when the approved address for an NFT is changed or</span>
  18 |     | <span class='neutral'>    /// reaffirmed. The zero address indicates there is no approved address.</span>
  19 |     | <span class='neutral'>    /// When a Transfer event emits, this also indicates that the approved</span>
  20 |     | <span class='neutral'>    /// address for that NFT (if any) is reset to none.</span>
  21 |     | <span class='neutral'>    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @dev This emits when an operator is enabled or disabled for an owner.</span>
  24 |     | <span class='neutral'>    /// The operator can manage all NFTs of the owner.</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /// @notice Count all NFTs assigned to an owner</span>
  28 |     | <span class='neutral'>    /// @dev NFTs assigned to the zero address are considered invalid, and this</span>
  29 |     | <span class='neutral'>    /// function throws for queries about the zero address.</span>
  30 |     | <span class='neutral'>    /// @param _owner An address for whom to query the balance</span>
  31 |     | <span class='neutral'>    /// @return The number of NFTs owned by `_owner`, possibly zero</span>
  32 |     | <span class='neutral'>    function balanceOf(address _owner) external view returns (uint256);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice Find the owner of an NFT</span>
  35 |     | <span class='neutral'>    /// @dev NFTs assigned to zero address are considered invalid, and queries</span>
  36 |     | <span class='neutral'>    /// about them do throw.</span>
  37 |     | <span class='neutral'>    /// @param _tokenId The identifier for an NFT</span>
  38 |     | <span class='neutral'>    /// @return The address of the owner of the NFT</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 _tokenId) external view returns (address);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  42 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  43 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  44 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  45 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT. When transfer is complete, this function</span>
  46 |     | <span class='neutral'>    /// checks if `_to` is a smart contract (code size &gt; 0). If so, it calls</span>
  47 |     | <span class='neutral'>    /// `onERC721Received` on `_to` and throws if the return value is not</span>
  48 |     | <span class='neutral'>    /// `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`.</span>
  49 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  50 |     | <span class='neutral'>    /// @param _to The new owner</span>
  51 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  52 |     | <span class='neutral'>    /// @param data Additional data with no specified format, sent in call to `_to`</span>
  53 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata data) external payable;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice Transfers the ownership of an NFT from one address to another address</span>
  56 |     | <span class='neutral'>    /// @dev This works identically to the other function with an extra data parameter,</span>
  57 |     | <span class='neutral'>    /// except this function just sets data to &quot;&quot;.</span>
  58 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  59 |     | <span class='neutral'>    /// @param _to The new owner</span>
  60 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  61 |     | <span class='neutral'>    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE</span>
  64 |     | <span class='neutral'>    /// TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE</span>
  65 |     | <span class='neutral'>    /// THEY MAY BE PERMANENTLY LOST</span>
  66 |     | <span class='neutral'>    /// @dev Throws unless `msg.sender` is the current owner, an authorized</span>
  67 |     | <span class='neutral'>    /// operator, or the approved address for this NFT. Throws if `_from` is</span>
  68 |     | <span class='neutral'>    /// not the current owner. Throws if `_to` is the zero address. Throws if</span>
  69 |     | <span class='neutral'>    /// `_tokenId` is not a valid NFT.</span>
  70 |     | <span class='neutral'>    /// @param _from The current owner of the NFT</span>
  71 |     | <span class='neutral'>    /// @param _to The new owner</span>
  72 |     | <span class='neutral'>    /// @param _tokenId The NFT to transfer</span>
  73 |     | <span class='neutral'>    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /// @notice Change or reaffirm the approved address for an NFT</span>
  76 |     | <span class='neutral'>    /// @dev The zero address indicates there is no approved address.</span>
  77 |     | <span class='neutral'>    /// Throws unless `msg.sender` is the current NFT owner, or an authorized</span>
  78 |     | <span class='neutral'>    /// operator of the current owner.</span>
  79 |     | <span class='neutral'>    /// @param _approved The new approved NFT controller</span>
  80 |     | <span class='neutral'>    /// @param _tokenId The NFT to approve</span>
  81 |     | <span class='neutral'>    function approve(address _approved, uint256 _tokenId) external payable;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Enable or disable approval for a third party (&quot;operator&quot;) to manage</span>
  84 |     | <span class='neutral'>    /// all of `msg.sender`&#39;s assets</span>
  85 |     | <span class='neutral'>    /// @dev Emits the ApprovalForAll event. The contract MUST allow</span>
  86 |     | <span class='neutral'>    /// multiple operators per owner.</span>
  87 |     | <span class='neutral'>    /// @param _operator Address to add to the set of authorized operators</span>
  88 |     | <span class='neutral'>    /// @param _approved True if the operator is approved, false to revoke approval</span>
  89 |     | <span class='neutral'>    function setApprovalForAll(address _operator, bool _approved) external;</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /// @notice Get the approved address for a single NFT</span>
  92 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT.</span>
  93 |     | <span class='neutral'>    /// @param _tokenId The NFT to find the approved address for</span>
  94 |     | <span class='neutral'>    /// @return The approved address for this NFT, or the zero address if there is none</span>
  95 |     | <span class='neutral'>    function getApproved(uint256 _tokenId) external view returns (address);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Query if an address is an authorized operator for another address</span>
  98 |     | <span class='neutral'>    /// @param _owner The address that owns the NFTs</span>
  99 |     | <span class='neutral'>    /// @param _operator The address that acts on behalf of the owner</span>
 100 |     | <span class='neutral'>    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise</span>
 101 |     | <span class='neutral'>    function isApprovedForAll(address _owner, address _operator) external view returns (bool);</span>
 102 |     | <span class='neutral'>}</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.</span>
 105 |     | <span class='neutral'>interface IERC721TokenReceiver {</span>
 106 |     | <span class='neutral'>    /// @notice Handle the receipt of an NFT</span>
 107 |     | <span class='neutral'>    /// @dev The ERC721 smart contract calls this function on the recipient</span>
 108 |     | <span class='neutral'>    /// after a `transfer`. This function MAY throw to revert and reject the</span>
 109 |     | <span class='neutral'>    /// transfer. Return of other than the magic value MUST result in the</span>
 110 |     | <span class='neutral'>    /// transaction being reverted.</span>
 111 |     | <span class='neutral'>    /// Note: the contract address is always the message sender.</span>
 112 |     | <span class='neutral'>    /// @param _operator The address which called `safeTransferFrom` function</span>
 113 |     | <span class='neutral'>    /// @param _from The address which previously owned the token</span>
 114 |     | <span class='neutral'>    /// @param _tokenId The NFT identifier which is being transferred</span>
 115 |     | <span class='neutral'>    /// @param _data Additional data with no specified format</span>
 116 |     | <span class='neutral'>    /// @return `bytes4(keccak256(&quot;onERC721Received(address,address,uint256,bytes)&quot;))`</span>
 117 |     | <span class='neutral'>    ///  unless throwing</span>
 118 |     | <span class='neutral'>    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data)</span>
 119 |     | <span class='neutral'>        external</span>
 120 |     | <span class='neutral'>        returns (bytes4);</span>
 121 |     | <span class='neutral'>}</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 124 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 125 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x5b5e139f.</span>
 126 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 127 |     | <span class='neutral'>    /// @notice A descriptive name for a collection of NFTs in this contract</span>
 128 |     | <span class='neutral'>    function name() external view returns (string memory _name);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /// @notice An abbreviated name for NFTs in this contract</span>
 131 |     | <span class='neutral'>    function symbol() external view returns (string memory _symbol);</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.</span>
 134 |     | <span class='neutral'>    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC</span>
 135 |     | <span class='neutral'>    /// 3986. The URI may point to a JSON file that conforms to the &quot;ERC721</span>
 136 |     | <span class='neutral'>    /// Metadata JSON Schema&quot;.</span>
 137 |     | <span class='neutral'>    function tokenURI(uint256 _tokenId) external view returns (string memory);</span>
 138 |     | <span class='neutral'>}</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension</span>
 141 |     | <span class='neutral'>/// @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 142 |     | <span class='neutral'>/// Note: the ERC-165 identifier for this interface is 0x780e9d63.</span>
 143 |     | <span class='neutral'>interface IERC721Enumerable is IERC721 {</span>
 144 |     | <span class='neutral'>    /// @notice Count NFTs tracked by this contract</span>
 145 |     | <span class='neutral'>    /// @return A count of valid NFTs tracked by this contract, where each one of</span>
 146 |     | <span class='neutral'>    /// them has an assigned and queryable owner not equal to the zero address</span>
 147 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice Enumerate valid NFTs</span>
 150 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `totalSupply()`.</span>
 151 |     | <span class='neutral'>    /// @param _index A counter less than `totalSupply()`</span>
 152 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT,</span>
 153 |     | <span class='neutral'>    /// (sort order not specified)</span>
 154 |     | <span class='neutral'>    function tokenByIndex(uint256 _index) external view returns (uint256);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /// @notice Enumerate NFTs assigned to an owner</span>
 157 |     | <span class='neutral'>    /// @dev Throws if `_index` &gt;= `balanceOf(_owner)` or if</span>
 158 |     | <span class='neutral'>    /// `_owner` is the zero address, representing invalid NFTs.</span>
 159 |     | <span class='neutral'>    /// @param _owner An address where we are interested in NFTs owned by them</span>
 160 |     | <span class='neutral'>    /// @param _index A counter less than `balanceOf(_owner)`</span>
 161 |     | <span class='neutral'>    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,</span>
 162 |     | <span class='neutral'>    /// (sort order not specified)</span>
 163 |     | <span class='neutral'>    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);</span>
 164 |     | <span class='neutral'>}</span>
 165 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/interfaces/IMulticall3.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma experimental ABIEncoderV2;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IMulticall3 {</span>
  7 |     | <span class='neutral'>    struct Call {</span>
  8 |     | <span class='neutral'>        address target;</span>
  9 |     | <span class='neutral'>        bytes callData;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct Call3 {</span>
 13 |     | <span class='neutral'>        address target;</span>
 14 |     | <span class='neutral'>        bool allowFailure;</span>
 15 |     | <span class='neutral'>        bytes callData;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    struct Call3Value {</span>
 19 |     | <span class='neutral'>        address target;</span>
 20 |     | <span class='neutral'>        bool allowFailure;</span>
 21 |     | <span class='neutral'>        uint256 value;</span>
 22 |     | <span class='neutral'>        bytes callData;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    struct Result {</span>
 26 |     | <span class='neutral'>        bool success;</span>
 27 |     | <span class='neutral'>        bytes returnData;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function aggregate(Call[] calldata calls)</span>
 31 |     | <span class='neutral'>        external</span>
 32 |     | <span class='neutral'>        payable</span>
 33 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes[] memory returnData);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function aggregate3(Call3[] calldata calls) external payable returns (Result[] memory returnData);</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    function aggregate3Value(Call3Value[] calldata calls) external payable returns (Result[] memory returnData);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    function blockAndAggregate(Call[] calldata calls)</span>
 40 |     | <span class='neutral'>        external</span>
 41 |     | <span class='neutral'>        payable</span>
 42 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    function getBasefee() external view returns (uint256 basefee);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function getBlockHash(uint256 blockNumber) external view returns (bytes32 blockHash);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function getBlockNumber() external view returns (uint256 blockNumber);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function getChainId() external view returns (uint256 chainid);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function getCurrentBlockCoinbase() external view returns (address coinbase);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getCurrentBlockDifficulty() external view returns (uint256 difficulty);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function getCurrentBlockGasLimit() external view returns (uint256 gaslimit);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function getCurrentBlockTimestamp() external view returns (uint256 timestamp);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function getEthBalance(address addr) external view returns (uint256 balance);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function getLastBlockHash() external view returns (bytes32 blockHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function tryAggregate(bool requireSuccess, Call[] calldata calls)</span>
 65 |     | <span class='neutral'>        external</span>
 66 |     | <span class='neutral'>        payable</span>
 67 |     | <span class='neutral'>        returns (Result[] memory returnData);</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    function tryBlockAndAggregate(bool requireSuccess, Call[] calldata calls)</span>
 70 |     | <span class='neutral'>        external</span>
 71 |     | <span class='neutral'>        payable</span>
 72 |     | <span class='neutral'>        returns (uint256 blockNumber, bytes32 blockHash, Result[] memory returnData);</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/mocks/MockERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;../interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC20 is IERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                            METADATA STORAGE</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    uint8 internal _decimals;</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  20 |     | <span class='unexecuted'>        return _name;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  24 |     | <span class='unexecuted'>        return _symbol;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>    function decimals() external view override returns (uint8) {</span>
  28 |     | <span class='unexecuted'>        return _decimals;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  32 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  33 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    uint256 internal _totalSupply;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) internal _allowance;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>    function totalSupply() external view override returns (uint256) {</span>
  42 |     | <span class='unexecuted'>        return _totalSupply;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function balanceOf(address owner) external view override returns (uint256) {</span>
  46 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view override returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return _allowance[owner][spender];</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  55 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    uint256 internal INITIAL_CHAIN_ID;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    bytes32 internal INITIAL_DOMAIN_SEPARATOR;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>                               INITIALIZE</span>
  65 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  68 |     | <span class='neutral'>    bool private initialized;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  71 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  72 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {</span>
  73 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        _name = name_;</span>
  76 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  77 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = _pureChainId();</span>
  80 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        initialized = true;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  86 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  87 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  90 |     | <span class='unexecuted'>        _allowance[msg.sender][spender] = amount;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>        emit Approval(msg.sender, spender, amount);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='unexecuted'>        return true;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
  98 |     | <span class='unexecuted'>        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);</span>
  99 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        return true;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 107 |     | <span class='unexecuted'>        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 112 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='unexecuted'>        emit Transfer(from, to, amount);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 120 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 121 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 122 |     | <span class='neutral'></span>
 123 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 124 |     | <span class='neutral'>        public</span>
 125 |     | <span class='neutral'>        virtual</span>
 126 |     | <span class='unexecuted'>    {</span>
 127 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(</span>
 130 |     | <span class='unexecuted'>            keccak256(</span>
 131 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 132 |     | <span class='neutral'>                    &quot;\x19\x01&quot;,</span>
 133 |     | <span class='unexecuted'>                    DOMAIN_SEPARATOR(),</span>
 134 |     | <span class='unexecuted'>                    keccak256(</span>
 135 |     | <span class='unexecuted'>                        abi.encode(</span>
 136 |     | <span class='unexecuted'>                            keccak256(</span>
 137 |     | <span class='neutral'>                                &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 138 |     | <span class='neutral'>                            ),</span>
 139 |     | <span class='unexecuted'>                            owner,</span>
 140 |     | <span class='unexecuted'>                            spender,</span>
 141 |     | <span class='unexecuted'>                            value,</span>
 142 |     | <span class='unexecuted'>                            nonces[owner]++,</span>
 143 |     | <span class='neutral'>                            deadline</span>
 144 |     | <span class='neutral'>                        )</span>
 145 |     | <span class='neutral'>                    )</span>
 146 |     | <span class='neutral'>                )</span>
 147 |     | <span class='neutral'>            ),</span>
 148 |     | <span class='neutral'>            v,</span>
 149 |     | <span class='neutral'>            r,</span>
 150 |     | <span class='neutral'>            s</span>
 151 |     | <span class='neutral'>        );</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>        _allowance[recoveredAddress][spender] = value;</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 161 |     | <span class='unexecuted'>        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 165 |     | <span class='unexecuted'>        return keccak256(</span>
 166 |     | <span class='unexecuted'>            abi.encode(</span>
 167 |     | <span class='unexecuted'>                keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 168 |     | <span class='unexecuted'>                keccak256(bytes(_name)),</span>
 169 |     | <span class='unexecuted'>                keccak256(&quot;1&quot;),</span>
 170 |     | <span class='unexecuted'>                _pureChainId(),</span>
 171 |     | <span class='unexecuted'>                address(this)</span>
 172 |     | <span class='neutral'>            )</span>
 173 |     | <span class='neutral'>        );</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 177 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 178 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>    function _mint(address to, uint256 amount) internal virtual {</span>
 181 |     | <span class='neutral'>        _totalSupply = _add(_totalSupply, amount);</span>
 182 |     | <span class='neutral'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        emit Transfer(address(0), to, amount);</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function _burn(address from, uint256 amount) internal virtual {</span>
 188 |     | <span class='neutral'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 189 |     | <span class='neutral'>        _totalSupply = _sub(_totalSupply, amount);</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>        emit Transfer(from, address(0), amount);</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 195 |     | <span class='neutral'>                        INTERNAL SAFE MATH LOGIC</span>
 196 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function _add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 199 |     | <span class='unexecuted'>        uint256 c = a + b;</span>
 200 |     | <span class='unexecuted'>        require(c &gt;= a, &quot;ERC20: addition overflow&quot;);</span>
 201 |     | <span class='neutral'>        return c;</span>
 202 |     | <span class='neutral'>    }</span>
 203 |     | <span class='neutral'></span>
 204 |     | <span class='unexecuted'>    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 205 |     | <span class='unexecuted'>        require(a &gt;= b, &quot;ERC20: subtraction underflow&quot;);</span>
 206 |     | <span class='unexecuted'>        return a - b;</span>
 207 |     | <span class='neutral'>    }</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 210 |     | <span class='neutral'>                                HELPERS</span>
 211 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 214 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 215 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 216 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 217 |     | <span class='unexecuted'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 218 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 219 |     | <span class='neutral'>        assembly {</span>
 220 |     | <span class='unexecuted'>            chainId := chainid()</span>
 221 |     | <span class='neutral'>        }</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='unexecuted'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 227 |     | <span class='unexecuted'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 228 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 229 |     | <span class='neutral'>        assembly {</span>
 230 |     | <span class='neutral'>            pureChainId := fnIn</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='unexecuted'>        chainId = pureChainId();</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'>}</span>
 235 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/mocks/MockERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC721Metadata, IERC721TokenReceiver} from &quot;../interfaces/IERC721.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC721 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC721.sol</span>
   8 |     | <span class='unexecuted'>contract MockERC721 is IERC721Metadata {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                         METADATA STORAGE/LOGIC</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='unexecuted'>    function name() external view override returns (string memory) {</span>
  18 |     | <span class='unexecuted'>        return _name;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  22 |     | <span class='unexecuted'>        return _symbol;</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='unexecuted'>    function tokenURI(uint256 id) public view virtual override returns (string memory) {}</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  28 |     | <span class='neutral'>                      ERC721 BALANCE/OWNER STORAGE</span>
  29 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _ownerOf;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='unexecuted'>    function ownerOf(uint256 id) public view virtual override returns (address owner) {</span>
  36 |     | <span class='unexecuted'>        require((owner = _ownerOf[id]) != address(0), &quot;NOT_MINTED&quot;);</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  40 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ZERO_ADDRESS&quot;);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='unexecuted'>        return _balanceOf[owner];</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  46 |     | <span class='neutral'>                         ERC721 APPROVAL STORAGE</span>
  47 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    mapping(uint256 =&gt; address) internal _getApproved;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) internal _isApprovedForAll;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='unexecuted'>    function getApproved(uint256 id) public view virtual override returns (address) {</span>
  54 |     | <span class='unexecuted'>        return _getApproved[id];</span>
  55 |     | <span class='neutral'>    }</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
  58 |     | <span class='unexecuted'>        return _isApprovedForAll[owner][operator];</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  62 |     | <span class='neutral'>                               INITIALIZE</span>
  63 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  66 |     | <span class='neutral'>    bool private initialized;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  69 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  70 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_) public {</span>
  71 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        _name = name_;</span>
  74 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>        initialized = true;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>                              ERC721 LOGIC</span>
  81 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function approve(address spender, uint256 id) public payable virtual override {</span>
  84 |     | <span class='unexecuted'>        address owner = _ownerOf[id];</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='unexecuted'>        require(msg.sender == owner || _isApprovedForAll[owner][msg.sender], &quot;NOT_AUTHORIZED&quot;);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        _getApproved[id] = spender;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='unexecuted'>        emit Approval(owner, spender, id);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
  94 |     | <span class='unexecuted'>        _isApprovedForAll[msg.sender][operator] = approved;</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        emit ApprovalForAll(msg.sender, operator, approved);</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 100 |     | <span class='unexecuted'>        require(from == _ownerOf[id], &quot;WRONG_FROM&quot;);</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='unexecuted'>        require(</span>
 105 |     | <span class='unexecuted'>            msg.sender == from || _isApprovedForAll[from][msg.sender] || msg.sender == _getApproved[id],</span>
 106 |     | <span class='neutral'>            &quot;NOT_AUTHORIZED&quot;</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>        // Underflow of the sender&#39;s balance is impossible because we check for</span>
 110 |     | <span class='neutral'>        // ownership above and the recipient&#39;s balance can&#39;t realistically overflow.</span>
 111 |     | <span class='unexecuted'>        _balanceOf[from]--;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='unexecuted'>        _balanceOf[to]++;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='unexecuted'>        _ownerOf[id] = to;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>        delete _getApproved[id];</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='unexecuted'>        emit Transfer(from, to, id);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id) public payable virtual override {</span>
 123 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        require(</span>
 126 |     | <span class='unexecuted'>            !_isContract(to)</span>
 127 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, &quot;&quot;)</span>
 128 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 129 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 130 |     | <span class='neutral'>        );</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 id, bytes memory data)</span>
 134 |     | <span class='neutral'>        public</span>
 135 |     | <span class='neutral'>        payable</span>
 136 |     | <span class='neutral'>        virtual</span>
 137 |     | <span class='neutral'>        override</span>
 138 |     | <span class='neutral'>    {</span>
 139 |     | <span class='unexecuted'>        transferFrom(from, to, id);</span>
 140 |     | <span class='neutral'></span>
 141 |     | <span class='unexecuted'>        require(</span>
 142 |     | <span class='unexecuted'>            !_isContract(to)</span>
 143 |     | <span class='unexecuted'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, from, id, data)</span>
 144 |     | <span class='unexecuted'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 145 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 150 |     | <span class='neutral'>                              ERC165 LOGIC</span>
 151 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 154 |     | <span class='unexecuted'>        return interfaceId == 0x01ffc9a7 // ERC165 Interface ID for ERC165</span>
 155 |     | <span class='unexecuted'>            || interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721</span>
 156 |     | <span class='unexecuted'>            || interfaceId == 0x5b5e139f; // ERC165 Interface ID for ERC721Metadata</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 160 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 161 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    function _mint(address to, uint256 id) internal virtual {</span>
 164 |     | <span class='neutral'>        require(to != address(0), &quot;INVALID_RECIPIENT&quot;);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>        require(_ownerOf[id] == address(0), &quot;ALREADY_MINTED&quot;);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>        // Counter overflow is incredibly unrealistic.</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>        _balanceOf[to]++;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>        _ownerOf[id] = to;</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>        emit Transfer(address(0), to, id);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    function _burn(uint256 id) internal virtual {</span>
 178 |     | <span class='neutral'>        address owner = _ownerOf[id];</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>        require(owner != address(0), &quot;NOT_MINTED&quot;);</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='neutral'>        _balanceOf[owner]--;</span>
 183 |     | <span class='neutral'></span>
 184 |     | <span class='neutral'>        delete _ownerOf[id];</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>        delete _getApproved[id];</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>        emit Transfer(owner, address(0), id);</span>
 189 |     | <span class='neutral'>    }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 192 |     | <span class='neutral'>                        INTERNAL SAFE MINT LOGIC</span>
 193 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function _safeMint(address to, uint256 id) internal virtual {</span>
 196 |     | <span class='neutral'>        _mint(to, id);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='neutral'>        require(</span>
 199 |     | <span class='neutral'>            !_isContract(to)</span>
 200 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, &quot;&quot;)</span>
 201 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 202 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 203 |     | <span class='neutral'>        );</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    function _safeMint(address to, uint256 id, bytes memory data) internal virtual {</span>
 207 |     | <span class='neutral'>        _mint(to, id);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>        require(</span>
 210 |     | <span class='neutral'>            !_isContract(to)</span>
 211 |     | <span class='neutral'>                || IERC721TokenReceiver(to).onERC721Received(msg.sender, address(0), id, data)</span>
 212 |     | <span class='neutral'>                    == IERC721TokenReceiver.onERC721Received.selector,</span>
 213 |     | <span class='neutral'>            &quot;UNSAFE_RECIPIENT&quot;</span>
 214 |     | <span class='neutral'>        );</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 218 |     | <span class='neutral'>                                HELPERS</span>
 219 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function _isContract(address _addr) private view returns (bool) {</span>
 222 |     | <span class='neutral'>        uint256 codeLength;</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>        // Assembly required for versions &lt; 0.8.0 to check extcodesize.</span>
 225 |     | <span class='neutral'>        assembly {</span>
 226 |     | <span class='unexecuted'>            codeLength := extcodesize(_addr)</span>
 227 |     | <span class='neutral'>        }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>        return codeLength &gt; 0;</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'>}</span>
 232 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/forge-std/src/safeconsole.sol</b>
<code>
     1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
     2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
     3 |     | <span class='neutral'></span>
     4 |     | <span class='neutral'>/// @author philogy &lt;https://github.com/philogy&gt;</span>
     5 |     | <span class='neutral'>/// @dev Code generated automatically by script.</span>
     6 |     | <span class='unexecuted'>library safeconsole {</span>
     7 |     | <span class='neutral'>    uint256 constant CONSOLE_ADDR = 0x000000000000000000000000000000000000000000636F6e736F6c652e6c6f67;</span>
     8 |     | <span class='neutral'></span>
     9 |     | <span class='neutral'>    // Credit to [0age](https://twitter.com/z0age/status/1654922202930888704) and [0xdapper](https://github.com/foundry-rs/forge-std/pull/374)</span>
    10 |     | <span class='neutral'>    // for the view-to-pure log trick.</span>
    11 |     | <span class='neutral'>    function _sendLogPayload(uint256 offset, uint256 size) private pure {</span>
    12 |     | <span class='neutral'>        function(uint256, uint256) internal view fnIn = _sendLogPayloadView;</span>
    13 |     | <span class='neutral'>        function(uint256, uint256) internal pure pureSendLogPayload;</span>
    14 |     | <span class='neutral'>        assembly {</span>
    15 |     | <span class='neutral'>            pureSendLogPayload := fnIn</span>
    16 |     | <span class='neutral'>        }</span>
    17 |     | <span class='neutral'>        pureSendLogPayload(offset, size);</span>
    18 |     | <span class='neutral'>    }</span>
    19 |     | <span class='neutral'></span>
    20 |     | <span class='neutral'>    function _sendLogPayloadView(uint256 offset, uint256 size) private view {</span>
    21 |     | <span class='neutral'>        assembly {</span>
    22 |     | <span class='neutral'>            pop(staticcall(gas(), CONSOLE_ADDR, offset, size, 0x0, 0x0))</span>
    23 |     | <span class='neutral'>        }</span>
    24 |     | <span class='neutral'>    }</span>
    25 |     | <span class='neutral'></span>
    26 |     | <span class='neutral'>    function _memcopy(uint256 fromOffset, uint256 toOffset, uint256 length) private pure {</span>
    27 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal view fnIn = _memcopyView;</span>
    28 |     | <span class='neutral'>        function(uint256, uint256, uint256) internal pure pureMemcopy;</span>
    29 |     | <span class='neutral'>        assembly {</span>
    30 |     | <span class='neutral'>            pureMemcopy := fnIn</span>
    31 |     | <span class='neutral'>        }</span>
    32 |     | <span class='neutral'>        pureMemcopy(fromOffset, toOffset, length);</span>
    33 |     | <span class='neutral'>    }</span>
    34 |     | <span class='neutral'></span>
    35 |     | <span class='neutral'>    function _memcopyView(uint256 fromOffset, uint256 toOffset, uint256 length) private view {</span>
    36 |     | <span class='neutral'>        assembly {</span>
    37 |     | <span class='neutral'>            pop(staticcall(gas(), 0x4, fromOffset, length, toOffset, length))</span>
    38 |     | <span class='neutral'>        }</span>
    39 |     | <span class='neutral'>    }</span>
    40 |     | <span class='neutral'></span>
    41 |     | <span class='neutral'>    function logMemory(uint256 offset, uint256 length) internal pure {</span>
    42 |     | <span class='neutral'>        if (offset &gt;= 0x60) {</span>
    43 |     | <span class='neutral'>            // Sufficient memory before slice to prepare call header.</span>
    44 |     | <span class='neutral'>            bytes32 m0;</span>
    45 |     | <span class='neutral'>            bytes32 m1;</span>
    46 |     | <span class='neutral'>            bytes32 m2;</span>
    47 |     | <span class='neutral'>            assembly {</span>
    48 |     | <span class='neutral'>                m0 := mload(sub(offset, 0x60))</span>
    49 |     | <span class='neutral'>                m1 := mload(sub(offset, 0x40))</span>
    50 |     | <span class='neutral'>                m2 := mload(sub(offset, 0x20))</span>
    51 |     | <span class='neutral'>                // Selector of `logBytes(bytes)`.</span>
    52 |     | <span class='neutral'>                mstore(sub(offset, 0x60), 0xe17bf956)</span>
    53 |     | <span class='neutral'>                mstore(sub(offset, 0x40), 0x20)</span>
    54 |     | <span class='neutral'>                mstore(sub(offset, 0x20), length)</span>
    55 |     | <span class='neutral'>            }</span>
    56 |     | <span class='neutral'>            _sendLogPayload(offset - 0x44, length + 0x44);</span>
    57 |     | <span class='neutral'>            assembly {</span>
    58 |     | <span class='neutral'>                mstore(sub(offset, 0x60), m0)</span>
    59 |     | <span class='neutral'>                mstore(sub(offset, 0x40), m1)</span>
    60 |     | <span class='neutral'>                mstore(sub(offset, 0x20), m2)</span>
    61 |     | <span class='neutral'>            }</span>
    62 |     | <span class='neutral'>        } else {</span>
    63 |     | <span class='neutral'>            // Insufficient space, so copy slice forward, add header and reverse.</span>
    64 |     | <span class='neutral'>            bytes32 m0;</span>
    65 |     | <span class='neutral'>            bytes32 m1;</span>
    66 |     | <span class='neutral'>            bytes32 m2;</span>
    67 |     | <span class='neutral'>            uint256 endOffset = offset + length;</span>
    68 |     | <span class='neutral'>            assembly {</span>
    69 |     | <span class='neutral'>                m0 := mload(add(endOffset, 0x00))</span>
    70 |     | <span class='neutral'>                m1 := mload(add(endOffset, 0x20))</span>
    71 |     | <span class='neutral'>                m2 := mload(add(endOffset, 0x40))</span>
    72 |     | <span class='neutral'>            }</span>
    73 |     | <span class='neutral'>            _memcopy(offset, offset + 0x60, length);</span>
    74 |     | <span class='neutral'>            assembly {</span>
    75 |     | <span class='neutral'>                // Selector of `logBytes(bytes)`.</span>
    76 |     | <span class='neutral'>                mstore(add(offset, 0x00), 0xe17bf956)</span>
    77 |     | <span class='neutral'>                mstore(add(offset, 0x20), 0x20)</span>
    78 |     | <span class='neutral'>                mstore(add(offset, 0x40), length)</span>
    79 |     | <span class='neutral'>            }</span>
    80 |     | <span class='neutral'>            _sendLogPayload(offset + 0x1c, length + 0x44);</span>
    81 |     | <span class='neutral'>            _memcopy(offset + 0x60, offset, length);</span>
    82 |     | <span class='neutral'>            assembly {</span>
    83 |     | <span class='neutral'>                mstore(add(endOffset, 0x00), m0)</span>
    84 |     | <span class='neutral'>                mstore(add(endOffset, 0x20), m1)</span>
    85 |     | <span class='neutral'>                mstore(add(endOffset, 0x40), m2)</span>
    86 |     | <span class='neutral'>            }</span>
    87 |     | <span class='neutral'>        }</span>
    88 |     | <span class='neutral'>    }</span>
    89 |     | <span class='neutral'></span>
    90 |     | <span class='neutral'>    function log(address p0) internal pure {</span>
    91 |     | <span class='neutral'>        bytes32 m0;</span>
    92 |     | <span class='neutral'>        bytes32 m1;</span>
    93 |     | <span class='neutral'>        assembly {</span>
    94 |     | <span class='neutral'>            m0 := mload(0x00)</span>
    95 |     | <span class='neutral'>            m1 := mload(0x20)</span>
    96 |     | <span class='neutral'>            // Selector of `log(address)`.</span>
    97 |     | <span class='neutral'>            mstore(0x00, 0x2c2ecbc2)</span>
    98 |     | <span class='neutral'>            mstore(0x20, p0)</span>
    99 |     | <span class='neutral'>        }</span>
   100 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   101 |     | <span class='neutral'>        assembly {</span>
   102 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   103 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   104 |     | <span class='neutral'>        }</span>
   105 |     | <span class='neutral'>    }</span>
   106 |     | <span class='neutral'></span>
   107 |     | <span class='neutral'>    function log(bool p0) internal pure {</span>
   108 |     | <span class='neutral'>        bytes32 m0;</span>
   109 |     | <span class='neutral'>        bytes32 m1;</span>
   110 |     | <span class='neutral'>        assembly {</span>
   111 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   112 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   113 |     | <span class='neutral'>            // Selector of `log(bool)`.</span>
   114 |     | <span class='neutral'>            mstore(0x00, 0x32458eed)</span>
   115 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   116 |     | <span class='neutral'>        }</span>
   117 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   118 |     | <span class='neutral'>        assembly {</span>
   119 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   120 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   121 |     | <span class='neutral'>        }</span>
   122 |     | <span class='neutral'>    }</span>
   123 |     | <span class='neutral'></span>
   124 |     | <span class='neutral'>    function log(uint256 p0) internal pure {</span>
   125 |     | <span class='neutral'>        bytes32 m0;</span>
   126 |     | <span class='neutral'>        bytes32 m1;</span>
   127 |     | <span class='neutral'>        assembly {</span>
   128 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   129 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   130 |     | <span class='neutral'>            // Selector of `log(uint256)`.</span>
   131 |     | <span class='neutral'>            mstore(0x00, 0xf82c50f1)</span>
   132 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   133 |     | <span class='neutral'>        }</span>
   134 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x24);</span>
   135 |     | <span class='neutral'>        assembly {</span>
   136 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   137 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   138 |     | <span class='neutral'>        }</span>
   139 |     | <span class='neutral'>    }</span>
   140 |     | <span class='neutral'></span>
   141 |     | <span class='neutral'>    function log(bytes32 p0) internal pure {</span>
   142 |     | <span class='neutral'>        bytes32 m0;</span>
   143 |     | <span class='neutral'>        bytes32 m1;</span>
   144 |     | <span class='neutral'>        bytes32 m2;</span>
   145 |     | <span class='neutral'>        bytes32 m3;</span>
   146 |     | <span class='neutral'>        assembly {</span>
   147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   148 |     | <span class='neutral'>                let length := 0</span>
   149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   150 |     | <span class='neutral'>                mstore(pos, length)</span>
   151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   153 |     | <span class='neutral'>            }</span>
   154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   158 |     | <span class='neutral'>            // Selector of `log(string)`.</span>
   159 |     | <span class='neutral'>            mstore(0x00, 0x41304fac)</span>
   160 |     | <span class='neutral'>            mstore(0x20, 0x20)</span>
   161 |     | <span class='neutral'>            writeString(0x40, p0)</span>
   162 |     | <span class='neutral'>        }</span>
   163 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   164 |     | <span class='neutral'>        assembly {</span>
   165 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   166 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   167 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   168 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   169 |     | <span class='neutral'>        }</span>
   170 |     | <span class='neutral'>    }</span>
   171 |     | <span class='neutral'></span>
   172 |     | <span class='neutral'>    function log(address p0, address p1) internal pure {</span>
   173 |     | <span class='neutral'>        bytes32 m0;</span>
   174 |     | <span class='neutral'>        bytes32 m1;</span>
   175 |     | <span class='neutral'>        bytes32 m2;</span>
   176 |     | <span class='neutral'>        assembly {</span>
   177 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   178 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   179 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   180 |     | <span class='neutral'>            // Selector of `log(address,address)`.</span>
   181 |     | <span class='neutral'>            mstore(0x00, 0xdaf0d4aa)</span>
   182 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   183 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   184 |     | <span class='neutral'>        }</span>
   185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   186 |     | <span class='neutral'>        assembly {</span>
   187 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   188 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   189 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   190 |     | <span class='neutral'>        }</span>
   191 |     | <span class='neutral'>    }</span>
   192 |     | <span class='neutral'></span>
   193 |     | <span class='neutral'>    function log(address p0, bool p1) internal pure {</span>
   194 |     | <span class='neutral'>        bytes32 m0;</span>
   195 |     | <span class='neutral'>        bytes32 m1;</span>
   196 |     | <span class='neutral'>        bytes32 m2;</span>
   197 |     | <span class='neutral'>        assembly {</span>
   198 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   199 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   200 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   201 |     | <span class='neutral'>            // Selector of `log(address,bool)`.</span>
   202 |     | <span class='neutral'>            mstore(0x00, 0x75b605d3)</span>
   203 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   204 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   205 |     | <span class='neutral'>        }</span>
   206 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   207 |     | <span class='neutral'>        assembly {</span>
   208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   211 |     | <span class='neutral'>        }</span>
   212 |     | <span class='neutral'>    }</span>
   213 |     | <span class='neutral'></span>
   214 |     | <span class='neutral'>    function log(address p0, uint256 p1) internal pure {</span>
   215 |     | <span class='neutral'>        bytes32 m0;</span>
   216 |     | <span class='neutral'>        bytes32 m1;</span>
   217 |     | <span class='neutral'>        bytes32 m2;</span>
   218 |     | <span class='neutral'>        assembly {</span>
   219 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   220 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   221 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   222 |     | <span class='neutral'>            // Selector of `log(address,uint256)`.</span>
   223 |     | <span class='neutral'>            mstore(0x00, 0x8309e8a8)</span>
   224 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   225 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   226 |     | <span class='neutral'>        }</span>
   227 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   228 |     | <span class='neutral'>        assembly {</span>
   229 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   230 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   231 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   232 |     | <span class='neutral'>        }</span>
   233 |     | <span class='neutral'>    }</span>
   234 |     | <span class='neutral'></span>
   235 |     | <span class='neutral'>    function log(address p0, bytes32 p1) internal pure {</span>
   236 |     | <span class='neutral'>        bytes32 m0;</span>
   237 |     | <span class='neutral'>        bytes32 m1;</span>
   238 |     | <span class='neutral'>        bytes32 m2;</span>
   239 |     | <span class='neutral'>        bytes32 m3;</span>
   240 |     | <span class='neutral'>        bytes32 m4;</span>
   241 |     | <span class='neutral'>        assembly {</span>
   242 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   243 |     | <span class='neutral'>                let length := 0</span>
   244 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   245 |     | <span class='neutral'>                mstore(pos, length)</span>
   246 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   247 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   248 |     | <span class='neutral'>            }</span>
   249 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   250 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   251 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   252 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   253 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   254 |     | <span class='neutral'>            // Selector of `log(address,string)`.</span>
   255 |     | <span class='neutral'>            mstore(0x00, 0x759f86bb)</span>
   256 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   257 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   258 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   259 |     | <span class='neutral'>        }</span>
   260 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   261 |     | <span class='neutral'>        assembly {</span>
   262 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   263 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   264 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   265 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   266 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   267 |     | <span class='neutral'>        }</span>
   268 |     | <span class='neutral'>    }</span>
   269 |     | <span class='neutral'></span>
   270 |     | <span class='neutral'>    function log(bool p0, address p1) internal pure {</span>
   271 |     | <span class='neutral'>        bytes32 m0;</span>
   272 |     | <span class='neutral'>        bytes32 m1;</span>
   273 |     | <span class='neutral'>        bytes32 m2;</span>
   274 |     | <span class='neutral'>        assembly {</span>
   275 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   276 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   277 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   278 |     | <span class='neutral'>            // Selector of `log(bool,address)`.</span>
   279 |     | <span class='neutral'>            mstore(0x00, 0x853c4849)</span>
   280 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   281 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   282 |     | <span class='neutral'>        }</span>
   283 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   284 |     | <span class='neutral'>        assembly {</span>
   285 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   286 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   287 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   288 |     | <span class='neutral'>        }</span>
   289 |     | <span class='neutral'>    }</span>
   290 |     | <span class='neutral'></span>
   291 |     | <span class='neutral'>    function log(bool p0, bool p1) internal pure {</span>
   292 |     | <span class='neutral'>        bytes32 m0;</span>
   293 |     | <span class='neutral'>        bytes32 m1;</span>
   294 |     | <span class='neutral'>        bytes32 m2;</span>
   295 |     | <span class='neutral'>        assembly {</span>
   296 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   297 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   298 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   299 |     | <span class='neutral'>            // Selector of `log(bool,bool)`.</span>
   300 |     | <span class='neutral'>            mstore(0x00, 0x2a110e83)</span>
   301 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   302 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   303 |     | <span class='neutral'>        }</span>
   304 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   305 |     | <span class='neutral'>        assembly {</span>
   306 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   307 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   308 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   309 |     | <span class='neutral'>        }</span>
   310 |     | <span class='neutral'>    }</span>
   311 |     | <span class='neutral'></span>
   312 |     | <span class='neutral'>    function log(bool p0, uint256 p1) internal pure {</span>
   313 |     | <span class='neutral'>        bytes32 m0;</span>
   314 |     | <span class='neutral'>        bytes32 m1;</span>
   315 |     | <span class='neutral'>        bytes32 m2;</span>
   316 |     | <span class='neutral'>        assembly {</span>
   317 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   318 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   319 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   320 |     | <span class='neutral'>            // Selector of `log(bool,uint256)`.</span>
   321 |     | <span class='neutral'>            mstore(0x00, 0x399174d3)</span>
   322 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   323 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   324 |     | <span class='neutral'>        }</span>
   325 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   326 |     | <span class='neutral'>        assembly {</span>
   327 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   328 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   329 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   330 |     | <span class='neutral'>        }</span>
   331 |     | <span class='neutral'>    }</span>
   332 |     | <span class='neutral'></span>
   333 |     | <span class='neutral'>    function log(bool p0, bytes32 p1) internal pure {</span>
   334 |     | <span class='neutral'>        bytes32 m0;</span>
   335 |     | <span class='neutral'>        bytes32 m1;</span>
   336 |     | <span class='neutral'>        bytes32 m2;</span>
   337 |     | <span class='neutral'>        bytes32 m3;</span>
   338 |     | <span class='neutral'>        bytes32 m4;</span>
   339 |     | <span class='neutral'>        assembly {</span>
   340 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   341 |     | <span class='neutral'>                let length := 0</span>
   342 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   343 |     | <span class='neutral'>                mstore(pos, length)</span>
   344 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   345 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   346 |     | <span class='neutral'>            }</span>
   347 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   348 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   349 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   350 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   351 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   352 |     | <span class='neutral'>            // Selector of `log(bool,string)`.</span>
   353 |     | <span class='neutral'>            mstore(0x00, 0x8feac525)</span>
   354 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   355 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   356 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   357 |     | <span class='neutral'>        }</span>
   358 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   359 |     | <span class='neutral'>        assembly {</span>
   360 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   361 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   362 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   363 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   364 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   365 |     | <span class='neutral'>        }</span>
   366 |     | <span class='neutral'>    }</span>
   367 |     | <span class='neutral'></span>
   368 |     | <span class='neutral'>    function log(uint256 p0, address p1) internal pure {</span>
   369 |     | <span class='neutral'>        bytes32 m0;</span>
   370 |     | <span class='neutral'>        bytes32 m1;</span>
   371 |     | <span class='neutral'>        bytes32 m2;</span>
   372 |     | <span class='neutral'>        assembly {</span>
   373 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   374 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   375 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   376 |     | <span class='neutral'>            // Selector of `log(uint256,address)`.</span>
   377 |     | <span class='neutral'>            mstore(0x00, 0x69276c86)</span>
   378 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   379 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   380 |     | <span class='neutral'>        }</span>
   381 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   382 |     | <span class='neutral'>        assembly {</span>
   383 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   384 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   385 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   386 |     | <span class='neutral'>        }</span>
   387 |     | <span class='neutral'>    }</span>
   388 |     | <span class='neutral'></span>
   389 |     | <span class='neutral'>    function log(uint256 p0, bool p1) internal pure {</span>
   390 |     | <span class='neutral'>        bytes32 m0;</span>
   391 |     | <span class='neutral'>        bytes32 m1;</span>
   392 |     | <span class='neutral'>        bytes32 m2;</span>
   393 |     | <span class='neutral'>        assembly {</span>
   394 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   395 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   396 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   397 |     | <span class='neutral'>            // Selector of `log(uint256,bool)`.</span>
   398 |     | <span class='neutral'>            mstore(0x00, 0x1c9d7eb3)</span>
   399 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   400 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   401 |     | <span class='neutral'>        }</span>
   402 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   403 |     | <span class='neutral'>        assembly {</span>
   404 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   405 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   406 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   407 |     | <span class='neutral'>        }</span>
   408 |     | <span class='neutral'>    }</span>
   409 |     | <span class='neutral'></span>
   410 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1) internal pure {</span>
   411 |     | <span class='neutral'>        bytes32 m0;</span>
   412 |     | <span class='neutral'>        bytes32 m1;</span>
   413 |     | <span class='neutral'>        bytes32 m2;</span>
   414 |     | <span class='neutral'>        assembly {</span>
   415 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   416 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   417 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   418 |     | <span class='neutral'>            // Selector of `log(uint256,uint256)`.</span>
   419 |     | <span class='neutral'>            mstore(0x00, 0xf666715a)</span>
   420 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   421 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   422 |     | <span class='neutral'>        }</span>
   423 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x44);</span>
   424 |     | <span class='neutral'>        assembly {</span>
   425 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   426 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   427 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   428 |     | <span class='neutral'>        }</span>
   429 |     | <span class='neutral'>    }</span>
   430 |     | <span class='neutral'></span>
   431 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1) internal pure {</span>
   432 |     | <span class='neutral'>        bytes32 m0;</span>
   433 |     | <span class='neutral'>        bytes32 m1;</span>
   434 |     | <span class='neutral'>        bytes32 m2;</span>
   435 |     | <span class='neutral'>        bytes32 m3;</span>
   436 |     | <span class='neutral'>        bytes32 m4;</span>
   437 |     | <span class='neutral'>        assembly {</span>
   438 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   439 |     | <span class='neutral'>                let length := 0</span>
   440 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   441 |     | <span class='neutral'>                mstore(pos, length)</span>
   442 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   443 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   444 |     | <span class='neutral'>            }</span>
   445 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   446 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   447 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   448 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   449 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   450 |     | <span class='neutral'>            // Selector of `log(uint256,string)`.</span>
   451 |     | <span class='neutral'>            mstore(0x00, 0x643fd0df)</span>
   452 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   453 |     | <span class='neutral'>            mstore(0x40, 0x40)</span>
   454 |     | <span class='neutral'>            writeString(0x60, p1)</span>
   455 |     | <span class='neutral'>        }</span>
   456 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   457 |     | <span class='neutral'>        assembly {</span>
   458 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   459 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   460 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   461 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   462 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   463 |     | <span class='neutral'>        }</span>
   464 |     | <span class='neutral'>    }</span>
   465 |     | <span class='neutral'></span>
   466 |     | <span class='neutral'>    function log(bytes32 p0, address p1) internal pure {</span>
   467 |     | <span class='neutral'>        bytes32 m0;</span>
   468 |     | <span class='neutral'>        bytes32 m1;</span>
   469 |     | <span class='neutral'>        bytes32 m2;</span>
   470 |     | <span class='neutral'>        bytes32 m3;</span>
   471 |     | <span class='neutral'>        bytes32 m4;</span>
   472 |     | <span class='neutral'>        assembly {</span>
   473 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   474 |     | <span class='neutral'>                let length := 0</span>
   475 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   476 |     | <span class='neutral'>                mstore(pos, length)</span>
   477 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   478 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   479 |     | <span class='neutral'>            }</span>
   480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   485 |     | <span class='neutral'>            // Selector of `log(string,address)`.</span>
   486 |     | <span class='neutral'>            mstore(0x00, 0x319af333)</span>
   487 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   488 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   489 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   490 |     | <span class='neutral'>        }</span>
   491 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   492 |     | <span class='neutral'>        assembly {</span>
   493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   498 |     | <span class='neutral'>        }</span>
   499 |     | <span class='neutral'>    }</span>
   500 |     | <span class='neutral'></span>
   501 |     | <span class='neutral'>    function log(bytes32 p0, bool p1) internal pure {</span>
   502 |     | <span class='neutral'>        bytes32 m0;</span>
   503 |     | <span class='neutral'>        bytes32 m1;</span>
   504 |     | <span class='neutral'>        bytes32 m2;</span>
   505 |     | <span class='neutral'>        bytes32 m3;</span>
   506 |     | <span class='neutral'>        bytes32 m4;</span>
   507 |     | <span class='neutral'>        assembly {</span>
   508 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   509 |     | <span class='neutral'>                let length := 0</span>
   510 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   511 |     | <span class='neutral'>                mstore(pos, length)</span>
   512 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   513 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   514 |     | <span class='neutral'>            }</span>
   515 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   516 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   517 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   518 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   519 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   520 |     | <span class='neutral'>            // Selector of `log(string,bool)`.</span>
   521 |     | <span class='neutral'>            mstore(0x00, 0xc3b55635)</span>
   522 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   523 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   524 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   525 |     | <span class='neutral'>        }</span>
   526 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   527 |     | <span class='neutral'>        assembly {</span>
   528 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   529 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   530 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   531 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   532 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   533 |     | <span class='neutral'>        }</span>
   534 |     | <span class='neutral'>    }</span>
   535 |     | <span class='neutral'></span>
   536 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1) internal pure {</span>
   537 |     | <span class='neutral'>        bytes32 m0;</span>
   538 |     | <span class='neutral'>        bytes32 m1;</span>
   539 |     | <span class='neutral'>        bytes32 m2;</span>
   540 |     | <span class='neutral'>        bytes32 m3;</span>
   541 |     | <span class='neutral'>        bytes32 m4;</span>
   542 |     | <span class='neutral'>        assembly {</span>
   543 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   544 |     | <span class='neutral'>                let length := 0</span>
   545 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   546 |     | <span class='neutral'>                mstore(pos, length)</span>
   547 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   548 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   549 |     | <span class='neutral'>            }</span>
   550 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   551 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   552 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   553 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   554 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   555 |     | <span class='neutral'>            // Selector of `log(string,uint256)`.</span>
   556 |     | <span class='neutral'>            mstore(0x00, 0xb60e72cc)</span>
   557 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   558 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   559 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   560 |     | <span class='neutral'>        }</span>
   561 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
   562 |     | <span class='neutral'>        assembly {</span>
   563 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   564 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   565 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   566 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   567 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   568 |     | <span class='neutral'>        }</span>
   569 |     | <span class='neutral'>    }</span>
   570 |     | <span class='neutral'></span>
   571 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1) internal pure {</span>
   572 |     | <span class='neutral'>        bytes32 m0;</span>
   573 |     | <span class='neutral'>        bytes32 m1;</span>
   574 |     | <span class='neutral'>        bytes32 m2;</span>
   575 |     | <span class='neutral'>        bytes32 m3;</span>
   576 |     | <span class='neutral'>        bytes32 m4;</span>
   577 |     | <span class='neutral'>        bytes32 m5;</span>
   578 |     | <span class='neutral'>        bytes32 m6;</span>
   579 |     | <span class='neutral'>        assembly {</span>
   580 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   581 |     | <span class='neutral'>                let length := 0</span>
   582 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   583 |     | <span class='neutral'>                mstore(pos, length)</span>
   584 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   585 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   586 |     | <span class='neutral'>            }</span>
   587 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   588 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   589 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   590 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   591 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   592 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   593 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
   594 |     | <span class='neutral'>            // Selector of `log(string,string)`.</span>
   595 |     | <span class='neutral'>            mstore(0x00, 0x4b5c4277)</span>
   596 |     | <span class='neutral'>            mstore(0x20, 0x40)</span>
   597 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
   598 |     | <span class='neutral'>            writeString(0x60, p0)</span>
   599 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
   600 |     | <span class='neutral'>        }</span>
   601 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
   602 |     | <span class='neutral'>        assembly {</span>
   603 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   604 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   605 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   606 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   607 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   608 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   609 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
   610 |     | <span class='neutral'>        }</span>
   611 |     | <span class='neutral'>    }</span>
   612 |     | <span class='neutral'></span>
   613 |     | <span class='neutral'>    function log(address p0, address p1, address p2) internal pure {</span>
   614 |     | <span class='neutral'>        bytes32 m0;</span>
   615 |     | <span class='neutral'>        bytes32 m1;</span>
   616 |     | <span class='neutral'>        bytes32 m2;</span>
   617 |     | <span class='neutral'>        bytes32 m3;</span>
   618 |     | <span class='neutral'>        assembly {</span>
   619 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   620 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   621 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   622 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   623 |     | <span class='neutral'>            // Selector of `log(address,address,address)`.</span>
   624 |     | <span class='neutral'>            mstore(0x00, 0x018c84c2)</span>
   625 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   626 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   627 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   628 |     | <span class='neutral'>        }</span>
   629 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   630 |     | <span class='neutral'>        assembly {</span>
   631 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   632 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   633 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   634 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   635 |     | <span class='neutral'>        }</span>
   636 |     | <span class='neutral'>    }</span>
   637 |     | <span class='neutral'></span>
   638 |     | <span class='neutral'>    function log(address p0, address p1, bool p2) internal pure {</span>
   639 |     | <span class='neutral'>        bytes32 m0;</span>
   640 |     | <span class='neutral'>        bytes32 m1;</span>
   641 |     | <span class='neutral'>        bytes32 m2;</span>
   642 |     | <span class='neutral'>        bytes32 m3;</span>
   643 |     | <span class='neutral'>        assembly {</span>
   644 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   645 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   646 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   647 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   648 |     | <span class='neutral'>            // Selector of `log(address,address,bool)`.</span>
   649 |     | <span class='neutral'>            mstore(0x00, 0xf2a66286)</span>
   650 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   651 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   652 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   653 |     | <span class='neutral'>        }</span>
   654 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   655 |     | <span class='neutral'>        assembly {</span>
   656 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   657 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   658 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   659 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   660 |     | <span class='neutral'>        }</span>
   661 |     | <span class='neutral'>    }</span>
   662 |     | <span class='neutral'></span>
   663 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2) internal pure {</span>
   664 |     | <span class='neutral'>        bytes32 m0;</span>
   665 |     | <span class='neutral'>        bytes32 m1;</span>
   666 |     | <span class='neutral'>        bytes32 m2;</span>
   667 |     | <span class='neutral'>        bytes32 m3;</span>
   668 |     | <span class='neutral'>        assembly {</span>
   669 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   670 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   671 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   672 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   673 |     | <span class='neutral'>            // Selector of `log(address,address,uint256)`.</span>
   674 |     | <span class='neutral'>            mstore(0x00, 0x17fe6185)</span>
   675 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   676 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   677 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   678 |     | <span class='neutral'>        }</span>
   679 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   680 |     | <span class='neutral'>        assembly {</span>
   681 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   682 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   683 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   684 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   685 |     | <span class='neutral'>        }</span>
   686 |     | <span class='neutral'>    }</span>
   687 |     | <span class='neutral'></span>
   688 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2) internal pure {</span>
   689 |     | <span class='neutral'>        bytes32 m0;</span>
   690 |     | <span class='neutral'>        bytes32 m1;</span>
   691 |     | <span class='neutral'>        bytes32 m2;</span>
   692 |     | <span class='neutral'>        bytes32 m3;</span>
   693 |     | <span class='neutral'>        bytes32 m4;</span>
   694 |     | <span class='neutral'>        bytes32 m5;</span>
   695 |     | <span class='neutral'>        assembly {</span>
   696 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   697 |     | <span class='neutral'>                let length := 0</span>
   698 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   699 |     | <span class='neutral'>                mstore(pos, length)</span>
   700 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   701 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   702 |     | <span class='neutral'>            }</span>
   703 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   704 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   705 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   706 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   707 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   708 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   709 |     | <span class='neutral'>            // Selector of `log(address,address,string)`.</span>
   710 |     | <span class='neutral'>            mstore(0x00, 0x007150be)</span>
   711 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   712 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   713 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   714 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   715 |     | <span class='neutral'>        }</span>
   716 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   717 |     | <span class='neutral'>        assembly {</span>
   718 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   719 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   720 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   721 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   722 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   723 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   724 |     | <span class='neutral'>        }</span>
   725 |     | <span class='neutral'>    }</span>
   726 |     | <span class='neutral'></span>
   727 |     | <span class='neutral'>    function log(address p0, bool p1, address p2) internal pure {</span>
   728 |     | <span class='neutral'>        bytes32 m0;</span>
   729 |     | <span class='neutral'>        bytes32 m1;</span>
   730 |     | <span class='neutral'>        bytes32 m2;</span>
   731 |     | <span class='neutral'>        bytes32 m3;</span>
   732 |     | <span class='neutral'>        assembly {</span>
   733 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   734 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   735 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   736 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   737 |     | <span class='neutral'>            // Selector of `log(address,bool,address)`.</span>
   738 |     | <span class='neutral'>            mstore(0x00, 0xf11699ed)</span>
   739 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   740 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   741 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   742 |     | <span class='neutral'>        }</span>
   743 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   744 |     | <span class='neutral'>        assembly {</span>
   745 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   746 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   747 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   748 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   749 |     | <span class='neutral'>        }</span>
   750 |     | <span class='neutral'>    }</span>
   751 |     | <span class='neutral'></span>
   752 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2) internal pure {</span>
   753 |     | <span class='neutral'>        bytes32 m0;</span>
   754 |     | <span class='neutral'>        bytes32 m1;</span>
   755 |     | <span class='neutral'>        bytes32 m2;</span>
   756 |     | <span class='neutral'>        bytes32 m3;</span>
   757 |     | <span class='neutral'>        assembly {</span>
   758 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   759 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   760 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   761 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   762 |     | <span class='neutral'>            // Selector of `log(address,bool,bool)`.</span>
   763 |     | <span class='neutral'>            mstore(0x00, 0xeb830c92)</span>
   764 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   765 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   766 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   767 |     | <span class='neutral'>        }</span>
   768 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   769 |     | <span class='neutral'>        assembly {</span>
   770 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   771 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   772 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   773 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   774 |     | <span class='neutral'>        }</span>
   775 |     | <span class='neutral'>    }</span>
   776 |     | <span class='neutral'></span>
   777 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2) internal pure {</span>
   778 |     | <span class='neutral'>        bytes32 m0;</span>
   779 |     | <span class='neutral'>        bytes32 m1;</span>
   780 |     | <span class='neutral'>        bytes32 m2;</span>
   781 |     | <span class='neutral'>        bytes32 m3;</span>
   782 |     | <span class='neutral'>        assembly {</span>
   783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   787 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256)`.</span>
   788 |     | <span class='neutral'>            mstore(0x00, 0x9c4f99fb)</span>
   789 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   790 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   791 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   792 |     | <span class='neutral'>        }</span>
   793 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   794 |     | <span class='neutral'>        assembly {</span>
   795 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   796 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   797 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   798 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   799 |     | <span class='neutral'>        }</span>
   800 |     | <span class='neutral'>    }</span>
   801 |     | <span class='neutral'></span>
   802 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2) internal pure {</span>
   803 |     | <span class='neutral'>        bytes32 m0;</span>
   804 |     | <span class='neutral'>        bytes32 m1;</span>
   805 |     | <span class='neutral'>        bytes32 m2;</span>
   806 |     | <span class='neutral'>        bytes32 m3;</span>
   807 |     | <span class='neutral'>        bytes32 m4;</span>
   808 |     | <span class='neutral'>        bytes32 m5;</span>
   809 |     | <span class='neutral'>        assembly {</span>
   810 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   811 |     | <span class='neutral'>                let length := 0</span>
   812 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   813 |     | <span class='neutral'>                mstore(pos, length)</span>
   814 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   815 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   816 |     | <span class='neutral'>            }</span>
   817 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   818 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   819 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   820 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   821 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   822 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   823 |     | <span class='neutral'>            // Selector of `log(address,bool,string)`.</span>
   824 |     | <span class='neutral'>            mstore(0x00, 0x212255cc)</span>
   825 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   826 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   827 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   828 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   829 |     | <span class='neutral'>        }</span>
   830 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   831 |     | <span class='neutral'>        assembly {</span>
   832 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   833 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   834 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   835 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   836 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   837 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   838 |     | <span class='neutral'>        }</span>
   839 |     | <span class='neutral'>    }</span>
   840 |     | <span class='neutral'></span>
   841 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2) internal pure {</span>
   842 |     | <span class='neutral'>        bytes32 m0;</span>
   843 |     | <span class='neutral'>        bytes32 m1;</span>
   844 |     | <span class='neutral'>        bytes32 m2;</span>
   845 |     | <span class='neutral'>        bytes32 m3;</span>
   846 |     | <span class='neutral'>        assembly {</span>
   847 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   848 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   849 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   850 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   851 |     | <span class='neutral'>            // Selector of `log(address,uint256,address)`.</span>
   852 |     | <span class='neutral'>            mstore(0x00, 0x7bc0d848)</span>
   853 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   854 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   855 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   856 |     | <span class='neutral'>        }</span>
   857 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   858 |     | <span class='neutral'>        assembly {</span>
   859 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   860 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   861 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   862 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   863 |     | <span class='neutral'>        }</span>
   864 |     | <span class='neutral'>    }</span>
   865 |     | <span class='neutral'></span>
   866 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2) internal pure {</span>
   867 |     | <span class='neutral'>        bytes32 m0;</span>
   868 |     | <span class='neutral'>        bytes32 m1;</span>
   869 |     | <span class='neutral'>        bytes32 m2;</span>
   870 |     | <span class='neutral'>        bytes32 m3;</span>
   871 |     | <span class='neutral'>        assembly {</span>
   872 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   873 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   874 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   875 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   876 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool)`.</span>
   877 |     | <span class='neutral'>            mstore(0x00, 0x678209a8)</span>
   878 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   879 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   880 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   881 |     | <span class='neutral'>        }</span>
   882 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   883 |     | <span class='neutral'>        assembly {</span>
   884 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   885 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   886 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   887 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   888 |     | <span class='neutral'>        }</span>
   889 |     | <span class='neutral'>    }</span>
   890 |     | <span class='neutral'></span>
   891 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2) internal pure {</span>
   892 |     | <span class='neutral'>        bytes32 m0;</span>
   893 |     | <span class='neutral'>        bytes32 m1;</span>
   894 |     | <span class='neutral'>        bytes32 m2;</span>
   895 |     | <span class='neutral'>        bytes32 m3;</span>
   896 |     | <span class='neutral'>        assembly {</span>
   897 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   898 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   899 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   900 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   901 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256)`.</span>
   902 |     | <span class='neutral'>            mstore(0x00, 0xb69bcaf6)</span>
   903 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   904 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   905 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   906 |     | <span class='neutral'>        }</span>
   907 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
   908 |     | <span class='neutral'>        assembly {</span>
   909 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   910 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   911 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   912 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   913 |     | <span class='neutral'>        }</span>
   914 |     | <span class='neutral'>    }</span>
   915 |     | <span class='neutral'></span>
   916 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2) internal pure {</span>
   917 |     | <span class='neutral'>        bytes32 m0;</span>
   918 |     | <span class='neutral'>        bytes32 m1;</span>
   919 |     | <span class='neutral'>        bytes32 m2;</span>
   920 |     | <span class='neutral'>        bytes32 m3;</span>
   921 |     | <span class='neutral'>        bytes32 m4;</span>
   922 |     | <span class='neutral'>        bytes32 m5;</span>
   923 |     | <span class='neutral'>        assembly {</span>
   924 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   925 |     | <span class='neutral'>                let length := 0</span>
   926 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   927 |     | <span class='neutral'>                mstore(pos, length)</span>
   928 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   929 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   930 |     | <span class='neutral'>            }</span>
   931 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   932 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   933 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   934 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   935 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   936 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   937 |     | <span class='neutral'>            // Selector of `log(address,uint256,string)`.</span>
   938 |     | <span class='neutral'>            mstore(0x00, 0xa1f2e8aa)</span>
   939 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
   941 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
   942 |     | <span class='neutral'>            writeString(0x80, p2)</span>
   943 |     | <span class='neutral'>        }</span>
   944 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   945 |     | <span class='neutral'>        assembly {</span>
   946 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   947 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   948 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   949 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   950 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   951 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   952 |     | <span class='neutral'>        }</span>
   953 |     | <span class='neutral'>    }</span>
   954 |     | <span class='neutral'></span>
   955 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2) internal pure {</span>
   956 |     | <span class='neutral'>        bytes32 m0;</span>
   957 |     | <span class='neutral'>        bytes32 m1;</span>
   958 |     | <span class='neutral'>        bytes32 m2;</span>
   959 |     | <span class='neutral'>        bytes32 m3;</span>
   960 |     | <span class='neutral'>        bytes32 m4;</span>
   961 |     | <span class='neutral'>        bytes32 m5;</span>
   962 |     | <span class='neutral'>        assembly {</span>
   963 |     | <span class='neutral'>            function writeString(pos, w) {</span>
   964 |     | <span class='neutral'>                let length := 0</span>
   965 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
   966 |     | <span class='neutral'>                mstore(pos, length)</span>
   967 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
   968 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
   969 |     | <span class='neutral'>            }</span>
   970 |     | <span class='neutral'>            m0 := mload(0x00)</span>
   971 |     | <span class='neutral'>            m1 := mload(0x20)</span>
   972 |     | <span class='neutral'>            m2 := mload(0x40)</span>
   973 |     | <span class='neutral'>            m3 := mload(0x60)</span>
   974 |     | <span class='neutral'>            m4 := mload(0x80)</span>
   975 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
   976 |     | <span class='neutral'>            // Selector of `log(address,string,address)`.</span>
   977 |     | <span class='neutral'>            mstore(0x00, 0xf08744e8)</span>
   978 |     | <span class='neutral'>            mstore(0x20, p0)</span>
   979 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
   980 |     | <span class='neutral'>            mstore(0x60, p2)</span>
   981 |     | <span class='neutral'>            writeString(0x80, p1)</span>
   982 |     | <span class='neutral'>        }</span>
   983 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
   984 |     | <span class='neutral'>        assembly {</span>
   985 |     | <span class='neutral'>            mstore(0x00, m0)</span>
   986 |     | <span class='neutral'>            mstore(0x20, m1)</span>
   987 |     | <span class='neutral'>            mstore(0x40, m2)</span>
   988 |     | <span class='neutral'>            mstore(0x60, m3)</span>
   989 |     | <span class='neutral'>            mstore(0x80, m4)</span>
   990 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
   991 |     | <span class='neutral'>        }</span>
   992 |     | <span class='neutral'>    }</span>
   993 |     | <span class='neutral'></span>
   994 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2) internal pure {</span>
   995 |     | <span class='neutral'>        bytes32 m0;</span>
   996 |     | <span class='neutral'>        bytes32 m1;</span>
   997 |     | <span class='neutral'>        bytes32 m2;</span>
   998 |     | <span class='neutral'>        bytes32 m3;</span>
   999 |     | <span class='neutral'>        bytes32 m4;</span>
  1000 |     | <span class='neutral'>        bytes32 m5;</span>
  1001 |     | <span class='neutral'>        assembly {</span>
  1002 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1003 |     | <span class='neutral'>                let length := 0</span>
  1004 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1005 |     | <span class='neutral'>                mstore(pos, length)</span>
  1006 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1007 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1008 |     | <span class='neutral'>            }</span>
  1009 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1010 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1011 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1012 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1013 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1014 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1015 |     | <span class='neutral'>            // Selector of `log(address,string,bool)`.</span>
  1016 |     | <span class='neutral'>            mstore(0x00, 0xcf020fb1)</span>
  1017 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1018 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1019 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1020 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1021 |     | <span class='neutral'>        }</span>
  1022 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1023 |     | <span class='neutral'>        assembly {</span>
  1024 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1025 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1026 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1027 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1028 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1029 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1030 |     | <span class='neutral'>        }</span>
  1031 |     | <span class='neutral'>    }</span>
  1032 |     | <span class='neutral'></span>
  1033 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2) internal pure {</span>
  1034 |     | <span class='neutral'>        bytes32 m0;</span>
  1035 |     | <span class='neutral'>        bytes32 m1;</span>
  1036 |     | <span class='neutral'>        bytes32 m2;</span>
  1037 |     | <span class='neutral'>        bytes32 m3;</span>
  1038 |     | <span class='neutral'>        bytes32 m4;</span>
  1039 |     | <span class='neutral'>        bytes32 m5;</span>
  1040 |     | <span class='neutral'>        assembly {</span>
  1041 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1042 |     | <span class='neutral'>                let length := 0</span>
  1043 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1044 |     | <span class='neutral'>                mstore(pos, length)</span>
  1045 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1046 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1047 |     | <span class='neutral'>            }</span>
  1048 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1049 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1050 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1051 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1052 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1053 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1054 |     | <span class='neutral'>            // Selector of `log(address,string,uint256)`.</span>
  1055 |     | <span class='neutral'>            mstore(0x00, 0x67dd6ff1)</span>
  1056 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1057 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1058 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1059 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1060 |     | <span class='neutral'>        }</span>
  1061 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1062 |     | <span class='neutral'>        assembly {</span>
  1063 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1064 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1065 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1066 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1067 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1068 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1069 |     | <span class='neutral'>        }</span>
  1070 |     | <span class='neutral'>    }</span>
  1071 |     | <span class='neutral'></span>
  1072 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1073 |     | <span class='neutral'>        bytes32 m0;</span>
  1074 |     | <span class='neutral'>        bytes32 m1;</span>
  1075 |     | <span class='neutral'>        bytes32 m2;</span>
  1076 |     | <span class='neutral'>        bytes32 m3;</span>
  1077 |     | <span class='neutral'>        bytes32 m4;</span>
  1078 |     | <span class='neutral'>        bytes32 m5;</span>
  1079 |     | <span class='neutral'>        bytes32 m6;</span>
  1080 |     | <span class='neutral'>        bytes32 m7;</span>
  1081 |     | <span class='neutral'>        assembly {</span>
  1082 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1083 |     | <span class='neutral'>                let length := 0</span>
  1084 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1085 |     | <span class='neutral'>                mstore(pos, length)</span>
  1086 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1087 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1088 |     | <span class='neutral'>            }</span>
  1089 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1090 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1091 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1092 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1093 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1094 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1095 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1096 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1097 |     | <span class='neutral'>            // Selector of `log(address,string,string)`.</span>
  1098 |     | <span class='neutral'>            mstore(0x00, 0xfb772265)</span>
  1099 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1100 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1101 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1102 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1103 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1104 |     | <span class='neutral'>        }</span>
  1105 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1106 |     | <span class='neutral'>        assembly {</span>
  1107 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1108 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1109 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1110 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1111 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1112 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1113 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1114 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1115 |     | <span class='neutral'>        }</span>
  1116 |     | <span class='neutral'>    }</span>
  1117 |     | <span class='neutral'></span>
  1118 |     | <span class='neutral'>    function log(bool p0, address p1, address p2) internal pure {</span>
  1119 |     | <span class='neutral'>        bytes32 m0;</span>
  1120 |     | <span class='neutral'>        bytes32 m1;</span>
  1121 |     | <span class='neutral'>        bytes32 m2;</span>
  1122 |     | <span class='neutral'>        bytes32 m3;</span>
  1123 |     | <span class='neutral'>        assembly {</span>
  1124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1128 |     | <span class='neutral'>            // Selector of `log(bool,address,address)`.</span>
  1129 |     | <span class='neutral'>            mstore(0x00, 0xd2763667)</span>
  1130 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1131 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1132 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1133 |     | <span class='neutral'>        }</span>
  1134 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1135 |     | <span class='neutral'>        assembly {</span>
  1136 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1137 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1138 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1139 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1140 |     | <span class='neutral'>        }</span>
  1141 |     | <span class='neutral'>    }</span>
  1142 |     | <span class='neutral'></span>
  1143 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2) internal pure {</span>
  1144 |     | <span class='neutral'>        bytes32 m0;</span>
  1145 |     | <span class='neutral'>        bytes32 m1;</span>
  1146 |     | <span class='neutral'>        bytes32 m2;</span>
  1147 |     | <span class='neutral'>        bytes32 m3;</span>
  1148 |     | <span class='neutral'>        assembly {</span>
  1149 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1150 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1151 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1152 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1153 |     | <span class='neutral'>            // Selector of `log(bool,address,bool)`.</span>
  1154 |     | <span class='neutral'>            mstore(0x00, 0x18c9c746)</span>
  1155 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1156 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1157 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1158 |     | <span class='neutral'>        }</span>
  1159 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1160 |     | <span class='neutral'>        assembly {</span>
  1161 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1162 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1163 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1164 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1165 |     | <span class='neutral'>        }</span>
  1166 |     | <span class='neutral'>    }</span>
  1167 |     | <span class='neutral'></span>
  1168 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2) internal pure {</span>
  1169 |     | <span class='neutral'>        bytes32 m0;</span>
  1170 |     | <span class='neutral'>        bytes32 m1;</span>
  1171 |     | <span class='neutral'>        bytes32 m2;</span>
  1172 |     | <span class='neutral'>        bytes32 m3;</span>
  1173 |     | <span class='neutral'>        assembly {</span>
  1174 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1175 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1176 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1177 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1178 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256)`.</span>
  1179 |     | <span class='neutral'>            mstore(0x00, 0x5f7b9afb)</span>
  1180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1183 |     | <span class='neutral'>        }</span>
  1184 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1185 |     | <span class='neutral'>        assembly {</span>
  1186 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1187 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1188 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1189 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1190 |     | <span class='neutral'>        }</span>
  1191 |     | <span class='neutral'>    }</span>
  1192 |     | <span class='neutral'></span>
  1193 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2) internal pure {</span>
  1194 |     | <span class='neutral'>        bytes32 m0;</span>
  1195 |     | <span class='neutral'>        bytes32 m1;</span>
  1196 |     | <span class='neutral'>        bytes32 m2;</span>
  1197 |     | <span class='neutral'>        bytes32 m3;</span>
  1198 |     | <span class='neutral'>        bytes32 m4;</span>
  1199 |     | <span class='neutral'>        bytes32 m5;</span>
  1200 |     | <span class='neutral'>        assembly {</span>
  1201 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1202 |     | <span class='neutral'>                let length := 0</span>
  1203 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1204 |     | <span class='neutral'>                mstore(pos, length)</span>
  1205 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1206 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1207 |     | <span class='neutral'>            }</span>
  1208 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1209 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1210 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1211 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1212 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1213 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1214 |     | <span class='neutral'>            // Selector of `log(bool,address,string)`.</span>
  1215 |     | <span class='neutral'>            mstore(0x00, 0xde9a9270)</span>
  1216 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1217 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1218 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1219 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1220 |     | <span class='neutral'>        }</span>
  1221 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1222 |     | <span class='neutral'>        assembly {</span>
  1223 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1224 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1225 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1226 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1227 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1228 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1229 |     | <span class='neutral'>        }</span>
  1230 |     | <span class='neutral'>    }</span>
  1231 |     | <span class='neutral'></span>
  1232 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2) internal pure {</span>
  1233 |     | <span class='neutral'>        bytes32 m0;</span>
  1234 |     | <span class='neutral'>        bytes32 m1;</span>
  1235 |     | <span class='neutral'>        bytes32 m2;</span>
  1236 |     | <span class='neutral'>        bytes32 m3;</span>
  1237 |     | <span class='neutral'>        assembly {</span>
  1238 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1239 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1240 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1241 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1242 |     | <span class='neutral'>            // Selector of `log(bool,bool,address)`.</span>
  1243 |     | <span class='neutral'>            mstore(0x00, 0x1078f68d)</span>
  1244 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1245 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1246 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1247 |     | <span class='neutral'>        }</span>
  1248 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1249 |     | <span class='neutral'>        assembly {</span>
  1250 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1251 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1252 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1253 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1254 |     | <span class='neutral'>        }</span>
  1255 |     | <span class='neutral'>    }</span>
  1256 |     | <span class='neutral'></span>
  1257 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2) internal pure {</span>
  1258 |     | <span class='neutral'>        bytes32 m0;</span>
  1259 |     | <span class='neutral'>        bytes32 m1;</span>
  1260 |     | <span class='neutral'>        bytes32 m2;</span>
  1261 |     | <span class='neutral'>        bytes32 m3;</span>
  1262 |     | <span class='neutral'>        assembly {</span>
  1263 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1264 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1265 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1266 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1267 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool)`.</span>
  1268 |     | <span class='neutral'>            mstore(0x00, 0x50709698)</span>
  1269 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1270 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1271 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1272 |     | <span class='neutral'>        }</span>
  1273 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1274 |     | <span class='neutral'>        assembly {</span>
  1275 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1276 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1277 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1278 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1279 |     | <span class='neutral'>        }</span>
  1280 |     | <span class='neutral'>    }</span>
  1281 |     | <span class='neutral'></span>
  1282 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2) internal pure {</span>
  1283 |     | <span class='neutral'>        bytes32 m0;</span>
  1284 |     | <span class='neutral'>        bytes32 m1;</span>
  1285 |     | <span class='neutral'>        bytes32 m2;</span>
  1286 |     | <span class='neutral'>        bytes32 m3;</span>
  1287 |     | <span class='neutral'>        assembly {</span>
  1288 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1289 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1290 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1291 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1292 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256)`.</span>
  1293 |     | <span class='neutral'>            mstore(0x00, 0x12f21602)</span>
  1294 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1295 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1296 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1297 |     | <span class='neutral'>        }</span>
  1298 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1299 |     | <span class='neutral'>        assembly {</span>
  1300 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1301 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1302 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1303 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1304 |     | <span class='neutral'>        }</span>
  1305 |     | <span class='neutral'>    }</span>
  1306 |     | <span class='neutral'></span>
  1307 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2) internal pure {</span>
  1308 |     | <span class='neutral'>        bytes32 m0;</span>
  1309 |     | <span class='neutral'>        bytes32 m1;</span>
  1310 |     | <span class='neutral'>        bytes32 m2;</span>
  1311 |     | <span class='neutral'>        bytes32 m3;</span>
  1312 |     | <span class='neutral'>        bytes32 m4;</span>
  1313 |     | <span class='neutral'>        bytes32 m5;</span>
  1314 |     | <span class='neutral'>        assembly {</span>
  1315 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1316 |     | <span class='neutral'>                let length := 0</span>
  1317 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1318 |     | <span class='neutral'>                mstore(pos, length)</span>
  1319 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1320 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1321 |     | <span class='neutral'>            }</span>
  1322 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1323 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1324 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1325 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1326 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1327 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1328 |     | <span class='neutral'>            // Selector of `log(bool,bool,string)`.</span>
  1329 |     | <span class='neutral'>            mstore(0x00, 0x2555fa46)</span>
  1330 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1331 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1332 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1333 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1334 |     | <span class='neutral'>        }</span>
  1335 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1336 |     | <span class='neutral'>        assembly {</span>
  1337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1343 |     | <span class='neutral'>        }</span>
  1344 |     | <span class='neutral'>    }</span>
  1345 |     | <span class='neutral'></span>
  1346 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2) internal pure {</span>
  1347 |     | <span class='neutral'>        bytes32 m0;</span>
  1348 |     | <span class='neutral'>        bytes32 m1;</span>
  1349 |     | <span class='neutral'>        bytes32 m2;</span>
  1350 |     | <span class='neutral'>        bytes32 m3;</span>
  1351 |     | <span class='neutral'>        assembly {</span>
  1352 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1353 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1354 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1355 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1356 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address)`.</span>
  1357 |     | <span class='neutral'>            mstore(0x00, 0x088ef9d2)</span>
  1358 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1359 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1360 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1361 |     | <span class='neutral'>        }</span>
  1362 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1363 |     | <span class='neutral'>        assembly {</span>
  1364 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1365 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1366 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1367 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1368 |     | <span class='neutral'>        }</span>
  1369 |     | <span class='neutral'>    }</span>
  1370 |     | <span class='neutral'></span>
  1371 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2) internal pure {</span>
  1372 |     | <span class='neutral'>        bytes32 m0;</span>
  1373 |     | <span class='neutral'>        bytes32 m1;</span>
  1374 |     | <span class='neutral'>        bytes32 m2;</span>
  1375 |     | <span class='neutral'>        bytes32 m3;</span>
  1376 |     | <span class='neutral'>        assembly {</span>
  1377 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1378 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1379 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1380 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1381 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool)`.</span>
  1382 |     | <span class='neutral'>            mstore(0x00, 0xe8defba9)</span>
  1383 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1384 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1385 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1386 |     | <span class='neutral'>        }</span>
  1387 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1388 |     | <span class='neutral'>        assembly {</span>
  1389 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1390 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1391 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1392 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1393 |     | <span class='neutral'>        }</span>
  1394 |     | <span class='neutral'>    }</span>
  1395 |     | <span class='neutral'></span>
  1396 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2) internal pure {</span>
  1397 |     | <span class='neutral'>        bytes32 m0;</span>
  1398 |     | <span class='neutral'>        bytes32 m1;</span>
  1399 |     | <span class='neutral'>        bytes32 m2;</span>
  1400 |     | <span class='neutral'>        bytes32 m3;</span>
  1401 |     | <span class='neutral'>        assembly {</span>
  1402 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1403 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1404 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1405 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1406 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256)`.</span>
  1407 |     | <span class='neutral'>            mstore(0x00, 0x37103367)</span>
  1408 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1409 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1410 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1411 |     | <span class='neutral'>        }</span>
  1412 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1413 |     | <span class='neutral'>        assembly {</span>
  1414 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1415 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1416 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1417 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1418 |     | <span class='neutral'>        }</span>
  1419 |     | <span class='neutral'>    }</span>
  1420 |     | <span class='neutral'></span>
  1421 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2) internal pure {</span>
  1422 |     | <span class='neutral'>        bytes32 m0;</span>
  1423 |     | <span class='neutral'>        bytes32 m1;</span>
  1424 |     | <span class='neutral'>        bytes32 m2;</span>
  1425 |     | <span class='neutral'>        bytes32 m3;</span>
  1426 |     | <span class='neutral'>        bytes32 m4;</span>
  1427 |     | <span class='neutral'>        bytes32 m5;</span>
  1428 |     | <span class='neutral'>        assembly {</span>
  1429 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1430 |     | <span class='neutral'>                let length := 0</span>
  1431 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1432 |     | <span class='neutral'>                mstore(pos, length)</span>
  1433 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1434 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1435 |     | <span class='neutral'>            }</span>
  1436 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1437 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1438 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1439 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1440 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1441 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1442 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string)`.</span>
  1443 |     | <span class='neutral'>            mstore(0x00, 0xc3fc3970)</span>
  1444 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1445 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1446 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1447 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1448 |     | <span class='neutral'>        }</span>
  1449 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1450 |     | <span class='neutral'>        assembly {</span>
  1451 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1452 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1453 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1454 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1455 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1456 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1457 |     | <span class='neutral'>        }</span>
  1458 |     | <span class='neutral'>    }</span>
  1459 |     | <span class='neutral'></span>
  1460 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2) internal pure {</span>
  1461 |     | <span class='neutral'>        bytes32 m0;</span>
  1462 |     | <span class='neutral'>        bytes32 m1;</span>
  1463 |     | <span class='neutral'>        bytes32 m2;</span>
  1464 |     | <span class='neutral'>        bytes32 m3;</span>
  1465 |     | <span class='neutral'>        bytes32 m4;</span>
  1466 |     | <span class='neutral'>        bytes32 m5;</span>
  1467 |     | <span class='neutral'>        assembly {</span>
  1468 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1469 |     | <span class='neutral'>                let length := 0</span>
  1470 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1471 |     | <span class='neutral'>                mstore(pos, length)</span>
  1472 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1473 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1474 |     | <span class='neutral'>            }</span>
  1475 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1476 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1477 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1478 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1479 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1480 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1481 |     | <span class='neutral'>            // Selector of `log(bool,string,address)`.</span>
  1482 |     | <span class='neutral'>            mstore(0x00, 0x9591b953)</span>
  1483 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1484 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1485 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1486 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1487 |     | <span class='neutral'>        }</span>
  1488 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1489 |     | <span class='neutral'>        assembly {</span>
  1490 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1491 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1492 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1493 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1494 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1495 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1496 |     | <span class='neutral'>        }</span>
  1497 |     | <span class='neutral'>    }</span>
  1498 |     | <span class='neutral'></span>
  1499 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2) internal pure {</span>
  1500 |     | <span class='neutral'>        bytes32 m0;</span>
  1501 |     | <span class='neutral'>        bytes32 m1;</span>
  1502 |     | <span class='neutral'>        bytes32 m2;</span>
  1503 |     | <span class='neutral'>        bytes32 m3;</span>
  1504 |     | <span class='neutral'>        bytes32 m4;</span>
  1505 |     | <span class='neutral'>        bytes32 m5;</span>
  1506 |     | <span class='neutral'>        assembly {</span>
  1507 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1508 |     | <span class='neutral'>                let length := 0</span>
  1509 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1510 |     | <span class='neutral'>                mstore(pos, length)</span>
  1511 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1512 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1513 |     | <span class='neutral'>            }</span>
  1514 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1515 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1516 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1517 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1518 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1519 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1520 |     | <span class='neutral'>            // Selector of `log(bool,string,bool)`.</span>
  1521 |     | <span class='neutral'>            mstore(0x00, 0xdbb4c247)</span>
  1522 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1523 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1524 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1525 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1526 |     | <span class='neutral'>        }</span>
  1527 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1528 |     | <span class='neutral'>        assembly {</span>
  1529 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1530 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1531 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1532 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1533 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1534 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1535 |     | <span class='neutral'>        }</span>
  1536 |     | <span class='neutral'>    }</span>
  1537 |     | <span class='neutral'></span>
  1538 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2) internal pure {</span>
  1539 |     | <span class='neutral'>        bytes32 m0;</span>
  1540 |     | <span class='neutral'>        bytes32 m1;</span>
  1541 |     | <span class='neutral'>        bytes32 m2;</span>
  1542 |     | <span class='neutral'>        bytes32 m3;</span>
  1543 |     | <span class='neutral'>        bytes32 m4;</span>
  1544 |     | <span class='neutral'>        bytes32 m5;</span>
  1545 |     | <span class='neutral'>        assembly {</span>
  1546 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1547 |     | <span class='neutral'>                let length := 0</span>
  1548 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1549 |     | <span class='neutral'>                mstore(pos, length)</span>
  1550 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1551 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1552 |     | <span class='neutral'>            }</span>
  1553 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1554 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1555 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1556 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1557 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1558 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1559 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256)`.</span>
  1560 |     | <span class='neutral'>            mstore(0x00, 0x1093ee11)</span>
  1561 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1562 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1563 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1564 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1565 |     | <span class='neutral'>        }</span>
  1566 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1567 |     | <span class='neutral'>        assembly {</span>
  1568 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1569 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1570 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1571 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1572 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1573 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1574 |     | <span class='neutral'>        }</span>
  1575 |     | <span class='neutral'>    }</span>
  1576 |     | <span class='neutral'></span>
  1577 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2) internal pure {</span>
  1578 |     | <span class='neutral'>        bytes32 m0;</span>
  1579 |     | <span class='neutral'>        bytes32 m1;</span>
  1580 |     | <span class='neutral'>        bytes32 m2;</span>
  1581 |     | <span class='neutral'>        bytes32 m3;</span>
  1582 |     | <span class='neutral'>        bytes32 m4;</span>
  1583 |     | <span class='neutral'>        bytes32 m5;</span>
  1584 |     | <span class='neutral'>        bytes32 m6;</span>
  1585 |     | <span class='neutral'>        bytes32 m7;</span>
  1586 |     | <span class='neutral'>        assembly {</span>
  1587 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1588 |     | <span class='neutral'>                let length := 0</span>
  1589 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1590 |     | <span class='neutral'>                mstore(pos, length)</span>
  1591 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1592 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1593 |     | <span class='neutral'>            }</span>
  1594 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1595 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1596 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1597 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1598 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1599 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1600 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  1601 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  1602 |     | <span class='neutral'>            // Selector of `log(bool,string,string)`.</span>
  1603 |     | <span class='neutral'>            mstore(0x00, 0xb076847f)</span>
  1604 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1605 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1606 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  1607 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1608 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  1609 |     | <span class='neutral'>        }</span>
  1610 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  1611 |     | <span class='neutral'>        assembly {</span>
  1612 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1613 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1614 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1615 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1616 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1617 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1618 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  1619 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  1620 |     | <span class='neutral'>        }</span>
  1621 |     | <span class='neutral'>    }</span>
  1622 |     | <span class='neutral'></span>
  1623 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2) internal pure {</span>
  1624 |     | <span class='neutral'>        bytes32 m0;</span>
  1625 |     | <span class='neutral'>        bytes32 m1;</span>
  1626 |     | <span class='neutral'>        bytes32 m2;</span>
  1627 |     | <span class='neutral'>        bytes32 m3;</span>
  1628 |     | <span class='neutral'>        assembly {</span>
  1629 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1630 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1631 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1632 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1633 |     | <span class='neutral'>            // Selector of `log(uint256,address,address)`.</span>
  1634 |     | <span class='neutral'>            mstore(0x00, 0xbcfd9be0)</span>
  1635 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1636 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1637 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1638 |     | <span class='neutral'>        }</span>
  1639 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1640 |     | <span class='neutral'>        assembly {</span>
  1641 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1642 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1643 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1644 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1645 |     | <span class='neutral'>        }</span>
  1646 |     | <span class='neutral'>    }</span>
  1647 |     | <span class='neutral'></span>
  1648 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2) internal pure {</span>
  1649 |     | <span class='neutral'>        bytes32 m0;</span>
  1650 |     | <span class='neutral'>        bytes32 m1;</span>
  1651 |     | <span class='neutral'>        bytes32 m2;</span>
  1652 |     | <span class='neutral'>        bytes32 m3;</span>
  1653 |     | <span class='neutral'>        assembly {</span>
  1654 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1655 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1656 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1657 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1658 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool)`.</span>
  1659 |     | <span class='neutral'>            mstore(0x00, 0x9b6ec042)</span>
  1660 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1661 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1662 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1663 |     | <span class='neutral'>        }</span>
  1664 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1665 |     | <span class='neutral'>        assembly {</span>
  1666 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1667 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1668 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1669 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1670 |     | <span class='neutral'>        }</span>
  1671 |     | <span class='neutral'>    }</span>
  1672 |     | <span class='neutral'></span>
  1673 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2) internal pure {</span>
  1674 |     | <span class='neutral'>        bytes32 m0;</span>
  1675 |     | <span class='neutral'>        bytes32 m1;</span>
  1676 |     | <span class='neutral'>        bytes32 m2;</span>
  1677 |     | <span class='neutral'>        bytes32 m3;</span>
  1678 |     | <span class='neutral'>        assembly {</span>
  1679 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1680 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1681 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1682 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1683 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256)`.</span>
  1684 |     | <span class='neutral'>            mstore(0x00, 0x5a9b5ed5)</span>
  1685 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1686 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1687 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1688 |     | <span class='neutral'>        }</span>
  1689 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1690 |     | <span class='neutral'>        assembly {</span>
  1691 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1692 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1693 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1694 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1695 |     | <span class='neutral'>        }</span>
  1696 |     | <span class='neutral'>    }</span>
  1697 |     | <span class='neutral'></span>
  1698 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2) internal pure {</span>
  1699 |     | <span class='neutral'>        bytes32 m0;</span>
  1700 |     | <span class='neutral'>        bytes32 m1;</span>
  1701 |     | <span class='neutral'>        bytes32 m2;</span>
  1702 |     | <span class='neutral'>        bytes32 m3;</span>
  1703 |     | <span class='neutral'>        bytes32 m4;</span>
  1704 |     | <span class='neutral'>        bytes32 m5;</span>
  1705 |     | <span class='neutral'>        assembly {</span>
  1706 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1707 |     | <span class='neutral'>                let length := 0</span>
  1708 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1709 |     | <span class='neutral'>                mstore(pos, length)</span>
  1710 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1711 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1712 |     | <span class='neutral'>            }</span>
  1713 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1714 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1715 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1716 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1717 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1718 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1719 |     | <span class='neutral'>            // Selector of `log(uint256,address,string)`.</span>
  1720 |     | <span class='neutral'>            mstore(0x00, 0x63cb41f9)</span>
  1721 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1722 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1723 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1724 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1725 |     | <span class='neutral'>        }</span>
  1726 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1727 |     | <span class='neutral'>        assembly {</span>
  1728 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1729 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1730 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1731 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1732 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1733 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1734 |     | <span class='neutral'>        }</span>
  1735 |     | <span class='neutral'>    }</span>
  1736 |     | <span class='neutral'></span>
  1737 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2) internal pure {</span>
  1738 |     | <span class='neutral'>        bytes32 m0;</span>
  1739 |     | <span class='neutral'>        bytes32 m1;</span>
  1740 |     | <span class='neutral'>        bytes32 m2;</span>
  1741 |     | <span class='neutral'>        bytes32 m3;</span>
  1742 |     | <span class='neutral'>        assembly {</span>
  1743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1747 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address)`.</span>
  1748 |     | <span class='neutral'>            mstore(0x00, 0x35085f7b)</span>
  1749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1752 |     | <span class='neutral'>        }</span>
  1753 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1754 |     | <span class='neutral'>        assembly {</span>
  1755 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1756 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1757 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1758 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1759 |     | <span class='neutral'>        }</span>
  1760 |     | <span class='neutral'>    }</span>
  1761 |     | <span class='neutral'></span>
  1762 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2) internal pure {</span>
  1763 |     | <span class='neutral'>        bytes32 m0;</span>
  1764 |     | <span class='neutral'>        bytes32 m1;</span>
  1765 |     | <span class='neutral'>        bytes32 m2;</span>
  1766 |     | <span class='neutral'>        bytes32 m3;</span>
  1767 |     | <span class='neutral'>        assembly {</span>
  1768 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1769 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1770 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1771 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1772 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool)`.</span>
  1773 |     | <span class='neutral'>            mstore(0x00, 0x20718650)</span>
  1774 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1775 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1776 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1777 |     | <span class='neutral'>        }</span>
  1778 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1779 |     | <span class='neutral'>        assembly {</span>
  1780 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1781 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1782 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1783 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1784 |     | <span class='neutral'>        }</span>
  1785 |     | <span class='neutral'>    }</span>
  1786 |     | <span class='neutral'></span>
  1787 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2) internal pure {</span>
  1788 |     | <span class='neutral'>        bytes32 m0;</span>
  1789 |     | <span class='neutral'>        bytes32 m1;</span>
  1790 |     | <span class='neutral'>        bytes32 m2;</span>
  1791 |     | <span class='neutral'>        bytes32 m3;</span>
  1792 |     | <span class='neutral'>        assembly {</span>
  1793 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1794 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1795 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1796 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1797 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256)`.</span>
  1798 |     | <span class='neutral'>            mstore(0x00, 0x20098014)</span>
  1799 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1800 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1801 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1802 |     | <span class='neutral'>        }</span>
  1803 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1804 |     | <span class='neutral'>        assembly {</span>
  1805 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1806 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1807 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1808 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1809 |     | <span class='neutral'>        }</span>
  1810 |     | <span class='neutral'>    }</span>
  1811 |     | <span class='neutral'></span>
  1812 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2) internal pure {</span>
  1813 |     | <span class='neutral'>        bytes32 m0;</span>
  1814 |     | <span class='neutral'>        bytes32 m1;</span>
  1815 |     | <span class='neutral'>        bytes32 m2;</span>
  1816 |     | <span class='neutral'>        bytes32 m3;</span>
  1817 |     | <span class='neutral'>        bytes32 m4;</span>
  1818 |     | <span class='neutral'>        bytes32 m5;</span>
  1819 |     | <span class='neutral'>        assembly {</span>
  1820 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1821 |     | <span class='neutral'>                let length := 0</span>
  1822 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1823 |     | <span class='neutral'>                mstore(pos, length)</span>
  1824 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1825 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1826 |     | <span class='neutral'>            }</span>
  1827 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1828 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1829 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1830 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1831 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1832 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1833 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string)`.</span>
  1834 |     | <span class='neutral'>            mstore(0x00, 0x85775021)</span>
  1835 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1836 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1837 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1838 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1839 |     | <span class='neutral'>        }</span>
  1840 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1841 |     | <span class='neutral'>        assembly {</span>
  1842 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1843 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1844 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1845 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1846 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1847 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1848 |     | <span class='neutral'>        }</span>
  1849 |     | <span class='neutral'>    }</span>
  1850 |     | <span class='neutral'></span>
  1851 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2) internal pure {</span>
  1852 |     | <span class='neutral'>        bytes32 m0;</span>
  1853 |     | <span class='neutral'>        bytes32 m1;</span>
  1854 |     | <span class='neutral'>        bytes32 m2;</span>
  1855 |     | <span class='neutral'>        bytes32 m3;</span>
  1856 |     | <span class='neutral'>        assembly {</span>
  1857 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1858 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1859 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1860 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1861 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address)`.</span>
  1862 |     | <span class='neutral'>            mstore(0x00, 0x5c96b331)</span>
  1863 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1864 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1865 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1866 |     | <span class='neutral'>        }</span>
  1867 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1868 |     | <span class='neutral'>        assembly {</span>
  1869 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1870 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1871 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1872 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1873 |     | <span class='neutral'>        }</span>
  1874 |     | <span class='neutral'>    }</span>
  1875 |     | <span class='neutral'></span>
  1876 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2) internal pure {</span>
  1877 |     | <span class='neutral'>        bytes32 m0;</span>
  1878 |     | <span class='neutral'>        bytes32 m1;</span>
  1879 |     | <span class='neutral'>        bytes32 m2;</span>
  1880 |     | <span class='neutral'>        bytes32 m3;</span>
  1881 |     | <span class='neutral'>        assembly {</span>
  1882 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1883 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1884 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1885 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1886 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool)`.</span>
  1887 |     | <span class='neutral'>            mstore(0x00, 0x4766da72)</span>
  1888 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1889 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1890 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1891 |     | <span class='neutral'>        }</span>
  1892 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1893 |     | <span class='neutral'>        assembly {</span>
  1894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1898 |     | <span class='neutral'>        }</span>
  1899 |     | <span class='neutral'>    }</span>
  1900 |     | <span class='neutral'></span>
  1901 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {</span>
  1902 |     | <span class='neutral'>        bytes32 m0;</span>
  1903 |     | <span class='neutral'>        bytes32 m1;</span>
  1904 |     | <span class='neutral'>        bytes32 m2;</span>
  1905 |     | <span class='neutral'>        bytes32 m3;</span>
  1906 |     | <span class='neutral'>        assembly {</span>
  1907 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1908 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1909 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1910 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1911 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256)`.</span>
  1912 |     | <span class='neutral'>            mstore(0x00, 0xd1ed7a3c)</span>
  1913 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1914 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1915 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1916 |     | <span class='neutral'>        }</span>
  1917 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x64);</span>
  1918 |     | <span class='neutral'>        assembly {</span>
  1919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1923 |     | <span class='neutral'>        }</span>
  1924 |     | <span class='neutral'>    }</span>
  1925 |     | <span class='neutral'></span>
  1926 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2) internal pure {</span>
  1927 |     | <span class='neutral'>        bytes32 m0;</span>
  1928 |     | <span class='neutral'>        bytes32 m1;</span>
  1929 |     | <span class='neutral'>        bytes32 m2;</span>
  1930 |     | <span class='neutral'>        bytes32 m3;</span>
  1931 |     | <span class='neutral'>        bytes32 m4;</span>
  1932 |     | <span class='neutral'>        bytes32 m5;</span>
  1933 |     | <span class='neutral'>        assembly {</span>
  1934 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1935 |     | <span class='neutral'>                let length := 0</span>
  1936 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1937 |     | <span class='neutral'>                mstore(pos, length)</span>
  1938 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1939 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1940 |     | <span class='neutral'>            }</span>
  1941 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1942 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1943 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1944 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1945 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1946 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1947 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string)`.</span>
  1948 |     | <span class='neutral'>            mstore(0x00, 0x71d04af2)</span>
  1949 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1950 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  1951 |     | <span class='neutral'>            mstore(0x60, 0x60)</span>
  1952 |     | <span class='neutral'>            writeString(0x80, p2)</span>
  1953 |     | <span class='neutral'>        }</span>
  1954 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1955 |     | <span class='neutral'>        assembly {</span>
  1956 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1957 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1958 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1959 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1960 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  1961 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  1962 |     | <span class='neutral'>        }</span>
  1963 |     | <span class='neutral'>    }</span>
  1964 |     | <span class='neutral'></span>
  1965 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2) internal pure {</span>
  1966 |     | <span class='neutral'>        bytes32 m0;</span>
  1967 |     | <span class='neutral'>        bytes32 m1;</span>
  1968 |     | <span class='neutral'>        bytes32 m2;</span>
  1969 |     | <span class='neutral'>        bytes32 m3;</span>
  1970 |     | <span class='neutral'>        bytes32 m4;</span>
  1971 |     | <span class='neutral'>        bytes32 m5;</span>
  1972 |     | <span class='neutral'>        assembly {</span>
  1973 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  1974 |     | <span class='neutral'>                let length := 0</span>
  1975 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  1976 |     | <span class='neutral'>                mstore(pos, length)</span>
  1977 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  1978 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  1979 |     | <span class='neutral'>            }</span>
  1980 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  1981 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  1982 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  1983 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  1984 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  1985 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  1986 |     | <span class='neutral'>            // Selector of `log(uint256,string,address)`.</span>
  1987 |     | <span class='neutral'>            mstore(0x00, 0x7afac959)</span>
  1988 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  1989 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  1990 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  1991 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  1992 |     | <span class='neutral'>        }</span>
  1993 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  1994 |     | <span class='neutral'>        assembly {</span>
  1995 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  1996 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  1997 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  1998 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  1999 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2000 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2001 |     | <span class='neutral'>        }</span>
  2002 |     | <span class='neutral'>    }</span>
  2003 |     | <span class='neutral'></span>
  2004 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2) internal pure {</span>
  2005 |     | <span class='neutral'>        bytes32 m0;</span>
  2006 |     | <span class='neutral'>        bytes32 m1;</span>
  2007 |     | <span class='neutral'>        bytes32 m2;</span>
  2008 |     | <span class='neutral'>        bytes32 m3;</span>
  2009 |     | <span class='neutral'>        bytes32 m4;</span>
  2010 |     | <span class='neutral'>        bytes32 m5;</span>
  2011 |     | <span class='neutral'>        assembly {</span>
  2012 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2013 |     | <span class='neutral'>                let length := 0</span>
  2014 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2015 |     | <span class='neutral'>                mstore(pos, length)</span>
  2016 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2017 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2018 |     | <span class='neutral'>            }</span>
  2019 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2020 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2021 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2022 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2023 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2024 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2025 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool)`.</span>
  2026 |     | <span class='neutral'>            mstore(0x00, 0x4ceda75a)</span>
  2027 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2028 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2029 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2030 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2031 |     | <span class='neutral'>        }</span>
  2032 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2033 |     | <span class='neutral'>        assembly {</span>
  2034 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2035 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2036 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2037 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2038 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2039 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2040 |     | <span class='neutral'>        }</span>
  2041 |     | <span class='neutral'>    }</span>
  2042 |     | <span class='neutral'></span>
  2043 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2044 |     | <span class='neutral'>        bytes32 m0;</span>
  2045 |     | <span class='neutral'>        bytes32 m1;</span>
  2046 |     | <span class='neutral'>        bytes32 m2;</span>
  2047 |     | <span class='neutral'>        bytes32 m3;</span>
  2048 |     | <span class='neutral'>        bytes32 m4;</span>
  2049 |     | <span class='neutral'>        bytes32 m5;</span>
  2050 |     | <span class='neutral'>        assembly {</span>
  2051 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2052 |     | <span class='neutral'>                let length := 0</span>
  2053 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2054 |     | <span class='neutral'>                mstore(pos, length)</span>
  2055 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2056 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2057 |     | <span class='neutral'>            }</span>
  2058 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2059 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2060 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2061 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2062 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2063 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2064 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256)`.</span>
  2065 |     | <span class='neutral'>            mstore(0x00, 0x37aa7d4c)</span>
  2066 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2067 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2068 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2069 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2070 |     | <span class='neutral'>        }</span>
  2071 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2072 |     | <span class='neutral'>        assembly {</span>
  2073 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2074 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2075 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2076 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2077 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2078 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2079 |     | <span class='neutral'>        }</span>
  2080 |     | <span class='neutral'>    }</span>
  2081 |     | <span class='neutral'></span>
  2082 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2083 |     | <span class='neutral'>        bytes32 m0;</span>
  2084 |     | <span class='neutral'>        bytes32 m1;</span>
  2085 |     | <span class='neutral'>        bytes32 m2;</span>
  2086 |     | <span class='neutral'>        bytes32 m3;</span>
  2087 |     | <span class='neutral'>        bytes32 m4;</span>
  2088 |     | <span class='neutral'>        bytes32 m5;</span>
  2089 |     | <span class='neutral'>        bytes32 m6;</span>
  2090 |     | <span class='neutral'>        bytes32 m7;</span>
  2091 |     | <span class='neutral'>        assembly {</span>
  2092 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2093 |     | <span class='neutral'>                let length := 0</span>
  2094 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2095 |     | <span class='neutral'>                mstore(pos, length)</span>
  2096 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2097 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2098 |     | <span class='neutral'>            }</span>
  2099 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2100 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2101 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2102 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2103 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2104 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2105 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2106 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2107 |     | <span class='neutral'>            // Selector of `log(uint256,string,string)`.</span>
  2108 |     | <span class='neutral'>            mstore(0x00, 0xb115611f)</span>
  2109 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2110 |     | <span class='neutral'>            mstore(0x40, 0x60)</span>
  2111 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2112 |     | <span class='neutral'>            writeString(0x80, p1)</span>
  2113 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2114 |     | <span class='neutral'>        }</span>
  2115 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2116 |     | <span class='neutral'>        assembly {</span>
  2117 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2118 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2119 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2120 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2121 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2122 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2123 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2124 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2125 |     | <span class='neutral'>        }</span>
  2126 |     | <span class='neutral'>    }</span>
  2127 |     | <span class='neutral'></span>
  2128 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2) internal pure {</span>
  2129 |     | <span class='neutral'>        bytes32 m0;</span>
  2130 |     | <span class='neutral'>        bytes32 m1;</span>
  2131 |     | <span class='neutral'>        bytes32 m2;</span>
  2132 |     | <span class='neutral'>        bytes32 m3;</span>
  2133 |     | <span class='neutral'>        bytes32 m4;</span>
  2134 |     | <span class='neutral'>        bytes32 m5;</span>
  2135 |     | <span class='neutral'>        assembly {</span>
  2136 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2137 |     | <span class='neutral'>                let length := 0</span>
  2138 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2139 |     | <span class='neutral'>                mstore(pos, length)</span>
  2140 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2141 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2142 |     | <span class='neutral'>            }</span>
  2143 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2144 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2145 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2146 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2147 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2148 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2149 |     | <span class='neutral'>            // Selector of `log(string,address,address)`.</span>
  2150 |     | <span class='neutral'>            mstore(0x00, 0xfcec75e0)</span>
  2151 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2152 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2153 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2154 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2155 |     | <span class='neutral'>        }</span>
  2156 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2157 |     | <span class='neutral'>        assembly {</span>
  2158 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2159 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2160 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2161 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2162 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2163 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2164 |     | <span class='neutral'>        }</span>
  2165 |     | <span class='neutral'>    }</span>
  2166 |     | <span class='neutral'></span>
  2167 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2) internal pure {</span>
  2168 |     | <span class='neutral'>        bytes32 m0;</span>
  2169 |     | <span class='neutral'>        bytes32 m1;</span>
  2170 |     | <span class='neutral'>        bytes32 m2;</span>
  2171 |     | <span class='neutral'>        bytes32 m3;</span>
  2172 |     | <span class='neutral'>        bytes32 m4;</span>
  2173 |     | <span class='neutral'>        bytes32 m5;</span>
  2174 |     | <span class='neutral'>        assembly {</span>
  2175 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2176 |     | <span class='neutral'>                let length := 0</span>
  2177 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2178 |     | <span class='neutral'>                mstore(pos, length)</span>
  2179 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2180 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2181 |     | <span class='neutral'>            }</span>
  2182 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2183 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2184 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2185 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2186 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2187 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2188 |     | <span class='neutral'>            // Selector of `log(string,address,bool)`.</span>
  2189 |     | <span class='neutral'>            mstore(0x00, 0xc91d5ed4)</span>
  2190 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2191 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2192 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2193 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2194 |     | <span class='neutral'>        }</span>
  2195 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2196 |     | <span class='neutral'>        assembly {</span>
  2197 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2198 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2199 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2200 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2201 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2202 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2203 |     | <span class='neutral'>        }</span>
  2204 |     | <span class='neutral'>    }</span>
  2205 |     | <span class='neutral'></span>
  2206 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2) internal pure {</span>
  2207 |     | <span class='neutral'>        bytes32 m0;</span>
  2208 |     | <span class='neutral'>        bytes32 m1;</span>
  2209 |     | <span class='neutral'>        bytes32 m2;</span>
  2210 |     | <span class='neutral'>        bytes32 m3;</span>
  2211 |     | <span class='neutral'>        bytes32 m4;</span>
  2212 |     | <span class='neutral'>        bytes32 m5;</span>
  2213 |     | <span class='neutral'>        assembly {</span>
  2214 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2215 |     | <span class='neutral'>                let length := 0</span>
  2216 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2217 |     | <span class='neutral'>                mstore(pos, length)</span>
  2218 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2219 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2220 |     | <span class='neutral'>            }</span>
  2221 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2222 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2223 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2224 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2225 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2226 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2227 |     | <span class='neutral'>            // Selector of `log(string,address,uint256)`.</span>
  2228 |     | <span class='neutral'>            mstore(0x00, 0x0d26b925)</span>
  2229 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2231 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2232 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2233 |     | <span class='neutral'>        }</span>
  2234 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2235 |     | <span class='neutral'>        assembly {</span>
  2236 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2237 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2238 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2239 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2240 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2241 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2242 |     | <span class='neutral'>        }</span>
  2243 |     | <span class='neutral'>    }</span>
  2244 |     | <span class='neutral'></span>
  2245 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2) internal pure {</span>
  2246 |     | <span class='neutral'>        bytes32 m0;</span>
  2247 |     | <span class='neutral'>        bytes32 m1;</span>
  2248 |     | <span class='neutral'>        bytes32 m2;</span>
  2249 |     | <span class='neutral'>        bytes32 m3;</span>
  2250 |     | <span class='neutral'>        bytes32 m4;</span>
  2251 |     | <span class='neutral'>        bytes32 m5;</span>
  2252 |     | <span class='neutral'>        bytes32 m6;</span>
  2253 |     | <span class='neutral'>        bytes32 m7;</span>
  2254 |     | <span class='neutral'>        assembly {</span>
  2255 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2256 |     | <span class='neutral'>                let length := 0</span>
  2257 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2258 |     | <span class='neutral'>                mstore(pos, length)</span>
  2259 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2260 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2261 |     | <span class='neutral'>            }</span>
  2262 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2263 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2264 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2265 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2266 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2267 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2268 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2269 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2270 |     | <span class='neutral'>            // Selector of `log(string,address,string)`.</span>
  2271 |     | <span class='neutral'>            mstore(0x00, 0xe0e9ad4f)</span>
  2272 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2273 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2274 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2275 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2276 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2277 |     | <span class='neutral'>        }</span>
  2278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2279 |     | <span class='neutral'>        assembly {</span>
  2280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2285 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2286 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2287 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2288 |     | <span class='neutral'>        }</span>
  2289 |     | <span class='neutral'>    }</span>
  2290 |     | <span class='neutral'></span>
  2291 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2) internal pure {</span>
  2292 |     | <span class='neutral'>        bytes32 m0;</span>
  2293 |     | <span class='neutral'>        bytes32 m1;</span>
  2294 |     | <span class='neutral'>        bytes32 m2;</span>
  2295 |     | <span class='neutral'>        bytes32 m3;</span>
  2296 |     | <span class='neutral'>        bytes32 m4;</span>
  2297 |     | <span class='neutral'>        bytes32 m5;</span>
  2298 |     | <span class='neutral'>        assembly {</span>
  2299 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2300 |     | <span class='neutral'>                let length := 0</span>
  2301 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2302 |     | <span class='neutral'>                mstore(pos, length)</span>
  2303 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2304 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2305 |     | <span class='neutral'>            }</span>
  2306 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2307 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2308 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2309 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2310 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2311 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2312 |     | <span class='neutral'>            // Selector of `log(string,bool,address)`.</span>
  2313 |     | <span class='neutral'>            mstore(0x00, 0x932bbb38)</span>
  2314 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2315 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2316 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2317 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2318 |     | <span class='neutral'>        }</span>
  2319 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2320 |     | <span class='neutral'>        assembly {</span>
  2321 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2322 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2323 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2324 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2325 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2326 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2327 |     | <span class='neutral'>        }</span>
  2328 |     | <span class='neutral'>    }</span>
  2329 |     | <span class='neutral'></span>
  2330 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2) internal pure {</span>
  2331 |     | <span class='neutral'>        bytes32 m0;</span>
  2332 |     | <span class='neutral'>        bytes32 m1;</span>
  2333 |     | <span class='neutral'>        bytes32 m2;</span>
  2334 |     | <span class='neutral'>        bytes32 m3;</span>
  2335 |     | <span class='neutral'>        bytes32 m4;</span>
  2336 |     | <span class='neutral'>        bytes32 m5;</span>
  2337 |     | <span class='neutral'>        assembly {</span>
  2338 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2339 |     | <span class='neutral'>                let length := 0</span>
  2340 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2341 |     | <span class='neutral'>                mstore(pos, length)</span>
  2342 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2343 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2344 |     | <span class='neutral'>            }</span>
  2345 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2346 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2347 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2348 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2349 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2350 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2351 |     | <span class='neutral'>            // Selector of `log(string,bool,bool)`.</span>
  2352 |     | <span class='neutral'>            mstore(0x00, 0x850b7ad6)</span>
  2353 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2354 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2355 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2356 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2357 |     | <span class='neutral'>        }</span>
  2358 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2359 |     | <span class='neutral'>        assembly {</span>
  2360 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2361 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2362 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2363 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2364 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2365 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2366 |     | <span class='neutral'>        }</span>
  2367 |     | <span class='neutral'>    }</span>
  2368 |     | <span class='neutral'></span>
  2369 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2) internal pure {</span>
  2370 |     | <span class='neutral'>        bytes32 m0;</span>
  2371 |     | <span class='neutral'>        bytes32 m1;</span>
  2372 |     | <span class='neutral'>        bytes32 m2;</span>
  2373 |     | <span class='neutral'>        bytes32 m3;</span>
  2374 |     | <span class='neutral'>        bytes32 m4;</span>
  2375 |     | <span class='neutral'>        bytes32 m5;</span>
  2376 |     | <span class='neutral'>        assembly {</span>
  2377 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2378 |     | <span class='neutral'>                let length := 0</span>
  2379 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2380 |     | <span class='neutral'>                mstore(pos, length)</span>
  2381 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2382 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2383 |     | <span class='neutral'>            }</span>
  2384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2389 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2390 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256)`.</span>
  2391 |     | <span class='neutral'>            mstore(0x00, 0xc95958d6)</span>
  2392 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2393 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2394 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2395 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2396 |     | <span class='neutral'>        }</span>
  2397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2398 |     | <span class='neutral'>        assembly {</span>
  2399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2405 |     | <span class='neutral'>        }</span>
  2406 |     | <span class='neutral'>    }</span>
  2407 |     | <span class='neutral'></span>
  2408 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2) internal pure {</span>
  2409 |     | <span class='neutral'>        bytes32 m0;</span>
  2410 |     | <span class='neutral'>        bytes32 m1;</span>
  2411 |     | <span class='neutral'>        bytes32 m2;</span>
  2412 |     | <span class='neutral'>        bytes32 m3;</span>
  2413 |     | <span class='neutral'>        bytes32 m4;</span>
  2414 |     | <span class='neutral'>        bytes32 m5;</span>
  2415 |     | <span class='neutral'>        bytes32 m6;</span>
  2416 |     | <span class='neutral'>        bytes32 m7;</span>
  2417 |     | <span class='neutral'>        assembly {</span>
  2418 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2419 |     | <span class='neutral'>                let length := 0</span>
  2420 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2421 |     | <span class='neutral'>                mstore(pos, length)</span>
  2422 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2423 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2424 |     | <span class='neutral'>            }</span>
  2425 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2426 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2427 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2428 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2429 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2430 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2431 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2432 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2433 |     | <span class='neutral'>            // Selector of `log(string,bool,string)`.</span>
  2434 |     | <span class='neutral'>            mstore(0x00, 0xe298f47d)</span>
  2435 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2436 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2437 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2438 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2439 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2440 |     | <span class='neutral'>        }</span>
  2441 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2442 |     | <span class='neutral'>        assembly {</span>
  2443 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2444 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2445 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2446 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2447 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2448 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2449 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2450 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2451 |     | <span class='neutral'>        }</span>
  2452 |     | <span class='neutral'>    }</span>
  2453 |     | <span class='neutral'></span>
  2454 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2) internal pure {</span>
  2455 |     | <span class='neutral'>        bytes32 m0;</span>
  2456 |     | <span class='neutral'>        bytes32 m1;</span>
  2457 |     | <span class='neutral'>        bytes32 m2;</span>
  2458 |     | <span class='neutral'>        bytes32 m3;</span>
  2459 |     | <span class='neutral'>        bytes32 m4;</span>
  2460 |     | <span class='neutral'>        bytes32 m5;</span>
  2461 |     | <span class='neutral'>        assembly {</span>
  2462 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2463 |     | <span class='neutral'>                let length := 0</span>
  2464 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2465 |     | <span class='neutral'>                mstore(pos, length)</span>
  2466 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2467 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2468 |     | <span class='neutral'>            }</span>
  2469 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2470 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2471 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2472 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2473 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2474 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2475 |     | <span class='neutral'>            // Selector of `log(string,uint256,address)`.</span>
  2476 |     | <span class='neutral'>            mstore(0x00, 0x1c7ec448)</span>
  2477 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2478 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2479 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2480 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2481 |     | <span class='neutral'>        }</span>
  2482 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2483 |     | <span class='neutral'>        assembly {</span>
  2484 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2485 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2486 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2487 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2488 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2489 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2490 |     | <span class='neutral'>        }</span>
  2491 |     | <span class='neutral'>    }</span>
  2492 |     | <span class='neutral'></span>
  2493 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2) internal pure {</span>
  2494 |     | <span class='neutral'>        bytes32 m0;</span>
  2495 |     | <span class='neutral'>        bytes32 m1;</span>
  2496 |     | <span class='neutral'>        bytes32 m2;</span>
  2497 |     | <span class='neutral'>        bytes32 m3;</span>
  2498 |     | <span class='neutral'>        bytes32 m4;</span>
  2499 |     | <span class='neutral'>        bytes32 m5;</span>
  2500 |     | <span class='neutral'>        assembly {</span>
  2501 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2502 |     | <span class='neutral'>                let length := 0</span>
  2503 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2504 |     | <span class='neutral'>                mstore(pos, length)</span>
  2505 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2506 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2507 |     | <span class='neutral'>            }</span>
  2508 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2509 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2510 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2511 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2512 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2513 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2514 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool)`.</span>
  2515 |     | <span class='neutral'>            mstore(0x00, 0xca7733b1)</span>
  2516 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2517 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2518 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2519 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2520 |     | <span class='neutral'>        }</span>
  2521 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2522 |     | <span class='neutral'>        assembly {</span>
  2523 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2524 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2525 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2526 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2527 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2528 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2529 |     | <span class='neutral'>        }</span>
  2530 |     | <span class='neutral'>    }</span>
  2531 |     | <span class='neutral'></span>
  2532 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2) internal pure {</span>
  2533 |     | <span class='neutral'>        bytes32 m0;</span>
  2534 |     | <span class='neutral'>        bytes32 m1;</span>
  2535 |     | <span class='neutral'>        bytes32 m2;</span>
  2536 |     | <span class='neutral'>        bytes32 m3;</span>
  2537 |     | <span class='neutral'>        bytes32 m4;</span>
  2538 |     | <span class='neutral'>        bytes32 m5;</span>
  2539 |     | <span class='neutral'>        assembly {</span>
  2540 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2541 |     | <span class='neutral'>                let length := 0</span>
  2542 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2543 |     | <span class='neutral'>                mstore(pos, length)</span>
  2544 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2545 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2546 |     | <span class='neutral'>            }</span>
  2547 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2548 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2549 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2550 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2551 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2552 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2553 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256)`.</span>
  2554 |     | <span class='neutral'>            mstore(0x00, 0xca47c4eb)</span>
  2555 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2556 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2557 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2558 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2559 |     | <span class='neutral'>        }</span>
  2560 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xa4);</span>
  2561 |     | <span class='neutral'>        assembly {</span>
  2562 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2563 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2564 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2565 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2566 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2567 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2568 |     | <span class='neutral'>        }</span>
  2569 |     | <span class='neutral'>    }</span>
  2570 |     | <span class='neutral'></span>
  2571 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2) internal pure {</span>
  2572 |     | <span class='neutral'>        bytes32 m0;</span>
  2573 |     | <span class='neutral'>        bytes32 m1;</span>
  2574 |     | <span class='neutral'>        bytes32 m2;</span>
  2575 |     | <span class='neutral'>        bytes32 m3;</span>
  2576 |     | <span class='neutral'>        bytes32 m4;</span>
  2577 |     | <span class='neutral'>        bytes32 m5;</span>
  2578 |     | <span class='neutral'>        bytes32 m6;</span>
  2579 |     | <span class='neutral'>        bytes32 m7;</span>
  2580 |     | <span class='neutral'>        assembly {</span>
  2581 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2582 |     | <span class='neutral'>                let length := 0</span>
  2583 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2584 |     | <span class='neutral'>                mstore(pos, length)</span>
  2585 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2586 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2587 |     | <span class='neutral'>            }</span>
  2588 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2589 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2590 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2591 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2592 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2593 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2594 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2595 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2596 |     | <span class='neutral'>            // Selector of `log(string,uint256,string)`.</span>
  2597 |     | <span class='neutral'>            mstore(0x00, 0x5970e089)</span>
  2598 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2599 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2600 |     | <span class='neutral'>            mstore(0x60, 0xa0)</span>
  2601 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2602 |     | <span class='neutral'>            writeString(0xc0, p2)</span>
  2603 |     | <span class='neutral'>        }</span>
  2604 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2605 |     | <span class='neutral'>        assembly {</span>
  2606 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2607 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2608 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2609 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2610 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2611 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2612 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2613 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2614 |     | <span class='neutral'>        }</span>
  2615 |     | <span class='neutral'>    }</span>
  2616 |     | <span class='neutral'></span>
  2617 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2) internal pure {</span>
  2618 |     | <span class='neutral'>        bytes32 m0;</span>
  2619 |     | <span class='neutral'>        bytes32 m1;</span>
  2620 |     | <span class='neutral'>        bytes32 m2;</span>
  2621 |     | <span class='neutral'>        bytes32 m3;</span>
  2622 |     | <span class='neutral'>        bytes32 m4;</span>
  2623 |     | <span class='neutral'>        bytes32 m5;</span>
  2624 |     | <span class='neutral'>        bytes32 m6;</span>
  2625 |     | <span class='neutral'>        bytes32 m7;</span>
  2626 |     | <span class='neutral'>        assembly {</span>
  2627 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2628 |     | <span class='neutral'>                let length := 0</span>
  2629 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2630 |     | <span class='neutral'>                mstore(pos, length)</span>
  2631 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2632 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2633 |     | <span class='neutral'>            }</span>
  2634 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2635 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2636 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2637 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2638 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2639 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2640 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2641 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2642 |     | <span class='neutral'>            // Selector of `log(string,string,address)`.</span>
  2643 |     | <span class='neutral'>            mstore(0x00, 0x95ed0195)</span>
  2644 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2645 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2646 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2647 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2648 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2649 |     | <span class='neutral'>        }</span>
  2650 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2651 |     | <span class='neutral'>        assembly {</span>
  2652 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2653 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2654 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2655 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2656 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2657 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2658 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2659 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2660 |     | <span class='neutral'>        }</span>
  2661 |     | <span class='neutral'>    }</span>
  2662 |     | <span class='neutral'></span>
  2663 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2) internal pure {</span>
  2664 |     | <span class='neutral'>        bytes32 m0;</span>
  2665 |     | <span class='neutral'>        bytes32 m1;</span>
  2666 |     | <span class='neutral'>        bytes32 m2;</span>
  2667 |     | <span class='neutral'>        bytes32 m3;</span>
  2668 |     | <span class='neutral'>        bytes32 m4;</span>
  2669 |     | <span class='neutral'>        bytes32 m5;</span>
  2670 |     | <span class='neutral'>        bytes32 m6;</span>
  2671 |     | <span class='neutral'>        bytes32 m7;</span>
  2672 |     | <span class='neutral'>        assembly {</span>
  2673 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2674 |     | <span class='neutral'>                let length := 0</span>
  2675 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2676 |     | <span class='neutral'>                mstore(pos, length)</span>
  2677 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2678 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2679 |     | <span class='neutral'>            }</span>
  2680 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2681 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2682 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2683 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2684 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2685 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2686 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2687 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2688 |     | <span class='neutral'>            // Selector of `log(string,string,bool)`.</span>
  2689 |     | <span class='neutral'>            mstore(0x00, 0xb0e0f9b5)</span>
  2690 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2691 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2692 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2693 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2694 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2695 |     | <span class='neutral'>        }</span>
  2696 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2697 |     | <span class='neutral'>        assembly {</span>
  2698 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2699 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2700 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2701 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2702 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2703 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2704 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2705 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2706 |     | <span class='neutral'>        }</span>
  2707 |     | <span class='neutral'>    }</span>
  2708 |     | <span class='neutral'></span>
  2709 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2) internal pure {</span>
  2710 |     | <span class='neutral'>        bytes32 m0;</span>
  2711 |     | <span class='neutral'>        bytes32 m1;</span>
  2712 |     | <span class='neutral'>        bytes32 m2;</span>
  2713 |     | <span class='neutral'>        bytes32 m3;</span>
  2714 |     | <span class='neutral'>        bytes32 m4;</span>
  2715 |     | <span class='neutral'>        bytes32 m5;</span>
  2716 |     | <span class='neutral'>        bytes32 m6;</span>
  2717 |     | <span class='neutral'>        bytes32 m7;</span>
  2718 |     | <span class='neutral'>        assembly {</span>
  2719 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2720 |     | <span class='neutral'>                let length := 0</span>
  2721 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2722 |     | <span class='neutral'>                mstore(pos, length)</span>
  2723 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2724 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2725 |     | <span class='neutral'>            }</span>
  2726 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2727 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2728 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2729 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2730 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2731 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2732 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2733 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2734 |     | <span class='neutral'>            // Selector of `log(string,string,uint256)`.</span>
  2735 |     | <span class='neutral'>            mstore(0x00, 0x5821efa1)</span>
  2736 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2737 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2738 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2739 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2740 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2741 |     | <span class='neutral'>        }</span>
  2742 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xe4);</span>
  2743 |     | <span class='neutral'>        assembly {</span>
  2744 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2745 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2746 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2747 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2748 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2749 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2750 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2751 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2752 |     | <span class='neutral'>        }</span>
  2753 |     | <span class='neutral'>    }</span>
  2754 |     | <span class='neutral'></span>
  2755 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2) internal pure {</span>
  2756 |     | <span class='neutral'>        bytes32 m0;</span>
  2757 |     | <span class='neutral'>        bytes32 m1;</span>
  2758 |     | <span class='neutral'>        bytes32 m2;</span>
  2759 |     | <span class='neutral'>        bytes32 m3;</span>
  2760 |     | <span class='neutral'>        bytes32 m4;</span>
  2761 |     | <span class='neutral'>        bytes32 m5;</span>
  2762 |     | <span class='neutral'>        bytes32 m6;</span>
  2763 |     | <span class='neutral'>        bytes32 m7;</span>
  2764 |     | <span class='neutral'>        bytes32 m8;</span>
  2765 |     | <span class='neutral'>        bytes32 m9;</span>
  2766 |     | <span class='neutral'>        assembly {</span>
  2767 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2768 |     | <span class='neutral'>                let length := 0</span>
  2769 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2770 |     | <span class='neutral'>                mstore(pos, length)</span>
  2771 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2772 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2773 |     | <span class='neutral'>            }</span>
  2774 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2775 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2776 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2777 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2778 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2779 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2780 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2781 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  2782 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  2783 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  2784 |     | <span class='neutral'>            // Selector of `log(string,string,string)`.</span>
  2785 |     | <span class='neutral'>            mstore(0x00, 0x2ced7cef)</span>
  2786 |     | <span class='neutral'>            mstore(0x20, 0x60)</span>
  2787 |     | <span class='neutral'>            mstore(0x40, 0xa0)</span>
  2788 |     | <span class='neutral'>            mstore(0x60, 0xe0)</span>
  2789 |     | <span class='neutral'>            writeString(0x80, p0)</span>
  2790 |     | <span class='neutral'>            writeString(0xc0, p1)</span>
  2791 |     | <span class='neutral'>            writeString(0x100, p2)</span>
  2792 |     | <span class='neutral'>        }</span>
  2793 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x124);</span>
  2794 |     | <span class='neutral'>        assembly {</span>
  2795 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2796 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2797 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2798 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2799 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2800 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2801 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2802 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  2803 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  2804 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  2805 |     | <span class='neutral'>        }</span>
  2806 |     | <span class='neutral'>    }</span>
  2807 |     | <span class='neutral'></span>
  2808 |     | <span class='neutral'>    function log(address p0, address p1, address p2, address p3) internal pure {</span>
  2809 |     | <span class='neutral'>        bytes32 m0;</span>
  2810 |     | <span class='neutral'>        bytes32 m1;</span>
  2811 |     | <span class='neutral'>        bytes32 m2;</span>
  2812 |     | <span class='neutral'>        bytes32 m3;</span>
  2813 |     | <span class='neutral'>        bytes32 m4;</span>
  2814 |     | <span class='neutral'>        assembly {</span>
  2815 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2816 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2817 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2818 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2819 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2820 |     | <span class='neutral'>            // Selector of `log(address,address,address,address)`.</span>
  2821 |     | <span class='neutral'>            mstore(0x00, 0x665bf134)</span>
  2822 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2823 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2824 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2825 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2826 |     | <span class='neutral'>        }</span>
  2827 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2828 |     | <span class='neutral'>        assembly {</span>
  2829 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2830 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2831 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2832 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2833 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2834 |     | <span class='neutral'>        }</span>
  2835 |     | <span class='neutral'>    }</span>
  2836 |     | <span class='neutral'></span>
  2837 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bool p3) internal pure {</span>
  2838 |     | <span class='neutral'>        bytes32 m0;</span>
  2839 |     | <span class='neutral'>        bytes32 m1;</span>
  2840 |     | <span class='neutral'>        bytes32 m2;</span>
  2841 |     | <span class='neutral'>        bytes32 m3;</span>
  2842 |     | <span class='neutral'>        bytes32 m4;</span>
  2843 |     | <span class='neutral'>        assembly {</span>
  2844 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2845 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2846 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2847 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2848 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2849 |     | <span class='neutral'>            // Selector of `log(address,address,address,bool)`.</span>
  2850 |     | <span class='neutral'>            mstore(0x00, 0x0e378994)</span>
  2851 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2852 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2853 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2854 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2855 |     | <span class='neutral'>        }</span>
  2856 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2857 |     | <span class='neutral'>        assembly {</span>
  2858 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2859 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2860 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2861 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2862 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2863 |     | <span class='neutral'>        }</span>
  2864 |     | <span class='neutral'>    }</span>
  2865 |     | <span class='neutral'></span>
  2866 |     | <span class='neutral'>    function log(address p0, address p1, address p2, uint256 p3) internal pure {</span>
  2867 |     | <span class='neutral'>        bytes32 m0;</span>
  2868 |     | <span class='neutral'>        bytes32 m1;</span>
  2869 |     | <span class='neutral'>        bytes32 m2;</span>
  2870 |     | <span class='neutral'>        bytes32 m3;</span>
  2871 |     | <span class='neutral'>        bytes32 m4;</span>
  2872 |     | <span class='neutral'>        assembly {</span>
  2873 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2874 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2875 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2876 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2877 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2878 |     | <span class='neutral'>            // Selector of `log(address,address,address,uint256)`.</span>
  2879 |     | <span class='neutral'>            mstore(0x00, 0x94250d77)</span>
  2880 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2881 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2882 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2883 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2884 |     | <span class='neutral'>        }</span>
  2885 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2886 |     | <span class='neutral'>        assembly {</span>
  2887 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2888 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2889 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2890 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2891 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2892 |     | <span class='neutral'>        }</span>
  2893 |     | <span class='neutral'>    }</span>
  2894 |     | <span class='neutral'></span>
  2895 |     | <span class='neutral'>    function log(address p0, address p1, address p2, bytes32 p3) internal pure {</span>
  2896 |     | <span class='neutral'>        bytes32 m0;</span>
  2897 |     | <span class='neutral'>        bytes32 m1;</span>
  2898 |     | <span class='neutral'>        bytes32 m2;</span>
  2899 |     | <span class='neutral'>        bytes32 m3;</span>
  2900 |     | <span class='neutral'>        bytes32 m4;</span>
  2901 |     | <span class='neutral'>        bytes32 m5;</span>
  2902 |     | <span class='neutral'>        bytes32 m6;</span>
  2903 |     | <span class='neutral'>        assembly {</span>
  2904 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  2905 |     | <span class='neutral'>                let length := 0</span>
  2906 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  2907 |     | <span class='neutral'>                mstore(pos, length)</span>
  2908 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  2909 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  2910 |     | <span class='neutral'>            }</span>
  2911 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2912 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2913 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2914 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2915 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2916 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  2917 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  2918 |     | <span class='neutral'>            // Selector of `log(address,address,address,string)`.</span>
  2919 |     | <span class='neutral'>            mstore(0x00, 0xf808da20)</span>
  2920 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2921 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2922 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2923 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  2924 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  2925 |     | <span class='neutral'>        }</span>
  2926 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  2927 |     | <span class='neutral'>        assembly {</span>
  2928 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2929 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2930 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2931 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2932 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2933 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  2934 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  2935 |     | <span class='neutral'>        }</span>
  2936 |     | <span class='neutral'>    }</span>
  2937 |     | <span class='neutral'></span>
  2938 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, address p3) internal pure {</span>
  2939 |     | <span class='neutral'>        bytes32 m0;</span>
  2940 |     | <span class='neutral'>        bytes32 m1;</span>
  2941 |     | <span class='neutral'>        bytes32 m2;</span>
  2942 |     | <span class='neutral'>        bytes32 m3;</span>
  2943 |     | <span class='neutral'>        bytes32 m4;</span>
  2944 |     | <span class='neutral'>        assembly {</span>
  2945 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2946 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2947 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2948 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2949 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2950 |     | <span class='neutral'>            // Selector of `log(address,address,bool,address)`.</span>
  2951 |     | <span class='neutral'>            mstore(0x00, 0x9f1bc36e)</span>
  2952 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2953 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2954 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2955 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2956 |     | <span class='neutral'>        }</span>
  2957 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2958 |     | <span class='neutral'>        assembly {</span>
  2959 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2960 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2961 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2962 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2963 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2964 |     | <span class='neutral'>        }</span>
  2965 |     | <span class='neutral'>    }</span>
  2966 |     | <span class='neutral'></span>
  2967 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bool p3) internal pure {</span>
  2968 |     | <span class='neutral'>        bytes32 m0;</span>
  2969 |     | <span class='neutral'>        bytes32 m1;</span>
  2970 |     | <span class='neutral'>        bytes32 m2;</span>
  2971 |     | <span class='neutral'>        bytes32 m3;</span>
  2972 |     | <span class='neutral'>        bytes32 m4;</span>
  2973 |     | <span class='neutral'>        assembly {</span>
  2974 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  2975 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  2976 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  2977 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  2978 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  2979 |     | <span class='neutral'>            // Selector of `log(address,address,bool,bool)`.</span>
  2980 |     | <span class='neutral'>            mstore(0x00, 0x2cd4134a)</span>
  2981 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  2982 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  2983 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  2984 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  2985 |     | <span class='neutral'>        }</span>
  2986 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  2987 |     | <span class='neutral'>        assembly {</span>
  2988 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  2989 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  2990 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  2991 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  2992 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  2993 |     | <span class='neutral'>        }</span>
  2994 |     | <span class='neutral'>    }</span>
  2995 |     | <span class='neutral'></span>
  2996 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, uint256 p3) internal pure {</span>
  2997 |     | <span class='neutral'>        bytes32 m0;</span>
  2998 |     | <span class='neutral'>        bytes32 m1;</span>
  2999 |     | <span class='neutral'>        bytes32 m2;</span>
  3000 |     | <span class='neutral'>        bytes32 m3;</span>
  3001 |     | <span class='neutral'>        bytes32 m4;</span>
  3002 |     | <span class='neutral'>        assembly {</span>
  3003 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3004 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3005 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3006 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3007 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3008 |     | <span class='neutral'>            // Selector of `log(address,address,bool,uint256)`.</span>
  3009 |     | <span class='neutral'>            mstore(0x00, 0x3971e78c)</span>
  3010 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3011 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3012 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3013 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3014 |     | <span class='neutral'>        }</span>
  3015 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3016 |     | <span class='neutral'>        assembly {</span>
  3017 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3018 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3019 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3020 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3021 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3022 |     | <span class='neutral'>        }</span>
  3023 |     | <span class='neutral'>    }</span>
  3024 |     | <span class='neutral'></span>
  3025 |     | <span class='neutral'>    function log(address p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  3026 |     | <span class='neutral'>        bytes32 m0;</span>
  3027 |     | <span class='neutral'>        bytes32 m1;</span>
  3028 |     | <span class='neutral'>        bytes32 m2;</span>
  3029 |     | <span class='neutral'>        bytes32 m3;</span>
  3030 |     | <span class='neutral'>        bytes32 m4;</span>
  3031 |     | <span class='neutral'>        bytes32 m5;</span>
  3032 |     | <span class='neutral'>        bytes32 m6;</span>
  3033 |     | <span class='neutral'>        assembly {</span>
  3034 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3035 |     | <span class='neutral'>                let length := 0</span>
  3036 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3037 |     | <span class='neutral'>                mstore(pos, length)</span>
  3038 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3039 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3040 |     | <span class='neutral'>            }</span>
  3041 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3042 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3043 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3044 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3045 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3046 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3047 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3048 |     | <span class='neutral'>            // Selector of `log(address,address,bool,string)`.</span>
  3049 |     | <span class='neutral'>            mstore(0x00, 0xaa6540c8)</span>
  3050 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3051 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3052 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3053 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3054 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3055 |     | <span class='neutral'>        }</span>
  3056 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3057 |     | <span class='neutral'>        assembly {</span>
  3058 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3059 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3060 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3061 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3062 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3063 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3064 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3065 |     | <span class='neutral'>        }</span>
  3066 |     | <span class='neutral'>    }</span>
  3067 |     | <span class='neutral'></span>
  3068 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, address p3) internal pure {</span>
  3069 |     | <span class='neutral'>        bytes32 m0;</span>
  3070 |     | <span class='neutral'>        bytes32 m1;</span>
  3071 |     | <span class='neutral'>        bytes32 m2;</span>
  3072 |     | <span class='neutral'>        bytes32 m3;</span>
  3073 |     | <span class='neutral'>        bytes32 m4;</span>
  3074 |     | <span class='neutral'>        assembly {</span>
  3075 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3076 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3077 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3078 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3079 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3080 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,address)`.</span>
  3081 |     | <span class='neutral'>            mstore(0x00, 0x8da6def5)</span>
  3082 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3083 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3084 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3085 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3086 |     | <span class='neutral'>        }</span>
  3087 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3088 |     | <span class='neutral'>        assembly {</span>
  3089 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3090 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3091 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3092 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3093 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3094 |     | <span class='neutral'>        }</span>
  3095 |     | <span class='neutral'>    }</span>
  3096 |     | <span class='neutral'></span>
  3097 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bool p3) internal pure {</span>
  3098 |     | <span class='neutral'>        bytes32 m0;</span>
  3099 |     | <span class='neutral'>        bytes32 m1;</span>
  3100 |     | <span class='neutral'>        bytes32 m2;</span>
  3101 |     | <span class='neutral'>        bytes32 m3;</span>
  3102 |     | <span class='neutral'>        bytes32 m4;</span>
  3103 |     | <span class='neutral'>        assembly {</span>
  3104 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3105 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3106 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3107 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3108 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3109 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,bool)`.</span>
  3110 |     | <span class='neutral'>            mstore(0x00, 0x9b4254e2)</span>
  3111 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3112 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3113 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3114 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3115 |     | <span class='neutral'>        }</span>
  3116 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3117 |     | <span class='neutral'>        assembly {</span>
  3118 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3119 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3120 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3121 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3122 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3123 |     | <span class='neutral'>        }</span>
  3124 |     | <span class='neutral'>    }</span>
  3125 |     | <span class='neutral'></span>
  3126 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  3127 |     | <span class='neutral'>        bytes32 m0;</span>
  3128 |     | <span class='neutral'>        bytes32 m1;</span>
  3129 |     | <span class='neutral'>        bytes32 m2;</span>
  3130 |     | <span class='neutral'>        bytes32 m3;</span>
  3131 |     | <span class='neutral'>        bytes32 m4;</span>
  3132 |     | <span class='neutral'>        assembly {</span>
  3133 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3134 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3135 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3136 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3137 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3138 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,uint256)`.</span>
  3139 |     | <span class='neutral'>            mstore(0x00, 0xbe553481)</span>
  3140 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3141 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3142 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3143 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3144 |     | <span class='neutral'>        }</span>
  3145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3146 |     | <span class='neutral'>        assembly {</span>
  3147 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3148 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3149 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3150 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3151 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3152 |     | <span class='neutral'>        }</span>
  3153 |     | <span class='neutral'>    }</span>
  3154 |     | <span class='neutral'></span>
  3155 |     | <span class='neutral'>    function log(address p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  3156 |     | <span class='neutral'>        bytes32 m0;</span>
  3157 |     | <span class='neutral'>        bytes32 m1;</span>
  3158 |     | <span class='neutral'>        bytes32 m2;</span>
  3159 |     | <span class='neutral'>        bytes32 m3;</span>
  3160 |     | <span class='neutral'>        bytes32 m4;</span>
  3161 |     | <span class='neutral'>        bytes32 m5;</span>
  3162 |     | <span class='neutral'>        bytes32 m6;</span>
  3163 |     | <span class='neutral'>        assembly {</span>
  3164 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3165 |     | <span class='neutral'>                let length := 0</span>
  3166 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3167 |     | <span class='neutral'>                mstore(pos, length)</span>
  3168 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3169 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3170 |     | <span class='neutral'>            }</span>
  3171 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3172 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3173 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3174 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3175 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3176 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3177 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3178 |     | <span class='neutral'>            // Selector of `log(address,address,uint256,string)`.</span>
  3179 |     | <span class='neutral'>            mstore(0x00, 0xfdb4f990)</span>
  3180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3183 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3184 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3185 |     | <span class='neutral'>        }</span>
  3186 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3187 |     | <span class='neutral'>        assembly {</span>
  3188 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3189 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3190 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3191 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3192 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3193 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3194 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3195 |     | <span class='neutral'>        }</span>
  3196 |     | <span class='neutral'>    }</span>
  3197 |     | <span class='neutral'></span>
  3198 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, address p3) internal pure {</span>
  3199 |     | <span class='neutral'>        bytes32 m0;</span>
  3200 |     | <span class='neutral'>        bytes32 m1;</span>
  3201 |     | <span class='neutral'>        bytes32 m2;</span>
  3202 |     | <span class='neutral'>        bytes32 m3;</span>
  3203 |     | <span class='neutral'>        bytes32 m4;</span>
  3204 |     | <span class='neutral'>        bytes32 m5;</span>
  3205 |     | <span class='neutral'>        bytes32 m6;</span>
  3206 |     | <span class='neutral'>        assembly {</span>
  3207 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3208 |     | <span class='neutral'>                let length := 0</span>
  3209 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3210 |     | <span class='neutral'>                mstore(pos, length)</span>
  3211 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3212 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3213 |     | <span class='neutral'>            }</span>
  3214 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3215 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3216 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3217 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3218 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3219 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3220 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3221 |     | <span class='neutral'>            // Selector of `log(address,address,string,address)`.</span>
  3222 |     | <span class='neutral'>            mstore(0x00, 0x8f736d16)</span>
  3223 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3224 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3225 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3226 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3227 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3228 |     | <span class='neutral'>        }</span>
  3229 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3230 |     | <span class='neutral'>        assembly {</span>
  3231 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3232 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3233 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3234 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3235 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3236 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3237 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3238 |     | <span class='neutral'>        }</span>
  3239 |     | <span class='neutral'>    }</span>
  3240 |     | <span class='neutral'></span>
  3241 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  3242 |     | <span class='neutral'>        bytes32 m0;</span>
  3243 |     | <span class='neutral'>        bytes32 m1;</span>
  3244 |     | <span class='neutral'>        bytes32 m2;</span>
  3245 |     | <span class='neutral'>        bytes32 m3;</span>
  3246 |     | <span class='neutral'>        bytes32 m4;</span>
  3247 |     | <span class='neutral'>        bytes32 m5;</span>
  3248 |     | <span class='neutral'>        bytes32 m6;</span>
  3249 |     | <span class='neutral'>        assembly {</span>
  3250 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3251 |     | <span class='neutral'>                let length := 0</span>
  3252 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3253 |     | <span class='neutral'>                mstore(pos, length)</span>
  3254 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3255 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3256 |     | <span class='neutral'>            }</span>
  3257 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3258 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3259 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3260 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3261 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3262 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3263 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3264 |     | <span class='neutral'>            // Selector of `log(address,address,string,bool)`.</span>
  3265 |     | <span class='neutral'>            mstore(0x00, 0x6f1a594e)</span>
  3266 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3267 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3268 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3269 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3270 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3271 |     | <span class='neutral'>        }</span>
  3272 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3273 |     | <span class='neutral'>        assembly {</span>
  3274 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3275 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3276 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3277 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3278 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3279 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3280 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3281 |     | <span class='neutral'>        }</span>
  3282 |     | <span class='neutral'>    }</span>
  3283 |     | <span class='neutral'></span>
  3284 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  3285 |     | <span class='neutral'>        bytes32 m0;</span>
  3286 |     | <span class='neutral'>        bytes32 m1;</span>
  3287 |     | <span class='neutral'>        bytes32 m2;</span>
  3288 |     | <span class='neutral'>        bytes32 m3;</span>
  3289 |     | <span class='neutral'>        bytes32 m4;</span>
  3290 |     | <span class='neutral'>        bytes32 m5;</span>
  3291 |     | <span class='neutral'>        bytes32 m6;</span>
  3292 |     | <span class='neutral'>        assembly {</span>
  3293 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3294 |     | <span class='neutral'>                let length := 0</span>
  3295 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3296 |     | <span class='neutral'>                mstore(pos, length)</span>
  3297 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3298 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3299 |     | <span class='neutral'>            }</span>
  3300 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3301 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3302 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3303 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3304 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3305 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3306 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3307 |     | <span class='neutral'>            // Selector of `log(address,address,string,uint256)`.</span>
  3308 |     | <span class='neutral'>            mstore(0x00, 0xef1cefe7)</span>
  3309 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3310 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3311 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3312 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3313 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3314 |     | <span class='neutral'>        }</span>
  3315 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3316 |     | <span class='neutral'>        assembly {</span>
  3317 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3318 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3319 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3320 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3321 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3322 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3323 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3324 |     | <span class='neutral'>        }</span>
  3325 |     | <span class='neutral'>    }</span>
  3326 |     | <span class='neutral'></span>
  3327 |     | <span class='neutral'>    function log(address p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3328 |     | <span class='neutral'>        bytes32 m0;</span>
  3329 |     | <span class='neutral'>        bytes32 m1;</span>
  3330 |     | <span class='neutral'>        bytes32 m2;</span>
  3331 |     | <span class='neutral'>        bytes32 m3;</span>
  3332 |     | <span class='neutral'>        bytes32 m4;</span>
  3333 |     | <span class='neutral'>        bytes32 m5;</span>
  3334 |     | <span class='neutral'>        bytes32 m6;</span>
  3335 |     | <span class='neutral'>        bytes32 m7;</span>
  3336 |     | <span class='neutral'>        bytes32 m8;</span>
  3337 |     | <span class='neutral'>        assembly {</span>
  3338 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3339 |     | <span class='neutral'>                let length := 0</span>
  3340 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3341 |     | <span class='neutral'>                mstore(pos, length)</span>
  3342 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3343 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3344 |     | <span class='neutral'>            }</span>
  3345 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3346 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3347 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3348 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3349 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3350 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3351 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3352 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3353 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3354 |     | <span class='neutral'>            // Selector of `log(address,address,string,string)`.</span>
  3355 |     | <span class='neutral'>            mstore(0x00, 0x21bdaf25)</span>
  3356 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3357 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3358 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3359 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3360 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3361 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3362 |     | <span class='neutral'>        }</span>
  3363 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3364 |     | <span class='neutral'>        assembly {</span>
  3365 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3366 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3367 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3368 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3369 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3370 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3371 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3372 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3373 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3374 |     | <span class='neutral'>        }</span>
  3375 |     | <span class='neutral'>    }</span>
  3376 |     | <span class='neutral'></span>
  3377 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, address p3) internal pure {</span>
  3378 |     | <span class='neutral'>        bytes32 m0;</span>
  3379 |     | <span class='neutral'>        bytes32 m1;</span>
  3380 |     | <span class='neutral'>        bytes32 m2;</span>
  3381 |     | <span class='neutral'>        bytes32 m3;</span>
  3382 |     | <span class='neutral'>        bytes32 m4;</span>
  3383 |     | <span class='neutral'>        assembly {</span>
  3384 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3385 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3386 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3387 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3388 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3389 |     | <span class='neutral'>            // Selector of `log(address,bool,address,address)`.</span>
  3390 |     | <span class='neutral'>            mstore(0x00, 0x660375dd)</span>
  3391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3394 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3395 |     | <span class='neutral'>        }</span>
  3396 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3397 |     | <span class='neutral'>        assembly {</span>
  3398 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3399 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3400 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3401 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3402 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3403 |     | <span class='neutral'>        }</span>
  3404 |     | <span class='neutral'>    }</span>
  3405 |     | <span class='neutral'></span>
  3406 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bool p3) internal pure {</span>
  3407 |     | <span class='neutral'>        bytes32 m0;</span>
  3408 |     | <span class='neutral'>        bytes32 m1;</span>
  3409 |     | <span class='neutral'>        bytes32 m2;</span>
  3410 |     | <span class='neutral'>        bytes32 m3;</span>
  3411 |     | <span class='neutral'>        bytes32 m4;</span>
  3412 |     | <span class='neutral'>        assembly {</span>
  3413 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3414 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3415 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3416 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3417 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3418 |     | <span class='neutral'>            // Selector of `log(address,bool,address,bool)`.</span>
  3419 |     | <span class='neutral'>            mstore(0x00, 0xa6f50b0f)</span>
  3420 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3421 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3422 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3423 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3424 |     | <span class='neutral'>        }</span>
  3425 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3426 |     | <span class='neutral'>        assembly {</span>
  3427 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3428 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3429 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3430 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3431 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3432 |     | <span class='neutral'>        }</span>
  3433 |     | <span class='neutral'>    }</span>
  3434 |     | <span class='neutral'></span>
  3435 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, uint256 p3) internal pure {</span>
  3436 |     | <span class='neutral'>        bytes32 m0;</span>
  3437 |     | <span class='neutral'>        bytes32 m1;</span>
  3438 |     | <span class='neutral'>        bytes32 m2;</span>
  3439 |     | <span class='neutral'>        bytes32 m3;</span>
  3440 |     | <span class='neutral'>        bytes32 m4;</span>
  3441 |     | <span class='neutral'>        assembly {</span>
  3442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3447 |     | <span class='neutral'>            // Selector of `log(address,bool,address,uint256)`.</span>
  3448 |     | <span class='neutral'>            mstore(0x00, 0xa75c59de)</span>
  3449 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3450 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3451 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3452 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3453 |     | <span class='neutral'>        }</span>
  3454 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3455 |     | <span class='neutral'>        assembly {</span>
  3456 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3457 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3458 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3459 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3460 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3461 |     | <span class='neutral'>        }</span>
  3462 |     | <span class='neutral'>    }</span>
  3463 |     | <span class='neutral'></span>
  3464 |     | <span class='neutral'>    function log(address p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  3465 |     | <span class='neutral'>        bytes32 m0;</span>
  3466 |     | <span class='neutral'>        bytes32 m1;</span>
  3467 |     | <span class='neutral'>        bytes32 m2;</span>
  3468 |     | <span class='neutral'>        bytes32 m3;</span>
  3469 |     | <span class='neutral'>        bytes32 m4;</span>
  3470 |     | <span class='neutral'>        bytes32 m5;</span>
  3471 |     | <span class='neutral'>        bytes32 m6;</span>
  3472 |     | <span class='neutral'>        assembly {</span>
  3473 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3474 |     | <span class='neutral'>                let length := 0</span>
  3475 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3476 |     | <span class='neutral'>                mstore(pos, length)</span>
  3477 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3478 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3479 |     | <span class='neutral'>            }</span>
  3480 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3481 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3482 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3483 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3484 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3485 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3486 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3487 |     | <span class='neutral'>            // Selector of `log(address,bool,address,string)`.</span>
  3488 |     | <span class='neutral'>            mstore(0x00, 0x2dd778e6)</span>
  3489 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3490 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3491 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3492 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3493 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3494 |     | <span class='neutral'>        }</span>
  3495 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3496 |     | <span class='neutral'>        assembly {</span>
  3497 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3498 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3499 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3500 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3501 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3502 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3503 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3504 |     | <span class='neutral'>        }</span>
  3505 |     | <span class='neutral'>    }</span>
  3506 |     | <span class='neutral'></span>
  3507 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, address p3) internal pure {</span>
  3508 |     | <span class='neutral'>        bytes32 m0;</span>
  3509 |     | <span class='neutral'>        bytes32 m1;</span>
  3510 |     | <span class='neutral'>        bytes32 m2;</span>
  3511 |     | <span class='neutral'>        bytes32 m3;</span>
  3512 |     | <span class='neutral'>        bytes32 m4;</span>
  3513 |     | <span class='neutral'>        assembly {</span>
  3514 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3515 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3516 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3517 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3518 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3519 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,address)`.</span>
  3520 |     | <span class='neutral'>            mstore(0x00, 0xcf394485)</span>
  3521 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3523 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3524 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3525 |     | <span class='neutral'>        }</span>
  3526 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3527 |     | <span class='neutral'>        assembly {</span>
  3528 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3529 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3530 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3531 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3532 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3533 |     | <span class='neutral'>        }</span>
  3534 |     | <span class='neutral'>    }</span>
  3535 |     | <span class='neutral'></span>
  3536 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bool p3) internal pure {</span>
  3537 |     | <span class='neutral'>        bytes32 m0;</span>
  3538 |     | <span class='neutral'>        bytes32 m1;</span>
  3539 |     | <span class='neutral'>        bytes32 m2;</span>
  3540 |     | <span class='neutral'>        bytes32 m3;</span>
  3541 |     | <span class='neutral'>        bytes32 m4;</span>
  3542 |     | <span class='neutral'>        assembly {</span>
  3543 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3544 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3545 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3546 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3547 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3548 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,bool)`.</span>
  3549 |     | <span class='neutral'>            mstore(0x00, 0xcac43479)</span>
  3550 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3551 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3552 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3553 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3554 |     | <span class='neutral'>        }</span>
  3555 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3556 |     | <span class='neutral'>        assembly {</span>
  3557 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3558 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3559 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3560 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3561 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3562 |     | <span class='neutral'>        }</span>
  3563 |     | <span class='neutral'>    }</span>
  3564 |     | <span class='neutral'></span>
  3565 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  3566 |     | <span class='neutral'>        bytes32 m0;</span>
  3567 |     | <span class='neutral'>        bytes32 m1;</span>
  3568 |     | <span class='neutral'>        bytes32 m2;</span>
  3569 |     | <span class='neutral'>        bytes32 m3;</span>
  3570 |     | <span class='neutral'>        bytes32 m4;</span>
  3571 |     | <span class='neutral'>        assembly {</span>
  3572 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3573 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3574 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3575 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3576 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3577 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,uint256)`.</span>
  3578 |     | <span class='neutral'>            mstore(0x00, 0x8c4e5de6)</span>
  3579 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3580 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3581 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3582 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3583 |     | <span class='neutral'>        }</span>
  3584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3585 |     | <span class='neutral'>        assembly {</span>
  3586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3591 |     | <span class='neutral'>        }</span>
  3592 |     | <span class='neutral'>    }</span>
  3593 |     | <span class='neutral'></span>
  3594 |     | <span class='neutral'>    function log(address p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  3595 |     | <span class='neutral'>        bytes32 m0;</span>
  3596 |     | <span class='neutral'>        bytes32 m1;</span>
  3597 |     | <span class='neutral'>        bytes32 m2;</span>
  3598 |     | <span class='neutral'>        bytes32 m3;</span>
  3599 |     | <span class='neutral'>        bytes32 m4;</span>
  3600 |     | <span class='neutral'>        bytes32 m5;</span>
  3601 |     | <span class='neutral'>        bytes32 m6;</span>
  3602 |     | <span class='neutral'>        assembly {</span>
  3603 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3604 |     | <span class='neutral'>                let length := 0</span>
  3605 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3606 |     | <span class='neutral'>                mstore(pos, length)</span>
  3607 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3608 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3609 |     | <span class='neutral'>            }</span>
  3610 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3611 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3612 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3613 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3614 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3615 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3616 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3617 |     | <span class='neutral'>            // Selector of `log(address,bool,bool,string)`.</span>
  3618 |     | <span class='neutral'>            mstore(0x00, 0xdfc4a2e8)</span>
  3619 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3620 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3621 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3622 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3623 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3624 |     | <span class='neutral'>        }</span>
  3625 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3626 |     | <span class='neutral'>        assembly {</span>
  3627 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3628 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3629 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3630 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3631 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3632 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3633 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3634 |     | <span class='neutral'>        }</span>
  3635 |     | <span class='neutral'>    }</span>
  3636 |     | <span class='neutral'></span>
  3637 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, address p3) internal pure {</span>
  3638 |     | <span class='neutral'>        bytes32 m0;</span>
  3639 |     | <span class='neutral'>        bytes32 m1;</span>
  3640 |     | <span class='neutral'>        bytes32 m2;</span>
  3641 |     | <span class='neutral'>        bytes32 m3;</span>
  3642 |     | <span class='neutral'>        bytes32 m4;</span>
  3643 |     | <span class='neutral'>        assembly {</span>
  3644 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3645 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3646 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3647 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3648 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3649 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,address)`.</span>
  3650 |     | <span class='neutral'>            mstore(0x00, 0xccf790a1)</span>
  3651 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3652 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3653 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3654 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3655 |     | <span class='neutral'>        }</span>
  3656 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3657 |     | <span class='neutral'>        assembly {</span>
  3658 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3659 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3660 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3661 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3662 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3663 |     | <span class='neutral'>        }</span>
  3664 |     | <span class='neutral'>    }</span>
  3665 |     | <span class='neutral'></span>
  3666 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  3667 |     | <span class='neutral'>        bytes32 m0;</span>
  3668 |     | <span class='neutral'>        bytes32 m1;</span>
  3669 |     | <span class='neutral'>        bytes32 m2;</span>
  3670 |     | <span class='neutral'>        bytes32 m3;</span>
  3671 |     | <span class='neutral'>        bytes32 m4;</span>
  3672 |     | <span class='neutral'>        assembly {</span>
  3673 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3674 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3675 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3676 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3677 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3678 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,bool)`.</span>
  3679 |     | <span class='neutral'>            mstore(0x00, 0xc4643e20)</span>
  3680 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3681 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3682 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3683 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3684 |     | <span class='neutral'>        }</span>
  3685 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3686 |     | <span class='neutral'>        assembly {</span>
  3687 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3688 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3689 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3690 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3691 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3692 |     | <span class='neutral'>        }</span>
  3693 |     | <span class='neutral'>    }</span>
  3694 |     | <span class='neutral'></span>
  3695 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  3696 |     | <span class='neutral'>        bytes32 m0;</span>
  3697 |     | <span class='neutral'>        bytes32 m1;</span>
  3698 |     | <span class='neutral'>        bytes32 m2;</span>
  3699 |     | <span class='neutral'>        bytes32 m3;</span>
  3700 |     | <span class='neutral'>        bytes32 m4;</span>
  3701 |     | <span class='neutral'>        assembly {</span>
  3702 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3703 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3704 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3705 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3706 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3707 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,uint256)`.</span>
  3708 |     | <span class='neutral'>            mstore(0x00, 0x386ff5f4)</span>
  3709 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3710 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3711 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3712 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3713 |     | <span class='neutral'>        }</span>
  3714 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3715 |     | <span class='neutral'>        assembly {</span>
  3716 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3717 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3718 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3719 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3720 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3721 |     | <span class='neutral'>        }</span>
  3722 |     | <span class='neutral'>    }</span>
  3723 |     | <span class='neutral'></span>
  3724 |     | <span class='neutral'>    function log(address p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  3725 |     | <span class='neutral'>        bytes32 m0;</span>
  3726 |     | <span class='neutral'>        bytes32 m1;</span>
  3727 |     | <span class='neutral'>        bytes32 m2;</span>
  3728 |     | <span class='neutral'>        bytes32 m3;</span>
  3729 |     | <span class='neutral'>        bytes32 m4;</span>
  3730 |     | <span class='neutral'>        bytes32 m5;</span>
  3731 |     | <span class='neutral'>        bytes32 m6;</span>
  3732 |     | <span class='neutral'>        assembly {</span>
  3733 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3734 |     | <span class='neutral'>                let length := 0</span>
  3735 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3736 |     | <span class='neutral'>                mstore(pos, length)</span>
  3737 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3738 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3739 |     | <span class='neutral'>            }</span>
  3740 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3741 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3742 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3743 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3744 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3745 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3746 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3747 |     | <span class='neutral'>            // Selector of `log(address,bool,uint256,string)`.</span>
  3748 |     | <span class='neutral'>            mstore(0x00, 0x0aa6cfad)</span>
  3749 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3750 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3751 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3752 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  3753 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  3754 |     | <span class='neutral'>        }</span>
  3755 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3756 |     | <span class='neutral'>        assembly {</span>
  3757 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3758 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3759 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3760 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3761 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3762 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3763 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3764 |     | <span class='neutral'>        }</span>
  3765 |     | <span class='neutral'>    }</span>
  3766 |     | <span class='neutral'></span>
  3767 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  3768 |     | <span class='neutral'>        bytes32 m0;</span>
  3769 |     | <span class='neutral'>        bytes32 m1;</span>
  3770 |     | <span class='neutral'>        bytes32 m2;</span>
  3771 |     | <span class='neutral'>        bytes32 m3;</span>
  3772 |     | <span class='neutral'>        bytes32 m4;</span>
  3773 |     | <span class='neutral'>        bytes32 m5;</span>
  3774 |     | <span class='neutral'>        bytes32 m6;</span>
  3775 |     | <span class='neutral'>        assembly {</span>
  3776 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3777 |     | <span class='neutral'>                let length := 0</span>
  3778 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3779 |     | <span class='neutral'>                mstore(pos, length)</span>
  3780 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3781 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3782 |     | <span class='neutral'>            }</span>
  3783 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3784 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3785 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3786 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3787 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3788 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3789 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3790 |     | <span class='neutral'>            // Selector of `log(address,bool,string,address)`.</span>
  3791 |     | <span class='neutral'>            mstore(0x00, 0x19fd4956)</span>
  3792 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3793 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3794 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3795 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3796 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3797 |     | <span class='neutral'>        }</span>
  3798 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3799 |     | <span class='neutral'>        assembly {</span>
  3800 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3801 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3802 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3803 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3804 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3805 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3806 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3807 |     | <span class='neutral'>        }</span>
  3808 |     | <span class='neutral'>    }</span>
  3809 |     | <span class='neutral'></span>
  3810 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  3811 |     | <span class='neutral'>        bytes32 m0;</span>
  3812 |     | <span class='neutral'>        bytes32 m1;</span>
  3813 |     | <span class='neutral'>        bytes32 m2;</span>
  3814 |     | <span class='neutral'>        bytes32 m3;</span>
  3815 |     | <span class='neutral'>        bytes32 m4;</span>
  3816 |     | <span class='neutral'>        bytes32 m5;</span>
  3817 |     | <span class='neutral'>        bytes32 m6;</span>
  3818 |     | <span class='neutral'>        assembly {</span>
  3819 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3820 |     | <span class='neutral'>                let length := 0</span>
  3821 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3822 |     | <span class='neutral'>                mstore(pos, length)</span>
  3823 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3824 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3825 |     | <span class='neutral'>            }</span>
  3826 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3827 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3828 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3829 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3830 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3831 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3832 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3833 |     | <span class='neutral'>            // Selector of `log(address,bool,string,bool)`.</span>
  3834 |     | <span class='neutral'>            mstore(0x00, 0x50ad461d)</span>
  3835 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3836 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3837 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3838 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3839 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3840 |     | <span class='neutral'>        }</span>
  3841 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3842 |     | <span class='neutral'>        assembly {</span>
  3843 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3844 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3845 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3846 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3847 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3848 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3849 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3850 |     | <span class='neutral'>        }</span>
  3851 |     | <span class='neutral'>    }</span>
  3852 |     | <span class='neutral'></span>
  3853 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  3854 |     | <span class='neutral'>        bytes32 m0;</span>
  3855 |     | <span class='neutral'>        bytes32 m1;</span>
  3856 |     | <span class='neutral'>        bytes32 m2;</span>
  3857 |     | <span class='neutral'>        bytes32 m3;</span>
  3858 |     | <span class='neutral'>        bytes32 m4;</span>
  3859 |     | <span class='neutral'>        bytes32 m5;</span>
  3860 |     | <span class='neutral'>        bytes32 m6;</span>
  3861 |     | <span class='neutral'>        assembly {</span>
  3862 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3863 |     | <span class='neutral'>                let length := 0</span>
  3864 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3865 |     | <span class='neutral'>                mstore(pos, length)</span>
  3866 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3867 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3868 |     | <span class='neutral'>            }</span>
  3869 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3870 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3871 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3872 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3873 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3874 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3875 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3876 |     | <span class='neutral'>            // Selector of `log(address,bool,string,uint256)`.</span>
  3877 |     | <span class='neutral'>            mstore(0x00, 0x80e6a20b)</span>
  3878 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3879 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3880 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3881 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3882 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3883 |     | <span class='neutral'>        }</span>
  3884 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  3885 |     | <span class='neutral'>        assembly {</span>
  3886 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3887 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3888 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3889 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3890 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3891 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3892 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3893 |     | <span class='neutral'>        }</span>
  3894 |     | <span class='neutral'>    }</span>
  3895 |     | <span class='neutral'></span>
  3896 |     | <span class='neutral'>    function log(address p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  3897 |     | <span class='neutral'>        bytes32 m0;</span>
  3898 |     | <span class='neutral'>        bytes32 m1;</span>
  3899 |     | <span class='neutral'>        bytes32 m2;</span>
  3900 |     | <span class='neutral'>        bytes32 m3;</span>
  3901 |     | <span class='neutral'>        bytes32 m4;</span>
  3902 |     | <span class='neutral'>        bytes32 m5;</span>
  3903 |     | <span class='neutral'>        bytes32 m6;</span>
  3904 |     | <span class='neutral'>        bytes32 m7;</span>
  3905 |     | <span class='neutral'>        bytes32 m8;</span>
  3906 |     | <span class='neutral'>        assembly {</span>
  3907 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  3908 |     | <span class='neutral'>                let length := 0</span>
  3909 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  3910 |     | <span class='neutral'>                mstore(pos, length)</span>
  3911 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  3912 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  3913 |     | <span class='neutral'>            }</span>
  3914 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3915 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3916 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3917 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3918 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3919 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  3920 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  3921 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  3922 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  3923 |     | <span class='neutral'>            // Selector of `log(address,bool,string,string)`.</span>
  3924 |     | <span class='neutral'>            mstore(0x00, 0x475c5c33)</span>
  3925 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3926 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3927 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  3928 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  3929 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  3930 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  3931 |     | <span class='neutral'>        }</span>
  3932 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  3933 |     | <span class='neutral'>        assembly {</span>
  3934 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3935 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3936 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3937 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3938 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3939 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  3940 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  3941 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  3942 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  3943 |     | <span class='neutral'>        }</span>
  3944 |     | <span class='neutral'>    }</span>
  3945 |     | <span class='neutral'></span>
  3946 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, address p3) internal pure {</span>
  3947 |     | <span class='neutral'>        bytes32 m0;</span>
  3948 |     | <span class='neutral'>        bytes32 m1;</span>
  3949 |     | <span class='neutral'>        bytes32 m2;</span>
  3950 |     | <span class='neutral'>        bytes32 m3;</span>
  3951 |     | <span class='neutral'>        bytes32 m4;</span>
  3952 |     | <span class='neutral'>        assembly {</span>
  3953 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3954 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3955 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3956 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3957 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3958 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,address)`.</span>
  3959 |     | <span class='neutral'>            mstore(0x00, 0x478d1c62)</span>
  3960 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3961 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3962 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3963 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3964 |     | <span class='neutral'>        }</span>
  3965 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3966 |     | <span class='neutral'>        assembly {</span>
  3967 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3968 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3969 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3970 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  3971 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  3972 |     | <span class='neutral'>        }</span>
  3973 |     | <span class='neutral'>    }</span>
  3974 |     | <span class='neutral'></span>
  3975 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bool p3) internal pure {</span>
  3976 |     | <span class='neutral'>        bytes32 m0;</span>
  3977 |     | <span class='neutral'>        bytes32 m1;</span>
  3978 |     | <span class='neutral'>        bytes32 m2;</span>
  3979 |     | <span class='neutral'>        bytes32 m3;</span>
  3980 |     | <span class='neutral'>        bytes32 m4;</span>
  3981 |     | <span class='neutral'>        assembly {</span>
  3982 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  3983 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  3984 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  3985 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  3986 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  3987 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,bool)`.</span>
  3988 |     | <span class='neutral'>            mstore(0x00, 0xa1bcc9b3)</span>
  3989 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  3990 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  3991 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  3992 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  3993 |     | <span class='neutral'>        }</span>
  3994 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  3995 |     | <span class='neutral'>        assembly {</span>
  3996 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  3997 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  3998 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  3999 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4000 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4001 |     | <span class='neutral'>        }</span>
  4002 |     | <span class='neutral'>    }</span>
  4003 |     | <span class='neutral'></span>
  4004 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  4005 |     | <span class='neutral'>        bytes32 m0;</span>
  4006 |     | <span class='neutral'>        bytes32 m1;</span>
  4007 |     | <span class='neutral'>        bytes32 m2;</span>
  4008 |     | <span class='neutral'>        bytes32 m3;</span>
  4009 |     | <span class='neutral'>        bytes32 m4;</span>
  4010 |     | <span class='neutral'>        assembly {</span>
  4011 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4012 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4013 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4014 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4015 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4016 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,uint256)`.</span>
  4017 |     | <span class='neutral'>            mstore(0x00, 0x100f650e)</span>
  4018 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4019 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4020 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4021 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4022 |     | <span class='neutral'>        }</span>
  4023 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4024 |     | <span class='neutral'>        assembly {</span>
  4025 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4026 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4027 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4028 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4029 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4030 |     | <span class='neutral'>        }</span>
  4031 |     | <span class='neutral'>    }</span>
  4032 |     | <span class='neutral'></span>
  4033 |     | <span class='neutral'>    function log(address p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  4034 |     | <span class='neutral'>        bytes32 m0;</span>
  4035 |     | <span class='neutral'>        bytes32 m1;</span>
  4036 |     | <span class='neutral'>        bytes32 m2;</span>
  4037 |     | <span class='neutral'>        bytes32 m3;</span>
  4038 |     | <span class='neutral'>        bytes32 m4;</span>
  4039 |     | <span class='neutral'>        bytes32 m5;</span>
  4040 |     | <span class='neutral'>        bytes32 m6;</span>
  4041 |     | <span class='neutral'>        assembly {</span>
  4042 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4043 |     | <span class='neutral'>                let length := 0</span>
  4044 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4045 |     | <span class='neutral'>                mstore(pos, length)</span>
  4046 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4047 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4048 |     | <span class='neutral'>            }</span>
  4049 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4050 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4051 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4052 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4053 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4054 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4055 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4056 |     | <span class='neutral'>            // Selector of `log(address,uint256,address,string)`.</span>
  4057 |     | <span class='neutral'>            mstore(0x00, 0x1da986ea)</span>
  4058 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4059 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4060 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4061 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4062 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4063 |     | <span class='neutral'>        }</span>
  4064 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4065 |     | <span class='neutral'>        assembly {</span>
  4066 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4067 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4068 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4069 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4070 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4071 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4072 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4073 |     | <span class='neutral'>        }</span>
  4074 |     | <span class='neutral'>    }</span>
  4075 |     | <span class='neutral'></span>
  4076 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, address p3) internal pure {</span>
  4077 |     | <span class='neutral'>        bytes32 m0;</span>
  4078 |     | <span class='neutral'>        bytes32 m1;</span>
  4079 |     | <span class='neutral'>        bytes32 m2;</span>
  4080 |     | <span class='neutral'>        bytes32 m3;</span>
  4081 |     | <span class='neutral'>        bytes32 m4;</span>
  4082 |     | <span class='neutral'>        assembly {</span>
  4083 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4084 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4085 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4086 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4087 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4088 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,address)`.</span>
  4089 |     | <span class='neutral'>            mstore(0x00, 0xa31bfdcc)</span>
  4090 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4091 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4092 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4093 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4094 |     | <span class='neutral'>        }</span>
  4095 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4096 |     | <span class='neutral'>        assembly {</span>
  4097 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4098 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4099 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4100 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4101 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4102 |     | <span class='neutral'>        }</span>
  4103 |     | <span class='neutral'>    }</span>
  4104 |     | <span class='neutral'></span>
  4105 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  4106 |     | <span class='neutral'>        bytes32 m0;</span>
  4107 |     | <span class='neutral'>        bytes32 m1;</span>
  4108 |     | <span class='neutral'>        bytes32 m2;</span>
  4109 |     | <span class='neutral'>        bytes32 m3;</span>
  4110 |     | <span class='neutral'>        bytes32 m4;</span>
  4111 |     | <span class='neutral'>        assembly {</span>
  4112 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4113 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4114 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4115 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4116 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4117 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,bool)`.</span>
  4118 |     | <span class='neutral'>            mstore(0x00, 0x3bf5e537)</span>
  4119 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4120 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4121 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4122 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4123 |     | <span class='neutral'>        }</span>
  4124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4125 |     | <span class='neutral'>        assembly {</span>
  4126 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4127 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4128 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4129 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4130 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4131 |     | <span class='neutral'>        }</span>
  4132 |     | <span class='neutral'>    }</span>
  4133 |     | <span class='neutral'></span>
  4134 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  4135 |     | <span class='neutral'>        bytes32 m0;</span>
  4136 |     | <span class='neutral'>        bytes32 m1;</span>
  4137 |     | <span class='neutral'>        bytes32 m2;</span>
  4138 |     | <span class='neutral'>        bytes32 m3;</span>
  4139 |     | <span class='neutral'>        bytes32 m4;</span>
  4140 |     | <span class='neutral'>        assembly {</span>
  4141 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4142 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4143 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4144 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4145 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4146 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,uint256)`.</span>
  4147 |     | <span class='neutral'>            mstore(0x00, 0x22f6b999)</span>
  4148 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4149 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4150 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4151 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4152 |     | <span class='neutral'>        }</span>
  4153 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4154 |     | <span class='neutral'>        assembly {</span>
  4155 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4156 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4157 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4158 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4159 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4160 |     | <span class='neutral'>        }</span>
  4161 |     | <span class='neutral'>    }</span>
  4162 |     | <span class='neutral'></span>
  4163 |     | <span class='neutral'>    function log(address p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  4164 |     | <span class='neutral'>        bytes32 m0;</span>
  4165 |     | <span class='neutral'>        bytes32 m1;</span>
  4166 |     | <span class='neutral'>        bytes32 m2;</span>
  4167 |     | <span class='neutral'>        bytes32 m3;</span>
  4168 |     | <span class='neutral'>        bytes32 m4;</span>
  4169 |     | <span class='neutral'>        bytes32 m5;</span>
  4170 |     | <span class='neutral'>        bytes32 m6;</span>
  4171 |     | <span class='neutral'>        assembly {</span>
  4172 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4173 |     | <span class='neutral'>                let length := 0</span>
  4174 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4175 |     | <span class='neutral'>                mstore(pos, length)</span>
  4176 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4177 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4178 |     | <span class='neutral'>            }</span>
  4179 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4180 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4181 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4182 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4183 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4184 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4185 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4186 |     | <span class='neutral'>            // Selector of `log(address,uint256,bool,string)`.</span>
  4187 |     | <span class='neutral'>            mstore(0x00, 0xc5ad85f9)</span>
  4188 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4189 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4190 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4191 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4192 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4193 |     | <span class='neutral'>        }</span>
  4194 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4195 |     | <span class='neutral'>        assembly {</span>
  4196 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4197 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4198 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4199 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4200 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4201 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4202 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4203 |     | <span class='neutral'>        }</span>
  4204 |     | <span class='neutral'>    }</span>
  4205 |     | <span class='neutral'></span>
  4206 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  4207 |     | <span class='neutral'>        bytes32 m0;</span>
  4208 |     | <span class='neutral'>        bytes32 m1;</span>
  4209 |     | <span class='neutral'>        bytes32 m2;</span>
  4210 |     | <span class='neutral'>        bytes32 m3;</span>
  4211 |     | <span class='neutral'>        bytes32 m4;</span>
  4212 |     | <span class='neutral'>        assembly {</span>
  4213 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4214 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4215 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4216 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4217 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4218 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,address)`.</span>
  4219 |     | <span class='neutral'>            mstore(0x00, 0x20e3984d)</span>
  4220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4223 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4224 |     | <span class='neutral'>        }</span>
  4225 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4226 |     | <span class='neutral'>        assembly {</span>
  4227 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4228 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4229 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4230 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4231 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4232 |     | <span class='neutral'>        }</span>
  4233 |     | <span class='neutral'>    }</span>
  4234 |     | <span class='neutral'></span>
  4235 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  4236 |     | <span class='neutral'>        bytes32 m0;</span>
  4237 |     | <span class='neutral'>        bytes32 m1;</span>
  4238 |     | <span class='neutral'>        bytes32 m2;</span>
  4239 |     | <span class='neutral'>        bytes32 m3;</span>
  4240 |     | <span class='neutral'>        bytes32 m4;</span>
  4241 |     | <span class='neutral'>        assembly {</span>
  4242 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4243 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4244 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4245 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4246 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4247 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,bool)`.</span>
  4248 |     | <span class='neutral'>            mstore(0x00, 0x66f1bc67)</span>
  4249 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4250 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4251 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4252 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4253 |     | <span class='neutral'>        }</span>
  4254 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4255 |     | <span class='neutral'>        assembly {</span>
  4256 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4257 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4258 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4259 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4260 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4261 |     | <span class='neutral'>        }</span>
  4262 |     | <span class='neutral'>    }</span>
  4263 |     | <span class='neutral'></span>
  4264 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  4265 |     | <span class='neutral'>        bytes32 m0;</span>
  4266 |     | <span class='neutral'>        bytes32 m1;</span>
  4267 |     | <span class='neutral'>        bytes32 m2;</span>
  4268 |     | <span class='neutral'>        bytes32 m3;</span>
  4269 |     | <span class='neutral'>        bytes32 m4;</span>
  4270 |     | <span class='neutral'>        assembly {</span>
  4271 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4272 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4273 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4274 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4275 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4276 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,uint256)`.</span>
  4277 |     | <span class='neutral'>            mstore(0x00, 0x34f0e636)</span>
  4278 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4279 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4280 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4281 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4282 |     | <span class='neutral'>        }</span>
  4283 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  4284 |     | <span class='neutral'>        assembly {</span>
  4285 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4286 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4287 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4288 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4289 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4290 |     | <span class='neutral'>        }</span>
  4291 |     | <span class='neutral'>    }</span>
  4292 |     | <span class='neutral'></span>
  4293 |     | <span class='neutral'>    function log(address p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  4294 |     | <span class='neutral'>        bytes32 m0;</span>
  4295 |     | <span class='neutral'>        bytes32 m1;</span>
  4296 |     | <span class='neutral'>        bytes32 m2;</span>
  4297 |     | <span class='neutral'>        bytes32 m3;</span>
  4298 |     | <span class='neutral'>        bytes32 m4;</span>
  4299 |     | <span class='neutral'>        bytes32 m5;</span>
  4300 |     | <span class='neutral'>        bytes32 m6;</span>
  4301 |     | <span class='neutral'>        assembly {</span>
  4302 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4303 |     | <span class='neutral'>                let length := 0</span>
  4304 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4305 |     | <span class='neutral'>                mstore(pos, length)</span>
  4306 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4307 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4308 |     | <span class='neutral'>            }</span>
  4309 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4310 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4311 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4312 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4313 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4314 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4315 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4316 |     | <span class='neutral'>            // Selector of `log(address,uint256,uint256,string)`.</span>
  4317 |     | <span class='neutral'>            mstore(0x00, 0x4a28c017)</span>
  4318 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4319 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4320 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4321 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  4322 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  4323 |     | <span class='neutral'>        }</span>
  4324 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4325 |     | <span class='neutral'>        assembly {</span>
  4326 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4327 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4328 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4329 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4330 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4331 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4332 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4333 |     | <span class='neutral'>        }</span>
  4334 |     | <span class='neutral'>    }</span>
  4335 |     | <span class='neutral'></span>
  4336 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  4337 |     | <span class='neutral'>        bytes32 m0;</span>
  4338 |     | <span class='neutral'>        bytes32 m1;</span>
  4339 |     | <span class='neutral'>        bytes32 m2;</span>
  4340 |     | <span class='neutral'>        bytes32 m3;</span>
  4341 |     | <span class='neutral'>        bytes32 m4;</span>
  4342 |     | <span class='neutral'>        bytes32 m5;</span>
  4343 |     | <span class='neutral'>        bytes32 m6;</span>
  4344 |     | <span class='neutral'>        assembly {</span>
  4345 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4346 |     | <span class='neutral'>                let length := 0</span>
  4347 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4348 |     | <span class='neutral'>                mstore(pos, length)</span>
  4349 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4350 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4351 |     | <span class='neutral'>            }</span>
  4352 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4353 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4354 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4355 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4356 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4357 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4358 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4359 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,address)`.</span>
  4360 |     | <span class='neutral'>            mstore(0x00, 0x5c430d47)</span>
  4361 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4362 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4363 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4364 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4365 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4366 |     | <span class='neutral'>        }</span>
  4367 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4368 |     | <span class='neutral'>        assembly {</span>
  4369 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4370 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4371 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4372 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4373 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4374 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4375 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4376 |     | <span class='neutral'>        }</span>
  4377 |     | <span class='neutral'>    }</span>
  4378 |     | <span class='neutral'></span>
  4379 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  4380 |     | <span class='neutral'>        bytes32 m0;</span>
  4381 |     | <span class='neutral'>        bytes32 m1;</span>
  4382 |     | <span class='neutral'>        bytes32 m2;</span>
  4383 |     | <span class='neutral'>        bytes32 m3;</span>
  4384 |     | <span class='neutral'>        bytes32 m4;</span>
  4385 |     | <span class='neutral'>        bytes32 m5;</span>
  4386 |     | <span class='neutral'>        bytes32 m6;</span>
  4387 |     | <span class='neutral'>        assembly {</span>
  4388 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4389 |     | <span class='neutral'>                let length := 0</span>
  4390 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4391 |     | <span class='neutral'>                mstore(pos, length)</span>
  4392 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4393 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4394 |     | <span class='neutral'>            }</span>
  4395 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4396 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4397 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4398 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4399 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4400 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4401 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4402 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,bool)`.</span>
  4403 |     | <span class='neutral'>            mstore(0x00, 0xcf18105c)</span>
  4404 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4405 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4406 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4407 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4408 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4409 |     | <span class='neutral'>        }</span>
  4410 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4411 |     | <span class='neutral'>        assembly {</span>
  4412 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4413 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4414 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4415 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4416 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4417 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4418 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4419 |     | <span class='neutral'>        }</span>
  4420 |     | <span class='neutral'>    }</span>
  4421 |     | <span class='neutral'></span>
  4422 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  4423 |     | <span class='neutral'>        bytes32 m0;</span>
  4424 |     | <span class='neutral'>        bytes32 m1;</span>
  4425 |     | <span class='neutral'>        bytes32 m2;</span>
  4426 |     | <span class='neutral'>        bytes32 m3;</span>
  4427 |     | <span class='neutral'>        bytes32 m4;</span>
  4428 |     | <span class='neutral'>        bytes32 m5;</span>
  4429 |     | <span class='neutral'>        bytes32 m6;</span>
  4430 |     | <span class='neutral'>        assembly {</span>
  4431 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4432 |     | <span class='neutral'>                let length := 0</span>
  4433 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4434 |     | <span class='neutral'>                mstore(pos, length)</span>
  4435 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4436 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4437 |     | <span class='neutral'>            }</span>
  4438 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4439 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4440 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4441 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4442 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4443 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4444 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4445 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,uint256)`.</span>
  4446 |     | <span class='neutral'>            mstore(0x00, 0xbf01f891)</span>
  4447 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4448 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4449 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4450 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4451 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4452 |     | <span class='neutral'>        }</span>
  4453 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4454 |     | <span class='neutral'>        assembly {</span>
  4455 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4456 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4457 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4458 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4459 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4460 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4461 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4462 |     | <span class='neutral'>        }</span>
  4463 |     | <span class='neutral'>    }</span>
  4464 |     | <span class='neutral'></span>
  4465 |     | <span class='neutral'>    function log(address p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  4466 |     | <span class='neutral'>        bytes32 m0;</span>
  4467 |     | <span class='neutral'>        bytes32 m1;</span>
  4468 |     | <span class='neutral'>        bytes32 m2;</span>
  4469 |     | <span class='neutral'>        bytes32 m3;</span>
  4470 |     | <span class='neutral'>        bytes32 m4;</span>
  4471 |     | <span class='neutral'>        bytes32 m5;</span>
  4472 |     | <span class='neutral'>        bytes32 m6;</span>
  4473 |     | <span class='neutral'>        bytes32 m7;</span>
  4474 |     | <span class='neutral'>        bytes32 m8;</span>
  4475 |     | <span class='neutral'>        assembly {</span>
  4476 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4477 |     | <span class='neutral'>                let length := 0</span>
  4478 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4479 |     | <span class='neutral'>                mstore(pos, length)</span>
  4480 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4481 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4482 |     | <span class='neutral'>            }</span>
  4483 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4484 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4485 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4486 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4487 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4488 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4489 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4490 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4491 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4492 |     | <span class='neutral'>            // Selector of `log(address,uint256,string,string)`.</span>
  4493 |     | <span class='neutral'>            mstore(0x00, 0x88a8c406)</span>
  4494 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4495 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  4496 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  4497 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4498 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  4499 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4500 |     | <span class='neutral'>        }</span>
  4501 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4502 |     | <span class='neutral'>        assembly {</span>
  4503 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4504 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4505 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4506 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4507 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4508 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4509 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4510 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4511 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4512 |     | <span class='neutral'>        }</span>
  4513 |     | <span class='neutral'>    }</span>
  4514 |     | <span class='neutral'></span>
  4515 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, address p3) internal pure {</span>
  4516 |     | <span class='neutral'>        bytes32 m0;</span>
  4517 |     | <span class='neutral'>        bytes32 m1;</span>
  4518 |     | <span class='neutral'>        bytes32 m2;</span>
  4519 |     | <span class='neutral'>        bytes32 m3;</span>
  4520 |     | <span class='neutral'>        bytes32 m4;</span>
  4521 |     | <span class='neutral'>        bytes32 m5;</span>
  4522 |     | <span class='neutral'>        bytes32 m6;</span>
  4523 |     | <span class='neutral'>        assembly {</span>
  4524 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4525 |     | <span class='neutral'>                let length := 0</span>
  4526 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4527 |     | <span class='neutral'>                mstore(pos, length)</span>
  4528 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4529 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4530 |     | <span class='neutral'>            }</span>
  4531 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4532 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4533 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4534 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4535 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4536 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4537 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4538 |     | <span class='neutral'>            // Selector of `log(address,string,address,address)`.</span>
  4539 |     | <span class='neutral'>            mstore(0x00, 0x0d36fa20)</span>
  4540 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4541 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4542 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4543 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4544 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4545 |     | <span class='neutral'>        }</span>
  4546 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4547 |     | <span class='neutral'>        assembly {</span>
  4548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4553 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4554 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4555 |     | <span class='neutral'>        }</span>
  4556 |     | <span class='neutral'>    }</span>
  4557 |     | <span class='neutral'></span>
  4558 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  4559 |     | <span class='neutral'>        bytes32 m0;</span>
  4560 |     | <span class='neutral'>        bytes32 m1;</span>
  4561 |     | <span class='neutral'>        bytes32 m2;</span>
  4562 |     | <span class='neutral'>        bytes32 m3;</span>
  4563 |     | <span class='neutral'>        bytes32 m4;</span>
  4564 |     | <span class='neutral'>        bytes32 m5;</span>
  4565 |     | <span class='neutral'>        bytes32 m6;</span>
  4566 |     | <span class='neutral'>        assembly {</span>
  4567 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4568 |     | <span class='neutral'>                let length := 0</span>
  4569 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4570 |     | <span class='neutral'>                mstore(pos, length)</span>
  4571 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4572 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4573 |     | <span class='neutral'>            }</span>
  4574 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4575 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4576 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4577 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4578 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4579 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4580 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4581 |     | <span class='neutral'>            // Selector of `log(address,string,address,bool)`.</span>
  4582 |     | <span class='neutral'>            mstore(0x00, 0x0df12b76)</span>
  4583 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4584 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4585 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4586 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4587 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4588 |     | <span class='neutral'>        }</span>
  4589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4590 |     | <span class='neutral'>        assembly {</span>
  4591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4598 |     | <span class='neutral'>        }</span>
  4599 |     | <span class='neutral'>    }</span>
  4600 |     | <span class='neutral'></span>
  4601 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  4602 |     | <span class='neutral'>        bytes32 m0;</span>
  4603 |     | <span class='neutral'>        bytes32 m1;</span>
  4604 |     | <span class='neutral'>        bytes32 m2;</span>
  4605 |     | <span class='neutral'>        bytes32 m3;</span>
  4606 |     | <span class='neutral'>        bytes32 m4;</span>
  4607 |     | <span class='neutral'>        bytes32 m5;</span>
  4608 |     | <span class='neutral'>        bytes32 m6;</span>
  4609 |     | <span class='neutral'>        assembly {</span>
  4610 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4611 |     | <span class='neutral'>                let length := 0</span>
  4612 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4613 |     | <span class='neutral'>                mstore(pos, length)</span>
  4614 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4615 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4616 |     | <span class='neutral'>            }</span>
  4617 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4618 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4619 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4620 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4621 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4622 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4623 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4624 |     | <span class='neutral'>            // Selector of `log(address,string,address,uint256)`.</span>
  4625 |     | <span class='neutral'>            mstore(0x00, 0x457fe3cf)</span>
  4626 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4627 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4628 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4629 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4630 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4631 |     | <span class='neutral'>        }</span>
  4632 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4633 |     | <span class='neutral'>        assembly {</span>
  4634 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4635 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4636 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4637 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4638 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4639 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4640 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4641 |     | <span class='neutral'>        }</span>
  4642 |     | <span class='neutral'>    }</span>
  4643 |     | <span class='neutral'></span>
  4644 |     | <span class='neutral'>    function log(address p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  4645 |     | <span class='neutral'>        bytes32 m0;</span>
  4646 |     | <span class='neutral'>        bytes32 m1;</span>
  4647 |     | <span class='neutral'>        bytes32 m2;</span>
  4648 |     | <span class='neutral'>        bytes32 m3;</span>
  4649 |     | <span class='neutral'>        bytes32 m4;</span>
  4650 |     | <span class='neutral'>        bytes32 m5;</span>
  4651 |     | <span class='neutral'>        bytes32 m6;</span>
  4652 |     | <span class='neutral'>        bytes32 m7;</span>
  4653 |     | <span class='neutral'>        bytes32 m8;</span>
  4654 |     | <span class='neutral'>        assembly {</span>
  4655 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4656 |     | <span class='neutral'>                let length := 0</span>
  4657 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4658 |     | <span class='neutral'>                mstore(pos, length)</span>
  4659 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4660 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4661 |     | <span class='neutral'>            }</span>
  4662 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4663 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4664 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4665 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4666 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4667 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4668 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4669 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4670 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4671 |     | <span class='neutral'>            // Selector of `log(address,string,address,string)`.</span>
  4672 |     | <span class='neutral'>            mstore(0x00, 0xf7e36245)</span>
  4673 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4674 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4675 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4676 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4677 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4678 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4679 |     | <span class='neutral'>        }</span>
  4680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4681 |     | <span class='neutral'>        assembly {</span>
  4682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4689 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4690 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4691 |     | <span class='neutral'>        }</span>
  4692 |     | <span class='neutral'>    }</span>
  4693 |     | <span class='neutral'></span>
  4694 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  4695 |     | <span class='neutral'>        bytes32 m0;</span>
  4696 |     | <span class='neutral'>        bytes32 m1;</span>
  4697 |     | <span class='neutral'>        bytes32 m2;</span>
  4698 |     | <span class='neutral'>        bytes32 m3;</span>
  4699 |     | <span class='neutral'>        bytes32 m4;</span>
  4700 |     | <span class='neutral'>        bytes32 m5;</span>
  4701 |     | <span class='neutral'>        bytes32 m6;</span>
  4702 |     | <span class='neutral'>        assembly {</span>
  4703 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4704 |     | <span class='neutral'>                let length := 0</span>
  4705 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4706 |     | <span class='neutral'>                mstore(pos, length)</span>
  4707 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4708 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4709 |     | <span class='neutral'>            }</span>
  4710 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4711 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4712 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4713 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4714 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4715 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4716 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4717 |     | <span class='neutral'>            // Selector of `log(address,string,bool,address)`.</span>
  4718 |     | <span class='neutral'>            mstore(0x00, 0x205871c2)</span>
  4719 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4720 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4721 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4722 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4723 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4724 |     | <span class='neutral'>        }</span>
  4725 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4726 |     | <span class='neutral'>        assembly {</span>
  4727 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4728 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4729 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4730 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4731 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4732 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4733 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4734 |     | <span class='neutral'>        }</span>
  4735 |     | <span class='neutral'>    }</span>
  4736 |     | <span class='neutral'></span>
  4737 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  4738 |     | <span class='neutral'>        bytes32 m0;</span>
  4739 |     | <span class='neutral'>        bytes32 m1;</span>
  4740 |     | <span class='neutral'>        bytes32 m2;</span>
  4741 |     | <span class='neutral'>        bytes32 m3;</span>
  4742 |     | <span class='neutral'>        bytes32 m4;</span>
  4743 |     | <span class='neutral'>        bytes32 m5;</span>
  4744 |     | <span class='neutral'>        bytes32 m6;</span>
  4745 |     | <span class='neutral'>        assembly {</span>
  4746 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4747 |     | <span class='neutral'>                let length := 0</span>
  4748 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4749 |     | <span class='neutral'>                mstore(pos, length)</span>
  4750 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4751 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4752 |     | <span class='neutral'>            }</span>
  4753 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4754 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4755 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4756 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4757 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4758 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4759 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4760 |     | <span class='neutral'>            // Selector of `log(address,string,bool,bool)`.</span>
  4761 |     | <span class='neutral'>            mstore(0x00, 0x5f1d5c9f)</span>
  4762 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4763 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4764 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4765 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4766 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4767 |     | <span class='neutral'>        }</span>
  4768 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4769 |     | <span class='neutral'>        assembly {</span>
  4770 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4771 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4772 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4773 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4774 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4775 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4776 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4777 |     | <span class='neutral'>        }</span>
  4778 |     | <span class='neutral'>    }</span>
  4779 |     | <span class='neutral'></span>
  4780 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  4781 |     | <span class='neutral'>        bytes32 m0;</span>
  4782 |     | <span class='neutral'>        bytes32 m1;</span>
  4783 |     | <span class='neutral'>        bytes32 m2;</span>
  4784 |     | <span class='neutral'>        bytes32 m3;</span>
  4785 |     | <span class='neutral'>        bytes32 m4;</span>
  4786 |     | <span class='neutral'>        bytes32 m5;</span>
  4787 |     | <span class='neutral'>        bytes32 m6;</span>
  4788 |     | <span class='neutral'>        assembly {</span>
  4789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4790 |     | <span class='neutral'>                let length := 0</span>
  4791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4792 |     | <span class='neutral'>                mstore(pos, length)</span>
  4793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4795 |     | <span class='neutral'>            }</span>
  4796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4803 |     | <span class='neutral'>            // Selector of `log(address,string,bool,uint256)`.</span>
  4804 |     | <span class='neutral'>            mstore(0x00, 0x515e38b6)</span>
  4805 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4806 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4807 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4808 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4809 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4810 |     | <span class='neutral'>        }</span>
  4811 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4812 |     | <span class='neutral'>        assembly {</span>
  4813 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4814 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4815 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4816 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4817 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4818 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4819 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4820 |     | <span class='neutral'>        }</span>
  4821 |     | <span class='neutral'>    }</span>
  4822 |     | <span class='neutral'></span>
  4823 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  4824 |     | <span class='neutral'>        bytes32 m0;</span>
  4825 |     | <span class='neutral'>        bytes32 m1;</span>
  4826 |     | <span class='neutral'>        bytes32 m2;</span>
  4827 |     | <span class='neutral'>        bytes32 m3;</span>
  4828 |     | <span class='neutral'>        bytes32 m4;</span>
  4829 |     | <span class='neutral'>        bytes32 m5;</span>
  4830 |     | <span class='neutral'>        bytes32 m6;</span>
  4831 |     | <span class='neutral'>        bytes32 m7;</span>
  4832 |     | <span class='neutral'>        bytes32 m8;</span>
  4833 |     | <span class='neutral'>        assembly {</span>
  4834 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4835 |     | <span class='neutral'>                let length := 0</span>
  4836 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4837 |     | <span class='neutral'>                mstore(pos, length)</span>
  4838 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4839 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4840 |     | <span class='neutral'>            }</span>
  4841 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4842 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4843 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4844 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4845 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4846 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4847 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4848 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  4849 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  4850 |     | <span class='neutral'>            // Selector of `log(address,string,bool,string)`.</span>
  4851 |     | <span class='neutral'>            mstore(0x00, 0xbc0b61fe)</span>
  4852 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4853 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4854 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4855 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  4856 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4857 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  4858 |     | <span class='neutral'>        }</span>
  4859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  4860 |     | <span class='neutral'>        assembly {</span>
  4861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4866 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4867 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4868 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  4869 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  4870 |     | <span class='neutral'>        }</span>
  4871 |     | <span class='neutral'>    }</span>
  4872 |     | <span class='neutral'></span>
  4873 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  4874 |     | <span class='neutral'>        bytes32 m0;</span>
  4875 |     | <span class='neutral'>        bytes32 m1;</span>
  4876 |     | <span class='neutral'>        bytes32 m2;</span>
  4877 |     | <span class='neutral'>        bytes32 m3;</span>
  4878 |     | <span class='neutral'>        bytes32 m4;</span>
  4879 |     | <span class='neutral'>        bytes32 m5;</span>
  4880 |     | <span class='neutral'>        bytes32 m6;</span>
  4881 |     | <span class='neutral'>        assembly {</span>
  4882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4883 |     | <span class='neutral'>                let length := 0</span>
  4884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4885 |     | <span class='neutral'>                mstore(pos, length)</span>
  4886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4888 |     | <span class='neutral'>            }</span>
  4889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4896 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,address)`.</span>
  4897 |     | <span class='neutral'>            mstore(0x00, 0x63183678)</span>
  4898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4899 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4900 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4902 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4903 |     | <span class='neutral'>        }</span>
  4904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4905 |     | <span class='neutral'>        assembly {</span>
  4906 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4907 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4908 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4909 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4910 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4911 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4912 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4913 |     | <span class='neutral'>        }</span>
  4914 |     | <span class='neutral'>    }</span>
  4915 |     | <span class='neutral'></span>
  4916 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  4917 |     | <span class='neutral'>        bytes32 m0;</span>
  4918 |     | <span class='neutral'>        bytes32 m1;</span>
  4919 |     | <span class='neutral'>        bytes32 m2;</span>
  4920 |     | <span class='neutral'>        bytes32 m3;</span>
  4921 |     | <span class='neutral'>        bytes32 m4;</span>
  4922 |     | <span class='neutral'>        bytes32 m5;</span>
  4923 |     | <span class='neutral'>        bytes32 m6;</span>
  4924 |     | <span class='neutral'>        assembly {</span>
  4925 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4926 |     | <span class='neutral'>                let length := 0</span>
  4927 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4928 |     | <span class='neutral'>                mstore(pos, length)</span>
  4929 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4930 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4931 |     | <span class='neutral'>            }</span>
  4932 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4933 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4934 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4935 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4936 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4937 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4938 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4939 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,bool)`.</span>
  4940 |     | <span class='neutral'>            mstore(0x00, 0x0ef7e050)</span>
  4941 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4942 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4943 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4944 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4945 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4946 |     | <span class='neutral'>        }</span>
  4947 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4948 |     | <span class='neutral'>        assembly {</span>
  4949 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4950 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4951 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4952 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4953 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4954 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4955 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4956 |     | <span class='neutral'>        }</span>
  4957 |     | <span class='neutral'>    }</span>
  4958 |     | <span class='neutral'></span>
  4959 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  4960 |     | <span class='neutral'>        bytes32 m0;</span>
  4961 |     | <span class='neutral'>        bytes32 m1;</span>
  4962 |     | <span class='neutral'>        bytes32 m2;</span>
  4963 |     | <span class='neutral'>        bytes32 m3;</span>
  4964 |     | <span class='neutral'>        bytes32 m4;</span>
  4965 |     | <span class='neutral'>        bytes32 m5;</span>
  4966 |     | <span class='neutral'>        bytes32 m6;</span>
  4967 |     | <span class='neutral'>        assembly {</span>
  4968 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  4969 |     | <span class='neutral'>                let length := 0</span>
  4970 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  4971 |     | <span class='neutral'>                mstore(pos, length)</span>
  4972 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  4973 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  4974 |     | <span class='neutral'>            }</span>
  4975 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  4976 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  4977 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  4978 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  4979 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  4980 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  4981 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  4982 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,uint256)`.</span>
  4983 |     | <span class='neutral'>            mstore(0x00, 0x1dc8e1b8)</span>
  4984 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  4985 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  4986 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  4987 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  4988 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  4989 |     | <span class='neutral'>        }</span>
  4990 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  4991 |     | <span class='neutral'>        assembly {</span>
  4992 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  4993 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  4994 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  4995 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  4996 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  4997 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  4998 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  4999 |     | <span class='neutral'>        }</span>
  5000 |     | <span class='neutral'>    }</span>
  5001 |     | <span class='neutral'></span>
  5002 |     | <span class='neutral'>    function log(address p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  5003 |     | <span class='neutral'>        bytes32 m0;</span>
  5004 |     | <span class='neutral'>        bytes32 m1;</span>
  5005 |     | <span class='neutral'>        bytes32 m2;</span>
  5006 |     | <span class='neutral'>        bytes32 m3;</span>
  5007 |     | <span class='neutral'>        bytes32 m4;</span>
  5008 |     | <span class='neutral'>        bytes32 m5;</span>
  5009 |     | <span class='neutral'>        bytes32 m6;</span>
  5010 |     | <span class='neutral'>        bytes32 m7;</span>
  5011 |     | <span class='neutral'>        bytes32 m8;</span>
  5012 |     | <span class='neutral'>        assembly {</span>
  5013 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5014 |     | <span class='neutral'>                let length := 0</span>
  5015 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5016 |     | <span class='neutral'>                mstore(pos, length)</span>
  5017 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5018 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5019 |     | <span class='neutral'>            }</span>
  5020 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5021 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5022 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5023 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5024 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5025 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5026 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5027 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5028 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5029 |     | <span class='neutral'>            // Selector of `log(address,string,uint256,string)`.</span>
  5030 |     | <span class='neutral'>            mstore(0x00, 0x448830a8)</span>
  5031 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5032 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5033 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5034 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5035 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5036 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5037 |     | <span class='neutral'>        }</span>
  5038 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5039 |     | <span class='neutral'>        assembly {</span>
  5040 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5041 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5042 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5043 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5044 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5045 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5046 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5047 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5048 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5049 |     | <span class='neutral'>        }</span>
  5050 |     | <span class='neutral'>    }</span>
  5051 |     | <span class='neutral'></span>
  5052 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  5053 |     | <span class='neutral'>        bytes32 m0;</span>
  5054 |     | <span class='neutral'>        bytes32 m1;</span>
  5055 |     | <span class='neutral'>        bytes32 m2;</span>
  5056 |     | <span class='neutral'>        bytes32 m3;</span>
  5057 |     | <span class='neutral'>        bytes32 m4;</span>
  5058 |     | <span class='neutral'>        bytes32 m5;</span>
  5059 |     | <span class='neutral'>        bytes32 m6;</span>
  5060 |     | <span class='neutral'>        bytes32 m7;</span>
  5061 |     | <span class='neutral'>        bytes32 m8;</span>
  5062 |     | <span class='neutral'>        assembly {</span>
  5063 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5064 |     | <span class='neutral'>                let length := 0</span>
  5065 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5066 |     | <span class='neutral'>                mstore(pos, length)</span>
  5067 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5068 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5069 |     | <span class='neutral'>            }</span>
  5070 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5071 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5072 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5073 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5074 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5075 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5076 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5077 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5078 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5079 |     | <span class='neutral'>            // Selector of `log(address,string,string,address)`.</span>
  5080 |     | <span class='neutral'>            mstore(0x00, 0xa04e2f87)</span>
  5081 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5082 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5083 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5084 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5085 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5086 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5087 |     | <span class='neutral'>        }</span>
  5088 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5089 |     | <span class='neutral'>        assembly {</span>
  5090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5097 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5098 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5099 |     | <span class='neutral'>        }</span>
  5100 |     | <span class='neutral'>    }</span>
  5101 |     | <span class='neutral'></span>
  5102 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  5103 |     | <span class='neutral'>        bytes32 m0;</span>
  5104 |     | <span class='neutral'>        bytes32 m1;</span>
  5105 |     | <span class='neutral'>        bytes32 m2;</span>
  5106 |     | <span class='neutral'>        bytes32 m3;</span>
  5107 |     | <span class='neutral'>        bytes32 m4;</span>
  5108 |     | <span class='neutral'>        bytes32 m5;</span>
  5109 |     | <span class='neutral'>        bytes32 m6;</span>
  5110 |     | <span class='neutral'>        bytes32 m7;</span>
  5111 |     | <span class='neutral'>        bytes32 m8;</span>
  5112 |     | <span class='neutral'>        assembly {</span>
  5113 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5114 |     | <span class='neutral'>                let length := 0</span>
  5115 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5116 |     | <span class='neutral'>                mstore(pos, length)</span>
  5117 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5118 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5119 |     | <span class='neutral'>            }</span>
  5120 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5121 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5122 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5123 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5124 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5125 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5126 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5127 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5128 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5129 |     | <span class='neutral'>            // Selector of `log(address,string,string,bool)`.</span>
  5130 |     | <span class='neutral'>            mstore(0x00, 0x35a5071f)</span>
  5131 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5132 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5133 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5134 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5135 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5136 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5137 |     | <span class='neutral'>        }</span>
  5138 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5139 |     | <span class='neutral'>        assembly {</span>
  5140 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5141 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5142 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5143 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5144 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5145 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5146 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5147 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5148 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5149 |     | <span class='neutral'>        }</span>
  5150 |     | <span class='neutral'>    }</span>
  5151 |     | <span class='neutral'></span>
  5152 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  5153 |     | <span class='neutral'>        bytes32 m0;</span>
  5154 |     | <span class='neutral'>        bytes32 m1;</span>
  5155 |     | <span class='neutral'>        bytes32 m2;</span>
  5156 |     | <span class='neutral'>        bytes32 m3;</span>
  5157 |     | <span class='neutral'>        bytes32 m4;</span>
  5158 |     | <span class='neutral'>        bytes32 m5;</span>
  5159 |     | <span class='neutral'>        bytes32 m6;</span>
  5160 |     | <span class='neutral'>        bytes32 m7;</span>
  5161 |     | <span class='neutral'>        bytes32 m8;</span>
  5162 |     | <span class='neutral'>        assembly {</span>
  5163 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5164 |     | <span class='neutral'>                let length := 0</span>
  5165 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5166 |     | <span class='neutral'>                mstore(pos, length)</span>
  5167 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5168 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5169 |     | <span class='neutral'>            }</span>
  5170 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5171 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5172 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5173 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5174 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5175 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5176 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5177 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5178 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5179 |     | <span class='neutral'>            // Selector of `log(address,string,string,uint256)`.</span>
  5180 |     | <span class='neutral'>            mstore(0x00, 0x159f8927)</span>
  5181 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5182 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5183 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5184 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5185 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5186 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5187 |     | <span class='neutral'>        }</span>
  5188 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5189 |     | <span class='neutral'>        assembly {</span>
  5190 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5191 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5192 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5193 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5194 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5195 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5196 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5197 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5198 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5199 |     | <span class='neutral'>        }</span>
  5200 |     | <span class='neutral'>    }</span>
  5201 |     | <span class='neutral'></span>
  5202 |     | <span class='neutral'>    function log(address p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5203 |     | <span class='neutral'>        bytes32 m0;</span>
  5204 |     | <span class='neutral'>        bytes32 m1;</span>
  5205 |     | <span class='neutral'>        bytes32 m2;</span>
  5206 |     | <span class='neutral'>        bytes32 m3;</span>
  5207 |     | <span class='neutral'>        bytes32 m4;</span>
  5208 |     | <span class='neutral'>        bytes32 m5;</span>
  5209 |     | <span class='neutral'>        bytes32 m6;</span>
  5210 |     | <span class='neutral'>        bytes32 m7;</span>
  5211 |     | <span class='neutral'>        bytes32 m8;</span>
  5212 |     | <span class='neutral'>        bytes32 m9;</span>
  5213 |     | <span class='neutral'>        bytes32 m10;</span>
  5214 |     | <span class='neutral'>        assembly {</span>
  5215 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5216 |     | <span class='neutral'>                let length := 0</span>
  5217 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5218 |     | <span class='neutral'>                mstore(pos, length)</span>
  5219 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5220 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5221 |     | <span class='neutral'>            }</span>
  5222 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5223 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5224 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5225 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5226 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5227 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5228 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5229 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5230 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5231 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  5232 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  5233 |     | <span class='neutral'>            // Selector of `log(address,string,string,string)`.</span>
  5234 |     | <span class='neutral'>            mstore(0x00, 0x5d02c50b)</span>
  5235 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5236 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  5237 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  5238 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  5239 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  5240 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  5241 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  5242 |     | <span class='neutral'>        }</span>
  5243 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  5244 |     | <span class='neutral'>        assembly {</span>
  5245 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5246 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5247 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5248 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5249 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5250 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5251 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5252 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5253 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5254 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  5255 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  5256 |     | <span class='neutral'>        }</span>
  5257 |     | <span class='neutral'>    }</span>
  5258 |     | <span class='neutral'></span>
  5259 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, address p3) internal pure {</span>
  5260 |     | <span class='neutral'>        bytes32 m0;</span>
  5261 |     | <span class='neutral'>        bytes32 m1;</span>
  5262 |     | <span class='neutral'>        bytes32 m2;</span>
  5263 |     | <span class='neutral'>        bytes32 m3;</span>
  5264 |     | <span class='neutral'>        bytes32 m4;</span>
  5265 |     | <span class='neutral'>        assembly {</span>
  5266 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5267 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5268 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5269 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5270 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5271 |     | <span class='neutral'>            // Selector of `log(bool,address,address,address)`.</span>
  5272 |     | <span class='neutral'>            mstore(0x00, 0x1d14d001)</span>
  5273 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5274 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5275 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5276 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5277 |     | <span class='neutral'>        }</span>
  5278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5279 |     | <span class='neutral'>        assembly {</span>
  5280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5285 |     | <span class='neutral'>        }</span>
  5286 |     | <span class='neutral'>    }</span>
  5287 |     | <span class='neutral'></span>
  5288 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bool p3) internal pure {</span>
  5289 |     | <span class='neutral'>        bytes32 m0;</span>
  5290 |     | <span class='neutral'>        bytes32 m1;</span>
  5291 |     | <span class='neutral'>        bytes32 m2;</span>
  5292 |     | <span class='neutral'>        bytes32 m3;</span>
  5293 |     | <span class='neutral'>        bytes32 m4;</span>
  5294 |     | <span class='neutral'>        assembly {</span>
  5295 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5296 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5297 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5298 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5299 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5300 |     | <span class='neutral'>            // Selector of `log(bool,address,address,bool)`.</span>
  5301 |     | <span class='neutral'>            mstore(0x00, 0x46600be0)</span>
  5302 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5303 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5304 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5305 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5306 |     | <span class='neutral'>        }</span>
  5307 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5308 |     | <span class='neutral'>        assembly {</span>
  5309 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5310 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5311 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5312 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5313 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5314 |     | <span class='neutral'>        }</span>
  5315 |     | <span class='neutral'>    }</span>
  5316 |     | <span class='neutral'></span>
  5317 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, uint256 p3) internal pure {</span>
  5318 |     | <span class='neutral'>        bytes32 m0;</span>
  5319 |     | <span class='neutral'>        bytes32 m1;</span>
  5320 |     | <span class='neutral'>        bytes32 m2;</span>
  5321 |     | <span class='neutral'>        bytes32 m3;</span>
  5322 |     | <span class='neutral'>        bytes32 m4;</span>
  5323 |     | <span class='neutral'>        assembly {</span>
  5324 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5325 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5326 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5327 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5328 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5329 |     | <span class='neutral'>            // Selector of `log(bool,address,address,uint256)`.</span>
  5330 |     | <span class='neutral'>            mstore(0x00, 0x0c66d1be)</span>
  5331 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5332 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5333 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5334 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5335 |     | <span class='neutral'>        }</span>
  5336 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5337 |     | <span class='neutral'>        assembly {</span>
  5338 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5339 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5340 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5341 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5342 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5343 |     | <span class='neutral'>        }</span>
  5344 |     | <span class='neutral'>    }</span>
  5345 |     | <span class='neutral'></span>
  5346 |     | <span class='neutral'>    function log(bool p0, address p1, address p2, bytes32 p3) internal pure {</span>
  5347 |     | <span class='neutral'>        bytes32 m0;</span>
  5348 |     | <span class='neutral'>        bytes32 m1;</span>
  5349 |     | <span class='neutral'>        bytes32 m2;</span>
  5350 |     | <span class='neutral'>        bytes32 m3;</span>
  5351 |     | <span class='neutral'>        bytes32 m4;</span>
  5352 |     | <span class='neutral'>        bytes32 m5;</span>
  5353 |     | <span class='neutral'>        bytes32 m6;</span>
  5354 |     | <span class='neutral'>        assembly {</span>
  5355 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5356 |     | <span class='neutral'>                let length := 0</span>
  5357 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5358 |     | <span class='neutral'>                mstore(pos, length)</span>
  5359 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5360 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5361 |     | <span class='neutral'>            }</span>
  5362 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5363 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5364 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5365 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5366 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5367 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5368 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5369 |     | <span class='neutral'>            // Selector of `log(bool,address,address,string)`.</span>
  5370 |     | <span class='neutral'>            mstore(0x00, 0xd812a167)</span>
  5371 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5372 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5373 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5374 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5375 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5376 |     | <span class='neutral'>        }</span>
  5377 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5378 |     | <span class='neutral'>        assembly {</span>
  5379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5384 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5385 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5386 |     | <span class='neutral'>        }</span>
  5387 |     | <span class='neutral'>    }</span>
  5388 |     | <span class='neutral'></span>
  5389 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, address p3) internal pure {</span>
  5390 |     | <span class='neutral'>        bytes32 m0;</span>
  5391 |     | <span class='neutral'>        bytes32 m1;</span>
  5392 |     | <span class='neutral'>        bytes32 m2;</span>
  5393 |     | <span class='neutral'>        bytes32 m3;</span>
  5394 |     | <span class='neutral'>        bytes32 m4;</span>
  5395 |     | <span class='neutral'>        assembly {</span>
  5396 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5397 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5398 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5399 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5400 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5401 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,address)`.</span>
  5402 |     | <span class='neutral'>            mstore(0x00, 0x1c41a336)</span>
  5403 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5404 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5405 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5406 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5407 |     | <span class='neutral'>        }</span>
  5408 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5409 |     | <span class='neutral'>        assembly {</span>
  5410 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5411 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5412 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5413 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5414 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5415 |     | <span class='neutral'>        }</span>
  5416 |     | <span class='neutral'>    }</span>
  5417 |     | <span class='neutral'></span>
  5418 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bool p3) internal pure {</span>
  5419 |     | <span class='neutral'>        bytes32 m0;</span>
  5420 |     | <span class='neutral'>        bytes32 m1;</span>
  5421 |     | <span class='neutral'>        bytes32 m2;</span>
  5422 |     | <span class='neutral'>        bytes32 m3;</span>
  5423 |     | <span class='neutral'>        bytes32 m4;</span>
  5424 |     | <span class='neutral'>        assembly {</span>
  5425 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5426 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5427 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5428 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5429 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5430 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,bool)`.</span>
  5431 |     | <span class='neutral'>            mstore(0x00, 0x6a9c478b)</span>
  5432 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5433 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5434 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5435 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5436 |     | <span class='neutral'>        }</span>
  5437 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5438 |     | <span class='neutral'>        assembly {</span>
  5439 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5440 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5441 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5442 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5443 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5444 |     | <span class='neutral'>        }</span>
  5445 |     | <span class='neutral'>    }</span>
  5446 |     | <span class='neutral'></span>
  5447 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {</span>
  5448 |     | <span class='neutral'>        bytes32 m0;</span>
  5449 |     | <span class='neutral'>        bytes32 m1;</span>
  5450 |     | <span class='neutral'>        bytes32 m2;</span>
  5451 |     | <span class='neutral'>        bytes32 m3;</span>
  5452 |     | <span class='neutral'>        bytes32 m4;</span>
  5453 |     | <span class='neutral'>        assembly {</span>
  5454 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5455 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5456 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5457 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5458 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5459 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,uint256)`.</span>
  5460 |     | <span class='neutral'>            mstore(0x00, 0x07831502)</span>
  5461 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5462 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5463 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5464 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5465 |     | <span class='neutral'>        }</span>
  5466 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5467 |     | <span class='neutral'>        assembly {</span>
  5468 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5469 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5470 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5471 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5472 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5473 |     | <span class='neutral'>        }</span>
  5474 |     | <span class='neutral'>    }</span>
  5475 |     | <span class='neutral'></span>
  5476 |     | <span class='neutral'>    function log(bool p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  5477 |     | <span class='neutral'>        bytes32 m0;</span>
  5478 |     | <span class='neutral'>        bytes32 m1;</span>
  5479 |     | <span class='neutral'>        bytes32 m2;</span>
  5480 |     | <span class='neutral'>        bytes32 m3;</span>
  5481 |     | <span class='neutral'>        bytes32 m4;</span>
  5482 |     | <span class='neutral'>        bytes32 m5;</span>
  5483 |     | <span class='neutral'>        bytes32 m6;</span>
  5484 |     | <span class='neutral'>        assembly {</span>
  5485 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5486 |     | <span class='neutral'>                let length := 0</span>
  5487 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5488 |     | <span class='neutral'>                mstore(pos, length)</span>
  5489 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5490 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5491 |     | <span class='neutral'>            }</span>
  5492 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5493 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5494 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5495 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5496 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5497 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5498 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5499 |     | <span class='neutral'>            // Selector of `log(bool,address,bool,string)`.</span>
  5500 |     | <span class='neutral'>            mstore(0x00, 0x4a66cb34)</span>
  5501 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5502 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5503 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5504 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5505 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5506 |     | <span class='neutral'>        }</span>
  5507 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5508 |     | <span class='neutral'>        assembly {</span>
  5509 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5510 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5511 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5512 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5513 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5514 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5515 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5516 |     | <span class='neutral'>        }</span>
  5517 |     | <span class='neutral'>    }</span>
  5518 |     | <span class='neutral'></span>
  5519 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, address p3) internal pure {</span>
  5520 |     | <span class='neutral'>        bytes32 m0;</span>
  5521 |     | <span class='neutral'>        bytes32 m1;</span>
  5522 |     | <span class='neutral'>        bytes32 m2;</span>
  5523 |     | <span class='neutral'>        bytes32 m3;</span>
  5524 |     | <span class='neutral'>        bytes32 m4;</span>
  5525 |     | <span class='neutral'>        assembly {</span>
  5526 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5527 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5528 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5529 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5530 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5531 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,address)`.</span>
  5532 |     | <span class='neutral'>            mstore(0x00, 0x136b05dd)</span>
  5533 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5534 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5535 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5536 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5537 |     | <span class='neutral'>        }</span>
  5538 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5539 |     | <span class='neutral'>        assembly {</span>
  5540 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5541 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5542 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5543 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5544 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5545 |     | <span class='neutral'>        }</span>
  5546 |     | <span class='neutral'>    }</span>
  5547 |     | <span class='neutral'></span>
  5548 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {</span>
  5549 |     | <span class='neutral'>        bytes32 m0;</span>
  5550 |     | <span class='neutral'>        bytes32 m1;</span>
  5551 |     | <span class='neutral'>        bytes32 m2;</span>
  5552 |     | <span class='neutral'>        bytes32 m3;</span>
  5553 |     | <span class='neutral'>        bytes32 m4;</span>
  5554 |     | <span class='neutral'>        assembly {</span>
  5555 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5556 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5557 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5558 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5559 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5560 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,bool)`.</span>
  5561 |     | <span class='neutral'>            mstore(0x00, 0xd6019f1c)</span>
  5562 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5563 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5564 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5565 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5566 |     | <span class='neutral'>        }</span>
  5567 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5568 |     | <span class='neutral'>        assembly {</span>
  5569 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5570 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5571 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5572 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5573 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5574 |     | <span class='neutral'>        }</span>
  5575 |     | <span class='neutral'>    }</span>
  5576 |     | <span class='neutral'></span>
  5577 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  5578 |     | <span class='neutral'>        bytes32 m0;</span>
  5579 |     | <span class='neutral'>        bytes32 m1;</span>
  5580 |     | <span class='neutral'>        bytes32 m2;</span>
  5581 |     | <span class='neutral'>        bytes32 m3;</span>
  5582 |     | <span class='neutral'>        bytes32 m4;</span>
  5583 |     | <span class='neutral'>        assembly {</span>
  5584 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5585 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5586 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5587 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5588 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5589 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,uint256)`.</span>
  5590 |     | <span class='neutral'>            mstore(0x00, 0x7bf181a1)</span>
  5591 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5592 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5593 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5594 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5595 |     | <span class='neutral'>        }</span>
  5596 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5597 |     | <span class='neutral'>        assembly {</span>
  5598 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5599 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5600 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5601 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5602 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5603 |     | <span class='neutral'>        }</span>
  5604 |     | <span class='neutral'>    }</span>
  5605 |     | <span class='neutral'></span>
  5606 |     | <span class='neutral'>    function log(bool p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  5607 |     | <span class='neutral'>        bytes32 m0;</span>
  5608 |     | <span class='neutral'>        bytes32 m1;</span>
  5609 |     | <span class='neutral'>        bytes32 m2;</span>
  5610 |     | <span class='neutral'>        bytes32 m3;</span>
  5611 |     | <span class='neutral'>        bytes32 m4;</span>
  5612 |     | <span class='neutral'>        bytes32 m5;</span>
  5613 |     | <span class='neutral'>        bytes32 m6;</span>
  5614 |     | <span class='neutral'>        assembly {</span>
  5615 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5616 |     | <span class='neutral'>                let length := 0</span>
  5617 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5618 |     | <span class='neutral'>                mstore(pos, length)</span>
  5619 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5620 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5621 |     | <span class='neutral'>            }</span>
  5622 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5623 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5624 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5625 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5626 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5627 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5628 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5629 |     | <span class='neutral'>            // Selector of `log(bool,address,uint256,string)`.</span>
  5630 |     | <span class='neutral'>            mstore(0x00, 0x51f09ff8)</span>
  5631 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5632 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5633 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5634 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5635 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5636 |     | <span class='neutral'>        }</span>
  5637 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5638 |     | <span class='neutral'>        assembly {</span>
  5639 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5640 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5641 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5642 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5643 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5644 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5645 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5646 |     | <span class='neutral'>        }</span>
  5647 |     | <span class='neutral'>    }</span>
  5648 |     | <span class='neutral'></span>
  5649 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, address p3) internal pure {</span>
  5650 |     | <span class='neutral'>        bytes32 m0;</span>
  5651 |     | <span class='neutral'>        bytes32 m1;</span>
  5652 |     | <span class='neutral'>        bytes32 m2;</span>
  5653 |     | <span class='neutral'>        bytes32 m3;</span>
  5654 |     | <span class='neutral'>        bytes32 m4;</span>
  5655 |     | <span class='neutral'>        bytes32 m5;</span>
  5656 |     | <span class='neutral'>        bytes32 m6;</span>
  5657 |     | <span class='neutral'>        assembly {</span>
  5658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5659 |     | <span class='neutral'>                let length := 0</span>
  5660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5661 |     | <span class='neutral'>                mstore(pos, length)</span>
  5662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5664 |     | <span class='neutral'>            }</span>
  5665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5672 |     | <span class='neutral'>            // Selector of `log(bool,address,string,address)`.</span>
  5673 |     | <span class='neutral'>            mstore(0x00, 0x6f7c603e)</span>
  5674 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5676 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5678 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5679 |     | <span class='neutral'>        }</span>
  5680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5681 |     | <span class='neutral'>        assembly {</span>
  5682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5689 |     | <span class='neutral'>        }</span>
  5690 |     | <span class='neutral'>    }</span>
  5691 |     | <span class='neutral'></span>
  5692 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  5693 |     | <span class='neutral'>        bytes32 m0;</span>
  5694 |     | <span class='neutral'>        bytes32 m1;</span>
  5695 |     | <span class='neutral'>        bytes32 m2;</span>
  5696 |     | <span class='neutral'>        bytes32 m3;</span>
  5697 |     | <span class='neutral'>        bytes32 m4;</span>
  5698 |     | <span class='neutral'>        bytes32 m5;</span>
  5699 |     | <span class='neutral'>        bytes32 m6;</span>
  5700 |     | <span class='neutral'>        assembly {</span>
  5701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5702 |     | <span class='neutral'>                let length := 0</span>
  5703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5704 |     | <span class='neutral'>                mstore(pos, length)</span>
  5705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5707 |     | <span class='neutral'>            }</span>
  5708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5715 |     | <span class='neutral'>            // Selector of `log(bool,address,string,bool)`.</span>
  5716 |     | <span class='neutral'>            mstore(0x00, 0xe2bfd60b)</span>
  5717 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5719 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5721 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5722 |     | <span class='neutral'>        }</span>
  5723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5724 |     | <span class='neutral'>        assembly {</span>
  5725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5732 |     | <span class='neutral'>        }</span>
  5733 |     | <span class='neutral'>    }</span>
  5734 |     | <span class='neutral'></span>
  5735 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  5736 |     | <span class='neutral'>        bytes32 m0;</span>
  5737 |     | <span class='neutral'>        bytes32 m1;</span>
  5738 |     | <span class='neutral'>        bytes32 m2;</span>
  5739 |     | <span class='neutral'>        bytes32 m3;</span>
  5740 |     | <span class='neutral'>        bytes32 m4;</span>
  5741 |     | <span class='neutral'>        bytes32 m5;</span>
  5742 |     | <span class='neutral'>        bytes32 m6;</span>
  5743 |     | <span class='neutral'>        assembly {</span>
  5744 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5745 |     | <span class='neutral'>                let length := 0</span>
  5746 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5747 |     | <span class='neutral'>                mstore(pos, length)</span>
  5748 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5749 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5750 |     | <span class='neutral'>            }</span>
  5751 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5752 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5753 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5754 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5755 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5756 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5757 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5758 |     | <span class='neutral'>            // Selector of `log(bool,address,string,uint256)`.</span>
  5759 |     | <span class='neutral'>            mstore(0x00, 0xc21f64c7)</span>
  5760 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5761 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5762 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5763 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5764 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5765 |     | <span class='neutral'>        }</span>
  5766 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5767 |     | <span class='neutral'>        assembly {</span>
  5768 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5769 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5770 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5771 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5772 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5773 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5774 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5775 |     | <span class='neutral'>        }</span>
  5776 |     | <span class='neutral'>    }</span>
  5777 |     | <span class='neutral'></span>
  5778 |     | <span class='neutral'>    function log(bool p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  5779 |     | <span class='neutral'>        bytes32 m0;</span>
  5780 |     | <span class='neutral'>        bytes32 m1;</span>
  5781 |     | <span class='neutral'>        bytes32 m2;</span>
  5782 |     | <span class='neutral'>        bytes32 m3;</span>
  5783 |     | <span class='neutral'>        bytes32 m4;</span>
  5784 |     | <span class='neutral'>        bytes32 m5;</span>
  5785 |     | <span class='neutral'>        bytes32 m6;</span>
  5786 |     | <span class='neutral'>        bytes32 m7;</span>
  5787 |     | <span class='neutral'>        bytes32 m8;</span>
  5788 |     | <span class='neutral'>        assembly {</span>
  5789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5790 |     | <span class='neutral'>                let length := 0</span>
  5791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5792 |     | <span class='neutral'>                mstore(pos, length)</span>
  5793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5795 |     | <span class='neutral'>            }</span>
  5796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5803 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  5804 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  5805 |     | <span class='neutral'>            // Selector of `log(bool,address,string,string)`.</span>
  5806 |     | <span class='neutral'>            mstore(0x00, 0xa73c1db6)</span>
  5807 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5808 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5809 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  5810 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  5811 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  5812 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  5813 |     | <span class='neutral'>        }</span>
  5814 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  5815 |     | <span class='neutral'>        assembly {</span>
  5816 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5817 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5818 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5819 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5820 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5821 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5822 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5823 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  5824 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  5825 |     | <span class='neutral'>        }</span>
  5826 |     | <span class='neutral'>    }</span>
  5827 |     | <span class='neutral'></span>
  5828 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, address p3) internal pure {</span>
  5829 |     | <span class='neutral'>        bytes32 m0;</span>
  5830 |     | <span class='neutral'>        bytes32 m1;</span>
  5831 |     | <span class='neutral'>        bytes32 m2;</span>
  5832 |     | <span class='neutral'>        bytes32 m3;</span>
  5833 |     | <span class='neutral'>        bytes32 m4;</span>
  5834 |     | <span class='neutral'>        assembly {</span>
  5835 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5836 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5837 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5838 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5839 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5840 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,address)`.</span>
  5841 |     | <span class='neutral'>            mstore(0x00, 0xf4880ea4)</span>
  5842 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5843 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5844 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5845 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5846 |     | <span class='neutral'>        }</span>
  5847 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5848 |     | <span class='neutral'>        assembly {</span>
  5849 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5850 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5851 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5852 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5853 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5854 |     | <span class='neutral'>        }</span>
  5855 |     | <span class='neutral'>    }</span>
  5856 |     | <span class='neutral'></span>
  5857 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bool p3) internal pure {</span>
  5858 |     | <span class='neutral'>        bytes32 m0;</span>
  5859 |     | <span class='neutral'>        bytes32 m1;</span>
  5860 |     | <span class='neutral'>        bytes32 m2;</span>
  5861 |     | <span class='neutral'>        bytes32 m3;</span>
  5862 |     | <span class='neutral'>        bytes32 m4;</span>
  5863 |     | <span class='neutral'>        assembly {</span>
  5864 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5865 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5866 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5867 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5868 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5869 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,bool)`.</span>
  5870 |     | <span class='neutral'>            mstore(0x00, 0xc0a302d8)</span>
  5871 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5872 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5873 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5874 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5875 |     | <span class='neutral'>        }</span>
  5876 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5877 |     | <span class='neutral'>        assembly {</span>
  5878 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5879 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5880 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5881 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5882 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5883 |     | <span class='neutral'>        }</span>
  5884 |     | <span class='neutral'>    }</span>
  5885 |     | <span class='neutral'></span>
  5886 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {</span>
  5887 |     | <span class='neutral'>        bytes32 m0;</span>
  5888 |     | <span class='neutral'>        bytes32 m1;</span>
  5889 |     | <span class='neutral'>        bytes32 m2;</span>
  5890 |     | <span class='neutral'>        bytes32 m3;</span>
  5891 |     | <span class='neutral'>        bytes32 m4;</span>
  5892 |     | <span class='neutral'>        assembly {</span>
  5893 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5894 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5895 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5896 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5897 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5898 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,uint256)`.</span>
  5899 |     | <span class='neutral'>            mstore(0x00, 0x4c123d57)</span>
  5900 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5901 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5902 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5903 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5904 |     | <span class='neutral'>        }</span>
  5905 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5906 |     | <span class='neutral'>        assembly {</span>
  5907 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5908 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5909 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5910 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5911 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5912 |     | <span class='neutral'>        }</span>
  5913 |     | <span class='neutral'>    }</span>
  5914 |     | <span class='neutral'></span>
  5915 |     | <span class='neutral'>    function log(bool p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  5916 |     | <span class='neutral'>        bytes32 m0;</span>
  5917 |     | <span class='neutral'>        bytes32 m1;</span>
  5918 |     | <span class='neutral'>        bytes32 m2;</span>
  5919 |     | <span class='neutral'>        bytes32 m3;</span>
  5920 |     | <span class='neutral'>        bytes32 m4;</span>
  5921 |     | <span class='neutral'>        bytes32 m5;</span>
  5922 |     | <span class='neutral'>        bytes32 m6;</span>
  5923 |     | <span class='neutral'>        assembly {</span>
  5924 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  5925 |     | <span class='neutral'>                let length := 0</span>
  5926 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  5927 |     | <span class='neutral'>                mstore(pos, length)</span>
  5928 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  5929 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  5930 |     | <span class='neutral'>            }</span>
  5931 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5932 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5933 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5934 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5935 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5936 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  5937 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  5938 |     | <span class='neutral'>            // Selector of `log(bool,bool,address,string)`.</span>
  5939 |     | <span class='neutral'>            mstore(0x00, 0xa0a47963)</span>
  5940 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5941 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5942 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5943 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  5944 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  5945 |     | <span class='neutral'>        }</span>
  5946 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  5947 |     | <span class='neutral'>        assembly {</span>
  5948 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5949 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5950 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5951 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5952 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5953 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  5954 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  5955 |     | <span class='neutral'>        }</span>
  5956 |     | <span class='neutral'>    }</span>
  5957 |     | <span class='neutral'></span>
  5958 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, address p3) internal pure {</span>
  5959 |     | <span class='neutral'>        bytes32 m0;</span>
  5960 |     | <span class='neutral'>        bytes32 m1;</span>
  5961 |     | <span class='neutral'>        bytes32 m2;</span>
  5962 |     | <span class='neutral'>        bytes32 m3;</span>
  5963 |     | <span class='neutral'>        bytes32 m4;</span>
  5964 |     | <span class='neutral'>        assembly {</span>
  5965 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5966 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5967 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5968 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5969 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5970 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,address)`.</span>
  5971 |     | <span class='neutral'>            mstore(0x00, 0x8c329b1a)</span>
  5972 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  5973 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  5974 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  5975 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  5976 |     | <span class='neutral'>        }</span>
  5977 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  5978 |     | <span class='neutral'>        assembly {</span>
  5979 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  5980 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  5981 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  5982 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  5983 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  5984 |     | <span class='neutral'>        }</span>
  5985 |     | <span class='neutral'>    }</span>
  5986 |     | <span class='neutral'></span>
  5987 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bool p3) internal pure {</span>
  5988 |     | <span class='neutral'>        bytes32 m0;</span>
  5989 |     | <span class='neutral'>        bytes32 m1;</span>
  5990 |     | <span class='neutral'>        bytes32 m2;</span>
  5991 |     | <span class='neutral'>        bytes32 m3;</span>
  5992 |     | <span class='neutral'>        bytes32 m4;</span>
  5993 |     | <span class='neutral'>        assembly {</span>
  5994 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  5995 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  5996 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  5997 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  5998 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  5999 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,bool)`.</span>
  6000 |     | <span class='neutral'>            mstore(0x00, 0x3b2a5ce0)</span>
  6001 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6002 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6003 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6004 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6005 |     | <span class='neutral'>        }</span>
  6006 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6007 |     | <span class='neutral'>        assembly {</span>
  6008 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6009 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6010 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6011 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6012 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6013 |     | <span class='neutral'>        }</span>
  6014 |     | <span class='neutral'>    }</span>
  6015 |     | <span class='neutral'></span>
  6016 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  6017 |     | <span class='neutral'>        bytes32 m0;</span>
  6018 |     | <span class='neutral'>        bytes32 m1;</span>
  6019 |     | <span class='neutral'>        bytes32 m2;</span>
  6020 |     | <span class='neutral'>        bytes32 m3;</span>
  6021 |     | <span class='neutral'>        bytes32 m4;</span>
  6022 |     | <span class='neutral'>        assembly {</span>
  6023 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6024 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6025 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6026 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6027 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6028 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,uint256)`.</span>
  6029 |     | <span class='neutral'>            mstore(0x00, 0x6d7045c1)</span>
  6030 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6031 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6032 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6033 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6034 |     | <span class='neutral'>        }</span>
  6035 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6036 |     | <span class='neutral'>        assembly {</span>
  6037 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6038 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6039 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6040 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6041 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6042 |     | <span class='neutral'>        }</span>
  6043 |     | <span class='neutral'>    }</span>
  6044 |     | <span class='neutral'></span>
  6045 |     | <span class='neutral'>    function log(bool p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  6046 |     | <span class='neutral'>        bytes32 m0;</span>
  6047 |     | <span class='neutral'>        bytes32 m1;</span>
  6048 |     | <span class='neutral'>        bytes32 m2;</span>
  6049 |     | <span class='neutral'>        bytes32 m3;</span>
  6050 |     | <span class='neutral'>        bytes32 m4;</span>
  6051 |     | <span class='neutral'>        bytes32 m5;</span>
  6052 |     | <span class='neutral'>        bytes32 m6;</span>
  6053 |     | <span class='neutral'>        assembly {</span>
  6054 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6055 |     | <span class='neutral'>                let length := 0</span>
  6056 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6057 |     | <span class='neutral'>                mstore(pos, length)</span>
  6058 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6059 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6060 |     | <span class='neutral'>            }</span>
  6061 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6062 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6063 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6064 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6065 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6066 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6067 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6068 |     | <span class='neutral'>            // Selector of `log(bool,bool,bool,string)`.</span>
  6069 |     | <span class='neutral'>            mstore(0x00, 0x2ae408d4)</span>
  6070 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6071 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6072 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6073 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6074 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6075 |     | <span class='neutral'>        }</span>
  6076 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6077 |     | <span class='neutral'>        assembly {</span>
  6078 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6079 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6080 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6081 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6082 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6083 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6084 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6085 |     | <span class='neutral'>        }</span>
  6086 |     | <span class='neutral'>    }</span>
  6087 |     | <span class='neutral'></span>
  6088 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {</span>
  6089 |     | <span class='neutral'>        bytes32 m0;</span>
  6090 |     | <span class='neutral'>        bytes32 m1;</span>
  6091 |     | <span class='neutral'>        bytes32 m2;</span>
  6092 |     | <span class='neutral'>        bytes32 m3;</span>
  6093 |     | <span class='neutral'>        bytes32 m4;</span>
  6094 |     | <span class='neutral'>        assembly {</span>
  6095 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6096 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6097 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6098 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6099 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6100 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,address)`.</span>
  6101 |     | <span class='neutral'>            mstore(0x00, 0x54a7a9a0)</span>
  6102 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6103 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6104 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6105 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6106 |     | <span class='neutral'>        }</span>
  6107 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6108 |     | <span class='neutral'>        assembly {</span>
  6109 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6110 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6111 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6112 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6113 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6114 |     | <span class='neutral'>        }</span>
  6115 |     | <span class='neutral'>    }</span>
  6116 |     | <span class='neutral'></span>
  6117 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  6118 |     | <span class='neutral'>        bytes32 m0;</span>
  6119 |     | <span class='neutral'>        bytes32 m1;</span>
  6120 |     | <span class='neutral'>        bytes32 m2;</span>
  6121 |     | <span class='neutral'>        bytes32 m3;</span>
  6122 |     | <span class='neutral'>        bytes32 m4;</span>
  6123 |     | <span class='neutral'>        assembly {</span>
  6124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6128 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6129 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,bool)`.</span>
  6130 |     | <span class='neutral'>            mstore(0x00, 0x619e4d0e)</span>
  6131 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6132 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6133 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6134 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6135 |     | <span class='neutral'>        }</span>
  6136 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6137 |     | <span class='neutral'>        assembly {</span>
  6138 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6139 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6140 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6141 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6142 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6143 |     | <span class='neutral'>        }</span>
  6144 |     | <span class='neutral'>    }</span>
  6145 |     | <span class='neutral'></span>
  6146 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  6147 |     | <span class='neutral'>        bytes32 m0;</span>
  6148 |     | <span class='neutral'>        bytes32 m1;</span>
  6149 |     | <span class='neutral'>        bytes32 m2;</span>
  6150 |     | <span class='neutral'>        bytes32 m3;</span>
  6151 |     | <span class='neutral'>        bytes32 m4;</span>
  6152 |     | <span class='neutral'>        assembly {</span>
  6153 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6154 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6155 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6156 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6157 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6158 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,uint256)`.</span>
  6159 |     | <span class='neutral'>            mstore(0x00, 0x0bb00eab)</span>
  6160 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6161 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6162 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6163 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6164 |     | <span class='neutral'>        }</span>
  6165 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6166 |     | <span class='neutral'>        assembly {</span>
  6167 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6168 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6169 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6170 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6171 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6172 |     | <span class='neutral'>        }</span>
  6173 |     | <span class='neutral'>    }</span>
  6174 |     | <span class='neutral'></span>
  6175 |     | <span class='neutral'>    function log(bool p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  6176 |     | <span class='neutral'>        bytes32 m0;</span>
  6177 |     | <span class='neutral'>        bytes32 m1;</span>
  6178 |     | <span class='neutral'>        bytes32 m2;</span>
  6179 |     | <span class='neutral'>        bytes32 m3;</span>
  6180 |     | <span class='neutral'>        bytes32 m4;</span>
  6181 |     | <span class='neutral'>        bytes32 m5;</span>
  6182 |     | <span class='neutral'>        bytes32 m6;</span>
  6183 |     | <span class='neutral'>        assembly {</span>
  6184 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6185 |     | <span class='neutral'>                let length := 0</span>
  6186 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6187 |     | <span class='neutral'>                mstore(pos, length)</span>
  6188 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6189 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6190 |     | <span class='neutral'>            }</span>
  6191 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6192 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6193 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6194 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6195 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6196 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6197 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6198 |     | <span class='neutral'>            // Selector of `log(bool,bool,uint256,string)`.</span>
  6199 |     | <span class='neutral'>            mstore(0x00, 0x7dd4d0e0)</span>
  6200 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6201 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6202 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6203 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6204 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6205 |     | <span class='neutral'>        }</span>
  6206 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6207 |     | <span class='neutral'>        assembly {</span>
  6208 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6209 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6210 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6211 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6212 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6213 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6214 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6215 |     | <span class='neutral'>        }</span>
  6216 |     | <span class='neutral'>    }</span>
  6217 |     | <span class='neutral'></span>
  6218 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  6219 |     | <span class='neutral'>        bytes32 m0;</span>
  6220 |     | <span class='neutral'>        bytes32 m1;</span>
  6221 |     | <span class='neutral'>        bytes32 m2;</span>
  6222 |     | <span class='neutral'>        bytes32 m3;</span>
  6223 |     | <span class='neutral'>        bytes32 m4;</span>
  6224 |     | <span class='neutral'>        bytes32 m5;</span>
  6225 |     | <span class='neutral'>        bytes32 m6;</span>
  6226 |     | <span class='neutral'>        assembly {</span>
  6227 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6228 |     | <span class='neutral'>                let length := 0</span>
  6229 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6230 |     | <span class='neutral'>                mstore(pos, length)</span>
  6231 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6232 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6233 |     | <span class='neutral'>            }</span>
  6234 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6235 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6236 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6237 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6238 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6239 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6240 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6241 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,address)`.</span>
  6242 |     | <span class='neutral'>            mstore(0x00, 0xf9ad2b89)</span>
  6243 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6244 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6245 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6246 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6247 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6248 |     | <span class='neutral'>        }</span>
  6249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6250 |     | <span class='neutral'>        assembly {</span>
  6251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6258 |     | <span class='neutral'>        }</span>
  6259 |     | <span class='neutral'>    }</span>
  6260 |     | <span class='neutral'></span>
  6261 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  6262 |     | <span class='neutral'>        bytes32 m0;</span>
  6263 |     | <span class='neutral'>        bytes32 m1;</span>
  6264 |     | <span class='neutral'>        bytes32 m2;</span>
  6265 |     | <span class='neutral'>        bytes32 m3;</span>
  6266 |     | <span class='neutral'>        bytes32 m4;</span>
  6267 |     | <span class='neutral'>        bytes32 m5;</span>
  6268 |     | <span class='neutral'>        bytes32 m6;</span>
  6269 |     | <span class='neutral'>        assembly {</span>
  6270 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6271 |     | <span class='neutral'>                let length := 0</span>
  6272 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6273 |     | <span class='neutral'>                mstore(pos, length)</span>
  6274 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6275 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6276 |     | <span class='neutral'>            }</span>
  6277 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6278 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6279 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6280 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6281 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6282 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6283 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6284 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,bool)`.</span>
  6285 |     | <span class='neutral'>            mstore(0x00, 0xb857163a)</span>
  6286 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6287 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6288 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6289 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6290 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6291 |     | <span class='neutral'>        }</span>
  6292 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6293 |     | <span class='neutral'>        assembly {</span>
  6294 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6295 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6296 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6297 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6298 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6299 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6300 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6301 |     | <span class='neutral'>        }</span>
  6302 |     | <span class='neutral'>    }</span>
  6303 |     | <span class='neutral'></span>
  6304 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  6305 |     | <span class='neutral'>        bytes32 m0;</span>
  6306 |     | <span class='neutral'>        bytes32 m1;</span>
  6307 |     | <span class='neutral'>        bytes32 m2;</span>
  6308 |     | <span class='neutral'>        bytes32 m3;</span>
  6309 |     | <span class='neutral'>        bytes32 m4;</span>
  6310 |     | <span class='neutral'>        bytes32 m5;</span>
  6311 |     | <span class='neutral'>        bytes32 m6;</span>
  6312 |     | <span class='neutral'>        assembly {</span>
  6313 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6314 |     | <span class='neutral'>                let length := 0</span>
  6315 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6316 |     | <span class='neutral'>                mstore(pos, length)</span>
  6317 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6318 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6319 |     | <span class='neutral'>            }</span>
  6320 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6321 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6322 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6323 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6324 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6325 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6326 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6327 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,uint256)`.</span>
  6328 |     | <span class='neutral'>            mstore(0x00, 0xe3a9ca2f)</span>
  6329 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6330 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6331 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6332 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6333 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6334 |     | <span class='neutral'>        }</span>
  6335 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6336 |     | <span class='neutral'>        assembly {</span>
  6337 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6338 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6339 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6340 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6341 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6342 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6343 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6344 |     | <span class='neutral'>        }</span>
  6345 |     | <span class='neutral'>    }</span>
  6346 |     | <span class='neutral'></span>
  6347 |     | <span class='neutral'>    function log(bool p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6348 |     | <span class='neutral'>        bytes32 m0;</span>
  6349 |     | <span class='neutral'>        bytes32 m1;</span>
  6350 |     | <span class='neutral'>        bytes32 m2;</span>
  6351 |     | <span class='neutral'>        bytes32 m3;</span>
  6352 |     | <span class='neutral'>        bytes32 m4;</span>
  6353 |     | <span class='neutral'>        bytes32 m5;</span>
  6354 |     | <span class='neutral'>        bytes32 m6;</span>
  6355 |     | <span class='neutral'>        bytes32 m7;</span>
  6356 |     | <span class='neutral'>        bytes32 m8;</span>
  6357 |     | <span class='neutral'>        assembly {</span>
  6358 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6359 |     | <span class='neutral'>                let length := 0</span>
  6360 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6361 |     | <span class='neutral'>                mstore(pos, length)</span>
  6362 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6363 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6364 |     | <span class='neutral'>            }</span>
  6365 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6366 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6367 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6368 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6369 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6370 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6371 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6372 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6373 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6374 |     | <span class='neutral'>            // Selector of `log(bool,bool,string,string)`.</span>
  6375 |     | <span class='neutral'>            mstore(0x00, 0x6d1e8751)</span>
  6376 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6377 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6378 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6379 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6380 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6381 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6382 |     | <span class='neutral'>        }</span>
  6383 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6384 |     | <span class='neutral'>        assembly {</span>
  6385 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6386 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6387 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6388 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6389 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6390 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6391 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6392 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6393 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6394 |     | <span class='neutral'>        }</span>
  6395 |     | <span class='neutral'>    }</span>
  6396 |     | <span class='neutral'></span>
  6397 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, address p3) internal pure {</span>
  6398 |     | <span class='neutral'>        bytes32 m0;</span>
  6399 |     | <span class='neutral'>        bytes32 m1;</span>
  6400 |     | <span class='neutral'>        bytes32 m2;</span>
  6401 |     | <span class='neutral'>        bytes32 m3;</span>
  6402 |     | <span class='neutral'>        bytes32 m4;</span>
  6403 |     | <span class='neutral'>        assembly {</span>
  6404 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6405 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6406 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6407 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6408 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6409 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,address)`.</span>
  6410 |     | <span class='neutral'>            mstore(0x00, 0x26f560a8)</span>
  6411 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6412 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6413 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6414 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6415 |     | <span class='neutral'>        }</span>
  6416 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6417 |     | <span class='neutral'>        assembly {</span>
  6418 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6419 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6420 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6421 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6422 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6423 |     | <span class='neutral'>        }</span>
  6424 |     | <span class='neutral'>    }</span>
  6425 |     | <span class='neutral'></span>
  6426 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {</span>
  6427 |     | <span class='neutral'>        bytes32 m0;</span>
  6428 |     | <span class='neutral'>        bytes32 m1;</span>
  6429 |     | <span class='neutral'>        bytes32 m2;</span>
  6430 |     | <span class='neutral'>        bytes32 m3;</span>
  6431 |     | <span class='neutral'>        bytes32 m4;</span>
  6432 |     | <span class='neutral'>        assembly {</span>
  6433 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6434 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6435 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6436 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6437 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6438 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,bool)`.</span>
  6439 |     | <span class='neutral'>            mstore(0x00, 0xb4c314ff)</span>
  6440 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6441 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6442 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6443 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6444 |     | <span class='neutral'>        }</span>
  6445 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6446 |     | <span class='neutral'>        assembly {</span>
  6447 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6448 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6449 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6450 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6451 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6452 |     | <span class='neutral'>        }</span>
  6453 |     | <span class='neutral'>    }</span>
  6454 |     | <span class='neutral'></span>
  6455 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  6456 |     | <span class='neutral'>        bytes32 m0;</span>
  6457 |     | <span class='neutral'>        bytes32 m1;</span>
  6458 |     | <span class='neutral'>        bytes32 m2;</span>
  6459 |     | <span class='neutral'>        bytes32 m3;</span>
  6460 |     | <span class='neutral'>        bytes32 m4;</span>
  6461 |     | <span class='neutral'>        assembly {</span>
  6462 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6463 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6464 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6465 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6466 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6467 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,uint256)`.</span>
  6468 |     | <span class='neutral'>            mstore(0x00, 0x1537dc87)</span>
  6469 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6470 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6471 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6472 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6473 |     | <span class='neutral'>        }</span>
  6474 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6475 |     | <span class='neutral'>        assembly {</span>
  6476 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6477 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6478 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6479 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6480 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6481 |     | <span class='neutral'>        }</span>
  6482 |     | <span class='neutral'>    }</span>
  6483 |     | <span class='neutral'></span>
  6484 |     | <span class='neutral'>    function log(bool p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  6485 |     | <span class='neutral'>        bytes32 m0;</span>
  6486 |     | <span class='neutral'>        bytes32 m1;</span>
  6487 |     | <span class='neutral'>        bytes32 m2;</span>
  6488 |     | <span class='neutral'>        bytes32 m3;</span>
  6489 |     | <span class='neutral'>        bytes32 m4;</span>
  6490 |     | <span class='neutral'>        bytes32 m5;</span>
  6491 |     | <span class='neutral'>        bytes32 m6;</span>
  6492 |     | <span class='neutral'>        assembly {</span>
  6493 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6494 |     | <span class='neutral'>                let length := 0</span>
  6495 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6496 |     | <span class='neutral'>                mstore(pos, length)</span>
  6497 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6498 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6499 |     | <span class='neutral'>            }</span>
  6500 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6501 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6502 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6503 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6504 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6505 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6506 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6507 |     | <span class='neutral'>            // Selector of `log(bool,uint256,address,string)`.</span>
  6508 |     | <span class='neutral'>            mstore(0x00, 0x1bb3b09a)</span>
  6509 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6510 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6511 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6512 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6513 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6514 |     | <span class='neutral'>        }</span>
  6515 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6516 |     | <span class='neutral'>        assembly {</span>
  6517 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6518 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6519 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6520 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6521 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6522 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6523 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6524 |     | <span class='neutral'>        }</span>
  6525 |     | <span class='neutral'>    }</span>
  6526 |     | <span class='neutral'></span>
  6527 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {</span>
  6528 |     | <span class='neutral'>        bytes32 m0;</span>
  6529 |     | <span class='neutral'>        bytes32 m1;</span>
  6530 |     | <span class='neutral'>        bytes32 m2;</span>
  6531 |     | <span class='neutral'>        bytes32 m3;</span>
  6532 |     | <span class='neutral'>        bytes32 m4;</span>
  6533 |     | <span class='neutral'>        assembly {</span>
  6534 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6535 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6536 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6537 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6538 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6539 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,address)`.</span>
  6540 |     | <span class='neutral'>            mstore(0x00, 0x9acd3616)</span>
  6541 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6542 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6543 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6544 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6545 |     | <span class='neutral'>        }</span>
  6546 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6547 |     | <span class='neutral'>        assembly {</span>
  6548 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6549 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6550 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6551 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6552 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6553 |     | <span class='neutral'>        }</span>
  6554 |     | <span class='neutral'>    }</span>
  6555 |     | <span class='neutral'></span>
  6556 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  6557 |     | <span class='neutral'>        bytes32 m0;</span>
  6558 |     | <span class='neutral'>        bytes32 m1;</span>
  6559 |     | <span class='neutral'>        bytes32 m2;</span>
  6560 |     | <span class='neutral'>        bytes32 m3;</span>
  6561 |     | <span class='neutral'>        bytes32 m4;</span>
  6562 |     | <span class='neutral'>        assembly {</span>
  6563 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6564 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6565 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6566 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6567 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6568 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,bool)`.</span>
  6569 |     | <span class='neutral'>            mstore(0x00, 0xceb5f4d7)</span>
  6570 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6571 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6572 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6573 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6574 |     | <span class='neutral'>        }</span>
  6575 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6576 |     | <span class='neutral'>        assembly {</span>
  6577 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6578 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6579 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6580 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6581 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6582 |     | <span class='neutral'>        }</span>
  6583 |     | <span class='neutral'>    }</span>
  6584 |     | <span class='neutral'></span>
  6585 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  6586 |     | <span class='neutral'>        bytes32 m0;</span>
  6587 |     | <span class='neutral'>        bytes32 m1;</span>
  6588 |     | <span class='neutral'>        bytes32 m2;</span>
  6589 |     | <span class='neutral'>        bytes32 m3;</span>
  6590 |     | <span class='neutral'>        bytes32 m4;</span>
  6591 |     | <span class='neutral'>        assembly {</span>
  6592 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6593 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6594 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6595 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6596 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6597 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,uint256)`.</span>
  6598 |     | <span class='neutral'>            mstore(0x00, 0x7f9bbca2)</span>
  6599 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6600 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6601 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6602 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6603 |     | <span class='neutral'>        }</span>
  6604 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6605 |     | <span class='neutral'>        assembly {</span>
  6606 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6607 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6608 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6609 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6610 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6611 |     | <span class='neutral'>        }</span>
  6612 |     | <span class='neutral'>    }</span>
  6613 |     | <span class='neutral'></span>
  6614 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  6615 |     | <span class='neutral'>        bytes32 m0;</span>
  6616 |     | <span class='neutral'>        bytes32 m1;</span>
  6617 |     | <span class='neutral'>        bytes32 m2;</span>
  6618 |     | <span class='neutral'>        bytes32 m3;</span>
  6619 |     | <span class='neutral'>        bytes32 m4;</span>
  6620 |     | <span class='neutral'>        bytes32 m5;</span>
  6621 |     | <span class='neutral'>        bytes32 m6;</span>
  6622 |     | <span class='neutral'>        assembly {</span>
  6623 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6624 |     | <span class='neutral'>                let length := 0</span>
  6625 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6626 |     | <span class='neutral'>                mstore(pos, length)</span>
  6627 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6628 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6629 |     | <span class='neutral'>            }</span>
  6630 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6631 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6632 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6633 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6634 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6635 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6636 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6637 |     | <span class='neutral'>            // Selector of `log(bool,uint256,bool,string)`.</span>
  6638 |     | <span class='neutral'>            mstore(0x00, 0x9143dbb1)</span>
  6639 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6640 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6641 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6642 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6643 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6644 |     | <span class='neutral'>        }</span>
  6645 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6646 |     | <span class='neutral'>        assembly {</span>
  6647 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6648 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6649 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6650 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6651 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6652 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6653 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6654 |     | <span class='neutral'>        }</span>
  6655 |     | <span class='neutral'>    }</span>
  6656 |     | <span class='neutral'></span>
  6657 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  6658 |     | <span class='neutral'>        bytes32 m0;</span>
  6659 |     | <span class='neutral'>        bytes32 m1;</span>
  6660 |     | <span class='neutral'>        bytes32 m2;</span>
  6661 |     | <span class='neutral'>        bytes32 m3;</span>
  6662 |     | <span class='neutral'>        bytes32 m4;</span>
  6663 |     | <span class='neutral'>        assembly {</span>
  6664 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6665 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6666 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6667 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6668 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6669 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,address)`.</span>
  6670 |     | <span class='neutral'>            mstore(0x00, 0x00dd87b9)</span>
  6671 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6672 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6673 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6674 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6675 |     | <span class='neutral'>        }</span>
  6676 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6677 |     | <span class='neutral'>        assembly {</span>
  6678 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6679 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6680 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6681 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6682 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6683 |     | <span class='neutral'>        }</span>
  6684 |     | <span class='neutral'>    }</span>
  6685 |     | <span class='neutral'></span>
  6686 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  6687 |     | <span class='neutral'>        bytes32 m0;</span>
  6688 |     | <span class='neutral'>        bytes32 m1;</span>
  6689 |     | <span class='neutral'>        bytes32 m2;</span>
  6690 |     | <span class='neutral'>        bytes32 m3;</span>
  6691 |     | <span class='neutral'>        bytes32 m4;</span>
  6692 |     | <span class='neutral'>        assembly {</span>
  6693 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6694 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6695 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6696 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6697 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6698 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,bool)`.</span>
  6699 |     | <span class='neutral'>            mstore(0x00, 0xbe984353)</span>
  6700 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6701 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6702 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6703 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6704 |     | <span class='neutral'>        }</span>
  6705 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6706 |     | <span class='neutral'>        assembly {</span>
  6707 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6708 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6709 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6710 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6711 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6712 |     | <span class='neutral'>        }</span>
  6713 |     | <span class='neutral'>    }</span>
  6714 |     | <span class='neutral'></span>
  6715 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  6716 |     | <span class='neutral'>        bytes32 m0;</span>
  6717 |     | <span class='neutral'>        bytes32 m1;</span>
  6718 |     | <span class='neutral'>        bytes32 m2;</span>
  6719 |     | <span class='neutral'>        bytes32 m3;</span>
  6720 |     | <span class='neutral'>        bytes32 m4;</span>
  6721 |     | <span class='neutral'>        assembly {</span>
  6722 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6723 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6724 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6725 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6726 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6727 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,uint256)`.</span>
  6728 |     | <span class='neutral'>            mstore(0x00, 0x374bb4b2)</span>
  6729 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6730 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6733 |     | <span class='neutral'>        }</span>
  6734 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  6735 |     | <span class='neutral'>        assembly {</span>
  6736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6740 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6741 |     | <span class='neutral'>        }</span>
  6742 |     | <span class='neutral'>    }</span>
  6743 |     | <span class='neutral'></span>
  6744 |     | <span class='neutral'>    function log(bool p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  6745 |     | <span class='neutral'>        bytes32 m0;</span>
  6746 |     | <span class='neutral'>        bytes32 m1;</span>
  6747 |     | <span class='neutral'>        bytes32 m2;</span>
  6748 |     | <span class='neutral'>        bytes32 m3;</span>
  6749 |     | <span class='neutral'>        bytes32 m4;</span>
  6750 |     | <span class='neutral'>        bytes32 m5;</span>
  6751 |     | <span class='neutral'>        bytes32 m6;</span>
  6752 |     | <span class='neutral'>        assembly {</span>
  6753 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6754 |     | <span class='neutral'>                let length := 0</span>
  6755 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6756 |     | <span class='neutral'>                mstore(pos, length)</span>
  6757 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6758 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6759 |     | <span class='neutral'>            }</span>
  6760 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6761 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6762 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6763 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6764 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6765 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6766 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6767 |     | <span class='neutral'>            // Selector of `log(bool,uint256,uint256,string)`.</span>
  6768 |     | <span class='neutral'>            mstore(0x00, 0x8e69fb5d)</span>
  6769 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6770 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6771 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6772 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  6773 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  6774 |     | <span class='neutral'>        }</span>
  6775 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6776 |     | <span class='neutral'>        assembly {</span>
  6777 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6778 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6779 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6780 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6781 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6782 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6783 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6784 |     | <span class='neutral'>        }</span>
  6785 |     | <span class='neutral'>    }</span>
  6786 |     | <span class='neutral'></span>
  6787 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  6788 |     | <span class='neutral'>        bytes32 m0;</span>
  6789 |     | <span class='neutral'>        bytes32 m1;</span>
  6790 |     | <span class='neutral'>        bytes32 m2;</span>
  6791 |     | <span class='neutral'>        bytes32 m3;</span>
  6792 |     | <span class='neutral'>        bytes32 m4;</span>
  6793 |     | <span class='neutral'>        bytes32 m5;</span>
  6794 |     | <span class='neutral'>        bytes32 m6;</span>
  6795 |     | <span class='neutral'>        assembly {</span>
  6796 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6797 |     | <span class='neutral'>                let length := 0</span>
  6798 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6799 |     | <span class='neutral'>                mstore(pos, length)</span>
  6800 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6801 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6802 |     | <span class='neutral'>            }</span>
  6803 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6804 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6805 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6806 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6807 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6808 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6809 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6810 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,address)`.</span>
  6811 |     | <span class='neutral'>            mstore(0x00, 0xfedd1fff)</span>
  6812 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6813 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6814 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6815 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6816 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6817 |     | <span class='neutral'>        }</span>
  6818 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6819 |     | <span class='neutral'>        assembly {</span>
  6820 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6821 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6822 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6823 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6824 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6825 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6826 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6827 |     | <span class='neutral'>        }</span>
  6828 |     | <span class='neutral'>    }</span>
  6829 |     | <span class='neutral'></span>
  6830 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  6831 |     | <span class='neutral'>        bytes32 m0;</span>
  6832 |     | <span class='neutral'>        bytes32 m1;</span>
  6833 |     | <span class='neutral'>        bytes32 m2;</span>
  6834 |     | <span class='neutral'>        bytes32 m3;</span>
  6835 |     | <span class='neutral'>        bytes32 m4;</span>
  6836 |     | <span class='neutral'>        bytes32 m5;</span>
  6837 |     | <span class='neutral'>        bytes32 m6;</span>
  6838 |     | <span class='neutral'>        assembly {</span>
  6839 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6840 |     | <span class='neutral'>                let length := 0</span>
  6841 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6842 |     | <span class='neutral'>                mstore(pos, length)</span>
  6843 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6844 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6845 |     | <span class='neutral'>            }</span>
  6846 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6847 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6848 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6849 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6850 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6851 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6852 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6853 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,bool)`.</span>
  6854 |     | <span class='neutral'>            mstore(0x00, 0xe5e70b2b)</span>
  6855 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6856 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6857 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6858 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6859 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6860 |     | <span class='neutral'>        }</span>
  6861 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6862 |     | <span class='neutral'>        assembly {</span>
  6863 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6864 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6865 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6866 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6867 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6868 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6869 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6870 |     | <span class='neutral'>        }</span>
  6871 |     | <span class='neutral'>    }</span>
  6872 |     | <span class='neutral'></span>
  6873 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  6874 |     | <span class='neutral'>        bytes32 m0;</span>
  6875 |     | <span class='neutral'>        bytes32 m1;</span>
  6876 |     | <span class='neutral'>        bytes32 m2;</span>
  6877 |     | <span class='neutral'>        bytes32 m3;</span>
  6878 |     | <span class='neutral'>        bytes32 m4;</span>
  6879 |     | <span class='neutral'>        bytes32 m5;</span>
  6880 |     | <span class='neutral'>        bytes32 m6;</span>
  6881 |     | <span class='neutral'>        assembly {</span>
  6882 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6883 |     | <span class='neutral'>                let length := 0</span>
  6884 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6885 |     | <span class='neutral'>                mstore(pos, length)</span>
  6886 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6887 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6888 |     | <span class='neutral'>            }</span>
  6889 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6890 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6891 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6892 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6893 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6894 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6895 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6896 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,uint256)`.</span>
  6897 |     | <span class='neutral'>            mstore(0x00, 0x6a1199e2)</span>
  6898 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6899 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6900 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6901 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6902 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6903 |     | <span class='neutral'>        }</span>
  6904 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6905 |     | <span class='neutral'>        assembly {</span>
  6906 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6907 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6908 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6909 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6910 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6911 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6912 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6913 |     | <span class='neutral'>        }</span>
  6914 |     | <span class='neutral'>    }</span>
  6915 |     | <span class='neutral'></span>
  6916 |     | <span class='neutral'>    function log(bool p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  6917 |     | <span class='neutral'>        bytes32 m0;</span>
  6918 |     | <span class='neutral'>        bytes32 m1;</span>
  6919 |     | <span class='neutral'>        bytes32 m2;</span>
  6920 |     | <span class='neutral'>        bytes32 m3;</span>
  6921 |     | <span class='neutral'>        bytes32 m4;</span>
  6922 |     | <span class='neutral'>        bytes32 m5;</span>
  6923 |     | <span class='neutral'>        bytes32 m6;</span>
  6924 |     | <span class='neutral'>        bytes32 m7;</span>
  6925 |     | <span class='neutral'>        bytes32 m8;</span>
  6926 |     | <span class='neutral'>        assembly {</span>
  6927 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6928 |     | <span class='neutral'>                let length := 0</span>
  6929 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6930 |     | <span class='neutral'>                mstore(pos, length)</span>
  6931 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6932 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6933 |     | <span class='neutral'>            }</span>
  6934 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6935 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6936 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6937 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6938 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6939 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6940 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6941 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  6942 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  6943 |     | <span class='neutral'>            // Selector of `log(bool,uint256,string,string)`.</span>
  6944 |     | <span class='neutral'>            mstore(0x00, 0xf5bc2249)</span>
  6945 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6946 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  6947 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  6948 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  6949 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  6950 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  6951 |     | <span class='neutral'>        }</span>
  6952 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  6953 |     | <span class='neutral'>        assembly {</span>
  6954 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  6955 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  6956 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  6957 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  6958 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  6959 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  6960 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  6961 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  6962 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  6963 |     | <span class='neutral'>        }</span>
  6964 |     | <span class='neutral'>    }</span>
  6965 |     | <span class='neutral'></span>
  6966 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, address p3) internal pure {</span>
  6967 |     | <span class='neutral'>        bytes32 m0;</span>
  6968 |     | <span class='neutral'>        bytes32 m1;</span>
  6969 |     | <span class='neutral'>        bytes32 m2;</span>
  6970 |     | <span class='neutral'>        bytes32 m3;</span>
  6971 |     | <span class='neutral'>        bytes32 m4;</span>
  6972 |     | <span class='neutral'>        bytes32 m5;</span>
  6973 |     | <span class='neutral'>        bytes32 m6;</span>
  6974 |     | <span class='neutral'>        assembly {</span>
  6975 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  6976 |     | <span class='neutral'>                let length := 0</span>
  6977 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  6978 |     | <span class='neutral'>                mstore(pos, length)</span>
  6979 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  6980 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  6981 |     | <span class='neutral'>            }</span>
  6982 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  6983 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  6984 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  6985 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  6986 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  6987 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  6988 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  6989 |     | <span class='neutral'>            // Selector of `log(bool,string,address,address)`.</span>
  6990 |     | <span class='neutral'>            mstore(0x00, 0x2b2b18dc)</span>
  6991 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  6992 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  6993 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  6994 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  6995 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  6996 |     | <span class='neutral'>        }</span>
  6997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  6998 |     | <span class='neutral'>        assembly {</span>
  6999 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7000 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7001 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7002 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7003 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7004 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7005 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7006 |     | <span class='neutral'>        }</span>
  7007 |     | <span class='neutral'>    }</span>
  7008 |     | <span class='neutral'></span>
  7009 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  7010 |     | <span class='neutral'>        bytes32 m0;</span>
  7011 |     | <span class='neutral'>        bytes32 m1;</span>
  7012 |     | <span class='neutral'>        bytes32 m2;</span>
  7013 |     | <span class='neutral'>        bytes32 m3;</span>
  7014 |     | <span class='neutral'>        bytes32 m4;</span>
  7015 |     | <span class='neutral'>        bytes32 m5;</span>
  7016 |     | <span class='neutral'>        bytes32 m6;</span>
  7017 |     | <span class='neutral'>        assembly {</span>
  7018 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7019 |     | <span class='neutral'>                let length := 0</span>
  7020 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7021 |     | <span class='neutral'>                mstore(pos, length)</span>
  7022 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7023 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7024 |     | <span class='neutral'>            }</span>
  7025 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7026 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7027 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7028 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7029 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7030 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7031 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7032 |     | <span class='neutral'>            // Selector of `log(bool,string,address,bool)`.</span>
  7033 |     | <span class='neutral'>            mstore(0x00, 0x6dd434ca)</span>
  7034 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7035 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7036 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7037 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7038 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7039 |     | <span class='neutral'>        }</span>
  7040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7041 |     | <span class='neutral'>        assembly {</span>
  7042 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7043 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7044 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7045 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7046 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7047 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7048 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7049 |     | <span class='neutral'>        }</span>
  7050 |     | <span class='neutral'>    }</span>
  7051 |     | <span class='neutral'></span>
  7052 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  7053 |     | <span class='neutral'>        bytes32 m0;</span>
  7054 |     | <span class='neutral'>        bytes32 m1;</span>
  7055 |     | <span class='neutral'>        bytes32 m2;</span>
  7056 |     | <span class='neutral'>        bytes32 m3;</span>
  7057 |     | <span class='neutral'>        bytes32 m4;</span>
  7058 |     | <span class='neutral'>        bytes32 m5;</span>
  7059 |     | <span class='neutral'>        bytes32 m6;</span>
  7060 |     | <span class='neutral'>        assembly {</span>
  7061 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7062 |     | <span class='neutral'>                let length := 0</span>
  7063 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7064 |     | <span class='neutral'>                mstore(pos, length)</span>
  7065 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7066 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7067 |     | <span class='neutral'>            }</span>
  7068 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7069 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7070 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7071 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7072 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7073 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7074 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7075 |     | <span class='neutral'>            // Selector of `log(bool,string,address,uint256)`.</span>
  7076 |     | <span class='neutral'>            mstore(0x00, 0xa5cada94)</span>
  7077 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7078 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7079 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7080 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7081 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7082 |     | <span class='neutral'>        }</span>
  7083 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7084 |     | <span class='neutral'>        assembly {</span>
  7085 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7086 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7087 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7088 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7089 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7090 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7091 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7092 |     | <span class='neutral'>        }</span>
  7093 |     | <span class='neutral'>    }</span>
  7094 |     | <span class='neutral'></span>
  7095 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  7096 |     | <span class='neutral'>        bytes32 m0;</span>
  7097 |     | <span class='neutral'>        bytes32 m1;</span>
  7098 |     | <span class='neutral'>        bytes32 m2;</span>
  7099 |     | <span class='neutral'>        bytes32 m3;</span>
  7100 |     | <span class='neutral'>        bytes32 m4;</span>
  7101 |     | <span class='neutral'>        bytes32 m5;</span>
  7102 |     | <span class='neutral'>        bytes32 m6;</span>
  7103 |     | <span class='neutral'>        bytes32 m7;</span>
  7104 |     | <span class='neutral'>        bytes32 m8;</span>
  7105 |     | <span class='neutral'>        assembly {</span>
  7106 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7107 |     | <span class='neutral'>                let length := 0</span>
  7108 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7109 |     | <span class='neutral'>                mstore(pos, length)</span>
  7110 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7111 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7112 |     | <span class='neutral'>            }</span>
  7113 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7114 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7115 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7116 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7117 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7118 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7119 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7120 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7121 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7122 |     | <span class='neutral'>            // Selector of `log(bool,string,address,string)`.</span>
  7123 |     | <span class='neutral'>            mstore(0x00, 0x12d6c788)</span>
  7124 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7125 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7126 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7127 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7128 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7129 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7130 |     | <span class='neutral'>        }</span>
  7131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7132 |     | <span class='neutral'>        assembly {</span>
  7133 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7134 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7135 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7136 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7137 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7138 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7139 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7140 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7141 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7142 |     | <span class='neutral'>        }</span>
  7143 |     | <span class='neutral'>    }</span>
  7144 |     | <span class='neutral'></span>
  7145 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  7146 |     | <span class='neutral'>        bytes32 m0;</span>
  7147 |     | <span class='neutral'>        bytes32 m1;</span>
  7148 |     | <span class='neutral'>        bytes32 m2;</span>
  7149 |     | <span class='neutral'>        bytes32 m3;</span>
  7150 |     | <span class='neutral'>        bytes32 m4;</span>
  7151 |     | <span class='neutral'>        bytes32 m5;</span>
  7152 |     | <span class='neutral'>        bytes32 m6;</span>
  7153 |     | <span class='neutral'>        assembly {</span>
  7154 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7155 |     | <span class='neutral'>                let length := 0</span>
  7156 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7157 |     | <span class='neutral'>                mstore(pos, length)</span>
  7158 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7159 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7160 |     | <span class='neutral'>            }</span>
  7161 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7162 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7163 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7164 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7165 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7166 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7167 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7168 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,address)`.</span>
  7169 |     | <span class='neutral'>            mstore(0x00, 0x538e06ab)</span>
  7170 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7171 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7172 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7173 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7174 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7175 |     | <span class='neutral'>        }</span>
  7176 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7177 |     | <span class='neutral'>        assembly {</span>
  7178 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7179 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7180 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7181 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7182 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7183 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7184 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7185 |     | <span class='neutral'>        }</span>
  7186 |     | <span class='neutral'>    }</span>
  7187 |     | <span class='neutral'></span>
  7188 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  7189 |     | <span class='neutral'>        bytes32 m0;</span>
  7190 |     | <span class='neutral'>        bytes32 m1;</span>
  7191 |     | <span class='neutral'>        bytes32 m2;</span>
  7192 |     | <span class='neutral'>        bytes32 m3;</span>
  7193 |     | <span class='neutral'>        bytes32 m4;</span>
  7194 |     | <span class='neutral'>        bytes32 m5;</span>
  7195 |     | <span class='neutral'>        bytes32 m6;</span>
  7196 |     | <span class='neutral'>        assembly {</span>
  7197 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7198 |     | <span class='neutral'>                let length := 0</span>
  7199 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7200 |     | <span class='neutral'>                mstore(pos, length)</span>
  7201 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7202 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7203 |     | <span class='neutral'>            }</span>
  7204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7209 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7210 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7211 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,bool)`.</span>
  7212 |     | <span class='neutral'>            mstore(0x00, 0xdc5e935b)</span>
  7213 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7214 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7215 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7216 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7217 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7218 |     | <span class='neutral'>        }</span>
  7219 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7220 |     | <span class='neutral'>        assembly {</span>
  7221 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7222 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7223 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7224 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7225 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7226 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7227 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7228 |     | <span class='neutral'>        }</span>
  7229 |     | <span class='neutral'>    }</span>
  7230 |     | <span class='neutral'></span>
  7231 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  7232 |     | <span class='neutral'>        bytes32 m0;</span>
  7233 |     | <span class='neutral'>        bytes32 m1;</span>
  7234 |     | <span class='neutral'>        bytes32 m2;</span>
  7235 |     | <span class='neutral'>        bytes32 m3;</span>
  7236 |     | <span class='neutral'>        bytes32 m4;</span>
  7237 |     | <span class='neutral'>        bytes32 m5;</span>
  7238 |     | <span class='neutral'>        bytes32 m6;</span>
  7239 |     | <span class='neutral'>        assembly {</span>
  7240 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7241 |     | <span class='neutral'>                let length := 0</span>
  7242 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7243 |     | <span class='neutral'>                mstore(pos, length)</span>
  7244 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7245 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7246 |     | <span class='neutral'>            }</span>
  7247 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7248 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7249 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7250 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7251 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7252 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7253 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7254 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,uint256)`.</span>
  7255 |     | <span class='neutral'>            mstore(0x00, 0x1606a393)</span>
  7256 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7257 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7258 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7259 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7260 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7261 |     | <span class='neutral'>        }</span>
  7262 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7263 |     | <span class='neutral'>        assembly {</span>
  7264 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7265 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7266 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7267 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7268 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7269 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7270 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7271 |     | <span class='neutral'>        }</span>
  7272 |     | <span class='neutral'>    }</span>
  7273 |     | <span class='neutral'></span>
  7274 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  7275 |     | <span class='neutral'>        bytes32 m0;</span>
  7276 |     | <span class='neutral'>        bytes32 m1;</span>
  7277 |     | <span class='neutral'>        bytes32 m2;</span>
  7278 |     | <span class='neutral'>        bytes32 m3;</span>
  7279 |     | <span class='neutral'>        bytes32 m4;</span>
  7280 |     | <span class='neutral'>        bytes32 m5;</span>
  7281 |     | <span class='neutral'>        bytes32 m6;</span>
  7282 |     | <span class='neutral'>        bytes32 m7;</span>
  7283 |     | <span class='neutral'>        bytes32 m8;</span>
  7284 |     | <span class='neutral'>        assembly {</span>
  7285 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7286 |     | <span class='neutral'>                let length := 0</span>
  7287 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7288 |     | <span class='neutral'>                mstore(pos, length)</span>
  7289 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7290 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7291 |     | <span class='neutral'>            }</span>
  7292 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7293 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7294 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7295 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7296 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7297 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7298 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7299 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7300 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7301 |     | <span class='neutral'>            // Selector of `log(bool,string,bool,string)`.</span>
  7302 |     | <span class='neutral'>            mstore(0x00, 0x483d0416)</span>
  7303 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7304 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7305 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7306 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7307 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7308 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7309 |     | <span class='neutral'>        }</span>
  7310 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7311 |     | <span class='neutral'>        assembly {</span>
  7312 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7313 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7314 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7315 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7316 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7317 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7318 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7319 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7320 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7321 |     | <span class='neutral'>        }</span>
  7322 |     | <span class='neutral'>    }</span>
  7323 |     | <span class='neutral'></span>
  7324 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  7325 |     | <span class='neutral'>        bytes32 m0;</span>
  7326 |     | <span class='neutral'>        bytes32 m1;</span>
  7327 |     | <span class='neutral'>        bytes32 m2;</span>
  7328 |     | <span class='neutral'>        bytes32 m3;</span>
  7329 |     | <span class='neutral'>        bytes32 m4;</span>
  7330 |     | <span class='neutral'>        bytes32 m5;</span>
  7331 |     | <span class='neutral'>        bytes32 m6;</span>
  7332 |     | <span class='neutral'>        assembly {</span>
  7333 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7334 |     | <span class='neutral'>                let length := 0</span>
  7335 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7336 |     | <span class='neutral'>                mstore(pos, length)</span>
  7337 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7338 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7339 |     | <span class='neutral'>            }</span>
  7340 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7341 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7342 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7343 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7344 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7345 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7346 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7347 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,address)`.</span>
  7348 |     | <span class='neutral'>            mstore(0x00, 0x1596a1ce)</span>
  7349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7350 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7351 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7353 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7354 |     | <span class='neutral'>        }</span>
  7355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7356 |     | <span class='neutral'>        assembly {</span>
  7357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7364 |     | <span class='neutral'>        }</span>
  7365 |     | <span class='neutral'>    }</span>
  7366 |     | <span class='neutral'></span>
  7367 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  7368 |     | <span class='neutral'>        bytes32 m0;</span>
  7369 |     | <span class='neutral'>        bytes32 m1;</span>
  7370 |     | <span class='neutral'>        bytes32 m2;</span>
  7371 |     | <span class='neutral'>        bytes32 m3;</span>
  7372 |     | <span class='neutral'>        bytes32 m4;</span>
  7373 |     | <span class='neutral'>        bytes32 m5;</span>
  7374 |     | <span class='neutral'>        bytes32 m6;</span>
  7375 |     | <span class='neutral'>        assembly {</span>
  7376 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7377 |     | <span class='neutral'>                let length := 0</span>
  7378 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7379 |     | <span class='neutral'>                mstore(pos, length)</span>
  7380 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7381 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7382 |     | <span class='neutral'>            }</span>
  7383 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7384 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7385 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7386 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7387 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7388 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7389 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7390 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,bool)`.</span>
  7391 |     | <span class='neutral'>            mstore(0x00, 0x6b0e5d53)</span>
  7392 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7393 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7394 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7395 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7396 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7397 |     | <span class='neutral'>        }</span>
  7398 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7399 |     | <span class='neutral'>        assembly {</span>
  7400 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7401 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7402 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7403 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7404 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7405 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7406 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7407 |     | <span class='neutral'>        }</span>
  7408 |     | <span class='neutral'>    }</span>
  7409 |     | <span class='neutral'></span>
  7410 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  7411 |     | <span class='neutral'>        bytes32 m0;</span>
  7412 |     | <span class='neutral'>        bytes32 m1;</span>
  7413 |     | <span class='neutral'>        bytes32 m2;</span>
  7414 |     | <span class='neutral'>        bytes32 m3;</span>
  7415 |     | <span class='neutral'>        bytes32 m4;</span>
  7416 |     | <span class='neutral'>        bytes32 m5;</span>
  7417 |     | <span class='neutral'>        bytes32 m6;</span>
  7418 |     | <span class='neutral'>        assembly {</span>
  7419 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7420 |     | <span class='neutral'>                let length := 0</span>
  7421 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7422 |     | <span class='neutral'>                mstore(pos, length)</span>
  7423 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7424 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7425 |     | <span class='neutral'>            }</span>
  7426 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7427 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7428 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7429 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7430 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7431 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7432 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7433 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,uint256)`.</span>
  7434 |     | <span class='neutral'>            mstore(0x00, 0x28863fcb)</span>
  7435 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7436 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7437 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7438 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7439 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7440 |     | <span class='neutral'>        }</span>
  7441 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7442 |     | <span class='neutral'>        assembly {</span>
  7443 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7444 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7445 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7446 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7447 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7448 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7449 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7450 |     | <span class='neutral'>        }</span>
  7451 |     | <span class='neutral'>    }</span>
  7452 |     | <span class='neutral'></span>
  7453 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  7454 |     | <span class='neutral'>        bytes32 m0;</span>
  7455 |     | <span class='neutral'>        bytes32 m1;</span>
  7456 |     | <span class='neutral'>        bytes32 m2;</span>
  7457 |     | <span class='neutral'>        bytes32 m3;</span>
  7458 |     | <span class='neutral'>        bytes32 m4;</span>
  7459 |     | <span class='neutral'>        bytes32 m5;</span>
  7460 |     | <span class='neutral'>        bytes32 m6;</span>
  7461 |     | <span class='neutral'>        bytes32 m7;</span>
  7462 |     | <span class='neutral'>        bytes32 m8;</span>
  7463 |     | <span class='neutral'>        assembly {</span>
  7464 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7465 |     | <span class='neutral'>                let length := 0</span>
  7466 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7467 |     | <span class='neutral'>                mstore(pos, length)</span>
  7468 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7469 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7470 |     | <span class='neutral'>            }</span>
  7471 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7472 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7473 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7474 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7475 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7476 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7477 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7478 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7479 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7480 |     | <span class='neutral'>            // Selector of `log(bool,string,uint256,string)`.</span>
  7481 |     | <span class='neutral'>            mstore(0x00, 0x1ad96de6)</span>
  7482 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7483 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7484 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7485 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  7486 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7487 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  7488 |     | <span class='neutral'>        }</span>
  7489 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7490 |     | <span class='neutral'>        assembly {</span>
  7491 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7492 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7493 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7494 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7495 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7496 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7497 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7498 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7499 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7500 |     | <span class='neutral'>        }</span>
  7501 |     | <span class='neutral'>    }</span>
  7502 |     | <span class='neutral'></span>
  7503 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  7504 |     | <span class='neutral'>        bytes32 m0;</span>
  7505 |     | <span class='neutral'>        bytes32 m1;</span>
  7506 |     | <span class='neutral'>        bytes32 m2;</span>
  7507 |     | <span class='neutral'>        bytes32 m3;</span>
  7508 |     | <span class='neutral'>        bytes32 m4;</span>
  7509 |     | <span class='neutral'>        bytes32 m5;</span>
  7510 |     | <span class='neutral'>        bytes32 m6;</span>
  7511 |     | <span class='neutral'>        bytes32 m7;</span>
  7512 |     | <span class='neutral'>        bytes32 m8;</span>
  7513 |     | <span class='neutral'>        assembly {</span>
  7514 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7515 |     | <span class='neutral'>                let length := 0</span>
  7516 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7517 |     | <span class='neutral'>                mstore(pos, length)</span>
  7518 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7519 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7520 |     | <span class='neutral'>            }</span>
  7521 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7522 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7523 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7524 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7525 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7526 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7527 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7528 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7529 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7530 |     | <span class='neutral'>            // Selector of `log(bool,string,string,address)`.</span>
  7531 |     | <span class='neutral'>            mstore(0x00, 0x97d394d8)</span>
  7532 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7533 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7534 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7535 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7536 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7537 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7538 |     | <span class='neutral'>        }</span>
  7539 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7540 |     | <span class='neutral'>        assembly {</span>
  7541 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7542 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7543 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7544 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7545 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7546 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7547 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7548 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7549 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7550 |     | <span class='neutral'>        }</span>
  7551 |     | <span class='neutral'>    }</span>
  7552 |     | <span class='neutral'></span>
  7553 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
  7554 |     | <span class='neutral'>        bytes32 m0;</span>
  7555 |     | <span class='neutral'>        bytes32 m1;</span>
  7556 |     | <span class='neutral'>        bytes32 m2;</span>
  7557 |     | <span class='neutral'>        bytes32 m3;</span>
  7558 |     | <span class='neutral'>        bytes32 m4;</span>
  7559 |     | <span class='neutral'>        bytes32 m5;</span>
  7560 |     | <span class='neutral'>        bytes32 m6;</span>
  7561 |     | <span class='neutral'>        bytes32 m7;</span>
  7562 |     | <span class='neutral'>        bytes32 m8;</span>
  7563 |     | <span class='neutral'>        assembly {</span>
  7564 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7565 |     | <span class='neutral'>                let length := 0</span>
  7566 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7567 |     | <span class='neutral'>                mstore(pos, length)</span>
  7568 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7569 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7570 |     | <span class='neutral'>            }</span>
  7571 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7572 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7573 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7574 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7575 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7576 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7577 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7578 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7579 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7580 |     | <span class='neutral'>            // Selector of `log(bool,string,string,bool)`.</span>
  7581 |     | <span class='neutral'>            mstore(0x00, 0x1e4b87e5)</span>
  7582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7583 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7584 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7585 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7586 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7587 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7588 |     | <span class='neutral'>        }</span>
  7589 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7590 |     | <span class='neutral'>        assembly {</span>
  7591 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7592 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7593 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7594 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7595 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7596 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7597 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7598 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7599 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7600 |     | <span class='neutral'>        }</span>
  7601 |     | <span class='neutral'>    }</span>
  7602 |     | <span class='neutral'></span>
  7603 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
  7604 |     | <span class='neutral'>        bytes32 m0;</span>
  7605 |     | <span class='neutral'>        bytes32 m1;</span>
  7606 |     | <span class='neutral'>        bytes32 m2;</span>
  7607 |     | <span class='neutral'>        bytes32 m3;</span>
  7608 |     | <span class='neutral'>        bytes32 m4;</span>
  7609 |     | <span class='neutral'>        bytes32 m5;</span>
  7610 |     | <span class='neutral'>        bytes32 m6;</span>
  7611 |     | <span class='neutral'>        bytes32 m7;</span>
  7612 |     | <span class='neutral'>        bytes32 m8;</span>
  7613 |     | <span class='neutral'>        assembly {</span>
  7614 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7615 |     | <span class='neutral'>                let length := 0</span>
  7616 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7617 |     | <span class='neutral'>                mstore(pos, length)</span>
  7618 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7619 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7620 |     | <span class='neutral'>            }</span>
  7621 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7622 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7623 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7624 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7625 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7626 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7627 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7628 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7629 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7630 |     | <span class='neutral'>            // Selector of `log(bool,string,string,uint256)`.</span>
  7631 |     | <span class='neutral'>            mstore(0x00, 0x7be0c3eb)</span>
  7632 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7633 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7634 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7635 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7636 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7637 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7638 |     | <span class='neutral'>        }</span>
  7639 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  7640 |     | <span class='neutral'>        assembly {</span>
  7641 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7642 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7643 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7644 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7645 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7646 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7647 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7648 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7649 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7650 |     | <span class='neutral'>        }</span>
  7651 |     | <span class='neutral'>    }</span>
  7652 |     | <span class='neutral'></span>
  7653 |     | <span class='neutral'>    function log(bool p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  7654 |     | <span class='neutral'>        bytes32 m0;</span>
  7655 |     | <span class='neutral'>        bytes32 m1;</span>
  7656 |     | <span class='neutral'>        bytes32 m2;</span>
  7657 |     | <span class='neutral'>        bytes32 m3;</span>
  7658 |     | <span class='neutral'>        bytes32 m4;</span>
  7659 |     | <span class='neutral'>        bytes32 m5;</span>
  7660 |     | <span class='neutral'>        bytes32 m6;</span>
  7661 |     | <span class='neutral'>        bytes32 m7;</span>
  7662 |     | <span class='neutral'>        bytes32 m8;</span>
  7663 |     | <span class='neutral'>        bytes32 m9;</span>
  7664 |     | <span class='neutral'>        bytes32 m10;</span>
  7665 |     | <span class='neutral'>        assembly {</span>
  7666 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7667 |     | <span class='neutral'>                let length := 0</span>
  7668 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7669 |     | <span class='neutral'>                mstore(pos, length)</span>
  7670 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7671 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7672 |     | <span class='neutral'>            }</span>
  7673 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7674 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7675 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7676 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7677 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7678 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7679 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7680 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  7681 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  7682 |     | <span class='neutral'>            m9 := mload(0x120)</span>
  7683 |     | <span class='neutral'>            m10 := mload(0x140)</span>
  7684 |     | <span class='neutral'>            // Selector of `log(bool,string,string,string)`.</span>
  7685 |     | <span class='neutral'>            mstore(0x00, 0x1762e32a)</span>
  7686 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7687 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  7688 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  7689 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
  7690 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  7691 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  7692 |     | <span class='neutral'>            writeString(0x120, p3)</span>
  7693 |     | <span class='neutral'>        }</span>
  7694 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
  7695 |     | <span class='neutral'>        assembly {</span>
  7696 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7697 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7698 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7699 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7700 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7701 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7702 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7703 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  7704 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  7705 |     | <span class='neutral'>            mstore(0x120, m9)</span>
  7706 |     | <span class='neutral'>            mstore(0x140, m10)</span>
  7707 |     | <span class='neutral'>        }</span>
  7708 |     | <span class='neutral'>    }</span>
  7709 |     | <span class='neutral'></span>
  7710 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, address p3) internal pure {</span>
  7711 |     | <span class='neutral'>        bytes32 m0;</span>
  7712 |     | <span class='neutral'>        bytes32 m1;</span>
  7713 |     | <span class='neutral'>        bytes32 m2;</span>
  7714 |     | <span class='neutral'>        bytes32 m3;</span>
  7715 |     | <span class='neutral'>        bytes32 m4;</span>
  7716 |     | <span class='neutral'>        assembly {</span>
  7717 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7718 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7719 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7720 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7721 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7722 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,address)`.</span>
  7723 |     | <span class='neutral'>            mstore(0x00, 0x2488b414)</span>
  7724 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7725 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7726 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7727 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7728 |     | <span class='neutral'>        }</span>
  7729 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7730 |     | <span class='neutral'>        assembly {</span>
  7731 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7732 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7733 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7734 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7735 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7736 |     | <span class='neutral'>        }</span>
  7737 |     | <span class='neutral'>    }</span>
  7738 |     | <span class='neutral'></span>
  7739 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bool p3) internal pure {</span>
  7740 |     | <span class='neutral'>        bytes32 m0;</span>
  7741 |     | <span class='neutral'>        bytes32 m1;</span>
  7742 |     | <span class='neutral'>        bytes32 m2;</span>
  7743 |     | <span class='neutral'>        bytes32 m3;</span>
  7744 |     | <span class='neutral'>        bytes32 m4;</span>
  7745 |     | <span class='neutral'>        assembly {</span>
  7746 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7747 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7748 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7749 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7750 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7751 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,bool)`.</span>
  7752 |     | <span class='neutral'>            mstore(0x00, 0x091ffaf5)</span>
  7753 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7754 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7755 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7756 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7757 |     | <span class='neutral'>        }</span>
  7758 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7759 |     | <span class='neutral'>        assembly {</span>
  7760 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7761 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7762 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7763 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7764 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7765 |     | <span class='neutral'>        }</span>
  7766 |     | <span class='neutral'>    }</span>
  7767 |     | <span class='neutral'></span>
  7768 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {</span>
  7769 |     | <span class='neutral'>        bytes32 m0;</span>
  7770 |     | <span class='neutral'>        bytes32 m1;</span>
  7771 |     | <span class='neutral'>        bytes32 m2;</span>
  7772 |     | <span class='neutral'>        bytes32 m3;</span>
  7773 |     | <span class='neutral'>        bytes32 m4;</span>
  7774 |     | <span class='neutral'>        assembly {</span>
  7775 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7776 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7777 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7778 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7779 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7780 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,uint256)`.</span>
  7781 |     | <span class='neutral'>            mstore(0x00, 0x736efbb6)</span>
  7782 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7783 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7784 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7785 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7786 |     | <span class='neutral'>        }</span>
  7787 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7788 |     | <span class='neutral'>        assembly {</span>
  7789 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7790 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7791 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7792 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7793 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7794 |     | <span class='neutral'>        }</span>
  7795 |     | <span class='neutral'>    }</span>
  7796 |     | <span class='neutral'></span>
  7797 |     | <span class='neutral'>    function log(uint256 p0, address p1, address p2, bytes32 p3) internal pure {</span>
  7798 |     | <span class='neutral'>        bytes32 m0;</span>
  7799 |     | <span class='neutral'>        bytes32 m1;</span>
  7800 |     | <span class='neutral'>        bytes32 m2;</span>
  7801 |     | <span class='neutral'>        bytes32 m3;</span>
  7802 |     | <span class='neutral'>        bytes32 m4;</span>
  7803 |     | <span class='neutral'>        bytes32 m5;</span>
  7804 |     | <span class='neutral'>        bytes32 m6;</span>
  7805 |     | <span class='neutral'>        assembly {</span>
  7806 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7807 |     | <span class='neutral'>                let length := 0</span>
  7808 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7809 |     | <span class='neutral'>                mstore(pos, length)</span>
  7810 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7811 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7812 |     | <span class='neutral'>            }</span>
  7813 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7814 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7815 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7816 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7817 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7818 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7819 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7820 |     | <span class='neutral'>            // Selector of `log(uint256,address,address,string)`.</span>
  7821 |     | <span class='neutral'>            mstore(0x00, 0x031c6f73)</span>
  7822 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7823 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7824 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7825 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7826 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7827 |     | <span class='neutral'>        }</span>
  7828 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7829 |     | <span class='neutral'>        assembly {</span>
  7830 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7831 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7832 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7833 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7834 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7835 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7836 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7837 |     | <span class='neutral'>        }</span>
  7838 |     | <span class='neutral'>    }</span>
  7839 |     | <span class='neutral'></span>
  7840 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, address p3) internal pure {</span>
  7841 |     | <span class='neutral'>        bytes32 m0;</span>
  7842 |     | <span class='neutral'>        bytes32 m1;</span>
  7843 |     | <span class='neutral'>        bytes32 m2;</span>
  7844 |     | <span class='neutral'>        bytes32 m3;</span>
  7845 |     | <span class='neutral'>        bytes32 m4;</span>
  7846 |     | <span class='neutral'>        assembly {</span>
  7847 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7848 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7849 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7850 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7851 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7852 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,address)`.</span>
  7853 |     | <span class='neutral'>            mstore(0x00, 0xef72c513)</span>
  7854 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7855 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7856 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7857 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7858 |     | <span class='neutral'>        }</span>
  7859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7860 |     | <span class='neutral'>        assembly {</span>
  7861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7866 |     | <span class='neutral'>        }</span>
  7867 |     | <span class='neutral'>    }</span>
  7868 |     | <span class='neutral'></span>
  7869 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {</span>
  7870 |     | <span class='neutral'>        bytes32 m0;</span>
  7871 |     | <span class='neutral'>        bytes32 m1;</span>
  7872 |     | <span class='neutral'>        bytes32 m2;</span>
  7873 |     | <span class='neutral'>        bytes32 m3;</span>
  7874 |     | <span class='neutral'>        bytes32 m4;</span>
  7875 |     | <span class='neutral'>        assembly {</span>
  7876 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7877 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7878 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7879 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7880 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7881 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,bool)`.</span>
  7882 |     | <span class='neutral'>            mstore(0x00, 0xe351140f)</span>
  7883 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7884 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7885 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7886 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7887 |     | <span class='neutral'>        }</span>
  7888 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7889 |     | <span class='neutral'>        assembly {</span>
  7890 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7891 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7892 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7893 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7894 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7895 |     | <span class='neutral'>        }</span>
  7896 |     | <span class='neutral'>    }</span>
  7897 |     | <span class='neutral'></span>
  7898 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {</span>
  7899 |     | <span class='neutral'>        bytes32 m0;</span>
  7900 |     | <span class='neutral'>        bytes32 m1;</span>
  7901 |     | <span class='neutral'>        bytes32 m2;</span>
  7902 |     | <span class='neutral'>        bytes32 m3;</span>
  7903 |     | <span class='neutral'>        bytes32 m4;</span>
  7904 |     | <span class='neutral'>        assembly {</span>
  7905 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7906 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7907 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7908 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7909 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7910 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,uint256)`.</span>
  7911 |     | <span class='neutral'>            mstore(0x00, 0x5abd992a)</span>
  7912 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7913 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7914 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7915 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7916 |     | <span class='neutral'>        }</span>
  7917 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7918 |     | <span class='neutral'>        assembly {</span>
  7919 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7920 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7921 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7922 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7923 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7924 |     | <span class='neutral'>        }</span>
  7925 |     | <span class='neutral'>    }</span>
  7926 |     | <span class='neutral'></span>
  7927 |     | <span class='neutral'>    function log(uint256 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
  7928 |     | <span class='neutral'>        bytes32 m0;</span>
  7929 |     | <span class='neutral'>        bytes32 m1;</span>
  7930 |     | <span class='neutral'>        bytes32 m2;</span>
  7931 |     | <span class='neutral'>        bytes32 m3;</span>
  7932 |     | <span class='neutral'>        bytes32 m4;</span>
  7933 |     | <span class='neutral'>        bytes32 m5;</span>
  7934 |     | <span class='neutral'>        bytes32 m6;</span>
  7935 |     | <span class='neutral'>        assembly {</span>
  7936 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  7937 |     | <span class='neutral'>                let length := 0</span>
  7938 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  7939 |     | <span class='neutral'>                mstore(pos, length)</span>
  7940 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  7941 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  7942 |     | <span class='neutral'>            }</span>
  7943 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7944 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7945 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7946 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7947 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7948 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  7949 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  7950 |     | <span class='neutral'>            // Selector of `log(uint256,address,bool,string)`.</span>
  7951 |     | <span class='neutral'>            mstore(0x00, 0x90fb06aa)</span>
  7952 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7953 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7954 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7955 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  7956 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  7957 |     | <span class='neutral'>        }</span>
  7958 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  7959 |     | <span class='neutral'>        assembly {</span>
  7960 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7961 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7962 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7963 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7964 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7965 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  7966 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  7967 |     | <span class='neutral'>        }</span>
  7968 |     | <span class='neutral'>    }</span>
  7969 |     | <span class='neutral'></span>
  7970 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {</span>
  7971 |     | <span class='neutral'>        bytes32 m0;</span>
  7972 |     | <span class='neutral'>        bytes32 m1;</span>
  7973 |     | <span class='neutral'>        bytes32 m2;</span>
  7974 |     | <span class='neutral'>        bytes32 m3;</span>
  7975 |     | <span class='neutral'>        bytes32 m4;</span>
  7976 |     | <span class='neutral'>        assembly {</span>
  7977 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  7978 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  7979 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  7980 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  7981 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  7982 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,address)`.</span>
  7983 |     | <span class='neutral'>            mstore(0x00, 0x15c127b5)</span>
  7984 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  7985 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  7986 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  7987 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  7988 |     | <span class='neutral'>        }</span>
  7989 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  7990 |     | <span class='neutral'>        assembly {</span>
  7991 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  7992 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  7993 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  7994 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  7995 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  7996 |     | <span class='neutral'>        }</span>
  7997 |     | <span class='neutral'>    }</span>
  7998 |     | <span class='neutral'></span>
  7999 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {</span>
  8000 |     | <span class='neutral'>        bytes32 m0;</span>
  8001 |     | <span class='neutral'>        bytes32 m1;</span>
  8002 |     | <span class='neutral'>        bytes32 m2;</span>
  8003 |     | <span class='neutral'>        bytes32 m3;</span>
  8004 |     | <span class='neutral'>        bytes32 m4;</span>
  8005 |     | <span class='neutral'>        assembly {</span>
  8006 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8007 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8008 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8009 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8010 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8011 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,bool)`.</span>
  8012 |     | <span class='neutral'>            mstore(0x00, 0x5f743a7c)</span>
  8013 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8014 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8015 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8016 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8017 |     | <span class='neutral'>        }</span>
  8018 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8019 |     | <span class='neutral'>        assembly {</span>
  8020 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8021 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8022 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8023 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8024 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8025 |     | <span class='neutral'>        }</span>
  8026 |     | <span class='neutral'>    }</span>
  8027 |     | <span class='neutral'></span>
  8028 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
  8029 |     | <span class='neutral'>        bytes32 m0;</span>
  8030 |     | <span class='neutral'>        bytes32 m1;</span>
  8031 |     | <span class='neutral'>        bytes32 m2;</span>
  8032 |     | <span class='neutral'>        bytes32 m3;</span>
  8033 |     | <span class='neutral'>        bytes32 m4;</span>
  8034 |     | <span class='neutral'>        assembly {</span>
  8035 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8036 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8037 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8038 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8039 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8040 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,uint256)`.</span>
  8041 |     | <span class='neutral'>            mstore(0x00, 0x0c9cd9c1)</span>
  8042 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8043 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8044 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8045 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8046 |     | <span class='neutral'>        }</span>
  8047 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8048 |     | <span class='neutral'>        assembly {</span>
  8049 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8050 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8051 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8052 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8053 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8054 |     | <span class='neutral'>        }</span>
  8055 |     | <span class='neutral'>    }</span>
  8056 |     | <span class='neutral'></span>
  8057 |     | <span class='neutral'>    function log(uint256 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
  8058 |     | <span class='neutral'>        bytes32 m0;</span>
  8059 |     | <span class='neutral'>        bytes32 m1;</span>
  8060 |     | <span class='neutral'>        bytes32 m2;</span>
  8061 |     | <span class='neutral'>        bytes32 m3;</span>
  8062 |     | <span class='neutral'>        bytes32 m4;</span>
  8063 |     | <span class='neutral'>        bytes32 m5;</span>
  8064 |     | <span class='neutral'>        bytes32 m6;</span>
  8065 |     | <span class='neutral'>        assembly {</span>
  8066 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8067 |     | <span class='neutral'>                let length := 0</span>
  8068 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8069 |     | <span class='neutral'>                mstore(pos, length)</span>
  8070 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8071 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8072 |     | <span class='neutral'>            }</span>
  8073 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8074 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8075 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8076 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8077 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8078 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8079 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8080 |     | <span class='neutral'>            // Selector of `log(uint256,address,uint256,string)`.</span>
  8081 |     | <span class='neutral'>            mstore(0x00, 0xddb06521)</span>
  8082 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8083 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8084 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8085 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8086 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8087 |     | <span class='neutral'>        }</span>
  8088 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8089 |     | <span class='neutral'>        assembly {</span>
  8090 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8091 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8092 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8093 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8094 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8095 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8096 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8097 |     | <span class='neutral'>        }</span>
  8098 |     | <span class='neutral'>    }</span>
  8099 |     | <span class='neutral'></span>
  8100 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, address p3) internal pure {</span>
  8101 |     | <span class='neutral'>        bytes32 m0;</span>
  8102 |     | <span class='neutral'>        bytes32 m1;</span>
  8103 |     | <span class='neutral'>        bytes32 m2;</span>
  8104 |     | <span class='neutral'>        bytes32 m3;</span>
  8105 |     | <span class='neutral'>        bytes32 m4;</span>
  8106 |     | <span class='neutral'>        bytes32 m5;</span>
  8107 |     | <span class='neutral'>        bytes32 m6;</span>
  8108 |     | <span class='neutral'>        assembly {</span>
  8109 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8110 |     | <span class='neutral'>                let length := 0</span>
  8111 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8112 |     | <span class='neutral'>                mstore(pos, length)</span>
  8113 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8114 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8115 |     | <span class='neutral'>            }</span>
  8116 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8117 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8118 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8119 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8120 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8121 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8122 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8123 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,address)`.</span>
  8124 |     | <span class='neutral'>            mstore(0x00, 0x9cba8fff)</span>
  8125 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8126 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8127 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8128 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8129 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8130 |     | <span class='neutral'>        }</span>
  8131 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8132 |     | <span class='neutral'>        assembly {</span>
  8133 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8134 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8135 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8136 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8137 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8138 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8139 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8140 |     | <span class='neutral'>        }</span>
  8141 |     | <span class='neutral'>    }</span>
  8142 |     | <span class='neutral'></span>
  8143 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
  8144 |     | <span class='neutral'>        bytes32 m0;</span>
  8145 |     | <span class='neutral'>        bytes32 m1;</span>
  8146 |     | <span class='neutral'>        bytes32 m2;</span>
  8147 |     | <span class='neutral'>        bytes32 m3;</span>
  8148 |     | <span class='neutral'>        bytes32 m4;</span>
  8149 |     | <span class='neutral'>        bytes32 m5;</span>
  8150 |     | <span class='neutral'>        bytes32 m6;</span>
  8151 |     | <span class='neutral'>        assembly {</span>
  8152 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8153 |     | <span class='neutral'>                let length := 0</span>
  8154 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8155 |     | <span class='neutral'>                mstore(pos, length)</span>
  8156 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8157 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8158 |     | <span class='neutral'>            }</span>
  8159 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8160 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8161 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8162 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8163 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8164 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8165 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8166 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,bool)`.</span>
  8167 |     | <span class='neutral'>            mstore(0x00, 0xcc32ab07)</span>
  8168 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8169 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8170 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8171 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8172 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8173 |     | <span class='neutral'>        }</span>
  8174 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8175 |     | <span class='neutral'>        assembly {</span>
  8176 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8177 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8178 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8179 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8180 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8181 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8182 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8183 |     | <span class='neutral'>        }</span>
  8184 |     | <span class='neutral'>    }</span>
  8185 |     | <span class='neutral'></span>
  8186 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
  8187 |     | <span class='neutral'>        bytes32 m0;</span>
  8188 |     | <span class='neutral'>        bytes32 m1;</span>
  8189 |     | <span class='neutral'>        bytes32 m2;</span>
  8190 |     | <span class='neutral'>        bytes32 m3;</span>
  8191 |     | <span class='neutral'>        bytes32 m4;</span>
  8192 |     | <span class='neutral'>        bytes32 m5;</span>
  8193 |     | <span class='neutral'>        bytes32 m6;</span>
  8194 |     | <span class='neutral'>        assembly {</span>
  8195 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8196 |     | <span class='neutral'>                let length := 0</span>
  8197 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8198 |     | <span class='neutral'>                mstore(pos, length)</span>
  8199 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8200 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8201 |     | <span class='neutral'>            }</span>
  8202 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8203 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8204 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8205 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8206 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8207 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8208 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8209 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,uint256)`.</span>
  8210 |     | <span class='neutral'>            mstore(0x00, 0x46826b5d)</span>
  8211 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8212 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8213 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8214 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8215 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8216 |     | <span class='neutral'>        }</span>
  8217 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8218 |     | <span class='neutral'>        assembly {</span>
  8219 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8220 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8221 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8222 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8223 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8224 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8225 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8226 |     | <span class='neutral'>        }</span>
  8227 |     | <span class='neutral'>    }</span>
  8228 |     | <span class='neutral'></span>
  8229 |     | <span class='neutral'>    function log(uint256 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8230 |     | <span class='neutral'>        bytes32 m0;</span>
  8231 |     | <span class='neutral'>        bytes32 m1;</span>
  8232 |     | <span class='neutral'>        bytes32 m2;</span>
  8233 |     | <span class='neutral'>        bytes32 m3;</span>
  8234 |     | <span class='neutral'>        bytes32 m4;</span>
  8235 |     | <span class='neutral'>        bytes32 m5;</span>
  8236 |     | <span class='neutral'>        bytes32 m6;</span>
  8237 |     | <span class='neutral'>        bytes32 m7;</span>
  8238 |     | <span class='neutral'>        bytes32 m8;</span>
  8239 |     | <span class='neutral'>        assembly {</span>
  8240 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8241 |     | <span class='neutral'>                let length := 0</span>
  8242 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8243 |     | <span class='neutral'>                mstore(pos, length)</span>
  8244 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8245 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8246 |     | <span class='neutral'>            }</span>
  8247 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8248 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8249 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8250 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8251 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8252 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8253 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8254 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8255 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8256 |     | <span class='neutral'>            // Selector of `log(uint256,address,string,string)`.</span>
  8257 |     | <span class='neutral'>            mstore(0x00, 0x3e128ca3)</span>
  8258 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8259 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8260 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8261 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8262 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8263 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8264 |     | <span class='neutral'>        }</span>
  8265 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8266 |     | <span class='neutral'>        assembly {</span>
  8267 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8268 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8269 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8270 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8271 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8272 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8273 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8274 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8275 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8276 |     | <span class='neutral'>        }</span>
  8277 |     | <span class='neutral'>    }</span>
  8278 |     | <span class='neutral'></span>
  8279 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, address p3) internal pure {</span>
  8280 |     | <span class='neutral'>        bytes32 m0;</span>
  8281 |     | <span class='neutral'>        bytes32 m1;</span>
  8282 |     | <span class='neutral'>        bytes32 m2;</span>
  8283 |     | <span class='neutral'>        bytes32 m3;</span>
  8284 |     | <span class='neutral'>        bytes32 m4;</span>
  8285 |     | <span class='neutral'>        assembly {</span>
  8286 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8287 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8288 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8289 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8290 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8291 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,address)`.</span>
  8292 |     | <span class='neutral'>            mstore(0x00, 0xa1ef4cbb)</span>
  8293 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8294 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8295 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8296 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8297 |     | <span class='neutral'>        }</span>
  8298 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8299 |     | <span class='neutral'>        assembly {</span>
  8300 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8301 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8302 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8303 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8304 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8305 |     | <span class='neutral'>        }</span>
  8306 |     | <span class='neutral'>    }</span>
  8307 |     | <span class='neutral'></span>
  8308 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {</span>
  8309 |     | <span class='neutral'>        bytes32 m0;</span>
  8310 |     | <span class='neutral'>        bytes32 m1;</span>
  8311 |     | <span class='neutral'>        bytes32 m2;</span>
  8312 |     | <span class='neutral'>        bytes32 m3;</span>
  8313 |     | <span class='neutral'>        bytes32 m4;</span>
  8314 |     | <span class='neutral'>        assembly {</span>
  8315 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8316 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8317 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8318 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8319 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8320 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,bool)`.</span>
  8321 |     | <span class='neutral'>            mstore(0x00, 0x454d54a5)</span>
  8322 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8323 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8324 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8325 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8326 |     | <span class='neutral'>        }</span>
  8327 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8328 |     | <span class='neutral'>        assembly {</span>
  8329 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8330 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8331 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8332 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8333 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8334 |     | <span class='neutral'>        }</span>
  8335 |     | <span class='neutral'>    }</span>
  8336 |     | <span class='neutral'></span>
  8337 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {</span>
  8338 |     | <span class='neutral'>        bytes32 m0;</span>
  8339 |     | <span class='neutral'>        bytes32 m1;</span>
  8340 |     | <span class='neutral'>        bytes32 m2;</span>
  8341 |     | <span class='neutral'>        bytes32 m3;</span>
  8342 |     | <span class='neutral'>        bytes32 m4;</span>
  8343 |     | <span class='neutral'>        assembly {</span>
  8344 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8345 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8346 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8347 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8348 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8349 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,uint256)`.</span>
  8350 |     | <span class='neutral'>            mstore(0x00, 0x078287f5)</span>
  8351 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8352 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8353 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8354 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8355 |     | <span class='neutral'>        }</span>
  8356 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8357 |     | <span class='neutral'>        assembly {</span>
  8358 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8359 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8360 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8361 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8362 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8363 |     | <span class='neutral'>        }</span>
  8364 |     | <span class='neutral'>    }</span>
  8365 |     | <span class='neutral'></span>
  8366 |     | <span class='neutral'>    function log(uint256 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
  8367 |     | <span class='neutral'>        bytes32 m0;</span>
  8368 |     | <span class='neutral'>        bytes32 m1;</span>
  8369 |     | <span class='neutral'>        bytes32 m2;</span>
  8370 |     | <span class='neutral'>        bytes32 m3;</span>
  8371 |     | <span class='neutral'>        bytes32 m4;</span>
  8372 |     | <span class='neutral'>        bytes32 m5;</span>
  8373 |     | <span class='neutral'>        bytes32 m6;</span>
  8374 |     | <span class='neutral'>        assembly {</span>
  8375 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8376 |     | <span class='neutral'>                let length := 0</span>
  8377 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8378 |     | <span class='neutral'>                mstore(pos, length)</span>
  8379 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8380 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8381 |     | <span class='neutral'>            }</span>
  8382 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8383 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8384 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8385 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8386 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8387 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8388 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8389 |     | <span class='neutral'>            // Selector of `log(uint256,bool,address,string)`.</span>
  8390 |     | <span class='neutral'>            mstore(0x00, 0xade052c7)</span>
  8391 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8392 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8393 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8394 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8395 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8396 |     | <span class='neutral'>        }</span>
  8397 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8398 |     | <span class='neutral'>        assembly {</span>
  8399 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8400 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8401 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8402 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8403 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8404 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8405 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8406 |     | <span class='neutral'>        }</span>
  8407 |     | <span class='neutral'>    }</span>
  8408 |     | <span class='neutral'></span>
  8409 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {</span>
  8410 |     | <span class='neutral'>        bytes32 m0;</span>
  8411 |     | <span class='neutral'>        bytes32 m1;</span>
  8412 |     | <span class='neutral'>        bytes32 m2;</span>
  8413 |     | <span class='neutral'>        bytes32 m3;</span>
  8414 |     | <span class='neutral'>        bytes32 m4;</span>
  8415 |     | <span class='neutral'>        assembly {</span>
  8416 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8417 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8418 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8419 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8420 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8421 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,address)`.</span>
  8422 |     | <span class='neutral'>            mstore(0x00, 0x69640b59)</span>
  8423 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8424 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8425 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8426 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8427 |     | <span class='neutral'>        }</span>
  8428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8429 |     | <span class='neutral'>        assembly {</span>
  8430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8435 |     | <span class='neutral'>        }</span>
  8436 |     | <span class='neutral'>    }</span>
  8437 |     | <span class='neutral'></span>
  8438 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {</span>
  8439 |     | <span class='neutral'>        bytes32 m0;</span>
  8440 |     | <span class='neutral'>        bytes32 m1;</span>
  8441 |     | <span class='neutral'>        bytes32 m2;</span>
  8442 |     | <span class='neutral'>        bytes32 m3;</span>
  8443 |     | <span class='neutral'>        bytes32 m4;</span>
  8444 |     | <span class='neutral'>        assembly {</span>
  8445 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8446 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8447 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8448 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8449 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8450 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,bool)`.</span>
  8451 |     | <span class='neutral'>            mstore(0x00, 0xb6f577a1)</span>
  8452 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8453 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8454 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8455 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8456 |     | <span class='neutral'>        }</span>
  8457 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8458 |     | <span class='neutral'>        assembly {</span>
  8459 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8460 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8461 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8462 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8463 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8464 |     | <span class='neutral'>        }</span>
  8465 |     | <span class='neutral'>    }</span>
  8466 |     | <span class='neutral'></span>
  8467 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
  8468 |     | <span class='neutral'>        bytes32 m0;</span>
  8469 |     | <span class='neutral'>        bytes32 m1;</span>
  8470 |     | <span class='neutral'>        bytes32 m2;</span>
  8471 |     | <span class='neutral'>        bytes32 m3;</span>
  8472 |     | <span class='neutral'>        bytes32 m4;</span>
  8473 |     | <span class='neutral'>        assembly {</span>
  8474 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8475 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8476 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8477 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8478 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8479 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,uint256)`.</span>
  8480 |     | <span class='neutral'>            mstore(0x00, 0x7464ce23)</span>
  8481 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8482 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8483 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8484 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8485 |     | <span class='neutral'>        }</span>
  8486 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8487 |     | <span class='neutral'>        assembly {</span>
  8488 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8489 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8490 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8491 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8492 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8493 |     | <span class='neutral'>        }</span>
  8494 |     | <span class='neutral'>    }</span>
  8495 |     | <span class='neutral'></span>
  8496 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
  8497 |     | <span class='neutral'>        bytes32 m0;</span>
  8498 |     | <span class='neutral'>        bytes32 m1;</span>
  8499 |     | <span class='neutral'>        bytes32 m2;</span>
  8500 |     | <span class='neutral'>        bytes32 m3;</span>
  8501 |     | <span class='neutral'>        bytes32 m4;</span>
  8502 |     | <span class='neutral'>        bytes32 m5;</span>
  8503 |     | <span class='neutral'>        bytes32 m6;</span>
  8504 |     | <span class='neutral'>        assembly {</span>
  8505 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8506 |     | <span class='neutral'>                let length := 0</span>
  8507 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8508 |     | <span class='neutral'>                mstore(pos, length)</span>
  8509 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8510 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8511 |     | <span class='neutral'>            }</span>
  8512 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8513 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8514 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8515 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8516 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8517 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8518 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8519 |     | <span class='neutral'>            // Selector of `log(uint256,bool,bool,string)`.</span>
  8520 |     | <span class='neutral'>            mstore(0x00, 0xdddb9561)</span>
  8521 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8523 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8524 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8525 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8526 |     | <span class='neutral'>        }</span>
  8527 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8528 |     | <span class='neutral'>        assembly {</span>
  8529 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8530 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8531 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8532 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8533 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8534 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8535 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8536 |     | <span class='neutral'>        }</span>
  8537 |     | <span class='neutral'>    }</span>
  8538 |     | <span class='neutral'></span>
  8539 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {</span>
  8540 |     | <span class='neutral'>        bytes32 m0;</span>
  8541 |     | <span class='neutral'>        bytes32 m1;</span>
  8542 |     | <span class='neutral'>        bytes32 m2;</span>
  8543 |     | <span class='neutral'>        bytes32 m3;</span>
  8544 |     | <span class='neutral'>        bytes32 m4;</span>
  8545 |     | <span class='neutral'>        assembly {</span>
  8546 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8547 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8548 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8549 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8550 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8551 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,address)`.</span>
  8552 |     | <span class='neutral'>            mstore(0x00, 0x88cb6041)</span>
  8553 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8554 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8555 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8556 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8557 |     | <span class='neutral'>        }</span>
  8558 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8559 |     | <span class='neutral'>        assembly {</span>
  8560 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8561 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8562 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8563 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8564 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8565 |     | <span class='neutral'>        }</span>
  8566 |     | <span class='neutral'>    }</span>
  8567 |     | <span class='neutral'></span>
  8568 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
  8569 |     | <span class='neutral'>        bytes32 m0;</span>
  8570 |     | <span class='neutral'>        bytes32 m1;</span>
  8571 |     | <span class='neutral'>        bytes32 m2;</span>
  8572 |     | <span class='neutral'>        bytes32 m3;</span>
  8573 |     | <span class='neutral'>        bytes32 m4;</span>
  8574 |     | <span class='neutral'>        assembly {</span>
  8575 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8576 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8577 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8578 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8579 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8580 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,bool)`.</span>
  8581 |     | <span class='neutral'>            mstore(0x00, 0x91a02e2a)</span>
  8582 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8583 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8584 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8585 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8586 |     | <span class='neutral'>        }</span>
  8587 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8588 |     | <span class='neutral'>        assembly {</span>
  8589 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8590 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8591 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8592 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8593 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8594 |     | <span class='neutral'>        }</span>
  8595 |     | <span class='neutral'>    }</span>
  8596 |     | <span class='neutral'></span>
  8597 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
  8598 |     | <span class='neutral'>        bytes32 m0;</span>
  8599 |     | <span class='neutral'>        bytes32 m1;</span>
  8600 |     | <span class='neutral'>        bytes32 m2;</span>
  8601 |     | <span class='neutral'>        bytes32 m3;</span>
  8602 |     | <span class='neutral'>        bytes32 m4;</span>
  8603 |     | <span class='neutral'>        assembly {</span>
  8604 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8605 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8606 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8607 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8608 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8609 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,uint256)`.</span>
  8610 |     | <span class='neutral'>            mstore(0x00, 0xc6acc7a8)</span>
  8611 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8612 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8613 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8614 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8615 |     | <span class='neutral'>        }</span>
  8616 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8617 |     | <span class='neutral'>        assembly {</span>
  8618 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8619 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8620 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8621 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8622 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8623 |     | <span class='neutral'>        }</span>
  8624 |     | <span class='neutral'>    }</span>
  8625 |     | <span class='neutral'></span>
  8626 |     | <span class='neutral'>    function log(uint256 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
  8627 |     | <span class='neutral'>        bytes32 m0;</span>
  8628 |     | <span class='neutral'>        bytes32 m1;</span>
  8629 |     | <span class='neutral'>        bytes32 m2;</span>
  8630 |     | <span class='neutral'>        bytes32 m3;</span>
  8631 |     | <span class='neutral'>        bytes32 m4;</span>
  8632 |     | <span class='neutral'>        bytes32 m5;</span>
  8633 |     | <span class='neutral'>        bytes32 m6;</span>
  8634 |     | <span class='neutral'>        assembly {</span>
  8635 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8636 |     | <span class='neutral'>                let length := 0</span>
  8637 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8638 |     | <span class='neutral'>                mstore(pos, length)</span>
  8639 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8640 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8641 |     | <span class='neutral'>            }</span>
  8642 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8643 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8644 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8645 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8646 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8647 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8648 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8649 |     | <span class='neutral'>            // Selector of `log(uint256,bool,uint256,string)`.</span>
  8650 |     | <span class='neutral'>            mstore(0x00, 0xde03e774)</span>
  8651 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8652 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8653 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8654 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8655 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8656 |     | <span class='neutral'>        }</span>
  8657 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8658 |     | <span class='neutral'>        assembly {</span>
  8659 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8660 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8661 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8662 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8663 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8664 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8665 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8666 |     | <span class='neutral'>        }</span>
  8667 |     | <span class='neutral'>    }</span>
  8668 |     | <span class='neutral'></span>
  8669 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
  8670 |     | <span class='neutral'>        bytes32 m0;</span>
  8671 |     | <span class='neutral'>        bytes32 m1;</span>
  8672 |     | <span class='neutral'>        bytes32 m2;</span>
  8673 |     | <span class='neutral'>        bytes32 m3;</span>
  8674 |     | <span class='neutral'>        bytes32 m4;</span>
  8675 |     | <span class='neutral'>        bytes32 m5;</span>
  8676 |     | <span class='neutral'>        bytes32 m6;</span>
  8677 |     | <span class='neutral'>        assembly {</span>
  8678 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8679 |     | <span class='neutral'>                let length := 0</span>
  8680 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8681 |     | <span class='neutral'>                mstore(pos, length)</span>
  8682 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8683 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8684 |     | <span class='neutral'>            }</span>
  8685 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8686 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8687 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8688 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8689 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8690 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8691 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8692 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,address)`.</span>
  8693 |     | <span class='neutral'>            mstore(0x00, 0xef529018)</span>
  8694 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8695 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8696 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8697 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8698 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8699 |     | <span class='neutral'>        }</span>
  8700 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8701 |     | <span class='neutral'>        assembly {</span>
  8702 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8703 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8704 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8705 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8706 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8707 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8708 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8709 |     | <span class='neutral'>        }</span>
  8710 |     | <span class='neutral'>    }</span>
  8711 |     | <span class='neutral'></span>
  8712 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
  8713 |     | <span class='neutral'>        bytes32 m0;</span>
  8714 |     | <span class='neutral'>        bytes32 m1;</span>
  8715 |     | <span class='neutral'>        bytes32 m2;</span>
  8716 |     | <span class='neutral'>        bytes32 m3;</span>
  8717 |     | <span class='neutral'>        bytes32 m4;</span>
  8718 |     | <span class='neutral'>        bytes32 m5;</span>
  8719 |     | <span class='neutral'>        bytes32 m6;</span>
  8720 |     | <span class='neutral'>        assembly {</span>
  8721 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8722 |     | <span class='neutral'>                let length := 0</span>
  8723 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8724 |     | <span class='neutral'>                mstore(pos, length)</span>
  8725 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8726 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8727 |     | <span class='neutral'>            }</span>
  8728 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8729 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8730 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8731 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8732 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8733 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8734 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8735 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,bool)`.</span>
  8736 |     | <span class='neutral'>            mstore(0x00, 0xeb928d7f)</span>
  8737 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8738 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8739 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8740 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8741 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8742 |     | <span class='neutral'>        }</span>
  8743 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8744 |     | <span class='neutral'>        assembly {</span>
  8745 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8746 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8747 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8748 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8749 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8750 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8751 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8752 |     | <span class='neutral'>        }</span>
  8753 |     | <span class='neutral'>    }</span>
  8754 |     | <span class='neutral'></span>
  8755 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
  8756 |     | <span class='neutral'>        bytes32 m0;</span>
  8757 |     | <span class='neutral'>        bytes32 m1;</span>
  8758 |     | <span class='neutral'>        bytes32 m2;</span>
  8759 |     | <span class='neutral'>        bytes32 m3;</span>
  8760 |     | <span class='neutral'>        bytes32 m4;</span>
  8761 |     | <span class='neutral'>        bytes32 m5;</span>
  8762 |     | <span class='neutral'>        bytes32 m6;</span>
  8763 |     | <span class='neutral'>        assembly {</span>
  8764 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8765 |     | <span class='neutral'>                let length := 0</span>
  8766 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8767 |     | <span class='neutral'>                mstore(pos, length)</span>
  8768 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8769 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8770 |     | <span class='neutral'>            }</span>
  8771 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8772 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8773 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8774 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8775 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8776 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8777 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8778 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,uint256)`.</span>
  8779 |     | <span class='neutral'>            mstore(0x00, 0x2c1d0746)</span>
  8780 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8781 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8782 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8783 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8784 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8785 |     | <span class='neutral'>        }</span>
  8786 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8787 |     | <span class='neutral'>        assembly {</span>
  8788 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8789 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8790 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8791 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8792 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8793 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8794 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8795 |     | <span class='neutral'>        }</span>
  8796 |     | <span class='neutral'>    }</span>
  8797 |     | <span class='neutral'></span>
  8798 |     | <span class='neutral'>    function log(uint256 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
  8799 |     | <span class='neutral'>        bytes32 m0;</span>
  8800 |     | <span class='neutral'>        bytes32 m1;</span>
  8801 |     | <span class='neutral'>        bytes32 m2;</span>
  8802 |     | <span class='neutral'>        bytes32 m3;</span>
  8803 |     | <span class='neutral'>        bytes32 m4;</span>
  8804 |     | <span class='neutral'>        bytes32 m5;</span>
  8805 |     | <span class='neutral'>        bytes32 m6;</span>
  8806 |     | <span class='neutral'>        bytes32 m7;</span>
  8807 |     | <span class='neutral'>        bytes32 m8;</span>
  8808 |     | <span class='neutral'>        assembly {</span>
  8809 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8810 |     | <span class='neutral'>                let length := 0</span>
  8811 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8812 |     | <span class='neutral'>                mstore(pos, length)</span>
  8813 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8814 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8815 |     | <span class='neutral'>            }</span>
  8816 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8817 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8818 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8819 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8820 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8821 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8822 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8823 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  8824 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  8825 |     | <span class='neutral'>            // Selector of `log(uint256,bool,string,string)`.</span>
  8826 |     | <span class='neutral'>            mstore(0x00, 0x68c8b8bd)</span>
  8827 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8828 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8829 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  8830 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  8831 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  8832 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  8833 |     | <span class='neutral'>        }</span>
  8834 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  8835 |     | <span class='neutral'>        assembly {</span>
  8836 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8837 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8838 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8839 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8840 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8841 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8842 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8843 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  8844 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  8845 |     | <span class='neutral'>        }</span>
  8846 |     | <span class='neutral'>    }</span>
  8847 |     | <span class='neutral'></span>
  8848 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {</span>
  8849 |     | <span class='neutral'>        bytes32 m0;</span>
  8850 |     | <span class='neutral'>        bytes32 m1;</span>
  8851 |     | <span class='neutral'>        bytes32 m2;</span>
  8852 |     | <span class='neutral'>        bytes32 m3;</span>
  8853 |     | <span class='neutral'>        bytes32 m4;</span>
  8854 |     | <span class='neutral'>        assembly {</span>
  8855 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8856 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8857 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8858 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8859 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8860 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,address)`.</span>
  8861 |     | <span class='neutral'>            mstore(0x00, 0x56a5d1b1)</span>
  8862 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8863 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8864 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8865 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8866 |     | <span class='neutral'>        }</span>
  8867 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8868 |     | <span class='neutral'>        assembly {</span>
  8869 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8870 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8871 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8872 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8873 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8874 |     | <span class='neutral'>        }</span>
  8875 |     | <span class='neutral'>    }</span>
  8876 |     | <span class='neutral'></span>
  8877 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {</span>
  8878 |     | <span class='neutral'>        bytes32 m0;</span>
  8879 |     | <span class='neutral'>        bytes32 m1;</span>
  8880 |     | <span class='neutral'>        bytes32 m2;</span>
  8881 |     | <span class='neutral'>        bytes32 m3;</span>
  8882 |     | <span class='neutral'>        bytes32 m4;</span>
  8883 |     | <span class='neutral'>        assembly {</span>
  8884 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8885 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8886 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8887 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8888 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8889 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,bool)`.</span>
  8890 |     | <span class='neutral'>            mstore(0x00, 0x15cac476)</span>
  8891 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8892 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8893 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8894 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8895 |     | <span class='neutral'>        }</span>
  8896 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8897 |     | <span class='neutral'>        assembly {</span>
  8898 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8899 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8900 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8901 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8902 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8903 |     | <span class='neutral'>        }</span>
  8904 |     | <span class='neutral'>    }</span>
  8905 |     | <span class='neutral'></span>
  8906 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
  8907 |     | <span class='neutral'>        bytes32 m0;</span>
  8908 |     | <span class='neutral'>        bytes32 m1;</span>
  8909 |     | <span class='neutral'>        bytes32 m2;</span>
  8910 |     | <span class='neutral'>        bytes32 m3;</span>
  8911 |     | <span class='neutral'>        bytes32 m4;</span>
  8912 |     | <span class='neutral'>        assembly {</span>
  8913 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8914 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8915 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8916 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8917 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8918 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,uint256)`.</span>
  8919 |     | <span class='neutral'>            mstore(0x00, 0x88f6e4b2)</span>
  8920 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8921 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8922 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8923 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8924 |     | <span class='neutral'>        }</span>
  8925 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8926 |     | <span class='neutral'>        assembly {</span>
  8927 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8928 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8929 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8930 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8931 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8932 |     | <span class='neutral'>        }</span>
  8933 |     | <span class='neutral'>    }</span>
  8934 |     | <span class='neutral'></span>
  8935 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
  8936 |     | <span class='neutral'>        bytes32 m0;</span>
  8937 |     | <span class='neutral'>        bytes32 m1;</span>
  8938 |     | <span class='neutral'>        bytes32 m2;</span>
  8939 |     | <span class='neutral'>        bytes32 m3;</span>
  8940 |     | <span class='neutral'>        bytes32 m4;</span>
  8941 |     | <span class='neutral'>        bytes32 m5;</span>
  8942 |     | <span class='neutral'>        bytes32 m6;</span>
  8943 |     | <span class='neutral'>        assembly {</span>
  8944 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  8945 |     | <span class='neutral'>                let length := 0</span>
  8946 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  8947 |     | <span class='neutral'>                mstore(pos, length)</span>
  8948 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  8949 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  8950 |     | <span class='neutral'>            }</span>
  8951 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8952 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8953 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8954 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8955 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8956 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  8957 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  8958 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,address,string)`.</span>
  8959 |     | <span class='neutral'>            mstore(0x00, 0x6cde40b8)</span>
  8960 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8961 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8962 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8963 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  8964 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  8965 |     | <span class='neutral'>        }</span>
  8966 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  8967 |     | <span class='neutral'>        assembly {</span>
  8968 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  8969 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  8970 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  8971 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  8972 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  8973 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  8974 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  8975 |     | <span class='neutral'>        }</span>
  8976 |     | <span class='neutral'>    }</span>
  8977 |     | <span class='neutral'></span>
  8978 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {</span>
  8979 |     | <span class='neutral'>        bytes32 m0;</span>
  8980 |     | <span class='neutral'>        bytes32 m1;</span>
  8981 |     | <span class='neutral'>        bytes32 m2;</span>
  8982 |     | <span class='neutral'>        bytes32 m3;</span>
  8983 |     | <span class='neutral'>        bytes32 m4;</span>
  8984 |     | <span class='neutral'>        assembly {</span>
  8985 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  8986 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  8987 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  8988 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  8989 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  8990 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,address)`.</span>
  8991 |     | <span class='neutral'>            mstore(0x00, 0x9a816a83)</span>
  8992 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  8993 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  8994 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  8995 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  8996 |     | <span class='neutral'>        }</span>
  8997 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  8998 |     | <span class='neutral'>        assembly {</span>
  8999 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9000 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9001 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9002 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9003 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9004 |     | <span class='neutral'>        }</span>
  9005 |     | <span class='neutral'>    }</span>
  9006 |     | <span class='neutral'></span>
  9007 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
  9008 |     | <span class='neutral'>        bytes32 m0;</span>
  9009 |     | <span class='neutral'>        bytes32 m1;</span>
  9010 |     | <span class='neutral'>        bytes32 m2;</span>
  9011 |     | <span class='neutral'>        bytes32 m3;</span>
  9012 |     | <span class='neutral'>        bytes32 m4;</span>
  9013 |     | <span class='neutral'>        assembly {</span>
  9014 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9015 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9016 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9017 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9018 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9019 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,bool)`.</span>
  9020 |     | <span class='neutral'>            mstore(0x00, 0xab085ae6)</span>
  9021 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9022 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9023 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9024 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9025 |     | <span class='neutral'>        }</span>
  9026 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9027 |     | <span class='neutral'>        assembly {</span>
  9028 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9029 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9030 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9031 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9032 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9033 |     | <span class='neutral'>        }</span>
  9034 |     | <span class='neutral'>    }</span>
  9035 |     | <span class='neutral'></span>
  9036 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
  9037 |     | <span class='neutral'>        bytes32 m0;</span>
  9038 |     | <span class='neutral'>        bytes32 m1;</span>
  9039 |     | <span class='neutral'>        bytes32 m2;</span>
  9040 |     | <span class='neutral'>        bytes32 m3;</span>
  9041 |     | <span class='neutral'>        bytes32 m4;</span>
  9042 |     | <span class='neutral'>        assembly {</span>
  9043 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9044 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9045 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9046 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9047 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9048 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,uint256)`.</span>
  9049 |     | <span class='neutral'>            mstore(0x00, 0xeb7f6fd2)</span>
  9050 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9051 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9052 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9053 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9054 |     | <span class='neutral'>        }</span>
  9055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9056 |     | <span class='neutral'>        assembly {</span>
  9057 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9058 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9059 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9060 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9061 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9062 |     | <span class='neutral'>        }</span>
  9063 |     | <span class='neutral'>    }</span>
  9064 |     | <span class='neutral'></span>
  9065 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
  9066 |     | <span class='neutral'>        bytes32 m0;</span>
  9067 |     | <span class='neutral'>        bytes32 m1;</span>
  9068 |     | <span class='neutral'>        bytes32 m2;</span>
  9069 |     | <span class='neutral'>        bytes32 m3;</span>
  9070 |     | <span class='neutral'>        bytes32 m4;</span>
  9071 |     | <span class='neutral'>        bytes32 m5;</span>
  9072 |     | <span class='neutral'>        bytes32 m6;</span>
  9073 |     | <span class='neutral'>        assembly {</span>
  9074 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9075 |     | <span class='neutral'>                let length := 0</span>
  9076 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9077 |     | <span class='neutral'>                mstore(pos, length)</span>
  9078 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9079 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9080 |     | <span class='neutral'>            }</span>
  9081 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9082 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9083 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9084 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9085 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9086 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9087 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9088 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,bool,string)`.</span>
  9089 |     | <span class='neutral'>            mstore(0x00, 0xa5b4fc99)</span>
  9090 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9091 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9092 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9093 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9094 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9095 |     | <span class='neutral'>        }</span>
  9096 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9097 |     | <span class='neutral'>        assembly {</span>
  9098 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9099 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9100 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9101 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9102 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9103 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9104 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9105 |     | <span class='neutral'>        }</span>
  9106 |     | <span class='neutral'>    }</span>
  9107 |     | <span class='neutral'></span>
  9108 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
  9109 |     | <span class='neutral'>        bytes32 m0;</span>
  9110 |     | <span class='neutral'>        bytes32 m1;</span>
  9111 |     | <span class='neutral'>        bytes32 m2;</span>
  9112 |     | <span class='neutral'>        bytes32 m3;</span>
  9113 |     | <span class='neutral'>        bytes32 m4;</span>
  9114 |     | <span class='neutral'>        assembly {</span>
  9115 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9116 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9117 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9118 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9119 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9120 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,address)`.</span>
  9121 |     | <span class='neutral'>            mstore(0x00, 0xfa8185af)</span>
  9122 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9123 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9124 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9125 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9126 |     | <span class='neutral'>        }</span>
  9127 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9128 |     | <span class='neutral'>        assembly {</span>
  9129 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9130 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9131 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9132 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9133 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9134 |     | <span class='neutral'>        }</span>
  9135 |     | <span class='neutral'>    }</span>
  9136 |     | <span class='neutral'></span>
  9137 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
  9138 |     | <span class='neutral'>        bytes32 m0;</span>
  9139 |     | <span class='neutral'>        bytes32 m1;</span>
  9140 |     | <span class='neutral'>        bytes32 m2;</span>
  9141 |     | <span class='neutral'>        bytes32 m3;</span>
  9142 |     | <span class='neutral'>        bytes32 m4;</span>
  9143 |     | <span class='neutral'>        assembly {</span>
  9144 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9145 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9146 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9147 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9148 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9149 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,bool)`.</span>
  9150 |     | <span class='neutral'>            mstore(0x00, 0xc598d185)</span>
  9151 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9152 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9153 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9154 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9155 |     | <span class='neutral'>        }</span>
  9156 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9157 |     | <span class='neutral'>        assembly {</span>
  9158 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9159 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9160 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9161 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9162 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9163 |     | <span class='neutral'>        }</span>
  9164 |     | <span class='neutral'>    }</span>
  9165 |     | <span class='neutral'></span>
  9166 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
  9167 |     | <span class='neutral'>        bytes32 m0;</span>
  9168 |     | <span class='neutral'>        bytes32 m1;</span>
  9169 |     | <span class='neutral'>        bytes32 m2;</span>
  9170 |     | <span class='neutral'>        bytes32 m3;</span>
  9171 |     | <span class='neutral'>        bytes32 m4;</span>
  9172 |     | <span class='neutral'>        assembly {</span>
  9173 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9174 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9175 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9176 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9177 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9178 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,uint256)`.</span>
  9179 |     | <span class='neutral'>            mstore(0x00, 0x193fb800)</span>
  9180 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9181 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9182 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9183 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9184 |     | <span class='neutral'>        }</span>
  9185 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x84);</span>
  9186 |     | <span class='neutral'>        assembly {</span>
  9187 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9188 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9189 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9190 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9191 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9192 |     | <span class='neutral'>        }</span>
  9193 |     | <span class='neutral'>    }</span>
  9194 |     | <span class='neutral'></span>
  9195 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9196 |     | <span class='neutral'>        bytes32 m0;</span>
  9197 |     | <span class='neutral'>        bytes32 m1;</span>
  9198 |     | <span class='neutral'>        bytes32 m2;</span>
  9199 |     | <span class='neutral'>        bytes32 m3;</span>
  9200 |     | <span class='neutral'>        bytes32 m4;</span>
  9201 |     | <span class='neutral'>        bytes32 m5;</span>
  9202 |     | <span class='neutral'>        bytes32 m6;</span>
  9203 |     | <span class='neutral'>        assembly {</span>
  9204 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9205 |     | <span class='neutral'>                let length := 0</span>
  9206 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9207 |     | <span class='neutral'>                mstore(pos, length)</span>
  9208 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9209 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9210 |     | <span class='neutral'>            }</span>
  9211 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9212 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9213 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9214 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9215 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9216 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9217 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9218 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,uint256,string)`.</span>
  9219 |     | <span class='neutral'>            mstore(0x00, 0x59cfcbe3)</span>
  9220 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9221 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9222 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9223 |     | <span class='neutral'>            mstore(0x80, 0x80)</span>
  9224 |     | <span class='neutral'>            writeString(0xa0, p3)</span>
  9225 |     | <span class='neutral'>        }</span>
  9226 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9227 |     | <span class='neutral'>        assembly {</span>
  9228 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9229 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9230 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9231 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9232 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9233 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9234 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9235 |     | <span class='neutral'>        }</span>
  9236 |     | <span class='neutral'>    }</span>
  9237 |     | <span class='neutral'></span>
  9238 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
  9239 |     | <span class='neutral'>        bytes32 m0;</span>
  9240 |     | <span class='neutral'>        bytes32 m1;</span>
  9241 |     | <span class='neutral'>        bytes32 m2;</span>
  9242 |     | <span class='neutral'>        bytes32 m3;</span>
  9243 |     | <span class='neutral'>        bytes32 m4;</span>
  9244 |     | <span class='neutral'>        bytes32 m5;</span>
  9245 |     | <span class='neutral'>        bytes32 m6;</span>
  9246 |     | <span class='neutral'>        assembly {</span>
  9247 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9248 |     | <span class='neutral'>                let length := 0</span>
  9249 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9250 |     | <span class='neutral'>                mstore(pos, length)</span>
  9251 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9252 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9253 |     | <span class='neutral'>            }</span>
  9254 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9255 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9256 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9257 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9258 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9259 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9260 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9261 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,address)`.</span>
  9262 |     | <span class='neutral'>            mstore(0x00, 0x42d21db7)</span>
  9263 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9264 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9265 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9266 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9267 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9268 |     | <span class='neutral'>        }</span>
  9269 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9270 |     | <span class='neutral'>        assembly {</span>
  9271 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9272 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9273 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9274 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9275 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9276 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9277 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9278 |     | <span class='neutral'>        }</span>
  9279 |     | <span class='neutral'>    }</span>
  9280 |     | <span class='neutral'></span>
  9281 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
  9282 |     | <span class='neutral'>        bytes32 m0;</span>
  9283 |     | <span class='neutral'>        bytes32 m1;</span>
  9284 |     | <span class='neutral'>        bytes32 m2;</span>
  9285 |     | <span class='neutral'>        bytes32 m3;</span>
  9286 |     | <span class='neutral'>        bytes32 m4;</span>
  9287 |     | <span class='neutral'>        bytes32 m5;</span>
  9288 |     | <span class='neutral'>        bytes32 m6;</span>
  9289 |     | <span class='neutral'>        assembly {</span>
  9290 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9291 |     | <span class='neutral'>                let length := 0</span>
  9292 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9293 |     | <span class='neutral'>                mstore(pos, length)</span>
  9294 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9295 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9296 |     | <span class='neutral'>            }</span>
  9297 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9298 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9299 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9300 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9301 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9302 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9303 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9304 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,bool)`.</span>
  9305 |     | <span class='neutral'>            mstore(0x00, 0x7af6ab25)</span>
  9306 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9307 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9308 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9309 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9310 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9311 |     | <span class='neutral'>        }</span>
  9312 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9313 |     | <span class='neutral'>        assembly {</span>
  9314 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9315 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9316 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9317 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9318 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9319 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9320 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9321 |     | <span class='neutral'>        }</span>
  9322 |     | <span class='neutral'>    }</span>
  9323 |     | <span class='neutral'></span>
  9324 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
  9325 |     | <span class='neutral'>        bytes32 m0;</span>
  9326 |     | <span class='neutral'>        bytes32 m1;</span>
  9327 |     | <span class='neutral'>        bytes32 m2;</span>
  9328 |     | <span class='neutral'>        bytes32 m3;</span>
  9329 |     | <span class='neutral'>        bytes32 m4;</span>
  9330 |     | <span class='neutral'>        bytes32 m5;</span>
  9331 |     | <span class='neutral'>        bytes32 m6;</span>
  9332 |     | <span class='neutral'>        assembly {</span>
  9333 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9334 |     | <span class='neutral'>                let length := 0</span>
  9335 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9336 |     | <span class='neutral'>                mstore(pos, length)</span>
  9337 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9338 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9339 |     | <span class='neutral'>            }</span>
  9340 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9341 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9342 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9343 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9344 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9345 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9346 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9347 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,uint256)`.</span>
  9348 |     | <span class='neutral'>            mstore(0x00, 0x5da297eb)</span>
  9349 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9350 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9351 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9352 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9353 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9354 |     | <span class='neutral'>        }</span>
  9355 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9356 |     | <span class='neutral'>        assembly {</span>
  9357 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9358 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9359 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9360 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9361 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9362 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9363 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9364 |     | <span class='neutral'>        }</span>
  9365 |     | <span class='neutral'>    }</span>
  9366 |     | <span class='neutral'></span>
  9367 |     | <span class='neutral'>    function log(uint256 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
  9368 |     | <span class='neutral'>        bytes32 m0;</span>
  9369 |     | <span class='neutral'>        bytes32 m1;</span>
  9370 |     | <span class='neutral'>        bytes32 m2;</span>
  9371 |     | <span class='neutral'>        bytes32 m3;</span>
  9372 |     | <span class='neutral'>        bytes32 m4;</span>
  9373 |     | <span class='neutral'>        bytes32 m5;</span>
  9374 |     | <span class='neutral'>        bytes32 m6;</span>
  9375 |     | <span class='neutral'>        bytes32 m7;</span>
  9376 |     | <span class='neutral'>        bytes32 m8;</span>
  9377 |     | <span class='neutral'>        assembly {</span>
  9378 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9379 |     | <span class='neutral'>                let length := 0</span>
  9380 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9381 |     | <span class='neutral'>                mstore(pos, length)</span>
  9382 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9383 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9384 |     | <span class='neutral'>            }</span>
  9385 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9386 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9387 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9388 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9389 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9390 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9391 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9392 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9393 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9394 |     | <span class='neutral'>            // Selector of `log(uint256,uint256,string,string)`.</span>
  9395 |     | <span class='neutral'>            mstore(0x00, 0x27d8afd2)</span>
  9396 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9397 |     | <span class='neutral'>            mstore(0x40, p1)</span>
  9398 |     | <span class='neutral'>            mstore(0x60, 0x80)</span>
  9399 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9400 |     | <span class='neutral'>            writeString(0xa0, p2)</span>
  9401 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9402 |     | <span class='neutral'>        }</span>
  9403 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9404 |     | <span class='neutral'>        assembly {</span>
  9405 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9406 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9407 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9408 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9409 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9410 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9411 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9412 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9413 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9414 |     | <span class='neutral'>        }</span>
  9415 |     | <span class='neutral'>    }</span>
  9416 |     | <span class='neutral'></span>
  9417 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, address p3) internal pure {</span>
  9418 |     | <span class='neutral'>        bytes32 m0;</span>
  9419 |     | <span class='neutral'>        bytes32 m1;</span>
  9420 |     | <span class='neutral'>        bytes32 m2;</span>
  9421 |     | <span class='neutral'>        bytes32 m3;</span>
  9422 |     | <span class='neutral'>        bytes32 m4;</span>
  9423 |     | <span class='neutral'>        bytes32 m5;</span>
  9424 |     | <span class='neutral'>        bytes32 m6;</span>
  9425 |     | <span class='neutral'>        assembly {</span>
  9426 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9427 |     | <span class='neutral'>                let length := 0</span>
  9428 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9429 |     | <span class='neutral'>                mstore(pos, length)</span>
  9430 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9431 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9432 |     | <span class='neutral'>            }</span>
  9433 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9434 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9435 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9436 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9437 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9438 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9439 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9440 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,address)`.</span>
  9441 |     | <span class='neutral'>            mstore(0x00, 0x6168ed61)</span>
  9442 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9443 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9444 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9445 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9446 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9447 |     | <span class='neutral'>        }</span>
  9448 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9449 |     | <span class='neutral'>        assembly {</span>
  9450 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9451 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9452 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9453 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9454 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9455 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9456 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9457 |     | <span class='neutral'>        }</span>
  9458 |     | <span class='neutral'>    }</span>
  9459 |     | <span class='neutral'></span>
  9460 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
  9461 |     | <span class='neutral'>        bytes32 m0;</span>
  9462 |     | <span class='neutral'>        bytes32 m1;</span>
  9463 |     | <span class='neutral'>        bytes32 m2;</span>
  9464 |     | <span class='neutral'>        bytes32 m3;</span>
  9465 |     | <span class='neutral'>        bytes32 m4;</span>
  9466 |     | <span class='neutral'>        bytes32 m5;</span>
  9467 |     | <span class='neutral'>        bytes32 m6;</span>
  9468 |     | <span class='neutral'>        assembly {</span>
  9469 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9470 |     | <span class='neutral'>                let length := 0</span>
  9471 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9472 |     | <span class='neutral'>                mstore(pos, length)</span>
  9473 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9474 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9475 |     | <span class='neutral'>            }</span>
  9476 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9477 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9478 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9479 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9480 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9481 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9482 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9483 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,bool)`.</span>
  9484 |     | <span class='neutral'>            mstore(0x00, 0x90c30a56)</span>
  9485 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9486 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9487 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9488 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9489 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9490 |     | <span class='neutral'>        }</span>
  9491 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9492 |     | <span class='neutral'>        assembly {</span>
  9493 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9494 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9495 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9496 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9497 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9498 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9499 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9500 |     | <span class='neutral'>        }</span>
  9501 |     | <span class='neutral'>    }</span>
  9502 |     | <span class='neutral'></span>
  9503 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
  9504 |     | <span class='neutral'>        bytes32 m0;</span>
  9505 |     | <span class='neutral'>        bytes32 m1;</span>
  9506 |     | <span class='neutral'>        bytes32 m2;</span>
  9507 |     | <span class='neutral'>        bytes32 m3;</span>
  9508 |     | <span class='neutral'>        bytes32 m4;</span>
  9509 |     | <span class='neutral'>        bytes32 m5;</span>
  9510 |     | <span class='neutral'>        bytes32 m6;</span>
  9511 |     | <span class='neutral'>        assembly {</span>
  9512 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9513 |     | <span class='neutral'>                let length := 0</span>
  9514 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9515 |     | <span class='neutral'>                mstore(pos, length)</span>
  9516 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9517 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9518 |     | <span class='neutral'>            }</span>
  9519 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9520 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9521 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9522 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9523 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9524 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9525 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9526 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,uint256)`.</span>
  9527 |     | <span class='neutral'>            mstore(0x00, 0xe8d3018d)</span>
  9528 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9529 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9530 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9531 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9532 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9533 |     | <span class='neutral'>        }</span>
  9534 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9535 |     | <span class='neutral'>        assembly {</span>
  9536 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9537 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9538 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9539 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9540 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9541 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9542 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9543 |     | <span class='neutral'>        }</span>
  9544 |     | <span class='neutral'>    }</span>
  9545 |     | <span class='neutral'></span>
  9546 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
  9547 |     | <span class='neutral'>        bytes32 m0;</span>
  9548 |     | <span class='neutral'>        bytes32 m1;</span>
  9549 |     | <span class='neutral'>        bytes32 m2;</span>
  9550 |     | <span class='neutral'>        bytes32 m3;</span>
  9551 |     | <span class='neutral'>        bytes32 m4;</span>
  9552 |     | <span class='neutral'>        bytes32 m5;</span>
  9553 |     | <span class='neutral'>        bytes32 m6;</span>
  9554 |     | <span class='neutral'>        bytes32 m7;</span>
  9555 |     | <span class='neutral'>        bytes32 m8;</span>
  9556 |     | <span class='neutral'>        assembly {</span>
  9557 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9558 |     | <span class='neutral'>                let length := 0</span>
  9559 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9560 |     | <span class='neutral'>                mstore(pos, length)</span>
  9561 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9562 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9563 |     | <span class='neutral'>            }</span>
  9564 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9565 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9566 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9567 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9568 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9569 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9570 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9571 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9572 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9573 |     | <span class='neutral'>            // Selector of `log(uint256,string,address,string)`.</span>
  9574 |     | <span class='neutral'>            mstore(0x00, 0x9c3adfa1)</span>
  9575 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9576 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9577 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9578 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9579 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9580 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9581 |     | <span class='neutral'>        }</span>
  9582 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9583 |     | <span class='neutral'>        assembly {</span>
  9584 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9585 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9586 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9587 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9588 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9589 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9590 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9591 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9592 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9593 |     | <span class='neutral'>        }</span>
  9594 |     | <span class='neutral'>    }</span>
  9595 |     | <span class='neutral'></span>
  9596 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
  9597 |     | <span class='neutral'>        bytes32 m0;</span>
  9598 |     | <span class='neutral'>        bytes32 m1;</span>
  9599 |     | <span class='neutral'>        bytes32 m2;</span>
  9600 |     | <span class='neutral'>        bytes32 m3;</span>
  9601 |     | <span class='neutral'>        bytes32 m4;</span>
  9602 |     | <span class='neutral'>        bytes32 m5;</span>
  9603 |     | <span class='neutral'>        bytes32 m6;</span>
  9604 |     | <span class='neutral'>        assembly {</span>
  9605 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9606 |     | <span class='neutral'>                let length := 0</span>
  9607 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9608 |     | <span class='neutral'>                mstore(pos, length)</span>
  9609 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9610 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9611 |     | <span class='neutral'>            }</span>
  9612 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9613 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9614 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9615 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9616 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9617 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9618 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9619 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,address)`.</span>
  9620 |     | <span class='neutral'>            mstore(0x00, 0xae2ec581)</span>
  9621 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9622 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9623 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9624 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9625 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9626 |     | <span class='neutral'>        }</span>
  9627 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9628 |     | <span class='neutral'>        assembly {</span>
  9629 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9630 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9631 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9632 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9633 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9634 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9635 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9636 |     | <span class='neutral'>        }</span>
  9637 |     | <span class='neutral'>    }</span>
  9638 |     | <span class='neutral'></span>
  9639 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
  9640 |     | <span class='neutral'>        bytes32 m0;</span>
  9641 |     | <span class='neutral'>        bytes32 m1;</span>
  9642 |     | <span class='neutral'>        bytes32 m2;</span>
  9643 |     | <span class='neutral'>        bytes32 m3;</span>
  9644 |     | <span class='neutral'>        bytes32 m4;</span>
  9645 |     | <span class='neutral'>        bytes32 m5;</span>
  9646 |     | <span class='neutral'>        bytes32 m6;</span>
  9647 |     | <span class='neutral'>        assembly {</span>
  9648 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9649 |     | <span class='neutral'>                let length := 0</span>
  9650 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9651 |     | <span class='neutral'>                mstore(pos, length)</span>
  9652 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9653 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9654 |     | <span class='neutral'>            }</span>
  9655 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9656 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9657 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9658 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9659 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9660 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9661 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9662 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,bool)`.</span>
  9663 |     | <span class='neutral'>            mstore(0x00, 0xba535d9c)</span>
  9664 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9665 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9666 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9667 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9668 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9669 |     | <span class='neutral'>        }</span>
  9670 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9671 |     | <span class='neutral'>        assembly {</span>
  9672 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9673 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9674 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9675 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9676 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9677 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9678 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9679 |     | <span class='neutral'>        }</span>
  9680 |     | <span class='neutral'>    }</span>
  9681 |     | <span class='neutral'></span>
  9682 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
  9683 |     | <span class='neutral'>        bytes32 m0;</span>
  9684 |     | <span class='neutral'>        bytes32 m1;</span>
  9685 |     | <span class='neutral'>        bytes32 m2;</span>
  9686 |     | <span class='neutral'>        bytes32 m3;</span>
  9687 |     | <span class='neutral'>        bytes32 m4;</span>
  9688 |     | <span class='neutral'>        bytes32 m5;</span>
  9689 |     | <span class='neutral'>        bytes32 m6;</span>
  9690 |     | <span class='neutral'>        assembly {</span>
  9691 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9692 |     | <span class='neutral'>                let length := 0</span>
  9693 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9694 |     | <span class='neutral'>                mstore(pos, length)</span>
  9695 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9696 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9697 |     | <span class='neutral'>            }</span>
  9698 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9699 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9700 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9701 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9702 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9703 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9704 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9705 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,uint256)`.</span>
  9706 |     | <span class='neutral'>            mstore(0x00, 0xcf009880)</span>
  9707 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9708 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9709 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9710 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9711 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9712 |     | <span class='neutral'>        }</span>
  9713 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9714 |     | <span class='neutral'>        assembly {</span>
  9715 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9716 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9717 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9718 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9719 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9720 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9721 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9722 |     | <span class='neutral'>        }</span>
  9723 |     | <span class='neutral'>    }</span>
  9724 |     | <span class='neutral'></span>
  9725 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
  9726 |     | <span class='neutral'>        bytes32 m0;</span>
  9727 |     | <span class='neutral'>        bytes32 m1;</span>
  9728 |     | <span class='neutral'>        bytes32 m2;</span>
  9729 |     | <span class='neutral'>        bytes32 m3;</span>
  9730 |     | <span class='neutral'>        bytes32 m4;</span>
  9731 |     | <span class='neutral'>        bytes32 m5;</span>
  9732 |     | <span class='neutral'>        bytes32 m6;</span>
  9733 |     | <span class='neutral'>        bytes32 m7;</span>
  9734 |     | <span class='neutral'>        bytes32 m8;</span>
  9735 |     | <span class='neutral'>        assembly {</span>
  9736 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9737 |     | <span class='neutral'>                let length := 0</span>
  9738 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9739 |     | <span class='neutral'>                mstore(pos, length)</span>
  9740 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9741 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9742 |     | <span class='neutral'>            }</span>
  9743 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9744 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9745 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9746 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9747 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9748 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9749 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9750 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9751 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9752 |     | <span class='neutral'>            // Selector of `log(uint256,string,bool,string)`.</span>
  9753 |     | <span class='neutral'>            mstore(0x00, 0xd2d423cd)</span>
  9754 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9755 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9756 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9757 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9758 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9759 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9760 |     | <span class='neutral'>        }</span>
  9761 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9762 |     | <span class='neutral'>        assembly {</span>
  9763 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9764 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9765 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9766 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9767 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9768 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9769 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9770 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9771 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9772 |     | <span class='neutral'>        }</span>
  9773 |     | <span class='neutral'>    }</span>
  9774 |     | <span class='neutral'></span>
  9775 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
  9776 |     | <span class='neutral'>        bytes32 m0;</span>
  9777 |     | <span class='neutral'>        bytes32 m1;</span>
  9778 |     | <span class='neutral'>        bytes32 m2;</span>
  9779 |     | <span class='neutral'>        bytes32 m3;</span>
  9780 |     | <span class='neutral'>        bytes32 m4;</span>
  9781 |     | <span class='neutral'>        bytes32 m5;</span>
  9782 |     | <span class='neutral'>        bytes32 m6;</span>
  9783 |     | <span class='neutral'>        assembly {</span>
  9784 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9785 |     | <span class='neutral'>                let length := 0</span>
  9786 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9787 |     | <span class='neutral'>                mstore(pos, length)</span>
  9788 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9789 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9790 |     | <span class='neutral'>            }</span>
  9791 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9792 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9793 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9794 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9795 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9796 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9797 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9798 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,address)`.</span>
  9799 |     | <span class='neutral'>            mstore(0x00, 0x3b2279b4)</span>
  9800 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9801 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9802 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9803 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9804 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9805 |     | <span class='neutral'>        }</span>
  9806 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9807 |     | <span class='neutral'>        assembly {</span>
  9808 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9809 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9810 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9811 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9812 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9813 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9814 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9815 |     | <span class='neutral'>        }</span>
  9816 |     | <span class='neutral'>    }</span>
  9817 |     | <span class='neutral'></span>
  9818 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
  9819 |     | <span class='neutral'>        bytes32 m0;</span>
  9820 |     | <span class='neutral'>        bytes32 m1;</span>
  9821 |     | <span class='neutral'>        bytes32 m2;</span>
  9822 |     | <span class='neutral'>        bytes32 m3;</span>
  9823 |     | <span class='neutral'>        bytes32 m4;</span>
  9824 |     | <span class='neutral'>        bytes32 m5;</span>
  9825 |     | <span class='neutral'>        bytes32 m6;</span>
  9826 |     | <span class='neutral'>        assembly {</span>
  9827 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9828 |     | <span class='neutral'>                let length := 0</span>
  9829 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9830 |     | <span class='neutral'>                mstore(pos, length)</span>
  9831 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9832 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9833 |     | <span class='neutral'>            }</span>
  9834 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9835 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9836 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9837 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9838 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9839 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9840 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9841 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,bool)`.</span>
  9842 |     | <span class='neutral'>            mstore(0x00, 0x691a8f74)</span>
  9843 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9844 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9845 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9846 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9847 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9848 |     | <span class='neutral'>        }</span>
  9849 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9850 |     | <span class='neutral'>        assembly {</span>
  9851 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9852 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9853 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9854 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9855 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9856 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9857 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9858 |     | <span class='neutral'>        }</span>
  9859 |     | <span class='neutral'>    }</span>
  9860 |     | <span class='neutral'></span>
  9861 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
  9862 |     | <span class='neutral'>        bytes32 m0;</span>
  9863 |     | <span class='neutral'>        bytes32 m1;</span>
  9864 |     | <span class='neutral'>        bytes32 m2;</span>
  9865 |     | <span class='neutral'>        bytes32 m3;</span>
  9866 |     | <span class='neutral'>        bytes32 m4;</span>
  9867 |     | <span class='neutral'>        bytes32 m5;</span>
  9868 |     | <span class='neutral'>        bytes32 m6;</span>
  9869 |     | <span class='neutral'>        assembly {</span>
  9870 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9871 |     | <span class='neutral'>                let length := 0</span>
  9872 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9873 |     | <span class='neutral'>                mstore(pos, length)</span>
  9874 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9875 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9876 |     | <span class='neutral'>            }</span>
  9877 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9878 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9879 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9880 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9881 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9882 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9883 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9884 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,uint256)`.</span>
  9885 |     | <span class='neutral'>            mstore(0x00, 0x82c25b74)</span>
  9886 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9887 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9890 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9891 |     | <span class='neutral'>        }</span>
  9892 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
  9893 |     | <span class='neutral'>        assembly {</span>
  9894 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9895 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9896 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9897 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9898 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9899 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9900 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9901 |     | <span class='neutral'>        }</span>
  9902 |     | <span class='neutral'>    }</span>
  9903 |     | <span class='neutral'></span>
  9904 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
  9905 |     | <span class='neutral'>        bytes32 m0;</span>
  9906 |     | <span class='neutral'>        bytes32 m1;</span>
  9907 |     | <span class='neutral'>        bytes32 m2;</span>
  9908 |     | <span class='neutral'>        bytes32 m3;</span>
  9909 |     | <span class='neutral'>        bytes32 m4;</span>
  9910 |     | <span class='neutral'>        bytes32 m5;</span>
  9911 |     | <span class='neutral'>        bytes32 m6;</span>
  9912 |     | <span class='neutral'>        bytes32 m7;</span>
  9913 |     | <span class='neutral'>        bytes32 m8;</span>
  9914 |     | <span class='neutral'>        assembly {</span>
  9915 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9916 |     | <span class='neutral'>                let length := 0</span>
  9917 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9918 |     | <span class='neutral'>                mstore(pos, length)</span>
  9919 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9920 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9921 |     | <span class='neutral'>            }</span>
  9922 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9923 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9924 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9925 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9926 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9927 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9928 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9929 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9930 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9931 |     | <span class='neutral'>            // Selector of `log(uint256,string,uint256,string)`.</span>
  9932 |     | <span class='neutral'>            mstore(0x00, 0xb7b914ca)</span>
  9933 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9934 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9935 |     | <span class='neutral'>            mstore(0x60, p2)</span>
  9936 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
  9937 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9938 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
  9939 |     | <span class='neutral'>        }</span>
  9940 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9941 |     | <span class='neutral'>        assembly {</span>
  9942 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9943 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9944 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9945 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9946 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9947 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9948 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9949 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
  9950 |     | <span class='neutral'>            mstore(0x100, m8)</span>
  9951 |     | <span class='neutral'>        }</span>
  9952 |     | <span class='neutral'>    }</span>
  9953 |     | <span class='neutral'></span>
  9954 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
  9955 |     | <span class='neutral'>        bytes32 m0;</span>
  9956 |     | <span class='neutral'>        bytes32 m1;</span>
  9957 |     | <span class='neutral'>        bytes32 m2;</span>
  9958 |     | <span class='neutral'>        bytes32 m3;</span>
  9959 |     | <span class='neutral'>        bytes32 m4;</span>
  9960 |     | <span class='neutral'>        bytes32 m5;</span>
  9961 |     | <span class='neutral'>        bytes32 m6;</span>
  9962 |     | <span class='neutral'>        bytes32 m7;</span>
  9963 |     | <span class='neutral'>        bytes32 m8;</span>
  9964 |     | <span class='neutral'>        assembly {</span>
  9965 |     | <span class='neutral'>            function writeString(pos, w) {</span>
  9966 |     | <span class='neutral'>                let length := 0</span>
  9967 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
  9968 |     | <span class='neutral'>                mstore(pos, length)</span>
  9969 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
  9970 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
  9971 |     | <span class='neutral'>            }</span>
  9972 |     | <span class='neutral'>            m0 := mload(0x00)</span>
  9973 |     | <span class='neutral'>            m1 := mload(0x20)</span>
  9974 |     | <span class='neutral'>            m2 := mload(0x40)</span>
  9975 |     | <span class='neutral'>            m3 := mload(0x60)</span>
  9976 |     | <span class='neutral'>            m4 := mload(0x80)</span>
  9977 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
  9978 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
  9979 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
  9980 |     | <span class='neutral'>            m8 := mload(0x100)</span>
  9981 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,address)`.</span>
  9982 |     | <span class='neutral'>            mstore(0x00, 0xd583c602)</span>
  9983 |     | <span class='neutral'>            mstore(0x20, p0)</span>
  9984 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
  9985 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
  9986 |     | <span class='neutral'>            mstore(0x80, p3)</span>
  9987 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
  9988 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
  9989 |     | <span class='neutral'>        }</span>
  9990 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
  9991 |     | <span class='neutral'>        assembly {</span>
  9992 |     | <span class='neutral'>            mstore(0x00, m0)</span>
  9993 |     | <span class='neutral'>            mstore(0x20, m1)</span>
  9994 |     | <span class='neutral'>            mstore(0x40, m2)</span>
  9995 |     | <span class='neutral'>            mstore(0x60, m3)</span>
  9996 |     | <span class='neutral'>            mstore(0x80, m4)</span>
  9997 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
  9998 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
  9999 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10000 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10001 |     | <span class='neutral'>        }</span>
 10002 |     | <span class='neutral'>    }</span>
 10003 |     | <span class='neutral'></span>
 10004 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 10005 |     | <span class='neutral'>        bytes32 m0;</span>
 10006 |     | <span class='neutral'>        bytes32 m1;</span>
 10007 |     | <span class='neutral'>        bytes32 m2;</span>
 10008 |     | <span class='neutral'>        bytes32 m3;</span>
 10009 |     | <span class='neutral'>        bytes32 m4;</span>
 10010 |     | <span class='neutral'>        bytes32 m5;</span>
 10011 |     | <span class='neutral'>        bytes32 m6;</span>
 10012 |     | <span class='neutral'>        bytes32 m7;</span>
 10013 |     | <span class='neutral'>        bytes32 m8;</span>
 10014 |     | <span class='neutral'>        assembly {</span>
 10015 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10016 |     | <span class='neutral'>                let length := 0</span>
 10017 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10018 |     | <span class='neutral'>                mstore(pos, length)</span>
 10019 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10020 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10021 |     | <span class='neutral'>            }</span>
 10022 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10023 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10024 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10025 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10026 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10027 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10028 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10029 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10030 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10031 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,bool)`.</span>
 10032 |     | <span class='neutral'>            mstore(0x00, 0xb3a6b6bd)</span>
 10033 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10034 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10035 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10036 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10037 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10038 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10039 |     | <span class='neutral'>        }</span>
 10040 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10041 |     | <span class='neutral'>        assembly {</span>
 10042 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10043 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10044 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10045 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10046 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10047 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10048 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10049 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10050 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10051 |     | <span class='neutral'>        }</span>
 10052 |     | <span class='neutral'>    }</span>
 10053 |     | <span class='neutral'></span>
 10054 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 10055 |     | <span class='neutral'>        bytes32 m0;</span>
 10056 |     | <span class='neutral'>        bytes32 m1;</span>
 10057 |     | <span class='neutral'>        bytes32 m2;</span>
 10058 |     | <span class='neutral'>        bytes32 m3;</span>
 10059 |     | <span class='neutral'>        bytes32 m4;</span>
 10060 |     | <span class='neutral'>        bytes32 m5;</span>
 10061 |     | <span class='neutral'>        bytes32 m6;</span>
 10062 |     | <span class='neutral'>        bytes32 m7;</span>
 10063 |     | <span class='neutral'>        bytes32 m8;</span>
 10064 |     | <span class='neutral'>        assembly {</span>
 10065 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10066 |     | <span class='neutral'>                let length := 0</span>
 10067 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10068 |     | <span class='neutral'>                mstore(pos, length)</span>
 10069 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10070 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10071 |     | <span class='neutral'>            }</span>
 10072 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10073 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10074 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10075 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10076 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10077 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10078 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10079 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10080 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10081 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,uint256)`.</span>
 10082 |     | <span class='neutral'>            mstore(0x00, 0xb028c9bd)</span>
 10083 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10084 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10085 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10086 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10087 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10088 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10089 |     | <span class='neutral'>        }</span>
 10090 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10091 |     | <span class='neutral'>        assembly {</span>
 10092 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10093 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10094 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10095 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10096 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10097 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10098 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10099 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10100 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10101 |     | <span class='neutral'>        }</span>
 10102 |     | <span class='neutral'>    }</span>
 10103 |     | <span class='neutral'></span>
 10104 |     | <span class='neutral'>    function log(uint256 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10105 |     | <span class='neutral'>        bytes32 m0;</span>
 10106 |     | <span class='neutral'>        bytes32 m1;</span>
 10107 |     | <span class='neutral'>        bytes32 m2;</span>
 10108 |     | <span class='neutral'>        bytes32 m3;</span>
 10109 |     | <span class='neutral'>        bytes32 m4;</span>
 10110 |     | <span class='neutral'>        bytes32 m5;</span>
 10111 |     | <span class='neutral'>        bytes32 m6;</span>
 10112 |     | <span class='neutral'>        bytes32 m7;</span>
 10113 |     | <span class='neutral'>        bytes32 m8;</span>
 10114 |     | <span class='neutral'>        bytes32 m9;</span>
 10115 |     | <span class='neutral'>        bytes32 m10;</span>
 10116 |     | <span class='neutral'>        assembly {</span>
 10117 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10118 |     | <span class='neutral'>                let length := 0</span>
 10119 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10120 |     | <span class='neutral'>                mstore(pos, length)</span>
 10121 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10122 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10123 |     | <span class='neutral'>            }</span>
 10124 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10125 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10126 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10127 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10128 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10129 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10130 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10131 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10132 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10133 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10134 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10135 |     | <span class='neutral'>            // Selector of `log(uint256,string,string,string)`.</span>
 10136 |     | <span class='neutral'>            mstore(0x00, 0x21ad0683)</span>
 10137 |     | <span class='neutral'>            mstore(0x20, p0)</span>
 10138 |     | <span class='neutral'>            mstore(0x40, 0x80)</span>
 10139 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10140 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10141 |     | <span class='neutral'>            writeString(0xa0, p1)</span>
 10142 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10143 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10144 |     | <span class='neutral'>        }</span>
 10145 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10146 |     | <span class='neutral'>        assembly {</span>
 10147 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10148 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10149 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10150 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10151 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10152 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10153 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10154 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10155 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10156 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10157 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10158 |     | <span class='neutral'>        }</span>
 10159 |     | <span class='neutral'>    }</span>
 10160 |     | <span class='neutral'></span>
 10161 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, address p3) internal pure {</span>
 10162 |     | <span class='neutral'>        bytes32 m0;</span>
 10163 |     | <span class='neutral'>        bytes32 m1;</span>
 10164 |     | <span class='neutral'>        bytes32 m2;</span>
 10165 |     | <span class='neutral'>        bytes32 m3;</span>
 10166 |     | <span class='neutral'>        bytes32 m4;</span>
 10167 |     | <span class='neutral'>        bytes32 m5;</span>
 10168 |     | <span class='neutral'>        bytes32 m6;</span>
 10169 |     | <span class='neutral'>        assembly {</span>
 10170 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10171 |     | <span class='neutral'>                let length := 0</span>
 10172 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10173 |     | <span class='neutral'>                mstore(pos, length)</span>
 10174 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10175 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10176 |     | <span class='neutral'>            }</span>
 10177 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10178 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10179 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10180 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10181 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10182 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10183 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10184 |     | <span class='neutral'>            // Selector of `log(string,address,address,address)`.</span>
 10185 |     | <span class='neutral'>            mstore(0x00, 0xed8f28f6)</span>
 10186 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10187 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10188 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10189 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10190 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10191 |     | <span class='neutral'>        }</span>
 10192 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10193 |     | <span class='neutral'>        assembly {</span>
 10194 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10195 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10196 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10197 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10198 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10199 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10200 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10201 |     | <span class='neutral'>        }</span>
 10202 |     | <span class='neutral'>    }</span>
 10203 |     | <span class='neutral'></span>
 10204 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bool p3) internal pure {</span>
 10205 |     | <span class='neutral'>        bytes32 m0;</span>
 10206 |     | <span class='neutral'>        bytes32 m1;</span>
 10207 |     | <span class='neutral'>        bytes32 m2;</span>
 10208 |     | <span class='neutral'>        bytes32 m3;</span>
 10209 |     | <span class='neutral'>        bytes32 m4;</span>
 10210 |     | <span class='neutral'>        bytes32 m5;</span>
 10211 |     | <span class='neutral'>        bytes32 m6;</span>
 10212 |     | <span class='neutral'>        assembly {</span>
 10213 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10214 |     | <span class='neutral'>                let length := 0</span>
 10215 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10216 |     | <span class='neutral'>                mstore(pos, length)</span>
 10217 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10218 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10219 |     | <span class='neutral'>            }</span>
 10220 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10221 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10222 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10223 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10224 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10225 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10226 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10227 |     | <span class='neutral'>            // Selector of `log(string,address,address,bool)`.</span>
 10228 |     | <span class='neutral'>            mstore(0x00, 0xb59dbd60)</span>
 10229 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10230 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10231 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10232 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10233 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10234 |     | <span class='neutral'>        }</span>
 10235 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10236 |     | <span class='neutral'>        assembly {</span>
 10237 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10238 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10239 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10240 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10241 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10242 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10243 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10244 |     | <span class='neutral'>        }</span>
 10245 |     | <span class='neutral'>    }</span>
 10246 |     | <span class='neutral'></span>
 10247 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, uint256 p3) internal pure {</span>
 10248 |     | <span class='neutral'>        bytes32 m0;</span>
 10249 |     | <span class='neutral'>        bytes32 m1;</span>
 10250 |     | <span class='neutral'>        bytes32 m2;</span>
 10251 |     | <span class='neutral'>        bytes32 m3;</span>
 10252 |     | <span class='neutral'>        bytes32 m4;</span>
 10253 |     | <span class='neutral'>        bytes32 m5;</span>
 10254 |     | <span class='neutral'>        bytes32 m6;</span>
 10255 |     | <span class='neutral'>        assembly {</span>
 10256 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10257 |     | <span class='neutral'>                let length := 0</span>
 10258 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10259 |     | <span class='neutral'>                mstore(pos, length)</span>
 10260 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10261 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10262 |     | <span class='neutral'>            }</span>
 10263 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10264 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10265 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10266 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10267 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10268 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10269 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10270 |     | <span class='neutral'>            // Selector of `log(string,address,address,uint256)`.</span>
 10271 |     | <span class='neutral'>            mstore(0x00, 0x8ef3f399)</span>
 10272 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10273 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10274 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10275 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10276 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10277 |     | <span class='neutral'>        }</span>
 10278 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10279 |     | <span class='neutral'>        assembly {</span>
 10280 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10281 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10282 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10283 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10284 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10285 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10286 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10287 |     | <span class='neutral'>        }</span>
 10288 |     | <span class='neutral'>    }</span>
 10289 |     | <span class='neutral'></span>
 10290 |     | <span class='neutral'>    function log(bytes32 p0, address p1, address p2, bytes32 p3) internal pure {</span>
 10291 |     | <span class='neutral'>        bytes32 m0;</span>
 10292 |     | <span class='neutral'>        bytes32 m1;</span>
 10293 |     | <span class='neutral'>        bytes32 m2;</span>
 10294 |     | <span class='neutral'>        bytes32 m3;</span>
 10295 |     | <span class='neutral'>        bytes32 m4;</span>
 10296 |     | <span class='neutral'>        bytes32 m5;</span>
 10297 |     | <span class='neutral'>        bytes32 m6;</span>
 10298 |     | <span class='neutral'>        bytes32 m7;</span>
 10299 |     | <span class='neutral'>        bytes32 m8;</span>
 10300 |     | <span class='neutral'>        assembly {</span>
 10301 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10302 |     | <span class='neutral'>                let length := 0</span>
 10303 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10304 |     | <span class='neutral'>                mstore(pos, length)</span>
 10305 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10306 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10307 |     | <span class='neutral'>            }</span>
 10308 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10309 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10310 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10311 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10312 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10313 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10314 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10315 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10316 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10317 |     | <span class='neutral'>            // Selector of `log(string,address,address,string)`.</span>
 10318 |     | <span class='neutral'>            mstore(0x00, 0x800a1c67)</span>
 10319 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10320 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10321 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10322 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10323 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10324 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10325 |     | <span class='neutral'>        }</span>
 10326 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10327 |     | <span class='neutral'>        assembly {</span>
 10328 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10329 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10330 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10331 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10332 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10333 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10334 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10335 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10336 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10337 |     | <span class='neutral'>        }</span>
 10338 |     | <span class='neutral'>    }</span>
 10339 |     | <span class='neutral'></span>
 10340 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, address p3) internal pure {</span>
 10341 |     | <span class='neutral'>        bytes32 m0;</span>
 10342 |     | <span class='neutral'>        bytes32 m1;</span>
 10343 |     | <span class='neutral'>        bytes32 m2;</span>
 10344 |     | <span class='neutral'>        bytes32 m3;</span>
 10345 |     | <span class='neutral'>        bytes32 m4;</span>
 10346 |     | <span class='neutral'>        bytes32 m5;</span>
 10347 |     | <span class='neutral'>        bytes32 m6;</span>
 10348 |     | <span class='neutral'>        assembly {</span>
 10349 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10350 |     | <span class='neutral'>                let length := 0</span>
 10351 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10352 |     | <span class='neutral'>                mstore(pos, length)</span>
 10353 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10354 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10355 |     | <span class='neutral'>            }</span>
 10356 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10357 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10358 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10359 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10360 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10361 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10362 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10363 |     | <span class='neutral'>            // Selector of `log(string,address,bool,address)`.</span>
 10364 |     | <span class='neutral'>            mstore(0x00, 0x223603bd)</span>
 10365 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10366 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10367 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10368 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10369 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10370 |     | <span class='neutral'>        }</span>
 10371 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10372 |     | <span class='neutral'>        assembly {</span>
 10373 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10374 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10375 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10376 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10377 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10378 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10379 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10380 |     | <span class='neutral'>        }</span>
 10381 |     | <span class='neutral'>    }</span>
 10382 |     | <span class='neutral'></span>
 10383 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bool p3) internal pure {</span>
 10384 |     | <span class='neutral'>        bytes32 m0;</span>
 10385 |     | <span class='neutral'>        bytes32 m1;</span>
 10386 |     | <span class='neutral'>        bytes32 m2;</span>
 10387 |     | <span class='neutral'>        bytes32 m3;</span>
 10388 |     | <span class='neutral'>        bytes32 m4;</span>
 10389 |     | <span class='neutral'>        bytes32 m5;</span>
 10390 |     | <span class='neutral'>        bytes32 m6;</span>
 10391 |     | <span class='neutral'>        assembly {</span>
 10392 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10393 |     | <span class='neutral'>                let length := 0</span>
 10394 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10395 |     | <span class='neutral'>                mstore(pos, length)</span>
 10396 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10397 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10398 |     | <span class='neutral'>            }</span>
 10399 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10400 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10401 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10402 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10403 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10404 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10405 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10406 |     | <span class='neutral'>            // Selector of `log(string,address,bool,bool)`.</span>
 10407 |     | <span class='neutral'>            mstore(0x00, 0x79884c2b)</span>
 10408 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10409 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10410 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10411 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10412 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10413 |     | <span class='neutral'>        }</span>
 10414 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10415 |     | <span class='neutral'>        assembly {</span>
 10416 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10417 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10418 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10419 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10420 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10421 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10422 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10423 |     | <span class='neutral'>        }</span>
 10424 |     | <span class='neutral'>    }</span>
 10425 |     | <span class='neutral'></span>
 10426 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, uint256 p3) internal pure {</span>
 10427 |     | <span class='neutral'>        bytes32 m0;</span>
 10428 |     | <span class='neutral'>        bytes32 m1;</span>
 10429 |     | <span class='neutral'>        bytes32 m2;</span>
 10430 |     | <span class='neutral'>        bytes32 m3;</span>
 10431 |     | <span class='neutral'>        bytes32 m4;</span>
 10432 |     | <span class='neutral'>        bytes32 m5;</span>
 10433 |     | <span class='neutral'>        bytes32 m6;</span>
 10434 |     | <span class='neutral'>        assembly {</span>
 10435 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10436 |     | <span class='neutral'>                let length := 0</span>
 10437 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10438 |     | <span class='neutral'>                mstore(pos, length)</span>
 10439 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10440 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10441 |     | <span class='neutral'>            }</span>
 10442 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10443 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10444 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10445 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10446 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10447 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10448 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10449 |     | <span class='neutral'>            // Selector of `log(string,address,bool,uint256)`.</span>
 10450 |     | <span class='neutral'>            mstore(0x00, 0x3e9f866a)</span>
 10451 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10452 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10453 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10454 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10455 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10456 |     | <span class='neutral'>        }</span>
 10457 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10458 |     | <span class='neutral'>        assembly {</span>
 10459 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10460 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10461 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10462 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10463 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10464 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10465 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10466 |     | <span class='neutral'>        }</span>
 10467 |     | <span class='neutral'>    }</span>
 10468 |     | <span class='neutral'></span>
 10469 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bool p2, bytes32 p3) internal pure {</span>
 10470 |     | <span class='neutral'>        bytes32 m0;</span>
 10471 |     | <span class='neutral'>        bytes32 m1;</span>
 10472 |     | <span class='neutral'>        bytes32 m2;</span>
 10473 |     | <span class='neutral'>        bytes32 m3;</span>
 10474 |     | <span class='neutral'>        bytes32 m4;</span>
 10475 |     | <span class='neutral'>        bytes32 m5;</span>
 10476 |     | <span class='neutral'>        bytes32 m6;</span>
 10477 |     | <span class='neutral'>        bytes32 m7;</span>
 10478 |     | <span class='neutral'>        bytes32 m8;</span>
 10479 |     | <span class='neutral'>        assembly {</span>
 10480 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10481 |     | <span class='neutral'>                let length := 0</span>
 10482 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10483 |     | <span class='neutral'>                mstore(pos, length)</span>
 10484 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10485 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10486 |     | <span class='neutral'>            }</span>
 10487 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10488 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10489 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10490 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10491 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10492 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10493 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10494 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10495 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10496 |     | <span class='neutral'>            // Selector of `log(string,address,bool,string)`.</span>
 10497 |     | <span class='neutral'>            mstore(0x00, 0x0454c079)</span>
 10498 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10499 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10500 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10501 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10502 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10503 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10504 |     | <span class='neutral'>        }</span>
 10505 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10506 |     | <span class='neutral'>        assembly {</span>
 10507 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10508 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10509 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10510 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10511 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10512 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10513 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10514 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10515 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10516 |     | <span class='neutral'>        }</span>
 10517 |     | <span class='neutral'>    }</span>
 10518 |     | <span class='neutral'></span>
 10519 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, address p3) internal pure {</span>
 10520 |     | <span class='neutral'>        bytes32 m0;</span>
 10521 |     | <span class='neutral'>        bytes32 m1;</span>
 10522 |     | <span class='neutral'>        bytes32 m2;</span>
 10523 |     | <span class='neutral'>        bytes32 m3;</span>
 10524 |     | <span class='neutral'>        bytes32 m4;</span>
 10525 |     | <span class='neutral'>        bytes32 m5;</span>
 10526 |     | <span class='neutral'>        bytes32 m6;</span>
 10527 |     | <span class='neutral'>        assembly {</span>
 10528 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10529 |     | <span class='neutral'>                let length := 0</span>
 10530 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10531 |     | <span class='neutral'>                mstore(pos, length)</span>
 10532 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10533 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10534 |     | <span class='neutral'>            }</span>
 10535 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10536 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10537 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10538 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10539 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10540 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10541 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10542 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,address)`.</span>
 10543 |     | <span class='neutral'>            mstore(0x00, 0x63fb8bc5)</span>
 10544 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10545 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10546 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10547 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10548 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10549 |     | <span class='neutral'>        }</span>
 10550 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10551 |     | <span class='neutral'>        assembly {</span>
 10552 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10553 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10554 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10555 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10556 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10557 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10558 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10559 |     | <span class='neutral'>        }</span>
 10560 |     | <span class='neutral'>    }</span>
 10561 |     | <span class='neutral'></span>
 10562 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bool p3) internal pure {</span>
 10563 |     | <span class='neutral'>        bytes32 m0;</span>
 10564 |     | <span class='neutral'>        bytes32 m1;</span>
 10565 |     | <span class='neutral'>        bytes32 m2;</span>
 10566 |     | <span class='neutral'>        bytes32 m3;</span>
 10567 |     | <span class='neutral'>        bytes32 m4;</span>
 10568 |     | <span class='neutral'>        bytes32 m5;</span>
 10569 |     | <span class='neutral'>        bytes32 m6;</span>
 10570 |     | <span class='neutral'>        assembly {</span>
 10571 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10572 |     | <span class='neutral'>                let length := 0</span>
 10573 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10574 |     | <span class='neutral'>                mstore(pos, length)</span>
 10575 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10576 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10577 |     | <span class='neutral'>            }</span>
 10578 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10579 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10580 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10581 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10582 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10583 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10584 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10585 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,bool)`.</span>
 10586 |     | <span class='neutral'>            mstore(0x00, 0xfc4845f0)</span>
 10587 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10588 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10589 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10590 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10591 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10592 |     | <span class='neutral'>        }</span>
 10593 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10594 |     | <span class='neutral'>        assembly {</span>
 10595 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10596 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10597 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10598 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10599 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10600 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10601 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10602 |     | <span class='neutral'>        }</span>
 10603 |     | <span class='neutral'>    }</span>
 10604 |     | <span class='neutral'></span>
 10605 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, uint256 p3) internal pure {</span>
 10606 |     | <span class='neutral'>        bytes32 m0;</span>
 10607 |     | <span class='neutral'>        bytes32 m1;</span>
 10608 |     | <span class='neutral'>        bytes32 m2;</span>
 10609 |     | <span class='neutral'>        bytes32 m3;</span>
 10610 |     | <span class='neutral'>        bytes32 m4;</span>
 10611 |     | <span class='neutral'>        bytes32 m5;</span>
 10612 |     | <span class='neutral'>        bytes32 m6;</span>
 10613 |     | <span class='neutral'>        assembly {</span>
 10614 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10615 |     | <span class='neutral'>                let length := 0</span>
 10616 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10617 |     | <span class='neutral'>                mstore(pos, length)</span>
 10618 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10619 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10620 |     | <span class='neutral'>            }</span>
 10621 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10622 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10623 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10624 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10625 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10626 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10627 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10628 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,uint256)`.</span>
 10629 |     | <span class='neutral'>            mstore(0x00, 0xf8f51b1e)</span>
 10630 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10631 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10632 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10633 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10634 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10635 |     | <span class='neutral'>        }</span>
 10636 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10637 |     | <span class='neutral'>        assembly {</span>
 10638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10644 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10645 |     | <span class='neutral'>        }</span>
 10646 |     | <span class='neutral'>    }</span>
 10647 |     | <span class='neutral'></span>
 10648 |     | <span class='neutral'>    function log(bytes32 p0, address p1, uint256 p2, bytes32 p3) internal pure {</span>
 10649 |     | <span class='neutral'>        bytes32 m0;</span>
 10650 |     | <span class='neutral'>        bytes32 m1;</span>
 10651 |     | <span class='neutral'>        bytes32 m2;</span>
 10652 |     | <span class='neutral'>        bytes32 m3;</span>
 10653 |     | <span class='neutral'>        bytes32 m4;</span>
 10654 |     | <span class='neutral'>        bytes32 m5;</span>
 10655 |     | <span class='neutral'>        bytes32 m6;</span>
 10656 |     | <span class='neutral'>        bytes32 m7;</span>
 10657 |     | <span class='neutral'>        bytes32 m8;</span>
 10658 |     | <span class='neutral'>        assembly {</span>
 10659 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10660 |     | <span class='neutral'>                let length := 0</span>
 10661 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10662 |     | <span class='neutral'>                mstore(pos, length)</span>
 10663 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10664 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10665 |     | <span class='neutral'>            }</span>
 10666 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10667 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10668 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10669 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10670 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10671 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10672 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10673 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10674 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10675 |     | <span class='neutral'>            // Selector of `log(string,address,uint256,string)`.</span>
 10676 |     | <span class='neutral'>            mstore(0x00, 0x5a477632)</span>
 10677 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10678 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10679 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10680 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 10681 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10682 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 10683 |     | <span class='neutral'>        }</span>
 10684 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10685 |     | <span class='neutral'>        assembly {</span>
 10686 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10687 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10688 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10689 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10690 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10691 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10692 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10693 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10694 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10695 |     | <span class='neutral'>        }</span>
 10696 |     | <span class='neutral'>    }</span>
 10697 |     | <span class='neutral'></span>
 10698 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, address p3) internal pure {</span>
 10699 |     | <span class='neutral'>        bytes32 m0;</span>
 10700 |     | <span class='neutral'>        bytes32 m1;</span>
 10701 |     | <span class='neutral'>        bytes32 m2;</span>
 10702 |     | <span class='neutral'>        bytes32 m3;</span>
 10703 |     | <span class='neutral'>        bytes32 m4;</span>
 10704 |     | <span class='neutral'>        bytes32 m5;</span>
 10705 |     | <span class='neutral'>        bytes32 m6;</span>
 10706 |     | <span class='neutral'>        bytes32 m7;</span>
 10707 |     | <span class='neutral'>        bytes32 m8;</span>
 10708 |     | <span class='neutral'>        assembly {</span>
 10709 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10710 |     | <span class='neutral'>                let length := 0</span>
 10711 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10712 |     | <span class='neutral'>                mstore(pos, length)</span>
 10713 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10714 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10715 |     | <span class='neutral'>            }</span>
 10716 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10717 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10718 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10719 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10720 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10721 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10722 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10723 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10724 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10725 |     | <span class='neutral'>            // Selector of `log(string,address,string,address)`.</span>
 10726 |     | <span class='neutral'>            mstore(0x00, 0xaabc9a31)</span>
 10727 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10728 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10729 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10730 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10731 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10732 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10733 |     | <span class='neutral'>        }</span>
 10734 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10735 |     | <span class='neutral'>        assembly {</span>
 10736 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10737 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10738 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10739 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10740 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10741 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10742 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10743 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10744 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10745 |     | <span class='neutral'>        }</span>
 10746 |     | <span class='neutral'>    }</span>
 10747 |     | <span class='neutral'></span>
 10748 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bool p3) internal pure {</span>
 10749 |     | <span class='neutral'>        bytes32 m0;</span>
 10750 |     | <span class='neutral'>        bytes32 m1;</span>
 10751 |     | <span class='neutral'>        bytes32 m2;</span>
 10752 |     | <span class='neutral'>        bytes32 m3;</span>
 10753 |     | <span class='neutral'>        bytes32 m4;</span>
 10754 |     | <span class='neutral'>        bytes32 m5;</span>
 10755 |     | <span class='neutral'>        bytes32 m6;</span>
 10756 |     | <span class='neutral'>        bytes32 m7;</span>
 10757 |     | <span class='neutral'>        bytes32 m8;</span>
 10758 |     | <span class='neutral'>        assembly {</span>
 10759 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10760 |     | <span class='neutral'>                let length := 0</span>
 10761 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10762 |     | <span class='neutral'>                mstore(pos, length)</span>
 10763 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10764 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10765 |     | <span class='neutral'>            }</span>
 10766 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10767 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10768 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10769 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10770 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10771 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10772 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10773 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10774 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10775 |     | <span class='neutral'>            // Selector of `log(string,address,string,bool)`.</span>
 10776 |     | <span class='neutral'>            mstore(0x00, 0x5f15d28c)</span>
 10777 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10778 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10779 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10780 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10781 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10782 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10783 |     | <span class='neutral'>        }</span>
 10784 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10785 |     | <span class='neutral'>        assembly {</span>
 10786 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10787 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10788 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10789 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10790 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10791 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10792 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10793 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10794 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10795 |     | <span class='neutral'>        }</span>
 10796 |     | <span class='neutral'>    }</span>
 10797 |     | <span class='neutral'></span>
 10798 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, uint256 p3) internal pure {</span>
 10799 |     | <span class='neutral'>        bytes32 m0;</span>
 10800 |     | <span class='neutral'>        bytes32 m1;</span>
 10801 |     | <span class='neutral'>        bytes32 m2;</span>
 10802 |     | <span class='neutral'>        bytes32 m3;</span>
 10803 |     | <span class='neutral'>        bytes32 m4;</span>
 10804 |     | <span class='neutral'>        bytes32 m5;</span>
 10805 |     | <span class='neutral'>        bytes32 m6;</span>
 10806 |     | <span class='neutral'>        bytes32 m7;</span>
 10807 |     | <span class='neutral'>        bytes32 m8;</span>
 10808 |     | <span class='neutral'>        assembly {</span>
 10809 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10810 |     | <span class='neutral'>                let length := 0</span>
 10811 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10812 |     | <span class='neutral'>                mstore(pos, length)</span>
 10813 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10814 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10815 |     | <span class='neutral'>            }</span>
 10816 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10817 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10818 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10819 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10820 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10821 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10822 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10823 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10824 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10825 |     | <span class='neutral'>            // Selector of `log(string,address,string,uint256)`.</span>
 10826 |     | <span class='neutral'>            mstore(0x00, 0x91d1112e)</span>
 10827 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10828 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10829 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10830 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10831 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10832 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10833 |     | <span class='neutral'>        }</span>
 10834 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 10835 |     | <span class='neutral'>        assembly {</span>
 10836 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10837 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10838 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10839 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10840 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10841 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10842 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10843 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10844 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10845 |     | <span class='neutral'>        }</span>
 10846 |     | <span class='neutral'>    }</span>
 10847 |     | <span class='neutral'></span>
 10848 |     | <span class='neutral'>    function log(bytes32 p0, address p1, bytes32 p2, bytes32 p3) internal pure {</span>
 10849 |     | <span class='neutral'>        bytes32 m0;</span>
 10850 |     | <span class='neutral'>        bytes32 m1;</span>
 10851 |     | <span class='neutral'>        bytes32 m2;</span>
 10852 |     | <span class='neutral'>        bytes32 m3;</span>
 10853 |     | <span class='neutral'>        bytes32 m4;</span>
 10854 |     | <span class='neutral'>        bytes32 m5;</span>
 10855 |     | <span class='neutral'>        bytes32 m6;</span>
 10856 |     | <span class='neutral'>        bytes32 m7;</span>
 10857 |     | <span class='neutral'>        bytes32 m8;</span>
 10858 |     | <span class='neutral'>        bytes32 m9;</span>
 10859 |     | <span class='neutral'>        bytes32 m10;</span>
 10860 |     | <span class='neutral'>        assembly {</span>
 10861 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10862 |     | <span class='neutral'>                let length := 0</span>
 10863 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10864 |     | <span class='neutral'>                mstore(pos, length)</span>
 10865 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10866 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10867 |     | <span class='neutral'>            }</span>
 10868 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10869 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10870 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10871 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10872 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10873 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10874 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10875 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 10876 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 10877 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 10878 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 10879 |     | <span class='neutral'>            // Selector of `log(string,address,string,string)`.</span>
 10880 |     | <span class='neutral'>            mstore(0x00, 0x245986f2)</span>
 10881 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10882 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10883 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 10884 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 10885 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10886 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 10887 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 10888 |     | <span class='neutral'>        }</span>
 10889 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 10890 |     | <span class='neutral'>        assembly {</span>
 10891 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10892 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10893 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10894 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10895 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10896 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10897 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10898 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 10899 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 10900 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 10901 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 10902 |     | <span class='neutral'>        }</span>
 10903 |     | <span class='neutral'>    }</span>
 10904 |     | <span class='neutral'></span>
 10905 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, address p3) internal pure {</span>
 10906 |     | <span class='neutral'>        bytes32 m0;</span>
 10907 |     | <span class='neutral'>        bytes32 m1;</span>
 10908 |     | <span class='neutral'>        bytes32 m2;</span>
 10909 |     | <span class='neutral'>        bytes32 m3;</span>
 10910 |     | <span class='neutral'>        bytes32 m4;</span>
 10911 |     | <span class='neutral'>        bytes32 m5;</span>
 10912 |     | <span class='neutral'>        bytes32 m6;</span>
 10913 |     | <span class='neutral'>        assembly {</span>
 10914 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10915 |     | <span class='neutral'>                let length := 0</span>
 10916 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10917 |     | <span class='neutral'>                mstore(pos, length)</span>
 10918 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10919 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10920 |     | <span class='neutral'>            }</span>
 10921 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10922 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10923 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10924 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10925 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10926 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10927 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10928 |     | <span class='neutral'>            // Selector of `log(string,bool,address,address)`.</span>
 10929 |     | <span class='neutral'>            mstore(0x00, 0x33e9dd1d)</span>
 10930 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10931 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10932 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10933 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10934 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10935 |     | <span class='neutral'>        }</span>
 10936 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10937 |     | <span class='neutral'>        assembly {</span>
 10938 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10939 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10940 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10941 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10942 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10943 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10944 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10945 |     | <span class='neutral'>        }</span>
 10946 |     | <span class='neutral'>    }</span>
 10947 |     | <span class='neutral'></span>
 10948 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bool p3) internal pure {</span>
 10949 |     | <span class='neutral'>        bytes32 m0;</span>
 10950 |     | <span class='neutral'>        bytes32 m1;</span>
 10951 |     | <span class='neutral'>        bytes32 m2;</span>
 10952 |     | <span class='neutral'>        bytes32 m3;</span>
 10953 |     | <span class='neutral'>        bytes32 m4;</span>
 10954 |     | <span class='neutral'>        bytes32 m5;</span>
 10955 |     | <span class='neutral'>        bytes32 m6;</span>
 10956 |     | <span class='neutral'>        assembly {</span>
 10957 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 10958 |     | <span class='neutral'>                let length := 0</span>
 10959 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 10960 |     | <span class='neutral'>                mstore(pos, length)</span>
 10961 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 10962 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 10963 |     | <span class='neutral'>            }</span>
 10964 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 10965 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 10966 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 10967 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 10968 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 10969 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 10970 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 10971 |     | <span class='neutral'>            // Selector of `log(string,bool,address,bool)`.</span>
 10972 |     | <span class='neutral'>            mstore(0x00, 0x958c28c6)</span>
 10973 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 10974 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 10975 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 10976 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 10977 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 10978 |     | <span class='neutral'>        }</span>
 10979 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 10980 |     | <span class='neutral'>        assembly {</span>
 10981 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 10982 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 10983 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 10984 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 10985 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 10986 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 10987 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 10988 |     | <span class='neutral'>        }</span>
 10989 |     | <span class='neutral'>    }</span>
 10990 |     | <span class='neutral'></span>
 10991 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, uint256 p3) internal pure {</span>
 10992 |     | <span class='neutral'>        bytes32 m0;</span>
 10993 |     | <span class='neutral'>        bytes32 m1;</span>
 10994 |     | <span class='neutral'>        bytes32 m2;</span>
 10995 |     | <span class='neutral'>        bytes32 m3;</span>
 10996 |     | <span class='neutral'>        bytes32 m4;</span>
 10997 |     | <span class='neutral'>        bytes32 m5;</span>
 10998 |     | <span class='neutral'>        bytes32 m6;</span>
 10999 |     | <span class='neutral'>        assembly {</span>
 11000 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11001 |     | <span class='neutral'>                let length := 0</span>
 11002 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11003 |     | <span class='neutral'>                mstore(pos, length)</span>
 11004 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11005 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11006 |     | <span class='neutral'>            }</span>
 11007 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11008 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11009 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11010 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11011 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11012 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11013 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11014 |     | <span class='neutral'>            // Selector of `log(string,bool,address,uint256)`.</span>
 11015 |     | <span class='neutral'>            mstore(0x00, 0x5d08bb05)</span>
 11016 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11017 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11018 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11019 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11020 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11021 |     | <span class='neutral'>        }</span>
 11022 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11023 |     | <span class='neutral'>        assembly {</span>
 11024 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11025 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11026 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11027 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11028 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11029 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11030 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11031 |     | <span class='neutral'>        }</span>
 11032 |     | <span class='neutral'>    }</span>
 11033 |     | <span class='neutral'></span>
 11034 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, address p2, bytes32 p3) internal pure {</span>
 11035 |     | <span class='neutral'>        bytes32 m0;</span>
 11036 |     | <span class='neutral'>        bytes32 m1;</span>
 11037 |     | <span class='neutral'>        bytes32 m2;</span>
 11038 |     | <span class='neutral'>        bytes32 m3;</span>
 11039 |     | <span class='neutral'>        bytes32 m4;</span>
 11040 |     | <span class='neutral'>        bytes32 m5;</span>
 11041 |     | <span class='neutral'>        bytes32 m6;</span>
 11042 |     | <span class='neutral'>        bytes32 m7;</span>
 11043 |     | <span class='neutral'>        bytes32 m8;</span>
 11044 |     | <span class='neutral'>        assembly {</span>
 11045 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11046 |     | <span class='neutral'>                let length := 0</span>
 11047 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11048 |     | <span class='neutral'>                mstore(pos, length)</span>
 11049 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11050 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11051 |     | <span class='neutral'>            }</span>
 11052 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11053 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11054 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11055 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11056 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11057 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11058 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11059 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11060 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11061 |     | <span class='neutral'>            // Selector of `log(string,bool,address,string)`.</span>
 11062 |     | <span class='neutral'>            mstore(0x00, 0x2d8e33a4)</span>
 11063 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11064 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11065 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11066 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11067 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11068 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11069 |     | <span class='neutral'>        }</span>
 11070 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11071 |     | <span class='neutral'>        assembly {</span>
 11072 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11073 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11074 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11075 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11076 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11077 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11078 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11079 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11080 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11081 |     | <span class='neutral'>        }</span>
 11082 |     | <span class='neutral'>    }</span>
 11083 |     | <span class='neutral'></span>
 11084 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, address p3) internal pure {</span>
 11085 |     | <span class='neutral'>        bytes32 m0;</span>
 11086 |     | <span class='neutral'>        bytes32 m1;</span>
 11087 |     | <span class='neutral'>        bytes32 m2;</span>
 11088 |     | <span class='neutral'>        bytes32 m3;</span>
 11089 |     | <span class='neutral'>        bytes32 m4;</span>
 11090 |     | <span class='neutral'>        bytes32 m5;</span>
 11091 |     | <span class='neutral'>        bytes32 m6;</span>
 11092 |     | <span class='neutral'>        assembly {</span>
 11093 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11094 |     | <span class='neutral'>                let length := 0</span>
 11095 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11096 |     | <span class='neutral'>                mstore(pos, length)</span>
 11097 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11098 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11099 |     | <span class='neutral'>            }</span>
 11100 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11101 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11102 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11103 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11104 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11105 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11106 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11107 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,address)`.</span>
 11108 |     | <span class='neutral'>            mstore(0x00, 0x7190a529)</span>
 11109 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11110 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11111 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11112 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11113 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11114 |     | <span class='neutral'>        }</span>
 11115 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11116 |     | <span class='neutral'>        assembly {</span>
 11117 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11118 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11119 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11120 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11121 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11122 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11123 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11124 |     | <span class='neutral'>        }</span>
 11125 |     | <span class='neutral'>    }</span>
 11126 |     | <span class='neutral'></span>
 11127 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bool p3) internal pure {</span>
 11128 |     | <span class='neutral'>        bytes32 m0;</span>
 11129 |     | <span class='neutral'>        bytes32 m1;</span>
 11130 |     | <span class='neutral'>        bytes32 m2;</span>
 11131 |     | <span class='neutral'>        bytes32 m3;</span>
 11132 |     | <span class='neutral'>        bytes32 m4;</span>
 11133 |     | <span class='neutral'>        bytes32 m5;</span>
 11134 |     | <span class='neutral'>        bytes32 m6;</span>
 11135 |     | <span class='neutral'>        assembly {</span>
 11136 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11137 |     | <span class='neutral'>                let length := 0</span>
 11138 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11139 |     | <span class='neutral'>                mstore(pos, length)</span>
 11140 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11141 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11142 |     | <span class='neutral'>            }</span>
 11143 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11144 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11145 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11146 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11147 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11148 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11149 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11150 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,bool)`.</span>
 11151 |     | <span class='neutral'>            mstore(0x00, 0x895af8c5)</span>
 11152 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11153 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11154 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11155 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11156 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11157 |     | <span class='neutral'>        }</span>
 11158 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11159 |     | <span class='neutral'>        assembly {</span>
 11160 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11161 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11162 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11163 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11164 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11165 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11166 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11167 |     | <span class='neutral'>        }</span>
 11168 |     | <span class='neutral'>    }</span>
 11169 |     | <span class='neutral'></span>
 11170 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, uint256 p3) internal pure {</span>
 11171 |     | <span class='neutral'>        bytes32 m0;</span>
 11172 |     | <span class='neutral'>        bytes32 m1;</span>
 11173 |     | <span class='neutral'>        bytes32 m2;</span>
 11174 |     | <span class='neutral'>        bytes32 m3;</span>
 11175 |     | <span class='neutral'>        bytes32 m4;</span>
 11176 |     | <span class='neutral'>        bytes32 m5;</span>
 11177 |     | <span class='neutral'>        bytes32 m6;</span>
 11178 |     | <span class='neutral'>        assembly {</span>
 11179 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11180 |     | <span class='neutral'>                let length := 0</span>
 11181 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11182 |     | <span class='neutral'>                mstore(pos, length)</span>
 11183 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11184 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11185 |     | <span class='neutral'>            }</span>
 11186 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11187 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11188 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11189 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11190 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11191 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11192 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11193 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,uint256)`.</span>
 11194 |     | <span class='neutral'>            mstore(0x00, 0x8e3f78a9)</span>
 11195 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11196 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11197 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11198 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11199 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11200 |     | <span class='neutral'>        }</span>
 11201 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11202 |     | <span class='neutral'>        assembly {</span>
 11203 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11204 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11205 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11206 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11207 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11208 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11209 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11210 |     | <span class='neutral'>        }</span>
 11211 |     | <span class='neutral'>    }</span>
 11212 |     | <span class='neutral'></span>
 11213 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bool p2, bytes32 p3) internal pure {</span>
 11214 |     | <span class='neutral'>        bytes32 m0;</span>
 11215 |     | <span class='neutral'>        bytes32 m1;</span>
 11216 |     | <span class='neutral'>        bytes32 m2;</span>
 11217 |     | <span class='neutral'>        bytes32 m3;</span>
 11218 |     | <span class='neutral'>        bytes32 m4;</span>
 11219 |     | <span class='neutral'>        bytes32 m5;</span>
 11220 |     | <span class='neutral'>        bytes32 m6;</span>
 11221 |     | <span class='neutral'>        bytes32 m7;</span>
 11222 |     | <span class='neutral'>        bytes32 m8;</span>
 11223 |     | <span class='neutral'>        assembly {</span>
 11224 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11225 |     | <span class='neutral'>                let length := 0</span>
 11226 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11227 |     | <span class='neutral'>                mstore(pos, length)</span>
 11228 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11229 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11230 |     | <span class='neutral'>            }</span>
 11231 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11232 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11233 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11234 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11235 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11236 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11237 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11238 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11239 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11240 |     | <span class='neutral'>            // Selector of `log(string,bool,bool,string)`.</span>
 11241 |     | <span class='neutral'>            mstore(0x00, 0x9d22d5dd)</span>
 11242 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11243 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11244 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11245 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11246 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11247 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11248 |     | <span class='neutral'>        }</span>
 11249 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11250 |     | <span class='neutral'>        assembly {</span>
 11251 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11252 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11253 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11254 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11255 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11256 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11257 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11258 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11259 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11260 |     | <span class='neutral'>        }</span>
 11261 |     | <span class='neutral'>    }</span>
 11262 |     | <span class='neutral'></span>
 11263 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, address p3) internal pure {</span>
 11264 |     | <span class='neutral'>        bytes32 m0;</span>
 11265 |     | <span class='neutral'>        bytes32 m1;</span>
 11266 |     | <span class='neutral'>        bytes32 m2;</span>
 11267 |     | <span class='neutral'>        bytes32 m3;</span>
 11268 |     | <span class='neutral'>        bytes32 m4;</span>
 11269 |     | <span class='neutral'>        bytes32 m5;</span>
 11270 |     | <span class='neutral'>        bytes32 m6;</span>
 11271 |     | <span class='neutral'>        assembly {</span>
 11272 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11273 |     | <span class='neutral'>                let length := 0</span>
 11274 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11275 |     | <span class='neutral'>                mstore(pos, length)</span>
 11276 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11277 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11278 |     | <span class='neutral'>            }</span>
 11279 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11280 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11281 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11282 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11283 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11284 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11285 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11286 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,address)`.</span>
 11287 |     | <span class='neutral'>            mstore(0x00, 0x935e09bf)</span>
 11288 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11289 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11290 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11291 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11292 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11293 |     | <span class='neutral'>        }</span>
 11294 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11295 |     | <span class='neutral'>        assembly {</span>
 11296 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11297 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11298 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11299 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11300 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11301 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11302 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11303 |     | <span class='neutral'>        }</span>
 11304 |     | <span class='neutral'>    }</span>
 11305 |     | <span class='neutral'></span>
 11306 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bool p3) internal pure {</span>
 11307 |     | <span class='neutral'>        bytes32 m0;</span>
 11308 |     | <span class='neutral'>        bytes32 m1;</span>
 11309 |     | <span class='neutral'>        bytes32 m2;</span>
 11310 |     | <span class='neutral'>        bytes32 m3;</span>
 11311 |     | <span class='neutral'>        bytes32 m4;</span>
 11312 |     | <span class='neutral'>        bytes32 m5;</span>
 11313 |     | <span class='neutral'>        bytes32 m6;</span>
 11314 |     | <span class='neutral'>        assembly {</span>
 11315 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11316 |     | <span class='neutral'>                let length := 0</span>
 11317 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11318 |     | <span class='neutral'>                mstore(pos, length)</span>
 11319 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11320 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11321 |     | <span class='neutral'>            }</span>
 11322 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11323 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11324 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11325 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11326 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11327 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11328 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11329 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,bool)`.</span>
 11330 |     | <span class='neutral'>            mstore(0x00, 0x8af7cf8a)</span>
 11331 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11332 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11333 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11334 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11335 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11336 |     | <span class='neutral'>        }</span>
 11337 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11338 |     | <span class='neutral'>        assembly {</span>
 11339 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11340 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11341 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11342 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11343 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11344 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11345 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11346 |     | <span class='neutral'>        }</span>
 11347 |     | <span class='neutral'>    }</span>
 11348 |     | <span class='neutral'></span>
 11349 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, uint256 p3) internal pure {</span>
 11350 |     | <span class='neutral'>        bytes32 m0;</span>
 11351 |     | <span class='neutral'>        bytes32 m1;</span>
 11352 |     | <span class='neutral'>        bytes32 m2;</span>
 11353 |     | <span class='neutral'>        bytes32 m3;</span>
 11354 |     | <span class='neutral'>        bytes32 m4;</span>
 11355 |     | <span class='neutral'>        bytes32 m5;</span>
 11356 |     | <span class='neutral'>        bytes32 m6;</span>
 11357 |     | <span class='neutral'>        assembly {</span>
 11358 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11359 |     | <span class='neutral'>                let length := 0</span>
 11360 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11361 |     | <span class='neutral'>                mstore(pos, length)</span>
 11362 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11363 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11364 |     | <span class='neutral'>            }</span>
 11365 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11366 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11367 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11368 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11369 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11370 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11371 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11372 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,uint256)`.</span>
 11373 |     | <span class='neutral'>            mstore(0x00, 0x64b5bb67)</span>
 11374 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11375 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11376 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11377 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11378 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11379 |     | <span class='neutral'>        }</span>
 11380 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11381 |     | <span class='neutral'>        assembly {</span>
 11382 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11383 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11384 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11385 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11386 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11387 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11388 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11389 |     | <span class='neutral'>        }</span>
 11390 |     | <span class='neutral'>    }</span>
 11391 |     | <span class='neutral'></span>
 11392 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, uint256 p2, bytes32 p3) internal pure {</span>
 11393 |     | <span class='neutral'>        bytes32 m0;</span>
 11394 |     | <span class='neutral'>        bytes32 m1;</span>
 11395 |     | <span class='neutral'>        bytes32 m2;</span>
 11396 |     | <span class='neutral'>        bytes32 m3;</span>
 11397 |     | <span class='neutral'>        bytes32 m4;</span>
 11398 |     | <span class='neutral'>        bytes32 m5;</span>
 11399 |     | <span class='neutral'>        bytes32 m6;</span>
 11400 |     | <span class='neutral'>        bytes32 m7;</span>
 11401 |     | <span class='neutral'>        bytes32 m8;</span>
 11402 |     | <span class='neutral'>        assembly {</span>
 11403 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11404 |     | <span class='neutral'>                let length := 0</span>
 11405 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11406 |     | <span class='neutral'>                mstore(pos, length)</span>
 11407 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11408 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11409 |     | <span class='neutral'>            }</span>
 11410 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11411 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11412 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11413 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11414 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11415 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11416 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11417 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11418 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11419 |     | <span class='neutral'>            // Selector of `log(string,bool,uint256,string)`.</span>
 11420 |     | <span class='neutral'>            mstore(0x00, 0x742d6ee7)</span>
 11421 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11422 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11423 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11424 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11425 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11426 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11427 |     | <span class='neutral'>        }</span>
 11428 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11429 |     | <span class='neutral'>        assembly {</span>
 11430 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11431 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11432 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11433 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11434 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11435 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11436 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11437 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11438 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11439 |     | <span class='neutral'>        }</span>
 11440 |     | <span class='neutral'>    }</span>
 11441 |     | <span class='neutral'></span>
 11442 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, address p3) internal pure {</span>
 11443 |     | <span class='neutral'>        bytes32 m0;</span>
 11444 |     | <span class='neutral'>        bytes32 m1;</span>
 11445 |     | <span class='neutral'>        bytes32 m2;</span>
 11446 |     | <span class='neutral'>        bytes32 m3;</span>
 11447 |     | <span class='neutral'>        bytes32 m4;</span>
 11448 |     | <span class='neutral'>        bytes32 m5;</span>
 11449 |     | <span class='neutral'>        bytes32 m6;</span>
 11450 |     | <span class='neutral'>        bytes32 m7;</span>
 11451 |     | <span class='neutral'>        bytes32 m8;</span>
 11452 |     | <span class='neutral'>        assembly {</span>
 11453 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11454 |     | <span class='neutral'>                let length := 0</span>
 11455 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11456 |     | <span class='neutral'>                mstore(pos, length)</span>
 11457 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11458 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11459 |     | <span class='neutral'>            }</span>
 11460 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11461 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11462 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11463 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11464 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11465 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11466 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11467 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11468 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11469 |     | <span class='neutral'>            // Selector of `log(string,bool,string,address)`.</span>
 11470 |     | <span class='neutral'>            mstore(0x00, 0xe0625b29)</span>
 11471 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11472 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11473 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11474 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11475 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11476 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11477 |     | <span class='neutral'>        }</span>
 11478 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11479 |     | <span class='neutral'>        assembly {</span>
 11480 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11481 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11482 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11483 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11484 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11485 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11486 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11487 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11488 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11489 |     | <span class='neutral'>        }</span>
 11490 |     | <span class='neutral'>    }</span>
 11491 |     | <span class='neutral'></span>
 11492 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bool p3) internal pure {</span>
 11493 |     | <span class='neutral'>        bytes32 m0;</span>
 11494 |     | <span class='neutral'>        bytes32 m1;</span>
 11495 |     | <span class='neutral'>        bytes32 m2;</span>
 11496 |     | <span class='neutral'>        bytes32 m3;</span>
 11497 |     | <span class='neutral'>        bytes32 m4;</span>
 11498 |     | <span class='neutral'>        bytes32 m5;</span>
 11499 |     | <span class='neutral'>        bytes32 m6;</span>
 11500 |     | <span class='neutral'>        bytes32 m7;</span>
 11501 |     | <span class='neutral'>        bytes32 m8;</span>
 11502 |     | <span class='neutral'>        assembly {</span>
 11503 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11504 |     | <span class='neutral'>                let length := 0</span>
 11505 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11506 |     | <span class='neutral'>                mstore(pos, length)</span>
 11507 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11508 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11509 |     | <span class='neutral'>            }</span>
 11510 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11511 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11512 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11513 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11514 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11515 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11516 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11517 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11518 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11519 |     | <span class='neutral'>            // Selector of `log(string,bool,string,bool)`.</span>
 11520 |     | <span class='neutral'>            mstore(0x00, 0x3f8a701d)</span>
 11521 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11522 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11523 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11524 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11525 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11526 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11527 |     | <span class='neutral'>        }</span>
 11528 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11529 |     | <span class='neutral'>        assembly {</span>
 11530 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11531 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11532 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11533 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11534 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11535 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11536 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11537 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11538 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11539 |     | <span class='neutral'>        }</span>
 11540 |     | <span class='neutral'>    }</span>
 11541 |     | <span class='neutral'></span>
 11542 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, uint256 p3) internal pure {</span>
 11543 |     | <span class='neutral'>        bytes32 m0;</span>
 11544 |     | <span class='neutral'>        bytes32 m1;</span>
 11545 |     | <span class='neutral'>        bytes32 m2;</span>
 11546 |     | <span class='neutral'>        bytes32 m3;</span>
 11547 |     | <span class='neutral'>        bytes32 m4;</span>
 11548 |     | <span class='neutral'>        bytes32 m5;</span>
 11549 |     | <span class='neutral'>        bytes32 m6;</span>
 11550 |     | <span class='neutral'>        bytes32 m7;</span>
 11551 |     | <span class='neutral'>        bytes32 m8;</span>
 11552 |     | <span class='neutral'>        assembly {</span>
 11553 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11554 |     | <span class='neutral'>                let length := 0</span>
 11555 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11556 |     | <span class='neutral'>                mstore(pos, length)</span>
 11557 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11558 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11559 |     | <span class='neutral'>            }</span>
 11560 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11561 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11562 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11563 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11564 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11565 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11566 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11567 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11568 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11569 |     | <span class='neutral'>            // Selector of `log(string,bool,string,uint256)`.</span>
 11570 |     | <span class='neutral'>            mstore(0x00, 0x24f91465)</span>
 11571 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11572 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11573 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11574 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11575 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11576 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11577 |     | <span class='neutral'>        }</span>
 11578 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11579 |     | <span class='neutral'>        assembly {</span>
 11580 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11581 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11582 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11583 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11584 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11585 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11586 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11587 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11588 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11589 |     | <span class='neutral'>        }</span>
 11590 |     | <span class='neutral'>    }</span>
 11591 |     | <span class='neutral'></span>
 11592 |     | <span class='neutral'>    function log(bytes32 p0, bool p1, bytes32 p2, bytes32 p3) internal pure {</span>
 11593 |     | <span class='neutral'>        bytes32 m0;</span>
 11594 |     | <span class='neutral'>        bytes32 m1;</span>
 11595 |     | <span class='neutral'>        bytes32 m2;</span>
 11596 |     | <span class='neutral'>        bytes32 m3;</span>
 11597 |     | <span class='neutral'>        bytes32 m4;</span>
 11598 |     | <span class='neutral'>        bytes32 m5;</span>
 11599 |     | <span class='neutral'>        bytes32 m6;</span>
 11600 |     | <span class='neutral'>        bytes32 m7;</span>
 11601 |     | <span class='neutral'>        bytes32 m8;</span>
 11602 |     | <span class='neutral'>        bytes32 m9;</span>
 11603 |     | <span class='neutral'>        bytes32 m10;</span>
 11604 |     | <span class='neutral'>        assembly {</span>
 11605 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11606 |     | <span class='neutral'>                let length := 0</span>
 11607 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11608 |     | <span class='neutral'>                mstore(pos, length)</span>
 11609 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11610 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11611 |     | <span class='neutral'>            }</span>
 11612 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11613 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11614 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11615 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11616 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11617 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11618 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11619 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11620 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11621 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 11622 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 11623 |     | <span class='neutral'>            // Selector of `log(string,bool,string,string)`.</span>
 11624 |     | <span class='neutral'>            mstore(0x00, 0xa826caeb)</span>
 11625 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11626 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11627 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 11628 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 11629 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11630 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 11631 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 11632 |     | <span class='neutral'>        }</span>
 11633 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 11634 |     | <span class='neutral'>        assembly {</span>
 11635 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11636 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11637 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11638 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11639 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11640 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11641 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11642 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11643 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11644 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 11645 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 11646 |     | <span class='neutral'>        }</span>
 11647 |     | <span class='neutral'>    }</span>
 11648 |     | <span class='neutral'></span>
 11649 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, address p3) internal pure {</span>
 11650 |     | <span class='neutral'>        bytes32 m0;</span>
 11651 |     | <span class='neutral'>        bytes32 m1;</span>
 11652 |     | <span class='neutral'>        bytes32 m2;</span>
 11653 |     | <span class='neutral'>        bytes32 m3;</span>
 11654 |     | <span class='neutral'>        bytes32 m4;</span>
 11655 |     | <span class='neutral'>        bytes32 m5;</span>
 11656 |     | <span class='neutral'>        bytes32 m6;</span>
 11657 |     | <span class='neutral'>        assembly {</span>
 11658 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11659 |     | <span class='neutral'>                let length := 0</span>
 11660 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11661 |     | <span class='neutral'>                mstore(pos, length)</span>
 11662 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11663 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11664 |     | <span class='neutral'>            }</span>
 11665 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11666 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11667 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11668 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11669 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11670 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11671 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11672 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,address)`.</span>
 11673 |     | <span class='neutral'>            mstore(0x00, 0x5ea2b7ae)</span>
 11674 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11675 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11676 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11677 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11678 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11679 |     | <span class='neutral'>        }</span>
 11680 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11681 |     | <span class='neutral'>        assembly {</span>
 11682 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11683 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11684 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11685 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11686 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11687 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11688 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11689 |     | <span class='neutral'>        }</span>
 11690 |     | <span class='neutral'>    }</span>
 11691 |     | <span class='neutral'></span>
 11692 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bool p3) internal pure {</span>
 11693 |     | <span class='neutral'>        bytes32 m0;</span>
 11694 |     | <span class='neutral'>        bytes32 m1;</span>
 11695 |     | <span class='neutral'>        bytes32 m2;</span>
 11696 |     | <span class='neutral'>        bytes32 m3;</span>
 11697 |     | <span class='neutral'>        bytes32 m4;</span>
 11698 |     | <span class='neutral'>        bytes32 m5;</span>
 11699 |     | <span class='neutral'>        bytes32 m6;</span>
 11700 |     | <span class='neutral'>        assembly {</span>
 11701 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11702 |     | <span class='neutral'>                let length := 0</span>
 11703 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11704 |     | <span class='neutral'>                mstore(pos, length)</span>
 11705 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11706 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11707 |     | <span class='neutral'>            }</span>
 11708 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11709 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11710 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11711 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11712 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11713 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11714 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11715 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,bool)`.</span>
 11716 |     | <span class='neutral'>            mstore(0x00, 0x82112a42)</span>
 11717 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11718 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11719 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11720 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11721 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11722 |     | <span class='neutral'>        }</span>
 11723 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11724 |     | <span class='neutral'>        assembly {</span>
 11725 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11726 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11727 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11728 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11729 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11730 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11731 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11732 |     | <span class='neutral'>        }</span>
 11733 |     | <span class='neutral'>    }</span>
 11734 |     | <span class='neutral'></span>
 11735 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, uint256 p3) internal pure {</span>
 11736 |     | <span class='neutral'>        bytes32 m0;</span>
 11737 |     | <span class='neutral'>        bytes32 m1;</span>
 11738 |     | <span class='neutral'>        bytes32 m2;</span>
 11739 |     | <span class='neutral'>        bytes32 m3;</span>
 11740 |     | <span class='neutral'>        bytes32 m4;</span>
 11741 |     | <span class='neutral'>        bytes32 m5;</span>
 11742 |     | <span class='neutral'>        bytes32 m6;</span>
 11743 |     | <span class='neutral'>        assembly {</span>
 11744 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11745 |     | <span class='neutral'>                let length := 0</span>
 11746 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11747 |     | <span class='neutral'>                mstore(pos, length)</span>
 11748 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11749 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11750 |     | <span class='neutral'>            }</span>
 11751 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11752 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11753 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11754 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11755 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11756 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11757 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11758 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,uint256)`.</span>
 11759 |     | <span class='neutral'>            mstore(0x00, 0x4f04fdc6)</span>
 11760 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11761 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11762 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11763 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11764 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11765 |     | <span class='neutral'>        }</span>
 11766 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11767 |     | <span class='neutral'>        assembly {</span>
 11768 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11769 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11770 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11771 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11772 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11773 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11774 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11775 |     | <span class='neutral'>        }</span>
 11776 |     | <span class='neutral'>    }</span>
 11777 |     | <span class='neutral'></span>
 11778 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, address p2, bytes32 p3) internal pure {</span>
 11779 |     | <span class='neutral'>        bytes32 m0;</span>
 11780 |     | <span class='neutral'>        bytes32 m1;</span>
 11781 |     | <span class='neutral'>        bytes32 m2;</span>
 11782 |     | <span class='neutral'>        bytes32 m3;</span>
 11783 |     | <span class='neutral'>        bytes32 m4;</span>
 11784 |     | <span class='neutral'>        bytes32 m5;</span>
 11785 |     | <span class='neutral'>        bytes32 m6;</span>
 11786 |     | <span class='neutral'>        bytes32 m7;</span>
 11787 |     | <span class='neutral'>        bytes32 m8;</span>
 11788 |     | <span class='neutral'>        assembly {</span>
 11789 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11790 |     | <span class='neutral'>                let length := 0</span>
 11791 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11792 |     | <span class='neutral'>                mstore(pos, length)</span>
 11793 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11794 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11795 |     | <span class='neutral'>            }</span>
 11796 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11797 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11798 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11799 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11800 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11801 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11802 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11803 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11804 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11805 |     | <span class='neutral'>            // Selector of `log(string,uint256,address,string)`.</span>
 11806 |     | <span class='neutral'>            mstore(0x00, 0x9ffb2f93)</span>
 11807 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11808 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11809 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11810 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11811 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11812 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11813 |     | <span class='neutral'>        }</span>
 11814 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11815 |     | <span class='neutral'>        assembly {</span>
 11816 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11817 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11818 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11819 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11820 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11821 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11822 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11823 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 11824 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 11825 |     | <span class='neutral'>        }</span>
 11826 |     | <span class='neutral'>    }</span>
 11827 |     | <span class='neutral'></span>
 11828 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, address p3) internal pure {</span>
 11829 |     | <span class='neutral'>        bytes32 m0;</span>
 11830 |     | <span class='neutral'>        bytes32 m1;</span>
 11831 |     | <span class='neutral'>        bytes32 m2;</span>
 11832 |     | <span class='neutral'>        bytes32 m3;</span>
 11833 |     | <span class='neutral'>        bytes32 m4;</span>
 11834 |     | <span class='neutral'>        bytes32 m5;</span>
 11835 |     | <span class='neutral'>        bytes32 m6;</span>
 11836 |     | <span class='neutral'>        assembly {</span>
 11837 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11838 |     | <span class='neutral'>                let length := 0</span>
 11839 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11840 |     | <span class='neutral'>                mstore(pos, length)</span>
 11841 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11842 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11843 |     | <span class='neutral'>            }</span>
 11844 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11845 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11846 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11847 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11848 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11849 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11850 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11851 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,address)`.</span>
 11852 |     | <span class='neutral'>            mstore(0x00, 0xe0e95b98)</span>
 11853 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11854 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11855 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11856 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11857 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11858 |     | <span class='neutral'>        }</span>
 11859 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11860 |     | <span class='neutral'>        assembly {</span>
 11861 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11862 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11863 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11864 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11865 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11866 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11867 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11868 |     | <span class='neutral'>        }</span>
 11869 |     | <span class='neutral'>    }</span>
 11870 |     | <span class='neutral'></span>
 11871 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bool p3) internal pure {</span>
 11872 |     | <span class='neutral'>        bytes32 m0;</span>
 11873 |     | <span class='neutral'>        bytes32 m1;</span>
 11874 |     | <span class='neutral'>        bytes32 m2;</span>
 11875 |     | <span class='neutral'>        bytes32 m3;</span>
 11876 |     | <span class='neutral'>        bytes32 m4;</span>
 11877 |     | <span class='neutral'>        bytes32 m5;</span>
 11878 |     | <span class='neutral'>        bytes32 m6;</span>
 11879 |     | <span class='neutral'>        assembly {</span>
 11880 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11881 |     | <span class='neutral'>                let length := 0</span>
 11882 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11883 |     | <span class='neutral'>                mstore(pos, length)</span>
 11884 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11885 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11886 |     | <span class='neutral'>            }</span>
 11887 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11888 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11889 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11890 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11891 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11892 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11893 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11894 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,bool)`.</span>
 11895 |     | <span class='neutral'>            mstore(0x00, 0x354c36d6)</span>
 11896 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11897 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11898 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11899 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11900 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11901 |     | <span class='neutral'>        }</span>
 11902 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11903 |     | <span class='neutral'>        assembly {</span>
 11904 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11905 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11906 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11907 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11908 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11909 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11910 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11911 |     | <span class='neutral'>        }</span>
 11912 |     | <span class='neutral'>    }</span>
 11913 |     | <span class='neutral'></span>
 11914 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, uint256 p3) internal pure {</span>
 11915 |     | <span class='neutral'>        bytes32 m0;</span>
 11916 |     | <span class='neutral'>        bytes32 m1;</span>
 11917 |     | <span class='neutral'>        bytes32 m2;</span>
 11918 |     | <span class='neutral'>        bytes32 m3;</span>
 11919 |     | <span class='neutral'>        bytes32 m4;</span>
 11920 |     | <span class='neutral'>        bytes32 m5;</span>
 11921 |     | <span class='neutral'>        bytes32 m6;</span>
 11922 |     | <span class='neutral'>        assembly {</span>
 11923 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11924 |     | <span class='neutral'>                let length := 0</span>
 11925 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11926 |     | <span class='neutral'>                mstore(pos, length)</span>
 11927 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11928 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11929 |     | <span class='neutral'>            }</span>
 11930 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11931 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11932 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11933 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11934 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11935 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11936 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11937 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,uint256)`.</span>
 11938 |     | <span class='neutral'>            mstore(0x00, 0xe41b6f6f)</span>
 11939 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11940 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11941 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11942 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 11943 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11944 |     | <span class='neutral'>        }</span>
 11945 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 11946 |     | <span class='neutral'>        assembly {</span>
 11947 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11948 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11949 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11950 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11951 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 11952 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 11953 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 11954 |     | <span class='neutral'>        }</span>
 11955 |     | <span class='neutral'>    }</span>
 11956 |     | <span class='neutral'></span>
 11957 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bool p2, bytes32 p3) internal pure {</span>
 11958 |     | <span class='neutral'>        bytes32 m0;</span>
 11959 |     | <span class='neutral'>        bytes32 m1;</span>
 11960 |     | <span class='neutral'>        bytes32 m2;</span>
 11961 |     | <span class='neutral'>        bytes32 m3;</span>
 11962 |     | <span class='neutral'>        bytes32 m4;</span>
 11963 |     | <span class='neutral'>        bytes32 m5;</span>
 11964 |     | <span class='neutral'>        bytes32 m6;</span>
 11965 |     | <span class='neutral'>        bytes32 m7;</span>
 11966 |     | <span class='neutral'>        bytes32 m8;</span>
 11967 |     | <span class='neutral'>        assembly {</span>
 11968 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 11969 |     | <span class='neutral'>                let length := 0</span>
 11970 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 11971 |     | <span class='neutral'>                mstore(pos, length)</span>
 11972 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 11973 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 11974 |     | <span class='neutral'>            }</span>
 11975 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 11976 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 11977 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 11978 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 11979 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 11980 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 11981 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 11982 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 11983 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 11984 |     | <span class='neutral'>            // Selector of `log(string,uint256,bool,string)`.</span>
 11985 |     | <span class='neutral'>            mstore(0x00, 0xabf73a98)</span>
 11986 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 11987 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 11988 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 11989 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 11990 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 11991 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 11992 |     | <span class='neutral'>        }</span>
 11993 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 11994 |     | <span class='neutral'>        assembly {</span>
 11995 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 11996 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 11997 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 11998 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 11999 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12000 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12001 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12002 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12003 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12004 |     | <span class='neutral'>        }</span>
 12005 |     | <span class='neutral'>    }</span>
 12006 |     | <span class='neutral'></span>
 12007 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, address p3) internal pure {</span>
 12008 |     | <span class='neutral'>        bytes32 m0;</span>
 12009 |     | <span class='neutral'>        bytes32 m1;</span>
 12010 |     | <span class='neutral'>        bytes32 m2;</span>
 12011 |     | <span class='neutral'>        bytes32 m3;</span>
 12012 |     | <span class='neutral'>        bytes32 m4;</span>
 12013 |     | <span class='neutral'>        bytes32 m5;</span>
 12014 |     | <span class='neutral'>        bytes32 m6;</span>
 12015 |     | <span class='neutral'>        assembly {</span>
 12016 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12017 |     | <span class='neutral'>                let length := 0</span>
 12018 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12019 |     | <span class='neutral'>                mstore(pos, length)</span>
 12020 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12021 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12022 |     | <span class='neutral'>            }</span>
 12023 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12024 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12025 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12026 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12027 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12028 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12029 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12030 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,address)`.</span>
 12031 |     | <span class='neutral'>            mstore(0x00, 0xe21de278)</span>
 12032 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12033 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12034 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12035 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12036 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12037 |     | <span class='neutral'>        }</span>
 12038 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12039 |     | <span class='neutral'>        assembly {</span>
 12040 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12041 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12042 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12043 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12044 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12045 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12046 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12047 |     | <span class='neutral'>        }</span>
 12048 |     | <span class='neutral'>    }</span>
 12049 |     | <span class='neutral'></span>
 12050 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bool p3) internal pure {</span>
 12051 |     | <span class='neutral'>        bytes32 m0;</span>
 12052 |     | <span class='neutral'>        bytes32 m1;</span>
 12053 |     | <span class='neutral'>        bytes32 m2;</span>
 12054 |     | <span class='neutral'>        bytes32 m3;</span>
 12055 |     | <span class='neutral'>        bytes32 m4;</span>
 12056 |     | <span class='neutral'>        bytes32 m5;</span>
 12057 |     | <span class='neutral'>        bytes32 m6;</span>
 12058 |     | <span class='neutral'>        assembly {</span>
 12059 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12060 |     | <span class='neutral'>                let length := 0</span>
 12061 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12062 |     | <span class='neutral'>                mstore(pos, length)</span>
 12063 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12064 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12065 |     | <span class='neutral'>            }</span>
 12066 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12067 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12068 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12069 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12070 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12071 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12072 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12073 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,bool)`.</span>
 12074 |     | <span class='neutral'>            mstore(0x00, 0x7626db92)</span>
 12075 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12076 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12077 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12078 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12079 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12080 |     | <span class='neutral'>        }</span>
 12081 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12082 |     | <span class='neutral'>        assembly {</span>
 12083 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12084 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12085 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12086 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12087 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12088 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12089 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12090 |     | <span class='neutral'>        }</span>
 12091 |     | <span class='neutral'>    }</span>
 12092 |     | <span class='neutral'></span>
 12093 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {</span>
 12094 |     | <span class='neutral'>        bytes32 m0;</span>
 12095 |     | <span class='neutral'>        bytes32 m1;</span>
 12096 |     | <span class='neutral'>        bytes32 m2;</span>
 12097 |     | <span class='neutral'>        bytes32 m3;</span>
 12098 |     | <span class='neutral'>        bytes32 m4;</span>
 12099 |     | <span class='neutral'>        bytes32 m5;</span>
 12100 |     | <span class='neutral'>        bytes32 m6;</span>
 12101 |     | <span class='neutral'>        assembly {</span>
 12102 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12103 |     | <span class='neutral'>                let length := 0</span>
 12104 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12105 |     | <span class='neutral'>                mstore(pos, length)</span>
 12106 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12107 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12108 |     | <span class='neutral'>            }</span>
 12109 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12110 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12111 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12112 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12113 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12114 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12115 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12116 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,uint256)`.</span>
 12117 |     | <span class='neutral'>            mstore(0x00, 0xa7a87853)</span>
 12118 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12119 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12120 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12121 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12122 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12123 |     | <span class='neutral'>        }</span>
 12124 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0xc4);</span>
 12125 |     | <span class='neutral'>        assembly {</span>
 12126 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12127 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12128 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12129 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12130 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12131 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12132 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12133 |     | <span class='neutral'>        }</span>
 12134 |     | <span class='neutral'>    }</span>
 12135 |     | <span class='neutral'></span>
 12136 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12137 |     | <span class='neutral'>        bytes32 m0;</span>
 12138 |     | <span class='neutral'>        bytes32 m1;</span>
 12139 |     | <span class='neutral'>        bytes32 m2;</span>
 12140 |     | <span class='neutral'>        bytes32 m3;</span>
 12141 |     | <span class='neutral'>        bytes32 m4;</span>
 12142 |     | <span class='neutral'>        bytes32 m5;</span>
 12143 |     | <span class='neutral'>        bytes32 m6;</span>
 12144 |     | <span class='neutral'>        bytes32 m7;</span>
 12145 |     | <span class='neutral'>        bytes32 m8;</span>
 12146 |     | <span class='neutral'>        assembly {</span>
 12147 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12148 |     | <span class='neutral'>                let length := 0</span>
 12149 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12150 |     | <span class='neutral'>                mstore(pos, length)</span>
 12151 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12152 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12153 |     | <span class='neutral'>            }</span>
 12154 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12155 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12156 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12157 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12158 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12159 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12160 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12161 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12162 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12163 |     | <span class='neutral'>            // Selector of `log(string,uint256,uint256,string)`.</span>
 12164 |     | <span class='neutral'>            mstore(0x00, 0x854b3496)</span>
 12165 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12166 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12167 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12168 |     | <span class='neutral'>            mstore(0x80, 0xc0)</span>
 12169 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12170 |     | <span class='neutral'>            writeString(0xe0, p3)</span>
 12171 |     | <span class='neutral'>        }</span>
 12172 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12173 |     | <span class='neutral'>        assembly {</span>
 12174 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12175 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12176 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12177 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12178 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12179 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12180 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12181 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12182 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12183 |     | <span class='neutral'>        }</span>
 12184 |     | <span class='neutral'>    }</span>
 12185 |     | <span class='neutral'></span>
 12186 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, address p3) internal pure {</span>
 12187 |     | <span class='neutral'>        bytes32 m0;</span>
 12188 |     | <span class='neutral'>        bytes32 m1;</span>
 12189 |     | <span class='neutral'>        bytes32 m2;</span>
 12190 |     | <span class='neutral'>        bytes32 m3;</span>
 12191 |     | <span class='neutral'>        bytes32 m4;</span>
 12192 |     | <span class='neutral'>        bytes32 m5;</span>
 12193 |     | <span class='neutral'>        bytes32 m6;</span>
 12194 |     | <span class='neutral'>        bytes32 m7;</span>
 12195 |     | <span class='neutral'>        bytes32 m8;</span>
 12196 |     | <span class='neutral'>        assembly {</span>
 12197 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12198 |     | <span class='neutral'>                let length := 0</span>
 12199 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12200 |     | <span class='neutral'>                mstore(pos, length)</span>
 12201 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12202 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12203 |     | <span class='neutral'>            }</span>
 12204 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12205 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12206 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12207 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12208 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12209 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12210 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12211 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12212 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12213 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,address)`.</span>
 12214 |     | <span class='neutral'>            mstore(0x00, 0x7c4632a4)</span>
 12215 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12216 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12217 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12218 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12219 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12220 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12221 |     | <span class='neutral'>        }</span>
 12222 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12223 |     | <span class='neutral'>        assembly {</span>
 12224 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12225 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12226 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12227 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12228 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12229 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12230 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12231 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12232 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12233 |     | <span class='neutral'>        }</span>
 12234 |     | <span class='neutral'>    }</span>
 12235 |     | <span class='neutral'></span>
 12236 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bool p3) internal pure {</span>
 12237 |     | <span class='neutral'>        bytes32 m0;</span>
 12238 |     | <span class='neutral'>        bytes32 m1;</span>
 12239 |     | <span class='neutral'>        bytes32 m2;</span>
 12240 |     | <span class='neutral'>        bytes32 m3;</span>
 12241 |     | <span class='neutral'>        bytes32 m4;</span>
 12242 |     | <span class='neutral'>        bytes32 m5;</span>
 12243 |     | <span class='neutral'>        bytes32 m6;</span>
 12244 |     | <span class='neutral'>        bytes32 m7;</span>
 12245 |     | <span class='neutral'>        bytes32 m8;</span>
 12246 |     | <span class='neutral'>        assembly {</span>
 12247 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12248 |     | <span class='neutral'>                let length := 0</span>
 12249 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12250 |     | <span class='neutral'>                mstore(pos, length)</span>
 12251 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12252 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12253 |     | <span class='neutral'>            }</span>
 12254 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12255 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12256 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12257 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12258 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12259 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12260 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12261 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12262 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12263 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,bool)`.</span>
 12264 |     | <span class='neutral'>            mstore(0x00, 0x7d24491d)</span>
 12265 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12266 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12267 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12268 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12269 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12270 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12271 |     | <span class='neutral'>        }</span>
 12272 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12273 |     | <span class='neutral'>        assembly {</span>
 12274 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12275 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12276 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12277 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12278 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12279 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12280 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12281 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12282 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12283 |     | <span class='neutral'>        }</span>
 12284 |     | <span class='neutral'>    }</span>
 12285 |     | <span class='neutral'></span>
 12286 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, uint256 p3) internal pure {</span>
 12287 |     | <span class='neutral'>        bytes32 m0;</span>
 12288 |     | <span class='neutral'>        bytes32 m1;</span>
 12289 |     | <span class='neutral'>        bytes32 m2;</span>
 12290 |     | <span class='neutral'>        bytes32 m3;</span>
 12291 |     | <span class='neutral'>        bytes32 m4;</span>
 12292 |     | <span class='neutral'>        bytes32 m5;</span>
 12293 |     | <span class='neutral'>        bytes32 m6;</span>
 12294 |     | <span class='neutral'>        bytes32 m7;</span>
 12295 |     | <span class='neutral'>        bytes32 m8;</span>
 12296 |     | <span class='neutral'>        assembly {</span>
 12297 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12298 |     | <span class='neutral'>                let length := 0</span>
 12299 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12300 |     | <span class='neutral'>                mstore(pos, length)</span>
 12301 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12302 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12303 |     | <span class='neutral'>            }</span>
 12304 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12305 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12306 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12307 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12308 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12309 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12310 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12311 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12312 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12313 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,uint256)`.</span>
 12314 |     | <span class='neutral'>            mstore(0x00, 0xc67ea9d1)</span>
 12315 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12316 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12317 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12318 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12319 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12320 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12321 |     | <span class='neutral'>        }</span>
 12322 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12323 |     | <span class='neutral'>        assembly {</span>
 12324 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12325 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12326 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12327 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12328 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12329 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12330 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12331 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12332 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12333 |     | <span class='neutral'>        }</span>
 12334 |     | <span class='neutral'>    }</span>
 12335 |     | <span class='neutral'></span>
 12336 |     | <span class='neutral'>    function log(bytes32 p0, uint256 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 12337 |     | <span class='neutral'>        bytes32 m0;</span>
 12338 |     | <span class='neutral'>        bytes32 m1;</span>
 12339 |     | <span class='neutral'>        bytes32 m2;</span>
 12340 |     | <span class='neutral'>        bytes32 m3;</span>
 12341 |     | <span class='neutral'>        bytes32 m4;</span>
 12342 |     | <span class='neutral'>        bytes32 m5;</span>
 12343 |     | <span class='neutral'>        bytes32 m6;</span>
 12344 |     | <span class='neutral'>        bytes32 m7;</span>
 12345 |     | <span class='neutral'>        bytes32 m8;</span>
 12346 |     | <span class='neutral'>        bytes32 m9;</span>
 12347 |     | <span class='neutral'>        bytes32 m10;</span>
 12348 |     | <span class='neutral'>        assembly {</span>
 12349 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12350 |     | <span class='neutral'>                let length := 0</span>
 12351 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12352 |     | <span class='neutral'>                mstore(pos, length)</span>
 12353 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12354 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12355 |     | <span class='neutral'>            }</span>
 12356 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12357 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12358 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12359 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12360 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12361 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12362 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12363 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12364 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12365 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12366 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12367 |     | <span class='neutral'>            // Selector of `log(string,uint256,string,string)`.</span>
 12368 |     | <span class='neutral'>            mstore(0x00, 0x5ab84e1f)</span>
 12369 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12370 |     | <span class='neutral'>            mstore(0x40, p1)</span>
 12371 |     | <span class='neutral'>            mstore(0x60, 0xc0)</span>
 12372 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12373 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12374 |     | <span class='neutral'>            writeString(0xe0, p2)</span>
 12375 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12376 |     | <span class='neutral'>        }</span>
 12377 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12378 |     | <span class='neutral'>        assembly {</span>
 12379 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12380 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12381 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12382 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12383 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12384 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12385 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12386 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12387 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12388 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12389 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12390 |     | <span class='neutral'>        }</span>
 12391 |     | <span class='neutral'>    }</span>
 12392 |     | <span class='neutral'></span>
 12393 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, address p3) internal pure {</span>
 12394 |     | <span class='neutral'>        bytes32 m0;</span>
 12395 |     | <span class='neutral'>        bytes32 m1;</span>
 12396 |     | <span class='neutral'>        bytes32 m2;</span>
 12397 |     | <span class='neutral'>        bytes32 m3;</span>
 12398 |     | <span class='neutral'>        bytes32 m4;</span>
 12399 |     | <span class='neutral'>        bytes32 m5;</span>
 12400 |     | <span class='neutral'>        bytes32 m6;</span>
 12401 |     | <span class='neutral'>        bytes32 m7;</span>
 12402 |     | <span class='neutral'>        bytes32 m8;</span>
 12403 |     | <span class='neutral'>        assembly {</span>
 12404 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12405 |     | <span class='neutral'>                let length := 0</span>
 12406 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12407 |     | <span class='neutral'>                mstore(pos, length)</span>
 12408 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12409 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12410 |     | <span class='neutral'>            }</span>
 12411 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12412 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12413 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12414 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12415 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12416 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12417 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12418 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12419 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12420 |     | <span class='neutral'>            // Selector of `log(string,string,address,address)`.</span>
 12421 |     | <span class='neutral'>            mstore(0x00, 0x439c7bef)</span>
 12422 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12423 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12424 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12425 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12426 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12427 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12428 |     | <span class='neutral'>        }</span>
 12429 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12430 |     | <span class='neutral'>        assembly {</span>
 12431 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12432 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12433 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12434 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12435 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12436 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12437 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12438 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12439 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12440 |     | <span class='neutral'>        }</span>
 12441 |     | <span class='neutral'>    }</span>
 12442 |     | <span class='neutral'></span>
 12443 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bool p3) internal pure {</span>
 12444 |     | <span class='neutral'>        bytes32 m0;</span>
 12445 |     | <span class='neutral'>        bytes32 m1;</span>
 12446 |     | <span class='neutral'>        bytes32 m2;</span>
 12447 |     | <span class='neutral'>        bytes32 m3;</span>
 12448 |     | <span class='neutral'>        bytes32 m4;</span>
 12449 |     | <span class='neutral'>        bytes32 m5;</span>
 12450 |     | <span class='neutral'>        bytes32 m6;</span>
 12451 |     | <span class='neutral'>        bytes32 m7;</span>
 12452 |     | <span class='neutral'>        bytes32 m8;</span>
 12453 |     | <span class='neutral'>        assembly {</span>
 12454 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12455 |     | <span class='neutral'>                let length := 0</span>
 12456 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12457 |     | <span class='neutral'>                mstore(pos, length)</span>
 12458 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12459 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12460 |     | <span class='neutral'>            }</span>
 12461 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12462 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12463 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12464 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12465 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12466 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12467 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12468 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12469 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12470 |     | <span class='neutral'>            // Selector of `log(string,string,address,bool)`.</span>
 12471 |     | <span class='neutral'>            mstore(0x00, 0x5ccd4e37)</span>
 12472 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12473 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12474 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12475 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12476 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12477 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12478 |     | <span class='neutral'>        }</span>
 12479 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12480 |     | <span class='neutral'>        assembly {</span>
 12481 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12482 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12483 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12484 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12485 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12486 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12487 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12488 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12489 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12490 |     | <span class='neutral'>        }</span>
 12491 |     | <span class='neutral'>    }</span>
 12492 |     | <span class='neutral'></span>
 12493 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, uint256 p3) internal pure {</span>
 12494 |     | <span class='neutral'>        bytes32 m0;</span>
 12495 |     | <span class='neutral'>        bytes32 m1;</span>
 12496 |     | <span class='neutral'>        bytes32 m2;</span>
 12497 |     | <span class='neutral'>        bytes32 m3;</span>
 12498 |     | <span class='neutral'>        bytes32 m4;</span>
 12499 |     | <span class='neutral'>        bytes32 m5;</span>
 12500 |     | <span class='neutral'>        bytes32 m6;</span>
 12501 |     | <span class='neutral'>        bytes32 m7;</span>
 12502 |     | <span class='neutral'>        bytes32 m8;</span>
 12503 |     | <span class='neutral'>        assembly {</span>
 12504 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12505 |     | <span class='neutral'>                let length := 0</span>
 12506 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12507 |     | <span class='neutral'>                mstore(pos, length)</span>
 12508 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12509 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12510 |     | <span class='neutral'>            }</span>
 12511 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12512 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12513 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12514 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12515 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12516 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12517 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12518 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12519 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12520 |     | <span class='neutral'>            // Selector of `log(string,string,address,uint256)`.</span>
 12521 |     | <span class='neutral'>            mstore(0x00, 0x7cc3c607)</span>
 12522 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12523 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12524 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12525 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12526 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12527 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12528 |     | <span class='neutral'>        }</span>
 12529 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12530 |     | <span class='neutral'>        assembly {</span>
 12531 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12532 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12533 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12534 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12535 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12536 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12537 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12538 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12539 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12540 |     | <span class='neutral'>        }</span>
 12541 |     | <span class='neutral'>    }</span>
 12542 |     | <span class='neutral'></span>
 12543 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, address p2, bytes32 p3) internal pure {</span>
 12544 |     | <span class='neutral'>        bytes32 m0;</span>
 12545 |     | <span class='neutral'>        bytes32 m1;</span>
 12546 |     | <span class='neutral'>        bytes32 m2;</span>
 12547 |     | <span class='neutral'>        bytes32 m3;</span>
 12548 |     | <span class='neutral'>        bytes32 m4;</span>
 12549 |     | <span class='neutral'>        bytes32 m5;</span>
 12550 |     | <span class='neutral'>        bytes32 m6;</span>
 12551 |     | <span class='neutral'>        bytes32 m7;</span>
 12552 |     | <span class='neutral'>        bytes32 m8;</span>
 12553 |     | <span class='neutral'>        bytes32 m9;</span>
 12554 |     | <span class='neutral'>        bytes32 m10;</span>
 12555 |     | <span class='neutral'>        assembly {</span>
 12556 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12557 |     | <span class='neutral'>                let length := 0</span>
 12558 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12559 |     | <span class='neutral'>                mstore(pos, length)</span>
 12560 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12561 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12562 |     | <span class='neutral'>            }</span>
 12563 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12564 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12565 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12566 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12567 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12568 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12569 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12570 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12571 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12572 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12573 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12574 |     | <span class='neutral'>            // Selector of `log(string,string,address,string)`.</span>
 12575 |     | <span class='neutral'>            mstore(0x00, 0xeb1bff80)</span>
 12576 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12577 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12578 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12579 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12580 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12581 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12582 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12583 |     | <span class='neutral'>        }</span>
 12584 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12585 |     | <span class='neutral'>        assembly {</span>
 12586 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12587 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12588 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12589 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12590 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12591 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12592 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12593 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12594 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12595 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12596 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12597 |     | <span class='neutral'>        }</span>
 12598 |     | <span class='neutral'>    }</span>
 12599 |     | <span class='neutral'></span>
 12600 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, address p3) internal pure {</span>
 12601 |     | <span class='neutral'>        bytes32 m0;</span>
 12602 |     | <span class='neutral'>        bytes32 m1;</span>
 12603 |     | <span class='neutral'>        bytes32 m2;</span>
 12604 |     | <span class='neutral'>        bytes32 m3;</span>
 12605 |     | <span class='neutral'>        bytes32 m4;</span>
 12606 |     | <span class='neutral'>        bytes32 m5;</span>
 12607 |     | <span class='neutral'>        bytes32 m6;</span>
 12608 |     | <span class='neutral'>        bytes32 m7;</span>
 12609 |     | <span class='neutral'>        bytes32 m8;</span>
 12610 |     | <span class='neutral'>        assembly {</span>
 12611 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12612 |     | <span class='neutral'>                let length := 0</span>
 12613 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12614 |     | <span class='neutral'>                mstore(pos, length)</span>
 12615 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12616 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12617 |     | <span class='neutral'>            }</span>
 12618 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12619 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12620 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12621 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12622 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12623 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12624 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12625 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12626 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12627 |     | <span class='neutral'>            // Selector of `log(string,string,bool,address)`.</span>
 12628 |     | <span class='neutral'>            mstore(0x00, 0xc371c7db)</span>
 12629 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12630 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12631 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12632 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12633 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12634 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12635 |     | <span class='neutral'>        }</span>
 12636 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12637 |     | <span class='neutral'>        assembly {</span>
 12638 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12639 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12640 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12641 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12642 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12643 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12644 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12645 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12646 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12647 |     | <span class='neutral'>        }</span>
 12648 |     | <span class='neutral'>    }</span>
 12649 |     | <span class='neutral'></span>
 12650 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bool p3) internal pure {</span>
 12651 |     | <span class='neutral'>        bytes32 m0;</span>
 12652 |     | <span class='neutral'>        bytes32 m1;</span>
 12653 |     | <span class='neutral'>        bytes32 m2;</span>
 12654 |     | <span class='neutral'>        bytes32 m3;</span>
 12655 |     | <span class='neutral'>        bytes32 m4;</span>
 12656 |     | <span class='neutral'>        bytes32 m5;</span>
 12657 |     | <span class='neutral'>        bytes32 m6;</span>
 12658 |     | <span class='neutral'>        bytes32 m7;</span>
 12659 |     | <span class='neutral'>        bytes32 m8;</span>
 12660 |     | <span class='neutral'>        assembly {</span>
 12661 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12662 |     | <span class='neutral'>                let length := 0</span>
 12663 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12664 |     | <span class='neutral'>                mstore(pos, length)</span>
 12665 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12666 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12667 |     | <span class='neutral'>            }</span>
 12668 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12669 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12670 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12671 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12672 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12673 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12674 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12675 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12676 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12677 |     | <span class='neutral'>            // Selector of `log(string,string,bool,bool)`.</span>
 12678 |     | <span class='neutral'>            mstore(0x00, 0x40785869)</span>
 12679 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12680 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12681 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12682 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12683 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12684 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12685 |     | <span class='neutral'>        }</span>
 12686 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12687 |     | <span class='neutral'>        assembly {</span>
 12688 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12689 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12690 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12691 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12692 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12693 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12694 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12695 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12696 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12697 |     | <span class='neutral'>        }</span>
 12698 |     | <span class='neutral'>    }</span>
 12699 |     | <span class='neutral'></span>
 12700 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, uint256 p3) internal pure {</span>
 12701 |     | <span class='neutral'>        bytes32 m0;</span>
 12702 |     | <span class='neutral'>        bytes32 m1;</span>
 12703 |     | <span class='neutral'>        bytes32 m2;</span>
 12704 |     | <span class='neutral'>        bytes32 m3;</span>
 12705 |     | <span class='neutral'>        bytes32 m4;</span>
 12706 |     | <span class='neutral'>        bytes32 m5;</span>
 12707 |     | <span class='neutral'>        bytes32 m6;</span>
 12708 |     | <span class='neutral'>        bytes32 m7;</span>
 12709 |     | <span class='neutral'>        bytes32 m8;</span>
 12710 |     | <span class='neutral'>        assembly {</span>
 12711 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12712 |     | <span class='neutral'>                let length := 0</span>
 12713 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12714 |     | <span class='neutral'>                mstore(pos, length)</span>
 12715 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12716 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12717 |     | <span class='neutral'>            }</span>
 12718 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12719 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12720 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12721 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12722 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12723 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12724 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12725 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12726 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12727 |     | <span class='neutral'>            // Selector of `log(string,string,bool,uint256)`.</span>
 12728 |     | <span class='neutral'>            mstore(0x00, 0xd6aefad2)</span>
 12729 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12730 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12731 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12732 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12733 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12734 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12735 |     | <span class='neutral'>        }</span>
 12736 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12737 |     | <span class='neutral'>        assembly {</span>
 12738 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12739 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12740 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12741 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12742 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12743 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12744 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12745 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12746 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12747 |     | <span class='neutral'>        }</span>
 12748 |     | <span class='neutral'>    }</span>
 12749 |     | <span class='neutral'></span>
 12750 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bool p2, bytes32 p3) internal pure {</span>
 12751 |     | <span class='neutral'>        bytes32 m0;</span>
 12752 |     | <span class='neutral'>        bytes32 m1;</span>
 12753 |     | <span class='neutral'>        bytes32 m2;</span>
 12754 |     | <span class='neutral'>        bytes32 m3;</span>
 12755 |     | <span class='neutral'>        bytes32 m4;</span>
 12756 |     | <span class='neutral'>        bytes32 m5;</span>
 12757 |     | <span class='neutral'>        bytes32 m6;</span>
 12758 |     | <span class='neutral'>        bytes32 m7;</span>
 12759 |     | <span class='neutral'>        bytes32 m8;</span>
 12760 |     | <span class='neutral'>        bytes32 m9;</span>
 12761 |     | <span class='neutral'>        bytes32 m10;</span>
 12762 |     | <span class='neutral'>        assembly {</span>
 12763 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12764 |     | <span class='neutral'>                let length := 0</span>
 12765 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12766 |     | <span class='neutral'>                mstore(pos, length)</span>
 12767 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12768 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12769 |     | <span class='neutral'>            }</span>
 12770 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12771 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12772 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12773 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12774 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12775 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12776 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12777 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12778 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12779 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12780 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12781 |     | <span class='neutral'>            // Selector of `log(string,string,bool,string)`.</span>
 12782 |     | <span class='neutral'>            mstore(0x00, 0x5e84b0ea)</span>
 12783 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12784 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12785 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12786 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12787 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12788 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12789 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12790 |     | <span class='neutral'>        }</span>
 12791 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12792 |     | <span class='neutral'>        assembly {</span>
 12793 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12794 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12795 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12796 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12797 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12798 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12799 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12800 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12801 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12802 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 12803 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 12804 |     | <span class='neutral'>        }</span>
 12805 |     | <span class='neutral'>    }</span>
 12806 |     | <span class='neutral'></span>
 12807 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, address p3) internal pure {</span>
 12808 |     | <span class='neutral'>        bytes32 m0;</span>
 12809 |     | <span class='neutral'>        bytes32 m1;</span>
 12810 |     | <span class='neutral'>        bytes32 m2;</span>
 12811 |     | <span class='neutral'>        bytes32 m3;</span>
 12812 |     | <span class='neutral'>        bytes32 m4;</span>
 12813 |     | <span class='neutral'>        bytes32 m5;</span>
 12814 |     | <span class='neutral'>        bytes32 m6;</span>
 12815 |     | <span class='neutral'>        bytes32 m7;</span>
 12816 |     | <span class='neutral'>        bytes32 m8;</span>
 12817 |     | <span class='neutral'>        assembly {</span>
 12818 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12819 |     | <span class='neutral'>                let length := 0</span>
 12820 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12821 |     | <span class='neutral'>                mstore(pos, length)</span>
 12822 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12823 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12824 |     | <span class='neutral'>            }</span>
 12825 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12826 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12827 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12828 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12829 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12830 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12831 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12832 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12833 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12834 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,address)`.</span>
 12835 |     | <span class='neutral'>            mstore(0x00, 0x1023f7b2)</span>
 12836 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12837 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12838 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12839 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12840 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12841 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12842 |     | <span class='neutral'>        }</span>
 12843 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12844 |     | <span class='neutral'>        assembly {</span>
 12845 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12846 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12847 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12848 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12849 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12850 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12851 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12852 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12853 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12854 |     | <span class='neutral'>        }</span>
 12855 |     | <span class='neutral'>    }</span>
 12856 |     | <span class='neutral'></span>
 12857 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bool p3) internal pure {</span>
 12858 |     | <span class='neutral'>        bytes32 m0;</span>
 12859 |     | <span class='neutral'>        bytes32 m1;</span>
 12860 |     | <span class='neutral'>        bytes32 m2;</span>
 12861 |     | <span class='neutral'>        bytes32 m3;</span>
 12862 |     | <span class='neutral'>        bytes32 m4;</span>
 12863 |     | <span class='neutral'>        bytes32 m5;</span>
 12864 |     | <span class='neutral'>        bytes32 m6;</span>
 12865 |     | <span class='neutral'>        bytes32 m7;</span>
 12866 |     | <span class='neutral'>        bytes32 m8;</span>
 12867 |     | <span class='neutral'>        assembly {</span>
 12868 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12869 |     | <span class='neutral'>                let length := 0</span>
 12870 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12871 |     | <span class='neutral'>                mstore(pos, length)</span>
 12872 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12873 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12874 |     | <span class='neutral'>            }</span>
 12875 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12876 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12877 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12878 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12879 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12880 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12881 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12882 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12883 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12884 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,bool)`.</span>
 12885 |     | <span class='neutral'>            mstore(0x00, 0xc3a8a654)</span>
 12886 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12887 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12888 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12889 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12890 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12891 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12892 |     | <span class='neutral'>        }</span>
 12893 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12894 |     | <span class='neutral'>        assembly {</span>
 12895 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12896 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12897 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12898 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12899 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12900 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12901 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12902 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12903 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12904 |     | <span class='neutral'>        }</span>
 12905 |     | <span class='neutral'>    }</span>
 12906 |     | <span class='neutral'></span>
 12907 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, uint256 p3) internal pure {</span>
 12908 |     | <span class='neutral'>        bytes32 m0;</span>
 12909 |     | <span class='neutral'>        bytes32 m1;</span>
 12910 |     | <span class='neutral'>        bytes32 m2;</span>
 12911 |     | <span class='neutral'>        bytes32 m3;</span>
 12912 |     | <span class='neutral'>        bytes32 m4;</span>
 12913 |     | <span class='neutral'>        bytes32 m5;</span>
 12914 |     | <span class='neutral'>        bytes32 m6;</span>
 12915 |     | <span class='neutral'>        bytes32 m7;</span>
 12916 |     | <span class='neutral'>        bytes32 m8;</span>
 12917 |     | <span class='neutral'>        assembly {</span>
 12918 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12919 |     | <span class='neutral'>                let length := 0</span>
 12920 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12921 |     | <span class='neutral'>                mstore(pos, length)</span>
 12922 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12923 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12924 |     | <span class='neutral'>            }</span>
 12925 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12926 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12927 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12928 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12929 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12930 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12931 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12932 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12933 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12934 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,uint256)`.</span>
 12935 |     | <span class='neutral'>            mstore(0x00, 0xf45d7d2c)</span>
 12936 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12937 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12938 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12939 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 12940 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12941 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12942 |     | <span class='neutral'>        }</span>
 12943 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x104);</span>
 12944 |     | <span class='neutral'>        assembly {</span>
 12945 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 12946 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 12947 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 12948 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 12949 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 12950 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 12951 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 12952 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 12953 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 12954 |     | <span class='neutral'>        }</span>
 12955 |     | <span class='neutral'>    }</span>
 12956 |     | <span class='neutral'></span>
 12957 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, uint256 p2, bytes32 p3) internal pure {</span>
 12958 |     | <span class='neutral'>        bytes32 m0;</span>
 12959 |     | <span class='neutral'>        bytes32 m1;</span>
 12960 |     | <span class='neutral'>        bytes32 m2;</span>
 12961 |     | <span class='neutral'>        bytes32 m3;</span>
 12962 |     | <span class='neutral'>        bytes32 m4;</span>
 12963 |     | <span class='neutral'>        bytes32 m5;</span>
 12964 |     | <span class='neutral'>        bytes32 m6;</span>
 12965 |     | <span class='neutral'>        bytes32 m7;</span>
 12966 |     | <span class='neutral'>        bytes32 m8;</span>
 12967 |     | <span class='neutral'>        bytes32 m9;</span>
 12968 |     | <span class='neutral'>        bytes32 m10;</span>
 12969 |     | <span class='neutral'>        assembly {</span>
 12970 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 12971 |     | <span class='neutral'>                let length := 0</span>
 12972 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 12973 |     | <span class='neutral'>                mstore(pos, length)</span>
 12974 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 12975 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 12976 |     | <span class='neutral'>            }</span>
 12977 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 12978 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 12979 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 12980 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 12981 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 12982 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 12983 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 12984 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 12985 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 12986 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 12987 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 12988 |     | <span class='neutral'>            // Selector of `log(string,string,uint256,string)`.</span>
 12989 |     | <span class='neutral'>            mstore(0x00, 0x5d1a971a)</span>
 12990 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 12991 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 12992 |     | <span class='neutral'>            mstore(0x60, p2)</span>
 12993 |     | <span class='neutral'>            mstore(0x80, 0x100)</span>
 12994 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 12995 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 12996 |     | <span class='neutral'>            writeString(0x120, p3)</span>
 12997 |     | <span class='neutral'>        }</span>
 12998 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 12999 |     | <span class='neutral'>        assembly {</span>
 13000 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13001 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13002 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13003 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13004 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13005 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13006 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13007 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13008 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13009 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13010 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13011 |     | <span class='neutral'>        }</span>
 13012 |     | <span class='neutral'>    }</span>
 13013 |     | <span class='neutral'></span>
 13014 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, address p3) internal pure {</span>
 13015 |     | <span class='neutral'>        bytes32 m0;</span>
 13016 |     | <span class='neutral'>        bytes32 m1;</span>
 13017 |     | <span class='neutral'>        bytes32 m2;</span>
 13018 |     | <span class='neutral'>        bytes32 m3;</span>
 13019 |     | <span class='neutral'>        bytes32 m4;</span>
 13020 |     | <span class='neutral'>        bytes32 m5;</span>
 13021 |     | <span class='neutral'>        bytes32 m6;</span>
 13022 |     | <span class='neutral'>        bytes32 m7;</span>
 13023 |     | <span class='neutral'>        bytes32 m8;</span>
 13024 |     | <span class='neutral'>        bytes32 m9;</span>
 13025 |     | <span class='neutral'>        bytes32 m10;</span>
 13026 |     | <span class='neutral'>        assembly {</span>
 13027 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13028 |     | <span class='neutral'>                let length := 0</span>
 13029 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13030 |     | <span class='neutral'>                mstore(pos, length)</span>
 13031 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13032 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13033 |     | <span class='neutral'>            }</span>
 13034 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13035 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13036 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13037 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13038 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13039 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13040 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13041 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13042 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13043 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13044 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13045 |     | <span class='neutral'>            // Selector of `log(string,string,string,address)`.</span>
 13046 |     | <span class='neutral'>            mstore(0x00, 0x6d572f44)</span>
 13047 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13048 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13049 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13050 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13051 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13052 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13053 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13054 |     | <span class='neutral'>        }</span>
 13055 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13056 |     | <span class='neutral'>        assembly {</span>
 13057 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13058 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13059 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13060 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13061 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13062 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13063 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13064 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13065 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13066 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13067 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13068 |     | <span class='neutral'>        }</span>
 13069 |     | <span class='neutral'>    }</span>
 13070 |     | <span class='neutral'></span>
 13071 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bool p3) internal pure {</span>
 13072 |     | <span class='neutral'>        bytes32 m0;</span>
 13073 |     | <span class='neutral'>        bytes32 m1;</span>
 13074 |     | <span class='neutral'>        bytes32 m2;</span>
 13075 |     | <span class='neutral'>        bytes32 m3;</span>
 13076 |     | <span class='neutral'>        bytes32 m4;</span>
 13077 |     | <span class='neutral'>        bytes32 m5;</span>
 13078 |     | <span class='neutral'>        bytes32 m6;</span>
 13079 |     | <span class='neutral'>        bytes32 m7;</span>
 13080 |     | <span class='neutral'>        bytes32 m8;</span>
 13081 |     | <span class='neutral'>        bytes32 m9;</span>
 13082 |     | <span class='neutral'>        bytes32 m10;</span>
 13083 |     | <span class='neutral'>        assembly {</span>
 13084 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13085 |     | <span class='neutral'>                let length := 0</span>
 13086 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13087 |     | <span class='neutral'>                mstore(pos, length)</span>
 13088 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13089 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13090 |     | <span class='neutral'>            }</span>
 13091 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13092 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13093 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13094 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13095 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13096 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13097 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13098 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13099 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13100 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13101 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13102 |     | <span class='neutral'>            // Selector of `log(string,string,string,bool)`.</span>
 13103 |     | <span class='neutral'>            mstore(0x00, 0x2c1754ed)</span>
 13104 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13105 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13106 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13107 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13108 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13109 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13110 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13111 |     | <span class='neutral'>        }</span>
 13112 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13113 |     | <span class='neutral'>        assembly {</span>
 13114 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13115 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13116 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13117 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13118 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13119 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13120 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13121 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13122 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13123 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13124 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13125 |     | <span class='neutral'>        }</span>
 13126 |     | <span class='neutral'>    }</span>
 13127 |     | <span class='neutral'></span>
 13128 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, uint256 p3) internal pure {</span>
 13129 |     | <span class='neutral'>        bytes32 m0;</span>
 13130 |     | <span class='neutral'>        bytes32 m1;</span>
 13131 |     | <span class='neutral'>        bytes32 m2;</span>
 13132 |     | <span class='neutral'>        bytes32 m3;</span>
 13133 |     | <span class='neutral'>        bytes32 m4;</span>
 13134 |     | <span class='neutral'>        bytes32 m5;</span>
 13135 |     | <span class='neutral'>        bytes32 m6;</span>
 13136 |     | <span class='neutral'>        bytes32 m7;</span>
 13137 |     | <span class='neutral'>        bytes32 m8;</span>
 13138 |     | <span class='neutral'>        bytes32 m9;</span>
 13139 |     | <span class='neutral'>        bytes32 m10;</span>
 13140 |     | <span class='neutral'>        assembly {</span>
 13141 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13142 |     | <span class='neutral'>                let length := 0</span>
 13143 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13144 |     | <span class='neutral'>                mstore(pos, length)</span>
 13145 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13146 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13147 |     | <span class='neutral'>            }</span>
 13148 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13149 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13150 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13151 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13152 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13153 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13154 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13155 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13156 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13157 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13158 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13159 |     | <span class='neutral'>            // Selector of `log(string,string,string,uint256)`.</span>
 13160 |     | <span class='neutral'>            mstore(0x00, 0x8eafb02b)</span>
 13161 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13162 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13163 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13164 |     | <span class='neutral'>            mstore(0x80, p3)</span>
 13165 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13166 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13167 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13168 |     | <span class='neutral'>        }</span>
 13169 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x144);</span>
 13170 |     | <span class='neutral'>        assembly {</span>
 13171 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13172 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13173 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13174 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13175 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13176 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13177 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13178 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13179 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13180 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13181 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13182 |     | <span class='neutral'>        }</span>
 13183 |     | <span class='neutral'>    }</span>
 13184 |     | <span class='neutral'></span>
 13185 |     | <span class='neutral'>    function log(bytes32 p0, bytes32 p1, bytes32 p2, bytes32 p3) internal pure {</span>
 13186 |     | <span class='neutral'>        bytes32 m0;</span>
 13187 |     | <span class='neutral'>        bytes32 m1;</span>
 13188 |     | <span class='neutral'>        bytes32 m2;</span>
 13189 |     | <span class='neutral'>        bytes32 m3;</span>
 13190 |     | <span class='neutral'>        bytes32 m4;</span>
 13191 |     | <span class='neutral'>        bytes32 m5;</span>
 13192 |     | <span class='neutral'>        bytes32 m6;</span>
 13193 |     | <span class='neutral'>        bytes32 m7;</span>
 13194 |     | <span class='neutral'>        bytes32 m8;</span>
 13195 |     | <span class='neutral'>        bytes32 m9;</span>
 13196 |     | <span class='neutral'>        bytes32 m10;</span>
 13197 |     | <span class='neutral'>        bytes32 m11;</span>
 13198 |     | <span class='neutral'>        bytes32 m12;</span>
 13199 |     | <span class='neutral'>        assembly {</span>
 13200 |     | <span class='neutral'>            function writeString(pos, w) {</span>
 13201 |     | <span class='neutral'>                let length := 0</span>
 13202 |     | <span class='neutral'>                for {} lt(length, 0x20) { length := add(length, 1) } { if iszero(byte(length, w)) { break } }</span>
 13203 |     | <span class='neutral'>                mstore(pos, length)</span>
 13204 |     | <span class='neutral'>                let shift := sub(256, shl(3, length))</span>
 13205 |     | <span class='neutral'>                mstore(add(pos, 0x20), shl(shift, shr(shift, w)))</span>
 13206 |     | <span class='neutral'>            }</span>
 13207 |     | <span class='neutral'>            m0 := mload(0x00)</span>
 13208 |     | <span class='neutral'>            m1 := mload(0x20)</span>
 13209 |     | <span class='neutral'>            m2 := mload(0x40)</span>
 13210 |     | <span class='neutral'>            m3 := mload(0x60)</span>
 13211 |     | <span class='neutral'>            m4 := mload(0x80)</span>
 13212 |     | <span class='neutral'>            m5 := mload(0xa0)</span>
 13213 |     | <span class='neutral'>            m6 := mload(0xc0)</span>
 13214 |     | <span class='neutral'>            m7 := mload(0xe0)</span>
 13215 |     | <span class='neutral'>            m8 := mload(0x100)</span>
 13216 |     | <span class='neutral'>            m9 := mload(0x120)</span>
 13217 |     | <span class='neutral'>            m10 := mload(0x140)</span>
 13218 |     | <span class='neutral'>            m11 := mload(0x160)</span>
 13219 |     | <span class='neutral'>            m12 := mload(0x180)</span>
 13220 |     | <span class='neutral'>            // Selector of `log(string,string,string,string)`.</span>
 13221 |     | <span class='neutral'>            mstore(0x00, 0xde68f20a)</span>
 13222 |     | <span class='neutral'>            mstore(0x20, 0x80)</span>
 13223 |     | <span class='neutral'>            mstore(0x40, 0xc0)</span>
 13224 |     | <span class='neutral'>            mstore(0x60, 0x100)</span>
 13225 |     | <span class='neutral'>            mstore(0x80, 0x140)</span>
 13226 |     | <span class='neutral'>            writeString(0xa0, p0)</span>
 13227 |     | <span class='neutral'>            writeString(0xe0, p1)</span>
 13228 |     | <span class='neutral'>            writeString(0x120, p2)</span>
 13229 |     | <span class='neutral'>            writeString(0x160, p3)</span>
 13230 |     | <span class='neutral'>        }</span>
 13231 |     | <span class='neutral'>        _sendLogPayload(0x1c, 0x184);</span>
 13232 |     | <span class='neutral'>        assembly {</span>
 13233 |     | <span class='neutral'>            mstore(0x00, m0)</span>
 13234 |     | <span class='neutral'>            mstore(0x20, m1)</span>
 13235 |     | <span class='neutral'>            mstore(0x40, m2)</span>
 13236 |     | <span class='neutral'>            mstore(0x60, m3)</span>
 13237 |     | <span class='neutral'>            mstore(0x80, m4)</span>
 13238 |     | <span class='neutral'>            mstore(0xa0, m5)</span>
 13239 |     | <span class='neutral'>            mstore(0xc0, m6)</span>
 13240 |     | <span class='neutral'>            mstore(0xe0, m7)</span>
 13241 |     | <span class='neutral'>            mstore(0x100, m8)</span>
 13242 |     | <span class='neutral'>            mstore(0x120, m9)</span>
 13243 |     | <span class='neutral'>            mstore(0x140, m10)</span>
 13244 |     | <span class='neutral'>            mstore(0x160, m11)</span>
 13245 |     | <span class='neutral'>            mstore(0x180, m12)</span>
 13246 |     | <span class='neutral'>        }</span>
 13247 |     | <span class='neutral'>    }</span>
 13248 |     | <span class='neutral'>}</span>
 13249 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/FuzzBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Fuzzlib} from &quot;./Fuzzlib.sol&quot;;</span>
  5 |     | <span class='neutral'>import {PlatformCrytic} from &quot;./platform/PlatformCrytic.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>abstract contract FuzzBase {</span>
  8 |     | <span class='unexecuted'>    Fuzzlib internal fl = new Fuzzlib();</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    constructor() {</span>
 11 |     | <span class='unexecuted'>        fl.setPlatform(address(new PlatformCrytic()));</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/FuzzLibString.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Efficient library for creating string representations of integers.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/transmissions11/solmate/blob/main/src/utils/LibString.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from Solady (https://github.com/Vectorized/solady/blob/main/src/utils/LibString.sol)</span>
   7 |     | <span class='neutral'>/// @author Modified from Crytic Properties (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='unexecuted'>library FuzzLibString {</span>
   9 |     | <span class='neutral'>    bytes16 internal constant HEX_DIGITS = &quot;0123456789abcdef&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>    function toString(int256 value) internal pure returns (string memory str) {</span>
  12 |     | <span class='unexecuted'>        uint256 absValue = value &gt;= 0 ? uint256(value) : uint256(-value);</span>
  13 |     | <span class='unexecuted'>        str = toString(absValue);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>        if (value &lt; 0) {</span>
  16 |     | <span class='unexecuted'>            str = string(abi.encodePacked(&quot;-&quot;, str));</span>
  17 |     | <span class='neutral'>        }</span>
  18 |     | <span class='neutral'>    }</span>
  19 |     | <span class='neutral'></span>
  20 | *   | <span class='executed'>    function toString(uint256 value) internal pure returns (string memory str) {</span>
  21 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  22 |     | <span class='neutral'>        assembly {</span>
  23 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but we allocate 160 bytes</span>
  24 |     | <span class='neutral'>            // to keep the free memory pointer word aligned. We&#39;ll need 1 word for the length, 1 word for the</span>
  25 |     | <span class='neutral'>            // trailing zeros padding, and 3 other words for a max of 78 digits. In total: 5 * 32 = 160 bytes.</span>
  26 | *   | <span class='executed'>            let newFreeMemoryPointer := add(mload(0x40), 160)</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>            // Update the free memory pointer to avoid overriding our string.</span>
  29 | *   | <span class='executed'>            mstore(0x40, newFreeMemoryPointer)</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>            // Assign str to the end of the zone of newly allocated memory.</span>
  32 | *   | <span class='executed'>            str := sub(newFreeMemoryPointer, 32)</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>            // Clean the last word of memory it may not be overwritten.</span>
  35 | *   | <span class='executed'>            mstore(str, 0)</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
  38 | *   | <span class='executed'>            let end := str</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
  41 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
  42 |     | <span class='neutral'>            // prettier-ignore</span>
  43 | *   | <span class='executed'>            for { let temp := value } 1 {} {</span>
  44 |     | <span class='neutral'>                // Move the pointer 1 byte to the left.</span>
  45 | *   | <span class='executed'>                str := sub(str, 1)</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>                // Write the character to the pointer.</span>
  48 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
  49 | *   | <span class='executed'>                mstore8(str, add(48, mod(temp, 10)))</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>                // Keep dividing temp until zero.</span>
  52 | *   | <span class='executed'>                temp := div(temp, 10)</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>                 // prettier-ignore</span>
  55 | *   | <span class='executed'>                if iszero(temp) { break }</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>            // Compute and cache the final total length of the string.</span>
  59 | *   | <span class='executed'>            let length := sub(end, str)</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
  62 | *   | <span class='executed'>            str := sub(str, 32)</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>            // Store the string&#39;s length at the start of memory allocated for our string.</span>
  65 | *   | <span class='executed'>            mstore(str, length)</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>    function toString(address value) internal pure returns (string memory str) {</span>
  70 |     | <span class='unexecuted'>        bytes memory s = new bytes(40);</span>
  71 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; 20; i++) {</span>
  72 |     | <span class='unexecuted'>            bytes1 b = bytes1(</span>
  73 |     | <span class='unexecuted'>                uint8(uint256(uint160(value)) / (2**(8 * (19 - i))))</span>
  74 |     | <span class='neutral'>            );</span>
  75 |     | <span class='unexecuted'>            bytes1 hi = bytes1(uint8(b) / 16);</span>
  76 |     | <span class='unexecuted'>            bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));</span>
  77 |     | <span class='unexecuted'>            s[2 * i] = char(hi);</span>
  78 |     | <span class='unexecuted'>            s[2 * i + 1] = char(lo);</span>
  79 |     | <span class='neutral'>        }</span>
  80 |     | <span class='unexecuted'>        return string(s);</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 | *   | <span class='executed'>    function char(bytes1 b) internal pure returns (bytes1 c) {</span>
  84 | *   | <span class='executed'>        if (uint8(b) &lt; 10) return bytes1(uint8(b) + 0x30);</span>
  85 |     | <span class='unexecuted'>        else return bytes1(uint8(b) + 0x57);</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    // based on OZ&#39;s toHexString</span>
  89 |     | <span class='neutral'>    // https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Strings.sol</span>
  90 |     | <span class='unexecuted'>    function toHexString(bytes memory value)</span>
  91 |     | <span class='neutral'>        internal</span>
  92 |     | <span class='neutral'>        pure</span>
  93 |     | <span class='unexecuted'>        returns (string memory)</span>
  94 |     | <span class='neutral'>    {</span>
  95 |     | <span class='unexecuted'>        bytes memory buffer = new bytes(2 * value.length + 2);</span>
  96 |     | <span class='unexecuted'>        buffer[0] = &quot;0&quot;;</span>
  97 |     | <span class='unexecuted'>        buffer[1] = &quot;x&quot;;</span>
  98 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; value.length; i++) {</span>
  99 |     | <span class='unexecuted'>            uint8 valueByte = uint8(value[i]);</span>
 100 |     | <span class='unexecuted'>            buffer[2 * i + 2] = HEX_DIGITS[valueByte &gt;&gt; 4];</span>
 101 |     | <span class='unexecuted'>            buffer[2 * i + 3] = HEX_DIGITS[valueByte &amp; 0xf];</span>
 102 |     | <span class='neutral'>        }</span>
 103 |     | <span class='neutral'>        return string(buffer);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // https://ethereum.stackexchange.com/a/83577</span>
 107 |     | <span class='unexecuted'>    function getRevertMsg(bytes memory returnData)</span>
 108 |     | <span class='neutral'>        internal</span>
 109 |     | <span class='neutral'>        pure</span>
 110 |     | <span class='unexecuted'>        returns (string memory)</span>
 111 |     | <span class='neutral'>    {</span>
 112 |     | <span class='neutral'>        // Check that the data has the right size: 4 bytes for signature + 32 bytes for panic code</span>
 113 |     | <span class='unexecuted'>        if (returnData.length == 4 + 32) {</span>
 114 |     | <span class='neutral'>            // Check that the data starts with the Panic signature</span>
 115 |     | <span class='unexecuted'>            bytes4 panicSignature = bytes4(keccak256(bytes(&quot;Panic(uint256)&quot;)));</span>
 116 |     | <span class='unexecuted'>            for (uint256 i = 0; i &lt; 4; i++) {</span>
 117 |     | <span class='unexecuted'>                if (returnData[i] != panicSignature[i])</span>
 118 |     | <span class='unexecuted'>                    return &quot;Undefined signature&quot;;</span>
 119 |     | <span class='neutral'>            }</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>            uint256 panicCode;</span>
 122 |     | <span class='unexecuted'>            for (uint256 i = 4; i &lt; 36; i++) {</span>
 123 |     | <span class='unexecuted'>                panicCode = panicCode &lt;&lt; 8;</span>
 124 |     | <span class='unexecuted'>                panicCode |= uint8(returnData[i]);</span>
 125 |     | <span class='neutral'>            }</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Now convert the panic code into its string representation</span>
 128 |     | <span class='unexecuted'>            if (panicCode == 17) {</span>
 129 |     | <span class='unexecuted'>                return &quot;Panic(17)&quot;;</span>
 130 |     | <span class='neutral'>            }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>            // Add other panic codes as needed or return a generic &quot;Unknown panic&quot;</span>
 133 |     | <span class='unexecuted'>            return &quot;Undefined panic code&quot;;</span>
 134 |     | <span class='neutral'>        }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        // If the returnData length is less than 68, then the transaction failed silently (without a revert message)</span>
 137 |     | <span class='unexecuted'>        if (returnData.length &lt; 68) return &quot;Transaction reverted silently&quot;;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        assembly {</span>
 140 |     | <span class='neutral'>            // Slice the sighash.</span>
 141 |     | <span class='unexecuted'>            returnData := add(returnData, 0x04)</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='unexecuted'>        return abi.decode(returnData, (string)); // All that remains is the revert string</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='unexecuted'>    function isRevertReasonEqual(bytes memory returnData, string memory reason)</span>
 147 |     | <span class='neutral'>        internal</span>
 148 |     | <span class='neutral'>        pure</span>
 149 |     | <span class='unexecuted'>        returns (bool)</span>
 150 |     | <span class='neutral'>    {</span>
 151 |     | <span class='unexecuted'>        return (keccak256(abi.encodePacked(getRevertMsg(returnData))) ==</span>
 152 |     | <span class='unexecuted'>            keccak256(abi.encodePacked(reason)));</span>
 153 |     | <span class='neutral'>    }</span>
 154 |     | <span class='neutral'>}</span>
 155 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/Fuzzlib.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {HelperBase} from &quot;./helpers/HelperBase.sol&quot;;</span>
  5 |     | <span class='neutral'>import {HelperAssert} from &quot;./helpers/HelperAssert.sol&quot;;</span>
  6 |     | <span class='neutral'>import {HelperClamp} from &quot;./helpers/HelperClamp.sol&quot;;</span>
  7 |     | <span class='neutral'>import {HelperLog} from &quot;./helpers/HelperLog.sol&quot;;</span>
  8 |     | <span class='neutral'>import {HelperMath} from &quot;./helpers/HelperMath.sol&quot;;</span>
  9 |     | <span class='neutral'>import {HelperRandom} from &quot;./helpers/HelperRandom.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 | *   | <span class='executed'>contract Fuzzlib is</span>
 12 |     | <span class='neutral'>    HelperBase,</span>
 13 |     | <span class='neutral'>    HelperAssert,</span>
 14 |     | <span class='neutral'>    HelperClamp,</span>
 15 |     | <span class='neutral'>    HelperLog,</span>
 16 |     | <span class='neutral'>    HelperMath,</span>
 17 |     | <span class='neutral'>    HelperRandom</span>
 18 |     | <span class='neutral'>{}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperAssert.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;./HelperBase.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../FuzzLibString.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   9 |     | <span class='neutral'>abstract contract HelperAssert is HelperBase {</span>
  10 |     | <span class='neutral'>    event AssertFail(string);</span>
  11 |     | <span class='neutral'>    event AssertEqFail(string);</span>
  12 |     | <span class='neutral'>    event AssertNeqFail(string);</span>
  13 |     | <span class='neutral'>    event AssertGteFail(string);</span>
  14 |     | <span class='neutral'>    event AssertGtFail(string);</span>
  15 |     | <span class='neutral'>    event AssertLteFail(string);</span>
  16 |     | <span class='neutral'>    event AssertLtFail(string);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    function t(bool b, string memory reason) public {</span>
  19 |     | <span class='unexecuted'>        if (!b) {</span>
  20 |     | <span class='unexecuted'>            emit AssertFail(reason);</span>
  21 |     | <span class='unexecuted'>            platform.assertFail();</span>
  22 |     | <span class='neutral'>        }</span>
  23 |     | <span class='neutral'>    }</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    /// @notice asserts that a is equal to b. Violations are logged using reason.</span>
  26 |     | <span class='unexecuted'>    function eq(</span>
  27 |     | <span class='neutral'>        uint256 a,</span>
  28 |     | <span class='neutral'>        uint256 b,</span>
  29 |     | <span class='neutral'>        string memory reason</span>
  30 |     | <span class='neutral'>    ) public {</span>
  31 |     | <span class='unexecuted'>        if (a != b) {</span>
  32 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  33 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  34 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  35 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  36 |     | <span class='neutral'>            platform.assertFail();</span>
  37 |     | <span class='neutral'>        }</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice int256 version of eq</span>
  41 |     | <span class='unexecuted'>    function eq(</span>
  42 |     | <span class='neutral'>        int256 a,</span>
  43 |     | <span class='neutral'>        int256 b,</span>
  44 |     | <span class='neutral'>        string memory reason</span>
  45 |     | <span class='neutral'>    ) public {</span>
  46 |     | <span class='unexecuted'>        if (a != b) {</span>
  47 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  48 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  49 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  50 |     | <span class='unexecuted'>           emit AssertEqFail(assertMsg);</span>
  51 |     | <span class='neutral'>            platform.assertFail();</span>
  52 |     | <span class='neutral'>        }</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice bool version of eq</span>
  56 |     | <span class='unexecuted'>    function eq(</span>
  57 |     | <span class='neutral'>        bool a,</span>
  58 |     | <span class='neutral'>        bool b,</span>
  59 |     | <span class='neutral'>        string memory reason</span>
  60 |     | <span class='neutral'>    ) public {</span>
  61 |     | <span class='unexecuted'>        if (a != b) {</span>
  62 |     | <span class='unexecuted'>            string memory aStr = a ? &quot;true&quot; : &quot;false&quot;;</span>
  63 |     | <span class='unexecuted'>            string memory bStr = b ? &quot;true&quot; : &quot;false&quot;;</span>
  64 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  65 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  66 |     | <span class='neutral'>            platform.assertFail();</span>
  67 |     | <span class='neutral'>        }</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice address version of eq</span>
  71 |     | <span class='unexecuted'>    function eq(</span>
  72 |     | <span class='neutral'>        address a,</span>
  73 |     | <span class='neutral'>        address b,</span>
  74 |     | <span class='neutral'>        string memory reason</span>
  75 |     | <span class='neutral'>    ) public {</span>
  76 |     | <span class='unexecuted'>        if (a != b) {</span>
  77 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
  78 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
  79 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  80 |     | <span class='neutral'>            emit AssertEqFail(assertMsg);</span>
  81 |     | <span class='neutral'>            platform.assertFail();</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice bytes4 version of eq</span>
  86 |     | <span class='unexecuted'>    function eq(</span>
  87 |     | <span class='neutral'>        bytes4 a,</span>
  88 |     | <span class='neutral'>        bytes4 b,</span>
  89 |     | <span class='neutral'>        string memory reason</span>
  90 |     | <span class='neutral'>    ) public {</span>
  91 |     | <span class='unexecuted'>        if (a != b) {</span>
  92 |     | <span class='unexecuted'>            bytes memory aBytes = abi.encodePacked(a);</span>
  93 |     | <span class='unexecuted'>            bytes memory bBytes = abi.encodePacked(b);</span>
  94 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toHexString(aBytes);</span>
  95 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toHexString(bBytes);</span>
  96 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;!=&quot;, reason);</span>
  97 |     | <span class='unexecuted'>            emit AssertEqFail(assertMsg);</span>
  98 |     | <span class='unexecuted'>            platform.assertFail();</span>
  99 |     | <span class='neutral'>        }</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    /// @notice asserts that a is not equal to b. Violations are logged using reason.</span>
 103 |     | <span class='unexecuted'>    function neq(</span>
 104 |     | <span class='neutral'>        uint256 a,</span>
 105 |     | <span class='neutral'>        uint256 b,</span>
 106 |     | <span class='neutral'>        string memory reason</span>
 107 |     | <span class='neutral'>    ) public {</span>
 108 |     | <span class='unexecuted'>        if (a == b) {</span>
 109 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 110 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 111 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;==&quot;, reason);</span>
 112 |     | <span class='unexecuted'>            emit AssertNeqFail(assertMsg);</span>
 113 |     | <span class='neutral'>            platform.assertFail();</span>
 114 |     | <span class='neutral'>        }</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /// @notice int256 version of neq</span>
 118 |     | <span class='unexecuted'>    function neq(</span>
 119 |     | <span class='neutral'>        int256 a,</span>
 120 |     | <span class='neutral'>        int256 b,</span>
 121 |     | <span class='neutral'>        string memory reason</span>
 122 |     | <span class='neutral'>    ) public {</span>
 123 |     | <span class='unexecuted'>        if (a == b) {</span>
 124 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 125 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 126 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;==&quot;, reason);</span>
 127 |     | <span class='neutral'>            emit AssertNeqFail(assertMsg);</span>
 128 |     | <span class='neutral'>            platform.assertFail();</span>
 129 |     | <span class='neutral'>        }</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @notice asserts that a is greater than or equal to b. Violations are logged using reason.</span>
 133 |     | <span class='unexecuted'>    function gte(</span>
 134 |     | <span class='neutral'>        uint256 a,</span>
 135 |     | <span class='neutral'>        uint256 b,</span>
 136 |     | <span class='neutral'>        string memory reason</span>
 137 |     | <span class='neutral'>    ) public {</span>
 138 |     | <span class='unexecuted'>        if (!(a &gt;= b)) {</span>
 139 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 140 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 141 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;&quot;, reason);</span>
 142 |     | <span class='neutral'>            emit AssertGteFail(assertMsg);</span>
 143 |     | <span class='neutral'>            platform.assertFail();</span>
 144 |     | <span class='neutral'>        }</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @notice int256 version of gte</span>
 148 |     | <span class='unexecuted'>    function gte(</span>
 149 |     | <span class='neutral'>        int256 a,</span>
 150 |     | <span class='neutral'>        int256 b,</span>
 151 |     | <span class='neutral'>        string memory reason</span>
 152 |     | <span class='neutral'>    ) public {</span>
 153 |     | <span class='unexecuted'>        if (!(a &gt;= b)) {</span>
 154 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 155 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 156 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;&quot;, reason);</span>
 157 |     | <span class='unexecuted'>            emit AssertGteFail(assertMsg);</span>
 158 |     | <span class='neutral'>            platform.assertFail();</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>    }</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /// @notice asserts that a is greater than b. Violations are logged using reason.</span>
 163 |     | <span class='unexecuted'>    function gt(</span>
 164 |     | <span class='neutral'>        uint256 a,</span>
 165 |     | <span class='neutral'>        uint256 b,</span>
 166 |     | <span class='neutral'>        string memory reason</span>
 167 |     | <span class='neutral'>    ) public {</span>
 168 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 169 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 170 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 171 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;=&quot;, reason);</span>
 172 |     | <span class='unexecuted'>            emit AssertGtFail(assertMsg);</span>
 173 |     | <span class='neutral'>            platform.assertFail();</span>
 174 |     | <span class='neutral'>        }</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /// @notice int256 version of gt</span>
 178 |     | <span class='unexecuted'>    function gt(</span>
 179 |     | <span class='neutral'>        int256 a,</span>
 180 |     | <span class='neutral'>        int256 b,</span>
 181 |     | <span class='neutral'>        string memory reason</span>
 182 |     | <span class='neutral'>    ) public {</span>
 183 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 184 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 185 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 186 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&lt;=&quot;, reason);</span>
 187 |     | <span class='neutral'>            emit AssertGtFail(assertMsg);</span>
 188 |     | <span class='neutral'>            platform.assertFail();</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /// @notice asserts that a is less than or equal to b. Violations are logged using reason.</span>
 193 |     | <span class='unexecuted'>    function lte(</span>
 194 |     | <span class='neutral'>        uint256 a,</span>
 195 |     | <span class='neutral'>        uint256 b,</span>
 196 |     | <span class='neutral'>        string memory reason</span>
 197 |     | <span class='neutral'>    ) public {</span>
 198 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 199 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 200 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 201 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;&quot;, reason);</span>
 202 |     | <span class='neutral'>            emit AssertLteFail(assertMsg);</span>
 203 |     | <span class='neutral'>            platform.assertFail();</span>
 204 |     | <span class='neutral'>        }</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    /// @notice int256 version of lte</span>
 208 |     | <span class='unexecuted'>    function lte(</span>
 209 |     | <span class='neutral'>        int256 a,</span>
 210 |     | <span class='neutral'>        int256 b,</span>
 211 |     | <span class='neutral'>        string memory reason</span>
 212 |     | <span class='neutral'>    ) public {</span>
 213 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 214 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 215 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 216 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;&quot;, reason);</span>
 217 |     | <span class='unexecuted'>            emit AssertLteFail(assertMsg);</span>
 218 |     | <span class='neutral'>            platform.assertFail();</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice asserts that a is less than b. Violations are logged using reason.</span>
 223 | *   | <span class='executed'>    function lt(</span>
 224 |     | <span class='neutral'>        uint256 a,</span>
 225 |     | <span class='neutral'>        uint256 b,</span>
 226 |     | <span class='neutral'>        string memory reason</span>
 227 |     | <span class='neutral'>    ) public {</span>
 228 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 229 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 230 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 231 |     | <span class='unexecuted'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;=&quot;, reason);</span>
 232 |     | <span class='unexecuted'>            emit AssertLtFail(assertMsg);</span>
 233 |     | <span class='unexecuted'>            platform.assertFail();</span>
 234 |     | <span class='neutral'>        }</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /// @notice int256 version of lt</span>
 238 |     | <span class='unexecuted'>    function lt(</span>
 239 |     | <span class='neutral'>        int256 a,</span>
 240 |     | <span class='neutral'>        int256 b,</span>
 241 |     | <span class='neutral'>        string memory reason</span>
 242 |     | <span class='neutral'>    ) public {</span>
 243 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 244 |     | <span class='unexecuted'>            string memory aStr = FuzzLibString.toString(a);</span>
 245 |     | <span class='unexecuted'>            string memory bStr = FuzzLibString.toString(b);</span>
 246 |     | <span class='neutral'>            string memory assertMsg = createAssertFailMessage(aStr, bStr, &quot;&gt;=&quot;, reason);</span>
 247 |     | <span class='neutral'>            emit AssertLtFail(assertMsg);</span>
 248 |     | <span class='neutral'>            platform.assertFail();</span>
 249 |     | <span class='neutral'>        }</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>    function assertRevertReasonNotEqual(</span>
 253 |     | <span class='neutral'>        bytes memory returnData,</span>
 254 |     | <span class='neutral'>        string memory reason</span>
 255 |     | <span class='neutral'>    ) public {</span>
 256 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 257 |     | <span class='unexecuted'>        t(!isEqual, reason);</span>
 258 |     | <span class='neutral'>    }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 261 |     | <span class='neutral'>        bytes memory returnData,</span>
 262 |     | <span class='neutral'>        string memory reason</span>
 263 |     | <span class='neutral'>    ) public {</span>
 264 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason);</span>
 265 |     | <span class='unexecuted'>        t(isEqual, reason);</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 269 |     | <span class='neutral'>        bytes memory returnData,</span>
 270 |     | <span class='neutral'>        string memory reason1,</span>
 271 |     | <span class='neutral'>        string memory reason2</span>
 272 |     | <span class='unexecuted'>    ) public {</span>
 273 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 274 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2);</span>
 275 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 276 |     | <span class='unexecuted'>            abi.encodePacked(reason1, &quot; OR &quot;, reason2)</span>
 277 |     | <span class='neutral'>        );</span>
 278 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 279 |     | <span class='neutral'>    }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 282 |     | <span class='neutral'>        bytes memory returnData,</span>
 283 |     | <span class='neutral'>        string memory reason1,</span>
 284 |     | <span class='neutral'>        string memory reason2,</span>
 285 |     | <span class='neutral'>        string memory reason3</span>
 286 |     | <span class='unexecuted'>    ) public {</span>
 287 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 288 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 289 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason3);</span>
 290 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 291 |     | <span class='unexecuted'>            abi.encodePacked(reason1, &quot; OR &quot;, reason2, &quot; OR &quot;, reason3)</span>
 292 |     | <span class='neutral'>        );</span>
 293 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 294 |     | <span class='neutral'>    }</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='unexecuted'>    function assertRevertReasonEqual(</span>
 297 |     | <span class='neutral'>        bytes memory returnData,</span>
 298 |     | <span class='neutral'>        string memory reason1,</span>
 299 |     | <span class='neutral'>        string memory reason2,</span>
 300 |     | <span class='neutral'>        string memory reason3,</span>
 301 |     | <span class='neutral'>        string memory reason4</span>
 302 |     | <span class='unexecuted'>    ) public {</span>
 303 |     | <span class='unexecuted'>        bool isEqual = FuzzLibString.isRevertReasonEqual(returnData, reason1) ||</span>
 304 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason2) ||</span>
 305 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason3) ||</span>
 306 |     | <span class='unexecuted'>            FuzzLibString.isRevertReasonEqual(returnData, reason4);</span>
 307 |     | <span class='unexecuted'>        string memory assertMsg = string(</span>
 308 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 309 |     | <span class='unexecuted'>                reason1,</span>
 310 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 311 |     | <span class='unexecuted'>                reason2,</span>
 312 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 313 |     | <span class='unexecuted'>                reason3,</span>
 314 |     | <span class='neutral'>                &quot; OR &quot;,</span>
 315 |     | <span class='unexecuted'>                reason4</span>
 316 |     | <span class='neutral'>            )</span>
 317 |     | <span class='neutral'>        );</span>
 318 |     | <span class='unexecuted'>        t(isEqual, assertMsg);</span>
 319 |     | <span class='neutral'>    }</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>    function errAllow(</span>
 322 |     | <span class='neutral'>        bytes4 errorSelector,</span>
 323 |     | <span class='neutral'>        bytes4[] memory allowedErrors,</span>
 324 |     | <span class='neutral'>        string memory message</span>
 325 |     | <span class='unexecuted'>    ) public {</span>
 326 |     | <span class='unexecuted'>        bool allowed = false;</span>
 327 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; allowedErrors.length; i++) {</span>
 328 |     | <span class='unexecuted'>            if (errorSelector == allowedErrors[i]) {</span>
 329 |     | <span class='unexecuted'>                allowed = true;</span>
 330 |     | <span class='unexecuted'>                break;</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='unexecuted'>        t(allowed, message);</span>
 334 |     | <span class='neutral'>    }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function errsAllow(</span>
 337 |     | <span class='neutral'>        bytes4 errorSelector,</span>
 338 |     | <span class='neutral'>        bytes4[] memory allowedErrors,</span>
 339 |     | <span class='neutral'>        string[] memory messages</span>
 340 |     | <span class='neutral'>    ) public {</span>
 341 |     | <span class='unexecuted'>        bool allowed = false;</span>
 342 |     | <span class='unexecuted'>        uint256 passIndex = 0;</span>
 343 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; allowedErrors.length; i++) {</span>
 344 |     | <span class='unexecuted'>            if (errorSelector == allowedErrors[i]) {</span>
 345 |     | <span class='unexecuted'>                allowed = true;</span>
 346 |     | <span class='unexecuted'>                passIndex = i;</span>
 347 |     | <span class='unexecuted'>                break;</span>
 348 |     | <span class='neutral'>            }</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='unexecuted'>        t(allowed, messages[passIndex]);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function createAssertFailMessage(string memory aStr, string memory bStr, string memory operator, string memory reason)internal pure returns (string memory) {</span>
 354 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Invalid: &quot;, aStr, operator, bStr, &quot;, reason: &quot;, reason));</span>
 355 |     | <span class='neutral'>    }</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>}</span>
 358 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperBase.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IPlatform} from &quot;../platform/IPlatform.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract HelperBase {</span>
  7 |     | <span class='unexecuted'>    IPlatform public platform;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function setPlatform(address _platform) public {</span>
 10 |     | <span class='unexecuted'>        platform = IPlatform(_platform);</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperClamp.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &quot;../FuzzLibString.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./HelperAssert.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @author Based on Crytic PropertiesHelper (https://github.com/crytic/properties/blob/main/contracts/util/PropertiesHelper.sol)</span>
   8 |     | <span class='neutral'>abstract contract HelperClamp is HelperAssert {</span>
   9 |     | <span class='neutral'>    event Clamped(string);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    /*</span>
  12 |     | <span class='neutral'>     **************************************************************************</span>
  13 |     | <span class='neutral'>     * Clamp functions with logging enabled</span>
  14 |     | <span class='neutral'>     **************************************************************************</span>
  15 |     | <span class='neutral'>     */</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  18 | *   | <span class='executed'>    function clamp(</span>
  19 |     | <span class='neutral'>        uint256 value,</span>
  20 |     | <span class='neutral'>        uint256 low,</span>
  21 |     | <span class='neutral'>        uint256 high</span>
  22 | *   | <span class='executed'>    ) public returns (uint256) {</span>
  23 | *   | <span class='executed'>        return clamp(value, low, high, true);</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /// @notice int256 version of clamp</span>
  27 |     | <span class='unexecuted'>    function clamp(</span>
  28 |     | <span class='neutral'>        int256 value,</span>
  29 |     | <span class='neutral'>        int256 low,</span>
  30 |     | <span class='neutral'>        int256 high</span>
  31 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
  32 |     | <span class='unexecuted'>        return clamp(value, low, high, true);</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
  36 |     | <span class='unexecuted'>    function clampLt(uint256 a, uint256 b) public returns (uint256) {</span>
  37 |     | <span class='unexecuted'>        return clampLt(a, b);</span>
  38 |     | <span class='neutral'>    }</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
  41 |     | <span class='unexecuted'>    function clampLt(int256 a, int256 b) public returns (int256) {</span>
  42 |     | <span class='unexecuted'>        return clampLt(a, b, true);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
  46 |     | <span class='unexecuted'>    function clampLte(uint256 a, uint256 b) public returns (uint256) {</span>
  47 |     | <span class='unexecuted'>        return clampLte(a, b, true);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
  51 |     | <span class='unexecuted'>    function clampLte(int256 a, int256 b) public returns (int256) {</span>
  52 |     | <span class='unexecuted'>        return clampLte(a, b, true);</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
  56 |     | <span class='unexecuted'>    function clampGt(uint256 a, uint256 b) public returns (uint256) {</span>
  57 |     | <span class='unexecuted'>        return clampGt(a, b, true);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
  61 |     | <span class='unexecuted'>    function clampGt(int256 a, int256 b) public returns (int256) {</span>
  62 |     | <span class='unexecuted'>        return clampGt(a, b, true);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
  66 |     | <span class='unexecuted'>    function clampGte(uint256 a, uint256 b) public returns (uint256) {</span>
  67 |     | <span class='unexecuted'>        return clampGte(a, b, true);</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
  71 |     | <span class='unexecuted'>    function clampGte(int256 a, int256 b) public returns (int256) {</span>
  72 |     | <span class='unexecuted'>        return clampGte(a, b, true);</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /*</span>
  76 |     | <span class='neutral'>     **************************************************************************</span>
  77 |     | <span class='neutral'>     * Clamp functions with optional logging</span>
  78 |     | <span class='neutral'>     **************************************************************************</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Clamps value to be between low and high, both inclusive</span>
  82 | *   | <span class='executed'>    function clamp(</span>
  83 |     | <span class='neutral'>        uint256 value,</span>
  84 |     | <span class='neutral'>        uint256 low,</span>
  85 |     | <span class='neutral'>        uint256 high,</span>
  86 |     | <span class='neutral'>        bool enableLogs</span>
  87 | *   | <span class='executed'>    ) public returns (uint256) {</span>
  88 | *   | <span class='executed'>        if (value &lt; low || value &gt; high) {</span>
  89 | *   | <span class='executed'>            uint256 ans = low + (value % (high - low + 1));</span>
  90 | *   | <span class='executed'>            if (enableLogs) {</span>
  91 | *   | <span class='executed'>                string memory valueStr = FuzzLibString.toString(value);</span>
  92 | *   | <span class='executed'>                string memory ansStr = FuzzLibString.toString(ans);</span>
  93 | *   | <span class='executed'>                bytes memory message = abi.encodePacked(</span>
  94 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
  95 | *   | <span class='executed'>                    valueStr,</span>
  96 |     | <span class='neutral'>                    &quot; to &quot;,</span>
  97 | *   | <span class='executed'>                    ansStr</span>
  98 |     | <span class='neutral'>                );</span>
  99 | *   | <span class='executed'>                emit Clamped(string(message));</span>
 100 |     | <span class='neutral'>            }</span>
 101 | *   | <span class='executed'>            return ans;</span>
 102 |     | <span class='neutral'>        }</span>
 103 | *   | <span class='executed'>        return value;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    /// @notice int256 version of clamp</span>
 107 |     | <span class='unexecuted'>    function clamp(</span>
 108 |     | <span class='neutral'>        int256 value,</span>
 109 |     | <span class='neutral'>        int256 low,</span>
 110 |     | <span class='neutral'>        int256 high,</span>
 111 |     | <span class='neutral'>        bool enableLogs</span>
 112 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 113 |     | <span class='unexecuted'>        if (value &lt; low || value &gt; high) {</span>
 114 |     | <span class='unexecuted'>            int256 range = high - low + 1;</span>
 115 |     | <span class='unexecuted'>            int256 clamped = (value - low) % (range);</span>
 116 |     | <span class='unexecuted'>            if (clamped &lt; 0) clamped += range;</span>
 117 |     | <span class='unexecuted'>            int256 ans = low + clamped;</span>
 118 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 119 |     | <span class='unexecuted'>                string memory valueStr = FuzzLibString.toString(value);</span>
 120 |     | <span class='unexecuted'>                string memory ansStr = FuzzLibString.toString(ans);</span>
 121 |     | <span class='unexecuted'>                bytes memory message = abi.encodePacked(</span>
 122 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 123 |     | <span class='unexecuted'>                    valueStr,</span>
 124 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 125 |     | <span class='unexecuted'>                    ansStr</span>
 126 |     | <span class='neutral'>                );</span>
 127 |     | <span class='unexecuted'>                emit Clamped(string(message));</span>
 128 |     | <span class='neutral'>            }</span>
 129 |     | <span class='unexecuted'>            return ans;</span>
 130 |     | <span class='neutral'>        }</span>
 131 |     | <span class='neutral'>        return value;</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    /// @notice clamps a to be less than b</span>
 135 |     | <span class='unexecuted'>    function clampLt(</span>
 136 |     | <span class='neutral'>        uint256 a,</span>
 137 |     | <span class='neutral'>        uint256 b,</span>
 138 |     | <span class='neutral'>        bool enableLogs</span>
 139 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 140 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 141 |     | <span class='unexecuted'>            neq(</span>
 142 |     | <span class='unexecuted'>                b,</span>
 143 |     | <span class='unexecuted'>                0,</span>
 144 |     | <span class='neutral'>                &quot;clampLt cannot clamp value a to be less than zero. Check your inputs/assumptions.&quot;</span>
 145 |     | <span class='neutral'>            );</span>
 146 |     | <span class='unexecuted'>            uint256 value = a % b;</span>
 147 |     | <span class='neutral'>            if (enableLogs) {</span>
 148 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 149 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 150 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 151 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 152 |     | <span class='neutral'>                    aStr,</span>
 153 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 154 |     | <span class='neutral'>                    valueStr</span>
 155 |     | <span class='neutral'>                );</span>
 156 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 157 |     | <span class='neutral'>            }</span>
 158 |     | <span class='neutral'>            return value;</span>
 159 |     | <span class='neutral'>        }</span>
 160 |     | <span class='neutral'>        return a;</span>
 161 |     | <span class='neutral'>    }</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>    /// @notice int256 version of clampLt</span>
 164 |     | <span class='unexecuted'>    function clampLt(</span>
 165 |     | <span class='neutral'>        int256 a,</span>
 166 |     | <span class='neutral'>        int256 b,</span>
 167 |     | <span class='neutral'>        bool enableLogs</span>
 168 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 169 |     | <span class='unexecuted'>        if (!(a &lt; b)) {</span>
 170 |     | <span class='unexecuted'>            int256 value = b - 1;</span>
 171 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 172 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 173 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 174 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 175 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 176 |     | <span class='neutral'>                    aStr,</span>
 177 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 178 |     | <span class='neutral'>                    valueStr</span>
 179 |     | <span class='neutral'>                );</span>
 180 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 181 |     | <span class='neutral'>            }</span>
 182 |     | <span class='neutral'>            return value;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>        return a;</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /// @notice clamps a to be less than or equal to b</span>
 188 |     | <span class='unexecuted'>    function clampLte(</span>
 189 |     | <span class='neutral'>        uint256 a,</span>
 190 |     | <span class='neutral'>        uint256 b,</span>
 191 |     | <span class='neutral'>        bool enableLogs</span>
 192 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 193 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 194 |     | <span class='unexecuted'>            uint256 value = a % (b + 1);</span>
 195 |     | <span class='neutral'>            if (enableLogs) {</span>
 196 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 197 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 198 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 199 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 200 |     | <span class='neutral'>                    aStr,</span>
 201 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 202 |     | <span class='neutral'>                    valueStr</span>
 203 |     | <span class='neutral'>                );</span>
 204 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>            return value;</span>
 207 |     | <span class='neutral'>        }</span>
 208 |     | <span class='neutral'>        return a;</span>
 209 |     | <span class='neutral'>    }</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    /// @notice int256 version of clampLte</span>
 212 | *   | <span class='executed'>    function clampLte(</span>
 213 |     | <span class='neutral'>        int256 a,</span>
 214 |     | <span class='neutral'>        int256 b,</span>
 215 |     | <span class='neutral'>        bool enableLogs</span>
 216 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 217 |     | <span class='unexecuted'>        if (!(a &lt;= b)) {</span>
 218 |     | <span class='unexecuted'>            int256 value = b;</span>
 219 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 220 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 221 |     | <span class='unexecuted'>                string memory valueStr = FuzzLibString.toString(value);</span>
 222 |     | <span class='unexecuted'>                bytes memory message = abi.encodePacked(</span>
 223 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 224 |     | <span class='unexecuted'>                    aStr,</span>
 225 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 226 |     | <span class='unexecuted'>                    valueStr</span>
 227 |     | <span class='neutral'>                );</span>
 228 |     | <span class='unexecuted'>                emit Clamped(string(message));</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='unexecuted'>            return value;</span>
 231 |     | <span class='neutral'>        }</span>
 232 |     | <span class='unexecuted'>        return a;</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /// @notice clamps a to be greater than b</span>
 236 |     | <span class='unexecuted'>    function clampGt(</span>
 237 |     | <span class='neutral'>        uint256 a,</span>
 238 |     | <span class='neutral'>        uint256 b,</span>
 239 |     | <span class='neutral'>        bool enableLogs</span>
 240 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 241 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 242 |     | <span class='unexecuted'>            neq(</span>
 243 |     | <span class='unexecuted'>                b,</span>
 244 |     | <span class='neutral'>                type(uint256).max,</span>
 245 |     | <span class='neutral'>                &quot;clampGt cannot clamp value a to be larger than uint256.max. Check your inputs/assumptions.&quot;</span>
 246 |     | <span class='neutral'>            );</span>
 247 |     | <span class='unexecuted'>            uint256 value = b + 1;</span>
 248 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 249 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 250 |     | <span class='unexecuted'>                string memory valueStr = FuzzLibString.toString(value);</span>
 251 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 252 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 253 |     | <span class='neutral'>                    aStr,</span>
 254 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 255 |     | <span class='neutral'>                    valueStr</span>
 256 |     | <span class='neutral'>                );</span>
 257 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='neutral'>            return value;</span>
 260 |     | <span class='neutral'>        } else {</span>
 261 |     | <span class='unexecuted'>            return a;</span>
 262 |     | <span class='neutral'>        }</span>
 263 |     | <span class='neutral'>    }</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='neutral'>    /// @notice int256 version of clampGt</span>
 266 |     | <span class='unexecuted'>    function clampGt(</span>
 267 |     | <span class='neutral'>        int256 a,</span>
 268 |     | <span class='neutral'>        int256 b,</span>
 269 |     | <span class='neutral'>        bool enableLogs</span>
 270 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 271 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 272 |     | <span class='unexecuted'>            int256 value = b + 1;</span>
 273 |     | <span class='neutral'>            if (enableLogs) {</span>
 274 |     | <span class='neutral'>                string memory aStr = FuzzLibString.toString(a);</span>
 275 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 276 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 277 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 278 |     | <span class='neutral'>                    aStr,</span>
 279 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 280 |     | <span class='neutral'>                    valueStr</span>
 281 |     | <span class='neutral'>                );</span>
 282 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 283 |     | <span class='neutral'>            }</span>
 284 |     | <span class='neutral'>            return value;</span>
 285 |     | <span class='neutral'>        } else {</span>
 286 |     | <span class='neutral'>            return a;</span>
 287 |     | <span class='neutral'>        }</span>
 288 |     | <span class='neutral'>    }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    /// @notice clamps a to be greater than or equal to b</span>
 291 |     | <span class='unexecuted'>    function clampGte(</span>
 292 |     | <span class='neutral'>        uint256 a,</span>
 293 |     | <span class='neutral'>        uint256 b,</span>
 294 |     | <span class='neutral'>        bool enableLogs</span>
 295 |     | <span class='unexecuted'>    ) public returns (uint256) {</span>
 296 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 297 |     | <span class='unexecuted'>            uint256 value = b;</span>
 298 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 299 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 300 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 301 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 302 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 303 |     | <span class='neutral'>                    aStr,</span>
 304 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 305 |     | <span class='neutral'>                    valueStr</span>
 306 |     | <span class='neutral'>                );</span>
 307 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 308 |     | <span class='neutral'>            }</span>
 309 |     | <span class='neutral'>            return value;</span>
 310 |     | <span class='neutral'>        }</span>
 311 |     | <span class='neutral'>        return a;</span>
 312 |     | <span class='neutral'>    }</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    /// @notice int256 version of clampGte</span>
 315 |     | <span class='unexecuted'>    function clampGte(</span>
 316 |     | <span class='neutral'>        int256 a,</span>
 317 |     | <span class='neutral'>        int256 b,</span>
 318 |     | <span class='neutral'>        bool enableLogs</span>
 319 |     | <span class='unexecuted'>    ) public returns (int256) {</span>
 320 |     | <span class='unexecuted'>        if (!(a &gt; b)) {</span>
 321 |     | <span class='unexecuted'>            int256 value = b;</span>
 322 |     | <span class='unexecuted'>            if (enableLogs) {</span>
 323 |     | <span class='unexecuted'>                string memory aStr = FuzzLibString.toString(a);</span>
 324 |     | <span class='neutral'>                string memory valueStr = FuzzLibString.toString(value);</span>
 325 |     | <span class='neutral'>                bytes memory message = abi.encodePacked(</span>
 326 |     | <span class='neutral'>                    &quot;Clamping value &quot;,</span>
 327 |     | <span class='neutral'>                    aStr,</span>
 328 |     | <span class='neutral'>                    &quot; to &quot;,</span>
 329 |     | <span class='neutral'>                    valueStr</span>
 330 |     | <span class='neutral'>                );</span>
 331 |     | <span class='neutral'>                emit Clamped(string(message));</span>
 332 |     | <span class='neutral'>            }</span>
 333 |     | <span class='neutral'>            return value;</span>
 334 |     | <span class='neutral'>        }</span>
 335 |     | <span class='neutral'>        return a;</span>
 336 |     | <span class='neutral'>    }</span>
 337 |     | <span class='neutral'>}</span>
 338 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperLog.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {LibLog} from &quot;../libraries/LibLog.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract HelperLog {</span>
  7 |     | <span class='unexecuted'>    function log(string memory message) public {</span>
  8 |     | <span class='unexecuted'>        LibLog.log(message);</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='unexecuted'>    function log(string memory message, string memory data) public {</span>
 12 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function log(string memory message, bytes memory data) public {</span>
 16 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function log(string memory message, uint256 data) public {</span>
 20 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function log(string memory message, int256 data) public {</span>
 24 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>    function log(string memory message, address data) public {</span>
 28 | *   | <span class='executed'>        LibLog.log(message, data);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function log(string memory message, bool data) public {</span>
 32 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function log(string memory message, bytes32 data) public {</span>
 36 |     | <span class='neutral'>        LibLog.log(message, data);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function logFail() public {</span>
 40 |     | <span class='unexecuted'>        LibLog.logFail();</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function logFail(string memory message) public {</span>
 44 |     | <span class='unexecuted'>        LibLog.logFail(message);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function logFail(string memory message, string memory data) public {</span>
 48 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function logFail(string memory message, bytes memory data) public {</span>
 52 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function logFail(string memory message, uint256 data) public {</span>
 56 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function logFail(string memory message, int256 data) public {</span>
 60 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function logFail(string memory message, address data) public {</span>
 64 |     | <span class='unexecuted'>        LibLog.logFail(message, data);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 | *   | <span class='executed'>    function logFail(string memory message, bool data) public {</span>
 68 | *   | <span class='executed'>        LibLog.logFail(message, data);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function logFail(string memory message, bytes32 data) public {</span>
 72 |     | <span class='unexecuted'>        LibLog.log(message, data);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract HelperMath {</span>
  5 |     | <span class='unexecuted'>    function min(uint256 a, uint256 b) public pure returns (uint256) {</span>
  6 |     | <span class='unexecuted'>        return a &lt; b ? a : b;</span>
  7 |     | <span class='neutral'>    }</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    function max(uint256 a, uint256 b) public pure returns (uint256) {</span>
 10 |     | <span class='unexecuted'>        return a &gt; b ? a : b;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // Forked from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.0.0/contracts/utils/math/SignedMath.sol</span>
 14 |     | <span class='unexecuted'>    function max(int256 a, int256 b) public pure returns (int256) {</span>
 15 |     | <span class='unexecuted'>        return a &gt; b ? a : b;</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    // Forked with modifications from https://ethereum.stackexchange.com/a/84391</span>
 19 |     | <span class='unexecuted'>    function abs(int128 n) public pure returns (int128) {</span>
 20 |     | <span class='unexecuted'>        return n &gt;= 0 ? n : -n;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 | *   | <span class='executed'>    function abs(int256 n) public pure returns (uint256) {</span>
 24 | *   | <span class='executed'>        return n &gt;= 0 ? uint256(n) : uint256(-n);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function diff(int256 a, int256 b) public pure returns (uint256) {</span>
 28 |     | <span class='unexecuted'>        return a &gt;= b ? uint256(a - b) : uint256(b - a);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function diff(uint256 a, uint256 b) public pure returns (uint256) {</span>
 32 |     | <span class='unexecuted'>        return a &gt;= b ? a - b : b - a;</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'>}</span>
 35 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/helpers/HelperRandom.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>abstract contract HelperRandom {</span>
  5 |     | <span class='neutral'>    /// @notice Shuffle an array using Fisher-Yates algorithm</span>
  6 |     | <span class='neutral'>    /// @dev Based on https://gist.github.com/scammi/602387a22e04c77beb73c0ebc0f0bc18</span>
  7 |     | <span class='unexecuted'>    function shuffleArray(</span>
  8 |     | <span class='neutral'>        uint256[] memory shuffle,</span>
  9 |     | <span class='neutral'>        uint256 entropy</span>
 10 |     | <span class='neutral'>    ) public pure {</span>
 11 |     | <span class='unexecuted'>        for (uint256 i = shuffle.length - 1; i &gt; 0; i--) {</span>
 12 |     | <span class='unexecuted'>            uint256 swapIndex = entropy % (shuffle.length - i);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>            uint256 currentIndex = shuffle[i];</span>
 15 |     | <span class='unexecuted'>            uint256 indexToSwap = shuffle[swapIndex];</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='unexecuted'>            shuffle[i] = indexToSwap;</span>
 18 |     | <span class='unexecuted'>            shuffle[swapIndex] = currentIndex;</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/libraries/LibLog.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='unexecuted'>library LibLog {</span>
  5 |     | <span class='neutral'>    event Log(string message);</span>
  6 |     | <span class='neutral'>    event LogString(string message, string data);</span>
  7 |     | <span class='neutral'>    event LogBytes(string message, bytes data);</span>
  8 |     | <span class='neutral'>    event LogUint(string message, uint256 data);</span>
  9 |     | <span class='neutral'>    event LogInt(string message, int256 data);</span>
 10 |     | <span class='neutral'>    event LogAddress(string message, address data);</span>
 11 |     | <span class='neutral'>    event LogBool(string message, bool data);</span>
 12 |     | <span class='neutral'>    event LogBytes32(string message, bytes32 data);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    event AssertionFailed();</span>
 15 |     | <span class='neutral'>    event AssertionFailed(string message);</span>
 16 |     | <span class='neutral'>    event AssertionFailed(string message, string data);</span>
 17 |     | <span class='neutral'>    event AssertionFailed(string message, bytes data);</span>
 18 |     | <span class='neutral'>    event AssertionFailed(string message, uint256 data);</span>
 19 |     | <span class='neutral'>    event AssertionFailed(string message, int256 data);</span>
 20 |     | <span class='neutral'>    event AssertionFailed(string message, address data);</span>
 21 |     | <span class='neutral'>    event AssertionFailed(string message, bool data);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function log(string memory message) internal {</span>
 24 |     | <span class='unexecuted'>        emit Log(message);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>    function log(string memory message, string memory data) internal {</span>
 28 |     | <span class='unexecuted'>        emit LogString(message, data);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='unexecuted'>    function log(string memory message, bytes memory data) internal {</span>
 32 |     | <span class='unexecuted'>        emit LogBytes(message, data);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>    function log(string memory message, uint256 data) internal {</span>
 36 |     | <span class='unexecuted'>        emit LogUint(message, data);</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>    function log(string memory message, int256 data) internal {</span>
 40 |     | <span class='unexecuted'>        emit LogInt(message, data);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 | *   | <span class='executed'>    function log(string memory message, address data) internal {</span>
 44 | *   | <span class='executed'>        emit LogAddress(message, data);</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function log(string memory message, bool data) internal {</span>
 48 |     | <span class='unexecuted'>        emit LogBool(message, data);</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>    function log(string memory message, bytes32 data) internal {</span>
 52 |     | <span class='unexecuted'>        emit LogBytes32(message, data);</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>    function logFail() internal {</span>
 56 |     | <span class='unexecuted'>        emit AssertionFailed();</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='unexecuted'>    function logFail(string memory message) internal {</span>
 60 |     | <span class='unexecuted'>        emit AssertionFailed(message);</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>    function logFail(string memory message, string memory data) internal {</span>
 64 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function logFail(string memory message, bytes memory data) internal {</span>
 68 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>    function logFail(string memory message, uint256 data) internal {</span>
 72 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'></span>
 75 |     | <span class='unexecuted'>    function logFail(string memory message, int256 data) internal {</span>
 76 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='unexecuted'>    function logFail(string memory message, address data) internal {</span>
 80 |     | <span class='unexecuted'>        emit AssertionFailed(message, data);</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 | *   | <span class='executed'>    function logFail(string memory message, bool data) internal {</span>
 84 | *   | <span class='executed'>        emit AssertionFailed(message, data);</span>
 85 |     | <span class='neutral'>    }</span>
 86 |     | <span class='neutral'></span>
 87 |     | <span class='neutral'>    function logFail(string memory message, bytes32 data) internal {</span>
 88 |     | <span class='neutral'>        emit LogBytes32(message, data);</span>
 89 |     | <span class='neutral'>    }</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/platform/IPlatform.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>interface IPlatform {</span>
 5 |     | <span class='neutral'>    function assertFail() pure external;</span>
 6 |     | <span class='neutral'>}</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/lib/fuzzlib/src/platform/PlatformCrytic.sol</b>
<code>
  1 |     | <span class='neutral'></span>
  2 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import {IPlatform} from &quot;./IPlatform.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='unexecuted'>contract PlatformCrytic is IPlatform {</span>
  8 |     | <span class='unexecuted'>    function assertFail() pure public override{</span>
  9 |     | <span class='unexecuted'>        assert(false);</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// solhint-disable-next-line interface-starts-with-i</span>
  5 |     | <span class='neutral'>interface AggregatorV3Interface {</span>
  6 |     | <span class='neutral'>  function decimals() external view returns (uint8);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>  function description() external view returns (string memory);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>  function version() external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>  function getRoundData(</span>
 13 |     | <span class='neutral'>    uint80 _roundId</span>
 14 |     | <span class='neutral'>  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>  function latestRoundData()</span>
 17 |     | <span class='neutral'>    external</span>
 18 |     | <span class='neutral'>    view</span>
 19 |     | <span class='neutral'>    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/access/Ownable.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../utils/Context.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides a basic access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available the modifier</span>
 17 |     | <span class='neutral'> * `onlyOwner`, which can be applied to your functions to restrict their use to</span>
 18 |     | <span class='neutral'> * the owner.</span>
 19 |     | <span class='neutral'> */</span>
 20 |     | <span class='neutral'>abstract contract Ownable is Context {</span>
 21 |     | <span class='neutral'>    address private _owner;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    /**</span>
 26 |     | <span class='neutral'>     * @dev Initializes the contract setting the deployer as the initial owner.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    constructor() {</span>
 29 |     | <span class='unexecuted'>        _transferOwnership(_msgSender());</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    /**</span>
 33 |     | <span class='neutral'>     * @dev Throws if called by any account other than the owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='neutral'>    modifier onlyOwner() {</span>
 36 |     | <span class='unexecuted'>        _checkOwner();</span>
 37 |     | <span class='neutral'>        _;</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Returns the address of the current owner.</span>
 42 |     | <span class='neutral'>     */</span>
 43 |     | <span class='unexecuted'>    function owner() public view virtual returns (address) {</span>
 44 |     | <span class='unexecuted'>        return _owner;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /**</span>
 48 |     | <span class='neutral'>     * @dev Throws if the sender is not the owner.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='unexecuted'>    function _checkOwner() internal view virtual {</span>
 51 |     | <span class='unexecuted'>        require(owner() == _msgSender(), &quot;Ownable: caller is not the owner&quot;);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /**</span>
 55 |     | <span class='neutral'>     * @dev Leaves the contract without owner. It will not be possible to call</span>
 56 |     | <span class='neutral'>     * `onlyOwner` functions. Can only be called by the current owner.</span>
 57 |     | <span class='neutral'>     *</span>
 58 |     | <span class='neutral'>     * NOTE: Renouncing ownership will leave the contract without an owner,</span>
 59 |     | <span class='neutral'>     * thereby disabling any functionality that is only available to the owner.</span>
 60 |     | <span class='neutral'>     */</span>
 61 |     | <span class='unexecuted'>    function renounceOwnership() public virtual onlyOwner {</span>
 62 |     | <span class='unexecuted'>        _transferOwnership(address(0));</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='neutral'>    /**</span>
 66 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 67 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 68 |     | <span class='neutral'>     */</span>
 69 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual onlyOwner {</span>
 70 |     | <span class='unexecuted'>        require(newOwner != address(0), &quot;Ownable: new owner is the zero address&quot;);</span>
 71 |     | <span class='unexecuted'>        _transferOwnership(newOwner);</span>
 72 |     | <span class='neutral'>    }</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>    /**</span>
 75 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`).</span>
 76 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 77 |     | <span class='neutral'>     */</span>
 78 |     | <span class='unexecuted'>    function _transferOwnership(address newOwner) internal virtual {</span>
 79 |     | <span class='unexecuted'>        address oldOwner = _owner;</span>
 80 |     | <span class='unexecuted'>        _owner = newOwner;</span>
 81 |     | <span class='unexecuted'>        emit OwnershipTransferred(oldOwner, newOwner);</span>
 82 |     | <span class='neutral'>    }</span>
 83 |     | <span class='neutral'>}</span>
 84 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/access/Ownable2Step.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable2Step.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./Ownable.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Contract module which provides access control mechanism, where</span>
 10 |     | <span class='neutral'> * there is an account (an owner) that can be granted exclusive access to</span>
 11 |     | <span class='neutral'> * specific functions.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * By default, the owner account will be the one that deploys the contract. This</span>
 14 |     | <span class='neutral'> * can later be changed with {transferOwnership} and {acceptOwnership}.</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * This module is used through inheritance. It will make available all functions</span>
 17 |     | <span class='neutral'> * from parent (Ownable).</span>
 18 |     | <span class='neutral'> */</span>
 19 |     | <span class='neutral'>abstract contract Ownable2Step is Ownable {</span>
 20 |     | <span class='neutral'>    address private _pendingOwner;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the address of the pending owner.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='unexecuted'>    function pendingOwner() public view virtual returns (address) {</span>
 28 |     | <span class='unexecuted'>        return _pendingOwner;</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /**</span>
 32 |     | <span class='neutral'>     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.</span>
 33 |     | <span class='neutral'>     * Can only be called by the current owner.</span>
 34 |     | <span class='neutral'>     */</span>
 35 |     | <span class='unexecuted'>    function transferOwnership(address newOwner) public virtual override onlyOwner {</span>
 36 |     | <span class='unexecuted'>        _pendingOwner = newOwner;</span>
 37 |     | <span class='unexecuted'>        emit OwnershipTransferStarted(owner(), newOwner);</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    /**</span>
 41 |     | <span class='neutral'>     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.</span>
 42 |     | <span class='neutral'>     * Internal function without access restriction.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='unexecuted'>    function _transferOwnership(address newOwner) internal virtual override {</span>
 45 |     | <span class='unexecuted'>        delete _pendingOwner;</span>
 46 |     | <span class='unexecuted'>        super._transferOwnership(newOwner);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='neutral'>    /**</span>
 50 |     | <span class='neutral'>     * @dev The new owner accepts the ownership transfer.</span>
 51 |     | <span class='neutral'>     */</span>
 52 |     | <span class='unexecuted'>    function acceptOwnership() public virtual {</span>
 53 |     | <span class='neutral'>        address sender = _msgSender();</span>
 54 |     | <span class='unexecuted'>        require(pendingOwner() == sender, &quot;Ownable2Step: caller is not the new owner&quot;);</span>
 55 |     | <span class='unexecuted'>        _transferOwnership(sender);</span>
 56 |     | <span class='neutral'>    }</span>
 57 |     | <span class='neutral'>}</span>
 58 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC20.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
 2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='neutral'>import &quot;../token/ERC20/IERC20.sol&quot;;</span>
 7 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC4626.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC4626.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../token/ERC20/IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>/**</span>
  10 |     | <span class='neutral'> * @dev Interface of the ERC4626 &quot;Tokenized Vault Standard&quot;, as defined in</span>
  11 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * _Available since v4.7._</span>
  14 |     | <span class='neutral'> */</span>
  15 |     | <span class='neutral'>interface IERC4626 is IERC20, IERC20Metadata {</span>
  16 |     | <span class='neutral'>    event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    event Withdraw(</span>
  19 |     | <span class='neutral'>        address indexed sender,</span>
  20 |     | <span class='neutral'>        address indexed receiver,</span>
  21 |     | <span class='neutral'>        address indexed owner,</span>
  22 |     | <span class='neutral'>        uint256 assets,</span>
  23 |     | <span class='neutral'>        uint256 shares</span>
  24 |     | <span class='neutral'>    );</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.</span>
  28 |     | <span class='neutral'>     *</span>
  29 |     | <span class='neutral'>     * - MUST be an ERC-20 token contract.</span>
  30 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  31 |     | <span class='neutral'>     */</span>
  32 |     | <span class='neutral'>    function asset() external view returns (address assetTokenAddress);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /**</span>
  35 |     | <span class='neutral'>     * @dev Returns the total amount of the underlying asset that is managed by Vault.</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - SHOULD include any compounding that occurs from yield.</span>
  38 |     | <span class='neutral'>     * - MUST be inclusive of any fees that are charged against assets in the Vault.</span>
  39 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  40 |     | <span class='neutral'>     */</span>
  41 |     | <span class='neutral'>    function totalAssets() external view returns (uint256 totalManagedAssets);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    /**</span>
  44 |     | <span class='neutral'>     * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal</span>
  45 |     | <span class='neutral'>     * scenario where all the conditions are met.</span>
  46 |     | <span class='neutral'>     *</span>
  47 |     | <span class='neutral'>     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.</span>
  48 |     | <span class='neutral'>     * - MUST NOT show any variations depending on the caller.</span>
  49 |     | <span class='neutral'>     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.</span>
  50 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the</span>
  53 |     | <span class='neutral'>     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and</span>
  54 |     | <span class='neutral'>     * from.</span>
  55 |     | <span class='neutral'>     */</span>
  56 |     | <span class='neutral'>    function convertToShares(uint256 assets) external view returns (uint256 shares);</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /**</span>
  59 |     | <span class='neutral'>     * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal</span>
  60 |     | <span class='neutral'>     * scenario where all the conditions are met.</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.</span>
  63 |     | <span class='neutral'>     * - MUST NOT show any variations depending on the caller.</span>
  64 |     | <span class='neutral'>     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.</span>
  65 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  66 |     | <span class='neutral'>     *</span>
  67 |     | <span class='neutral'>     * NOTE: This calculation MAY NOT reflect the per-user price-per-share, and instead should reflect the</span>
  68 |     | <span class='neutral'>     * average-users price-per-share, meaning what the average user should expect to see when exchanging to and</span>
  69 |     | <span class='neutral'>     * from.</span>
  70 |     | <span class='neutral'>     */</span>
  71 |     | <span class='neutral'>    function convertToAssets(uint256 shares) external view returns (uint256 assets);</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /**</span>
  74 |     | <span class='neutral'>     * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,</span>
  75 |     | <span class='neutral'>     * through a deposit call.</span>
  76 |     | <span class='neutral'>     *</span>
  77 |     | <span class='neutral'>     * - MUST return a limited value if receiver is subject to some deposit limit.</span>
  78 |     | <span class='neutral'>     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.</span>
  79 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='neutral'>    function maxDeposit(address receiver) external view returns (uint256 maxAssets);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given</span>
  85 |     | <span class='neutral'>     * current on-chain conditions.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit</span>
  88 |     | <span class='neutral'>     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called</span>
  89 |     | <span class='neutral'>     *   in the same transaction.</span>
  90 |     | <span class='neutral'>     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the</span>
  91 |     | <span class='neutral'>     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.</span>
  92 |     | <span class='neutral'>     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.</span>
  93 |     | <span class='neutral'>     * - MUST NOT revert.</span>
  94 |     | <span class='neutral'>     *</span>
  95 |     | <span class='neutral'>     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in</span>
  96 |     | <span class='neutral'>     * share price or some other type of condition, meaning the depositor will lose assets by depositing.</span>
  97 |     | <span class='neutral'>     */</span>
  98 |     | <span class='neutral'>    function previewDeposit(uint256 assets) external view returns (uint256 shares);</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.</span>
 102 |     | <span class='neutral'>     *</span>
 103 |     | <span class='neutral'>     * - MUST emit the Deposit event.</span>
 104 |     | <span class='neutral'>     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the</span>
 105 |     | <span class='neutral'>     *   deposit execution, and are accounted for during deposit.</span>
 106 |     | <span class='neutral'>     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not</span>
 107 |     | <span class='neutral'>     *   approving enough underlying tokens to the Vault contract, etc).</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.</span>
 110 |     | <span class='neutral'>     */</span>
 111 |     | <span class='neutral'>    function deposit(uint256 assets, address receiver) external returns (uint256 shares);</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    /**</span>
 114 |     | <span class='neutral'>     * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.</span>
 115 |     | <span class='neutral'>     * - MUST return a limited value if receiver is subject to some mint limit.</span>
 116 |     | <span class='neutral'>     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.</span>
 117 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 118 |     | <span class='neutral'>     */</span>
 119 |     | <span class='neutral'>    function maxMint(address receiver) external view returns (uint256 maxShares);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given</span>
 123 |     | <span class='neutral'>     * current on-chain conditions.</span>
 124 |     | <span class='neutral'>     *</span>
 125 |     | <span class='neutral'>     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call</span>
 126 |     | <span class='neutral'>     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the</span>
 127 |     | <span class='neutral'>     *   same transaction.</span>
 128 |     | <span class='neutral'>     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint</span>
 129 |     | <span class='neutral'>     *   would be accepted, regardless if the user has enough tokens approved, etc.</span>
 130 |     | <span class='neutral'>     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.</span>
 131 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 132 |     | <span class='neutral'>     *</span>
 133 |     | <span class='neutral'>     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in</span>
 134 |     | <span class='neutral'>     * share price or some other type of condition, meaning the depositor will lose assets by minting.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='neutral'>    function previewMint(uint256 shares) external view returns (uint256 assets);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    /**</span>
 139 |     | <span class='neutral'>     * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.</span>
 140 |     | <span class='neutral'>     *</span>
 141 |     | <span class='neutral'>     * - MUST emit the Deposit event.</span>
 142 |     | <span class='neutral'>     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint</span>
 143 |     | <span class='neutral'>     *   execution, and are accounted for during mint.</span>
 144 |     | <span class='neutral'>     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not</span>
 145 |     | <span class='neutral'>     *   approving enough underlying tokens to the Vault contract, etc).</span>
 146 |     | <span class='neutral'>     *</span>
 147 |     | <span class='neutral'>     * NOTE: most implementations will require pre-approval of the Vault with the Vaults underlying asset token.</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='neutral'>    function mint(uint256 shares, address receiver) external returns (uint256 assets);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /**</span>
 152 |     | <span class='neutral'>     * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the</span>
 153 |     | <span class='neutral'>     * Vault, through a withdraw call.</span>
 154 |     | <span class='neutral'>     *</span>
 155 |     | <span class='neutral'>     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.</span>
 156 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 157 |     | <span class='neutral'>     */</span>
 158 |     | <span class='neutral'>    function maxWithdraw(address owner) external view returns (uint256 maxAssets);</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /**</span>
 161 |     | <span class='neutral'>     * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,</span>
 162 |     | <span class='neutral'>     * given current on-chain conditions.</span>
 163 |     | <span class='neutral'>     *</span>
 164 |     | <span class='neutral'>     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw</span>
 165 |     | <span class='neutral'>     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if</span>
 166 |     | <span class='neutral'>     *   called</span>
 167 |     | <span class='neutral'>     *   in the same transaction.</span>
 168 |     | <span class='neutral'>     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though</span>
 169 |     | <span class='neutral'>     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.</span>
 170 |     | <span class='neutral'>     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.</span>
 171 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in</span>
 174 |     | <span class='neutral'>     * share price or some other type of condition, meaning the depositor will lose assets by depositing.</span>
 175 |     | <span class='neutral'>     */</span>
 176 |     | <span class='neutral'>    function previewWithdraw(uint256 assets) external view returns (uint256 shares);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>    /**</span>
 179 |     | <span class='neutral'>     * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * - MUST emit the Withdraw event.</span>
 182 |     | <span class='neutral'>     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the</span>
 183 |     | <span class='neutral'>     *   withdraw execution, and are accounted for during withdraw.</span>
 184 |     | <span class='neutral'>     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner</span>
 185 |     | <span class='neutral'>     *   not having enough shares, etc).</span>
 186 |     | <span class='neutral'>     *</span>
 187 |     | <span class='neutral'>     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.</span>
 188 |     | <span class='neutral'>     * Those methods should be performed separately.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='neutral'>    function withdraw(uint256 assets, address receiver, address owner) external returns (uint256 shares);</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='neutral'>    /**</span>
 193 |     | <span class='neutral'>     * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,</span>
 194 |     | <span class='neutral'>     * through a redeem call.</span>
 195 |     | <span class='neutral'>     *</span>
 196 |     | <span class='neutral'>     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.</span>
 197 |     | <span class='neutral'>     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.</span>
 198 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 199 |     | <span class='neutral'>     */</span>
 200 |     | <span class='neutral'>    function maxRedeem(address owner) external view returns (uint256 maxShares);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,</span>
 204 |     | <span class='neutral'>     * given current on-chain conditions.</span>
 205 |     | <span class='neutral'>     *</span>
 206 |     | <span class='neutral'>     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call</span>
 207 |     | <span class='neutral'>     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the</span>
 208 |     | <span class='neutral'>     *   same transaction.</span>
 209 |     | <span class='neutral'>     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the</span>
 210 |     | <span class='neutral'>     *   redemption would be accepted, regardless if the user has enough shares, etc.</span>
 211 |     | <span class='neutral'>     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.</span>
 212 |     | <span class='neutral'>     * - MUST NOT revert.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in</span>
 215 |     | <span class='neutral'>     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.</span>
 216 |     | <span class='neutral'>     */</span>
 217 |     | <span class='neutral'>    function previewRedeem(uint256 shares) external view returns (uint256 assets);</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /**</span>
 220 |     | <span class='neutral'>     * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.</span>
 221 |     | <span class='neutral'>     *</span>
 222 |     | <span class='neutral'>     * - MUST emit the Withdraw event.</span>
 223 |     | <span class='neutral'>     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the</span>
 224 |     | <span class='neutral'>     *   redeem execution, and are accounted for during redeem.</span>
 225 |     | <span class='neutral'>     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner</span>
 226 |     | <span class='neutral'>     *   not having enough shares, etc).</span>
 227 |     | <span class='neutral'>     *</span>
 228 |     | <span class='neutral'>     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.</span>
 229 |     | <span class='neutral'>     * Those methods should be performed separately.</span>
 230 |     | <span class='neutral'>     */</span>
 231 |     | <span class='neutral'>    function redeem(uint256 shares, address receiver, address owner) external returns (uint256 assets);</span>
 232 |     | <span class='neutral'>}</span>
 233 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/interfaces/IERC5267.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC5267 {</span>
  7 |     | <span class='neutral'>    /**</span>
  8 |     | <span class='neutral'>     * @dev MAY be emitted to signal that the domain could have changed.</span>
  9 |     | <span class='neutral'>     */</span>
 10 |     | <span class='neutral'>    event EIP712DomainChanged();</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712</span>
 14 |     | <span class='neutral'>     * signature.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function eip712Domain()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            bytes1 fields,</span>
 21 |     | <span class='neutral'>            string memory name,</span>
 22 |     | <span class='neutral'>            string memory version,</span>
 23 |     | <span class='neutral'>            uint256 chainId,</span>
 24 |     | <span class='neutral'>            address verifyingContract,</span>
 25 |     | <span class='neutral'>            bytes32 salt,</span>
 26 |     | <span class='neutral'>            uint256[] memory extensions</span>
 27 |     | <span class='neutral'>        );</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/security/ReentrancyGuard.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Contract module that helps prevent reentrant calls to a function.</span>
  8 |     | <span class='neutral'> *</span>
  9 |     | <span class='neutral'> * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier</span>
 10 |     | <span class='neutral'> * available, which can be applied to functions to make sure there are no nested</span>
 11 |     | <span class='neutral'> * (reentrant) calls to them.</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * Note that because there is a single `nonReentrant` guard, functions marked as</span>
 14 |     | <span class='neutral'> * `nonReentrant` may not call one another. This can be worked around by making</span>
 15 |     | <span class='neutral'> * those functions `private`, and then adding `external` `nonReentrant` entry</span>
 16 |     | <span class='neutral'> * points to them.</span>
 17 |     | <span class='neutral'> *</span>
 18 |     | <span class='neutral'> * TIP: If you would like to learn more about reentrancy and alternative ways</span>
 19 |     | <span class='neutral'> * to protect against it, check out our blog post</span>
 20 |     | <span class='neutral'> * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ReentrancyGuard {</span>
 23 |     | <span class='neutral'>    // Booleans are more expensive than uint256 or any type that takes up a full</span>
 24 |     | <span class='neutral'>    // word because each write operation emits an extra SLOAD to first read the</span>
 25 |     | <span class='neutral'>    // slot&#39;s contents, replace the bits taken up by the boolean, and then write</span>
 26 |     | <span class='neutral'>    // back. This is the compiler&#39;s defense against contract upgrades and</span>
 27 |     | <span class='neutral'>    // pointer aliasing, and it cannot be disabled.</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    // The values being non-zero value makes deployment a bit more expensive,</span>
 30 |     | <span class='neutral'>    // but in exchange the refund on every call to nonReentrant will be lower in</span>
 31 |     | <span class='neutral'>    // amount. Since refunds are capped to a percentage of the total</span>
 32 |     | <span class='neutral'>    // transaction&#39;s gas, it is best to keep them low in cases like this one, to</span>
 33 |     | <span class='neutral'>    // increase the likelihood of the full refund coming into effect.</span>
 34 |     | <span class='unexecuted'>    uint256 private constant _NOT_ENTERED = 1;</span>
 35 |     | <span class='unexecuted'>    uint256 private constant _ENTERED = 2;</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    uint256 private _status;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    constructor() {</span>
 40 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Prevents a contract from calling itself, directly or indirectly.</span>
 45 |     | <span class='neutral'>     * Calling a `nonReentrant` function from another `nonReentrant`</span>
 46 |     | <span class='neutral'>     * function is not supported. It is possible to prevent this from happening</span>
 47 |     | <span class='neutral'>     * by making the `nonReentrant` function external, and making it call a</span>
 48 |     | <span class='neutral'>     * `private` function that does the actual work.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    modifier nonReentrant() {</span>
 51 |     | <span class='unexecuted'>        _nonReentrantBefore();</span>
 52 |     | <span class='unexecuted'>        _;</span>
 53 |     | <span class='unexecuted'>        _nonReentrantAfter();</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>    function _nonReentrantBefore() private {</span>
 57 |     | <span class='neutral'>        // On the first call to nonReentrant, _status will be _NOT_ENTERED</span>
 58 |     | <span class='unexecuted'>        require(_status != _ENTERED, &quot;ReentrancyGuard: reentrant call&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // Any calls to nonReentrant after this point will fail</span>
 61 |     | <span class='unexecuted'>        _status = _ENTERED;</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>    function _nonReentrantAfter() private {</span>
 65 |     | <span class='neutral'>        // By storing the original value once again, a refund is triggered (see</span>
 66 |     | <span class='neutral'>        // https://eips.ethereum.org/EIPS/eip-2200)</span>
 67 |     | <span class='unexecuted'>        _status = _NOT_ENTERED;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @dev Returns true if the reentrancy guard is currently set to &quot;entered&quot;, which indicates there is a</span>
 72 |     | <span class='neutral'>     * `nonReentrant` function in the call stack.</span>
 73 |     | <span class='neutral'>     */</span>
 74 |     | <span class='neutral'>    function _reentrancyGuardEntered() internal view returns (bool) {</span>
 75 |     | <span class='neutral'>        return _status == _ENTERED;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'>}</span>
 78 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/ERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./extensions/IERC20Metadata.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev Implementation of the {IERC20} interface.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * This implementation is agnostic to the way tokens are created. This means</span>
  14 |     | <span class='neutral'> * that a supply mechanism has to be added in a derived contract using {_mint}.</span>
  15 |     | <span class='neutral'> * For a generic mechanism see {ERC20PresetMinterPauser}.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * TIP: For a detailed writeup see our guide</span>
  18 |     | <span class='neutral'> * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How</span>
  19 |     | <span class='neutral'> * to implement supply mechanisms].</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The default value of {decimals} is 18. To change this, you should override</span>
  22 |     | <span class='neutral'> * this function so it returns a different value.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * We have followed general OpenZeppelin Contracts guidelines: functions revert</span>
  25 |     | <span class='neutral'> * instead returning `false` on failure. This behavior is nonetheless</span>
  26 |     | <span class='neutral'> * conventional and does not conflict with the expectations of ERC20</span>
  27 |     | <span class='neutral'> * applications.</span>
  28 |     | <span class='neutral'> *</span>
  29 |     | <span class='neutral'> * Additionally, an {Approval} event is emitted on calls to {transferFrom}.</span>
  30 |     | <span class='neutral'> * This allows applications to reconstruct the allowance for all accounts just</span>
  31 |     | <span class='neutral'> * by listening to said events. Other implementations of the EIP may not emit</span>
  32 |     | <span class='neutral'> * these events, as it isn&#39;t required by the specification.</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}</span>
  35 |     | <span class='neutral'> * functions have been added to mitigate the well-known issues around setting</span>
  36 |     | <span class='neutral'> * allowances. See {IERC20-approve}.</span>
  37 |     | <span class='neutral'> */</span>
  38 |     | <span class='unexecuted'>contract ERC20 is Context, IERC20, IERC20Metadata {</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) private _allowances;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    uint256 private _totalSupply;</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    string private _name;</span>
  46 |     | <span class='neutral'>    string private _symbol;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Sets the values for {name} and {symbol}.</span>
  50 |     | <span class='neutral'>     *</span>
  51 |     | <span class='neutral'>     * All two of these values are immutable: they can only be set once during</span>
  52 |     | <span class='neutral'>     * construction.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  55 |     | <span class='unexecuted'>        _name = name_;</span>
  56 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
  61 |     | <span class='neutral'>     */</span>
  62 | *   | <span class='executed'>    function name() public view virtual override returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return _name;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /**</span>
  67 |     | <span class='neutral'>     * @dev Returns the symbol of the token, usually a shorter version of the</span>
  68 |     | <span class='neutral'>     * name.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  71 |     | <span class='unexecuted'>        return _symbol;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the number of decimals used to get its user representation.</span>
  76 |     | <span class='neutral'>     * For example, if `decimals` equals `2`, a balance of `505` tokens should</span>
  77 |     | <span class='neutral'>     * be displayed to a user as `5.05` (`505 / 10 ** 2`).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Tokens usually opt for a value of 18, imitating the relationship between</span>
  80 |     | <span class='neutral'>     * Ether and Wei. This is the default value returned by this function, unless</span>
  81 |     | <span class='neutral'>     * it&#39;s overridden.</span>
  82 |     | <span class='neutral'>     *</span>
  83 |     | <span class='neutral'>     * NOTE: This information is only used for _display_ purposes: it in</span>
  84 |     | <span class='neutral'>     * no way affects any of the arithmetic of the contract, including</span>
  85 |     | <span class='neutral'>     * {IERC20-balanceOf} and {IERC20-transfer}.</span>
  86 |     | <span class='neutral'>     */</span>
  87 | *   | <span class='executed'>    function decimals() public view virtual override returns (uint8) {</span>
  88 | *   | <span class='executed'>        return 18;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev See {IERC20-totalSupply}.</span>
  93 |     | <span class='neutral'>     */</span>
  94 | *   | <span class='executed'>    function totalSupply() public view virtual override returns (uint256) {</span>
  95 | *   | <span class='executed'>        return _totalSupply;</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev See {IERC20-balanceOf}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 | *   | <span class='executed'>    function balanceOf(address account) public view virtual override returns (uint256) {</span>
 102 | *   | <span class='executed'>        return _balances[account];</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev See {IERC20-transfer}.</span>
 107 |     | <span class='neutral'>     *</span>
 108 |     | <span class='neutral'>     * Requirements:</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 111 |     | <span class='neutral'>     * - the caller must have a balance of at least `amount`.</span>
 112 |     | <span class='neutral'>     */</span>
 113 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
 114 |     | <span class='neutral'>        address owner = _msgSender();</span>
 115 |     | <span class='unexecuted'>        _transfer(owner, to, amount);</span>
 116 |     | <span class='neutral'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev See {IERC20-allowance}.</span>
 121 |     | <span class='neutral'>     */</span>
 122 | *   | <span class='executed'>    function allowance(address owner, address spender) public view virtual override returns (uint256) {</span>
 123 | *   | <span class='executed'>        return _allowances[owner][spender];</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev See {IERC20-approve}.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on</span>
 130 |     | <span class='neutral'>     * `transferFrom`. This is semantically equivalent to an infinite approval.</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * Requirements:</span>
 133 |     | <span class='neutral'>     *</span>
 134 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 135 |     | <span class='neutral'>     */</span>
 136 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
 137 |     | <span class='neutral'>        address owner = _msgSender();</span>
 138 | *   | <span class='executed'>        _approve(owner, spender, amount);</span>
 139 | *   | <span class='executed'>        return true;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /**</span>
 143 |     | <span class='neutral'>     * @dev See {IERC20-transferFrom}.</span>
 144 |     | <span class='neutral'>     *</span>
 145 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance. This is not</span>
 146 |     | <span class='neutral'>     * required by the EIP. See the note at the beginning of {ERC20}.</span>
 147 |     | <span class='neutral'>     *</span>
 148 |     | <span class='neutral'>     * NOTE: Does not update the allowance if the current allowance</span>
 149 |     | <span class='neutral'>     * is the maximum `uint256`.</span>
 150 |     | <span class='neutral'>     *</span>
 151 |     | <span class='neutral'>     * Requirements:</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * - `from` and `to` cannot be the zero address.</span>
 154 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 155 |     | <span class='neutral'>     * - the caller must have allowance for ``from``&#39;s tokens of at least</span>
 156 |     | <span class='neutral'>     * `amount`.</span>
 157 |     | <span class='neutral'>     */</span>
 158 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 159 |     | <span class='neutral'>        address spender = _msgSender();</span>
 160 | *   | <span class='executed'>        _spendAllowance(from, spender, amount);</span>
 161 | *   | <span class='executed'>        _transfer(from, to, amount);</span>
 162 | *   | <span class='executed'>        return true;</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /**</span>
 166 |     | <span class='neutral'>     * @dev Atomically increases the allowance granted to `spender` by the caller.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 169 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 170 |     | <span class='neutral'>     *</span>
 171 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 172 |     | <span class='neutral'>     *</span>
 173 |     | <span class='neutral'>     * Requirements:</span>
 174 |     | <span class='neutral'>     *</span>
 175 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 176 |     | <span class='neutral'>     */</span>
 177 |     | <span class='unexecuted'>    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {</span>
 178 |     | <span class='neutral'>        address owner = _msgSender();</span>
 179 |     | <span class='unexecuted'>        _approve(owner, spender, allowance(owner, spender) + addedValue);</span>
 180 |     | <span class='neutral'>        return true;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /**</span>
 184 |     | <span class='neutral'>     * @dev Atomically decreases the allowance granted to `spender` by the caller.</span>
 185 |     | <span class='neutral'>     *</span>
 186 |     | <span class='neutral'>     * This is an alternative to {approve} that can be used as a mitigation for</span>
 187 |     | <span class='neutral'>     * problems described in {IERC20-approve}.</span>
 188 |     | <span class='neutral'>     *</span>
 189 |     | <span class='neutral'>     * Emits an {Approval} event indicating the updated allowance.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Requirements:</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 194 |     | <span class='neutral'>     * - `spender` must have allowance for the caller of at least</span>
 195 |     | <span class='neutral'>     * `subtractedValue`.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {</span>
 198 |     | <span class='neutral'>        address owner = _msgSender();</span>
 199 |     | <span class='unexecuted'>        uint256 currentAllowance = allowance(owner, spender);</span>
 200 |     | <span class='unexecuted'>        require(currentAllowance &gt;= subtractedValue, &quot;ERC20: decreased allowance below zero&quot;);</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='unexecuted'>            _approve(owner, spender, currentAllowance - subtractedValue);</span>
 203 |     | <span class='neutral'>        }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='unexecuted'>        return true;</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Moves `amount` of tokens from `from` to `to`.</span>
 210 |     | <span class='neutral'>     *</span>
 211 |     | <span class='neutral'>     * This internal function is equivalent to {transfer}, and can be used to</span>
 212 |     | <span class='neutral'>     * e.g. implement automatic token fees, slashing mechanisms, etc.</span>
 213 |     | <span class='neutral'>     *</span>
 214 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 215 |     | <span class='neutral'>     *</span>
 216 |     | <span class='neutral'>     * Requirements:</span>
 217 |     | <span class='neutral'>     *</span>
 218 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 220 |     | <span class='neutral'>     * - `from` must have a balance of at least `amount`.</span>
 221 |     | <span class='neutral'>     */</span>
 222 | *   | <span class='executed'>    function _transfer(address from, address to, uint256 amount) internal virtual {</span>
 223 | *   | <span class='executed'>        require(from != address(0), &quot;ERC20: transfer from the zero address&quot;);</span>
 224 | *   | <span class='executed'>        require(to != address(0), &quot;ERC20: transfer to the zero address&quot;);</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, amount);</span>
 227 |     | <span class='neutral'></span>
 228 | *   | <span class='executed'>        uint256 fromBalance = _balances[from];</span>
 229 | *   | <span class='executed'>        require(fromBalance &gt;= amount, &quot;ERC20: transfer amount exceeds balance&quot;);</span>
 230 |     | <span class='neutral'>        unchecked {</span>
 231 | *   | <span class='executed'>            _balances[from] = fromBalance - amount;</span>
 232 |     | <span class='neutral'>            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by</span>
 233 |     | <span class='neutral'>            // decrementing then incrementing.</span>
 234 | *   | <span class='executed'>            _balances[to] += amount;</span>
 235 |     | <span class='neutral'>        }</span>
 236 |     | <span class='neutral'></span>
 237 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 238 |     | <span class='neutral'></span>
 239 | *   | <span class='executed'>        _afterTokenTransfer(from, to, amount);</span>
 240 |     | <span class='neutral'>    }</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>    /** @dev Creates `amount` tokens and assigns them to `account`, increasing</span>
 243 |     | <span class='neutral'>     * the total supply.</span>
 244 |     | <span class='neutral'>     *</span>
 245 |     | <span class='neutral'>     * Emits a {Transfer} event with `from` set to the zero address.</span>
 246 |     | <span class='neutral'>     *</span>
 247 |     | <span class='neutral'>     * Requirements:</span>
 248 |     | <span class='neutral'>     *</span>
 249 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 250 |     | <span class='neutral'>     */</span>
 251 | *   | <span class='executed'>    function _mint(address account, uint256 amount) internal virtual {</span>
 252 | *   | <span class='executed'>        require(account != address(0), &quot;ERC20: mint to the zero address&quot;);</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), account, amount);</span>
 255 |     | <span class='neutral'></span>
 256 | *   | <span class='executed'>        _totalSupply += amount;</span>
 257 |     | <span class='neutral'>        unchecked {</span>
 258 |     | <span class='neutral'>            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.</span>
 259 | *   | <span class='executed'>            _balances[account] += amount;</span>
 260 |     | <span class='neutral'>        }</span>
 261 | *   | <span class='executed'>        emit Transfer(address(0), account, amount);</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>        _afterTokenTransfer(address(0), account, amount);</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='neutral'>    /**</span>
 267 |     | <span class='neutral'>     * @dev Destroys `amount` tokens from `account`, reducing the</span>
 268 |     | <span class='neutral'>     * total supply.</span>
 269 |     | <span class='neutral'>     *</span>
 270 |     | <span class='neutral'>     * Emits a {Transfer} event with `to` set to the zero address.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * Requirements:</span>
 273 |     | <span class='neutral'>     *</span>
 274 |     | <span class='neutral'>     * - `account` cannot be the zero address.</span>
 275 |     | <span class='neutral'>     * - `account` must have at least `amount` tokens.</span>
 276 |     | <span class='neutral'>     */</span>
 277 | *   | <span class='executed'>    function _burn(address account, uint256 amount) internal virtual {</span>
 278 |     | <span class='unexecuted'>        require(account != address(0), &quot;ERC20: burn from the zero address&quot;);</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>        _beforeTokenTransfer(account, address(0), amount);</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='unexecuted'>        uint256 accountBalance = _balances[account];</span>
 283 |     | <span class='unexecuted'>        require(accountBalance &gt;= amount, &quot;ERC20: burn amount exceeds balance&quot;);</span>
 284 |     | <span class='neutral'>        unchecked {</span>
 285 |     | <span class='unexecuted'>            _balances[account] = accountBalance - amount;</span>
 286 |     | <span class='neutral'>            // Overflow not possible: amount &lt;= accountBalance &lt;= totalSupply.</span>
 287 |     | <span class='unexecuted'>            _totalSupply -= amount;</span>
 288 |     | <span class='neutral'>        }</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>        emit Transfer(account, address(0), amount);</span>
 291 |     | <span class='neutral'></span>
 292 | *   | <span class='executed'>        _afterTokenTransfer(account, address(0), amount);</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    /**</span>
 296 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.</span>
 297 |     | <span class='neutral'>     *</span>
 298 |     | <span class='neutral'>     * This internal function is equivalent to `approve`, and can be used to</span>
 299 |     | <span class='neutral'>     * e.g. set automatic allowances for certain subsystems, etc.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 302 |     | <span class='neutral'>     *</span>
 303 |     | <span class='neutral'>     * Requirements:</span>
 304 |     | <span class='neutral'>     *</span>
 305 |     | <span class='neutral'>     * - `owner` cannot be the zero address.</span>
 306 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 307 |     | <span class='neutral'>     */</span>
 308 | *   | <span class='executed'>    function _approve(address owner, address spender, uint256 amount) internal virtual {</span>
 309 | *   | <span class='executed'>        require(owner != address(0), &quot;ERC20: approve from the zero address&quot;);</span>
 310 | *   | <span class='executed'>        require(spender != address(0), &quot;ERC20: approve to the zero address&quot;);</span>
 311 |     | <span class='neutral'></span>
 312 | *   | <span class='executed'>        _allowances[owner][spender] = amount;</span>
 313 | *   | <span class='executed'>        emit Approval(owner, spender, amount);</span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /**</span>
 317 |     | <span class='neutral'>     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.</span>
 318 |     | <span class='neutral'>     *</span>
 319 |     | <span class='neutral'>     * Does not update the allowance amount in case of infinite allowance.</span>
 320 |     | <span class='neutral'>     * Revert if not enough allowance is available.</span>
 321 |     | <span class='neutral'>     *</span>
 322 |     | <span class='neutral'>     * Might emit an {Approval} event.</span>
 323 |     | <span class='neutral'>     */</span>
 324 | *   | <span class='executed'>    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {</span>
 325 | *   | <span class='executed'>        uint256 currentAllowance = allowance(owner, spender);</span>
 326 | *   | <span class='executed'>        if (currentAllowance != type(uint256).max) {</span>
 327 |     | <span class='unexecuted'>            require(currentAllowance &gt;= amount, &quot;ERC20: insufficient allowance&quot;);</span>
 328 |     | <span class='neutral'>            unchecked {</span>
 329 | *   | <span class='executed'>                _approve(owner, spender, currentAllowance - amount);</span>
 330 |     | <span class='neutral'>            }</span>
 331 |     | <span class='neutral'>        }</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>    /**</span>
 335 |     | <span class='neutral'>     * @dev Hook that is called before any transfer of tokens. This includes</span>
 336 |     | <span class='neutral'>     * minting and burning.</span>
 337 |     | <span class='neutral'>     *</span>
 338 |     | <span class='neutral'>     * Calling conditions:</span>
 339 |     | <span class='neutral'>     *</span>
 340 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 341 |     | <span class='neutral'>     * will be transferred to `to`.</span>
 342 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens will be minted for `to`.</span>
 343 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens will be burned.</span>
 344 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 345 |     | <span class='neutral'>     *</span>
 346 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 347 |     | <span class='neutral'>     */</span>
 348 |     | <span class='unexecuted'>    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 349 |     | <span class='neutral'></span>
 350 |     | <span class='neutral'>    /**</span>
 351 |     | <span class='neutral'>     * @dev Hook that is called after any transfer of tokens. This includes</span>
 352 |     | <span class='neutral'>     * minting and burning.</span>
 353 |     | <span class='neutral'>     *</span>
 354 |     | <span class='neutral'>     * Calling conditions:</span>
 355 |     | <span class='neutral'>     *</span>
 356 |     | <span class='neutral'>     * - when `from` and `to` are both non-zero, `amount` of ``from``&#39;s tokens</span>
 357 |     | <span class='neutral'>     * has been transferred to `to`.</span>
 358 |     | <span class='neutral'>     * - when `from` is zero, `amount` tokens have been minted for `to`.</span>
 359 |     | <span class='neutral'>     * - when `to` is zero, `amount` of ``from``&#39;s tokens have been burned.</span>
 360 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 361 |     | <span class='neutral'>     *</span>
 362 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 363 |     | <span class='neutral'>     */</span>
 364 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}</span>
 365 |     | <span class='neutral'>}</span>
 366 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 standard as defined in the EIP.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='neutral'>interface IERC20 {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Emitted when `value` tokens are moved from one account (`from`) to</span>
 12 |     | <span class='neutral'>     * another (`to`).</span>
 13 |     | <span class='neutral'>     *</span>
 14 |     | <span class='neutral'>     * Note that `value` may be zero.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Emitted when the allowance of a `spender` for an `owner` is set by</span>
 20 |     | <span class='neutral'>     * a call to {approve}. `value` is the new allowance.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the amount of tokens in existence.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /**</span>
 30 |     | <span class='neutral'>     * @dev Returns the amount of tokens owned by `account`.</span>
 31 |     | <span class='neutral'>     */</span>
 32 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 36 |     | <span class='neutral'>     *</span>
 37 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 38 |     | <span class='neutral'>     *</span>
 39 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 40 |     | <span class='neutral'>     */</span>
 41 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Returns the remaining number of tokens that `spender` will be</span>
 45 |     | <span class='neutral'>     * allowed to spend on behalf of `owner` through {transferFrom}. This is</span>
 46 |     | <span class='neutral'>     * zero by default.</span>
 47 |     | <span class='neutral'>     *</span>
 48 |     | <span class='neutral'>     * This value changes when {approve} or {transferFrom} are called.</span>
 49 |     | <span class='neutral'>     */</span>
 50 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /**</span>
 53 |     | <span class='neutral'>     * @dev Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 54 |     | <span class='neutral'>     *</span>
 55 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 56 |     | <span class='neutral'>     *</span>
 57 |     | <span class='neutral'>     * IMPORTANT: Beware that changing an allowance with this method brings the risk</span>
 58 |     | <span class='neutral'>     * that someone may use both the old and the new allowance by unfortunate</span>
 59 |     | <span class='neutral'>     * transaction ordering. One possible solution to mitigate this race</span>
 60 |     | <span class='neutral'>     * condition is to first reduce the spender&#39;s allowance to 0 and set the</span>
 61 |     | <span class='neutral'>     * desired value afterwards:</span>
 62 |     | <span class='neutral'>     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /**</span>
 69 |     | <span class='neutral'>     * @dev Moves `amount` tokens from `from` to `to` using the</span>
 70 |     | <span class='neutral'>     * allowance mechanism. `amount` is then deducted from the caller&#39;s</span>
 71 |     | <span class='neutral'>     * allowance.</span>
 72 |     | <span class='neutral'>     *</span>
 73 |     | <span class='neutral'>     * Returns a boolean value indicating whether the operation succeeded.</span>
 74 |     | <span class='neutral'>     *</span>
 75 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 76 |     | <span class='neutral'>     */</span>
 77 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 78 |     | <span class='neutral'>}</span>
 79 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/ERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC20Permit.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../ERC20.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../../../utils/cryptography/ECDSA.sol&quot;;</span>
  9 |     | <span class='neutral'>import &quot;../../../utils/cryptography/EIP712.sol&quot;;</span>
 10 |     | <span class='neutral'>import &quot;../../../utils/Counters.sol&quot;;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>/**</span>
 13 |     | <span class='neutral'> * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
 14 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 17 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn&#39;t</span>
 18 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * _Available since v3.4._</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {</span>
 23 |     | <span class='neutral'>    using Counters for Counters.Counter;</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    mapping(address =&gt; Counters.Counter) private _nonces;</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 28 |     | <span class='neutral'>    bytes32 private constant _PERMIT_TYPEHASH =</span>
 29 |     | <span class='unexecuted'>        keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 30 |     | <span class='neutral'>    /**</span>
 31 |     | <span class='neutral'>     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.</span>
 32 |     | <span class='neutral'>     * However, to ensure consistency with the upgradeable transpiler, we will continue</span>
 33 |     | <span class='neutral'>     * to reserve a slot.</span>
 34 |     | <span class='neutral'>     * @custom:oz-renamed-from _PERMIT_TYPEHASH</span>
 35 |     | <span class='neutral'>     */</span>
 36 |     | <span class='neutral'>    // solhint-disable-next-line var-name-mixedcase</span>
 37 |     | <span class='neutral'>    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /**</span>
 40 |     | <span class='neutral'>     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `&quot;1&quot;`.</span>
 41 |     | <span class='neutral'>     *</span>
 42 |     | <span class='neutral'>     * It&#39;s a good idea to use the same `name` that is defined as the ERC20 token name.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='unexecuted'>    constructor(string memory name) EIP712(name, &quot;1&quot;) {}</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    /**</span>
 47 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 48 |     | <span class='neutral'>     */</span>
 49 |     | <span class='unexecuted'>    function permit(</span>
 50 |     | <span class='neutral'>        address owner,</span>
 51 |     | <span class='neutral'>        address spender,</span>
 52 |     | <span class='neutral'>        uint256 value,</span>
 53 |     | <span class='neutral'>        uint256 deadline,</span>
 54 |     | <span class='neutral'>        uint8 v,</span>
 55 |     | <span class='neutral'>        bytes32 r,</span>
 56 |     | <span class='neutral'>        bytes32 s</span>
 57 |     | <span class='unexecuted'>    ) public virtual override {</span>
 58 |     | <span class='unexecuted'>        require(block.timestamp &lt;= deadline, &quot;ERC20Permit: expired deadline&quot;);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='unexecuted'>        bytes32 hash = _hashTypedDataV4(structHash);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>        address signer = ECDSA.recover(hash, v, r, s);</span>
 65 |     | <span class='unexecuted'>        require(signer == owner, &quot;ERC20Permit: invalid signature&quot;);</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>        _approve(owner, spender, value);</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    /**</span>
 71 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 72 |     | <span class='neutral'>     */</span>
 73 |     | <span class='unexecuted'>    function nonces(address owner) public view virtual override returns (uint256) {</span>
 74 |     | <span class='unexecuted'>        return _nonces[owner].current();</span>
 75 |     | <span class='neutral'>    }</span>
 76 |     | <span class='neutral'></span>
 77 |     | <span class='neutral'>    /**</span>
 78 |     | <span class='neutral'>     * @inheritdoc IERC20Permit</span>
 79 |     | <span class='neutral'>     */</span>
 80 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 81 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() external view override returns (bytes32) {</span>
 82 |     | <span class='unexecuted'>        return _domainSeparatorV4();</span>
 83 |     | <span class='neutral'>    }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev &quot;Consume a nonce&quot;: return the current value and increment.</span>
 87 |     | <span class='neutral'>     *</span>
 88 |     | <span class='neutral'>     * _Available since v4.1._</span>
 89 |     | <span class='neutral'>     */</span>
 90 |     | <span class='unexecuted'>    function _useNonce(address owner) internal virtual returns (uint256 current) {</span>
 91 |     | <span class='unexecuted'>        Counters.Counter storage nonce = _nonces[owner];</span>
 92 |     | <span class='neutral'>        current = nonce.current();</span>
 93 |     | <span class='unexecuted'>        nonce.increment();</span>
 94 |     | <span class='neutral'>    }</span>
 95 |     | <span class='neutral'>}</span>
 96 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Interface for the optional metadata functions from the ERC20 standard.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * _Available since v4.1._</span>
 12 |     | <span class='neutral'> */</span>
 13 |     | <span class='neutral'>interface IERC20Metadata is IERC20 {</span>
 14 |     | <span class='neutral'>    /**</span>
 15 |     | <span class='neutral'>     * @dev Returns the name of the token.</span>
 16 |     | <span class='neutral'>     */</span>
 17 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /**</span>
 20 |     | <span class='neutral'>     * @dev Returns the symbol of the token.</span>
 21 |     | <span class='neutral'>     */</span>
 22 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the decimals places of the token.</span>
 26 |     | <span class='neutral'>     */</span>
 27 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Adds the {permit} method, which can be used to change an account&#39;s ERC20 allowance (see {IERC20-allowance}) by</span>
 11 |     | <span class='neutral'> * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn&#39;t</span>
 12 |     | <span class='neutral'> * need to send a transaction, and thus is not required to hold Ether at all.</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ==== Security Considerations</span>
 15 |     | <span class='neutral'> *</span>
 16 |     | <span class='neutral'> * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature</span>
 17 |     | <span class='neutral'> * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be</span>
 18 |     | <span class='neutral'> * considered as an intention to spend the allowance in any specific way. The second is that because permits have</span>
 19 |     | <span class='neutral'> * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should</span>
 20 |     | <span class='neutral'> * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be</span>
 21 |     | <span class='neutral'> * generally recommended is:</span>
 22 |     | <span class='neutral'> *</span>
 23 |     | <span class='neutral'> * ```solidity</span>
 24 |     | <span class='neutral'> * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {</span>
 25 |     | <span class='neutral'> *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}</span>
 26 |     | <span class='neutral'> *     doThing(..., value);</span>
 27 |     | <span class='neutral'> * }</span>
 28 |     | <span class='neutral'> *</span>
 29 |     | <span class='neutral'> * function doThing(..., uint256 value) public {</span>
 30 |     | <span class='neutral'> *     token.safeTransferFrom(msg.sender, address(this), value);</span>
 31 |     | <span class='neutral'> *     ...</span>
 32 |     | <span class='neutral'> * }</span>
 33 |     | <span class='neutral'> * ```</span>
 34 |     | <span class='neutral'> *</span>
 35 |     | <span class='neutral'> * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of</span>
 36 |     | <span class='neutral'> * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also</span>
 37 |     | <span class='neutral'> * {SafeERC20-safeTransferFrom}).</span>
 38 |     | <span class='neutral'> *</span>
 39 |     | <span class='neutral'> * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so</span>
 40 |     | <span class='neutral'> * contracts should have entry points that don&#39;t rely on permit.</span>
 41 |     | <span class='neutral'> */</span>
 42 |     | <span class='neutral'>interface IERC20Permit {</span>
 43 |     | <span class='neutral'>    /**</span>
 44 |     | <span class='neutral'>     * @dev Sets `value` as the allowance of `spender` over ``owner``&#39;s tokens,</span>
 45 |     | <span class='neutral'>     * given ``owner``&#39;s signed approval.</span>
 46 |     | <span class='neutral'>     *</span>
 47 |     | <span class='neutral'>     * IMPORTANT: The same issues {IERC20-approve} has related to transaction</span>
 48 |     | <span class='neutral'>     * ordering also apply here.</span>
 49 |     | <span class='neutral'>     *</span>
 50 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 51 |     | <span class='neutral'>     *</span>
 52 |     | <span class='neutral'>     * Requirements:</span>
 53 |     | <span class='neutral'>     *</span>
 54 |     | <span class='neutral'>     * - `spender` cannot be the zero address.</span>
 55 |     | <span class='neutral'>     * - `deadline` must be a timestamp in the future.</span>
 56 |     | <span class='neutral'>     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`</span>
 57 |     | <span class='neutral'>     * over the EIP712-formatted function arguments.</span>
 58 |     | <span class='neutral'>     * - the signature must use ``owner``&#39;s current nonce (see {nonces}).</span>
 59 |     | <span class='neutral'>     *</span>
 60 |     | <span class='neutral'>     * For more information on the signature format, see the</span>
 61 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP</span>
 62 |     | <span class='neutral'>     * section].</span>
 63 |     | <span class='neutral'>     *</span>
 64 |     | <span class='neutral'>     * CAUTION: See Security Considerations above.</span>
 65 |     | <span class='neutral'>     */</span>
 66 |     | <span class='neutral'>    function permit(</span>
 67 |     | <span class='neutral'>        address owner,</span>
 68 |     | <span class='neutral'>        address spender,</span>
 69 |     | <span class='neutral'>        uint256 value,</span>
 70 |     | <span class='neutral'>        uint256 deadline,</span>
 71 |     | <span class='neutral'>        uint8 v,</span>
 72 |     | <span class='neutral'>        bytes32 r,</span>
 73 |     | <span class='neutral'>        bytes32 s</span>
 74 |     | <span class='neutral'>    ) external;</span>
 75 |     | <span class='neutral'></span>
 76 |     | <span class='neutral'>    /**</span>
 77 |     | <span class='neutral'>     * @dev Returns the current nonce for `owner`. This value must be</span>
 78 |     | <span class='neutral'>     * included whenever a signature is generated for {permit}.</span>
 79 |     | <span class='neutral'>     *</span>
 80 |     | <span class='neutral'>     * Every successful call to {permit} increases ``owner``&#39;s nonce by one. This</span>
 81 |     | <span class='neutral'>     * prevents a signature from being used multiple times.</span>
 82 |     | <span class='neutral'>     */</span>
 83 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>    /**</span>
 86 |     | <span class='neutral'>     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.</span>
 87 |     | <span class='neutral'>     */</span>
 88 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 89 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 90 |     | <span class='neutral'>}</span>
 91 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../IERC20.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../extensions/IERC20Permit.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../../utils/Address.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @title SafeERC20</span>
  12 |     | <span class='neutral'> * @dev Wrappers around ERC20 operations that throw on failure (when the token</span>
  13 |     | <span class='neutral'> * contract returns false). Tokens that return no value (and instead revert or</span>
  14 |     | <span class='neutral'> * throw on failure) are also supported, non-reverting calls are assumed to be</span>
  15 |     | <span class='neutral'> * successful.</span>
  16 |     | <span class='neutral'> * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,</span>
  17 |     | <span class='neutral'> * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>library SafeERC20 {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,</span>
  24 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='unexecuted'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
  27 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the</span>
  32 |     | <span class='neutral'>     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.</span>
  33 |     | <span class='neutral'>     */</span>
  34 | *   | <span class='executed'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
  35 | *   | <span class='executed'>        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));</span>
  36 |     | <span class='neutral'>    }</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /**</span>
  39 |     | <span class='neutral'>     * @dev Deprecated. This function has issues similar to the ones found in</span>
  40 |     | <span class='neutral'>     * {IERC20-approve}, and its usage is discouraged.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * Whenever possible, use {safeIncreaseAllowance} and</span>
  43 |     | <span class='neutral'>     * {safeDecreaseAllowance} instead.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='unexecuted'>    function safeApprove(IERC20 token, address spender, uint256 value) internal {</span>
  46 |     | <span class='neutral'>        // safeApprove should only be called when setting an initial allowance,</span>
  47 |     | <span class='neutral'>        // or when resetting it to zero. To increase and decrease it, use</span>
  48 |     | <span class='neutral'>        // &#39;safeIncreaseAllowance&#39; and &#39;safeDecreaseAllowance&#39;</span>
  49 |     | <span class='unexecuted'>        require(</span>
  50 |     | <span class='unexecuted'>            (value == 0) || (token.allowance(address(this), spender) == 0),</span>
  51 |     | <span class='neutral'>            &quot;SafeERC20: approve from non-zero to non-zero allowance&quot;</span>
  52 |     | <span class='neutral'>        );</span>
  53 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Increase the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  58 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='unexecuted'>    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  61 |     | <span class='unexecuted'>        uint256 oldAllowance = token.allowance(address(this), spender);</span>
  62 |     | <span class='unexecuted'>        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /**</span>
  66 |     | <span class='neutral'>     * @dev Decrease the calling contract&#39;s allowance toward `spender` by `value`. If `token` returns no value,</span>
  67 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful.</span>
  68 |     | <span class='neutral'>     */</span>
  69 |     | <span class='unexecuted'>    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {</span>
  70 |     | <span class='neutral'>        unchecked {</span>
  71 |     | <span class='unexecuted'>            uint256 oldAllowance = token.allowance(address(this), spender);</span>
  72 |     | <span class='unexecuted'>            require(oldAllowance &gt;= value, &quot;SafeERC20: decreased allowance below zero&quot;);</span>
  73 |     | <span class='unexecuted'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * @dev Set the calling contract&#39;s allowance toward `spender` to `value`. If `token` returns no value,</span>
  79 |     | <span class='neutral'>     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval</span>
  80 |     | <span class='neutral'>     * to be set to zero before setting it to a non-zero value, such as USDT.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function forceApprove(IERC20 token, address spender, uint256 value) internal {</span>
  83 |     | <span class='neutral'>        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        if (!_callOptionalReturnBool(token, approvalCall)) {</span>
  86 |     | <span class='neutral'>            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));</span>
  87 |     | <span class='neutral'>            _callOptionalReturn(token, approvalCall);</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    /**</span>
  92 |     | <span class='neutral'>     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.</span>
  93 |     | <span class='neutral'>     * Revert on invalid signature.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    function safePermit(</span>
  96 |     | <span class='neutral'>        IERC20Permit token,</span>
  97 |     | <span class='neutral'>        address owner,</span>
  98 |     | <span class='neutral'>        address spender,</span>
  99 |     | <span class='neutral'>        uint256 value,</span>
 100 |     | <span class='neutral'>        uint256 deadline,</span>
 101 |     | <span class='neutral'>        uint8 v,</span>
 102 |     | <span class='neutral'>        bytes32 r,</span>
 103 |     | <span class='neutral'>        bytes32 s</span>
 104 |     | <span class='neutral'>    ) internal {</span>
 105 |     | <span class='neutral'>        uint256 nonceBefore = token.nonces(owner);</span>
 106 |     | <span class='neutral'>        token.permit(owner, spender, value, deadline, v, r, s);</span>
 107 |     | <span class='neutral'>        uint256 nonceAfter = token.nonces(owner);</span>
 108 |     | <span class='neutral'>        require(nonceAfter == nonceBefore + 1, &quot;SafeERC20: permit did not succeed&quot;);</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /**</span>
 112 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 113 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 114 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 115 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 116 |     | <span class='neutral'>     */</span>
 117 | *   | <span class='executed'>    function _callOptionalReturn(IERC20 token, bytes memory data) private {</span>
 118 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 119 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that</span>
 120 |     | <span class='neutral'>        // the target address contains contract code and also asserts for success in the low-level call.</span>
 121 |     | <span class='neutral'></span>
 122 | *   | <span class='executed'>        bytes memory returndata = address(token).functionCall(data, &quot;SafeERC20: low-level call failed&quot;);</span>
 123 | *   | <span class='executed'>        require(returndata.length == 0 || abi.decode(returndata, (bool)), &quot;SafeERC20: ERC20 operation did not succeed&quot;);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement</span>
 128 |     | <span class='neutral'>     * on the return value: the return value is optional (but if data is returned, it must not be false).</span>
 129 |     | <span class='neutral'>     * @param token The token targeted by the call.</span>
 130 |     | <span class='neutral'>     * @param data The call data (encoded using abi.encode or one of its variants).</span>
 131 |     | <span class='neutral'>     *</span>
 132 |     | <span class='neutral'>     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.</span>
 133 |     | <span class='neutral'>     */</span>
 134 |     | <span class='neutral'>    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {</span>
 135 |     | <span class='neutral'>        // We need to perform a low level call here, to bypass Solidity&#39;s return data size checking mechanism, since</span>
 136 |     | <span class='neutral'>        // we&#39;re implementing it ourselves. We cannot use {Address-functionCall} here since this should return false</span>
 137 |     | <span class='neutral'>        // and not revert is the subcall reverts.</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>        (bool success, bytes memory returndata) = address(token).call(data);</span>
 140 |     | <span class='neutral'>        return</span>
 141 |     | <span class='neutral'>            success &amp;&amp; (returndata.length == 0 || abi.decode(returndata, (bool))) &amp;&amp; Address.isContract(address(token));</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'>}</span>
 144 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/ERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/ERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./IERC721.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./IERC721Receiver.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./extensions/IERC721Metadata.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;../../utils/Address.sol&quot;;</span>
  10 |     | <span class='neutral'>import &quot;../../utils/Context.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;../../utils/Strings.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;../../utils/introspection/ERC165.sol&quot;;</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='neutral'>/**</span>
  15 |     | <span class='neutral'> * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including</span>
  16 |     | <span class='neutral'> * the Metadata extension, but not including the Enumerable extension, which is available separately as</span>
  17 |     | <span class='neutral'> * {ERC721Enumerable}.</span>
  18 |     | <span class='neutral'> */</span>
  19 |     | <span class='unexecuted'>contract ERC721 is Context, ERC165, IERC721, IERC721Metadata {</span>
  20 |     | <span class='neutral'>    using Address for address;</span>
  21 |     | <span class='neutral'>    using Strings for uint256;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    // Token name</span>
  24 |     | <span class='neutral'>    string private _name;</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    // Token symbol</span>
  27 |     | <span class='neutral'>    string private _symbol;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    // Mapping from token ID to owner address</span>
  30 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _owners;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    // Mapping owner address to token count</span>
  33 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _balances;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    // Mapping from token ID to approved address</span>
  36 |     | <span class='neutral'>    mapping(uint256 =&gt; address) private _tokenApprovals;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    // Mapping from owner to operator approvals</span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  45 |     | <span class='unexecuted'>        _name = name_;</span>
  46 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /**</span>
  50 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {</span>
  53 |     | <span class='unexecuted'>        return</span>
  54 |     | <span class='unexecuted'>            interfaceId == type(IERC721).interfaceId ||</span>
  55 |     | <span class='unexecuted'>            interfaceId == type(IERC721Metadata).interfaceId ||</span>
  56 |     | <span class='unexecuted'>            super.supportsInterface(interfaceId);</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev See {IERC721-balanceOf}.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  63 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC721: address zero is not a valid owner&quot;);</span>
  64 |     | <span class='unexecuted'>        return _balances[owner];</span>
  65 |     | <span class='neutral'>    }</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * @dev See {IERC721-ownerOf}.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='unexecuted'>    function ownerOf(uint256 tokenId) public view virtual override returns (address) {</span>
  71 |     | <span class='neutral'>        address owner = _ownerOf(tokenId);</span>
  72 |     | <span class='unexecuted'>        require(owner != address(0), &quot;ERC721: invalid token ID&quot;);</span>
  73 |     | <span class='neutral'>        return owner;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /**</span>
  77 |     | <span class='neutral'>     * @dev See {IERC721Metadata-name}.</span>
  78 |     | <span class='neutral'>     */</span>
  79 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  80 |     | <span class='unexecuted'>        return _name;</span>
  81 |     | <span class='neutral'>    }</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /**</span>
  84 |     | <span class='neutral'>     * @dev See {IERC721Metadata-symbol}.</span>
  85 |     | <span class='neutral'>     */</span>
  86 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  87 |     | <span class='unexecuted'>        return _symbol;</span>
  88 |     | <span class='neutral'>    }</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev See {IERC721Metadata-tokenURI}.</span>
  92 |     | <span class='neutral'>     */</span>
  93 |     | <span class='unexecuted'>    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {</span>
  94 |     | <span class='unexecuted'>        _requireMinted(tokenId);</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='unexecuted'>        string memory baseURI = _baseURI();</span>
  97 |     | <span class='unexecuted'>        return bytes(baseURI).length &gt; 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : &quot;&quot;;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /**</span>
 101 |     | <span class='neutral'>     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each</span>
 102 |     | <span class='neutral'>     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty</span>
 103 |     | <span class='neutral'>     * by default, can be overridden in child contracts.</span>
 104 |     | <span class='neutral'>     */</span>
 105 |     | <span class='unexecuted'>    function _baseURI() internal view virtual returns (string memory) {</span>
 106 |     | <span class='unexecuted'>        return &quot;&quot;;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev See {IERC721-approve}.</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='unexecuted'>    function approve(address to, uint256 tokenId) public virtual override {</span>
 113 |     | <span class='unexecuted'>        address owner = ERC721.ownerOf(tokenId);</span>
 114 |     | <span class='unexecuted'>        require(to != owner, &quot;ERC721: approval to current owner&quot;);</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='unexecuted'>        require(</span>
 117 |     | <span class='unexecuted'>            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),</span>
 118 |     | <span class='neutral'>            &quot;ERC721: approve caller is not token owner or approved for all&quot;</span>
 119 |     | <span class='neutral'>        );</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>        _approve(to, tokenId);</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /**</span>
 125 |     | <span class='neutral'>     * @dev See {IERC721-getApproved}.</span>
 126 |     | <span class='neutral'>     */</span>
 127 |     | <span class='unexecuted'>    function getApproved(uint256 tokenId) public view virtual override returns (address) {</span>
 128 |     | <span class='unexecuted'>        _requireMinted(tokenId);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        return _tokenApprovals[tokenId];</span>
 131 |     | <span class='neutral'>    }</span>
 132 |     | <span class='neutral'></span>
 133 |     | <span class='neutral'>    /**</span>
 134 |     | <span class='neutral'>     * @dev See {IERC721-setApprovalForAll}.</span>
 135 |     | <span class='neutral'>     */</span>
 136 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
 137 |     | <span class='unexecuted'>        _setApprovalForAll(_msgSender(), operator, approved);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='neutral'>    /**</span>
 141 |     | <span class='neutral'>     * @dev See {IERC721-isApprovedForAll}.</span>
 142 |     | <span class='neutral'>     */</span>
 143 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
 144 |     | <span class='unexecuted'>        return _operatorApprovals[owner][operator];</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev See {IERC721-transferFrom}.</span>
 149 |     | <span class='neutral'>     */</span>
 150 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 151 |     | <span class='neutral'>        //solhint-disable-next-line max-line-length</span>
 152 |     | <span class='unexecuted'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 tokenId) public virtual override {</span>
 161 |     | <span class='unexecuted'>        safeTransferFrom(from, to, tokenId, &quot;&quot;);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev See {IERC721-safeTransferFrom}.</span>
 166 |     | <span class='neutral'>     */</span>
 167 |     | <span class='unexecuted'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual override {</span>
 168 |     | <span class='unexecuted'>        require(_isApprovedOrOwner(_msgSender(), tokenId), &quot;ERC721: caller is not token owner or approved&quot;);</span>
 169 |     | <span class='unexecuted'>        _safeTransfer(from, to, tokenId, data);</span>
 170 |     | <span class='neutral'>    }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    /**</span>
 173 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
 174 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
 175 |     | <span class='neutral'>     *</span>
 176 |     | <span class='neutral'>     * `data` is additional data, it has no specified format and it is sent in call to `to`.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.</span>
 179 |     | <span class='neutral'>     * implement alternative mechanisms to perform token transfer, such as signature-based.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * Requirements:</span>
 182 |     | <span class='neutral'>     *</span>
 183 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 184 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 185 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
 186 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 187 |     | <span class='neutral'>     *</span>
 188 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 189 |     | <span class='neutral'>     */</span>
 190 |     | <span class='unexecuted'>    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 191 |     | <span class='unexecuted'>        _transfer(from, to, tokenId);</span>
 192 |     | <span class='unexecuted'>        require(_checkOnERC721Received(from, to, tokenId, data), &quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn&#39;t exist</span>
 197 |     | <span class='neutral'>     */</span>
 198 |     | <span class='neutral'>    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {</span>
 199 |     | <span class='unexecuted'>        return _owners[tokenId];</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /**</span>
 203 |     | <span class='neutral'>     * @dev Returns whether `tokenId` exists.</span>
 204 |     | <span class='neutral'>     *</span>
 205 |     | <span class='neutral'>     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.</span>
 206 |     | <span class='neutral'>     *</span>
 207 |     | <span class='neutral'>     * Tokens start existing when they are minted (`_mint`),</span>
 208 |     | <span class='neutral'>     * and stop existing when they are burned (`_burn`).</span>
 209 |     | <span class='neutral'>     */</span>
 210 |     | <span class='unexecuted'>    function _exists(uint256 tokenId) internal view virtual returns (bool) {</span>
 211 |     | <span class='neutral'>        return _ownerOf(tokenId) != address(0);</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='neutral'></span>
 214 |     | <span class='neutral'>    /**</span>
 215 |     | <span class='neutral'>     * @dev Returns whether `spender` is allowed to manage `tokenId`.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * Requirements:</span>
 218 |     | <span class='neutral'>     *</span>
 219 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 220 |     | <span class='neutral'>     */</span>
 221 |     | <span class='unexecuted'>    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {</span>
 222 |     | <span class='unexecuted'>        address owner = ERC721.ownerOf(tokenId);</span>
 223 |     | <span class='unexecuted'>        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /**</span>
 227 |     | <span class='neutral'>     * @dev Safely mints `tokenId` and transfers it to `to`.</span>
 228 |     | <span class='neutral'>     *</span>
 229 |     | <span class='neutral'>     * Requirements:</span>
 230 |     | <span class='neutral'>     *</span>
 231 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 232 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 233 |     | <span class='neutral'>     *</span>
 234 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 235 |     | <span class='neutral'>     */</span>
 236 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId) internal virtual {</span>
 237 |     | <span class='neutral'>        _safeMint(to, tokenId, &quot;&quot;);</span>
 238 |     | <span class='neutral'>    }</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='neutral'>    /**</span>
 241 |     | <span class='neutral'>     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is</span>
 242 |     | <span class='neutral'>     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.</span>
 243 |     | <span class='neutral'>     */</span>
 244 |     | <span class='neutral'>    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {</span>
 245 |     | <span class='neutral'>        _mint(to, tokenId);</span>
 246 |     | <span class='neutral'>        require(</span>
 247 |     | <span class='neutral'>            _checkOnERC721Received(address(0), to, tokenId, data),</span>
 248 |     | <span class='neutral'>            &quot;ERC721: transfer to non ERC721Receiver implementer&quot;</span>
 249 |     | <span class='neutral'>        );</span>
 250 |     | <span class='neutral'>    }</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>    /**</span>
 253 |     | <span class='neutral'>     * @dev Mints `tokenId` and transfers it to `to`.</span>
 254 |     | <span class='neutral'>     *</span>
 255 |     | <span class='neutral'>     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible</span>
 256 |     | <span class='neutral'>     *</span>
 257 |     | <span class='neutral'>     * Requirements:</span>
 258 |     | <span class='neutral'>     *</span>
 259 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 260 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 261 |     | <span class='neutral'>     *</span>
 262 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 263 |     | <span class='neutral'>     */</span>
 264 |     | <span class='neutral'>    function _mint(address to, uint256 tokenId) internal virtual {</span>
 265 |     | <span class='neutral'>        require(to != address(0), &quot;ERC721: mint to the zero address&quot;);</span>
 266 |     | <span class='neutral'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        _beforeTokenTransfer(address(0), to, tokenId, 1);</span>
 269 |     | <span class='neutral'></span>
 270 |     | <span class='neutral'>        // Check that tokenId was not minted by `_beforeTokenTransfer` hook</span>
 271 |     | <span class='neutral'>        require(!_exists(tokenId), &quot;ERC721: token already minted&quot;);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='neutral'>        unchecked {</span>
 274 |     | <span class='neutral'>            // Will not overflow unless all 2**256 token ids are minted to the same owner.</span>
 275 |     | <span class='neutral'>            // Given that tokens are minted one by one, it is impossible in practice that</span>
 276 |     | <span class='neutral'>            // this ever happens. Might change if we allow batch minting.</span>
 277 |     | <span class='neutral'>            // The ERC fails to describe this case.</span>
 278 |     | <span class='neutral'>            _balances[to] += 1;</span>
 279 |     | <span class='neutral'>        }</span>
 280 |     | <span class='neutral'></span>
 281 |     | <span class='neutral'>        _owners[tokenId] = to;</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        emit Transfer(address(0), to, tokenId);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>        _afterTokenTransfer(address(0), to, tokenId, 1);</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    /**</span>
 289 |     | <span class='neutral'>     * @dev Destroys `tokenId`.</span>
 290 |     | <span class='neutral'>     * The approval is cleared when the token is burned.</span>
 291 |     | <span class='neutral'>     * This is an internal function that does not check if the sender is authorized to operate on the token.</span>
 292 |     | <span class='neutral'>     *</span>
 293 |     | <span class='neutral'>     * Requirements:</span>
 294 |     | <span class='neutral'>     *</span>
 295 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 296 |     | <span class='neutral'>     *</span>
 297 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 298 |     | <span class='neutral'>     */</span>
 299 |     | <span class='neutral'>    function _burn(uint256 tokenId) internal virtual {</span>
 300 |     | <span class='neutral'>        address owner = ERC721.ownerOf(tokenId);</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>        _beforeTokenTransfer(owner, address(0), tokenId, 1);</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>        // Update ownership in case tokenId was transferred by `_beforeTokenTransfer` hook</span>
 305 |     | <span class='neutral'>        owner = ERC721.ownerOf(tokenId);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='neutral'>        // Clear approvals</span>
 308 |     | <span class='neutral'>        delete _tokenApprovals[tokenId];</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>        unchecked {</span>
 311 |     | <span class='neutral'>            // Cannot overflow, as that would require more tokens to be burned/transferred</span>
 312 |     | <span class='neutral'>            // out than the owner initially received through minting and transferring in.</span>
 313 |     | <span class='neutral'>            _balances[owner] -= 1;</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'>        delete _owners[tokenId];</span>
 316 |     | <span class='neutral'></span>
 317 |     | <span class='neutral'>        emit Transfer(owner, address(0), tokenId);</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>        _afterTokenTransfer(owner, address(0), tokenId, 1);</span>
 320 |     | <span class='neutral'>    }</span>
 321 |     | <span class='neutral'></span>
 322 |     | <span class='neutral'>    /**</span>
 323 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
 324 |     | <span class='neutral'>     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.</span>
 325 |     | <span class='neutral'>     *</span>
 326 |     | <span class='neutral'>     * Requirements:</span>
 327 |     | <span class='neutral'>     *</span>
 328 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 329 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
 330 |     | <span class='neutral'>     *</span>
 331 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 tokenId) internal virtual {</span>
 334 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 335 |     | <span class='unexecuted'>        require(to != address(0), &quot;ERC721: transfer to the zero address&quot;);</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='neutral'>        _beforeTokenTransfer(from, to, tokenId, 1);</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>        // Check that tokenId was not transferred by `_beforeTokenTransfer` hook</span>
 340 |     | <span class='unexecuted'>        require(ERC721.ownerOf(tokenId) == from, &quot;ERC721: transfer from incorrect owner&quot;);</span>
 341 |     | <span class='neutral'></span>
 342 |     | <span class='neutral'>        // Clear approvals from the previous owner</span>
 343 |     | <span class='unexecuted'>        delete _tokenApprovals[tokenId];</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        unchecked {</span>
 346 |     | <span class='neutral'>            // `_balances[from]` cannot overflow for the same reason as described in `_burn`:</span>
 347 |     | <span class='neutral'>            // `from`&#39;s balance is the number of token held, which is at least one before the current</span>
 348 |     | <span class='neutral'>            // transfer.</span>
 349 |     | <span class='neutral'>            // `_balances[to]` could overflow in the conditions described in `_mint`. That would require</span>
 350 |     | <span class='neutral'>            // all 2**256 token ids to be minted, which in practice is impossible.</span>
 351 |     | <span class='unexecuted'>            _balances[from] -= 1;</span>
 352 |     | <span class='unexecuted'>            _balances[to] += 1;</span>
 353 |     | <span class='neutral'>        }</span>
 354 |     | <span class='unexecuted'>        _owners[tokenId] = to;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='unexecuted'>        emit Transfer(from, to, tokenId);</span>
 357 |     | <span class='neutral'></span>
 358 |     | <span class='neutral'>        _afterTokenTransfer(from, to, tokenId, 1);</span>
 359 |     | <span class='neutral'>    }</span>
 360 |     | <span class='neutral'></span>
 361 |     | <span class='neutral'>    /**</span>
 362 |     | <span class='neutral'>     * @dev Approve `to` to operate on `tokenId`</span>
 363 |     | <span class='neutral'>     *</span>
 364 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 365 |     | <span class='neutral'>     */</span>
 366 |     | <span class='unexecuted'>    function _approve(address to, uint256 tokenId) internal virtual {</span>
 367 |     | <span class='unexecuted'>        _tokenApprovals[tokenId] = to;</span>
 368 |     | <span class='unexecuted'>        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);</span>
 369 |     | <span class='neutral'>    }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>    /**</span>
 372 |     | <span class='neutral'>     * @dev Approve `operator` to operate on all of `owner` tokens</span>
 373 |     | <span class='neutral'>     *</span>
 374 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 375 |     | <span class='neutral'>     */</span>
 376 |     | <span class='unexecuted'>    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {</span>
 377 |     | <span class='unexecuted'>        require(owner != operator, &quot;ERC721: approve to caller&quot;);</span>
 378 |     | <span class='unexecuted'>        _operatorApprovals[owner][operator] = approved;</span>
 379 |     | <span class='unexecuted'>        emit ApprovalForAll(owner, operator, approved);</span>
 380 |     | <span class='neutral'>    }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>    /**</span>
 383 |     | <span class='neutral'>     * @dev Reverts if the `tokenId` has not been minted yet.</span>
 384 |     | <span class='neutral'>     */</span>
 385 |     | <span class='unexecuted'>    function _requireMinted(uint256 tokenId) internal view virtual {</span>
 386 |     | <span class='unexecuted'>        require(_exists(tokenId), &quot;ERC721: invalid token ID&quot;);</span>
 387 |     | <span class='neutral'>    }</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>    /**</span>
 390 |     | <span class='neutral'>     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.</span>
 391 |     | <span class='neutral'>     * The call is not executed if the target address is not a contract.</span>
 392 |     | <span class='neutral'>     *</span>
 393 |     | <span class='neutral'>     * @param from address representing the previous owner of the given token ID</span>
 394 |     | <span class='neutral'>     * @param to target address that will receive the tokens</span>
 395 |     | <span class='neutral'>     * @param tokenId uint256 ID of the token to be transferred</span>
 396 |     | <span class='neutral'>     * @param data bytes optional data to send along with the call</span>
 397 |     | <span class='neutral'>     * @return bool whether the call correctly returned the expected magic value</span>
 398 |     | <span class='neutral'>     */</span>
 399 |     | <span class='unexecuted'>    function _checkOnERC721Received(</span>
 400 |     | <span class='neutral'>        address from,</span>
 401 |     | <span class='neutral'>        address to,</span>
 402 |     | <span class='neutral'>        uint256 tokenId,</span>
 403 |     | <span class='neutral'>        bytes memory data</span>
 404 |     | <span class='unexecuted'>    ) private returns (bool) {</span>
 405 |     | <span class='unexecuted'>        if (to.isContract()) {</span>
 406 |     | <span class='unexecuted'>            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {</span>
 407 |     | <span class='unexecuted'>                return retval == IERC721Receiver.onERC721Received.selector;</span>
 408 |     | <span class='neutral'>            } catch (bytes memory reason) {</span>
 409 |     | <span class='unexecuted'>                if (reason.length == 0) {</span>
 410 |     | <span class='unexecuted'>                    revert(&quot;ERC721: transfer to non ERC721Receiver implementer&quot;);</span>
 411 |     | <span class='neutral'>                } else {</span>
 412 |     | <span class='neutral'>                    /// @solidity memory-safe-assembly</span>
 413 |     | <span class='neutral'>                    assembly {</span>
 414 |     | <span class='unexecuted'>                        revert(add(32, reason), mload(reason))</span>
 415 |     | <span class='neutral'>                    }</span>
 416 |     | <span class='neutral'>                }</span>
 417 |     | <span class='neutral'>            }</span>
 418 |     | <span class='neutral'>        } else {</span>
 419 |     | <span class='unexecuted'>            return true;</span>
 420 |     | <span class='neutral'>        }</span>
 421 |     | <span class='neutral'>    }</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='neutral'>    /**</span>
 424 |     | <span class='neutral'>     * @dev Hook that is called before any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 425 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 426 |     | <span class='neutral'>     *</span>
 427 |     | <span class='neutral'>     * Calling conditions:</span>
 428 |     | <span class='neutral'>     *</span>
 429 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens will be transferred to `to`.</span>
 430 |     | <span class='neutral'>     * - When `from` is zero, the tokens will be minted for `to`.</span>
 431 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens will be burned.</span>
 432 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 433 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 434 |     | <span class='neutral'>     *</span>
 435 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 436 |     | <span class='neutral'>     */</span>
 437 |     | <span class='neutral'>    function _beforeTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    /**</span>
 440 |     | <span class='neutral'>     * @dev Hook that is called after any token transfer. This includes minting and burning. If {ERC721Consecutive} is</span>
 441 |     | <span class='neutral'>     * used, the hook may be called as part of a consecutive (batch) mint, as indicated by `batchSize` greater than 1.</span>
 442 |     | <span class='neutral'>     *</span>
 443 |     | <span class='neutral'>     * Calling conditions:</span>
 444 |     | <span class='neutral'>     *</span>
 445 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, ``from``&#39;s tokens were transferred to `to`.</span>
 446 |     | <span class='neutral'>     * - When `from` is zero, the tokens were minted for `to`.</span>
 447 |     | <span class='neutral'>     * - When `to` is zero, ``from``&#39;s tokens were burned.</span>
 448 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 449 |     | <span class='neutral'>     * - `batchSize` is non-zero.</span>
 450 |     | <span class='neutral'>     *</span>
 451 |     | <span class='neutral'>     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].</span>
 452 |     | <span class='neutral'>     */</span>
 453 |     | <span class='neutral'>    function _afterTokenTransfer(address from, address to, uint256 firstTokenId, uint256 batchSize) internal virtual {}</span>
 454 |     | <span class='neutral'></span>
 455 |     | <span class='neutral'>    /**</span>
 456 |     | <span class='neutral'>     * @dev Unsafe write access to the balances, used by extensions that &quot;mint&quot; tokens using an {ownerOf} override.</span>
 457 |     | <span class='neutral'>     *</span>
 458 |     | <span class='neutral'>     * WARNING: Anyone calling this MUST ensure that the balances remain consistent with the ownership. The invariant</span>
 459 |     | <span class='neutral'>     * being that for any address `a` the value returned by `balanceOf(a)` must be equal to the number of tokens such</span>
 460 |     | <span class='neutral'>     * that `ownerOf(tokenId)` is `a`.</span>
 461 |     | <span class='neutral'>     */</span>
 462 |     | <span class='neutral'>    // solhint-disable-next-line func-name-mixedcase</span>
 463 |     | <span class='neutral'>    function __unsafe_increaseBalance(address account, uint256 amount) internal {</span>
 464 |     | <span class='neutral'>        _balances[account] += amount;</span>
 465 |     | <span class='neutral'>    }</span>
 466 |     | <span class='neutral'>}</span>
 467 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../../utils/introspection/IERC165.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Required interface of an ERC721 compliant contract.</span>
  10 |     | <span class='neutral'> */</span>
  11 |     | <span class='neutral'>interface IERC721 is IERC165 {</span>
  12 |     | <span class='neutral'>    /**</span>
  13 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
  14 |     | <span class='neutral'>     */</span>
  15 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /**</span>
  18 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
  19 |     | <span class='neutral'>     */</span>
  20 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>    /**</span>
  23 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.</span>
  24 |     | <span class='neutral'>     */</span>
  25 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    /**</span>
  28 |     | <span class='neutral'>     * @dev Returns the number of tokens in ``owner``&#39;s account.</span>
  29 |     | <span class='neutral'>     */</span>
  30 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /**</span>
  33 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Requirements:</span>
  36 |     | <span class='neutral'>     *</span>
  37 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  43 |     | <span class='neutral'>     *</span>
  44 |     | <span class='neutral'>     * Requirements:</span>
  45 |     | <span class='neutral'>     *</span>
  46 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  47 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  48 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  49 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  50 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  53 |     | <span class='neutral'>     */</span>
  54 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /**</span>
  57 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients</span>
  58 |     | <span class='neutral'>     * are aware of the ERC721 protocol to prevent tokens from being forever locked.</span>
  59 |     | <span class='neutral'>     *</span>
  60 |     | <span class='neutral'>     * Requirements:</span>
  61 |     | <span class='neutral'>     *</span>
  62 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  63 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  64 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  65 |     | <span class='neutral'>     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.</span>
  66 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  67 |     | <span class='neutral'>     *</span>
  68 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    function safeTransferFrom(address from, address to, uint256 tokenId) external;</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * @dev Transfers `tokenId` token from `from` to `to`.</span>
  74 |     | <span class='neutral'>     *</span>
  75 |     | <span class='neutral'>     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721</span>
  76 |     | <span class='neutral'>     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must</span>
  77 |     | <span class='neutral'>     * understand this adds an external call which potentially creates a reentrancy vulnerability.</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Requirements:</span>
  80 |     | <span class='neutral'>     *</span>
  81 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  82 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  83 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  84 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.</span>
  85 |     | <span class='neutral'>     *</span>
  86 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 tokenId) external;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /**</span>
  91 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
  92 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
  93 |     | <span class='neutral'>     *</span>
  94 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.</span>
  95 |     | <span class='neutral'>     *</span>
  96 |     | <span class='neutral'>     * Requirements:</span>
  97 |     | <span class='neutral'>     *</span>
  98 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
  99 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 100 |     | <span class='neutral'>     *</span>
 101 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 102 |     | <span class='neutral'>     */</span>
 103 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external;</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    /**</span>
 106 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 107 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.</span>
 108 |     | <span class='neutral'>     *</span>
 109 |     | <span class='neutral'>     * Requirements:</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool approved) external;</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    /**</span>
 118 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 119 |     | <span class='neutral'>     *</span>
 120 |     | <span class='neutral'>     * Requirements:</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /**</span>
 127 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 128 |     | <span class='neutral'>     *</span>
 129 |     | <span class='neutral'>     * See {setApprovalForAll}</span>
 130 |     | <span class='neutral'>     */</span>
 131 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 132 |     | <span class='neutral'>}</span>
 133 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title ERC721 token receiver interface</span>
  8 |     | <span class='neutral'> * @dev Interface for any contract that wants to support safeTransfers</span>
  9 |     | <span class='neutral'> * from ERC721 asset contracts.</span>
 10 |     | <span class='neutral'> */</span>
 11 |     | <span class='neutral'>interface IERC721Receiver {</span>
 12 |     | <span class='neutral'>    /**</span>
 13 |     | <span class='neutral'>     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}</span>
 14 |     | <span class='neutral'>     * by `operator` from `from`, this function is called.</span>
 15 |     | <span class='neutral'>     *</span>
 16 |     | <span class='neutral'>     * It must return its Solidity selector to confirm the token transfer.</span>
 17 |     | <span class='neutral'>     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.</span>
 18 |     | <span class='neutral'>     *</span>
 19 |     | <span class='neutral'>     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function onERC721Received(</span>
 22 |     | <span class='neutral'>        address operator,</span>
 23 |     | <span class='neutral'>        address from,</span>
 24 |     | <span class='neutral'>        uint256 tokenId,</span>
 25 |     | <span class='neutral'>        bytes calldata data</span>
 26 |     | <span class='neutral'>    ) external returns (bytes4);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../IERC721.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @title ERC-721 Non-Fungible Token Standard, optional metadata extension</span>
 10 |     | <span class='neutral'> * @dev See https://eips.ethereum.org/EIPS/eip-721</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='neutral'>interface IERC721Metadata is IERC721 {</span>
 13 |     | <span class='neutral'>    /**</span>
 14 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
 15 |     | <span class='neutral'>     */</span>
 16 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /**</span>
 19 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
 20 |     | <span class='neutral'>     */</span>
 21 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) external view returns (string memory);</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Address.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.1;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Collection of functions related to the address type</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Address {</span>
  10 |     | <span class='neutral'>    /**</span>
  11 |     | <span class='neutral'>     * @dev Returns true if `account` is a contract.</span>
  12 |     | <span class='neutral'>     *</span>
  13 |     | <span class='neutral'>     * [IMPORTANT]</span>
  14 |     | <span class='neutral'>     * ====</span>
  15 |     | <span class='neutral'>     * It is unsafe to assume that an address for which this function returns</span>
  16 |     | <span class='neutral'>     * false is an externally-owned account (EOA) and not a contract.</span>
  17 |     | <span class='neutral'>     *</span>
  18 |     | <span class='neutral'>     * Among others, `isContract` will return false for the following</span>
  19 |     | <span class='neutral'>     * types of addresses:</span>
  20 |     | <span class='neutral'>     *</span>
  21 |     | <span class='neutral'>     *  - an externally-owned account</span>
  22 |     | <span class='neutral'>     *  - a contract in construction</span>
  23 |     | <span class='neutral'>     *  - an address where a contract will be created</span>
  24 |     | <span class='neutral'>     *  - an address where a contract lived, but was destroyed</span>
  25 |     | <span class='neutral'>     *</span>
  26 |     | <span class='neutral'>     * Furthermore, `isContract` will also return true if the target contract within</span>
  27 |     | <span class='neutral'>     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,</span>
  28 |     | <span class='neutral'>     * which only has an effect at the end of a transaction.</span>
  29 |     | <span class='neutral'>     * ====</span>
  30 |     | <span class='neutral'>     *</span>
  31 |     | <span class='neutral'>     * [IMPORTANT]</span>
  32 |     | <span class='neutral'>     * ====</span>
  33 |     | <span class='neutral'>     * You shouldn&#39;t rely on `isContract` to protect against flash loan attacks!</span>
  34 |     | <span class='neutral'>     *</span>
  35 |     | <span class='neutral'>     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets</span>
  36 |     | <span class='neutral'>     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract</span>
  37 |     | <span class='neutral'>     * constructor.</span>
  38 |     | <span class='neutral'>     * ====</span>
  39 |     | <span class='neutral'>     */</span>
  40 |     | <span class='neutral'>    function isContract(address account) internal view returns (bool) {</span>
  41 |     | <span class='neutral'>        // This method relies on extcodesize/address.code.length, which returns 0</span>
  42 |     | <span class='neutral'>        // for contracts in construction, since the code is only stored at the end</span>
  43 |     | <span class='neutral'>        // of the constructor execution.</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>        return account.code.length &gt; 0;</span>
  46 |     | <span class='neutral'>    }</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>    /**</span>
  49 |     | <span class='neutral'>     * @dev Replacement for Solidity&#39;s `transfer`: sends `amount` wei to</span>
  50 |     | <span class='neutral'>     * `recipient`, forwarding all available gas and reverting on errors.</span>
  51 |     | <span class='neutral'>     *</span>
  52 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost</span>
  53 |     | <span class='neutral'>     * of certain opcodes, possibly making contracts go over the 2300 gas limit</span>
  54 |     | <span class='neutral'>     * imposed by `transfer`, making them unable to receive funds via</span>
  55 |     | <span class='neutral'>     * `transfer`. {sendValue} removes this limitation.</span>
  56 |     | <span class='neutral'>     *</span>
  57 |     | <span class='neutral'>     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].</span>
  58 |     | <span class='neutral'>     *</span>
  59 |     | <span class='neutral'>     * IMPORTANT: because control is transferred to `recipient`, care must be</span>
  60 |     | <span class='neutral'>     * taken to not create reentrancy vulnerabilities. Consider using</span>
  61 |     | <span class='neutral'>     * {ReentrancyGuard} or the</span>
  62 |     | <span class='neutral'>     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].</span>
  63 |     | <span class='neutral'>     */</span>
  64 |     | <span class='neutral'>    function sendValue(address payable recipient, uint256 amount) internal {</span>
  65 |     | <span class='neutral'>        require(address(this).balance &gt;= amount, &quot;Address: insufficient balance&quot;);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>        (bool success, ) = recipient.call{value: amount}(&quot;&quot;);</span>
  68 |     | <span class='neutral'>        require(success, &quot;Address: unable to send value, recipient may have reverted&quot;);</span>
  69 |     | <span class='neutral'>    }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>    /**</span>
  72 |     | <span class='neutral'>     * @dev Performs a Solidity function call using a low level `call`. A</span>
  73 |     | <span class='neutral'>     * plain `call` is an unsafe replacement for a function call: use this</span>
  74 |     | <span class='neutral'>     * function instead.</span>
  75 |     | <span class='neutral'>     *</span>
  76 |     | <span class='neutral'>     * If `target` reverts with a revert reason, it is bubbled up by this</span>
  77 |     | <span class='neutral'>     * function (like regular Solidity function calls).</span>
  78 |     | <span class='neutral'>     *</span>
  79 |     | <span class='neutral'>     * Returns the raw returned data. To convert to the expected return value,</span>
  80 |     | <span class='neutral'>     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * Requirements:</span>
  83 |     | <span class='neutral'>     *</span>
  84 |     | <span class='neutral'>     * - `target` must be a contract.</span>
  85 |     | <span class='neutral'>     * - calling `target` with `data` must not revert.</span>
  86 |     | <span class='neutral'>     *</span>
  87 |     | <span class='neutral'>     * _Available since v3.1._</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='neutral'>    function functionCall(address target, bytes memory data) internal returns (bytes memory) {</span>
  90 |     | <span class='neutral'>        return functionCallWithValue(target, data, 0, &quot;Address: low-level call failed&quot;);</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with</span>
  95 |     | <span class='neutral'>     * `errorMessage` as a fallback revert reason when `target` reverts.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * _Available since v3.1._</span>
  98 |     | <span class='neutral'>     */</span>
  99 | *   | <span class='executed'>    function functionCall(</span>
 100 |     | <span class='neutral'>        address target,</span>
 101 |     | <span class='neutral'>        bytes memory data,</span>
 102 |     | <span class='neutral'>        string memory errorMessage</span>
 103 | *   | <span class='executed'>    ) internal returns (bytes memory) {</span>
 104 | *   | <span class='executed'>        return functionCallWithValue(target, data, 0, errorMessage);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 109 |     | <span class='neutral'>     * but also transferring `value` wei to `target`.</span>
 110 |     | <span class='neutral'>     *</span>
 111 |     | <span class='neutral'>     * Requirements:</span>
 112 |     | <span class='neutral'>     *</span>
 113 |     | <span class='neutral'>     * - the calling contract must have an ETH balance of at least `value`.</span>
 114 |     | <span class='neutral'>     * - the called Solidity function must be `payable`.</span>
 115 |     | <span class='neutral'>     *</span>
 116 |     | <span class='neutral'>     * _Available since v3.1._</span>
 117 |     | <span class='neutral'>     */</span>
 118 |     | <span class='neutral'>    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {</span>
 119 |     | <span class='neutral'>        return functionCallWithValue(target, data, value, &quot;Address: low-level call with value failed&quot;);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /**</span>
 123 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but</span>
 124 |     | <span class='neutral'>     * with `errorMessage` as a fallback revert reason when `target` reverts.</span>
 125 |     | <span class='neutral'>     *</span>
 126 |     | <span class='neutral'>     * _Available since v3.1._</span>
 127 |     | <span class='neutral'>     */</span>
 128 | *   | <span class='executed'>    function functionCallWithValue(</span>
 129 |     | <span class='neutral'>        address target,</span>
 130 |     | <span class='neutral'>        bytes memory data,</span>
 131 |     | <span class='neutral'>        uint256 value,</span>
 132 |     | <span class='neutral'>        string memory errorMessage</span>
 133 |     | <span class='unexecuted'>    ) internal returns (bytes memory) {</span>
 134 |     | <span class='unexecuted'>        require(address(this).balance &gt;= value, &quot;Address: insufficient balance for call&quot;);</span>
 135 | *   | <span class='executed'>        (bool success, bytes memory returndata) = target.call{value: value}(data);</span>
 136 | *   | <span class='executed'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='neutral'>    /**</span>
 140 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 141 |     | <span class='neutral'>     * but performing a static call.</span>
 142 |     | <span class='neutral'>     *</span>
 143 |     | <span class='neutral'>     * _Available since v3.3._</span>
 144 |     | <span class='neutral'>     */</span>
 145 |     | <span class='neutral'>    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {</span>
 146 |     | <span class='neutral'>        return functionStaticCall(target, data, &quot;Address: low-level static call failed&quot;);</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /**</span>
 150 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 151 |     | <span class='neutral'>     * but performing a static call.</span>
 152 |     | <span class='neutral'>     *</span>
 153 |     | <span class='neutral'>     * _Available since v3.3._</span>
 154 |     | <span class='neutral'>     */</span>
 155 |     | <span class='neutral'>    function functionStaticCall(</span>
 156 |     | <span class='neutral'>        address target,</span>
 157 |     | <span class='neutral'>        bytes memory data,</span>
 158 |     | <span class='neutral'>        string memory errorMessage</span>
 159 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
 160 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.staticcall(data);</span>
 161 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    /**</span>
 165 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],</span>
 166 |     | <span class='neutral'>     * but performing a delegate call.</span>
 167 |     | <span class='neutral'>     *</span>
 168 |     | <span class='neutral'>     * _Available since v3.4._</span>
 169 |     | <span class='neutral'>     */</span>
 170 |     | <span class='neutral'>    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {</span>
 171 |     | <span class='neutral'>        return functionDelegateCall(target, data, &quot;Address: low-level delegate call failed&quot;);</span>
 172 |     | <span class='neutral'>    }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    /**</span>
 175 |     | <span class='neutral'>     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],</span>
 176 |     | <span class='neutral'>     * but performing a delegate call.</span>
 177 |     | <span class='neutral'>     *</span>
 178 |     | <span class='neutral'>     * _Available since v3.4._</span>
 179 |     | <span class='neutral'>     */</span>
 180 |     | <span class='neutral'>    function functionDelegateCall(</span>
 181 |     | <span class='neutral'>        address target,</span>
 182 |     | <span class='neutral'>        bytes memory data,</span>
 183 |     | <span class='neutral'>        string memory errorMessage</span>
 184 |     | <span class='neutral'>    ) internal returns (bytes memory) {</span>
 185 |     | <span class='neutral'>        (bool success, bytes memory returndata) = target.delegatecall(data);</span>
 186 |     | <span class='neutral'>        return verifyCallResultFromTarget(target, success, returndata, errorMessage);</span>
 187 |     | <span class='neutral'>    }</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    /**</span>
 190 |     | <span class='neutral'>     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling</span>
 191 |     | <span class='neutral'>     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.</span>
 192 |     | <span class='neutral'>     *</span>
 193 |     | <span class='neutral'>     * _Available since v4.8._</span>
 194 |     | <span class='neutral'>     */</span>
 195 | *   | <span class='executed'>    function verifyCallResultFromTarget(</span>
 196 |     | <span class='neutral'>        address target,</span>
 197 |     | <span class='neutral'>        bool success,</span>
 198 |     | <span class='neutral'>        bytes memory returndata,</span>
 199 |     | <span class='neutral'>        string memory errorMessage</span>
 200 | *   | <span class='executed'>    ) internal view returns (bytes memory) {</span>
 201 | *   | <span class='executed'>        if (success) {</span>
 202 | *   | <span class='executed'>            if (returndata.length == 0) {</span>
 203 |     | <span class='neutral'>                // only check isContract if the call was successful and the return data is empty</span>
 204 |     | <span class='neutral'>                // otherwise we already know that it was a contract</span>
 205 | *   | <span class='executed'>                require(isContract(target), &quot;Address: call to non-contract&quot;);</span>
 206 |     | <span class='neutral'>            }</span>
 207 | *   | <span class='executed'>            return returndata;</span>
 208 |     | <span class='neutral'>        } else {</span>
 209 |     | <span class='unexecuted'>            _revert(returndata, errorMessage);</span>
 210 |     | <span class='neutral'>        }</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    /**</span>
 214 |     | <span class='neutral'>     * @dev Tool to verify that a low level call was successful, and revert if it wasn&#39;t, either by bubbling the</span>
 215 |     | <span class='neutral'>     * revert reason or using the provided one.</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * _Available since v4.3._</span>
 218 |     | <span class='neutral'>     */</span>
 219 |     | <span class='neutral'>    function verifyCallResult(</span>
 220 |     | <span class='neutral'>        bool success,</span>
 221 |     | <span class='neutral'>        bytes memory returndata,</span>
 222 |     | <span class='neutral'>        string memory errorMessage</span>
 223 |     | <span class='neutral'>    ) internal pure returns (bytes memory) {</span>
 224 |     | <span class='neutral'>        if (success) {</span>
 225 |     | <span class='neutral'>            return returndata;</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            _revert(returndata, errorMessage);</span>
 228 |     | <span class='neutral'>        }</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    function _revert(bytes memory returndata, string memory errorMessage) private pure {</span>
 232 |     | <span class='neutral'>        // Look for revert reason and bubble it up if present</span>
 233 |     | <span class='unexecuted'>        if (returndata.length &gt; 0) {</span>
 234 |     | <span class='neutral'>            // The easiest way to bubble the revert reason is using memory via assembly</span>
 235 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 236 |     | <span class='neutral'>            assembly {</span>
 237 |     | <span class='unexecuted'>                let returndata_size := mload(returndata)</span>
 238 |     | <span class='unexecuted'>                revert(add(32, returndata), returndata_size)</span>
 239 |     | <span class='neutral'>            }</span>
 240 |     | <span class='neutral'>        } else {</span>
 241 |     | <span class='unexecuted'>            revert(errorMessage);</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='neutral'>    }</span>
 244 |     | <span class='neutral'>}</span>
 245 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Context.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.4) (utils/Context.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Provides information about the current execution context, including the</span>
  8 |     | <span class='neutral'> * sender of the transaction and its data. While these are generally available</span>
  9 |     | <span class='neutral'> * via msg.sender and msg.data, they should not be accessed in such a direct</span>
 10 |     | <span class='neutral'> * manner, since when dealing with meta-transactions the account sending and</span>
 11 |     | <span class='neutral'> * paying for execution may not be the actual sender (as far as an application</span>
 12 |     | <span class='neutral'> * is concerned).</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * This contract is only required for intermediate, library-like contracts.</span>
 15 |     | <span class='neutral'> */</span>
 16 |     | <span class='neutral'>abstract contract Context {</span>
 17 |     | <span class='unexecuted'>    function _msgSender() internal view virtual returns (address) {</span>
 18 | *   | <span class='executed'>        return msg.sender;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function _msgData() internal view virtual returns (bytes calldata) {</span>
 22 |     | <span class='neutral'>        return msg.data;</span>
 23 |     | <span class='neutral'>    }</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function _contextSuffixLength() internal view virtual returns (uint256) {</span>
 26 |     | <span class='neutral'>        return 0;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Counters.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @title Counters</span>
  8 |     | <span class='neutral'> * @author Matt Condon (@shrugs)</span>
  9 |     | <span class='neutral'> * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number</span>
 10 |     | <span class='neutral'> * of elements in a mapping, issuing ERC721 ids, or counting request ids.</span>
 11 |     | <span class='neutral'> *</span>
 12 |     | <span class='neutral'> * Include with `using Counters for Counters.Counter;`</span>
 13 |     | <span class='neutral'> */</span>
 14 |     | <span class='unexecuted'>library Counters {</span>
 15 |     | <span class='neutral'>    struct Counter {</span>
 16 |     | <span class='neutral'>        // This variable should never be directly accessed by users of the library: interactions must be restricted to</span>
 17 |     | <span class='neutral'>        // the library&#39;s function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add</span>
 18 |     | <span class='neutral'>        // this feature: see https://github.com/ethereum/solidity/issues/4637</span>
 19 |     | <span class='neutral'>        uint256 _value; // default: 0</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='unexecuted'>    function current(Counter storage counter) internal view returns (uint256) {</span>
 23 |     | <span class='unexecuted'>        return counter._value;</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function increment(Counter storage counter) internal {</span>
 27 |     | <span class='neutral'>        unchecked {</span>
 28 |     | <span class='unexecuted'>            counter._value += 1;</span>
 29 |     | <span class='neutral'>        }</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function decrement(Counter storage counter) internal {</span>
 33 |     | <span class='neutral'>        uint256 value = counter._value;</span>
 34 |     | <span class='neutral'>        require(value &gt; 0, &quot;Counter: decrement overflow&quot;);</span>
 35 |     | <span class='neutral'>        unchecked {</span>
 36 |     | <span class='neutral'>            counter._value = value - 1;</span>
 37 |     | <span class='neutral'>        }</span>
 38 |     | <span class='neutral'>    }</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='neutral'>    function reset(Counter storage counter) internal {</span>
 41 |     | <span class='neutral'>        counter._value = 0;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/ShortStrings.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.8;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./StorageSlot.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |</span>
   9 |     | <span class='neutral'>// | length  | 0x                                                              BB |</span>
  10 |     | <span class='neutral'>type ShortString is bytes32;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>/**</span>
  13 |     | <span class='neutral'> * @dev This library provides functions to convert short memory strings</span>
  14 |     | <span class='neutral'> * into a `ShortString` type that can be used as an immutable variable.</span>
  15 |     | <span class='neutral'> *</span>
  16 |     | <span class='neutral'> * Strings of arbitrary length can be optimized using this library if</span>
  17 |     | <span class='neutral'> * they are short enough (up to 31 bytes) by packing them with their</span>
  18 |     | <span class='neutral'> * length (1 byte) in a single EVM word (32 bytes). Additionally, a</span>
  19 |     | <span class='neutral'> * fallback mechanism can be used for every other case.</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * Usage example:</span>
  22 |     | <span class='neutral'> *</span>
  23 |     | <span class='neutral'> * ```solidity</span>
  24 |     | <span class='neutral'> * contract Named {</span>
  25 |     | <span class='neutral'> *     using ShortStrings for *;</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> *     ShortString private immutable _name;</span>
  28 |     | <span class='neutral'> *     string private _nameFallback;</span>
  29 |     | <span class='neutral'> *</span>
  30 |     | <span class='neutral'> *     constructor(string memory contractName) {</span>
  31 |     | <span class='neutral'> *         _name = contractName.toShortStringWithFallback(_nameFallback);</span>
  32 |     | <span class='neutral'> *     }</span>
  33 |     | <span class='neutral'> *</span>
  34 |     | <span class='neutral'> *     function name() external view returns (string memory) {</span>
  35 |     | <span class='neutral'> *         return _name.toStringWithFallback(_nameFallback);</span>
  36 |     | <span class='neutral'> *     }</span>
  37 |     | <span class='neutral'> * }</span>
  38 |     | <span class='neutral'> * ```</span>
  39 |     | <span class='neutral'> */</span>
  40 |     | <span class='unexecuted'>library ShortStrings {</span>
  41 |     | <span class='neutral'>    // Used as an identifier for strings longer than 31 bytes.</span>
  42 |     | <span class='unexecuted'>    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='neutral'>    error StringTooLong(string str);</span>
  45 |     | <span class='neutral'>    error InvalidShortString();</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /**</span>
  48 |     | <span class='neutral'>     * @dev Encode a string of at most 31 chars into a `ShortString`.</span>
  49 |     | <span class='neutral'>     *</span>
  50 |     | <span class='neutral'>     * This will trigger a `StringTooLong` error is the input string is too long.</span>
  51 |     | <span class='neutral'>     */</span>
  52 |     | <span class='unexecuted'>    function toShortString(string memory str) internal pure returns (ShortString) {</span>
  53 |     | <span class='unexecuted'>        bytes memory bstr = bytes(str);</span>
  54 |     | <span class='unexecuted'>        if (bstr.length &gt; 31) {</span>
  55 |     | <span class='unexecuted'>            revert StringTooLong(str);</span>
  56 |     | <span class='neutral'>        }</span>
  57 |     | <span class='unexecuted'>        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /**</span>
  61 |     | <span class='neutral'>     * @dev Decode a `ShortString` back to a &quot;normal&quot; string.</span>
  62 |     | <span class='neutral'>     */</span>
  63 |     | <span class='unexecuted'>    function toString(ShortString sstr) internal pure returns (string memory) {</span>
  64 |     | <span class='unexecuted'>        uint256 len = byteLength(sstr);</span>
  65 |     | <span class='neutral'>        // using `new string(len)` would work locally but is not memory safe.</span>
  66 |     | <span class='unexecuted'>        string memory str = new string(32);</span>
  67 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  68 |     | <span class='neutral'>        assembly {</span>
  69 |     | <span class='unexecuted'>            mstore(str, len)</span>
  70 |     | <span class='unexecuted'>            mstore(add(str, 0x20), sstr)</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>        return str;</span>
  73 |     | <span class='neutral'>    }</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>    /**</span>
  76 |     | <span class='neutral'>     * @dev Return the length of a `ShortString`.</span>
  77 |     | <span class='neutral'>     */</span>
  78 |     | <span class='unexecuted'>    function byteLength(ShortString sstr) internal pure returns (uint256) {</span>
  79 |     | <span class='unexecuted'>        uint256 result = uint256(ShortString.unwrap(sstr)) &amp; 0xFF;</span>
  80 |     | <span class='unexecuted'>        if (result &gt; 31) {</span>
  81 |     | <span class='unexecuted'>            revert InvalidShortString();</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>        return result;</span>
  84 |     | <span class='neutral'>    }</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    /**</span>
  87 |     | <span class='neutral'>     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.</span>
  88 |     | <span class='neutral'>     */</span>
  89 |     | <span class='unexecuted'>    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {</span>
  90 |     | <span class='unexecuted'>        if (bytes(value).length &lt; 32) {</span>
  91 |     | <span class='unexecuted'>            return toShortString(value);</span>
  92 |     | <span class='neutral'>        } else {</span>
  93 |     | <span class='unexecuted'>            StorageSlot.getStringSlot(store).value = value;</span>
  94 |     | <span class='neutral'>            return ShortString.wrap(_FALLBACK_SENTINEL);</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /**</span>
  99 |     | <span class='neutral'>     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='unexecuted'>    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {</span>
 102 |     | <span class='unexecuted'>        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {</span>
 103 |     | <span class='unexecuted'>            return toString(value);</span>
 104 |     | <span class='neutral'>        } else {</span>
 105 |     | <span class='unexecuted'>            return store;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.</span>
 111 |     | <span class='neutral'>     *</span>
 112 |     | <span class='neutral'>     * WARNING: This will return the &quot;byte length&quot; of the string. This may not reflect the actual length in terms of</span>
 113 |     | <span class='neutral'>     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.</span>
 114 |     | <span class='neutral'>     */</span>
 115 |     | <span class='neutral'>    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {</span>
 116 |     | <span class='neutral'>        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {</span>
 117 |     | <span class='neutral'>            return byteLength(value);</span>
 118 |     | <span class='neutral'>        } else {</span>
 119 |     | <span class='neutral'>            return bytes(store).length;</span>
 120 |     | <span class='neutral'>        }</span>
 121 |     | <span class='neutral'>    }</span>
 122 |     | <span class='neutral'>}</span>
 123 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/StorageSlot.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)</span>
   3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Library for reading and writing primitive types to specific storage slots.</span>
   9 |     | <span class='neutral'> *</span>
  10 |     | <span class='neutral'> * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.</span>
  11 |     | <span class='neutral'> * This library helps with reading and writing to such slots without the need for inline assembly.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.</span>
  14 |     | <span class='neutral'> *</span>
  15 |     | <span class='neutral'> * Example usage to set ERC1967 implementation slot:</span>
  16 |     | <span class='neutral'> * ```solidity</span>
  17 |     | <span class='neutral'> * contract ERC1967 {</span>
  18 |     | <span class='neutral'> *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;</span>
  19 |     | <span class='neutral'> *</span>
  20 |     | <span class='neutral'> *     function _getImplementation() internal view returns (address) {</span>
  21 |     | <span class='neutral'> *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;</span>
  22 |     | <span class='neutral'> *     }</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> *     function _setImplementation(address newImplementation) internal {</span>
  25 |     | <span class='neutral'> *         require(Address.isContract(newImplementation), &quot;ERC1967: new implementation is not a contract&quot;);</span>
  26 |     | <span class='neutral'> *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;</span>
  27 |     | <span class='neutral'> *     }</span>
  28 |     | <span class='neutral'> * }</span>
  29 |     | <span class='neutral'> * ```</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._</span>
  32 |     | <span class='neutral'> * _Available since v4.9 for `string`, `bytes`._</span>
  33 |     | <span class='neutral'> */</span>
  34 |     | <span class='unexecuted'>library StorageSlot {</span>
  35 |     | <span class='neutral'>    struct AddressSlot {</span>
  36 |     | <span class='neutral'>        address value;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    struct BooleanSlot {</span>
  40 |     | <span class='neutral'>        bool value;</span>
  41 |     | <span class='neutral'>    }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    struct Bytes32Slot {</span>
  44 |     | <span class='neutral'>        bytes32 value;</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    struct Uint256Slot {</span>
  48 |     | <span class='neutral'>        uint256 value;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct StringSlot {</span>
  52 |     | <span class='neutral'>        string value;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    struct BytesSlot {</span>
  56 |     | <span class='neutral'>        bytes value;</span>
  57 |     | <span class='neutral'>    }</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    /**</span>
  60 |     | <span class='neutral'>     * @dev Returns an `AddressSlot` with member `value` located at `slot`.</span>
  61 |     | <span class='neutral'>     */</span>
  62 |     | <span class='neutral'>    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {</span>
  63 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  64 |     | <span class='neutral'>        assembly {</span>
  65 |     | <span class='neutral'>            r.slot := slot</span>
  66 |     | <span class='neutral'>        }</span>
  67 |     | <span class='neutral'>    }</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>    /**</span>
  70 |     | <span class='neutral'>     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.</span>
  71 |     | <span class='neutral'>     */</span>
  72 |     | <span class='neutral'>    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {</span>
  73 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  74 |     | <span class='neutral'>        assembly {</span>
  75 |     | <span class='neutral'>            r.slot := slot</span>
  76 |     | <span class='neutral'>        }</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    /**</span>
  80 |     | <span class='neutral'>     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.</span>
  81 |     | <span class='neutral'>     */</span>
  82 |     | <span class='neutral'>    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {</span>
  83 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='neutral'>            r.slot := slot</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /**</span>
  90 |     | <span class='neutral'>     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.</span>
  91 |     | <span class='neutral'>     */</span>
  92 |     | <span class='neutral'>    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {</span>
  93 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
  94 |     | <span class='neutral'>        assembly {</span>
  95 |     | <span class='neutral'>            r.slot := slot</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /**</span>
 100 |     | <span class='neutral'>     * @dev Returns an `StringSlot` with member `value` located at `slot`.</span>
 101 |     | <span class='neutral'>     */</span>
 102 |     | <span class='neutral'>    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {</span>
 103 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 104 |     | <span class='neutral'>        assembly {</span>
 105 |     | <span class='neutral'>            r.slot := slot</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /**</span>
 110 |     | <span class='neutral'>     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {</span>
 113 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 114 |     | <span class='neutral'>        assembly {</span>
 115 |     | <span class='neutral'>            r.slot := store.slot</span>
 116 |     | <span class='neutral'>        }</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    /**</span>
 120 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` with member `value` located at `slot`.</span>
 121 |     | <span class='neutral'>     */</span>
 122 |     | <span class='neutral'>    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {</span>
 123 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 124 |     | <span class='neutral'>        assembly {</span>
 125 |     | <span class='neutral'>            r.slot := slot</span>
 126 |     | <span class='neutral'>        }</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    /**</span>
 130 |     | <span class='neutral'>     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.</span>
 131 |     | <span class='neutral'>     */</span>
 132 |     | <span class='neutral'>    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {</span>
 133 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 134 |     | <span class='neutral'>        assembly {</span>
 135 |     | <span class='neutral'>            r.slot := store.slot</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'>    }</span>
 138 |     | <span class='neutral'>}</span>
 139 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/Strings.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./math/Math.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;./math/SignedMath.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/**</span>
 10 |     | <span class='neutral'> * @dev String operations.</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>library Strings {</span>
 13 |     | <span class='neutral'>    bytes16 private constant _SYMBOLS = &quot;0123456789abcdef&quot;;</span>
 14 |     | <span class='neutral'>    uint8 private constant _ADDRESS_LENGTH = 20;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` decimal representation.</span>
 18 |     | <span class='neutral'>     */</span>
 19 |     | <span class='unexecuted'>    function toString(uint256 value) internal pure returns (string memory) {</span>
 20 |     | <span class='neutral'>        unchecked {</span>
 21 |     | <span class='unexecuted'>            uint256 length = Math.log10(value) + 1;</span>
 22 |     | <span class='unexecuted'>            string memory buffer = new string(length);</span>
 23 |     | <span class='neutral'>            uint256 ptr;</span>
 24 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
 25 |     | <span class='neutral'>            assembly {</span>
 26 |     | <span class='unexecuted'>                ptr := add(buffer, add(32, length))</span>
 27 |     | <span class='neutral'>            }</span>
 28 |     | <span class='unexecuted'>            while (true) {</span>
 29 |     | <span class='unexecuted'>                ptr--;</span>
 30 |     | <span class='neutral'>                /// @solidity memory-safe-assembly</span>
 31 |     | <span class='neutral'>                assembly {</span>
 32 |     | <span class='unexecuted'>                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))</span>
 33 |     | <span class='neutral'>                }</span>
 34 |     | <span class='unexecuted'>                value /= 10;</span>
 35 |     | <span class='unexecuted'>                if (value == 0) break;</span>
 36 |     | <span class='neutral'>            }</span>
 37 |     | <span class='unexecuted'>            return buffer;</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /**</span>
 42 |     | <span class='neutral'>     * @dev Converts a `int256` to its ASCII `string` decimal representation.</span>
 43 |     | <span class='neutral'>     */</span>
 44 |     | <span class='neutral'>    function toString(int256 value) internal pure returns (string memory) {</span>
 45 |     | <span class='neutral'>        return string(abi.encodePacked(value &lt; 0 ? &quot;-&quot; : &quot;&quot;, toString(SignedMath.abs(value))));</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    /**</span>
 49 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.</span>
 50 |     | <span class='neutral'>     */</span>
 51 |     | <span class='neutral'>    function toHexString(uint256 value) internal pure returns (string memory) {</span>
 52 |     | <span class='neutral'>        unchecked {</span>
 53 |     | <span class='neutral'>            return toHexString(value, Math.log256(value) + 1);</span>
 54 |     | <span class='neutral'>        }</span>
 55 |     | <span class='neutral'>    }</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>    /**</span>
 58 |     | <span class='neutral'>     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.</span>
 59 |     | <span class='neutral'>     */</span>
 60 |     | <span class='neutral'>    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {</span>
 61 |     | <span class='neutral'>        bytes memory buffer = new bytes(2 * length + 2);</span>
 62 |     | <span class='neutral'>        buffer[0] = &quot;0&quot;;</span>
 63 |     | <span class='neutral'>        buffer[1] = &quot;x&quot;;</span>
 64 |     | <span class='neutral'>        for (uint256 i = 2 * length + 1; i &gt; 1; --i) {</span>
 65 |     | <span class='neutral'>            buffer[i] = _SYMBOLS[value &amp; 0xf];</span>
 66 |     | <span class='neutral'>            value &gt;&gt;= 4;</span>
 67 |     | <span class='neutral'>        }</span>
 68 |     | <span class='neutral'>        require(value == 0, &quot;Strings: hex length insufficient&quot;);</span>
 69 |     | <span class='neutral'>        return string(buffer);</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /**</span>
 73 |     | <span class='neutral'>     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.</span>
 74 |     | <span class='neutral'>     */</span>
 75 |     | <span class='neutral'>    function toHexString(address addr) internal pure returns (string memory) {</span>
 76 |     | <span class='neutral'>        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'></span>
 79 |     | <span class='neutral'>    /**</span>
 80 |     | <span class='neutral'>     * @dev Returns true if the two strings are equal.</span>
 81 |     | <span class='neutral'>     */</span>
 82 |     | <span class='neutral'>    function equal(string memory a, string memory b) internal pure returns (bool) {</span>
 83 |     | <span class='neutral'>        return keccak256(bytes(a)) == keccak256(bytes(b));</span>
 84 |     | <span class='neutral'>    }</span>
 85 |     | <span class='neutral'>}</span>
 86 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/ECDSA.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;../Strings.sol&quot;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>/**</span>
   9 |     | <span class='neutral'> * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.</span>
  10 |     | <span class='neutral'> *</span>
  11 |     | <span class='neutral'> * These functions can be used to verify that a message was signed by the holder</span>
  12 |     | <span class='neutral'> * of the private keys of a given address.</span>
  13 |     | <span class='neutral'> */</span>
  14 |     | <span class='unexecuted'>library ECDSA {</span>
  15 |     | <span class='neutral'>    enum RecoverError {</span>
  16 |     | <span class='neutral'>        NoError,</span>
  17 |     | <span class='neutral'>        InvalidSignature,</span>
  18 |     | <span class='neutral'>        InvalidSignatureLength,</span>
  19 |     | <span class='neutral'>        InvalidSignatureS,</span>
  20 |     | <span class='neutral'>        InvalidSignatureV // Deprecated in v4.8</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function _throwError(RecoverError error) private pure {</span>
  24 |     | <span class='unexecuted'>        if (error == RecoverError.NoError) {</span>
  25 |     | <span class='neutral'>            return; // no error: do nothing</span>
  26 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignature) {</span>
  27 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature&quot;);</span>
  28 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignatureLength) {</span>
  29 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature length&quot;);</span>
  30 |     | <span class='unexecuted'>        } else if (error == RecoverError.InvalidSignatureS) {</span>
  31 |     | <span class='unexecuted'>            revert(&quot;ECDSA: invalid signature &#39;s&#39; value&quot;);</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /**</span>
  36 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  37 |     | <span class='neutral'>     * `signature` or error string. This address can then be used for verification purposes.</span>
  38 |     | <span class='neutral'>     *</span>
  39 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  40 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  41 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  42 |     | <span class='neutral'>     *</span>
  43 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  44 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  45 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  46 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  47 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  48 |     | <span class='neutral'>     *</span>
  49 |     | <span class='neutral'>     * Documentation for signature generation:</span>
  50 |     | <span class='neutral'>     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]</span>
  51 |     | <span class='neutral'>     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]</span>
  52 |     | <span class='neutral'>     *</span>
  53 |     | <span class='neutral'>     * _Available since v4.3._</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {</span>
  56 |     | <span class='neutral'>        if (signature.length == 65) {</span>
  57 |     | <span class='neutral'>            bytes32 r;</span>
  58 |     | <span class='neutral'>            bytes32 s;</span>
  59 |     | <span class='neutral'>            uint8 v;</span>
  60 |     | <span class='neutral'>            // ecrecover takes the signature parameters, and the only way to get them</span>
  61 |     | <span class='neutral'>            // currently is to use assembly.</span>
  62 |     | <span class='neutral'>            /// @solidity memory-safe-assembly</span>
  63 |     | <span class='neutral'>            assembly {</span>
  64 |     | <span class='neutral'>                r := mload(add(signature, 0x20))</span>
  65 |     | <span class='neutral'>                s := mload(add(signature, 0x40))</span>
  66 |     | <span class='neutral'>                v := byte(0, mload(add(signature, 0x60)))</span>
  67 |     | <span class='neutral'>            }</span>
  68 |     | <span class='neutral'>            return tryRecover(hash, v, r, s);</span>
  69 |     | <span class='neutral'>        } else {</span>
  70 |     | <span class='neutral'>            return (address(0), RecoverError.InvalidSignatureLength);</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    /**</span>
  75 |     | <span class='neutral'>     * @dev Returns the address that signed a hashed message (`hash`) with</span>
  76 |     | <span class='neutral'>     * `signature`. This address can then be used for verification purposes.</span>
  77 |     | <span class='neutral'>     *</span>
  78 |     | <span class='neutral'>     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:</span>
  79 |     | <span class='neutral'>     * this function rejects them by requiring the `s` value to be in the lower</span>
  80 |     | <span class='neutral'>     * half order, and the `v` value to be either 27 or 28.</span>
  81 |     | <span class='neutral'>     *</span>
  82 |     | <span class='neutral'>     * IMPORTANT: `hash` _must_ be the result of a hash operation for the</span>
  83 |     | <span class='neutral'>     * verification to be secure: it is possible to craft signatures that</span>
  84 |     | <span class='neutral'>     * recover to arbitrary addresses for non-hashed data. A safe way to ensure</span>
  85 |     | <span class='neutral'>     * this is by receiving a hash of the original message (which may otherwise</span>
  86 |     | <span class='neutral'>     * be too long), and then calling {toEthSignedMessageHash} on it.</span>
  87 |     | <span class='neutral'>     */</span>
  88 |     | <span class='neutral'>    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {</span>
  89 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, signature);</span>
  90 |     | <span class='neutral'>        _throwError(error);</span>
  91 |     | <span class='neutral'>        return recovered;</span>
  92 |     | <span class='neutral'>    }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    /**</span>
  95 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * _Available since v4.3._</span>
 100 |     | <span class='neutral'>     */</span>
 101 |     | <span class='neutral'>    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {</span>
 102 |     | <span class='neutral'>        bytes32 s = vs &amp; bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);</span>
 103 |     | <span class='neutral'>        uint8 v = uint8((uint256(vs) &gt;&gt; 255) + 27);</span>
 104 |     | <span class='neutral'>        return tryRecover(hash, v, r, s);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /**</span>
 108 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.</span>
 109 |     | <span class='neutral'>     *</span>
 110 |     | <span class='neutral'>     * _Available since v4.2._</span>
 111 |     | <span class='neutral'>     */</span>
 112 |     | <span class='neutral'>    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {</span>
 113 |     | <span class='neutral'>        (address recovered, RecoverError error) = tryRecover(hash, r, vs);</span>
 114 |     | <span class='neutral'>        _throwError(error);</span>
 115 |     | <span class='neutral'>        return recovered;</span>
 116 |     | <span class='neutral'>    }</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    /**</span>
 119 |     | <span class='neutral'>     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,</span>
 120 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 121 |     | <span class='neutral'>     *</span>
 122 |     | <span class='neutral'>     * _Available since v4.3._</span>
 123 |     | <span class='neutral'>     */</span>
 124 |     | <span class='unexecuted'>    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {</span>
 125 |     | <span class='neutral'>        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature</span>
 126 |     | <span class='neutral'>        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines</span>
 127 |     | <span class='neutral'>        // the valid range for s in (301): 0 &lt; s &lt; secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most</span>
 128 |     | <span class='neutral'>        // signatures from current libraries generate a unique signature with an s-value in the lower half order.</span>
 129 |     | <span class='neutral'>        //</span>
 130 |     | <span class='neutral'>        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value</span>
 131 |     | <span class='neutral'>        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or</span>
 132 |     | <span class='neutral'>        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept</span>
 133 |     | <span class='neutral'>        // these malleable signatures as well.</span>
 134 |     | <span class='unexecuted'>        if (uint256(s) &gt; 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {</span>
 135 |     | <span class='unexecuted'>            return (address(0), RecoverError.InvalidSignatureS);</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // If the signature is valid (and not malleable), return the signer address</span>
 139 |     | <span class='unexecuted'>        address signer = ecrecover(hash, v, r, s);</span>
 140 |     | <span class='unexecuted'>        if (signer == address(0)) {</span>
 141 |     | <span class='unexecuted'>            return (address(0), RecoverError.InvalidSignature);</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        return (signer, RecoverError.NoError);</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Overload of {ECDSA-recover} that receives the `v`,</span>
 149 |     | <span class='neutral'>     * `r` and `s` signature fields separately.</span>
 150 |     | <span class='neutral'>     */</span>
 151 | *   | <span class='executed'>    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {</span>
 152 |     | <span class='unexecuted'>        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);</span>
 153 |     | <span class='unexecuted'>        _throwError(error);</span>
 154 |     | <span class='unexecuted'>        return recovered;</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /**</span>
 158 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from a `hash`. This</span>
 159 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 160 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 161 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 162 |     | <span class='neutral'>     *</span>
 163 |     | <span class='neutral'>     * See {recover}.</span>
 164 |     | <span class='neutral'>     */</span>
 165 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {</span>
 166 |     | <span class='neutral'>        // 32 is the length in bytes of hash,</span>
 167 |     | <span class='neutral'>        // enforced by the type signature above</span>
 168 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 169 |     | <span class='neutral'>        assembly {</span>
 170 |     | <span class='neutral'>            mstore(0x00, &quot;\x19Ethereum Signed Message:\n32&quot;)</span>
 171 |     | <span class='neutral'>            mstore(0x1c, hash)</span>
 172 |     | <span class='neutral'>            message := keccak256(0x00, 0x3c)</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>    }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /**</span>
 177 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Message, created from `s`. This</span>
 178 |     | <span class='neutral'>     * produces hash corresponding to the one signed with the</span>
 179 |     | <span class='neutral'>     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]</span>
 180 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-191.</span>
 181 |     | <span class='neutral'>     *</span>
 182 |     | <span class='neutral'>     * See {recover}.</span>
 183 |     | <span class='neutral'>     */</span>
 184 |     | <span class='neutral'>    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {</span>
 185 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19Ethereum Signed Message:\n&quot;, Strings.toString(s.length), s));</span>
 186 |     | <span class='neutral'>    }</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /**</span>
 189 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Typed Data, created from a</span>
 190 |     | <span class='neutral'>     * `domainSeparator` and a `structHash`. This produces hash corresponding</span>
 191 |     | <span class='neutral'>     * to the one signed with the</span>
 192 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]</span>
 193 |     | <span class='neutral'>     * JSON-RPC method as part of EIP-712.</span>
 194 |     | <span class='neutral'>     *</span>
 195 |     | <span class='neutral'>     * See {recover}.</span>
 196 |     | <span class='neutral'>     */</span>
 197 |     | <span class='unexecuted'>    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {</span>
 198 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 199 |     | <span class='neutral'>        assembly {</span>
 200 |     | <span class='unexecuted'>            let ptr := mload(0x40)</span>
 201 |     | <span class='unexecuted'>            mstore(ptr, &quot;\x19\x01&quot;)</span>
 202 |     | <span class='unexecuted'>            mstore(add(ptr, 0x02), domainSeparator)</span>
 203 |     | <span class='unexecuted'>            mstore(add(ptr, 0x22), structHash)</span>
 204 |     | <span class='unexecuted'>            data := keccak256(ptr, 0x42)</span>
 205 |     | <span class='neutral'>        }</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    /**</span>
 209 |     | <span class='neutral'>     * @dev Returns an Ethereum Signed Data with intended validator, created from a</span>
 210 |     | <span class='neutral'>     * `validator` and `data` according to the version 0 of EIP-191.</span>
 211 |     | <span class='neutral'>     *</span>
 212 |     | <span class='neutral'>     * See {recover}.</span>
 213 |     | <span class='neutral'>     */</span>
 214 |     | <span class='neutral'>    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {</span>
 215 |     | <span class='neutral'>        return keccak256(abi.encodePacked(&quot;\x19\x00&quot;, validator, data));</span>
 216 |     | <span class='neutral'>    }</span>
 217 |     | <span class='neutral'>}</span>
 218 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/cryptography/EIP712.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.8;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./ECDSA.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;../ShortStrings.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;../../interfaces/IERC5267.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/**</span>
  11 |     | <span class='neutral'> * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.</span>
  12 |     | <span class='neutral'> *</span>
  13 |     | <span class='neutral'> * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,</span>
  14 |     | <span class='neutral'> * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding</span>
  15 |     | <span class='neutral'> * they need in their contracts using a combination of `abi.encode` and `keccak256`.</span>
  16 |     | <span class='neutral'> *</span>
  17 |     | <span class='neutral'> * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding</span>
  18 |     | <span class='neutral'> * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA</span>
  19 |     | <span class='neutral'> * ({_hashTypedDataV4}).</span>
  20 |     | <span class='neutral'> *</span>
  21 |     | <span class='neutral'> * The implementation of the domain separator was designed to be as efficient as possible while still properly updating</span>
  22 |     | <span class='neutral'> * the chain id to protect against replay attacks on an eventual fork of the chain.</span>
  23 |     | <span class='neutral'> *</span>
  24 |     | <span class='neutral'> * NOTE: This contract implements the version of the encoding known as &quot;v4&quot;, as implemented by the JSON RPC method</span>
  25 |     | <span class='neutral'> * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].</span>
  26 |     | <span class='neutral'> *</span>
  27 |     | <span class='neutral'> * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain</span>
  28 |     | <span class='neutral'> * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the</span>
  29 |     | <span class='neutral'> * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.</span>
  30 |     | <span class='neutral'> *</span>
  31 |     | <span class='neutral'> * _Available since v3.4._</span>
  32 |     | <span class='neutral'> *</span>
  33 |     | <span class='neutral'> * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment</span>
  34 |     | <span class='neutral'> */</span>
  35 |     | <span class='neutral'>abstract contract EIP712 is IERC5267 {</span>
  36 |     | <span class='neutral'>    using ShortStrings for *;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    bytes32 private constant _TYPE_HASH =</span>
  39 |     | <span class='unexecuted'>        keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to</span>
  42 |     | <span class='neutral'>    // invalidate the cached domain separator if the chain id changes.</span>
  43 |     | <span class='neutral'>    bytes32 private immutable _cachedDomainSeparator;</span>
  44 |     | <span class='neutral'>    uint256 private immutable _cachedChainId;</span>
  45 |     | <span class='neutral'>    address private immutable _cachedThis;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    bytes32 private immutable _hashedName;</span>
  48 |     | <span class='neutral'>    bytes32 private immutable _hashedVersion;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    ShortString private immutable _name;</span>
  51 |     | <span class='neutral'>    ShortString private immutable _version;</span>
  52 |     | <span class='neutral'>    string private _nameFallback;</span>
  53 |     | <span class='neutral'>    string private _versionFallback;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /**</span>
  56 |     | <span class='neutral'>     * @dev Initializes the domain separator and parameter caches.</span>
  57 |     | <span class='neutral'>     *</span>
  58 |     | <span class='neutral'>     * The meaning of `name` and `version` is specified in</span>
  59 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:</span>
  60 |     | <span class='neutral'>     *</span>
  61 |     | <span class='neutral'>     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.</span>
  62 |     | <span class='neutral'>     * - `version`: the current major version of the signing domain.</span>
  63 |     | <span class='neutral'>     *</span>
  64 |     | <span class='neutral'>     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart</span>
  65 |     | <span class='neutral'>     * contract upgrade].</span>
  66 |     | <span class='neutral'>     */</span>
  67 |     | <span class='unexecuted'>    constructor(string memory name, string memory version) {</span>
  68 |     | <span class='unexecuted'>        _name = name.toShortStringWithFallback(_nameFallback);</span>
  69 |     | <span class='unexecuted'>        _version = version.toShortStringWithFallback(_versionFallback);</span>
  70 |     | <span class='unexecuted'>        _hashedName = keccak256(bytes(name));</span>
  71 |     | <span class='unexecuted'>        _hashedVersion = keccak256(bytes(version));</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        _cachedChainId = block.chainid;</span>
  74 |     | <span class='unexecuted'>        _cachedDomainSeparator = _buildDomainSeparator();</span>
  75 |     | <span class='unexecuted'>        _cachedThis = address(this);</span>
  76 |     | <span class='neutral'>    }</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /**</span>
  79 |     | <span class='neutral'>     * @dev Returns the domain separator for the current chain.</span>
  80 |     | <span class='neutral'>     */</span>
  81 |     | <span class='unexecuted'>    function _domainSeparatorV4() internal view returns (bytes32) {</span>
  82 |     | <span class='unexecuted'>        if (address(this) == _cachedThis &amp;&amp; block.chainid == _cachedChainId) {</span>
  83 |     | <span class='unexecuted'>            return _cachedDomainSeparator;</span>
  84 |     | <span class='neutral'>        } else {</span>
  85 |     | <span class='unexecuted'>            return _buildDomainSeparator();</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='unexecuted'>    function _buildDomainSeparator() private view returns (bytes32) {</span>
  90 |     | <span class='unexecuted'>        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));</span>
  91 |     | <span class='neutral'>    }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>    /**</span>
  94 |     | <span class='neutral'>     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this</span>
  95 |     | <span class='neutral'>     * function returns the hash of the fully encoded EIP712 message for this domain.</span>
  96 |     | <span class='neutral'>     *</span>
  97 |     | <span class='neutral'>     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:</span>
  98 |     | <span class='neutral'>     *</span>
  99 |     | <span class='neutral'>     * ```solidity</span>
 100 |     | <span class='neutral'>     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(</span>
 101 |     | <span class='neutral'>     *     keccak256(&quot;Mail(address to,string contents)&quot;),</span>
 102 |     | <span class='neutral'>     *     mailTo,</span>
 103 |     | <span class='neutral'>     *     keccak256(bytes(mailContents))</span>
 104 |     | <span class='neutral'>     * )));</span>
 105 |     | <span class='neutral'>     * address signer = ECDSA.recover(digest, signature);</span>
 106 |     | <span class='neutral'>     * ```</span>
 107 |     | <span class='neutral'>     */</span>
 108 |     | <span class='unexecuted'>    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {</span>
 109 |     | <span class='unexecuted'>        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /**</span>
 113 |     | <span class='neutral'>     * @dev See {EIP-5267}.</span>
 114 |     | <span class='neutral'>     *</span>
 115 |     | <span class='neutral'>     * _Available since v4.9._</span>
 116 |     | <span class='neutral'>     */</span>
 117 |     | <span class='unexecuted'>    function eip712Domain()</span>
 118 |     | <span class='neutral'>        public</span>
 119 |     | <span class='neutral'>        view</span>
 120 |     | <span class='neutral'>        virtual</span>
 121 |     | <span class='neutral'>        override</span>
 122 |     | <span class='neutral'>        returns (</span>
 123 |     | <span class='unexecuted'>            bytes1 fields,</span>
 124 |     | <span class='unexecuted'>            string memory name,</span>
 125 |     | <span class='neutral'>            string memory version,</span>
 126 |     | <span class='neutral'>            uint256 chainId,</span>
 127 |     | <span class='neutral'>            address verifyingContract,</span>
 128 |     | <span class='neutral'>            bytes32 salt,</span>
 129 |     | <span class='neutral'>            uint256[] memory extensions</span>
 130 |     | <span class='neutral'>        )</span>
 131 |     | <span class='neutral'>    {</span>
 132 |     | <span class='unexecuted'>        return (</span>
 133 |     | <span class='neutral'>            hex&quot;0f&quot;, // 01111</span>
 134 |     | <span class='unexecuted'>            _name.toStringWithFallback(_nameFallback),</span>
 135 |     | <span class='unexecuted'>            _version.toStringWithFallback(_versionFallback),</span>
 136 |     | <span class='unexecuted'>            block.chainid,</span>
 137 |     | <span class='unexecuted'>            address(this),</span>
 138 |     | <span class='unexecuted'>            bytes32(0),</span>
 139 |     | <span class='unexecuted'>            new uint256[](0)</span>
 140 |     | <span class='neutral'>        );</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'>}</span>
 143 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/ERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;./IERC165.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/**</span>
  9 |     | <span class='neutral'> * @dev Implementation of the {IERC165} interface.</span>
 10 |     | <span class='neutral'> *</span>
 11 |     | <span class='neutral'> * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check</span>
 12 |     | <span class='neutral'> * for the additional interface id that will be supported. For example:</span>
 13 |     | <span class='neutral'> *</span>
 14 |     | <span class='neutral'> * ```solidity</span>
 15 |     | <span class='neutral'> * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 16 |     | <span class='neutral'> *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);</span>
 17 |     | <span class='neutral'> * }</span>
 18 |     | <span class='neutral'> * ```</span>
 19 |     | <span class='neutral'> *</span>
 20 |     | <span class='neutral'> * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.</span>
 21 |     | <span class='neutral'> */</span>
 22 |     | <span class='neutral'>abstract contract ERC165 is IERC165 {</span>
 23 |     | <span class='neutral'>    /**</span>
 24 |     | <span class='neutral'>     * @dev See {IERC165-supportsInterface}.</span>
 25 |     | <span class='neutral'>     */</span>
 26 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
 27 |     | <span class='unexecuted'>        return interfaceId == type(IERC165).interfaceId;</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/introspection/IERC165.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Interface of the ERC165 standard, as defined in the</span>
  8 |     | <span class='neutral'> * https://eips.ethereum.org/EIPS/eip-165[EIP].</span>
  9 |     | <span class='neutral'> *</span>
 10 |     | <span class='neutral'> * Implementers can declare support of contract interfaces, which can then be</span>
 11 |     | <span class='neutral'> * queried by others ({ERC165Checker}).</span>
 12 |     | <span class='neutral'> *</span>
 13 |     | <span class='neutral'> * For an implementation, see {ERC165}.</span>
 14 |     | <span class='neutral'> */</span>
 15 |     | <span class='neutral'>interface IERC165 {</span>
 16 |     | <span class='neutral'>    /**</span>
 17 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 18 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 19 |     | <span class='neutral'>     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]</span>
 20 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 21 |     | <span class='neutral'>     *</span>
 22 |     | <span class='neutral'>     * This function call must use less than 30 000 gas.</span>
 23 |     | <span class='neutral'>     */</span>
 24 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 25 |     | <span class='neutral'>}</span>
 26 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/Math.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/**</span>
   7 |     | <span class='neutral'> * @dev Standard math utilities missing in the Solidity language.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='unexecuted'>library Math {</span>
  10 |     | <span class='neutral'>    enum Rounding {</span>
  11 |     | <span class='neutral'>        Down, // Toward negative infinity</span>
  12 |     | <span class='neutral'>        Up, // Toward infinity</span>
  13 |     | <span class='neutral'>        Zero // Toward zero</span>
  14 |     | <span class='neutral'>    }</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * @dev Returns the largest of two numbers.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    function max(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  20 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /**</span>
  24 |     | <span class='neutral'>     * @dev Returns the smallest of two numbers.</span>
  25 |     | <span class='neutral'>     */</span>
  26 |     | <span class='neutral'>    function min(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  27 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    /**</span>
  31 |     | <span class='neutral'>     * @dev Returns the average of two numbers. The result is rounded towards</span>
  32 |     | <span class='neutral'>     * zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    function average(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  35 |     | <span class='neutral'>        // (a + b) / 2 can overflow.</span>
  36 |     | <span class='neutral'>        return (a &amp; b) + (a ^ b) / 2;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /**</span>
  40 |     | <span class='neutral'>     * @dev Returns the ceiling of the division of two numbers.</span>
  41 |     | <span class='neutral'>     *</span>
  42 |     | <span class='neutral'>     * This differs from standard division with `/` in that it rounds up instead</span>
  43 |     | <span class='neutral'>     * of rounding down.</span>
  44 |     | <span class='neutral'>     */</span>
  45 |     | <span class='neutral'>    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {</span>
  46 |     | <span class='neutral'>        // (a + b - 1) / b can overflow on addition, so we distribute.</span>
  47 |     | <span class='neutral'>        return a == 0 ? 0 : (a - 1) / b + 1;</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /**</span>
  51 |     | <span class='neutral'>     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
  52 |     | <span class='neutral'>     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)</span>
  53 |     | <span class='neutral'>     * with further edits by Uniswap Labs also under MIT license.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {</span>
  56 |     | <span class='neutral'>        unchecked {</span>
  57 |     | <span class='neutral'>            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use</span>
  58 |     | <span class='neutral'>            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256</span>
  59 |     | <span class='neutral'>            // variables such that product = prod1 * 2^256 + prod0.</span>
  60 |     | <span class='neutral'>            uint256 prod0; // Least significant 256 bits of the product</span>
  61 |     | <span class='neutral'>            uint256 prod1; // Most significant 256 bits of the product</span>
  62 |     | <span class='neutral'>            assembly {</span>
  63 |     | <span class='neutral'>                let mm := mulmod(x, y, not(0))</span>
  64 |     | <span class='neutral'>                prod0 := mul(x, y)</span>
  65 |     | <span class='neutral'>                prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  66 |     | <span class='neutral'>            }</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>            // Handle non-overflow cases, 256 by 256 division.</span>
  69 |     | <span class='neutral'>            if (prod1 == 0) {</span>
  70 |     | <span class='neutral'>                // Solidity will revert if denominator == 0, unlike the div opcode on its own.</span>
  71 |     | <span class='neutral'>                // The surrounding unchecked block does not change this fact.</span>
  72 |     | <span class='neutral'>                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.</span>
  73 |     | <span class='neutral'>                return prod0 / denominator;</span>
  74 |     | <span class='neutral'>            }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>            // Make sure the result is less than 2^256. Also prevents denominator == 0.</span>
  77 |     | <span class='neutral'>            require(denominator &gt; prod1, &quot;Math: mulDiv overflow&quot;);</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  80 |     | <span class='neutral'>            // 512 by 256 division.</span>
  81 |     | <span class='neutral'>            ///////////////////////////////////////////////</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>            // Make division exact by subtracting the remainder from [prod1 prod0].</span>
  84 |     | <span class='neutral'>            uint256 remainder;</span>
  85 |     | <span class='neutral'>            assembly {</span>
  86 |     | <span class='neutral'>                // Compute remainder using mulmod.</span>
  87 |     | <span class='neutral'>                remainder := mulmod(x, y, denominator)</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>                // Subtract 256 bit number from 512 bit number.</span>
  90 |     | <span class='neutral'>                prod1 := sub(prod1, gt(remainder, prod0))</span>
  91 |     | <span class='neutral'>                prod0 := sub(prod0, remainder)</span>
  92 |     | <span class='neutral'>            }</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always &gt;= 1.</span>
  95 |     | <span class='neutral'>            // See https://cs.stackexchange.com/q/138556/92363.</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>            // Does not overflow because the denominator cannot be zero at this stage in the function.</span>
  98 |     | <span class='neutral'>            uint256 twos = denominator &amp; (~denominator + 1);</span>
  99 |     | <span class='neutral'>            assembly {</span>
 100 |     | <span class='neutral'>                // Divide denominator by twos.</span>
 101 |     | <span class='neutral'>                denominator := div(denominator, twos)</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>                // Divide [prod1 prod0] by twos.</span>
 104 |     | <span class='neutral'>                prod0 := div(prod0, twos)</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.</span>
 107 |     | <span class='neutral'>                twos := add(div(sub(0, twos), twos), 1)</span>
 108 |     | <span class='neutral'>            }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>            // Shift in bits from prod1 into prod0.</span>
 111 |     | <span class='neutral'>            prod0 |= prod1 * twos;</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such</span>
 114 |     | <span class='neutral'>            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for</span>
 115 |     | <span class='neutral'>            // four bits. That is, denominator * inv = 1 mod 2^4.</span>
 116 |     | <span class='neutral'>            uint256 inverse = (3 * denominator) ^ 2;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel&#39;s lifting lemma, this also works</span>
 119 |     | <span class='neutral'>            // in modular arithmetic, doubling the correct bits in each step.</span>
 120 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^8</span>
 121 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^16</span>
 122 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^32</span>
 123 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^64</span>
 124 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^128</span>
 125 |     | <span class='neutral'>            inverse *= 2 - denominator * inverse; // inverse mod 2^256</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.</span>
 128 |     | <span class='neutral'>            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is</span>
 129 |     | <span class='neutral'>            // less than 2^256, this is the final result. We don&#39;t need to compute the high bits of the result and prod1</span>
 130 |     | <span class='neutral'>            // is no longer required.</span>
 131 |     | <span class='neutral'>            result = prod0 * inverse;</span>
 132 |     | <span class='neutral'>            return result;</span>
 133 |     | <span class='neutral'>        }</span>
 134 |     | <span class='neutral'>    }</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    /**</span>
 137 |     | <span class='neutral'>     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.</span>
 138 |     | <span class='neutral'>     */</span>
 139 |     | <span class='neutral'>    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {</span>
 140 |     | <span class='neutral'>        uint256 result = mulDiv(x, y, denominator);</span>
 141 |     | <span class='neutral'>        if (rounding == Rounding.Up &amp;&amp; mulmod(x, y, denominator) &gt; 0) {</span>
 142 |     | <span class='neutral'>            result += 1;</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        return result;</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /**</span>
 148 |     | <span class='neutral'>     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.</span>
 149 |     | <span class='neutral'>     *</span>
 150 |     | <span class='neutral'>     * Inspired by Henry S. Warren, Jr.&#39;s &quot;Hacker&#39;s Delight&quot; (Chapter 11).</span>
 151 |     | <span class='neutral'>     */</span>
 152 |     | <span class='neutral'>    function sqrt(uint256 a) internal pure returns (uint256) {</span>
 153 |     | <span class='neutral'>        if (a == 0) {</span>
 154 |     | <span class='neutral'>            return 0;</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.</span>
 158 |     | <span class='neutral'>        //</span>
 159 |     | <span class='neutral'>        // We know that the &quot;msb&quot; (most significant bit) of our target number `a` is a power of 2 such that we have</span>
 160 |     | <span class='neutral'>        // `msb(a) &lt;= a &lt; 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.</span>
 161 |     | <span class='neutral'>        //</span>
 162 |     | <span class='neutral'>        // This can be rewritten `2**log2(a) &lt;= a &lt; 2**(log2(a) + 1)`</span>
 163 |     | <span class='neutral'>        //  `sqrt(2**k) &lt;= sqrt(a) &lt; sqrt(2**(k+1))`</span>
 164 |     | <span class='neutral'>        //  `2**(k/2) &lt;= sqrt(a) &lt; 2**((k+1)/2) &lt;= 2**(k/2 + 1)`</span>
 165 |     | <span class='neutral'>        //</span>
 166 |     | <span class='neutral'>        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.</span>
 167 |     | <span class='neutral'>        uint256 result = 1 &lt;&lt; (log2(a) &gt;&gt; 1);</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,</span>
 170 |     | <span class='neutral'>        // since it is the square root of a uint256. Newton&#39;s method converges quadratically (precision doubles at</span>
 171 |     | <span class='neutral'>        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision</span>
 172 |     | <span class='neutral'>        // into the expected uint128 result.</span>
 173 |     | <span class='neutral'>        unchecked {</span>
 174 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 175 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 176 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 177 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 178 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 179 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 180 |     | <span class='neutral'>            result = (result + a / result) &gt;&gt; 1;</span>
 181 |     | <span class='neutral'>            return min(result, a / result);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /**</span>
 186 |     | <span class='neutral'>     * @notice Calculates sqrt(a), following the selected rounding direction.</span>
 187 |     | <span class='neutral'>     */</span>
 188 |     | <span class='neutral'>    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {</span>
 189 |     | <span class='neutral'>        unchecked {</span>
 190 |     | <span class='neutral'>            uint256 result = sqrt(a);</span>
 191 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; result * result &lt; a ? 1 : 0);</span>
 192 |     | <span class='neutral'>        }</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /**</span>
 196 |     | <span class='neutral'>     * @dev Return the log in base 2, rounded down, of a positive value.</span>
 197 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 198 |     | <span class='neutral'>     */</span>
 199 |     | <span class='neutral'>    function log2(uint256 value) internal pure returns (uint256) {</span>
 200 |     | <span class='neutral'>        uint256 result = 0;</span>
 201 |     | <span class='neutral'>        unchecked {</span>
 202 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 203 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 204 |     | <span class='neutral'>                result += 128;</span>
 205 |     | <span class='neutral'>            }</span>
 206 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 207 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 208 |     | <span class='neutral'>                result += 64;</span>
 209 |     | <span class='neutral'>            }</span>
 210 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 211 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 212 |     | <span class='neutral'>                result += 32;</span>
 213 |     | <span class='neutral'>            }</span>
 214 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 215 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 216 |     | <span class='neutral'>                result += 16;</span>
 217 |     | <span class='neutral'>            }</span>
 218 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 219 |     | <span class='neutral'>                value &gt;&gt;= 8;</span>
 220 |     | <span class='neutral'>                result += 8;</span>
 221 |     | <span class='neutral'>            }</span>
 222 |     | <span class='neutral'>            if (value &gt;&gt; 4 &gt; 0) {</span>
 223 |     | <span class='neutral'>                value &gt;&gt;= 4;</span>
 224 |     | <span class='neutral'>                result += 4;</span>
 225 |     | <span class='neutral'>            }</span>
 226 |     | <span class='neutral'>            if (value &gt;&gt; 2 &gt; 0) {</span>
 227 |     | <span class='neutral'>                value &gt;&gt;= 2;</span>
 228 |     | <span class='neutral'>                result += 2;</span>
 229 |     | <span class='neutral'>            }</span>
 230 |     | <span class='neutral'>            if (value &gt;&gt; 1 &gt; 0) {</span>
 231 |     | <span class='neutral'>                result += 1;</span>
 232 |     | <span class='neutral'>            }</span>
 233 |     | <span class='neutral'>        }</span>
 234 |     | <span class='neutral'>        return result;</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='neutral'>    /**</span>
 238 |     | <span class='neutral'>     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.</span>
 239 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 240 |     | <span class='neutral'>     */</span>
 241 |     | <span class='neutral'>    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 242 |     | <span class='neutral'>        unchecked {</span>
 243 |     | <span class='neutral'>            uint256 result = log2(value);</span>
 244 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; result &lt; value ? 1 : 0);</span>
 245 |     | <span class='neutral'>        }</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'></span>
 248 |     | <span class='neutral'>    /**</span>
 249 |     | <span class='neutral'>     * @dev Return the log in base 10, rounded down, of a positive value.</span>
 250 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 251 |     | <span class='neutral'>     */</span>
 252 |     | <span class='unexecuted'>    function log10(uint256 value) internal pure returns (uint256) {</span>
 253 |     | <span class='neutral'>        uint256 result = 0;</span>
 254 |     | <span class='neutral'>        unchecked {</span>
 255 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 64) {</span>
 256 |     | <span class='unexecuted'>                value /= 10 ** 64;</span>
 257 |     | <span class='unexecuted'>                result += 64;</span>
 258 |     | <span class='neutral'>            }</span>
 259 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 32) {</span>
 260 |     | <span class='unexecuted'>                value /= 10 ** 32;</span>
 261 |     | <span class='unexecuted'>                result += 32;</span>
 262 |     | <span class='neutral'>            }</span>
 263 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 16) {</span>
 264 |     | <span class='unexecuted'>                value /= 10 ** 16;</span>
 265 |     | <span class='unexecuted'>                result += 16;</span>
 266 |     | <span class='neutral'>            }</span>
 267 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 8) {</span>
 268 |     | <span class='unexecuted'>                value /= 10 ** 8;</span>
 269 |     | <span class='unexecuted'>                result += 8;</span>
 270 |     | <span class='neutral'>            }</span>
 271 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 4) {</span>
 272 |     | <span class='unexecuted'>                value /= 10 ** 4;</span>
 273 |     | <span class='unexecuted'>                result += 4;</span>
 274 |     | <span class='neutral'>            }</span>
 275 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 2) {</span>
 276 |     | <span class='unexecuted'>                value /= 10 ** 2;</span>
 277 |     | <span class='unexecuted'>                result += 2;</span>
 278 |     | <span class='neutral'>            }</span>
 279 |     | <span class='unexecuted'>            if (value &gt;= 10 ** 1) {</span>
 280 |     | <span class='unexecuted'>                result += 1;</span>
 281 |     | <span class='neutral'>            }</span>
 282 |     | <span class='neutral'>        }</span>
 283 |     | <span class='unexecuted'>        return result;</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='neutral'>    /**</span>
 287 |     | <span class='neutral'>     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.</span>
 288 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 289 |     | <span class='neutral'>     */</span>
 290 |     | <span class='neutral'>    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 291 |     | <span class='neutral'>        unchecked {</span>
 292 |     | <span class='neutral'>            uint256 result = log10(value);</span>
 293 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 10 ** result &lt; value ? 1 : 0);</span>
 294 |     | <span class='neutral'>        }</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /**</span>
 298 |     | <span class='neutral'>     * @dev Return the log in base 256, rounded down, of a positive value.</span>
 299 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 300 |     | <span class='neutral'>     *</span>
 301 |     | <span class='neutral'>     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.</span>
 302 |     | <span class='neutral'>     */</span>
 303 |     | <span class='neutral'>    function log256(uint256 value) internal pure returns (uint256) {</span>
 304 |     | <span class='neutral'>        uint256 result = 0;</span>
 305 |     | <span class='neutral'>        unchecked {</span>
 306 |     | <span class='neutral'>            if (value &gt;&gt; 128 &gt; 0) {</span>
 307 |     | <span class='neutral'>                value &gt;&gt;= 128;</span>
 308 |     | <span class='neutral'>                result += 16;</span>
 309 |     | <span class='neutral'>            }</span>
 310 |     | <span class='neutral'>            if (value &gt;&gt; 64 &gt; 0) {</span>
 311 |     | <span class='neutral'>                value &gt;&gt;= 64;</span>
 312 |     | <span class='neutral'>                result += 8;</span>
 313 |     | <span class='neutral'>            }</span>
 314 |     | <span class='neutral'>            if (value &gt;&gt; 32 &gt; 0) {</span>
 315 |     | <span class='neutral'>                value &gt;&gt;= 32;</span>
 316 |     | <span class='neutral'>                result += 4;</span>
 317 |     | <span class='neutral'>            }</span>
 318 |     | <span class='neutral'>            if (value &gt;&gt; 16 &gt; 0) {</span>
 319 |     | <span class='neutral'>                value &gt;&gt;= 16;</span>
 320 |     | <span class='neutral'>                result += 2;</span>
 321 |     | <span class='neutral'>            }</span>
 322 |     | <span class='neutral'>            if (value &gt;&gt; 8 &gt; 0) {</span>
 323 |     | <span class='neutral'>                result += 1;</span>
 324 |     | <span class='neutral'>            }</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'>        return result;</span>
 327 |     | <span class='neutral'>    }</span>
 328 |     | <span class='neutral'></span>
 329 |     | <span class='neutral'>    /**</span>
 330 |     | <span class='neutral'>     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.</span>
 331 |     | <span class='neutral'>     * Returns 0 if given 0.</span>
 332 |     | <span class='neutral'>     */</span>
 333 |     | <span class='neutral'>    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {</span>
 334 |     | <span class='neutral'>        unchecked {</span>
 335 |     | <span class='neutral'>            uint256 result = log256(value);</span>
 336 |     | <span class='neutral'>            return result + (rounding == Rounding.Up &amp;&amp; 1 &lt;&lt; (result &lt;&lt; 3) &lt; value ? 1 : 0);</span>
 337 |     | <span class='neutral'>        }</span>
 338 |     | <span class='neutral'>    }</span>
 339 |     | <span class='neutral'>}</span>
 340 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SafeCast.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)</span>
    3 |     | <span class='neutral'>// This file was procedurally generated from scripts/generate/templates/SafeCast.js.</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>/**</span>
    8 |     | <span class='neutral'> * @dev Wrappers over Solidity&#39;s uintXX/intXX casting operators with added overflow</span>
    9 |     | <span class='neutral'> * checks.</span>
   10 |     | <span class='neutral'> *</span>
   11 |     | <span class='neutral'> * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can</span>
   12 |     | <span class='neutral'> * easily result in undesired exploitation or bugs, since developers usually</span>
   13 |     | <span class='neutral'> * assume that overflows raise errors. `SafeCast` restores this intuition by</span>
   14 |     | <span class='neutral'> * reverting the transaction when such an operation overflows.</span>
   15 |     | <span class='neutral'> *</span>
   16 |     | <span class='neutral'> * Using this library instead of the unchecked operations eliminates an entire</span>
   17 |     | <span class='neutral'> * class of bugs, so it&#39;s recommended to use it always.</span>
   18 |     | <span class='neutral'> *</span>
   19 |     | <span class='neutral'> * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing</span>
   20 |     | <span class='neutral'> * all math on `uint256` and `int256` and then downcasting.</span>
   21 |     | <span class='neutral'> */</span>
   22 |     | <span class='unexecuted'>library SafeCast {</span>
   23 |     | <span class='neutral'>    /**</span>
   24 |     | <span class='neutral'>     * @dev Returns the downcasted uint248 from uint256, reverting on</span>
   25 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint248).</span>
   26 |     | <span class='neutral'>     *</span>
   27 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint248` operator.</span>
   28 |     | <span class='neutral'>     *</span>
   29 |     | <span class='neutral'>     * Requirements:</span>
   30 |     | <span class='neutral'>     *</span>
   31 |     | <span class='neutral'>     * - input must fit into 248 bits</span>
   32 |     | <span class='neutral'>     *</span>
   33 |     | <span class='neutral'>     * _Available since v4.7._</span>
   34 |     | <span class='neutral'>     */</span>
   35 |     | <span class='neutral'>    function toUint248(uint256 value) internal pure returns (uint248) {</span>
   36 |     | <span class='neutral'>        require(value &lt;= type(uint248).max, &quot;SafeCast: value doesn&#39;t fit in 248 bits&quot;);</span>
   37 |     | <span class='neutral'>        return uint248(value);</span>
   38 |     | <span class='neutral'>    }</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>    /**</span>
   41 |     | <span class='neutral'>     * @dev Returns the downcasted uint240 from uint256, reverting on</span>
   42 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint240).</span>
   43 |     | <span class='neutral'>     *</span>
   44 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint240` operator.</span>
   45 |     | <span class='neutral'>     *</span>
   46 |     | <span class='neutral'>     * Requirements:</span>
   47 |     | <span class='neutral'>     *</span>
   48 |     | <span class='neutral'>     * - input must fit into 240 bits</span>
   49 |     | <span class='neutral'>     *</span>
   50 |     | <span class='neutral'>     * _Available since v4.7._</span>
   51 |     | <span class='neutral'>     */</span>
   52 |     | <span class='neutral'>    function toUint240(uint256 value) internal pure returns (uint240) {</span>
   53 |     | <span class='neutral'>        require(value &lt;= type(uint240).max, &quot;SafeCast: value doesn&#39;t fit in 240 bits&quot;);</span>
   54 |     | <span class='neutral'>        return uint240(value);</span>
   55 |     | <span class='neutral'>    }</span>
   56 |     | <span class='neutral'></span>
   57 |     | <span class='neutral'>    /**</span>
   58 |     | <span class='neutral'>     * @dev Returns the downcasted uint232 from uint256, reverting on</span>
   59 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint232).</span>
   60 |     | <span class='neutral'>     *</span>
   61 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint232` operator.</span>
   62 |     | <span class='neutral'>     *</span>
   63 |     | <span class='neutral'>     * Requirements:</span>
   64 |     | <span class='neutral'>     *</span>
   65 |     | <span class='neutral'>     * - input must fit into 232 bits</span>
   66 |     | <span class='neutral'>     *</span>
   67 |     | <span class='neutral'>     * _Available since v4.7._</span>
   68 |     | <span class='neutral'>     */</span>
   69 |     | <span class='neutral'>    function toUint232(uint256 value) internal pure returns (uint232) {</span>
   70 |     | <span class='neutral'>        require(value &lt;= type(uint232).max, &quot;SafeCast: value doesn&#39;t fit in 232 bits&quot;);</span>
   71 |     | <span class='neutral'>        return uint232(value);</span>
   72 |     | <span class='neutral'>    }</span>
   73 |     | <span class='neutral'></span>
   74 |     | <span class='neutral'>    /**</span>
   75 |     | <span class='neutral'>     * @dev Returns the downcasted uint224 from uint256, reverting on</span>
   76 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint224).</span>
   77 |     | <span class='neutral'>     *</span>
   78 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint224` operator.</span>
   79 |     | <span class='neutral'>     *</span>
   80 |     | <span class='neutral'>     * Requirements:</span>
   81 |     | <span class='neutral'>     *</span>
   82 |     | <span class='neutral'>     * - input must fit into 224 bits</span>
   83 |     | <span class='neutral'>     *</span>
   84 |     | <span class='neutral'>     * _Available since v4.2._</span>
   85 |     | <span class='neutral'>     */</span>
   86 |     | <span class='neutral'>    function toUint224(uint256 value) internal pure returns (uint224) {</span>
   87 |     | <span class='neutral'>        require(value &lt;= type(uint224).max, &quot;SafeCast: value doesn&#39;t fit in 224 bits&quot;);</span>
   88 |     | <span class='neutral'>        return uint224(value);</span>
   89 |     | <span class='neutral'>    }</span>
   90 |     | <span class='neutral'></span>
   91 |     | <span class='neutral'>    /**</span>
   92 |     | <span class='neutral'>     * @dev Returns the downcasted uint216 from uint256, reverting on</span>
   93 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint216).</span>
   94 |     | <span class='neutral'>     *</span>
   95 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint216` operator.</span>
   96 |     | <span class='neutral'>     *</span>
   97 |     | <span class='neutral'>     * Requirements:</span>
   98 |     | <span class='neutral'>     *</span>
   99 |     | <span class='neutral'>     * - input must fit into 216 bits</span>
  100 |     | <span class='neutral'>     *</span>
  101 |     | <span class='neutral'>     * _Available since v4.7._</span>
  102 |     | <span class='neutral'>     */</span>
  103 |     | <span class='neutral'>    function toUint216(uint256 value) internal pure returns (uint216) {</span>
  104 |     | <span class='neutral'>        require(value &lt;= type(uint216).max, &quot;SafeCast: value doesn&#39;t fit in 216 bits&quot;);</span>
  105 |     | <span class='neutral'>        return uint216(value);</span>
  106 |     | <span class='neutral'>    }</span>
  107 |     | <span class='neutral'></span>
  108 |     | <span class='neutral'>    /**</span>
  109 |     | <span class='neutral'>     * @dev Returns the downcasted uint208 from uint256, reverting on</span>
  110 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint208).</span>
  111 |     | <span class='neutral'>     *</span>
  112 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint208` operator.</span>
  113 |     | <span class='neutral'>     *</span>
  114 |     | <span class='neutral'>     * Requirements:</span>
  115 |     | <span class='neutral'>     *</span>
  116 |     | <span class='neutral'>     * - input must fit into 208 bits</span>
  117 |     | <span class='neutral'>     *</span>
  118 |     | <span class='neutral'>     * _Available since v4.7._</span>
  119 |     | <span class='neutral'>     */</span>
  120 |     | <span class='neutral'>    function toUint208(uint256 value) internal pure returns (uint208) {</span>
  121 |     | <span class='neutral'>        require(value &lt;= type(uint208).max, &quot;SafeCast: value doesn&#39;t fit in 208 bits&quot;);</span>
  122 |     | <span class='neutral'>        return uint208(value);</span>
  123 |     | <span class='neutral'>    }</span>
  124 |     | <span class='neutral'></span>
  125 |     | <span class='neutral'>    /**</span>
  126 |     | <span class='neutral'>     * @dev Returns the downcasted uint200 from uint256, reverting on</span>
  127 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint200).</span>
  128 |     | <span class='neutral'>     *</span>
  129 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint200` operator.</span>
  130 |     | <span class='neutral'>     *</span>
  131 |     | <span class='neutral'>     * Requirements:</span>
  132 |     | <span class='neutral'>     *</span>
  133 |     | <span class='neutral'>     * - input must fit into 200 bits</span>
  134 |     | <span class='neutral'>     *</span>
  135 |     | <span class='neutral'>     * _Available since v4.7._</span>
  136 |     | <span class='neutral'>     */</span>
  137 |     | <span class='neutral'>    function toUint200(uint256 value) internal pure returns (uint200) {</span>
  138 |     | <span class='neutral'>        require(value &lt;= type(uint200).max, &quot;SafeCast: value doesn&#39;t fit in 200 bits&quot;);</span>
  139 |     | <span class='neutral'>        return uint200(value);</span>
  140 |     | <span class='neutral'>    }</span>
  141 |     | <span class='neutral'></span>
  142 |     | <span class='neutral'>    /**</span>
  143 |     | <span class='neutral'>     * @dev Returns the downcasted uint192 from uint256, reverting on</span>
  144 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint192).</span>
  145 |     | <span class='neutral'>     *</span>
  146 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint192` operator.</span>
  147 |     | <span class='neutral'>     *</span>
  148 |     | <span class='neutral'>     * Requirements:</span>
  149 |     | <span class='neutral'>     *</span>
  150 |     | <span class='neutral'>     * - input must fit into 192 bits</span>
  151 |     | <span class='neutral'>     *</span>
  152 |     | <span class='neutral'>     * _Available since v4.7._</span>
  153 |     | <span class='neutral'>     */</span>
  154 |     | <span class='neutral'>    function toUint192(uint256 value) internal pure returns (uint192) {</span>
  155 |     | <span class='neutral'>        require(value &lt;= type(uint192).max, &quot;SafeCast: value doesn&#39;t fit in 192 bits&quot;);</span>
  156 |     | <span class='neutral'>        return uint192(value);</span>
  157 |     | <span class='neutral'>    }</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>    /**</span>
  160 |     | <span class='neutral'>     * @dev Returns the downcasted uint184 from uint256, reverting on</span>
  161 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint184).</span>
  162 |     | <span class='neutral'>     *</span>
  163 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint184` operator.</span>
  164 |     | <span class='neutral'>     *</span>
  165 |     | <span class='neutral'>     * Requirements:</span>
  166 |     | <span class='neutral'>     *</span>
  167 |     | <span class='neutral'>     * - input must fit into 184 bits</span>
  168 |     | <span class='neutral'>     *</span>
  169 |     | <span class='neutral'>     * _Available since v4.7._</span>
  170 |     | <span class='neutral'>     */</span>
  171 |     | <span class='neutral'>    function toUint184(uint256 value) internal pure returns (uint184) {</span>
  172 |     | <span class='neutral'>        require(value &lt;= type(uint184).max, &quot;SafeCast: value doesn&#39;t fit in 184 bits&quot;);</span>
  173 |     | <span class='neutral'>        return uint184(value);</span>
  174 |     | <span class='neutral'>    }</span>
  175 |     | <span class='neutral'></span>
  176 |     | <span class='neutral'>    /**</span>
  177 |     | <span class='neutral'>     * @dev Returns the downcasted uint176 from uint256, reverting on</span>
  178 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint176).</span>
  179 |     | <span class='neutral'>     *</span>
  180 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint176` operator.</span>
  181 |     | <span class='neutral'>     *</span>
  182 |     | <span class='neutral'>     * Requirements:</span>
  183 |     | <span class='neutral'>     *</span>
  184 |     | <span class='neutral'>     * - input must fit into 176 bits</span>
  185 |     | <span class='neutral'>     *</span>
  186 |     | <span class='neutral'>     * _Available since v4.7._</span>
  187 |     | <span class='neutral'>     */</span>
  188 |     | <span class='neutral'>    function toUint176(uint256 value) internal pure returns (uint176) {</span>
  189 |     | <span class='neutral'>        require(value &lt;= type(uint176).max, &quot;SafeCast: value doesn&#39;t fit in 176 bits&quot;);</span>
  190 |     | <span class='neutral'>        return uint176(value);</span>
  191 |     | <span class='neutral'>    }</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>    /**</span>
  194 |     | <span class='neutral'>     * @dev Returns the downcasted uint168 from uint256, reverting on</span>
  195 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint168).</span>
  196 |     | <span class='neutral'>     *</span>
  197 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint168` operator.</span>
  198 |     | <span class='neutral'>     *</span>
  199 |     | <span class='neutral'>     * Requirements:</span>
  200 |     | <span class='neutral'>     *</span>
  201 |     | <span class='neutral'>     * - input must fit into 168 bits</span>
  202 |     | <span class='neutral'>     *</span>
  203 |     | <span class='neutral'>     * _Available since v4.7._</span>
  204 |     | <span class='neutral'>     */</span>
  205 |     | <span class='neutral'>    function toUint168(uint256 value) internal pure returns (uint168) {</span>
  206 |     | <span class='neutral'>        require(value &lt;= type(uint168).max, &quot;SafeCast: value doesn&#39;t fit in 168 bits&quot;);</span>
  207 |     | <span class='neutral'>        return uint168(value);</span>
  208 |     | <span class='neutral'>    }</span>
  209 |     | <span class='neutral'></span>
  210 |     | <span class='neutral'>    /**</span>
  211 |     | <span class='neutral'>     * @dev Returns the downcasted uint160 from uint256, reverting on</span>
  212 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint160).</span>
  213 |     | <span class='neutral'>     *</span>
  214 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint160` operator.</span>
  215 |     | <span class='neutral'>     *</span>
  216 |     | <span class='neutral'>     * Requirements:</span>
  217 |     | <span class='neutral'>     *</span>
  218 |     | <span class='neutral'>     * - input must fit into 160 bits</span>
  219 |     | <span class='neutral'>     *</span>
  220 |     | <span class='neutral'>     * _Available since v4.7._</span>
  221 |     | <span class='neutral'>     */</span>
  222 |     | <span class='neutral'>    function toUint160(uint256 value) internal pure returns (uint160) {</span>
  223 |     | <span class='neutral'>        require(value &lt;= type(uint160).max, &quot;SafeCast: value doesn&#39;t fit in 160 bits&quot;);</span>
  224 |     | <span class='neutral'>        return uint160(value);</span>
  225 |     | <span class='neutral'>    }</span>
  226 |     | <span class='neutral'></span>
  227 |     | <span class='neutral'>    /**</span>
  228 |     | <span class='neutral'>     * @dev Returns the downcasted uint152 from uint256, reverting on</span>
  229 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint152).</span>
  230 |     | <span class='neutral'>     *</span>
  231 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint152` operator.</span>
  232 |     | <span class='neutral'>     *</span>
  233 |     | <span class='neutral'>     * Requirements:</span>
  234 |     | <span class='neutral'>     *</span>
  235 |     | <span class='neutral'>     * - input must fit into 152 bits</span>
  236 |     | <span class='neutral'>     *</span>
  237 |     | <span class='neutral'>     * _Available since v4.7._</span>
  238 |     | <span class='neutral'>     */</span>
  239 |     | <span class='neutral'>    function toUint152(uint256 value) internal pure returns (uint152) {</span>
  240 |     | <span class='neutral'>        require(value &lt;= type(uint152).max, &quot;SafeCast: value doesn&#39;t fit in 152 bits&quot;);</span>
  241 |     | <span class='neutral'>        return uint152(value);</span>
  242 |     | <span class='neutral'>    }</span>
  243 |     | <span class='neutral'></span>
  244 |     | <span class='neutral'>    /**</span>
  245 |     | <span class='neutral'>     * @dev Returns the downcasted uint144 from uint256, reverting on</span>
  246 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint144).</span>
  247 |     | <span class='neutral'>     *</span>
  248 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint144` operator.</span>
  249 |     | <span class='neutral'>     *</span>
  250 |     | <span class='neutral'>     * Requirements:</span>
  251 |     | <span class='neutral'>     *</span>
  252 |     | <span class='neutral'>     * - input must fit into 144 bits</span>
  253 |     | <span class='neutral'>     *</span>
  254 |     | <span class='neutral'>     * _Available since v4.7._</span>
  255 |     | <span class='neutral'>     */</span>
  256 |     | <span class='neutral'>    function toUint144(uint256 value) internal pure returns (uint144) {</span>
  257 |     | <span class='neutral'>        require(value &lt;= type(uint144).max, &quot;SafeCast: value doesn&#39;t fit in 144 bits&quot;);</span>
  258 |     | <span class='neutral'>        return uint144(value);</span>
  259 |     | <span class='neutral'>    }</span>
  260 |     | <span class='neutral'></span>
  261 |     | <span class='neutral'>    /**</span>
  262 |     | <span class='neutral'>     * @dev Returns the downcasted uint136 from uint256, reverting on</span>
  263 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint136).</span>
  264 |     | <span class='neutral'>     *</span>
  265 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint136` operator.</span>
  266 |     | <span class='neutral'>     *</span>
  267 |     | <span class='neutral'>     * Requirements:</span>
  268 |     | <span class='neutral'>     *</span>
  269 |     | <span class='neutral'>     * - input must fit into 136 bits</span>
  270 |     | <span class='neutral'>     *</span>
  271 |     | <span class='neutral'>     * _Available since v4.7._</span>
  272 |     | <span class='neutral'>     */</span>
  273 |     | <span class='neutral'>    function toUint136(uint256 value) internal pure returns (uint136) {</span>
  274 |     | <span class='neutral'>        require(value &lt;= type(uint136).max, &quot;SafeCast: value doesn&#39;t fit in 136 bits&quot;);</span>
  275 |     | <span class='neutral'>        return uint136(value);</span>
  276 |     | <span class='neutral'>    }</span>
  277 |     | <span class='neutral'></span>
  278 |     | <span class='neutral'>    /**</span>
  279 |     | <span class='neutral'>     * @dev Returns the downcasted uint128 from uint256, reverting on</span>
  280 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint128).</span>
  281 |     | <span class='neutral'>     *</span>
  282 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint128` operator.</span>
  283 |     | <span class='neutral'>     *</span>
  284 |     | <span class='neutral'>     * Requirements:</span>
  285 |     | <span class='neutral'>     *</span>
  286 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  287 |     | <span class='neutral'>     *</span>
  288 |     | <span class='neutral'>     * _Available since v2.5._</span>
  289 |     | <span class='neutral'>     */</span>
  290 |     | <span class='unexecuted'>    function toUint128(uint256 value) internal pure returns (uint128) {</span>
  291 |     | <span class='unexecuted'>        require(value &lt;= type(uint128).max, &quot;SafeCast: value doesn&#39;t fit in 128 bits&quot;);</span>
  292 |     | <span class='unexecuted'>        return uint128(value);</span>
  293 |     | <span class='neutral'>    }</span>
  294 |     | <span class='neutral'></span>
  295 |     | <span class='neutral'>    /**</span>
  296 |     | <span class='neutral'>     * @dev Returns the downcasted uint120 from uint256, reverting on</span>
  297 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint120).</span>
  298 |     | <span class='neutral'>     *</span>
  299 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint120` operator.</span>
  300 |     | <span class='neutral'>     *</span>
  301 |     | <span class='neutral'>     * Requirements:</span>
  302 |     | <span class='neutral'>     *</span>
  303 |     | <span class='neutral'>     * - input must fit into 120 bits</span>
  304 |     | <span class='neutral'>     *</span>
  305 |     | <span class='neutral'>     * _Available since v4.7._</span>
  306 |     | <span class='neutral'>     */</span>
  307 |     | <span class='neutral'>    function toUint120(uint256 value) internal pure returns (uint120) {</span>
  308 |     | <span class='neutral'>        require(value &lt;= type(uint120).max, &quot;SafeCast: value doesn&#39;t fit in 120 bits&quot;);</span>
  309 |     | <span class='neutral'>        return uint120(value);</span>
  310 |     | <span class='neutral'>    }</span>
  311 |     | <span class='neutral'></span>
  312 |     | <span class='neutral'>    /**</span>
  313 |     | <span class='neutral'>     * @dev Returns the downcasted uint112 from uint256, reverting on</span>
  314 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint112).</span>
  315 |     | <span class='neutral'>     *</span>
  316 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint112` operator.</span>
  317 |     | <span class='neutral'>     *</span>
  318 |     | <span class='neutral'>     * Requirements:</span>
  319 |     | <span class='neutral'>     *</span>
  320 |     | <span class='neutral'>     * - input must fit into 112 bits</span>
  321 |     | <span class='neutral'>     *</span>
  322 |     | <span class='neutral'>     * _Available since v4.7._</span>
  323 |     | <span class='neutral'>     */</span>
  324 |     | <span class='neutral'>    function toUint112(uint256 value) internal pure returns (uint112) {</span>
  325 |     | <span class='neutral'>        require(value &lt;= type(uint112).max, &quot;SafeCast: value doesn&#39;t fit in 112 bits&quot;);</span>
  326 |     | <span class='neutral'>        return uint112(value);</span>
  327 |     | <span class='neutral'>    }</span>
  328 |     | <span class='neutral'></span>
  329 |     | <span class='neutral'>    /**</span>
  330 |     | <span class='neutral'>     * @dev Returns the downcasted uint104 from uint256, reverting on</span>
  331 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint104).</span>
  332 |     | <span class='neutral'>     *</span>
  333 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint104` operator.</span>
  334 |     | <span class='neutral'>     *</span>
  335 |     | <span class='neutral'>     * Requirements:</span>
  336 |     | <span class='neutral'>     *</span>
  337 |     | <span class='neutral'>     * - input must fit into 104 bits</span>
  338 |     | <span class='neutral'>     *</span>
  339 |     | <span class='neutral'>     * _Available since v4.7._</span>
  340 |     | <span class='neutral'>     */</span>
  341 |     | <span class='neutral'>    function toUint104(uint256 value) internal pure returns (uint104) {</span>
  342 |     | <span class='neutral'>        require(value &lt;= type(uint104).max, &quot;SafeCast: value doesn&#39;t fit in 104 bits&quot;);</span>
  343 |     | <span class='neutral'>        return uint104(value);</span>
  344 |     | <span class='neutral'>    }</span>
  345 |     | <span class='neutral'></span>
  346 |     | <span class='neutral'>    /**</span>
  347 |     | <span class='neutral'>     * @dev Returns the downcasted uint96 from uint256, reverting on</span>
  348 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint96).</span>
  349 |     | <span class='neutral'>     *</span>
  350 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint96` operator.</span>
  351 |     | <span class='neutral'>     *</span>
  352 |     | <span class='neutral'>     * Requirements:</span>
  353 |     | <span class='neutral'>     *</span>
  354 |     | <span class='neutral'>     * - input must fit into 96 bits</span>
  355 |     | <span class='neutral'>     *</span>
  356 |     | <span class='neutral'>     * _Available since v4.2._</span>
  357 |     | <span class='neutral'>     */</span>
  358 |     | <span class='neutral'>    function toUint96(uint256 value) internal pure returns (uint96) {</span>
  359 |     | <span class='neutral'>        require(value &lt;= type(uint96).max, &quot;SafeCast: value doesn&#39;t fit in 96 bits&quot;);</span>
  360 |     | <span class='neutral'>        return uint96(value);</span>
  361 |     | <span class='neutral'>    }</span>
  362 |     | <span class='neutral'></span>
  363 |     | <span class='neutral'>    /**</span>
  364 |     | <span class='neutral'>     * @dev Returns the downcasted uint88 from uint256, reverting on</span>
  365 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint88).</span>
  366 |     | <span class='neutral'>     *</span>
  367 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint88` operator.</span>
  368 |     | <span class='neutral'>     *</span>
  369 |     | <span class='neutral'>     * Requirements:</span>
  370 |     | <span class='neutral'>     *</span>
  371 |     | <span class='neutral'>     * - input must fit into 88 bits</span>
  372 |     | <span class='neutral'>     *</span>
  373 |     | <span class='neutral'>     * _Available since v4.7._</span>
  374 |     | <span class='neutral'>     */</span>
  375 |     | <span class='neutral'>    function toUint88(uint256 value) internal pure returns (uint88) {</span>
  376 |     | <span class='neutral'>        require(value &lt;= type(uint88).max, &quot;SafeCast: value doesn&#39;t fit in 88 bits&quot;);</span>
  377 |     | <span class='neutral'>        return uint88(value);</span>
  378 |     | <span class='neutral'>    }</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>    /**</span>
  381 |     | <span class='neutral'>     * @dev Returns the downcasted uint80 from uint256, reverting on</span>
  382 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint80).</span>
  383 |     | <span class='neutral'>     *</span>
  384 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint80` operator.</span>
  385 |     | <span class='neutral'>     *</span>
  386 |     | <span class='neutral'>     * Requirements:</span>
  387 |     | <span class='neutral'>     *</span>
  388 |     | <span class='neutral'>     * - input must fit into 80 bits</span>
  389 |     | <span class='neutral'>     *</span>
  390 |     | <span class='neutral'>     * _Available since v4.7._</span>
  391 |     | <span class='neutral'>     */</span>
  392 |     | <span class='neutral'>    function toUint80(uint256 value) internal pure returns (uint80) {</span>
  393 |     | <span class='neutral'>        require(value &lt;= type(uint80).max, &quot;SafeCast: value doesn&#39;t fit in 80 bits&quot;);</span>
  394 |     | <span class='neutral'>        return uint80(value);</span>
  395 |     | <span class='neutral'>    }</span>
  396 |     | <span class='neutral'></span>
  397 |     | <span class='neutral'>    /**</span>
  398 |     | <span class='neutral'>     * @dev Returns the downcasted uint72 from uint256, reverting on</span>
  399 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint72).</span>
  400 |     | <span class='neutral'>     *</span>
  401 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint72` operator.</span>
  402 |     | <span class='neutral'>     *</span>
  403 |     | <span class='neutral'>     * Requirements:</span>
  404 |     | <span class='neutral'>     *</span>
  405 |     | <span class='neutral'>     * - input must fit into 72 bits</span>
  406 |     | <span class='neutral'>     *</span>
  407 |     | <span class='neutral'>     * _Available since v4.7._</span>
  408 |     | <span class='neutral'>     */</span>
  409 |     | <span class='neutral'>    function toUint72(uint256 value) internal pure returns (uint72) {</span>
  410 |     | <span class='neutral'>        require(value &lt;= type(uint72).max, &quot;SafeCast: value doesn&#39;t fit in 72 bits&quot;);</span>
  411 |     | <span class='neutral'>        return uint72(value);</span>
  412 |     | <span class='neutral'>    }</span>
  413 |     | <span class='neutral'></span>
  414 |     | <span class='neutral'>    /**</span>
  415 |     | <span class='neutral'>     * @dev Returns the downcasted uint64 from uint256, reverting on</span>
  416 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint64).</span>
  417 |     | <span class='neutral'>     *</span>
  418 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint64` operator.</span>
  419 |     | <span class='neutral'>     *</span>
  420 |     | <span class='neutral'>     * Requirements:</span>
  421 |     | <span class='neutral'>     *</span>
  422 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
  423 |     | <span class='neutral'>     *</span>
  424 |     | <span class='neutral'>     * _Available since v2.5._</span>
  425 |     | <span class='neutral'>     */</span>
  426 |     | <span class='neutral'>    function toUint64(uint256 value) internal pure returns (uint64) {</span>
  427 |     | <span class='neutral'>        require(value &lt;= type(uint64).max, &quot;SafeCast: value doesn&#39;t fit in 64 bits&quot;);</span>
  428 |     | <span class='neutral'>        return uint64(value);</span>
  429 |     | <span class='neutral'>    }</span>
  430 |     | <span class='neutral'></span>
  431 |     | <span class='neutral'>    /**</span>
  432 |     | <span class='neutral'>     * @dev Returns the downcasted uint56 from uint256, reverting on</span>
  433 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint56).</span>
  434 |     | <span class='neutral'>     *</span>
  435 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint56` operator.</span>
  436 |     | <span class='neutral'>     *</span>
  437 |     | <span class='neutral'>     * Requirements:</span>
  438 |     | <span class='neutral'>     *</span>
  439 |     | <span class='neutral'>     * - input must fit into 56 bits</span>
  440 |     | <span class='neutral'>     *</span>
  441 |     | <span class='neutral'>     * _Available since v4.7._</span>
  442 |     | <span class='neutral'>     */</span>
  443 |     | <span class='neutral'>    function toUint56(uint256 value) internal pure returns (uint56) {</span>
  444 |     | <span class='neutral'>        require(value &lt;= type(uint56).max, &quot;SafeCast: value doesn&#39;t fit in 56 bits&quot;);</span>
  445 |     | <span class='neutral'>        return uint56(value);</span>
  446 |     | <span class='neutral'>    }</span>
  447 |     | <span class='neutral'></span>
  448 |     | <span class='neutral'>    /**</span>
  449 |     | <span class='neutral'>     * @dev Returns the downcasted uint48 from uint256, reverting on</span>
  450 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint48).</span>
  451 |     | <span class='neutral'>     *</span>
  452 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint48` operator.</span>
  453 |     | <span class='neutral'>     *</span>
  454 |     | <span class='neutral'>     * Requirements:</span>
  455 |     | <span class='neutral'>     *</span>
  456 |     | <span class='neutral'>     * - input must fit into 48 bits</span>
  457 |     | <span class='neutral'>     *</span>
  458 |     | <span class='neutral'>     * _Available since v4.7._</span>
  459 |     | <span class='neutral'>     */</span>
  460 |     | <span class='neutral'>    function toUint48(uint256 value) internal pure returns (uint48) {</span>
  461 |     | <span class='neutral'>        require(value &lt;= type(uint48).max, &quot;SafeCast: value doesn&#39;t fit in 48 bits&quot;);</span>
  462 |     | <span class='neutral'>        return uint48(value);</span>
  463 |     | <span class='neutral'>    }</span>
  464 |     | <span class='neutral'></span>
  465 |     | <span class='neutral'>    /**</span>
  466 |     | <span class='neutral'>     * @dev Returns the downcasted uint40 from uint256, reverting on</span>
  467 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint40).</span>
  468 |     | <span class='neutral'>     *</span>
  469 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint40` operator.</span>
  470 |     | <span class='neutral'>     *</span>
  471 |     | <span class='neutral'>     * Requirements:</span>
  472 |     | <span class='neutral'>     *</span>
  473 |     | <span class='neutral'>     * - input must fit into 40 bits</span>
  474 |     | <span class='neutral'>     *</span>
  475 |     | <span class='neutral'>     * _Available since v4.7._</span>
  476 |     | <span class='neutral'>     */</span>
  477 |     | <span class='neutral'>    function toUint40(uint256 value) internal pure returns (uint40) {</span>
  478 |     | <span class='neutral'>        require(value &lt;= type(uint40).max, &quot;SafeCast: value doesn&#39;t fit in 40 bits&quot;);</span>
  479 |     | <span class='neutral'>        return uint40(value);</span>
  480 |     | <span class='neutral'>    }</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    /**</span>
  483 |     | <span class='neutral'>     * @dev Returns the downcasted uint32 from uint256, reverting on</span>
  484 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint32).</span>
  485 |     | <span class='neutral'>     *</span>
  486 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint32` operator.</span>
  487 |     | <span class='neutral'>     *</span>
  488 |     | <span class='neutral'>     * Requirements:</span>
  489 |     | <span class='neutral'>     *</span>
  490 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
  491 |     | <span class='neutral'>     *</span>
  492 |     | <span class='neutral'>     * _Available since v2.5._</span>
  493 |     | <span class='neutral'>     */</span>
  494 |     | <span class='neutral'>    function toUint32(uint256 value) internal pure returns (uint32) {</span>
  495 |     | <span class='neutral'>        require(value &lt;= type(uint32).max, &quot;SafeCast: value doesn&#39;t fit in 32 bits&quot;);</span>
  496 |     | <span class='neutral'>        return uint32(value);</span>
  497 |     | <span class='neutral'>    }</span>
  498 |     | <span class='neutral'></span>
  499 |     | <span class='neutral'>    /**</span>
  500 |     | <span class='neutral'>     * @dev Returns the downcasted uint24 from uint256, reverting on</span>
  501 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint24).</span>
  502 |     | <span class='neutral'>     *</span>
  503 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint24` operator.</span>
  504 |     | <span class='neutral'>     *</span>
  505 |     | <span class='neutral'>     * Requirements:</span>
  506 |     | <span class='neutral'>     *</span>
  507 |     | <span class='neutral'>     * - input must fit into 24 bits</span>
  508 |     | <span class='neutral'>     *</span>
  509 |     | <span class='neutral'>     * _Available since v4.7._</span>
  510 |     | <span class='neutral'>     */</span>
  511 |     | <span class='neutral'>    function toUint24(uint256 value) internal pure returns (uint24) {</span>
  512 |     | <span class='neutral'>        require(value &lt;= type(uint24).max, &quot;SafeCast: value doesn&#39;t fit in 24 bits&quot;);</span>
  513 |     | <span class='neutral'>        return uint24(value);</span>
  514 |     | <span class='neutral'>    }</span>
  515 |     | <span class='neutral'></span>
  516 |     | <span class='neutral'>    /**</span>
  517 |     | <span class='neutral'>     * @dev Returns the downcasted uint16 from uint256, reverting on</span>
  518 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint16).</span>
  519 |     | <span class='neutral'>     *</span>
  520 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint16` operator.</span>
  521 |     | <span class='neutral'>     *</span>
  522 |     | <span class='neutral'>     * Requirements:</span>
  523 |     | <span class='neutral'>     *</span>
  524 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
  525 |     | <span class='neutral'>     *</span>
  526 |     | <span class='neutral'>     * _Available since v2.5._</span>
  527 |     | <span class='neutral'>     */</span>
  528 |     | <span class='neutral'>    function toUint16(uint256 value) internal pure returns (uint16) {</span>
  529 |     | <span class='neutral'>        require(value &lt;= type(uint16).max, &quot;SafeCast: value doesn&#39;t fit in 16 bits&quot;);</span>
  530 |     | <span class='neutral'>        return uint16(value);</span>
  531 |     | <span class='neutral'>    }</span>
  532 |     | <span class='neutral'></span>
  533 |     | <span class='neutral'>    /**</span>
  534 |     | <span class='neutral'>     * @dev Returns the downcasted uint8 from uint256, reverting on</span>
  535 |     | <span class='neutral'>     * overflow (when the input is greater than largest uint8).</span>
  536 |     | <span class='neutral'>     *</span>
  537 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `uint8` operator.</span>
  538 |     | <span class='neutral'>     *</span>
  539 |     | <span class='neutral'>     * Requirements:</span>
  540 |     | <span class='neutral'>     *</span>
  541 |     | <span class='neutral'>     * - input must fit into 8 bits</span>
  542 |     | <span class='neutral'>     *</span>
  543 |     | <span class='neutral'>     * _Available since v2.5._</span>
  544 |     | <span class='neutral'>     */</span>
  545 |     | <span class='neutral'>    function toUint8(uint256 value) internal pure returns (uint8) {</span>
  546 |     | <span class='neutral'>        require(value &lt;= type(uint8).max, &quot;SafeCast: value doesn&#39;t fit in 8 bits&quot;);</span>
  547 |     | <span class='neutral'>        return uint8(value);</span>
  548 |     | <span class='neutral'>    }</span>
  549 |     | <span class='neutral'></span>
  550 |     | <span class='neutral'>    /**</span>
  551 |     | <span class='neutral'>     * @dev Converts a signed int256 into an unsigned uint256.</span>
  552 |     | <span class='neutral'>     *</span>
  553 |     | <span class='neutral'>     * Requirements:</span>
  554 |     | <span class='neutral'>     *</span>
  555 |     | <span class='neutral'>     * - input must be greater than or equal to 0.</span>
  556 |     | <span class='neutral'>     *</span>
  557 |     | <span class='neutral'>     * _Available since v3.0._</span>
  558 |     | <span class='neutral'>     */</span>
  559 |     | <span class='neutral'>    function toUint256(int256 value) internal pure returns (uint256) {</span>
  560 |     | <span class='neutral'>        require(value &gt;= 0, &quot;SafeCast: value must be positive&quot;);</span>
  561 |     | <span class='neutral'>        return uint256(value);</span>
  562 |     | <span class='neutral'>    }</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>    /**</span>
  565 |     | <span class='neutral'>     * @dev Returns the downcasted int248 from int256, reverting on</span>
  566 |     | <span class='neutral'>     * overflow (when the input is less than smallest int248 or</span>
  567 |     | <span class='neutral'>     * greater than largest int248).</span>
  568 |     | <span class='neutral'>     *</span>
  569 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int248` operator.</span>
  570 |     | <span class='neutral'>     *</span>
  571 |     | <span class='neutral'>     * Requirements:</span>
  572 |     | <span class='neutral'>     *</span>
  573 |     | <span class='neutral'>     * - input must fit into 248 bits</span>
  574 |     | <span class='neutral'>     *</span>
  575 |     | <span class='neutral'>     * _Available since v4.7._</span>
  576 |     | <span class='neutral'>     */</span>
  577 |     | <span class='neutral'>    function toInt248(int256 value) internal pure returns (int248 downcasted) {</span>
  578 |     | <span class='neutral'>        downcasted = int248(value);</span>
  579 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 248 bits&quot;);</span>
  580 |     | <span class='neutral'>    }</span>
  581 |     | <span class='neutral'></span>
  582 |     | <span class='neutral'>    /**</span>
  583 |     | <span class='neutral'>     * @dev Returns the downcasted int240 from int256, reverting on</span>
  584 |     | <span class='neutral'>     * overflow (when the input is less than smallest int240 or</span>
  585 |     | <span class='neutral'>     * greater than largest int240).</span>
  586 |     | <span class='neutral'>     *</span>
  587 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int240` operator.</span>
  588 |     | <span class='neutral'>     *</span>
  589 |     | <span class='neutral'>     * Requirements:</span>
  590 |     | <span class='neutral'>     *</span>
  591 |     | <span class='neutral'>     * - input must fit into 240 bits</span>
  592 |     | <span class='neutral'>     *</span>
  593 |     | <span class='neutral'>     * _Available since v4.7._</span>
  594 |     | <span class='neutral'>     */</span>
  595 |     | <span class='neutral'>    function toInt240(int256 value) internal pure returns (int240 downcasted) {</span>
  596 |     | <span class='neutral'>        downcasted = int240(value);</span>
  597 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 240 bits&quot;);</span>
  598 |     | <span class='neutral'>    }</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>    /**</span>
  601 |     | <span class='neutral'>     * @dev Returns the downcasted int232 from int256, reverting on</span>
  602 |     | <span class='neutral'>     * overflow (when the input is less than smallest int232 or</span>
  603 |     | <span class='neutral'>     * greater than largest int232).</span>
  604 |     | <span class='neutral'>     *</span>
  605 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int232` operator.</span>
  606 |     | <span class='neutral'>     *</span>
  607 |     | <span class='neutral'>     * Requirements:</span>
  608 |     | <span class='neutral'>     *</span>
  609 |     | <span class='neutral'>     * - input must fit into 232 bits</span>
  610 |     | <span class='neutral'>     *</span>
  611 |     | <span class='neutral'>     * _Available since v4.7._</span>
  612 |     | <span class='neutral'>     */</span>
  613 |     | <span class='neutral'>    function toInt232(int256 value) internal pure returns (int232 downcasted) {</span>
  614 |     | <span class='neutral'>        downcasted = int232(value);</span>
  615 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 232 bits&quot;);</span>
  616 |     | <span class='neutral'>    }</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>    /**</span>
  619 |     | <span class='neutral'>     * @dev Returns the downcasted int224 from int256, reverting on</span>
  620 |     | <span class='neutral'>     * overflow (when the input is less than smallest int224 or</span>
  621 |     | <span class='neutral'>     * greater than largest int224).</span>
  622 |     | <span class='neutral'>     *</span>
  623 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int224` operator.</span>
  624 |     | <span class='neutral'>     *</span>
  625 |     | <span class='neutral'>     * Requirements:</span>
  626 |     | <span class='neutral'>     *</span>
  627 |     | <span class='neutral'>     * - input must fit into 224 bits</span>
  628 |     | <span class='neutral'>     *</span>
  629 |     | <span class='neutral'>     * _Available since v4.7._</span>
  630 |     | <span class='neutral'>     */</span>
  631 |     | <span class='neutral'>    function toInt224(int256 value) internal pure returns (int224 downcasted) {</span>
  632 |     | <span class='neutral'>        downcasted = int224(value);</span>
  633 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 224 bits&quot;);</span>
  634 |     | <span class='neutral'>    }</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='neutral'>    /**</span>
  637 |     | <span class='neutral'>     * @dev Returns the downcasted int216 from int256, reverting on</span>
  638 |     | <span class='neutral'>     * overflow (when the input is less than smallest int216 or</span>
  639 |     | <span class='neutral'>     * greater than largest int216).</span>
  640 |     | <span class='neutral'>     *</span>
  641 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int216` operator.</span>
  642 |     | <span class='neutral'>     *</span>
  643 |     | <span class='neutral'>     * Requirements:</span>
  644 |     | <span class='neutral'>     *</span>
  645 |     | <span class='neutral'>     * - input must fit into 216 bits</span>
  646 |     | <span class='neutral'>     *</span>
  647 |     | <span class='neutral'>     * _Available since v4.7._</span>
  648 |     | <span class='neutral'>     */</span>
  649 |     | <span class='neutral'>    function toInt216(int256 value) internal pure returns (int216 downcasted) {</span>
  650 |     | <span class='neutral'>        downcasted = int216(value);</span>
  651 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 216 bits&quot;);</span>
  652 |     | <span class='neutral'>    }</span>
  653 |     | <span class='neutral'></span>
  654 |     | <span class='neutral'>    /**</span>
  655 |     | <span class='neutral'>     * @dev Returns the downcasted int208 from int256, reverting on</span>
  656 |     | <span class='neutral'>     * overflow (when the input is less than smallest int208 or</span>
  657 |     | <span class='neutral'>     * greater than largest int208).</span>
  658 |     | <span class='neutral'>     *</span>
  659 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int208` operator.</span>
  660 |     | <span class='neutral'>     *</span>
  661 |     | <span class='neutral'>     * Requirements:</span>
  662 |     | <span class='neutral'>     *</span>
  663 |     | <span class='neutral'>     * - input must fit into 208 bits</span>
  664 |     | <span class='neutral'>     *</span>
  665 |     | <span class='neutral'>     * _Available since v4.7._</span>
  666 |     | <span class='neutral'>     */</span>
  667 |     | <span class='neutral'>    function toInt208(int256 value) internal pure returns (int208 downcasted) {</span>
  668 |     | <span class='neutral'>        downcasted = int208(value);</span>
  669 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 208 bits&quot;);</span>
  670 |     | <span class='neutral'>    }</span>
  671 |     | <span class='neutral'></span>
  672 |     | <span class='neutral'>    /**</span>
  673 |     | <span class='neutral'>     * @dev Returns the downcasted int200 from int256, reverting on</span>
  674 |     | <span class='neutral'>     * overflow (when the input is less than smallest int200 or</span>
  675 |     | <span class='neutral'>     * greater than largest int200).</span>
  676 |     | <span class='neutral'>     *</span>
  677 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int200` operator.</span>
  678 |     | <span class='neutral'>     *</span>
  679 |     | <span class='neutral'>     * Requirements:</span>
  680 |     | <span class='neutral'>     *</span>
  681 |     | <span class='neutral'>     * - input must fit into 200 bits</span>
  682 |     | <span class='neutral'>     *</span>
  683 |     | <span class='neutral'>     * _Available since v4.7._</span>
  684 |     | <span class='neutral'>     */</span>
  685 |     | <span class='neutral'>    function toInt200(int256 value) internal pure returns (int200 downcasted) {</span>
  686 |     | <span class='neutral'>        downcasted = int200(value);</span>
  687 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 200 bits&quot;);</span>
  688 |     | <span class='neutral'>    }</span>
  689 |     | <span class='neutral'></span>
  690 |     | <span class='neutral'>    /**</span>
  691 |     | <span class='neutral'>     * @dev Returns the downcasted int192 from int256, reverting on</span>
  692 |     | <span class='neutral'>     * overflow (when the input is less than smallest int192 or</span>
  693 |     | <span class='neutral'>     * greater than largest int192).</span>
  694 |     | <span class='neutral'>     *</span>
  695 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int192` operator.</span>
  696 |     | <span class='neutral'>     *</span>
  697 |     | <span class='neutral'>     * Requirements:</span>
  698 |     | <span class='neutral'>     *</span>
  699 |     | <span class='neutral'>     * - input must fit into 192 bits</span>
  700 |     | <span class='neutral'>     *</span>
  701 |     | <span class='neutral'>     * _Available since v4.7._</span>
  702 |     | <span class='neutral'>     */</span>
  703 |     | <span class='neutral'>    function toInt192(int256 value) internal pure returns (int192 downcasted) {</span>
  704 |     | <span class='neutral'>        downcasted = int192(value);</span>
  705 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 192 bits&quot;);</span>
  706 |     | <span class='neutral'>    }</span>
  707 |     | <span class='neutral'></span>
  708 |     | <span class='neutral'>    /**</span>
  709 |     | <span class='neutral'>     * @dev Returns the downcasted int184 from int256, reverting on</span>
  710 |     | <span class='neutral'>     * overflow (when the input is less than smallest int184 or</span>
  711 |     | <span class='neutral'>     * greater than largest int184).</span>
  712 |     | <span class='neutral'>     *</span>
  713 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int184` operator.</span>
  714 |     | <span class='neutral'>     *</span>
  715 |     | <span class='neutral'>     * Requirements:</span>
  716 |     | <span class='neutral'>     *</span>
  717 |     | <span class='neutral'>     * - input must fit into 184 bits</span>
  718 |     | <span class='neutral'>     *</span>
  719 |     | <span class='neutral'>     * _Available since v4.7._</span>
  720 |     | <span class='neutral'>     */</span>
  721 |     | <span class='neutral'>    function toInt184(int256 value) internal pure returns (int184 downcasted) {</span>
  722 |     | <span class='neutral'>        downcasted = int184(value);</span>
  723 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 184 bits&quot;);</span>
  724 |     | <span class='neutral'>    }</span>
  725 |     | <span class='neutral'></span>
  726 |     | <span class='neutral'>    /**</span>
  727 |     | <span class='neutral'>     * @dev Returns the downcasted int176 from int256, reverting on</span>
  728 |     | <span class='neutral'>     * overflow (when the input is less than smallest int176 or</span>
  729 |     | <span class='neutral'>     * greater than largest int176).</span>
  730 |     | <span class='neutral'>     *</span>
  731 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int176` operator.</span>
  732 |     | <span class='neutral'>     *</span>
  733 |     | <span class='neutral'>     * Requirements:</span>
  734 |     | <span class='neutral'>     *</span>
  735 |     | <span class='neutral'>     * - input must fit into 176 bits</span>
  736 |     | <span class='neutral'>     *</span>
  737 |     | <span class='neutral'>     * _Available since v4.7._</span>
  738 |     | <span class='neutral'>     */</span>
  739 |     | <span class='neutral'>    function toInt176(int256 value) internal pure returns (int176 downcasted) {</span>
  740 |     | <span class='neutral'>        downcasted = int176(value);</span>
  741 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 176 bits&quot;);</span>
  742 |     | <span class='neutral'>    }</span>
  743 |     | <span class='neutral'></span>
  744 |     | <span class='neutral'>    /**</span>
  745 |     | <span class='neutral'>     * @dev Returns the downcasted int168 from int256, reverting on</span>
  746 |     | <span class='neutral'>     * overflow (when the input is less than smallest int168 or</span>
  747 |     | <span class='neutral'>     * greater than largest int168).</span>
  748 |     | <span class='neutral'>     *</span>
  749 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int168` operator.</span>
  750 |     | <span class='neutral'>     *</span>
  751 |     | <span class='neutral'>     * Requirements:</span>
  752 |     | <span class='neutral'>     *</span>
  753 |     | <span class='neutral'>     * - input must fit into 168 bits</span>
  754 |     | <span class='neutral'>     *</span>
  755 |     | <span class='neutral'>     * _Available since v4.7._</span>
  756 |     | <span class='neutral'>     */</span>
  757 |     | <span class='neutral'>    function toInt168(int256 value) internal pure returns (int168 downcasted) {</span>
  758 |     | <span class='neutral'>        downcasted = int168(value);</span>
  759 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 168 bits&quot;);</span>
  760 |     | <span class='neutral'>    }</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>    /**</span>
  763 |     | <span class='neutral'>     * @dev Returns the downcasted int160 from int256, reverting on</span>
  764 |     | <span class='neutral'>     * overflow (when the input is less than smallest int160 or</span>
  765 |     | <span class='neutral'>     * greater than largest int160).</span>
  766 |     | <span class='neutral'>     *</span>
  767 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int160` operator.</span>
  768 |     | <span class='neutral'>     *</span>
  769 |     | <span class='neutral'>     * Requirements:</span>
  770 |     | <span class='neutral'>     *</span>
  771 |     | <span class='neutral'>     * - input must fit into 160 bits</span>
  772 |     | <span class='neutral'>     *</span>
  773 |     | <span class='neutral'>     * _Available since v4.7._</span>
  774 |     | <span class='neutral'>     */</span>
  775 |     | <span class='neutral'>    function toInt160(int256 value) internal pure returns (int160 downcasted) {</span>
  776 |     | <span class='neutral'>        downcasted = int160(value);</span>
  777 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 160 bits&quot;);</span>
  778 |     | <span class='neutral'>    }</span>
  779 |     | <span class='neutral'></span>
  780 |     | <span class='neutral'>    /**</span>
  781 |     | <span class='neutral'>     * @dev Returns the downcasted int152 from int256, reverting on</span>
  782 |     | <span class='neutral'>     * overflow (when the input is less than smallest int152 or</span>
  783 |     | <span class='neutral'>     * greater than largest int152).</span>
  784 |     | <span class='neutral'>     *</span>
  785 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int152` operator.</span>
  786 |     | <span class='neutral'>     *</span>
  787 |     | <span class='neutral'>     * Requirements:</span>
  788 |     | <span class='neutral'>     *</span>
  789 |     | <span class='neutral'>     * - input must fit into 152 bits</span>
  790 |     | <span class='neutral'>     *</span>
  791 |     | <span class='neutral'>     * _Available since v4.7._</span>
  792 |     | <span class='neutral'>     */</span>
  793 |     | <span class='neutral'>    function toInt152(int256 value) internal pure returns (int152 downcasted) {</span>
  794 |     | <span class='neutral'>        downcasted = int152(value);</span>
  795 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 152 bits&quot;);</span>
  796 |     | <span class='neutral'>    }</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>    /**</span>
  799 |     | <span class='neutral'>     * @dev Returns the downcasted int144 from int256, reverting on</span>
  800 |     | <span class='neutral'>     * overflow (when the input is less than smallest int144 or</span>
  801 |     | <span class='neutral'>     * greater than largest int144).</span>
  802 |     | <span class='neutral'>     *</span>
  803 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int144` operator.</span>
  804 |     | <span class='neutral'>     *</span>
  805 |     | <span class='neutral'>     * Requirements:</span>
  806 |     | <span class='neutral'>     *</span>
  807 |     | <span class='neutral'>     * - input must fit into 144 bits</span>
  808 |     | <span class='neutral'>     *</span>
  809 |     | <span class='neutral'>     * _Available since v4.7._</span>
  810 |     | <span class='neutral'>     */</span>
  811 |     | <span class='neutral'>    function toInt144(int256 value) internal pure returns (int144 downcasted) {</span>
  812 |     | <span class='neutral'>        downcasted = int144(value);</span>
  813 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 144 bits&quot;);</span>
  814 |     | <span class='neutral'>    }</span>
  815 |     | <span class='neutral'></span>
  816 |     | <span class='neutral'>    /**</span>
  817 |     | <span class='neutral'>     * @dev Returns the downcasted int136 from int256, reverting on</span>
  818 |     | <span class='neutral'>     * overflow (when the input is less than smallest int136 or</span>
  819 |     | <span class='neutral'>     * greater than largest int136).</span>
  820 |     | <span class='neutral'>     *</span>
  821 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int136` operator.</span>
  822 |     | <span class='neutral'>     *</span>
  823 |     | <span class='neutral'>     * Requirements:</span>
  824 |     | <span class='neutral'>     *</span>
  825 |     | <span class='neutral'>     * - input must fit into 136 bits</span>
  826 |     | <span class='neutral'>     *</span>
  827 |     | <span class='neutral'>     * _Available since v4.7._</span>
  828 |     | <span class='neutral'>     */</span>
  829 |     | <span class='neutral'>    function toInt136(int256 value) internal pure returns (int136 downcasted) {</span>
  830 |     | <span class='neutral'>        downcasted = int136(value);</span>
  831 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 136 bits&quot;);</span>
  832 |     | <span class='neutral'>    }</span>
  833 |     | <span class='neutral'></span>
  834 |     | <span class='neutral'>    /**</span>
  835 |     | <span class='neutral'>     * @dev Returns the downcasted int128 from int256, reverting on</span>
  836 |     | <span class='neutral'>     * overflow (when the input is less than smallest int128 or</span>
  837 |     | <span class='neutral'>     * greater than largest int128).</span>
  838 |     | <span class='neutral'>     *</span>
  839 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int128` operator.</span>
  840 |     | <span class='neutral'>     *</span>
  841 |     | <span class='neutral'>     * Requirements:</span>
  842 |     | <span class='neutral'>     *</span>
  843 |     | <span class='neutral'>     * - input must fit into 128 bits</span>
  844 |     | <span class='neutral'>     *</span>
  845 |     | <span class='neutral'>     * _Available since v3.1._</span>
  846 |     | <span class='neutral'>     */</span>
  847 |     | <span class='neutral'>    function toInt128(int256 value) internal pure returns (int128 downcasted) {</span>
  848 |     | <span class='neutral'>        downcasted = int128(value);</span>
  849 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 128 bits&quot;);</span>
  850 |     | <span class='neutral'>    }</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>    /**</span>
  853 |     | <span class='neutral'>     * @dev Returns the downcasted int120 from int256, reverting on</span>
  854 |     | <span class='neutral'>     * overflow (when the input is less than smallest int120 or</span>
  855 |     | <span class='neutral'>     * greater than largest int120).</span>
  856 |     | <span class='neutral'>     *</span>
  857 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int120` operator.</span>
  858 |     | <span class='neutral'>     *</span>
  859 |     | <span class='neutral'>     * Requirements:</span>
  860 |     | <span class='neutral'>     *</span>
  861 |     | <span class='neutral'>     * - input must fit into 120 bits</span>
  862 |     | <span class='neutral'>     *</span>
  863 |     | <span class='neutral'>     * _Available since v4.7._</span>
  864 |     | <span class='neutral'>     */</span>
  865 |     | <span class='neutral'>    function toInt120(int256 value) internal pure returns (int120 downcasted) {</span>
  866 |     | <span class='neutral'>        downcasted = int120(value);</span>
  867 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 120 bits&quot;);</span>
  868 |     | <span class='neutral'>    }</span>
  869 |     | <span class='neutral'></span>
  870 |     | <span class='neutral'>    /**</span>
  871 |     | <span class='neutral'>     * @dev Returns the downcasted int112 from int256, reverting on</span>
  872 |     | <span class='neutral'>     * overflow (when the input is less than smallest int112 or</span>
  873 |     | <span class='neutral'>     * greater than largest int112).</span>
  874 |     | <span class='neutral'>     *</span>
  875 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int112` operator.</span>
  876 |     | <span class='neutral'>     *</span>
  877 |     | <span class='neutral'>     * Requirements:</span>
  878 |     | <span class='neutral'>     *</span>
  879 |     | <span class='neutral'>     * - input must fit into 112 bits</span>
  880 |     | <span class='neutral'>     *</span>
  881 |     | <span class='neutral'>     * _Available since v4.7._</span>
  882 |     | <span class='neutral'>     */</span>
  883 |     | <span class='neutral'>    function toInt112(int256 value) internal pure returns (int112 downcasted) {</span>
  884 |     | <span class='neutral'>        downcasted = int112(value);</span>
  885 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 112 bits&quot;);</span>
  886 |     | <span class='neutral'>    }</span>
  887 |     | <span class='neutral'></span>
  888 |     | <span class='neutral'>    /**</span>
  889 |     | <span class='neutral'>     * @dev Returns the downcasted int104 from int256, reverting on</span>
  890 |     | <span class='neutral'>     * overflow (when the input is less than smallest int104 or</span>
  891 |     | <span class='neutral'>     * greater than largest int104).</span>
  892 |     | <span class='neutral'>     *</span>
  893 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int104` operator.</span>
  894 |     | <span class='neutral'>     *</span>
  895 |     | <span class='neutral'>     * Requirements:</span>
  896 |     | <span class='neutral'>     *</span>
  897 |     | <span class='neutral'>     * - input must fit into 104 bits</span>
  898 |     | <span class='neutral'>     *</span>
  899 |     | <span class='neutral'>     * _Available since v4.7._</span>
  900 |     | <span class='neutral'>     */</span>
  901 |     | <span class='neutral'>    function toInt104(int256 value) internal pure returns (int104 downcasted) {</span>
  902 |     | <span class='neutral'>        downcasted = int104(value);</span>
  903 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 104 bits&quot;);</span>
  904 |     | <span class='neutral'>    }</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>    /**</span>
  907 |     | <span class='neutral'>     * @dev Returns the downcasted int96 from int256, reverting on</span>
  908 |     | <span class='neutral'>     * overflow (when the input is less than smallest int96 or</span>
  909 |     | <span class='neutral'>     * greater than largest int96).</span>
  910 |     | <span class='neutral'>     *</span>
  911 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int96` operator.</span>
  912 |     | <span class='neutral'>     *</span>
  913 |     | <span class='neutral'>     * Requirements:</span>
  914 |     | <span class='neutral'>     *</span>
  915 |     | <span class='neutral'>     * - input must fit into 96 bits</span>
  916 |     | <span class='neutral'>     *</span>
  917 |     | <span class='neutral'>     * _Available since v4.7._</span>
  918 |     | <span class='neutral'>     */</span>
  919 |     | <span class='neutral'>    function toInt96(int256 value) internal pure returns (int96 downcasted) {</span>
  920 |     | <span class='neutral'>        downcasted = int96(value);</span>
  921 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 96 bits&quot;);</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    /**</span>
  925 |     | <span class='neutral'>     * @dev Returns the downcasted int88 from int256, reverting on</span>
  926 |     | <span class='neutral'>     * overflow (when the input is less than smallest int88 or</span>
  927 |     | <span class='neutral'>     * greater than largest int88).</span>
  928 |     | <span class='neutral'>     *</span>
  929 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int88` operator.</span>
  930 |     | <span class='neutral'>     *</span>
  931 |     | <span class='neutral'>     * Requirements:</span>
  932 |     | <span class='neutral'>     *</span>
  933 |     | <span class='neutral'>     * - input must fit into 88 bits</span>
  934 |     | <span class='neutral'>     *</span>
  935 |     | <span class='neutral'>     * _Available since v4.7._</span>
  936 |     | <span class='neutral'>     */</span>
  937 |     | <span class='neutral'>    function toInt88(int256 value) internal pure returns (int88 downcasted) {</span>
  938 |     | <span class='neutral'>        downcasted = int88(value);</span>
  939 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 88 bits&quot;);</span>
  940 |     | <span class='neutral'>    }</span>
  941 |     | <span class='neutral'></span>
  942 |     | <span class='neutral'>    /**</span>
  943 |     | <span class='neutral'>     * @dev Returns the downcasted int80 from int256, reverting on</span>
  944 |     | <span class='neutral'>     * overflow (when the input is less than smallest int80 or</span>
  945 |     | <span class='neutral'>     * greater than largest int80).</span>
  946 |     | <span class='neutral'>     *</span>
  947 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int80` operator.</span>
  948 |     | <span class='neutral'>     *</span>
  949 |     | <span class='neutral'>     * Requirements:</span>
  950 |     | <span class='neutral'>     *</span>
  951 |     | <span class='neutral'>     * - input must fit into 80 bits</span>
  952 |     | <span class='neutral'>     *</span>
  953 |     | <span class='neutral'>     * _Available since v4.7._</span>
  954 |     | <span class='neutral'>     */</span>
  955 |     | <span class='neutral'>    function toInt80(int256 value) internal pure returns (int80 downcasted) {</span>
  956 |     | <span class='neutral'>        downcasted = int80(value);</span>
  957 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 80 bits&quot;);</span>
  958 |     | <span class='neutral'>    }</span>
  959 |     | <span class='neutral'></span>
  960 |     | <span class='neutral'>    /**</span>
  961 |     | <span class='neutral'>     * @dev Returns the downcasted int72 from int256, reverting on</span>
  962 |     | <span class='neutral'>     * overflow (when the input is less than smallest int72 or</span>
  963 |     | <span class='neutral'>     * greater than largest int72).</span>
  964 |     | <span class='neutral'>     *</span>
  965 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int72` operator.</span>
  966 |     | <span class='neutral'>     *</span>
  967 |     | <span class='neutral'>     * Requirements:</span>
  968 |     | <span class='neutral'>     *</span>
  969 |     | <span class='neutral'>     * - input must fit into 72 bits</span>
  970 |     | <span class='neutral'>     *</span>
  971 |     | <span class='neutral'>     * _Available since v4.7._</span>
  972 |     | <span class='neutral'>     */</span>
  973 |     | <span class='neutral'>    function toInt72(int256 value) internal pure returns (int72 downcasted) {</span>
  974 |     | <span class='neutral'>        downcasted = int72(value);</span>
  975 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 72 bits&quot;);</span>
  976 |     | <span class='neutral'>    }</span>
  977 |     | <span class='neutral'></span>
  978 |     | <span class='neutral'>    /**</span>
  979 |     | <span class='neutral'>     * @dev Returns the downcasted int64 from int256, reverting on</span>
  980 |     | <span class='neutral'>     * overflow (when the input is less than smallest int64 or</span>
  981 |     | <span class='neutral'>     * greater than largest int64).</span>
  982 |     | <span class='neutral'>     *</span>
  983 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int64` operator.</span>
  984 |     | <span class='neutral'>     *</span>
  985 |     | <span class='neutral'>     * Requirements:</span>
  986 |     | <span class='neutral'>     *</span>
  987 |     | <span class='neutral'>     * - input must fit into 64 bits</span>
  988 |     | <span class='neutral'>     *</span>
  989 |     | <span class='neutral'>     * _Available since v3.1._</span>
  990 |     | <span class='neutral'>     */</span>
  991 |     | <span class='neutral'>    function toInt64(int256 value) internal pure returns (int64 downcasted) {</span>
  992 |     | <span class='neutral'>        downcasted = int64(value);</span>
  993 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 64 bits&quot;);</span>
  994 |     | <span class='neutral'>    }</span>
  995 |     | <span class='neutral'></span>
  996 |     | <span class='neutral'>    /**</span>
  997 |     | <span class='neutral'>     * @dev Returns the downcasted int56 from int256, reverting on</span>
  998 |     | <span class='neutral'>     * overflow (when the input is less than smallest int56 or</span>
  999 |     | <span class='neutral'>     * greater than largest int56).</span>
 1000 |     | <span class='neutral'>     *</span>
 1001 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int56` operator.</span>
 1002 |     | <span class='neutral'>     *</span>
 1003 |     | <span class='neutral'>     * Requirements:</span>
 1004 |     | <span class='neutral'>     *</span>
 1005 |     | <span class='neutral'>     * - input must fit into 56 bits</span>
 1006 |     | <span class='neutral'>     *</span>
 1007 |     | <span class='neutral'>     * _Available since v4.7._</span>
 1008 |     | <span class='neutral'>     */</span>
 1009 |     | <span class='neutral'>    function toInt56(int256 value) internal pure returns (int56 downcasted) {</span>
 1010 |     | <span class='neutral'>        downcasted = int56(value);</span>
 1011 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 56 bits&quot;);</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    /**</span>
 1015 |     | <span class='neutral'>     * @dev Returns the downcasted int48 from int256, reverting on</span>
 1016 |     | <span class='neutral'>     * overflow (when the input is less than smallest int48 or</span>
 1017 |     | <span class='neutral'>     * greater than largest int48).</span>
 1018 |     | <span class='neutral'>     *</span>
 1019 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int48` operator.</span>
 1020 |     | <span class='neutral'>     *</span>
 1021 |     | <span class='neutral'>     * Requirements:</span>
 1022 |     | <span class='neutral'>     *</span>
 1023 |     | <span class='neutral'>     * - input must fit into 48 bits</span>
 1024 |     | <span class='neutral'>     *</span>
 1025 |     | <span class='neutral'>     * _Available since v4.7._</span>
 1026 |     | <span class='neutral'>     */</span>
 1027 |     | <span class='neutral'>    function toInt48(int256 value) internal pure returns (int48 downcasted) {</span>
 1028 |     | <span class='neutral'>        downcasted = int48(value);</span>
 1029 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 48 bits&quot;);</span>
 1030 |     | <span class='neutral'>    }</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>    /**</span>
 1033 |     | <span class='neutral'>     * @dev Returns the downcasted int40 from int256, reverting on</span>
 1034 |     | <span class='neutral'>     * overflow (when the input is less than smallest int40 or</span>
 1035 |     | <span class='neutral'>     * greater than largest int40).</span>
 1036 |     | <span class='neutral'>     *</span>
 1037 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int40` operator.</span>
 1038 |     | <span class='neutral'>     *</span>
 1039 |     | <span class='neutral'>     * Requirements:</span>
 1040 |     | <span class='neutral'>     *</span>
 1041 |     | <span class='neutral'>     * - input must fit into 40 bits</span>
 1042 |     | <span class='neutral'>     *</span>
 1043 |     | <span class='neutral'>     * _Available since v4.7._</span>
 1044 |     | <span class='neutral'>     */</span>
 1045 |     | <span class='neutral'>    function toInt40(int256 value) internal pure returns (int40 downcasted) {</span>
 1046 |     | <span class='neutral'>        downcasted = int40(value);</span>
 1047 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 40 bits&quot;);</span>
 1048 |     | <span class='neutral'>    }</span>
 1049 |     | <span class='neutral'></span>
 1050 |     | <span class='neutral'>    /**</span>
 1051 |     | <span class='neutral'>     * @dev Returns the downcasted int32 from int256, reverting on</span>
 1052 |     | <span class='neutral'>     * overflow (when the input is less than smallest int32 or</span>
 1053 |     | <span class='neutral'>     * greater than largest int32).</span>
 1054 |     | <span class='neutral'>     *</span>
 1055 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int32` operator.</span>
 1056 |     | <span class='neutral'>     *</span>
 1057 |     | <span class='neutral'>     * Requirements:</span>
 1058 |     | <span class='neutral'>     *</span>
 1059 |     | <span class='neutral'>     * - input must fit into 32 bits</span>
 1060 |     | <span class='neutral'>     *</span>
 1061 |     | <span class='neutral'>     * _Available since v3.1._</span>
 1062 |     | <span class='neutral'>     */</span>
 1063 |     | <span class='neutral'>    function toInt32(int256 value) internal pure returns (int32 downcasted) {</span>
 1064 |     | <span class='neutral'>        downcasted = int32(value);</span>
 1065 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 32 bits&quot;);</span>
 1066 |     | <span class='neutral'>    }</span>
 1067 |     | <span class='neutral'></span>
 1068 |     | <span class='neutral'>    /**</span>
 1069 |     | <span class='neutral'>     * @dev Returns the downcasted int24 from int256, reverting on</span>
 1070 |     | <span class='neutral'>     * overflow (when the input is less than smallest int24 or</span>
 1071 |     | <span class='neutral'>     * greater than largest int24).</span>
 1072 |     | <span class='neutral'>     *</span>
 1073 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int24` operator.</span>
 1074 |     | <span class='neutral'>     *</span>
 1075 |     | <span class='neutral'>     * Requirements:</span>
 1076 |     | <span class='neutral'>     *</span>
 1077 |     | <span class='neutral'>     * - input must fit into 24 bits</span>
 1078 |     | <span class='neutral'>     *</span>
 1079 |     | <span class='neutral'>     * _Available since v4.7._</span>
 1080 |     | <span class='neutral'>     */</span>
 1081 |     | <span class='neutral'>    function toInt24(int256 value) internal pure returns (int24 downcasted) {</span>
 1082 |     | <span class='neutral'>        downcasted = int24(value);</span>
 1083 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 24 bits&quot;);</span>
 1084 |     | <span class='neutral'>    }</span>
 1085 |     | <span class='neutral'></span>
 1086 |     | <span class='neutral'>    /**</span>
 1087 |     | <span class='neutral'>     * @dev Returns the downcasted int16 from int256, reverting on</span>
 1088 |     | <span class='neutral'>     * overflow (when the input is less than smallest int16 or</span>
 1089 |     | <span class='neutral'>     * greater than largest int16).</span>
 1090 |     | <span class='neutral'>     *</span>
 1091 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int16` operator.</span>
 1092 |     | <span class='neutral'>     *</span>
 1093 |     | <span class='neutral'>     * Requirements:</span>
 1094 |     | <span class='neutral'>     *</span>
 1095 |     | <span class='neutral'>     * - input must fit into 16 bits</span>
 1096 |     | <span class='neutral'>     *</span>
 1097 |     | <span class='neutral'>     * _Available since v3.1._</span>
 1098 |     | <span class='neutral'>     */</span>
 1099 |     | <span class='neutral'>    function toInt16(int256 value) internal pure returns (int16 downcasted) {</span>
 1100 |     | <span class='neutral'>        downcasted = int16(value);</span>
 1101 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 16 bits&quot;);</span>
 1102 |     | <span class='neutral'>    }</span>
 1103 |     | <span class='neutral'></span>
 1104 |     | <span class='neutral'>    /**</span>
 1105 |     | <span class='neutral'>     * @dev Returns the downcasted int8 from int256, reverting on</span>
 1106 |     | <span class='neutral'>     * overflow (when the input is less than smallest int8 or</span>
 1107 |     | <span class='neutral'>     * greater than largest int8).</span>
 1108 |     | <span class='neutral'>     *</span>
 1109 |     | <span class='neutral'>     * Counterpart to Solidity&#39;s `int8` operator.</span>
 1110 |     | <span class='neutral'>     *</span>
 1111 |     | <span class='neutral'>     * Requirements:</span>
 1112 |     | <span class='neutral'>     *</span>
 1113 |     | <span class='neutral'>     * - input must fit into 8 bits</span>
 1114 |     | <span class='neutral'>     *</span>
 1115 |     | <span class='neutral'>     * _Available since v3.1._</span>
 1116 |     | <span class='neutral'>     */</span>
 1117 |     | <span class='neutral'>    function toInt8(int256 value) internal pure returns (int8 downcasted) {</span>
 1118 |     | <span class='neutral'>        downcasted = int8(value);</span>
 1119 |     | <span class='neutral'>        require(downcasted == value, &quot;SafeCast: value doesn&#39;t fit in 8 bits&quot;);</span>
 1120 |     | <span class='neutral'>    }</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>    /**</span>
 1123 |     | <span class='neutral'>     * @dev Converts an unsigned uint256 into a signed int256.</span>
 1124 |     | <span class='neutral'>     *</span>
 1125 |     | <span class='neutral'>     * Requirements:</span>
 1126 |     | <span class='neutral'>     *</span>
 1127 |     | <span class='neutral'>     * - input must be less than or equal to maxInt256.</span>
 1128 |     | <span class='neutral'>     *</span>
 1129 |     | <span class='neutral'>     * _Available since v3.0._</span>
 1130 |     | <span class='neutral'>     */</span>
 1131 |     | <span class='unexecuted'>    function toInt256(uint256 value) internal pure returns (int256) {</span>
 1132 |     | <span class='neutral'>        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive</span>
 1133 |     | <span class='unexecuted'>        require(value &lt;= uint256(type(int256).max), &quot;SafeCast: value doesn&#39;t fit in an int256&quot;);</span>
 1134 |     | <span class='neutral'>        return int256(value);</span>
 1135 |     | <span class='neutral'>    }</span>
 1136 |     | <span class='neutral'>}</span>
 1137 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@openzeppelin/contracts/utils/math/SignedMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/**</span>
  7 |     | <span class='neutral'> * @dev Standard signed math utilities missing in the Solidity language.</span>
  8 |     | <span class='neutral'> */</span>
  9 |     | <span class='unexecuted'>library SignedMath {</span>
 10 |     | <span class='neutral'>    /**</span>
 11 |     | <span class='neutral'>     * @dev Returns the largest of two signed numbers.</span>
 12 |     | <span class='neutral'>     */</span>
 13 |     | <span class='neutral'>    function max(int256 a, int256 b) internal pure returns (int256) {</span>
 14 |     | <span class='neutral'>        return a &gt; b ? a : b;</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /**</span>
 18 |     | <span class='neutral'>     * @dev Returns the smallest of two signed numbers.</span>
 19 |     | <span class='neutral'>     */</span>
 20 |     | <span class='neutral'>    function min(int256 a, int256 b) internal pure returns (int256) {</span>
 21 |     | <span class='neutral'>        return a &lt; b ? a : b;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /**</span>
 25 |     | <span class='neutral'>     * @dev Returns the average of two signed numbers without overflow.</span>
 26 |     | <span class='neutral'>     * The result is rounded towards zero.</span>
 27 |     | <span class='neutral'>     */</span>
 28 |     | <span class='neutral'>    function average(int256 a, int256 b) internal pure returns (int256) {</span>
 29 |     | <span class='neutral'>        // Formula from the book &quot;Hacker&#39;s Delight&quot;</span>
 30 |     | <span class='neutral'>        int256 x = (a &amp; b) + ((a ^ b) &gt;&gt; 1);</span>
 31 |     | <span class='neutral'>        return x + (int256(uint256(x) &gt;&gt; 255) &amp; (a ^ b));</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /**</span>
 35 |     | <span class='neutral'>     * @dev Returns the absolute unsigned value of a signed value.</span>
 36 |     | <span class='neutral'>     */</span>
 37 |     | <span class='neutral'>    function abs(int256 n) internal pure returns (uint256) {</span>
 38 |     | <span class='neutral'>        unchecked {</span>
 39 |     | <span class='neutral'>            // must be unchecked in order to support `n = type(int256).min`</span>
 40 |     | <span class='neutral'>            return uint256(n &gt;= 0 ? n : -n);</span>
 41 |     | <span class='neutral'>        }</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@rari-capital/solmate/src/utils/SSTORE2.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: AGPL-3.0-only</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @notice Read and write to persistent storage at a fraction of the cost.</span>
   5 |     | <span class='neutral'>/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/SSTORE2.sol)</span>
   6 |     | <span class='neutral'>/// @author Modified from 0xSequence (https://github.com/0xSequence/sstore2/blob/master/contracts/SSTORE2.sol)</span>
   7 |     | <span class='unexecuted'>library SSTORE2 {</span>
   8 |     | <span class='unexecuted'>    uint256 internal constant DATA_OFFSET = 1; // We skip the first byte as it&#39;s a STOP opcode to ensure the contract can&#39;t be called.</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
  11 |     | <span class='neutral'>                               WRITE LOGIC</span>
  12 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  13 |     | <span class='neutral'></span>
  14 |     | <span class='unexecuted'>    function write(bytes memory data) internal returns (address pointer) {</span>
  15 |     | <span class='neutral'>        // Prefix the bytecode with a STOP opcode to ensure it cannot be called.</span>
  16 |     | <span class='unexecuted'>        bytes memory runtimeCode = abi.encodePacked(hex&quot;00&quot;, data);</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>        bytes memory creationCode = abi.encodePacked(</span>
  19 |     | <span class='neutral'>            //---------------------------------------------------------------------------------------------------------------//</span>
  20 |     | <span class='neutral'>            // Opcode  | Opcode + Arguments  | Description  | Stack View                                                     //</span>
  21 |     | <span class='neutral'>            //---------------------------------------------------------------------------------------------------------------//</span>
  22 |     | <span class='neutral'>            // 0x60    |  0x600B             | PUSH1 11     | codeOffset                                                     //</span>
  23 |     | <span class='neutral'>            // 0x59    |  0x59               | MSIZE        | 0 codeOffset                                                   //</span>
  24 |     | <span class='neutral'>            // 0x81    |  0x81               | DUP2         | codeOffset 0 codeOffset                                        //</span>
  25 |     | <span class='neutral'>            // 0x38    |  0x38               | CODESIZE     | codeSize codeOffset 0 codeOffset                               //</span>
  26 |     | <span class='neutral'>            // 0x03    |  0x03               | SUB          | (codeSize - codeOffset) 0 codeOffset                           //</span>
  27 |     | <span class='neutral'>            // 0x80    |  0x80               | DUP          | (codeSize - codeOffset) (codeSize - codeOffset) 0 codeOffset   //</span>
  28 |     | <span class='neutral'>            // 0x92    |  0x92               | SWAP3        | codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset)   //</span>
  29 |     | <span class='neutral'>            // 0x59    |  0x59               | MSIZE        | 0 codeOffset (codeSize - codeOffset) 0 (codeSize - codeOffset) //</span>
  30 |     | <span class='neutral'>            // 0x39    |  0x39               | CODECOPY     | 0 (codeSize - codeOffset)                                      //</span>
  31 |     | <span class='neutral'>            // 0xf3    |  0xf3               | RETURN       |                                                                //</span>
  32 |     | <span class='neutral'>            //---------------------------------------------------------------------------------------------------------------//</span>
  33 |     | <span class='neutral'>            hex&quot;60_0B_59_81_38_03_80_92_59_39_F3&quot;, // Returns all code in the contract except for the first 11 (0B in hex) bytes.</span>
  34 |     | <span class='unexecuted'>            runtimeCode // The bytecode we want the contract to have after deployment. Capped at 1 byte less than the code size limit.</span>
  35 |     | <span class='neutral'>        );</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>        assembly {</span>
  38 |     | <span class='neutral'>            // Deploy a new contract with the generated creation code.</span>
  39 |     | <span class='neutral'>            // We start 32 bytes into the code to avoid copying the byte length.</span>
  40 |     | <span class='unexecuted'>            pointer := create(0, add(creationCode, 32), mload(creationCode))</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='unexecuted'>        require(pointer != address(0), &quot;DEPLOYMENT_FAILED&quot;);</span>
  44 |     | <span class='neutral'>    }</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
  47 |     | <span class='neutral'>                               READ LOGIC</span>
  48 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='unexecuted'>    function read(address pointer) internal view returns (bytes memory) {</span>
  51 |     | <span class='unexecuted'>        return readBytecode(pointer, DATA_OFFSET, pointer.code.length - DATA_OFFSET);</span>
  52 |     | <span class='neutral'>    }</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>    function read(address pointer, uint256 start) internal view returns (bytes memory) {</span>
  55 |     | <span class='neutral'>        start += DATA_OFFSET;</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>        return readBytecode(pointer, start, pointer.code.length - start);</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function read(</span>
  61 |     | <span class='neutral'>        address pointer,</span>
  62 |     | <span class='neutral'>        uint256 start,</span>
  63 |     | <span class='neutral'>        uint256 end</span>
  64 |     | <span class='neutral'>    ) internal view returns (bytes memory) {</span>
  65 |     | <span class='neutral'>        start += DATA_OFFSET;</span>
  66 |     | <span class='neutral'>        end += DATA_OFFSET;</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>        require(pointer.code.length &gt;= end, &quot;OUT_OF_BOUNDS&quot;);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>        return readBytecode(pointer, start, end - start);</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
  74 |     | <span class='neutral'>                         INTERNAL HELPER LOGIC</span>
  75 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='unexecuted'>    function readBytecode(</span>
  78 |     | <span class='neutral'>        address pointer,</span>
  79 |     | <span class='neutral'>        uint256 start,</span>
  80 |     | <span class='neutral'>        uint256 size</span>
  81 |     | <span class='neutral'>    ) private view returns (bytes memory data) {</span>
  82 |     | <span class='neutral'>        assembly {</span>
  83 |     | <span class='neutral'>            // Get a pointer to some free memory.</span>
  84 |     | <span class='unexecuted'>            data := mload(0x40)</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>            // Update the free memory pointer to prevent overriding our data.</span>
  87 |     | <span class='neutral'>            // We use and(x, not(31)) as a cheaper equivalent to sub(x, mod(x, 32)).</span>
  88 |     | <span class='neutral'>            // Adding 31 to size and running the result through the logic above ensures</span>
  89 |     | <span class='neutral'>            // the memory pointer remains word-aligned, following the Solidity convention.</span>
  90 |     | <span class='unexecuted'>            mstore(0x40, add(data, and(add(add(size, 32), 31), not(31))))</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>            // Store the size of the data in the first 32 byte chunk of free memory.</span>
  93 |     | <span class='unexecuted'>            mstore(data, size)</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='neutral'>            // Copy the code into memory right after the 32 bytes we used to store the size.</span>
  96 |     | <span class='unexecuted'>            extcodecopy(pointer, add(data, 32), start, size)</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Pair {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
  9 |     | <span class='neutral'>    function decimals() external pure returns (uint8);</span>
 10 |     | <span class='neutral'>    function totalSupply() external view returns (uint);</span>
 11 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint);</span>
 12 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function approve(address spender, uint value) external returns (bool);</span>
 15 |     | <span class='neutral'>    function transfer(address to, uint value) external returns (bool);</span>
 16 |     | <span class='neutral'>    function transferFrom(address from, address to, uint value) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 19 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 20 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    event Mint(address indexed sender, uint amount0, uint amount1);</span>
 25 |     | <span class='neutral'>    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);</span>
 26 |     | <span class='neutral'>    event Swap(</span>
 27 |     | <span class='neutral'>        address indexed sender,</span>
 28 |     | <span class='neutral'>        uint amount0In,</span>
 29 |     | <span class='neutral'>        uint amount1In,</span>
 30 |     | <span class='neutral'>        uint amount0Out,</span>
 31 |     | <span class='neutral'>        uint amount1Out,</span>
 32 |     | <span class='neutral'>        address indexed to</span>
 33 |     | <span class='neutral'>    );</span>
 34 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function MINIMUM_LIQUIDITY() external pure returns (uint);</span>
 37 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 38 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 39 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 40 |     | <span class='neutral'>    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
 41 |     | <span class='neutral'>    function price0CumulativeLast() external view returns (uint);</span>
 42 |     | <span class='neutral'>    function price1CumulativeLast() external view returns (uint);</span>
 43 |     | <span class='neutral'>    function kLast() external view returns (uint);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    function mint(address to) external returns (uint liquidity);</span>
 46 |     | <span class='neutral'>    function burn(address to) external returns (uint amount0, uint amount1);</span>
 47 |     | <span class='neutral'>    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;</span>
 48 |     | <span class='neutral'>    function skim(address to) external;</span>
 49 |     | <span class='neutral'>    function sync() external;</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='neutral'>    function initialize(address, address) external;</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#swap</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3SwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 11 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by</span>
 12 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.</span>
 13 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by</span>
 14 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.</span>
 15 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 16 |     | <span class='neutral'>    function uniswapV3SwapCallback(</span>
 17 |     | <span class='neutral'>        int256 amount0Delta,</span>
 18 |     | <span class='neutral'>        int256 amount1Delta,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-core/contracts/libraries/FixedPoint96.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.4.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint96</span>
  5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='neutral'>/// @dev Used in SqrtPriceMath.sol</span>
  7 |     | <span class='unexecuted'>library FixedPoint96 {</span>
  8 |     | <span class='neutral'>    uint8 internal constant RESOLUTION = 96;</span>
  9 |     | <span class='unexecuted'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
 10 |     | <span class='neutral'>}</span>
 11 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.5.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Immutable state</span>
  5 |     | <span class='neutral'>/// @notice Functions that return immutable state of the router</span>
  6 |     | <span class='neutral'>interface IPeripheryImmutableState {</span>
  7 |     | <span class='neutral'>    /// @return Returns the address of the Uniswap V3 factory</span>
  8 |     | <span class='neutral'>    function factory() external view returns (address);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @return Returns the address of WETH9</span>
 11 |     | <span class='neutral'>    function WETH9() external view returns (address);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.7.5;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Router token swapping functionality</span>
  8 |     | <span class='neutral'>/// @notice Functions for swapping tokens via Uniswap V3</span>
  9 |     | <span class='neutral'>interface ISwapRouter is IUniswapV3SwapCallback {</span>
 10 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
 11 |     | <span class='neutral'>        address tokenIn;</span>
 12 |     | <span class='neutral'>        address tokenOut;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>        address recipient;</span>
 15 |     | <span class='neutral'>        uint256 deadline;</span>
 16 |     | <span class='neutral'>        uint256 amountIn;</span>
 17 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 18 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 22 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 23 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 24 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    struct ExactInputParams {</span>
 27 |     | <span class='neutral'>        bytes path;</span>
 28 |     | <span class='neutral'>        address recipient;</span>
 29 |     | <span class='neutral'>        uint256 deadline;</span>
 30 |     | <span class='neutral'>        uint256 amountIn;</span>
 31 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path</span>
 35 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata</span>
 36 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 37 |     | <span class='neutral'>    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 40 |     | <span class='neutral'>        address tokenIn;</span>
 41 |     | <span class='neutral'>        address tokenOut;</span>
 42 |     | <span class='neutral'>        uint24 fee;</span>
 43 |     | <span class='neutral'>        address recipient;</span>
 44 |     | <span class='neutral'>        uint256 deadline;</span>
 45 |     | <span class='neutral'>        uint256 amountOut;</span>
 46 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 47 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 51 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 52 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 53 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='neutral'>    struct ExactOutputParams {</span>
 56 |     | <span class='neutral'>        bytes path;</span>
 57 |     | <span class='neutral'>        address recipient;</span>
 58 |     | <span class='neutral'>        uint256 deadline;</span>
 59 |     | <span class='neutral'>        uint256 amountOut;</span>
 60 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 61 |     | <span class='neutral'>    }</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)</span>
 64 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata</span>
 65 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 66 |     | <span class='neutral'>    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/erc721a/contracts/ERC721A.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
    2 |     | <span class='neutral'>// ERC721A Contracts v4.3.0</span>
    3 |     | <span class='neutral'>// Creator: Chiru Labs</span>
    4 |     | <span class='neutral'></span>
    5 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
    6 |     | <span class='neutral'></span>
    7 |     | <span class='neutral'>import &#39;./IERC721A.sol&#39;;</span>
    8 |     | <span class='neutral'></span>
    9 |     | <span class='neutral'>/**</span>
   10 |     | <span class='neutral'> * @dev Interface of ERC721 token receiver.</span>
   11 |     | <span class='neutral'> */</span>
   12 |     | <span class='neutral'>interface ERC721A__IERC721Receiver {</span>
   13 |     | <span class='neutral'>    function onERC721Received(</span>
   14 |     | <span class='neutral'>        address operator,</span>
   15 |     | <span class='neutral'>        address from,</span>
   16 |     | <span class='neutral'>        uint256 tokenId,</span>
   17 |     | <span class='neutral'>        bytes calldata data</span>
   18 |     | <span class='neutral'>    ) external returns (bytes4);</span>
   19 |     | <span class='neutral'>}</span>
   20 |     | <span class='neutral'></span>
   21 |     | <span class='neutral'>/**</span>
   22 |     | <span class='neutral'> * @title ERC721A</span>
   23 |     | <span class='neutral'> *</span>
   24 |     | <span class='neutral'> * @dev Implementation of the [ERC721](https://eips.ethereum.org/EIPS/eip-721)</span>
   25 |     | <span class='neutral'> * Non-Fungible Token Standard, including the Metadata extension.</span>
   26 |     | <span class='neutral'> * Optimized for lower gas during batch mints.</span>
   27 |     | <span class='neutral'> *</span>
   28 |     | <span class='neutral'> * Token IDs are minted in sequential order (e.g. 0, 1, 2, 3, ...)</span>
   29 |     | <span class='neutral'> * starting from `_startTokenId()`.</span>
   30 |     | <span class='neutral'> *</span>
   31 |     | <span class='neutral'> * The `_sequentialUpTo()` function can be overriden to enable spot mints</span>
   32 |     | <span class='neutral'> * (i.e. non-consecutive mints) for `tokenId`s greater than `_sequentialUpTo()`.</span>
   33 |     | <span class='neutral'> *</span>
   34 |     | <span class='neutral'> * Assumptions:</span>
   35 |     | <span class='neutral'> *</span>
   36 |     | <span class='neutral'> * - An owner cannot have more than 2**64 - 1 (max value of uint64) of supply.</span>
   37 |     | <span class='neutral'> * - The maximum token ID cannot exceed 2**256 - 1 (max value of uint256).</span>
   38 |     | <span class='neutral'> */</span>
   39 |     | <span class='unexecuted'>contract ERC721A is IERC721A {</span>
   40 |     | <span class='neutral'>    // Bypass for a `--via-ir` bug (https://github.com/chiru-labs/ERC721A/pull/364).</span>
   41 |     | <span class='neutral'>    struct TokenApprovalRef {</span>
   42 |     | <span class='neutral'>        address value;</span>
   43 |     | <span class='neutral'>    }</span>
   44 |     | <span class='neutral'></span>
   45 |     | <span class='neutral'>    // =============================================================</span>
   46 |     | <span class='neutral'>    //                           CONSTANTS</span>
   47 |     | <span class='neutral'>    // =============================================================</span>
   48 |     | <span class='neutral'></span>
   49 |     | <span class='neutral'>    // Mask of an entry in packed address data.</span>
   50 |     | <span class='unexecuted'>    uint256 private constant _BITMASK_ADDRESS_DATA_ENTRY = (1 &lt;&lt; 64) - 1;</span>
   51 |     | <span class='neutral'></span>
   52 |     | <span class='neutral'>    // The bit position of `numberMinted` in packed address data.</span>
   53 |     | <span class='neutral'>    uint256 private constant _BITPOS_NUMBER_MINTED = 64;</span>
   54 |     | <span class='neutral'></span>
   55 |     | <span class='neutral'>    // The bit position of `numberBurned` in packed address data.</span>
   56 |     | <span class='neutral'>    uint256 private constant _BITPOS_NUMBER_BURNED = 128;</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    // The bit position of `aux` in packed address data.</span>
   59 |     | <span class='neutral'>    uint256 private constant _BITPOS_AUX = 192;</span>
   60 |     | <span class='neutral'></span>
   61 |     | <span class='neutral'>    // Mask of all 256 bits in packed address data except the 64 bits for `aux`.</span>
   62 |     | <span class='neutral'>    uint256 private constant _BITMASK_AUX_COMPLEMENT = (1 &lt;&lt; 192) - 1;</span>
   63 |     | <span class='neutral'></span>
   64 |     | <span class='neutral'>    // The bit position of `startTimestamp` in packed ownership.</span>
   65 |     | <span class='neutral'>    uint256 private constant _BITPOS_START_TIMESTAMP = 160;</span>
   66 |     | <span class='neutral'></span>
   67 |     | <span class='neutral'>    // The bit mask of the `burned` bit in packed ownership.</span>
   68 |     | <span class='neutral'>    uint256 private constant _BITMASK_BURNED = 1 &lt;&lt; 224;</span>
   69 |     | <span class='neutral'></span>
   70 |     | <span class='neutral'>    // The bit position of the `nextInitialized` bit in packed ownership.</span>
   71 |     | <span class='neutral'>    uint256 private constant _BITPOS_NEXT_INITIALIZED = 225;</span>
   72 |     | <span class='neutral'></span>
   73 |     | <span class='neutral'>    // The bit mask of the `nextInitialized` bit in packed ownership.</span>
   74 |     | <span class='neutral'>    uint256 private constant _BITMASK_NEXT_INITIALIZED = 1 &lt;&lt; 225;</span>
   75 |     | <span class='neutral'></span>
   76 |     | <span class='neutral'>    // The bit position of `extraData` in packed ownership.</span>
   77 |     | <span class='neutral'>    uint256 private constant _BITPOS_EXTRA_DATA = 232;</span>
   78 |     | <span class='neutral'></span>
   79 |     | <span class='neutral'>    // Mask of all 256 bits in a packed ownership except the 24 bits for `extraData`.</span>
   80 |     | <span class='neutral'>    uint256 private constant _BITMASK_EXTRA_DATA_COMPLEMENT = (1 &lt;&lt; 232) - 1;</span>
   81 |     | <span class='neutral'></span>
   82 |     | <span class='neutral'>    // The mask of the lower 160 bits for addresses.</span>
   83 |     | <span class='neutral'>    uint256 private constant _BITMASK_ADDRESS = (1 &lt;&lt; 160) - 1;</span>
   84 |     | <span class='neutral'></span>
   85 |     | <span class='neutral'>    // The maximum `quantity` that can be minted with {_mintERC2309}.</span>
   86 |     | <span class='neutral'>    // This limit is to prevent overflows on the address data entries.</span>
   87 |     | <span class='neutral'>    // For a limit of 5000, a total of 3.689e15 calls to {_mintERC2309}</span>
   88 |     | <span class='neutral'>    // is required to cause an overflow, which is unrealistic.</span>
   89 |     | <span class='neutral'>    uint256 private constant _MAX_MINT_ERC2309_QUANTITY_LIMIT = 5000;</span>
   90 |     | <span class='neutral'></span>
   91 |     | <span class='neutral'>    // The `Transfer` event signature is given by:</span>
   92 |     | <span class='neutral'>    // `keccak256(bytes(&quot;Transfer(address,address,uint256)&quot;))`.</span>
   93 |     | <span class='neutral'>    bytes32 private constant _TRANSFER_EVENT_SIGNATURE =</span>
   94 |     | <span class='neutral'>        0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef;</span>
   95 |     | <span class='neutral'></span>
   96 |     | <span class='neutral'>    // =============================================================</span>
   97 |     | <span class='neutral'>    //                            STORAGE</span>
   98 |     | <span class='neutral'>    // =============================================================</span>
   99 |     | <span class='neutral'></span>
  100 |     | <span class='neutral'>    // The next token ID to be minted.</span>
  101 |     | <span class='neutral'>    uint256 private _currentIndex;</span>
  102 |     | <span class='neutral'></span>
  103 |     | <span class='neutral'>    // The number of tokens burned.</span>
  104 |     | <span class='neutral'>    uint256 private _burnCounter;</span>
  105 |     | <span class='neutral'></span>
  106 |     | <span class='neutral'>    // Token name</span>
  107 |     | <span class='neutral'>    string private _name;</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    // Token symbol</span>
  110 |     | <span class='neutral'>    string private _symbol;</span>
  111 |     | <span class='neutral'></span>
  112 |     | <span class='neutral'>    // Mapping from token ID to ownership details</span>
  113 |     | <span class='neutral'>    // An empty struct value does not necessarily mean the token is unowned.</span>
  114 |     | <span class='neutral'>    // See {_packedOwnershipOf} implementation for details.</span>
  115 |     | <span class='neutral'>    //</span>
  116 |     | <span class='neutral'>    // Bits Layout:</span>
  117 |     | <span class='neutral'>    // - [0..159]   `addr`</span>
  118 |     | <span class='neutral'>    // - [160..223] `startTimestamp`</span>
  119 |     | <span class='neutral'>    // - [224]      `burned`</span>
  120 |     | <span class='neutral'>    // - [225]      `nextInitialized`</span>
  121 |     | <span class='neutral'>    // - [232..255] `extraData`</span>
  122 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private _packedOwnerships;</span>
  123 |     | <span class='neutral'></span>
  124 |     | <span class='neutral'>    // Mapping owner address to address data.</span>
  125 |     | <span class='neutral'>    //</span>
  126 |     | <span class='neutral'>    // Bits Layout:</span>
  127 |     | <span class='neutral'>    // - [0..63]    `balance`</span>
  128 |     | <span class='neutral'>    // - [64..127]  `numberMinted`</span>
  129 |     | <span class='neutral'>    // - [128..191] `numberBurned`</span>
  130 |     | <span class='neutral'>    // - [192..255] `aux`</span>
  131 |     | <span class='neutral'>    mapping(address =&gt; uint256) private _packedAddressData;</span>
  132 |     | <span class='neutral'></span>
  133 |     | <span class='neutral'>    // Mapping from token ID to approved address.</span>
  134 |     | <span class='neutral'>    mapping(uint256 =&gt; TokenApprovalRef) private _tokenApprovals;</span>
  135 |     | <span class='neutral'></span>
  136 |     | <span class='neutral'>    // Mapping from owner to operator approvals</span>
  137 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; bool)) private _operatorApprovals;</span>
  138 |     | <span class='neutral'></span>
  139 |     | <span class='neutral'>    // The amount of tokens minted above `_sequentialUpTo()`.</span>
  140 |     | <span class='neutral'>    // We call these spot mints (i.e. non-sequential mints).</span>
  141 |     | <span class='neutral'>    uint256 private _spotMinted;</span>
  142 |     | <span class='neutral'></span>
  143 |     | <span class='neutral'>    // =============================================================</span>
  144 |     | <span class='neutral'>    //                          CONSTRUCTOR</span>
  145 |     | <span class='neutral'>    // =============================================================</span>
  146 |     | <span class='neutral'></span>
  147 |     | <span class='unexecuted'>    constructor(string memory name_, string memory symbol_) {</span>
  148 |     | <span class='unexecuted'>        _name = name_;</span>
  149 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  150 |     | <span class='unexecuted'>        _currentIndex = _startTokenId();</span>
  151 |     | <span class='neutral'></span>
  152 |     | <span class='neutral'>        if (_sequentialUpTo() &lt; _startTokenId()) _revert(SequentialUpToTooSmall.selector);</span>
  153 |     | <span class='neutral'>    }</span>
  154 |     | <span class='neutral'></span>
  155 |     | <span class='neutral'>    // =============================================================</span>
  156 |     | <span class='neutral'>    //                   TOKEN COUNTING OPERATIONS</span>
  157 |     | <span class='neutral'>    // =============================================================</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>    /**</span>
  160 |     | <span class='neutral'>     * @dev Returns the starting token ID for sequential mints.</span>
  161 |     | <span class='neutral'>     *</span>
  162 |     | <span class='neutral'>     * Override this function to change the starting token ID for sequential mints.</span>
  163 |     | <span class='neutral'>     *</span>
  164 |     | <span class='neutral'>     * Note: The value returned must never change after any tokens have been minted.</span>
  165 |     | <span class='neutral'>     */</span>
  166 |     | <span class='unexecuted'>    function _startTokenId() internal view virtual returns (uint256) {</span>
  167 |     | <span class='neutral'>        return 0;</span>
  168 |     | <span class='neutral'>    }</span>
  169 |     | <span class='neutral'></span>
  170 |     | <span class='neutral'>    /**</span>
  171 |     | <span class='neutral'>     * @dev Returns the maximum token ID (inclusive) for sequential mints.</span>
  172 |     | <span class='neutral'>     *</span>
  173 |     | <span class='neutral'>     * Override this function to return a value less than 2**256 - 1,</span>
  174 |     | <span class='neutral'>     * but greater than `_startTokenId()`, to enable spot (non-sequential) mints.</span>
  175 |     | <span class='neutral'>     *</span>
  176 |     | <span class='neutral'>     * Note: The value returned must never change after any tokens have been minted.</span>
  177 |     | <span class='neutral'>     */</span>
  178 |     | <span class='neutral'>    function _sequentialUpTo() internal view virtual returns (uint256) {</span>
  179 |     | <span class='neutral'>        return type(uint256).max;</span>
  180 |     | <span class='neutral'>    }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='neutral'>    /**</span>
  183 |     | <span class='neutral'>     * @dev Returns the next token ID to be minted.</span>
  184 |     | <span class='neutral'>     */</span>
  185 |     | <span class='unexecuted'>    function _nextTokenId() internal view virtual returns (uint256) {</span>
  186 |     | <span class='unexecuted'>        return _currentIndex;</span>
  187 |     | <span class='neutral'>    }</span>
  188 |     | <span class='neutral'></span>
  189 |     | <span class='neutral'>    /**</span>
  190 |     | <span class='neutral'>     * @dev Returns the total number of tokens in existence.</span>
  191 |     | <span class='neutral'>     * Burned tokens will reduce the count.</span>
  192 |     | <span class='neutral'>     * To get the total number of tokens minted, please see {_totalMinted}.</span>
  193 |     | <span class='neutral'>     */</span>
  194 |     | <span class='unexecuted'>    function totalSupply() public view virtual override returns (uint256 result) {</span>
  195 |     | <span class='neutral'>        // Counter underflow is impossible as `_burnCounter` cannot be incremented</span>
  196 |     | <span class='neutral'>        // more than `_currentIndex + _spotMinted - _startTokenId()` times.</span>
  197 |     | <span class='neutral'>        unchecked {</span>
  198 |     | <span class='neutral'>            // With spot minting, the intermediate `result` can be temporarily negative,</span>
  199 |     | <span class='neutral'>            // and the computation must be unchecked.</span>
  200 |     | <span class='unexecuted'>            result = _currentIndex - _burnCounter - _startTokenId();</span>
  201 |     | <span class='neutral'>            if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;</span>
  202 |     | <span class='neutral'>        }</span>
  203 |     | <span class='neutral'>    }</span>
  204 |     | <span class='neutral'></span>
  205 |     | <span class='neutral'>    /**</span>
  206 |     | <span class='neutral'>     * @dev Returns the total amount of tokens minted in the contract.</span>
  207 |     | <span class='neutral'>     */</span>
  208 |     | <span class='neutral'>    function _totalMinted() internal view virtual returns (uint256 result) {</span>
  209 |     | <span class='neutral'>        // Counter underflow is impossible as `_currentIndex` does not decrement,</span>
  210 |     | <span class='neutral'>        // and it is initialized to `_startTokenId()`.</span>
  211 |     | <span class='neutral'>        unchecked {</span>
  212 |     | <span class='neutral'>            result = _currentIndex - _startTokenId();</span>
  213 |     | <span class='neutral'>            if (_sequentialUpTo() != type(uint256).max) result += _spotMinted;</span>
  214 |     | <span class='neutral'>        }</span>
  215 |     | <span class='neutral'>    }</span>
  216 |     | <span class='neutral'></span>
  217 |     | <span class='neutral'>    /**</span>
  218 |     | <span class='neutral'>     * @dev Returns the total number of tokens burned.</span>
  219 |     | <span class='neutral'>     */</span>
  220 |     | <span class='neutral'>    function _totalBurned() internal view virtual returns (uint256) {</span>
  221 |     | <span class='neutral'>        return _burnCounter;</span>
  222 |     | <span class='neutral'>    }</span>
  223 |     | <span class='neutral'></span>
  224 |     | <span class='neutral'>    /**</span>
  225 |     | <span class='neutral'>     * @dev Returns the total number of tokens that are spot-minted.</span>
  226 |     | <span class='neutral'>     */</span>
  227 |     | <span class='neutral'>    function _totalSpotMinted() internal view virtual returns (uint256) {</span>
  228 |     | <span class='neutral'>        return _spotMinted;</span>
  229 |     | <span class='neutral'>    }</span>
  230 |     | <span class='neutral'></span>
  231 |     | <span class='neutral'>    // =============================================================</span>
  232 |     | <span class='neutral'>    //                    ADDRESS DATA OPERATIONS</span>
  233 |     | <span class='neutral'>    // =============================================================</span>
  234 |     | <span class='neutral'></span>
  235 |     | <span class='neutral'>    /**</span>
  236 |     | <span class='neutral'>     * @dev Returns the number of tokens in `owner`&#39;s account.</span>
  237 |     | <span class='neutral'>     */</span>
  238 |     | <span class='unexecuted'>    function balanceOf(address owner) public view virtual override returns (uint256) {</span>
  239 |     | <span class='unexecuted'>        if (owner == address(0)) _revert(BalanceQueryForZeroAddress.selector);</span>
  240 |     | <span class='unexecuted'>        return _packedAddressData[owner] &amp; _BITMASK_ADDRESS_DATA_ENTRY;</span>
  241 |     | <span class='neutral'>    }</span>
  242 |     | <span class='neutral'></span>
  243 |     | <span class='neutral'>    /**</span>
  244 |     | <span class='neutral'>     * Returns the number of tokens minted by `owner`.</span>
  245 |     | <span class='neutral'>     */</span>
  246 |     | <span class='neutral'>    function _numberMinted(address owner) internal view returns (uint256) {</span>
  247 |     | <span class='neutral'>        return (_packedAddressData[owner] &gt;&gt; _BITPOS_NUMBER_MINTED) &amp; _BITMASK_ADDRESS_DATA_ENTRY;</span>
  248 |     | <span class='neutral'>    }</span>
  249 |     | <span class='neutral'></span>
  250 |     | <span class='neutral'>    /**</span>
  251 |     | <span class='neutral'>     * Returns the number of tokens burned by or on behalf of `owner`.</span>
  252 |     | <span class='neutral'>     */</span>
  253 |     | <span class='neutral'>    function _numberBurned(address owner) internal view returns (uint256) {</span>
  254 |     | <span class='neutral'>        return (_packedAddressData[owner] &gt;&gt; _BITPOS_NUMBER_BURNED) &amp; _BITMASK_ADDRESS_DATA_ENTRY;</span>
  255 |     | <span class='neutral'>    }</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    /**</span>
  258 |     | <span class='neutral'>     * Returns the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).</span>
  259 |     | <span class='neutral'>     */</span>
  260 |     | <span class='neutral'>    function _getAux(address owner) internal view returns (uint64) {</span>
  261 |     | <span class='neutral'>        return uint64(_packedAddressData[owner] &gt;&gt; _BITPOS_AUX);</span>
  262 |     | <span class='neutral'>    }</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    /**</span>
  265 |     | <span class='neutral'>     * Sets the auxiliary data for `owner`. (e.g. number of whitelist mint slots used).</span>
  266 |     | <span class='neutral'>     * If there are multiple variables, please pack them into a uint64.</span>
  267 |     | <span class='neutral'>     */</span>
  268 |     | <span class='neutral'>    function _setAux(address owner, uint64 aux) internal virtual {</span>
  269 |     | <span class='neutral'>        uint256 packed = _packedAddressData[owner];</span>
  270 |     | <span class='neutral'>        uint256 auxCasted;</span>
  271 |     | <span class='neutral'>        // Cast `aux` with assembly to avoid redundant masking.</span>
  272 |     | <span class='neutral'>        assembly {</span>
  273 |     | <span class='neutral'>            auxCasted := aux</span>
  274 |     | <span class='neutral'>        }</span>
  275 |     | <span class='neutral'>        packed = (packed &amp; _BITMASK_AUX_COMPLEMENT) | (auxCasted &lt;&lt; _BITPOS_AUX);</span>
  276 |     | <span class='neutral'>        _packedAddressData[owner] = packed;</span>
  277 |     | <span class='neutral'>    }</span>
  278 |     | <span class='neutral'></span>
  279 |     | <span class='neutral'>    // =============================================================</span>
  280 |     | <span class='neutral'>    //                            IERC165</span>
  281 |     | <span class='neutral'>    // =============================================================</span>
  282 |     | <span class='neutral'></span>
  283 |     | <span class='neutral'>    /**</span>
  284 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
  285 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
  286 |     | <span class='neutral'>     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)</span>
  287 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
  288 |     | <span class='neutral'>     *</span>
  289 |     | <span class='neutral'>     * This function call must use less than 30000 gas.</span>
  290 |     | <span class='neutral'>     */</span>
  291 |     | <span class='unexecuted'>    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {</span>
  292 |     | <span class='neutral'>        // The interface IDs are constants representing the first 4 bytes</span>
  293 |     | <span class='neutral'>        // of the XOR of all function selectors in the interface.</span>
  294 |     | <span class='neutral'>        // See: [ERC165](https://eips.ethereum.org/EIPS/eip-165)</span>
  295 |     | <span class='neutral'>        // (e.g. `bytes4(i.functionA.selector ^ i.functionB.selector ^ ...)`)</span>
  296 |     | <span class='unexecuted'>        return</span>
  297 |     | <span class='unexecuted'>            interfaceId == 0x01ffc9a7 || // ERC165 interface ID for ERC165.</span>
  298 |     | <span class='unexecuted'>            interfaceId == 0x80ac58cd || // ERC165 interface ID for ERC721.</span>
  299 |     | <span class='unexecuted'>            interfaceId == 0x5b5e139f; // ERC165 interface ID for ERC721Metadata.</span>
  300 |     | <span class='neutral'>    }</span>
  301 |     | <span class='neutral'></span>
  302 |     | <span class='neutral'>    // =============================================================</span>
  303 |     | <span class='neutral'>    //                        IERC721Metadata</span>
  304 |     | <span class='neutral'>    // =============================================================</span>
  305 |     | <span class='neutral'></span>
  306 |     | <span class='neutral'>    /**</span>
  307 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
  308 |     | <span class='neutral'>     */</span>
  309 |     | <span class='unexecuted'>    function name() public view virtual override returns (string memory) {</span>
  310 |     | <span class='unexecuted'>        return _name;</span>
  311 |     | <span class='neutral'>    }</span>
  312 |     | <span class='neutral'></span>
  313 |     | <span class='neutral'>    /**</span>
  314 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
  315 |     | <span class='neutral'>     */</span>
  316 |     | <span class='unexecuted'>    function symbol() public view virtual override returns (string memory) {</span>
  317 |     | <span class='unexecuted'>        return _symbol;</span>
  318 |     | <span class='neutral'>    }</span>
  319 |     | <span class='neutral'></span>
  320 |     | <span class='neutral'>    /**</span>
  321 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
  322 |     | <span class='neutral'>     */</span>
  323 |     | <span class='unexecuted'>    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {</span>
  324 |     | <span class='unexecuted'>        if (!_exists(tokenId)) _revert(URIQueryForNonexistentToken.selector);</span>
  325 |     | <span class='neutral'></span>
  326 |     | <span class='unexecuted'>        string memory baseURI = _baseURI();</span>
  327 |     | <span class='unexecuted'>        return bytes(baseURI).length != 0 ? string(abi.encodePacked(baseURI, _toString(tokenId))) : &#39;&#39;;</span>
  328 |     | <span class='neutral'>    }</span>
  329 |     | <span class='neutral'></span>
  330 |     | <span class='neutral'>    /**</span>
  331 |     | <span class='neutral'>     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each</span>
  332 |     | <span class='neutral'>     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty</span>
  333 |     | <span class='neutral'>     * by default, it can be overridden in child contracts.</span>
  334 |     | <span class='neutral'>     */</span>
  335 |     | <span class='unexecuted'>    function _baseURI() internal view virtual returns (string memory) {</span>
  336 |     | <span class='unexecuted'>        return &#39;&#39;;</span>
  337 |     | <span class='neutral'>    }</span>
  338 |     | <span class='neutral'></span>
  339 |     | <span class='neutral'>    // =============================================================</span>
  340 |     | <span class='neutral'>    //                     OWNERSHIPS OPERATIONS</span>
  341 |     | <span class='neutral'>    // =============================================================</span>
  342 |     | <span class='neutral'></span>
  343 |     | <span class='neutral'>    /**</span>
  344 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
  345 |     | <span class='neutral'>     *</span>
  346 |     | <span class='neutral'>     * Requirements:</span>
  347 |     | <span class='neutral'>     *</span>
  348 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  349 |     | <span class='neutral'>     */</span>
  350 |     | <span class='unexecuted'>    function ownerOf(uint256 tokenId) public view virtual override returns (address) {</span>
  351 |     | <span class='unexecuted'>        return address(uint160(_packedOwnershipOf(tokenId)));</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    /**</span>
  355 |     | <span class='neutral'>     * @dev Gas spent here starts off proportional to the maximum mint batch size.</span>
  356 |     | <span class='neutral'>     * It gradually moves to O(1) as tokens get transferred around over time.</span>
  357 |     | <span class='neutral'>     */</span>
  358 |     | <span class='neutral'>    function _ownershipOf(uint256 tokenId) internal view virtual returns (TokenOwnership memory) {</span>
  359 |     | <span class='neutral'>        return _unpackedOwnership(_packedOwnershipOf(tokenId));</span>
  360 |     | <span class='neutral'>    }</span>
  361 |     | <span class='neutral'></span>
  362 |     | <span class='neutral'>    /**</span>
  363 |     | <span class='neutral'>     * @dev Returns the unpacked `TokenOwnership` struct at `index`.</span>
  364 |     | <span class='neutral'>     */</span>
  365 |     | <span class='neutral'>    function _ownershipAt(uint256 index) internal view virtual returns (TokenOwnership memory) {</span>
  366 |     | <span class='neutral'>        return _unpackedOwnership(_packedOwnerships[index]);</span>
  367 |     | <span class='neutral'>    }</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>    /**</span>
  370 |     | <span class='neutral'>     * @dev Returns whether the ownership slot at `index` is initialized.</span>
  371 |     | <span class='neutral'>     * An uninitialized slot does not necessarily mean that the slot has no owner.</span>
  372 |     | <span class='neutral'>     */</span>
  373 |     | <span class='neutral'>    function _ownershipIsInitialized(uint256 index) internal view virtual returns (bool) {</span>
  374 |     | <span class='neutral'>        return _packedOwnerships[index] != 0;</span>
  375 |     | <span class='neutral'>    }</span>
  376 |     | <span class='neutral'></span>
  377 |     | <span class='neutral'>    /**</span>
  378 |     | <span class='neutral'>     * @dev Initializes the ownership slot minted at `index` for efficiency purposes.</span>
  379 |     | <span class='neutral'>     */</span>
  380 |     | <span class='neutral'>    function _initializeOwnershipAt(uint256 index) internal virtual {</span>
  381 |     | <span class='neutral'>        if (_packedOwnerships[index] == 0) {</span>
  382 |     | <span class='neutral'>            _packedOwnerships[index] = _packedOwnershipOf(index);</span>
  383 |     | <span class='neutral'>        }</span>
  384 |     | <span class='neutral'>    }</span>
  385 |     | <span class='neutral'></span>
  386 |     | <span class='neutral'>    /**</span>
  387 |     | <span class='neutral'>     * @dev Returns the packed ownership data of `tokenId`.</span>
  388 |     | <span class='neutral'>     */</span>
  389 |     | <span class='unexecuted'>    function _packedOwnershipOf(uint256 tokenId) private view returns (uint256 packed) {</span>
  390 |     | <span class='unexecuted'>        if (_startTokenId() &lt;= tokenId) {</span>
  391 |     | <span class='unexecuted'>            packed = _packedOwnerships[tokenId];</span>
  392 |     | <span class='neutral'></span>
  393 |     | <span class='neutral'>            if (tokenId &gt; _sequentialUpTo()) {</span>
  394 |     | <span class='neutral'>                if (_packedOwnershipExists(packed)) return packed;</span>
  395 |     | <span class='neutral'>                _revert(OwnerQueryForNonexistentToken.selector);</span>
  396 |     | <span class='neutral'>            }</span>
  397 |     | <span class='neutral'></span>
  398 |     | <span class='neutral'>            // If the data at the starting slot does not exist, start the scan.</span>
  399 |     | <span class='unexecuted'>            if (packed == 0) {</span>
  400 |     | <span class='unexecuted'>                if (tokenId &gt;= _currentIndex) _revert(OwnerQueryForNonexistentToken.selector);</span>
  401 |     | <span class='neutral'>                // Invariant:</span>
  402 |     | <span class='neutral'>                // There will always be an initialized ownership slot</span>
  403 |     | <span class='neutral'>                // (i.e. `ownership.addr != address(0) &amp;&amp; ownership.burned == false`)</span>
  404 |     | <span class='neutral'>                // before an unintialized ownership slot</span>
  405 |     | <span class='neutral'>                // (i.e. `ownership.addr == address(0) &amp;&amp; ownership.burned == false`)</span>
  406 |     | <span class='neutral'>                // Hence, `tokenId` will not underflow.</span>
  407 |     | <span class='neutral'>                //</span>
  408 |     | <span class='neutral'>                // We can directly compare the packed value.</span>
  409 |     | <span class='neutral'>                // If the address is zero, packed will be zero.</span>
  410 |     | <span class='unexecuted'>                for (;;) {</span>
  411 |     | <span class='neutral'>                    unchecked {</span>
  412 |     | <span class='unexecuted'>                        packed = _packedOwnerships[--tokenId];</span>
  413 |     | <span class='neutral'>                    }</span>
  414 |     | <span class='unexecuted'>                    if (packed == 0) continue;</span>
  415 |     | <span class='unexecuted'>                    if (packed &amp; _BITMASK_BURNED == 0) return packed;</span>
  416 |     | <span class='neutral'>                    // Otherwise, the token is burned, and we must revert.</span>
  417 |     | <span class='neutral'>                    // This handles the case of batch burned tokens, where only the burned bit</span>
  418 |     | <span class='neutral'>                    // of the starting slot is set, and remaining slots are left uninitialized.</span>
  419 |     | <span class='unexecuted'>                    _revert(OwnerQueryForNonexistentToken.selector);</span>
  420 |     | <span class='neutral'>                }</span>
  421 |     | <span class='neutral'>            }</span>
  422 |     | <span class='neutral'>            // Otherwise, the data exists and we can skip the scan.</span>
  423 |     | <span class='neutral'>            // This is possible because we have already achieved the target condition.</span>
  424 |     | <span class='neutral'>            // This saves 2143 gas on transfers of initialized tokens.</span>
  425 |     | <span class='neutral'>            // If the token is not burned, return `packed`. Otherwise, revert.</span>
  426 |     | <span class='unexecuted'>            if (packed &amp; _BITMASK_BURNED == 0) return packed;</span>
  427 |     | <span class='neutral'>        }</span>
  428 |     | <span class='unexecuted'>        _revert(OwnerQueryForNonexistentToken.selector);</span>
  429 |     | <span class='neutral'>    }</span>
  430 |     | <span class='neutral'></span>
  431 |     | <span class='neutral'>    /**</span>
  432 |     | <span class='neutral'>     * @dev Returns the unpacked `TokenOwnership` struct from `packed`.</span>
  433 |     | <span class='neutral'>     */</span>
  434 |     | <span class='neutral'>    function _unpackedOwnership(uint256 packed) private pure returns (TokenOwnership memory ownership) {</span>
  435 |     | <span class='neutral'>        ownership.addr = address(uint160(packed));</span>
  436 |     | <span class='neutral'>        ownership.startTimestamp = uint64(packed &gt;&gt; _BITPOS_START_TIMESTAMP);</span>
  437 |     | <span class='neutral'>        ownership.burned = packed &amp; _BITMASK_BURNED != 0;</span>
  438 |     | <span class='neutral'>        ownership.extraData = uint24(packed &gt;&gt; _BITPOS_EXTRA_DATA);</span>
  439 |     | <span class='neutral'>    }</span>
  440 |     | <span class='neutral'></span>
  441 |     | <span class='neutral'>    /**</span>
  442 |     | <span class='neutral'>     * @dev Packs ownership data into a single uint256.</span>
  443 |     | <span class='neutral'>     */</span>
  444 |     | <span class='neutral'>    function _packOwnershipData(address owner, uint256 flags) private view returns (uint256 result) {</span>
  445 |     | <span class='neutral'>        assembly {</span>
  446 |     | <span class='neutral'>            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  447 |     | <span class='unexecuted'>            owner := and(owner, _BITMASK_ADDRESS)</span>
  448 |     | <span class='neutral'>            // `owner | (block.timestamp &lt;&lt; _BITPOS_START_TIMESTAMP) | flags`.</span>
  449 |     | <span class='unexecuted'>            result := or(owner, or(shl(_BITPOS_START_TIMESTAMP, timestamp()), flags))</span>
  450 |     | <span class='neutral'>        }</span>
  451 |     | <span class='neutral'>    }</span>
  452 |     | <span class='neutral'></span>
  453 |     | <span class='neutral'>    /**</span>
  454 |     | <span class='neutral'>     * @dev Returns the `nextInitialized` flag set if `quantity` equals 1.</span>
  455 |     | <span class='neutral'>     */</span>
  456 |     | <span class='neutral'>    function _nextInitializedFlag(uint256 quantity) private pure returns (uint256 result) {</span>
  457 |     | <span class='neutral'>        // For branchless setting of the `nextInitialized` flag.</span>
  458 |     | <span class='neutral'>        assembly {</span>
  459 |     | <span class='neutral'>            // `(quantity == 1) &lt;&lt; _BITPOS_NEXT_INITIALIZED`.</span>
  460 |     | <span class='unexecuted'>            result := shl(_BITPOS_NEXT_INITIALIZED, eq(quantity, 1))</span>
  461 |     | <span class='neutral'>        }</span>
  462 |     | <span class='neutral'>    }</span>
  463 |     | <span class='neutral'></span>
  464 |     | <span class='neutral'>    // =============================================================</span>
  465 |     | <span class='neutral'>    //                      APPROVAL OPERATIONS</span>
  466 |     | <span class='neutral'>    // =============================================================</span>
  467 |     | <span class='neutral'></span>
  468 |     | <span class='neutral'>    /**</span>
  469 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account. See {ERC721A-_approve}.</span>
  470 |     | <span class='neutral'>     *</span>
  471 |     | <span class='neutral'>     * Requirements:</span>
  472 |     | <span class='neutral'>     *</span>
  473 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
  474 |     | <span class='neutral'>     */</span>
  475 |     | <span class='unexecuted'>    function approve(address to, uint256 tokenId) public payable virtual override {</span>
  476 |     | <span class='unexecuted'>        _approve(to, tokenId, true);</span>
  477 |     | <span class='neutral'>    }</span>
  478 |     | <span class='neutral'></span>
  479 |     | <span class='neutral'>    /**</span>
  480 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
  481 |     | <span class='neutral'>     *</span>
  482 |     | <span class='neutral'>     * Requirements:</span>
  483 |     | <span class='neutral'>     *</span>
  484 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
  485 |     | <span class='neutral'>     */</span>
  486 |     | <span class='unexecuted'>    function getApproved(uint256 tokenId) public view virtual override returns (address) {</span>
  487 |     | <span class='unexecuted'>        if (!_exists(tokenId)) _revert(ApprovalQueryForNonexistentToken.selector);</span>
  488 |     | <span class='neutral'></span>
  489 |     | <span class='unexecuted'>        return _tokenApprovals[tokenId].value;</span>
  490 |     | <span class='neutral'>    }</span>
  491 |     | <span class='neutral'></span>
  492 |     | <span class='neutral'>    /**</span>
  493 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
  494 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom}</span>
  495 |     | <span class='neutral'>     * for any token owned by the caller.</span>
  496 |     | <span class='neutral'>     *</span>
  497 |     | <span class='neutral'>     * Requirements:</span>
  498 |     | <span class='neutral'>     *</span>
  499 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
  500 |     | <span class='neutral'>     *</span>
  501 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
  502 |     | <span class='neutral'>     */</span>
  503 |     | <span class='unexecuted'>    function setApprovalForAll(address operator, bool approved) public virtual override {</span>
  504 |     | <span class='unexecuted'>        _operatorApprovals[_msgSenderERC721A()][operator] = approved;</span>
  505 |     | <span class='unexecuted'>        emit ApprovalForAll(_msgSenderERC721A(), operator, approved);</span>
  506 |     | <span class='neutral'>    }</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>    /**</span>
  509 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
  510 |     | <span class='neutral'>     *</span>
  511 |     | <span class='neutral'>     * See {setApprovalForAll}.</span>
  512 |     | <span class='neutral'>     */</span>
  513 |     | <span class='unexecuted'>    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {</span>
  514 |     | <span class='unexecuted'>        return _operatorApprovals[owner][operator];</span>
  515 |     | <span class='neutral'>    }</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>    /**</span>
  518 |     | <span class='neutral'>     * @dev Returns whether `tokenId` exists.</span>
  519 |     | <span class='neutral'>     *</span>
  520 |     | <span class='neutral'>     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.</span>
  521 |     | <span class='neutral'>     *</span>
  522 |     | <span class='neutral'>     * Tokens start existing when they are minted. See {_mint}.</span>
  523 |     | <span class='neutral'>     */</span>
  524 |     | <span class='unexecuted'>    function _exists(uint256 tokenId) internal view virtual returns (bool result) {</span>
  525 |     | <span class='unexecuted'>        if (_startTokenId() &lt;= tokenId) {</span>
  526 |     | <span class='neutral'>            if (tokenId &gt; _sequentialUpTo()) return _packedOwnershipExists(_packedOwnerships[tokenId]);</span>
  527 |     | <span class='neutral'></span>
  528 |     | <span class='unexecuted'>            if (tokenId &lt; _currentIndex) {</span>
  529 |     | <span class='unexecuted'>                uint256 packed;</span>
  530 |     | <span class='unexecuted'>                while ((packed = _packedOwnerships[tokenId]) == 0) --tokenId;</span>
  531 |     | <span class='unexecuted'>                result = packed &amp; _BITMASK_BURNED == 0;</span>
  532 |     | <span class='neutral'>            }</span>
  533 |     | <span class='neutral'>        }</span>
  534 |     | <span class='neutral'>    }</span>
  535 |     | <span class='neutral'></span>
  536 |     | <span class='neutral'>    /**</span>
  537 |     | <span class='neutral'>     * @dev Returns whether `packed` represents a token that exists.</span>
  538 |     | <span class='neutral'>     */</span>
  539 |     | <span class='neutral'>    function _packedOwnershipExists(uint256 packed) private pure returns (bool result) {</span>
  540 |     | <span class='neutral'>        assembly {</span>
  541 |     | <span class='neutral'>            // The following is equivalent to `owner != address(0) &amp;&amp; burned == false`.</span>
  542 |     | <span class='neutral'>            // Symbolically tested.</span>
  543 |     | <span class='neutral'>            result := gt(and(packed, _BITMASK_ADDRESS), and(packed, _BITMASK_BURNED))</span>
  544 |     | <span class='neutral'>        }</span>
  545 |     | <span class='neutral'>    }</span>
  546 |     | <span class='neutral'></span>
  547 |     | <span class='neutral'>    /**</span>
  548 |     | <span class='neutral'>     * @dev Returns whether `msgSender` is equal to `approvedAddress` or `owner`.</span>
  549 |     | <span class='neutral'>     */</span>
  550 |     | <span class='neutral'>    function _isSenderApprovedOrOwner(</span>
  551 |     | <span class='neutral'>        address approvedAddress,</span>
  552 |     | <span class='neutral'>        address owner,</span>
  553 |     | <span class='neutral'>        address msgSender</span>
  554 |     | <span class='neutral'>    ) private pure returns (bool result) {</span>
  555 |     | <span class='neutral'>        assembly {</span>
  556 |     | <span class='neutral'>            // Mask `owner` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  557 |     | <span class='unexecuted'>            owner := and(owner, _BITMASK_ADDRESS)</span>
  558 |     | <span class='neutral'>            // Mask `msgSender` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  559 |     | <span class='neutral'>            msgSender := and(msgSender, _BITMASK_ADDRESS)</span>
  560 |     | <span class='neutral'>            // `msgSender == owner || msgSender == approvedAddress`.</span>
  561 |     | <span class='unexecuted'>            result := or(eq(msgSender, owner), eq(msgSender, approvedAddress))</span>
  562 |     | <span class='neutral'>        }</span>
  563 |     | <span class='neutral'>    }</span>
  564 |     | <span class='neutral'></span>
  565 |     | <span class='neutral'>    /**</span>
  566 |     | <span class='neutral'>     * @dev Returns the storage slot and value for the approved address of `tokenId`.</span>
  567 |     | <span class='neutral'>     */</span>
  568 |     | <span class='neutral'>    function _getApprovedSlotAndAddress(uint256 tokenId)</span>
  569 |     | <span class='neutral'>        private</span>
  570 |     | <span class='neutral'>        view</span>
  571 |     | <span class='neutral'>        returns (uint256 approvedAddressSlot, address approvedAddress)</span>
  572 |     | <span class='neutral'>    {</span>
  573 |     | <span class='unexecuted'>        TokenApprovalRef storage tokenApproval = _tokenApprovals[tokenId];</span>
  574 |     | <span class='neutral'>        // The following is equivalent to `approvedAddress = _tokenApprovals[tokenId].value`.</span>
  575 |     | <span class='neutral'>        assembly {</span>
  576 |     | <span class='neutral'>            approvedAddressSlot := tokenApproval.slot</span>
  577 |     | <span class='unexecuted'>            approvedAddress := sload(approvedAddressSlot)</span>
  578 |     | <span class='neutral'>        }</span>
  579 |     | <span class='neutral'>    }</span>
  580 |     | <span class='neutral'></span>
  581 |     | <span class='neutral'>    // =============================================================</span>
  582 |     | <span class='neutral'>    //                      TRANSFER OPERATIONS</span>
  583 |     | <span class='neutral'>    // =============================================================</span>
  584 |     | <span class='neutral'></span>
  585 |     | <span class='neutral'>    /**</span>
  586 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
  587 |     | <span class='neutral'>     *</span>
  588 |     | <span class='neutral'>     * Requirements:</span>
  589 |     | <span class='neutral'>     *</span>
  590 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  591 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  592 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
  593 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token</span>
  594 |     | <span class='neutral'>     * by either {approve} or {setApprovalForAll}.</span>
  595 |     | <span class='neutral'>     *</span>
  596 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  597 |     | <span class='neutral'>     */</span>
  598 |     | <span class='unexecuted'>    function transferFrom(</span>
  599 |     | <span class='neutral'>        address from,</span>
  600 |     | <span class='neutral'>        address to,</span>
  601 |     | <span class='neutral'>        uint256 tokenId</span>
  602 |     | <span class='unexecuted'>    ) public payable virtual override {</span>
  603 |     | <span class='unexecuted'>        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);</span>
  604 |     | <span class='neutral'></span>
  605 |     | <span class='neutral'>        // Mask `from` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  606 |     | <span class='unexecuted'>        from = address(uint160(uint256(uint160(from)) &amp; _BITMASK_ADDRESS));</span>
  607 |     | <span class='neutral'></span>
  608 |     | <span class='unexecuted'>        if (address(uint160(prevOwnershipPacked)) != from) _revert(TransferFromIncorrectOwner.selector);</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='unexecuted'>        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);</span>
  611 |     | <span class='neutral'></span>
  612 |     | <span class='neutral'>        // The nested ifs save around 20+ gas over a compound boolean condition.</span>
  613 |     | <span class='unexecuted'>        if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))</span>
  614 |     | <span class='unexecuted'>            if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>        _beforeTokenTransfers(from, to, tokenId, 1);</span>
  617 |     | <span class='neutral'></span>
  618 |     | <span class='neutral'>        // Clear approvals from the previous owner.</span>
  619 |     | <span class='neutral'>        assembly {</span>
  620 |     | <span class='unexecuted'>            if approvedAddress {</span>
  621 |     | <span class='neutral'>                // This is equivalent to `delete _tokenApprovals[tokenId]`.</span>
  622 |     | <span class='unexecuted'>                sstore(approvedAddressSlot, 0)</span>
  623 |     | <span class='neutral'>            }</span>
  624 |     | <span class='neutral'>        }</span>
  625 |     | <span class='neutral'></span>
  626 |     | <span class='neutral'>        // Underflow of the sender&#39;s balance is impossible because we check for</span>
  627 |     | <span class='neutral'>        // ownership above and the recipient&#39;s balance can&#39;t realistically overflow.</span>
  628 |     | <span class='neutral'>        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.</span>
  629 |     | <span class='neutral'>        unchecked {</span>
  630 |     | <span class='neutral'>            // We can directly increment and decrement the balances.</span>
  631 |     | <span class='unexecuted'>            --_packedAddressData[from]; // Updates: `balance -= 1`.</span>
  632 |     | <span class='unexecuted'>            ++_packedAddressData[to]; // Updates: `balance += 1`.</span>
  633 |     | <span class='neutral'></span>
  634 |     | <span class='neutral'>            // Updates:</span>
  635 |     | <span class='neutral'>            // - `address` to the next owner.</span>
  636 |     | <span class='neutral'>            // - `startTimestamp` to the timestamp of transfering.</span>
  637 |     | <span class='neutral'>            // - `burned` to `false`.</span>
  638 |     | <span class='neutral'>            // - `nextInitialized` to `true`.</span>
  639 |     | <span class='unexecuted'>            _packedOwnerships[tokenId] = _packOwnershipData(</span>
  640 |     | <span class='neutral'>                to,</span>
  641 |     | <span class='neutral'>                _BITMASK_NEXT_INITIALIZED | _nextExtraData(from, to, prevOwnershipPacked)</span>
  642 |     | <span class='neutral'>            );</span>
  643 |     | <span class='neutral'></span>
  644 |     | <span class='neutral'>            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .</span>
  645 |     | <span class='unexecuted'>            if (prevOwnershipPacked &amp; _BITMASK_NEXT_INITIALIZED == 0) {</span>
  646 |     | <span class='unexecuted'>                uint256 nextTokenId = tokenId + 1;</span>
  647 |     | <span class='neutral'>                // If the next slot&#39;s address is zero and not burned (i.e. packed value is zero).</span>
  648 |     | <span class='unexecuted'>                if (_packedOwnerships[nextTokenId] == 0) {</span>
  649 |     | <span class='neutral'>                    // If the next slot is within bounds.</span>
  650 |     | <span class='unexecuted'>                    if (nextTokenId != _currentIndex) {</span>
  651 |     | <span class='neutral'>                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.</span>
  652 |     | <span class='unexecuted'>                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;</span>
  653 |     | <span class='neutral'>                    }</span>
  654 |     | <span class='neutral'>                }</span>
  655 |     | <span class='neutral'>            }</span>
  656 |     | <span class='neutral'>        }</span>
  657 |     | <span class='neutral'></span>
  658 |     | <span class='neutral'>        // Mask `to` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  659 |     | <span class='unexecuted'>        uint256 toMasked = uint256(uint160(to)) &amp; _BITMASK_ADDRESS;</span>
  660 |     | <span class='neutral'>        assembly {</span>
  661 |     | <span class='neutral'>            // Emit the `Transfer` event.</span>
  662 |     | <span class='unexecuted'>            log4(</span>
  663 |     | <span class='neutral'>                0, // Start of data (0, since no data).</span>
  664 |     | <span class='neutral'>                0, // End of data (0, since no data).</span>
  665 |     | <span class='unexecuted'>                _TRANSFER_EVENT_SIGNATURE, // Signature.</span>
  666 |     | <span class='unexecuted'>                from, // `from`.</span>
  667 |     | <span class='neutral'>                toMasked, // `to`.</span>
  668 |     | <span class='unexecuted'>                tokenId // `tokenId`.</span>
  669 |     | <span class='neutral'>            )</span>
  670 |     | <span class='neutral'>        }</span>
  671 |     | <span class='unexecuted'>        if (toMasked == 0) _revert(TransferToZeroAddress.selector);</span>
  672 |     | <span class='neutral'></span>
  673 |     | <span class='neutral'>        _afterTokenTransfers(from, to, tokenId, 1);</span>
  674 |     | <span class='neutral'>    }</span>
  675 |     | <span class='neutral'></span>
  676 |     | <span class='neutral'>    /**</span>
  677 |     | <span class='neutral'>     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, &#39;&#39;)`.</span>
  678 |     | <span class='neutral'>     */</span>
  679 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
  680 |     | <span class='neutral'>        address from,</span>
  681 |     | <span class='neutral'>        address to,</span>
  682 |     | <span class='neutral'>        uint256 tokenId</span>
  683 |     | <span class='neutral'>    ) public payable virtual override {</span>
  684 |     | <span class='unexecuted'>        safeTransferFrom(from, to, tokenId, &#39;&#39;);</span>
  685 |     | <span class='neutral'>    }</span>
  686 |     | <span class='neutral'></span>
  687 |     | <span class='neutral'>    /**</span>
  688 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`.</span>
  689 |     | <span class='neutral'>     *</span>
  690 |     | <span class='neutral'>     * Requirements:</span>
  691 |     | <span class='neutral'>     *</span>
  692 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
  693 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  694 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
  695 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token</span>
  696 |     | <span class='neutral'>     * by either {approve} or {setApprovalForAll}.</span>
  697 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement</span>
  698 |     | <span class='neutral'>     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
  699 |     | <span class='neutral'>     *</span>
  700 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
  701 |     | <span class='neutral'>     */</span>
  702 |     | <span class='unexecuted'>    function safeTransferFrom(</span>
  703 |     | <span class='neutral'>        address from,</span>
  704 |     | <span class='neutral'>        address to,</span>
  705 |     | <span class='neutral'>        uint256 tokenId,</span>
  706 |     | <span class='neutral'>        bytes memory _data</span>
  707 |     | <span class='neutral'>    ) public payable virtual override {</span>
  708 |     | <span class='unexecuted'>        transferFrom(from, to, tokenId);</span>
  709 |     | <span class='unexecuted'>        if (to.code.length != 0)</span>
  710 |     | <span class='unexecuted'>            if (!_checkContractOnERC721Received(from, to, tokenId, _data)) {</span>
  711 |     | <span class='unexecuted'>                _revert(TransferToNonERC721ReceiverImplementer.selector);</span>
  712 |     | <span class='neutral'>            }</span>
  713 |     | <span class='neutral'>    }</span>
  714 |     | <span class='neutral'></span>
  715 |     | <span class='neutral'>    /**</span>
  716 |     | <span class='neutral'>     * @dev Hook that is called before a set of serially-ordered token IDs</span>
  717 |     | <span class='neutral'>     * are about to be transferred. This includes minting.</span>
  718 |     | <span class='neutral'>     * And also called before burning one token.</span>
  719 |     | <span class='neutral'>     *</span>
  720 |     | <span class='neutral'>     * `startTokenId` - the first token ID to be transferred.</span>
  721 |     | <span class='neutral'>     * `quantity` - the amount to be transferred.</span>
  722 |     | <span class='neutral'>     *</span>
  723 |     | <span class='neutral'>     * Calling conditions:</span>
  724 |     | <span class='neutral'>     *</span>
  725 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, `from`&#39;s `tokenId` will be</span>
  726 |     | <span class='neutral'>     * transferred to `to`.</span>
  727 |     | <span class='neutral'>     * - When `from` is zero, `tokenId` will be minted for `to`.</span>
  728 |     | <span class='neutral'>     * - When `to` is zero, `tokenId` will be burned by `from`.</span>
  729 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
  730 |     | <span class='neutral'>     */</span>
  731 |     | <span class='neutral'>    function _beforeTokenTransfers(</span>
  732 |     | <span class='neutral'>        address from,</span>
  733 |     | <span class='neutral'>        address to,</span>
  734 |     | <span class='neutral'>        uint256 startTokenId,</span>
  735 |     | <span class='neutral'>        uint256 quantity</span>
  736 |     | <span class='neutral'>    ) internal virtual {}</span>
  737 |     | <span class='neutral'></span>
  738 |     | <span class='neutral'>    /**</span>
  739 |     | <span class='neutral'>     * @dev Hook that is called after a set of serially-ordered token IDs</span>
  740 |     | <span class='neutral'>     * have been transferred. This includes minting.</span>
  741 |     | <span class='neutral'>     * And also called after one token has been burned.</span>
  742 |     | <span class='neutral'>     *</span>
  743 |     | <span class='neutral'>     * `startTokenId` - the first token ID to be transferred.</span>
  744 |     | <span class='neutral'>     * `quantity` - the amount to be transferred.</span>
  745 |     | <span class='neutral'>     *</span>
  746 |     | <span class='neutral'>     * Calling conditions:</span>
  747 |     | <span class='neutral'>     *</span>
  748 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, `from`&#39;s `tokenId` has been</span>
  749 |     | <span class='neutral'>     * transferred to `to`.</span>
  750 |     | <span class='neutral'>     * - When `from` is zero, `tokenId` has been minted for `to`.</span>
  751 |     | <span class='neutral'>     * - When `to` is zero, `tokenId` has been burned by `from`.</span>
  752 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
  753 |     | <span class='neutral'>     */</span>
  754 |     | <span class='neutral'>    function _afterTokenTransfers(</span>
  755 |     | <span class='neutral'>        address from,</span>
  756 |     | <span class='neutral'>        address to,</span>
  757 |     | <span class='neutral'>        uint256 startTokenId,</span>
  758 |     | <span class='neutral'>        uint256 quantity</span>
  759 |     | <span class='neutral'>    ) internal virtual {}</span>
  760 |     | <span class='neutral'></span>
  761 |     | <span class='neutral'>    /**</span>
  762 |     | <span class='neutral'>     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target contract.</span>
  763 |     | <span class='neutral'>     *</span>
  764 |     | <span class='neutral'>     * `from` - Previous owner of the given token ID.</span>
  765 |     | <span class='neutral'>     * `to` - Target address that will receive the token.</span>
  766 |     | <span class='neutral'>     * `tokenId` - Token ID to be transferred.</span>
  767 |     | <span class='neutral'>     * `_data` - Optional data to send along with the call.</span>
  768 |     | <span class='neutral'>     *</span>
  769 |     | <span class='neutral'>     * Returns whether the call correctly returned the expected magic value.</span>
  770 |     | <span class='neutral'>     */</span>
  771 |     | <span class='unexecuted'>    function _checkContractOnERC721Received(</span>
  772 |     | <span class='neutral'>        address from,</span>
  773 |     | <span class='neutral'>        address to,</span>
  774 |     | <span class='neutral'>        uint256 tokenId,</span>
  775 |     | <span class='neutral'>        bytes memory _data</span>
  776 |     | <span class='unexecuted'>    ) private returns (bool) {</span>
  777 |     | <span class='unexecuted'>        try ERC721A__IERC721Receiver(to).onERC721Received(_msgSenderERC721A(), from, tokenId, _data) returns (</span>
  778 |     | <span class='neutral'>            bytes4 retval</span>
  779 |     | <span class='neutral'>        ) {</span>
  780 |     | <span class='unexecuted'>            return retval == ERC721A__IERC721Receiver(to).onERC721Received.selector;</span>
  781 |     | <span class='neutral'>        } catch (bytes memory reason) {</span>
  782 |     | <span class='unexecuted'>            if (reason.length == 0) {</span>
  783 |     | <span class='unexecuted'>                _revert(TransferToNonERC721ReceiverImplementer.selector);</span>
  784 |     | <span class='neutral'>            }</span>
  785 |     | <span class='neutral'>            assembly {</span>
  786 |     | <span class='unexecuted'>                revert(add(32, reason), mload(reason))</span>
  787 |     | <span class='neutral'>            }</span>
  788 |     | <span class='neutral'>        }</span>
  789 |     | <span class='neutral'>    }</span>
  790 |     | <span class='neutral'></span>
  791 |     | <span class='neutral'>    // =============================================================</span>
  792 |     | <span class='neutral'>    //                        MINT OPERATIONS</span>
  793 |     | <span class='neutral'>    // =============================================================</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>    /**</span>
  796 |     | <span class='neutral'>     * @dev Mints `quantity` tokens and transfers them to `to`.</span>
  797 |     | <span class='neutral'>     *</span>
  798 |     | <span class='neutral'>     * Requirements:</span>
  799 |     | <span class='neutral'>     *</span>
  800 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  801 |     | <span class='neutral'>     * - `quantity` must be greater than 0.</span>
  802 |     | <span class='neutral'>     *</span>
  803 |     | <span class='neutral'>     * Emits a {Transfer} event for each mint.</span>
  804 |     | <span class='neutral'>     */</span>
  805 |     | <span class='unexecuted'>    function _mint(address to, uint256 quantity) internal virtual {</span>
  806 |     | <span class='unexecuted'>        uint256 startTokenId = _currentIndex;</span>
  807 |     | <span class='unexecuted'>        if (quantity == 0) _revert(MintZeroQuantity.selector);</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>        _beforeTokenTransfers(address(0), to, startTokenId, quantity);</span>
  810 |     | <span class='neutral'></span>
  811 |     | <span class='neutral'>        // Overflows are incredibly unrealistic.</span>
  812 |     | <span class='neutral'>        // `balance` and `numberMinted` have a maximum limit of 2**64.</span>
  813 |     | <span class='neutral'>        // `tokenId` has a maximum limit of 2**256.</span>
  814 |     | <span class='neutral'>        unchecked {</span>
  815 |     | <span class='neutral'>            // Updates:</span>
  816 |     | <span class='neutral'>            // - `address` to the owner.</span>
  817 |     | <span class='neutral'>            // - `startTimestamp` to the timestamp of minting.</span>
  818 |     | <span class='neutral'>            // - `burned` to `false`.</span>
  819 |     | <span class='neutral'>            // - `nextInitialized` to `quantity == 1`.</span>
  820 |     | <span class='unexecuted'>            _packedOwnerships[startTokenId] = _packOwnershipData(</span>
  821 |     | <span class='neutral'>                to,</span>
  822 |     | <span class='neutral'>                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)</span>
  823 |     | <span class='neutral'>            );</span>
  824 |     | <span class='neutral'></span>
  825 |     | <span class='neutral'>            // Updates:</span>
  826 |     | <span class='neutral'>            // - `balance += quantity`.</span>
  827 |     | <span class='neutral'>            // - `numberMinted += quantity`.</span>
  828 |     | <span class='neutral'>            //</span>
  829 |     | <span class='neutral'>            // We can directly add to the `balance` and `numberMinted`.</span>
  830 |     | <span class='unexecuted'>            _packedAddressData[to] += quantity * ((1 &lt;&lt; _BITPOS_NUMBER_MINTED) | 1);</span>
  831 |     | <span class='neutral'></span>
  832 |     | <span class='neutral'>            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
  833 |     | <span class='neutral'>            uint256 toMasked = uint256(uint160(to)) &amp; _BITMASK_ADDRESS;</span>
  834 |     | <span class='neutral'></span>
  835 |     | <span class='unexecuted'>            if (toMasked == 0) _revert(MintToZeroAddress.selector);</span>
  836 |     | <span class='neutral'></span>
  837 |     | <span class='unexecuted'>            uint256 end = startTokenId + quantity;</span>
  838 |     | <span class='neutral'>            uint256 tokenId = startTokenId;</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>            if (end - 1 &gt; _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);</span>
  841 |     | <span class='neutral'></span>
  842 |     | <span class='unexecuted'>            do {</span>
  843 |     | <span class='neutral'>                assembly {</span>
  844 |     | <span class='neutral'>                    // Emit the `Transfer` event.</span>
  845 |     | <span class='unexecuted'>                    log4(</span>
  846 |     | <span class='unexecuted'>                        0, // Start of data (0, since no data).</span>
  847 |     | <span class='unexecuted'>                        0, // End of data (0, since no data).</span>
  848 |     | <span class='unexecuted'>                        _TRANSFER_EVENT_SIGNATURE, // Signature.</span>
  849 |     | <span class='unexecuted'>                        0, // `address(0)`.</span>
  850 |     | <span class='unexecuted'>                        toMasked, // `to`.</span>
  851 |     | <span class='unexecuted'>                        tokenId // `tokenId`.</span>
  852 |     | <span class='neutral'>                    )</span>
  853 |     | <span class='neutral'>                }</span>
  854 |     | <span class='neutral'>                // The `!=` check ensures that large values of `quantity`</span>
  855 |     | <span class='neutral'>                // that overflows uint256 will make the loop run out of gas.</span>
  856 |     | <span class='unexecuted'>            } while (++tokenId != end);</span>
  857 |     | <span class='neutral'></span>
  858 |     | <span class='unexecuted'>            _currentIndex = end;</span>
  859 |     | <span class='neutral'>        }</span>
  860 |     | <span class='neutral'>        _afterTokenTransfers(address(0), to, startTokenId, quantity);</span>
  861 |     | <span class='neutral'>    }</span>
  862 |     | <span class='neutral'></span>
  863 |     | <span class='neutral'>    /**</span>
  864 |     | <span class='neutral'>     * @dev Mints `quantity` tokens and transfers them to `to`.</span>
  865 |     | <span class='neutral'>     *</span>
  866 |     | <span class='neutral'>     * This function is intended for efficient minting only during contract creation.</span>
  867 |     | <span class='neutral'>     *</span>
  868 |     | <span class='neutral'>     * It emits only one {ConsecutiveTransfer} as defined in</span>
  869 |     | <span class='neutral'>     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309),</span>
  870 |     | <span class='neutral'>     * instead of a sequence of {Transfer} event(s).</span>
  871 |     | <span class='neutral'>     *</span>
  872 |     | <span class='neutral'>     * Calling this function outside of contract creation WILL make your contract</span>
  873 |     | <span class='neutral'>     * non-compliant with the ERC721 standard.</span>
  874 |     | <span class='neutral'>     * For full ERC721 compliance, substituting ERC721 {Transfer} event(s) with the ERC2309</span>
  875 |     | <span class='neutral'>     * {ConsecutiveTransfer} event is only permissible during contract creation.</span>
  876 |     | <span class='neutral'>     *</span>
  877 |     | <span class='neutral'>     * Requirements:</span>
  878 |     | <span class='neutral'>     *</span>
  879 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  880 |     | <span class='neutral'>     * - `quantity` must be greater than 0.</span>
  881 |     | <span class='neutral'>     *</span>
  882 |     | <span class='neutral'>     * Emits a {ConsecutiveTransfer} event.</span>
  883 |     | <span class='neutral'>     */</span>
  884 |     | <span class='neutral'>    function _mintERC2309(address to, uint256 quantity) internal virtual {</span>
  885 |     | <span class='neutral'>        uint256 startTokenId = _currentIndex;</span>
  886 |     | <span class='neutral'>        if (to == address(0)) _revert(MintToZeroAddress.selector);</span>
  887 |     | <span class='neutral'>        if (quantity == 0) _revert(MintZeroQuantity.selector);</span>
  888 |     | <span class='neutral'>        if (quantity &gt; _MAX_MINT_ERC2309_QUANTITY_LIMIT) _revert(MintERC2309QuantityExceedsLimit.selector);</span>
  889 |     | <span class='neutral'></span>
  890 |     | <span class='neutral'>        _beforeTokenTransfers(address(0), to, startTokenId, quantity);</span>
  891 |     | <span class='neutral'></span>
  892 |     | <span class='neutral'>        // Overflows are unrealistic due to the above check for `quantity` to be below the limit.</span>
  893 |     | <span class='neutral'>        unchecked {</span>
  894 |     | <span class='neutral'>            // Updates:</span>
  895 |     | <span class='neutral'>            // - `balance += quantity`.</span>
  896 |     | <span class='neutral'>            // - `numberMinted += quantity`.</span>
  897 |     | <span class='neutral'>            //</span>
  898 |     | <span class='neutral'>            // We can directly add to the `balance` and `numberMinted`.</span>
  899 |     | <span class='neutral'>            _packedAddressData[to] += quantity * ((1 &lt;&lt; _BITPOS_NUMBER_MINTED) | 1);</span>
  900 |     | <span class='neutral'></span>
  901 |     | <span class='neutral'>            // Updates:</span>
  902 |     | <span class='neutral'>            // - `address` to the owner.</span>
  903 |     | <span class='neutral'>            // - `startTimestamp` to the timestamp of minting.</span>
  904 |     | <span class='neutral'>            // - `burned` to `false`.</span>
  905 |     | <span class='neutral'>            // - `nextInitialized` to `quantity == 1`.</span>
  906 |     | <span class='neutral'>            _packedOwnerships[startTokenId] = _packOwnershipData(</span>
  907 |     | <span class='neutral'>                to,</span>
  908 |     | <span class='neutral'>                _nextInitializedFlag(quantity) | _nextExtraData(address(0), to, 0)</span>
  909 |     | <span class='neutral'>            );</span>
  910 |     | <span class='neutral'></span>
  911 |     | <span class='neutral'>            if (startTokenId + quantity - 1 &gt; _sequentialUpTo()) _revert(SequentialMintExceedsLimit.selector);</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>            emit ConsecutiveTransfer(startTokenId, startTokenId + quantity - 1, address(0), to);</span>
  914 |     | <span class='neutral'></span>
  915 |     | <span class='neutral'>            _currentIndex = startTokenId + quantity;</span>
  916 |     | <span class='neutral'>        }</span>
  917 |     | <span class='neutral'>        _afterTokenTransfers(address(0), to, startTokenId, quantity);</span>
  918 |     | <span class='neutral'>    }</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='neutral'>    /**</span>
  921 |     | <span class='neutral'>     * @dev Safely mints `quantity` tokens and transfers them to `to`.</span>
  922 |     | <span class='neutral'>     *</span>
  923 |     | <span class='neutral'>     * Requirements:</span>
  924 |     | <span class='neutral'>     *</span>
  925 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement</span>
  926 |     | <span class='neutral'>     * {IERC721Receiver-onERC721Received}, which is called for each safe transfer.</span>
  927 |     | <span class='neutral'>     * - `quantity` must be greater than 0.</span>
  928 |     | <span class='neutral'>     *</span>
  929 |     | <span class='neutral'>     * See {_mint}.</span>
  930 |     | <span class='neutral'>     *</span>
  931 |     | <span class='neutral'>     * Emits a {Transfer} event for each mint.</span>
  932 |     | <span class='neutral'>     */</span>
  933 |     | <span class='neutral'>    function _safeMint(</span>
  934 |     | <span class='neutral'>        address to,</span>
  935 |     | <span class='neutral'>        uint256 quantity,</span>
  936 |     | <span class='neutral'>        bytes memory _data</span>
  937 |     | <span class='neutral'>    ) internal virtual {</span>
  938 |     | <span class='neutral'>        _mint(to, quantity);</span>
  939 |     | <span class='neutral'></span>
  940 |     | <span class='neutral'>        unchecked {</span>
  941 |     | <span class='neutral'>            if (to.code.length != 0) {</span>
  942 |     | <span class='neutral'>                uint256 end = _currentIndex;</span>
  943 |     | <span class='neutral'>                uint256 index = end - quantity;</span>
  944 |     | <span class='neutral'>                do {</span>
  945 |     | <span class='neutral'>                    if (!_checkContractOnERC721Received(address(0), to, index++, _data)) {</span>
  946 |     | <span class='neutral'>                        _revert(TransferToNonERC721ReceiverImplementer.selector);</span>
  947 |     | <span class='neutral'>                    }</span>
  948 |     | <span class='neutral'>                } while (index &lt; end);</span>
  949 |     | <span class='neutral'>                // This prevents reentrancy to `_safeMint`.</span>
  950 |     | <span class='neutral'>                // It does not prevent reentrancy to `_safeMintSpot`.</span>
  951 |     | <span class='neutral'>                if (_currentIndex != end) revert();</span>
  952 |     | <span class='neutral'>            }</span>
  953 |     | <span class='neutral'>        }</span>
  954 |     | <span class='neutral'>    }</span>
  955 |     | <span class='neutral'></span>
  956 |     | <span class='neutral'>    /**</span>
  957 |     | <span class='neutral'>     * @dev Equivalent to `_safeMint(to, quantity, &#39;&#39;)`.</span>
  958 |     | <span class='neutral'>     */</span>
  959 |     | <span class='neutral'>    function _safeMint(address to, uint256 quantity) internal virtual {</span>
  960 |     | <span class='neutral'>        _safeMint(to, quantity, &#39;&#39;);</span>
  961 |     | <span class='neutral'>    }</span>
  962 |     | <span class='neutral'></span>
  963 |     | <span class='neutral'>    /**</span>
  964 |     | <span class='neutral'>     * @dev Mints a single token at `tokenId`.</span>
  965 |     | <span class='neutral'>     *</span>
  966 |     | <span class='neutral'>     * Note: A spot-minted `tokenId` that has been burned can be re-minted again.</span>
  967 |     | <span class='neutral'>     *</span>
  968 |     | <span class='neutral'>     * Requirements:</span>
  969 |     | <span class='neutral'>     *</span>
  970 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
  971 |     | <span class='neutral'>     * - `tokenId` must be greater than `_sequentialUpTo()`.</span>
  972 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
  973 |     | <span class='neutral'>     *</span>
  974 |     | <span class='neutral'>     * Emits a {Transfer} event for each mint.</span>
  975 |     | <span class='neutral'>     */</span>
  976 |     | <span class='neutral'>    function _mintSpot(address to, uint256 tokenId) internal virtual {</span>
  977 |     | <span class='neutral'>        if (tokenId &lt;= _sequentialUpTo()) _revert(SpotMintTokenIdTooSmall.selector);</span>
  978 |     | <span class='neutral'>        uint256 prevOwnershipPacked = _packedOwnerships[tokenId];</span>
  979 |     | <span class='neutral'>        if (_packedOwnershipExists(prevOwnershipPacked)) _revert(TokenAlreadyExists.selector);</span>
  980 |     | <span class='neutral'></span>
  981 |     | <span class='neutral'>        _beforeTokenTransfers(address(0), to, tokenId, 1);</span>
  982 |     | <span class='neutral'></span>
  983 |     | <span class='neutral'>        // Overflows are incredibly unrealistic.</span>
  984 |     | <span class='neutral'>        // The `numberMinted` for `to` is incremented by 1, and has a max limit of 2**64 - 1.</span>
  985 |     | <span class='neutral'>        // `_spotMinted` is incremented by 1, and has a max limit of 2**256 - 1.</span>
  986 |     | <span class='neutral'>        unchecked {</span>
  987 |     | <span class='neutral'>            // Updates:</span>
  988 |     | <span class='neutral'>            // - `address` to the owner.</span>
  989 |     | <span class='neutral'>            // - `startTimestamp` to the timestamp of minting.</span>
  990 |     | <span class='neutral'>            // - `burned` to `false`.</span>
  991 |     | <span class='neutral'>            // - `nextInitialized` to `true` (as `quantity == 1`).</span>
  992 |     | <span class='neutral'>            _packedOwnerships[tokenId] = _packOwnershipData(</span>
  993 |     | <span class='neutral'>                to,</span>
  994 |     | <span class='neutral'>                _nextInitializedFlag(1) | _nextExtraData(address(0), to, prevOwnershipPacked)</span>
  995 |     | <span class='neutral'>            );</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>            // Updates:</span>
  998 |     | <span class='neutral'>            // - `balance += 1`.</span>
  999 |     | <span class='neutral'>            // - `numberMinted += 1`.</span>
 1000 |     | <span class='neutral'>            //</span>
 1001 |     | <span class='neutral'>            // We can directly add to the `balance` and `numberMinted`.</span>
 1002 |     | <span class='neutral'>            _packedAddressData[to] += (1 &lt;&lt; _BITPOS_NUMBER_MINTED) | 1;</span>
 1003 |     | <span class='neutral'></span>
 1004 |     | <span class='neutral'>            // Mask `to` to the lower 160 bits, in case the upper bits somehow aren&#39;t clean.</span>
 1005 |     | <span class='neutral'>            uint256 toMasked = uint256(uint160(to)) &amp; _BITMASK_ADDRESS;</span>
 1006 |     | <span class='neutral'></span>
 1007 |     | <span class='neutral'>            if (toMasked == 0) _revert(MintToZeroAddress.selector);</span>
 1008 |     | <span class='neutral'></span>
 1009 |     | <span class='neutral'>            assembly {</span>
 1010 |     | <span class='neutral'>                // Emit the `Transfer` event.</span>
 1011 |     | <span class='neutral'>                log4(</span>
 1012 |     | <span class='neutral'>                    0, // Start of data (0, since no data).</span>
 1013 |     | <span class='neutral'>                    0, // End of data (0, since no data).</span>
 1014 |     | <span class='neutral'>                    _TRANSFER_EVENT_SIGNATURE, // Signature.</span>
 1015 |     | <span class='neutral'>                    0, // `address(0)`.</span>
 1016 |     | <span class='neutral'>                    toMasked, // `to`.</span>
 1017 |     | <span class='neutral'>                    tokenId // `tokenId`.</span>
 1018 |     | <span class='neutral'>                )</span>
 1019 |     | <span class='neutral'>            }</span>
 1020 |     | <span class='neutral'></span>
 1021 |     | <span class='neutral'>            ++_spotMinted;</span>
 1022 |     | <span class='neutral'>        }</span>
 1023 |     | <span class='neutral'></span>
 1024 |     | <span class='neutral'>        _afterTokenTransfers(address(0), to, tokenId, 1);</span>
 1025 |     | <span class='neutral'>    }</span>
 1026 |     | <span class='neutral'></span>
 1027 |     | <span class='neutral'>    /**</span>
 1028 |     | <span class='neutral'>     * @dev Safely mints a single token at `tokenId`.</span>
 1029 |     | <span class='neutral'>     *</span>
 1030 |     | <span class='neutral'>     * Note: A spot-minted `tokenId` that has been burned can be re-minted again.</span>
 1031 |     | <span class='neutral'>     *</span>
 1032 |     | <span class='neutral'>     * Requirements:</span>
 1033 |     | <span class='neutral'>     *</span>
 1034 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}.</span>
 1035 |     | <span class='neutral'>     * - `tokenId` must be greater than `_sequentialUpTo()`.</span>
 1036 |     | <span class='neutral'>     * - `tokenId` must not exist.</span>
 1037 |     | <span class='neutral'>     *</span>
 1038 |     | <span class='neutral'>     * See {_mintSpot}.</span>
 1039 |     | <span class='neutral'>     *</span>
 1040 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 1041 |     | <span class='neutral'>     */</span>
 1042 |     | <span class='neutral'>    function _safeMintSpot(</span>
 1043 |     | <span class='neutral'>        address to,</span>
 1044 |     | <span class='neutral'>        uint256 tokenId,</span>
 1045 |     | <span class='neutral'>        bytes memory _data</span>
 1046 |     | <span class='neutral'>    ) internal virtual {</span>
 1047 |     | <span class='neutral'>        _mintSpot(to, tokenId);</span>
 1048 |     | <span class='neutral'></span>
 1049 |     | <span class='neutral'>        unchecked {</span>
 1050 |     | <span class='neutral'>            if (to.code.length != 0) {</span>
 1051 |     | <span class='neutral'>                uint256 currentSpotMinted = _spotMinted;</span>
 1052 |     | <span class='neutral'>                if (!_checkContractOnERC721Received(address(0), to, tokenId, _data)) {</span>
 1053 |     | <span class='neutral'>                    _revert(TransferToNonERC721ReceiverImplementer.selector);</span>
 1054 |     | <span class='neutral'>                }</span>
 1055 |     | <span class='neutral'>                // This prevents reentrancy to `_safeMintSpot`.</span>
 1056 |     | <span class='neutral'>                // It does not prevent reentrancy to `_safeMint`.</span>
 1057 |     | <span class='neutral'>                if (_spotMinted != currentSpotMinted) revert();</span>
 1058 |     | <span class='neutral'>            }</span>
 1059 |     | <span class='neutral'>        }</span>
 1060 |     | <span class='neutral'>    }</span>
 1061 |     | <span class='neutral'></span>
 1062 |     | <span class='neutral'>    /**</span>
 1063 |     | <span class='neutral'>     * @dev Equivalent to `_safeMintSpot(to, tokenId, &#39;&#39;)`.</span>
 1064 |     | <span class='neutral'>     */</span>
 1065 |     | <span class='neutral'>    function _safeMintSpot(address to, uint256 tokenId) internal virtual {</span>
 1066 |     | <span class='neutral'>        _safeMintSpot(to, tokenId, &#39;&#39;);</span>
 1067 |     | <span class='neutral'>    }</span>
 1068 |     | <span class='neutral'></span>
 1069 |     | <span class='neutral'>    // =============================================================</span>
 1070 |     | <span class='neutral'>    //                       APPROVAL OPERATIONS</span>
 1071 |     | <span class='neutral'>    // =============================================================</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>    /**</span>
 1074 |     | <span class='neutral'>     * @dev Equivalent to `_approve(to, tokenId, false)`.</span>
 1075 |     | <span class='neutral'>     */</span>
 1076 |     | <span class='neutral'>    function _approve(address to, uint256 tokenId) internal virtual {</span>
 1077 |     | <span class='neutral'>        _approve(to, tokenId, false);</span>
 1078 |     | <span class='neutral'>    }</span>
 1079 |     | <span class='neutral'></span>
 1080 |     | <span class='neutral'>    /**</span>
 1081 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
 1082 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
 1083 |     | <span class='neutral'>     *</span>
 1084 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the</span>
 1085 |     | <span class='neutral'>     * zero address clears previous approvals.</span>
 1086 |     | <span class='neutral'>     *</span>
 1087 |     | <span class='neutral'>     * Requirements:</span>
 1088 |     | <span class='neutral'>     *</span>
 1089 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 1090 |     | <span class='neutral'>     *</span>
 1091 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 1092 |     | <span class='neutral'>     */</span>
 1093 |     | <span class='unexecuted'>    function _approve(</span>
 1094 |     | <span class='neutral'>        address to,</span>
 1095 |     | <span class='neutral'>        uint256 tokenId,</span>
 1096 |     | <span class='neutral'>        bool approvalCheck</span>
 1097 |     | <span class='unexecuted'>    ) internal virtual {</span>
 1098 |     | <span class='unexecuted'>        address owner = ownerOf(tokenId);</span>
 1099 |     | <span class='neutral'></span>
 1100 |     | <span class='unexecuted'>        if (approvalCheck &amp;&amp; _msgSenderERC721A() != owner)</span>
 1101 |     | <span class='unexecuted'>            if (!isApprovedForAll(owner, _msgSenderERC721A())) {</span>
 1102 |     | <span class='unexecuted'>                _revert(ApprovalCallerNotOwnerNorApproved.selector);</span>
 1103 |     | <span class='neutral'>            }</span>
 1104 |     | <span class='neutral'></span>
 1105 |     | <span class='unexecuted'>        _tokenApprovals[tokenId].value = to;</span>
 1106 |     | <span class='unexecuted'>        emit Approval(owner, to, tokenId);</span>
 1107 |     | <span class='neutral'>    }</span>
 1108 |     | <span class='neutral'></span>
 1109 |     | <span class='neutral'>    // =============================================================</span>
 1110 |     | <span class='neutral'>    //                        BURN OPERATIONS</span>
 1111 |     | <span class='neutral'>    // =============================================================</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='neutral'>    /**</span>
 1114 |     | <span class='neutral'>     * @dev Equivalent to `_burn(tokenId, false)`.</span>
 1115 |     | <span class='neutral'>     */</span>
 1116 |     | <span class='neutral'>    function _burn(uint256 tokenId) internal virtual {</span>
 1117 |     | <span class='neutral'>        _burn(tokenId, false);</span>
 1118 |     | <span class='neutral'>    }</span>
 1119 |     | <span class='neutral'></span>
 1120 |     | <span class='neutral'>    /**</span>
 1121 |     | <span class='neutral'>     * @dev Destroys `tokenId`.</span>
 1122 |     | <span class='neutral'>     * The approval is cleared when the token is burned.</span>
 1123 |     | <span class='neutral'>     *</span>
 1124 |     | <span class='neutral'>     * Requirements:</span>
 1125 |     | <span class='neutral'>     *</span>
 1126 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 1127 |     | <span class='neutral'>     *</span>
 1128 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 1129 |     | <span class='neutral'>     */</span>
 1130 |     | <span class='neutral'>    function _burn(uint256 tokenId, bool approvalCheck) internal virtual {</span>
 1131 |     | <span class='neutral'>        uint256 prevOwnershipPacked = _packedOwnershipOf(tokenId);</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>        address from = address(uint160(prevOwnershipPacked));</span>
 1134 |     | <span class='neutral'></span>
 1135 |     | <span class='neutral'>        (uint256 approvedAddressSlot, address approvedAddress) = _getApprovedSlotAndAddress(tokenId);</span>
 1136 |     | <span class='neutral'></span>
 1137 |     | <span class='neutral'>        if (approvalCheck) {</span>
 1138 |     | <span class='neutral'>            // The nested ifs save around 20+ gas over a compound boolean condition.</span>
 1139 |     | <span class='neutral'>            if (!_isSenderApprovedOrOwner(approvedAddress, from, _msgSenderERC721A()))</span>
 1140 |     | <span class='neutral'>                if (!isApprovedForAll(from, _msgSenderERC721A())) _revert(TransferCallerNotOwnerNorApproved.selector);</span>
 1141 |     | <span class='neutral'>        }</span>
 1142 |     | <span class='neutral'></span>
 1143 |     | <span class='neutral'>        _beforeTokenTransfers(from, address(0), tokenId, 1);</span>
 1144 |     | <span class='neutral'></span>
 1145 |     | <span class='neutral'>        // Clear approvals from the previous owner.</span>
 1146 |     | <span class='neutral'>        assembly {</span>
 1147 |     | <span class='neutral'>            if approvedAddress {</span>
 1148 |     | <span class='neutral'>                // This is equivalent to `delete _tokenApprovals[tokenId]`.</span>
 1149 |     | <span class='neutral'>                sstore(approvedAddressSlot, 0)</span>
 1150 |     | <span class='neutral'>            }</span>
 1151 |     | <span class='neutral'>        }</span>
 1152 |     | <span class='neutral'></span>
 1153 |     | <span class='neutral'>        // Underflow of the sender&#39;s balance is impossible because we check for</span>
 1154 |     | <span class='neutral'>        // ownership above and the recipient&#39;s balance can&#39;t realistically overflow.</span>
 1155 |     | <span class='neutral'>        // Counter overflow is incredibly unrealistic as `tokenId` would have to be 2**256.</span>
 1156 |     | <span class='neutral'>        unchecked {</span>
 1157 |     | <span class='neutral'>            // Updates:</span>
 1158 |     | <span class='neutral'>            // - `balance -= 1`.</span>
 1159 |     | <span class='neutral'>            // - `numberBurned += 1`.</span>
 1160 |     | <span class='neutral'>            //</span>
 1161 |     | <span class='neutral'>            // We can directly decrement the balance, and increment the number burned.</span>
 1162 |     | <span class='neutral'>            // This is equivalent to `packed -= 1; packed += 1 &lt;&lt; _BITPOS_NUMBER_BURNED;`.</span>
 1163 |     | <span class='neutral'>            _packedAddressData[from] += (1 &lt;&lt; _BITPOS_NUMBER_BURNED) - 1;</span>
 1164 |     | <span class='neutral'></span>
 1165 |     | <span class='neutral'>            // Updates:</span>
 1166 |     | <span class='neutral'>            // - `address` to the last owner.</span>
 1167 |     | <span class='neutral'>            // - `startTimestamp` to the timestamp of burning.</span>
 1168 |     | <span class='neutral'>            // - `burned` to `true`.</span>
 1169 |     | <span class='neutral'>            // - `nextInitialized` to `true`.</span>
 1170 |     | <span class='neutral'>            _packedOwnerships[tokenId] = _packOwnershipData(</span>
 1171 |     | <span class='neutral'>                from,</span>
 1172 |     | <span class='neutral'>                (_BITMASK_BURNED | _BITMASK_NEXT_INITIALIZED) | _nextExtraData(from, address(0), prevOwnershipPacked)</span>
 1173 |     | <span class='neutral'>            );</span>
 1174 |     | <span class='neutral'></span>
 1175 |     | <span class='neutral'>            // If the next slot may not have been initialized (i.e. `nextInitialized == false`) .</span>
 1176 |     | <span class='neutral'>            if (prevOwnershipPacked &amp; _BITMASK_NEXT_INITIALIZED == 0) {</span>
 1177 |     | <span class='neutral'>                uint256 nextTokenId = tokenId + 1;</span>
 1178 |     | <span class='neutral'>                // If the next slot&#39;s address is zero and not burned (i.e. packed value is zero).</span>
 1179 |     | <span class='neutral'>                if (_packedOwnerships[nextTokenId] == 0) {</span>
 1180 |     | <span class='neutral'>                    // If the next slot is within bounds.</span>
 1181 |     | <span class='neutral'>                    if (nextTokenId != _currentIndex) {</span>
 1182 |     | <span class='neutral'>                        // Initialize the next slot to maintain correctness for `ownerOf(tokenId + 1)`.</span>
 1183 |     | <span class='neutral'>                        _packedOwnerships[nextTokenId] = prevOwnershipPacked;</span>
 1184 |     | <span class='neutral'>                    }</span>
 1185 |     | <span class='neutral'>                }</span>
 1186 |     | <span class='neutral'>            }</span>
 1187 |     | <span class='neutral'>        }</span>
 1188 |     | <span class='neutral'></span>
 1189 |     | <span class='neutral'>        emit Transfer(from, address(0), tokenId);</span>
 1190 |     | <span class='neutral'>        _afterTokenTransfers(from, address(0), tokenId, 1);</span>
 1191 |     | <span class='neutral'></span>
 1192 |     | <span class='neutral'>        // Overflow not possible, as `_burnCounter` cannot be exceed `_currentIndex + _spotMinted` times.</span>
 1193 |     | <span class='neutral'>        unchecked {</span>
 1194 |     | <span class='neutral'>            _burnCounter++;</span>
 1195 |     | <span class='neutral'>        }</span>
 1196 |     | <span class='neutral'>    }</span>
 1197 |     | <span class='neutral'></span>
 1198 |     | <span class='neutral'>    // =============================================================</span>
 1199 |     | <span class='neutral'>    //                     EXTRA DATA OPERATIONS</span>
 1200 |     | <span class='neutral'>    // =============================================================</span>
 1201 |     | <span class='neutral'></span>
 1202 |     | <span class='neutral'>    /**</span>
 1203 |     | <span class='neutral'>     * @dev Directly sets the extra data for the ownership data `index`.</span>
 1204 |     | <span class='neutral'>     */</span>
 1205 |     | <span class='neutral'>    function _setExtraDataAt(uint256 index, uint24 extraData) internal virtual {</span>
 1206 |     | <span class='neutral'>        uint256 packed = _packedOwnerships[index];</span>
 1207 |     | <span class='neutral'>        if (packed == 0) _revert(OwnershipNotInitializedForExtraData.selector);</span>
 1208 |     | <span class='neutral'>        uint256 extraDataCasted;</span>
 1209 |     | <span class='neutral'>        // Cast `extraData` with assembly to avoid redundant masking.</span>
 1210 |     | <span class='neutral'>        assembly {</span>
 1211 |     | <span class='neutral'>            extraDataCasted := extraData</span>
 1212 |     | <span class='neutral'>        }</span>
 1213 |     | <span class='neutral'>        packed = (packed &amp; _BITMASK_EXTRA_DATA_COMPLEMENT) | (extraDataCasted &lt;&lt; _BITPOS_EXTRA_DATA);</span>
 1214 |     | <span class='neutral'>        _packedOwnerships[index] = packed;</span>
 1215 |     | <span class='neutral'>    }</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='neutral'>    /**</span>
 1218 |     | <span class='neutral'>     * @dev Called during each token transfer to set the 24bit `extraData` field.</span>
 1219 |     | <span class='neutral'>     * Intended to be overridden by the cosumer contract.</span>
 1220 |     | <span class='neutral'>     *</span>
 1221 |     | <span class='neutral'>     * `previousExtraData` - the value of `extraData` before transfer.</span>
 1222 |     | <span class='neutral'>     *</span>
 1223 |     | <span class='neutral'>     * Calling conditions:</span>
 1224 |     | <span class='neutral'>     *</span>
 1225 |     | <span class='neutral'>     * - When `from` and `to` are both non-zero, `from`&#39;s `tokenId` will be</span>
 1226 |     | <span class='neutral'>     * transferred to `to`.</span>
 1227 |     | <span class='neutral'>     * - When `from` is zero, `tokenId` will be minted for `to`.</span>
 1228 |     | <span class='neutral'>     * - When `to` is zero, `tokenId` will be burned by `from`.</span>
 1229 |     | <span class='neutral'>     * - `from` and `to` are never both zero.</span>
 1230 |     | <span class='neutral'>     */</span>
 1231 |     | <span class='neutral'>    function _extraData(</span>
 1232 |     | <span class='neutral'>        address from,</span>
 1233 |     | <span class='neutral'>        address to,</span>
 1234 |     | <span class='neutral'>        uint24 previousExtraData</span>
 1235 |     | <span class='neutral'>    ) internal view virtual returns (uint24) {}</span>
 1236 |     | <span class='neutral'></span>
 1237 |     | <span class='neutral'>    /**</span>
 1238 |     | <span class='neutral'>     * @dev Returns the next extra data for the packed ownership data.</span>
 1239 |     | <span class='neutral'>     * The returned result is shifted into position.</span>
 1240 |     | <span class='neutral'>     */</span>
 1241 |     | <span class='neutral'>    function _nextExtraData(</span>
 1242 |     | <span class='neutral'>        address from,</span>
 1243 |     | <span class='neutral'>        address to,</span>
 1244 |     | <span class='neutral'>        uint256 prevOwnershipPacked</span>
 1245 |     | <span class='neutral'>    ) private view returns (uint256) {</span>
 1246 |     | <span class='neutral'>        uint24 extraData = uint24(prevOwnershipPacked &gt;&gt; _BITPOS_EXTRA_DATA);</span>
 1247 |     | <span class='neutral'>        return uint256(_extraData(from, to, extraData)) &lt;&lt; _BITPOS_EXTRA_DATA;</span>
 1248 |     | <span class='neutral'>    }</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>    // =============================================================</span>
 1251 |     | <span class='neutral'>    //                       OTHER OPERATIONS</span>
 1252 |     | <span class='neutral'>    // =============================================================</span>
 1253 |     | <span class='neutral'></span>
 1254 |     | <span class='neutral'>    /**</span>
 1255 |     | <span class='neutral'>     * @dev Returns the message sender (defaults to `msg.sender`).</span>
 1256 |     | <span class='neutral'>     *</span>
 1257 |     | <span class='neutral'>     * If you are writing GSN compatible contracts, you need to override this function.</span>
 1258 |     | <span class='neutral'>     */</span>
 1259 |     | <span class='neutral'>    function _msgSenderERC721A() internal view virtual returns (address) {</span>
 1260 |     | <span class='unexecuted'>        return msg.sender;</span>
 1261 |     | <span class='neutral'>    }</span>
 1262 |     | <span class='neutral'></span>
 1263 |     | <span class='neutral'>    /**</span>
 1264 |     | <span class='neutral'>     * @dev Converts a uint256 to its ASCII string decimal representation.</span>
 1265 |     | <span class='neutral'>     */</span>
 1266 |     | <span class='unexecuted'>    function _toString(uint256 value) internal pure virtual returns (string memory str) {</span>
 1267 |     | <span class='neutral'>        assembly {</span>
 1268 |     | <span class='neutral'>            // The maximum value of a uint256 contains 78 digits (1 byte per digit), but</span>
 1269 |     | <span class='neutral'>            // we allocate 0xa0 bytes to keep the free memory pointer 32-byte word aligned.</span>
 1270 |     | <span class='neutral'>            // We will need 1 word for the trailing zeros padding, 1 word for the length,</span>
 1271 |     | <span class='neutral'>            // and 3 words for a maximum of 78 digits. Total: 5 * 0x20 = 0xa0.</span>
 1272 |     | <span class='unexecuted'>            let m := add(mload(0x40), 0xa0)</span>
 1273 |     | <span class='neutral'>            // Update the free memory pointer to allocate.</span>
 1274 |     | <span class='unexecuted'>            mstore(0x40, m)</span>
 1275 |     | <span class='neutral'>            // Assign the `str` to the end.</span>
 1276 |     | <span class='unexecuted'>            str := sub(m, 0x20)</span>
 1277 |     | <span class='neutral'>            // Zeroize the slot after the string.</span>
 1278 |     | <span class='unexecuted'>            mstore(str, 0)</span>
 1279 |     | <span class='neutral'></span>
 1280 |     | <span class='neutral'>            // Cache the end of the memory to calculate the length later.</span>
 1281 |     | <span class='unexecuted'>            let end := str</span>
 1282 |     | <span class='neutral'></span>
 1283 |     | <span class='neutral'>            // We write the string from rightmost digit to leftmost digit.</span>
 1284 |     | <span class='neutral'>            // The following is essentially a do-while loop that also handles the zero case.</span>
 1285 |     | <span class='neutral'>            // prettier-ignore</span>
 1286 |     | <span class='unexecuted'>            for { let temp := value } 1 {} {</span>
 1287 |     | <span class='unexecuted'>                str := sub(str, 1)</span>
 1288 |     | <span class='neutral'>                // Write the character to the pointer.</span>
 1289 |     | <span class='neutral'>                // The ASCII index of the &#39;0&#39; character is 48.</span>
 1290 |     | <span class='unexecuted'>                mstore8(str, add(48, mod(temp, 10)))</span>
 1291 |     | <span class='neutral'>                // Keep dividing `temp` until zero.</span>
 1292 |     | <span class='unexecuted'>                temp := div(temp, 10)</span>
 1293 |     | <span class='neutral'>                // prettier-ignore</span>
 1294 |     | <span class='unexecuted'>                if iszero(temp) { break }</span>
 1295 |     | <span class='neutral'>            }</span>
 1296 |     | <span class='neutral'></span>
 1297 |     | <span class='unexecuted'>            let length := sub(end, str)</span>
 1298 |     | <span class='neutral'>            // Move the pointer 32 bytes leftwards to make room for the length.</span>
 1299 |     | <span class='unexecuted'>            str := sub(str, 0x20)</span>
 1300 |     | <span class='neutral'>            // Store the length.</span>
 1301 |     | <span class='unexecuted'>            mstore(str, length)</span>
 1302 |     | <span class='neutral'>        }</span>
 1303 |     | <span class='neutral'>    }</span>
 1304 |     | <span class='neutral'></span>
 1305 |     | <span class='neutral'>    /**</span>
 1306 |     | <span class='neutral'>     * @dev For more efficient reverts.</span>
 1307 |     | <span class='neutral'>     */</span>
 1308 |     | <span class='unexecuted'>    function _revert(bytes4 errorSelector) internal pure {</span>
 1309 |     | <span class='neutral'>        assembly {</span>
 1310 |     | <span class='unexecuted'>            mstore(0x00, errorSelector)</span>
 1311 |     | <span class='unexecuted'>            revert(0x00, 0x04)</span>
 1312 |     | <span class='neutral'>        }</span>
 1313 |     | <span class='neutral'>    }</span>
 1314 |     | <span class='neutral'>}</span>
 1315 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/node_modules/erc721a/contracts/IERC721A.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>// ERC721A Contracts v4.3.0</span>
   3 |     | <span class='neutral'>// Creator: Chiru Labs</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>pragma solidity ^0.8.4;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/**</span>
   8 |     | <span class='neutral'> * @dev Interface of ERC721A.</span>
   9 |     | <span class='neutral'> */</span>
  10 |     | <span class='neutral'>interface IERC721A {</span>
  11 |     | <span class='neutral'>    /**</span>
  12 |     | <span class='neutral'>     * The caller must own the token or be an approved operator.</span>
  13 |     | <span class='neutral'>     */</span>
  14 |     | <span class='neutral'>    error ApprovalCallerNotOwnerNorApproved();</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    /**</span>
  17 |     | <span class='neutral'>     * The token does not exist.</span>
  18 |     | <span class='neutral'>     */</span>
  19 |     | <span class='neutral'>    error ApprovalQueryForNonexistentToken();</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    /**</span>
  22 |     | <span class='neutral'>     * Cannot query the balance for the zero address.</span>
  23 |     | <span class='neutral'>     */</span>
  24 |     | <span class='neutral'>    error BalanceQueryForZeroAddress();</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    /**</span>
  27 |     | <span class='neutral'>     * Cannot mint to the zero address.</span>
  28 |     | <span class='neutral'>     */</span>
  29 |     | <span class='neutral'>    error MintToZeroAddress();</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /**</span>
  32 |     | <span class='neutral'>     * The quantity of tokens minted must be more than zero.</span>
  33 |     | <span class='neutral'>     */</span>
  34 |     | <span class='neutral'>    error MintZeroQuantity();</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    /**</span>
  37 |     | <span class='neutral'>     * The token does not exist.</span>
  38 |     | <span class='neutral'>     */</span>
  39 |     | <span class='neutral'>    error OwnerQueryForNonexistentToken();</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /**</span>
  42 |     | <span class='neutral'>     * The caller must own the token or be an approved operator.</span>
  43 |     | <span class='neutral'>     */</span>
  44 |     | <span class='neutral'>    error TransferCallerNotOwnerNorApproved();</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /**</span>
  47 |     | <span class='neutral'>     * The token must be owned by `from`.</span>
  48 |     | <span class='neutral'>     */</span>
  49 |     | <span class='neutral'>    error TransferFromIncorrectOwner();</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /**</span>
  52 |     | <span class='neutral'>     * Cannot safely transfer to a contract that does not implement the</span>
  53 |     | <span class='neutral'>     * ERC721Receiver interface.</span>
  54 |     | <span class='neutral'>     */</span>
  55 |     | <span class='neutral'>    error TransferToNonERC721ReceiverImplementer();</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    /**</span>
  58 |     | <span class='neutral'>     * Cannot transfer to the zero address.</span>
  59 |     | <span class='neutral'>     */</span>
  60 |     | <span class='neutral'>    error TransferToZeroAddress();</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    /**</span>
  63 |     | <span class='neutral'>     * The token does not exist.</span>
  64 |     | <span class='neutral'>     */</span>
  65 |     | <span class='neutral'>    error URIQueryForNonexistentToken();</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /**</span>
  68 |     | <span class='neutral'>     * The `quantity` minted with ERC2309 exceeds the safety limit.</span>
  69 |     | <span class='neutral'>     */</span>
  70 |     | <span class='neutral'>    error MintERC2309QuantityExceedsLimit();</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /**</span>
  73 |     | <span class='neutral'>     * The `extraData` cannot be set on an unintialized ownership slot.</span>
  74 |     | <span class='neutral'>     */</span>
  75 |     | <span class='neutral'>    error OwnershipNotInitializedForExtraData();</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /**</span>
  78 |     | <span class='neutral'>     * `_sequentialUpTo()` must be greater than `_startTokenId()`.</span>
  79 |     | <span class='neutral'>     */</span>
  80 |     | <span class='neutral'>    error SequentialUpToTooSmall();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /**</span>
  83 |     | <span class='neutral'>     * The `tokenId` of a sequential mint exceeds `_sequentialUpTo()`.</span>
  84 |     | <span class='neutral'>     */</span>
  85 |     | <span class='neutral'>    error SequentialMintExceedsLimit();</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='neutral'>    /**</span>
  88 |     | <span class='neutral'>     * Spot minting requires a `tokenId` greater than `_sequentialUpTo()`.</span>
  89 |     | <span class='neutral'>     */</span>
  90 |     | <span class='neutral'>    error SpotMintTokenIdTooSmall();</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /**</span>
  93 |     | <span class='neutral'>     * Cannot mint over a token that already exists.</span>
  94 |     | <span class='neutral'>     */</span>
  95 |     | <span class='neutral'>    error TokenAlreadyExists();</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /**</span>
  98 |     | <span class='neutral'>     * The feature is not compatible with spot mints.</span>
  99 |     | <span class='neutral'>     */</span>
 100 |     | <span class='neutral'>    error NotCompatibleWithSpotMints();</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='neutral'>    // =============================================================</span>
 103 |     | <span class='neutral'>    //                            STRUCTS</span>
 104 |     | <span class='neutral'>    // =============================================================</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    struct TokenOwnership {</span>
 107 |     | <span class='neutral'>        // The address of the owner.</span>
 108 |     | <span class='neutral'>        address addr;</span>
 109 |     | <span class='neutral'>        // Stores the start time of ownership with minimal overhead for tokenomics.</span>
 110 |     | <span class='neutral'>        uint64 startTimestamp;</span>
 111 |     | <span class='neutral'>        // Whether the token has been burned.</span>
 112 |     | <span class='neutral'>        bool burned;</span>
 113 |     | <span class='neutral'>        // Arbitrary data similar to `startTimestamp` that can be set via {_extraData}.</span>
 114 |     | <span class='neutral'>        uint24 extraData;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>    // =============================================================</span>
 118 |     | <span class='neutral'>    //                         TOKEN COUNTERS</span>
 119 |     | <span class='neutral'>    // =============================================================</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='neutral'>    /**</span>
 122 |     | <span class='neutral'>     * @dev Returns the total number of tokens in existence.</span>
 123 |     | <span class='neutral'>     * Burned tokens will reduce the count.</span>
 124 |     | <span class='neutral'>     * To get the total number of tokens minted, please see {_totalMinted}.</span>
 125 |     | <span class='neutral'>     */</span>
 126 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    // =============================================================</span>
 129 |     | <span class='neutral'>    //                            IERC165</span>
 130 |     | <span class='neutral'>    // =============================================================</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /**</span>
 133 |     | <span class='neutral'>     * @dev Returns true if this contract implements the interface defined by</span>
 134 |     | <span class='neutral'>     * `interfaceId`. See the corresponding</span>
 135 |     | <span class='neutral'>     * [EIP section](https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified)</span>
 136 |     | <span class='neutral'>     * to learn more about how these ids are created.</span>
 137 |     | <span class='neutral'>     *</span>
 138 |     | <span class='neutral'>     * This function call must use less than 30000 gas.</span>
 139 |     | <span class='neutral'>     */</span>
 140 |     | <span class='neutral'>    function supportsInterface(bytes4 interfaceId) external view returns (bool);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    // =============================================================</span>
 143 |     | <span class='neutral'>    //                            IERC721</span>
 144 |     | <span class='neutral'>    // =============================================================</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    /**</span>
 147 |     | <span class='neutral'>     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.</span>
 148 |     | <span class='neutral'>     */</span>
 149 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);</span>
 150 |     | <span class='neutral'></span>
 151 |     | <span class='neutral'>    /**</span>
 152 |     | <span class='neutral'>     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.</span>
 153 |     | <span class='neutral'>     */</span>
 154 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    /**</span>
 157 |     | <span class='neutral'>     * @dev Emitted when `owner` enables or disables</span>
 158 |     | <span class='neutral'>     * (`approved`) `operator` to manage all of its assets.</span>
 159 |     | <span class='neutral'>     */</span>
 160 |     | <span class='neutral'>    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    /**</span>
 163 |     | <span class='neutral'>     * @dev Returns the number of tokens in `owner`&#39;s account.</span>
 164 |     | <span class='neutral'>     */</span>
 165 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256 balance);</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /**</span>
 168 |     | <span class='neutral'>     * @dev Returns the owner of the `tokenId` token.</span>
 169 |     | <span class='neutral'>     *</span>
 170 |     | <span class='neutral'>     * Requirements:</span>
 171 |     | <span class='neutral'>     *</span>
 172 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 173 |     | <span class='neutral'>     */</span>
 174 |     | <span class='neutral'>    function ownerOf(uint256 tokenId) external view returns (address owner);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /**</span>
 177 |     | <span class='neutral'>     * @dev Safely transfers `tokenId` token from `from` to `to`,</span>
 178 |     | <span class='neutral'>     * checking first that contract recipients are aware of the ERC721 protocol</span>
 179 |     | <span class='neutral'>     * to prevent tokens from being forever locked.</span>
 180 |     | <span class='neutral'>     *</span>
 181 |     | <span class='neutral'>     * Requirements:</span>
 182 |     | <span class='neutral'>     *</span>
 183 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 184 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 185 |     | <span class='neutral'>     * - `tokenId` token must exist and be owned by `from`.</span>
 186 |     | <span class='neutral'>     * - If the caller is not `from`, it must be have been allowed to move</span>
 187 |     | <span class='neutral'>     * this token by either {approve} or {setApprovalForAll}.</span>
 188 |     | <span class='neutral'>     * - If `to` refers to a smart contract, it must implement</span>
 189 |     | <span class='neutral'>     * {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.</span>
 190 |     | <span class='neutral'>     *</span>
 191 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 192 |     | <span class='neutral'>     */</span>
 193 |     | <span class='neutral'>    function safeTransferFrom(</span>
 194 |     | <span class='neutral'>        address from,</span>
 195 |     | <span class='neutral'>        address to,</span>
 196 |     | <span class='neutral'>        uint256 tokenId,</span>
 197 |     | <span class='neutral'>        bytes calldata data</span>
 198 |     | <span class='neutral'>    ) external payable;</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /**</span>
 201 |     | <span class='neutral'>     * @dev Equivalent to `safeTransferFrom(from, to, tokenId, &#39;&#39;)`.</span>
 202 |     | <span class='neutral'>     */</span>
 203 |     | <span class='neutral'>    function safeTransferFrom(</span>
 204 |     | <span class='neutral'>        address from,</span>
 205 |     | <span class='neutral'>        address to,</span>
 206 |     | <span class='neutral'>        uint256 tokenId</span>
 207 |     | <span class='neutral'>    ) external payable;</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    /**</span>
 210 |     | <span class='neutral'>     * @dev Transfers `tokenId` from `from` to `to`.</span>
 211 |     | <span class='neutral'>     *</span>
 212 |     | <span class='neutral'>     * WARNING: Usage of this method is discouraged, use {safeTransferFrom}</span>
 213 |     | <span class='neutral'>     * whenever possible.</span>
 214 |     | <span class='neutral'>     *</span>
 215 |     | <span class='neutral'>     * Requirements:</span>
 216 |     | <span class='neutral'>     *</span>
 217 |     | <span class='neutral'>     * - `from` cannot be the zero address.</span>
 218 |     | <span class='neutral'>     * - `to` cannot be the zero address.</span>
 219 |     | <span class='neutral'>     * - `tokenId` token must be owned by `from`.</span>
 220 |     | <span class='neutral'>     * - If the caller is not `from`, it must be approved to move this token</span>
 221 |     | <span class='neutral'>     * by either {approve} or {setApprovalForAll}.</span>
 222 |     | <span class='neutral'>     *</span>
 223 |     | <span class='neutral'>     * Emits a {Transfer} event.</span>
 224 |     | <span class='neutral'>     */</span>
 225 |     | <span class='neutral'>    function transferFrom(</span>
 226 |     | <span class='neutral'>        address from,</span>
 227 |     | <span class='neutral'>        address to,</span>
 228 |     | <span class='neutral'>        uint256 tokenId</span>
 229 |     | <span class='neutral'>    ) external payable;</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    /**</span>
 232 |     | <span class='neutral'>     * @dev Gives permission to `to` to transfer `tokenId` token to another account.</span>
 233 |     | <span class='neutral'>     * The approval is cleared when the token is transferred.</span>
 234 |     | <span class='neutral'>     *</span>
 235 |     | <span class='neutral'>     * Only a single account can be approved at a time, so approving the</span>
 236 |     | <span class='neutral'>     * zero address clears previous approvals.</span>
 237 |     | <span class='neutral'>     *</span>
 238 |     | <span class='neutral'>     * Requirements:</span>
 239 |     | <span class='neutral'>     *</span>
 240 |     | <span class='neutral'>     * - The caller must own the token or be an approved operator.</span>
 241 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 242 |     | <span class='neutral'>     *</span>
 243 |     | <span class='neutral'>     * Emits an {Approval} event.</span>
 244 |     | <span class='neutral'>     */</span>
 245 |     | <span class='neutral'>    function approve(address to, uint256 tokenId) external payable;</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='neutral'>    /**</span>
 248 |     | <span class='neutral'>     * @dev Approve or remove `operator` as an operator for the caller.</span>
 249 |     | <span class='neutral'>     * Operators can call {transferFrom} or {safeTransferFrom}</span>
 250 |     | <span class='neutral'>     * for any token owned by the caller.</span>
 251 |     | <span class='neutral'>     *</span>
 252 |     | <span class='neutral'>     * Requirements:</span>
 253 |     | <span class='neutral'>     *</span>
 254 |     | <span class='neutral'>     * - The `operator` cannot be the caller.</span>
 255 |     | <span class='neutral'>     *</span>
 256 |     | <span class='neutral'>     * Emits an {ApprovalForAll} event.</span>
 257 |     | <span class='neutral'>     */</span>
 258 |     | <span class='neutral'>    function setApprovalForAll(address operator, bool _approved) external;</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>    /**</span>
 261 |     | <span class='neutral'>     * @dev Returns the account approved for `tokenId` token.</span>
 262 |     | <span class='neutral'>     *</span>
 263 |     | <span class='neutral'>     * Requirements:</span>
 264 |     | <span class='neutral'>     *</span>
 265 |     | <span class='neutral'>     * - `tokenId` must exist.</span>
 266 |     | <span class='neutral'>     */</span>
 267 |     | <span class='neutral'>    function getApproved(uint256 tokenId) external view returns (address operator);</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /**</span>
 270 |     | <span class='neutral'>     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.</span>
 271 |     | <span class='neutral'>     *</span>
 272 |     | <span class='neutral'>     * See {setApprovalForAll}.</span>
 273 |     | <span class='neutral'>     */</span>
 274 |     | <span class='neutral'>    function isApprovedForAll(address owner, address operator) external view returns (bool);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='neutral'>    // =============================================================</span>
 277 |     | <span class='neutral'>    //                        IERC721Metadata</span>
 278 |     | <span class='neutral'>    // =============================================================</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='neutral'>    /**</span>
 281 |     | <span class='neutral'>     * @dev Returns the token collection name.</span>
 282 |     | <span class='neutral'>     */</span>
 283 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>    /**</span>
 286 |     | <span class='neutral'>     * @dev Returns the token collection symbol.</span>
 287 |     | <span class='neutral'>     */</span>
 288 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='neutral'>    /**</span>
 291 |     | <span class='neutral'>     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.</span>
 292 |     | <span class='neutral'>     */</span>
 293 |     | <span class='neutral'>    function tokenURI(uint256 tokenId) external view returns (string memory);</span>
 294 |     | <span class='neutral'></span>
 295 |     | <span class='neutral'>    // =============================================================</span>
 296 |     | <span class='neutral'>    //                           IERC2309</span>
 297 |     | <span class='neutral'>    // =============================================================</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='neutral'>    /**</span>
 300 |     | <span class='neutral'>     * @dev Emitted when tokens in `fromTokenId` to `toTokenId`</span>
 301 |     | <span class='neutral'>     * (inclusive) is transferred from `from` to `to`, as defined in the</span>
 302 |     | <span class='neutral'>     * [ERC2309](https://eips.ethereum.org/EIPS/eip-2309) standard.</span>
 303 |     | <span class='neutral'>     *</span>
 304 |     | <span class='neutral'>     * See {_mintERC2309} for more details.</span>
 305 |     | <span class='neutral'>     */</span>
 306 |     | <span class='neutral'>    event ConsecutiveTransfer(uint256 indexed fromTokenId, uint256 toTokenId, address indexed from, address indexed to);</span>
 307 |     | <span class='neutral'>}</span>
 308 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/FuzzSetup.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// fuzzlib</span>
   5 |     | <span class='neutral'>import {FuzzBase} from &quot;fuzzlib/FuzzBase.sol&quot;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// forge</span>
   8 |     | <span class='neutral'>import {Test} from &quot;forge-std/Test.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>// PEAS</span>
  11 |     | <span class='neutral'>import {PEAS} from &quot;../../contracts/PEAS.sol&quot;;</span>
  12 |     | <span class='neutral'>import {V3TwapUtilities} from &#39;../../contracts/twaputils/V3TwapUtilities.sol&#39;;</span>
  13 |     | <span class='neutral'>import {UniswapDexAdapter} from &#39;../../contracts/dex/UniswapDexAdapter.sol&#39;;</span>
  14 |     | <span class='neutral'>import {IDecentralizedIndex} from &#39;../../contracts/interfaces/IDecentralizedIndex.sol&#39;;</span>
  15 |     | <span class='neutral'>import {WeightedIndex} from &#39;../../contracts/WeightedIndex.sol&#39;;</span>
  16 |     | <span class='neutral'>import {StakingPoolToken} from &quot;../../contracts/StakingPoolToken.sol&quot;; </span>
  17 |     | <span class='neutral'>import {LendingAssetVault} from &quot;../../contracts/LendingAssetVault.sol&quot;;</span>
  18 |     | <span class='neutral'>import {IndexUtils} from &quot;../../contracts/IndexUtils.sol&quot;;</span>
  19 |     | <span class='neutral'>import {IIndexUtils_LEGACY} from &quot;../../contracts/interfaces/IIndexUtils_LEGACY.sol&quot;;</span>
  20 |     | <span class='neutral'>import {MockIndexUtils} from &quot;./mocks/MockIndexUtils.sol&quot;;</span>
  21 |     | <span class='neutral'>import {RewardsWhitelist} from &quot;../../contracts/RewardsWhitelist.sol&quot;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>// oracles</span>
  24 |     | <span class='neutral'>import {ChainlinkSinglePriceOracle} from &quot;../../contracts/oracle/ChainlinkSinglePriceOracle.sol&quot;;</span>
  25 |     | <span class='neutral'>import {UniswapV3SinglePriceOracle} from &quot;../../contracts/oracle/UniswapV3SinglePriceOracle.sol&quot;;</span>
  26 |     | <span class='neutral'>import {V2ReservesUniswap} from &quot;../../contracts/oracle/V2ReservesUniswap.sol&quot;;</span>
  27 |     | <span class='neutral'>import {aspTKNMinimalOracle} from &quot;../../contracts/oracle/aspTKNMinimalOracle.sol&quot;;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>// autocompounding</span>
  30 |     | <span class='neutral'>import {AutoCompoundingPodLpFactory} from &quot;../../contracts/AutoCompoundingPodLpFactory.sol&quot;;</span>
  31 |     | <span class='neutral'>import {AutoCompoundingPodLp} from &quot;../../contracts/AutoCompoundingPodLp.sol&quot;;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>// lvf</span>
  34 |     | <span class='neutral'>import {LeverageManager} from &quot;../../contracts/lvf/LeverageManager.sol&quot;;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>// fraxlend</span>
  37 |     | <span class='neutral'>import {FraxlendPairDeployer, ConstructorParams} from &quot;./modules/fraxlend/FraxlendPairDeployer.sol&quot;;</span>
  38 |     | <span class='neutral'>import {FraxlendWhitelist} from &quot;./modules/fraxlend/FraxlendWhitelist.sol&quot;;</span>
  39 |     | <span class='neutral'>import {FraxlendPairRegistry} from &quot;./modules/fraxlend/FraxlendPairRegistry.sol&quot;;</span>
  40 |     | <span class='neutral'>import {FraxlendPair} from &quot;./modules/fraxlend/FraxlendPair.sol&quot;;</span>
  41 |     | <span class='neutral'>import {VariableInterestRate} from &quot;./modules/fraxlend/VariableInterestRate.sol&quot;;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>// uniswap-v2-core</span>
  44 |     | <span class='neutral'>import {UniswapV2Factory} from &quot;v2-core/UniswapV2Factory.sol&quot;;</span>
  45 |     | <span class='neutral'>import {UniswapV2Pair} from &quot;v2-core/UniswapV2Pair.sol&quot;;</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>// uniswap-v2-periphery</span>
  48 |     | <span class='neutral'>import {UniswapV2Router02} from &quot;v2-periphery/UniswapV2Router02.sol&quot;;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>// uniswap-v3-core</span>
  51 |     | <span class='neutral'>import {UniswapV3Factory} from &quot;v3-core/UniswapV3Factory.sol&quot;;</span>
  52 |     | <span class='neutral'>import {UniswapV3Pool} from &quot;v3-core/UniswapV3Pool.sol&quot;;</span>
  53 |     | <span class='neutral'></span>
  54 |     | <span class='neutral'>// uniswap-v3-periphery</span>
  55 |     | <span class='neutral'>import {SwapRouter} from &quot;v3-periphery/SwapRouter.sol&quot;;</span>
  56 |     | <span class='neutral'>import {LiquidityManagement} from &quot;v3-periphery/base/LiquidityManagement.sol&quot;;</span>
  57 |     | <span class='neutral'>import {PeripheryPayments} from &quot;v3-periphery/base/PeripheryPayments.sol&quot;;</span>
  58 |     | <span class='neutral'>import {PoolAddress} from &quot;v3-periphery/libraries/PoolAddress.sol&quot;;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>// mocks</span>
  62 |     | <span class='neutral'>import {WETH9} from &quot;./mocks/WETH.sol&quot;;</span>
  63 |     | <span class='neutral'>import {IERC20} from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  64 |     | <span class='neutral'>import {MockERC20} from &quot;./mocks/MockERC20.sol&quot;;</span>
  65 |     | <span class='neutral'>import {TestERC20} from &quot;../../contracts/test/TestERC20.sol&quot;;</span>
  66 |     | <span class='neutral'>import {TestERC4626Vault} from &quot;../../contracts/test/TestERC4626Vault.sol&quot;;</span>
  67 |     | <span class='neutral'>import {MockV3Aggregator} from &quot;./mocks/MockV3Aggregator.sol&quot;;</span>
  68 |     | <span class='neutral'>import {MockUniV3Minter} from &quot;./mocks/MockUniV3Minter.sol&quot;;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>contract FuzzSetup is Test, FuzzBase {</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
  73 |     | <span class='neutral'>                            GLOBAL VARIABLES</span>
  74 |     | <span class='neutral'>    ///////////////////////////////////////////////////////////////*/</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // external actors</span>
  77 |     | <span class='unexecuted'>    address internal user0 = vm.addr(uint256(keccak256(&quot;User0&quot;)));</span>
  78 |     | <span class='unexecuted'>    address internal user1 = vm.addr(uint256(keccak256(&quot;User1&quot;)));</span>
  79 |     | <span class='unexecuted'>    address internal user2 = vm.addr(uint256(keccak256(&quot;User2&quot;)));</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='unexecuted'>    address[] internal users = [user0, user1, user2];</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    // fraxlend protocol actors</span>
  84 |     | <span class='unexecuted'>    address internal comptroller = vm.addr(uint256(keccak256(&quot;comptroller&quot;)));</span>
  85 |     | <span class='unexecuted'>    address internal circuitBreaker = vm.addr(uint256(keccak256(&quot;circuitBreaker&quot;)));</span>
  86 |     | <span class='unexecuted'>    address internal timelock = vm.addr(uint256(keccak256(&quot;comptroller&quot;)));</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    uint16 internal fee = 100;</span>
  89 |     | <span class='neutral'></span>
  90 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
  91 |     | <span class='neutral'>                            TEST CONTRACTS</span>
  92 |     | <span class='neutral'>    ///////////////////////////////////////////////////////////////*/</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>    PEAS internal _peas;</span>
  95 |     | <span class='neutral'>    V3TwapUtilities internal _twapUtils;</span>
  96 |     | <span class='neutral'>    UniswapDexAdapter internal _dexAdapter;</span>
  97 |     | <span class='neutral'>    LendingAssetVault internal _lendingAssetVault;</span>
  98 |     | <span class='neutral'>    RewardsWhitelist internal _rewardsWhitelist;</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    // oracles</span>
 101 |     | <span class='neutral'>    V2ReservesUniswap internal _v2Res;</span>
 102 |     | <span class='neutral'>    ChainlinkSinglePriceOracle internal _clOracle;</span>
 103 |     | <span class='neutral'>    UniswapV3SinglePriceOracle internal _uniOracle;</span>
 104 |     | <span class='neutral'>    aspTKNMinimalOracle internal _aspTKNMinOracle1;</span>
 105 |     | <span class='neutral'>    aspTKNMinimalOracle internal _aspTKNMinOracle2;</span>
 106 |     | <span class='neutral'>    aspTKNMinimalOracle internal _aspTKNMinOracle4;</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    // pods</span>
 109 |     | <span class='neutral'>    WeightedIndex internal _pod1; // 1 token</span>
 110 |     | <span class='neutral'>    WeightedIndex internal _pod2; // 2 tokens</span>
 111 |     | <span class='neutral'>    WeightedIndex internal _pod4; // 4 tokens *_*</span>
 112 |     | <span class='neutral'></span>
 113 |     | <span class='neutral'>    WeightedIndex[] internal _pods;</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    // index utils</span>
 116 |     | <span class='neutral'>    MockIndexUtils internal _indexUtils;</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='neutral'>    // autocompounding</span>
 119 |     | <span class='neutral'>    AutoCompoundingPodLpFactory internal _aspTKNFactory;</span>
 120 |     | <span class='neutral'>    AutoCompoundingPodLp internal _aspTKN1;</span>
 121 |     | <span class='neutral'>    address internal _aspTKN1Address;</span>
 122 |     | <span class='neutral'>    AutoCompoundingPodLp internal _aspTKN2;</span>
 123 |     | <span class='neutral'>    address internal _aspTKN2Address;</span>
 124 |     | <span class='neutral'>    AutoCompoundingPodLp internal _aspTKN4;</span>
 125 |     | <span class='neutral'>    address internal _aspTKN4Address;</span>
 126 |     | <span class='neutral'></span>
 127 |     | <span class='neutral'>    AutoCompoundingPodLp[] internal _aspTKNs;</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // lvf </span>
 130 |     | <span class='neutral'>    LeverageManager internal _leverageManager;</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    // fraxlend</span>
 133 |     | <span class='neutral'>    FraxlendPairDeployer internal _fraxDeployer;</span>
 134 |     | <span class='neutral'>    FraxlendWhitelist internal _fraxWhitelist;</span>
 135 |     | <span class='neutral'>    FraxlendPairRegistry internal _fraxRegistry;</span>
 136 |     | <span class='neutral'>    VariableInterestRate internal _variableInterestRate;</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    FraxlendPair internal _fraxLPToken1;</span>
 139 |     | <span class='neutral'>    FraxlendPair internal _fraxLPToken2;</span>
 140 |     | <span class='neutral'>    FraxlendPair internal _fraxLPToken4;</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    FraxlendPair[] internal _fraxPairs;</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    // mocks</span>
 145 |     | <span class='neutral'>    MockUniV3Minter internal _uniV3Minter;</span>
 146 |     | <span class='neutral'>    MockERC20 internal _mockDai;</span>
 147 |     | <span class='neutral'>    WETH9 internal _weth;</span>
 148 |     | <span class='neutral'>    MockERC20 internal _tokenA;</span>
 149 |     | <span class='neutral'>    MockERC20 internal _tokenB;</span>
 150 |     | <span class='neutral'>    MockERC20 internal _tokenC;</span>
 151 |     | <span class='unexecuted'>    address[] internal tokens = [address(_weth), address(_tokenA), address(_tokenB), address(_tokenC)];</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    // mock price feeds</span>
 154 |     | <span class='neutral'>    MockV3Aggregator internal _peasPriceFeed;</span>
 155 |     | <span class='neutral'>    MockV3Aggregator internal _daiPriceFeed;</span>
 156 |     | <span class='neutral'>    MockV3Aggregator internal _wethPriceFeed;</span>
 157 |     | <span class='neutral'>    MockV3Aggregator internal _tokenAPriceFeed;</span>
 158 |     | <span class='neutral'>    MockV3Aggregator internal _tokenBPriceFeed;</span>
 159 |     | <span class='neutral'>    MockV3Aggregator internal _tokenCPriceFeed;</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>    // uniswap-v2-core</span>
 162 |     | <span class='neutral'>    UniswapV2Factory internal _uniV2Factory;</span>
 163 |     | <span class='neutral'>    UniswapV2Pair internal _uniV2Pool;</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    // uniswap-v2-periphery</span>
 166 |     | <span class='neutral'>    UniswapV2Router02 internal _v2SwapRouter;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    // uniswap-v3-core</span>
 169 |     | <span class='neutral'>    UniswapV3Factory internal _uniV3Factory;</span>
 170 |     | <span class='neutral'>    UniswapV3Pool internal _v3peasDaiPool;</span>
 171 |     | <span class='neutral'>    UniswapV3Pool internal _v3wethDaiPool;</span>
 172 |     | <span class='neutral'></span>
 173 |     | <span class='neutral'>    // uniswap=v3-periphery</span>
 174 |     | <span class='neutral'>    SwapRouter internal _v3SwapRouter;</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /*///////////////////////////////////////////////////////////////</span>
 177 |     | <span class='neutral'>                            SETUP FUNCTIONS</span>
 178 |     | <span class='neutral'>    ///////////////////////////////////////////////////////////////*/</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='unexecuted'>    function setup() internal {</span>
 181 |     | <span class='neutral'>        </span>
 182 |     | <span class='unexecuted'>        _deployUniV3Minter();</span>
 183 |     | <span class='unexecuted'>        _deployWETH();</span>
 184 |     | <span class='unexecuted'>        _deployTokens();</span>
 185 |     | <span class='unexecuted'>        _deployPeas();</span>
 186 |     | <span class='unexecuted'>        _deployUniV2();</span>
 187 |     | <span class='unexecuted'>        _deployUniV3();</span>
 188 |     | <span class='unexecuted'>        _deployTwapUtils();</span>
 189 |     | <span class='unexecuted'>        _deployDexAdapter();</span>
 190 |     | <span class='unexecuted'>        _deployRewardsWhitelist();</span>
 191 |     | <span class='unexecuted'>        _deployIndexUtils();</span>
 192 |     | <span class='unexecuted'>        _deployPriceFeeds();</span>
 193 |     | <span class='unexecuted'>        _deployWeightedIndexes();</span>
 194 |     | <span class='unexecuted'>        _deployAutoCompoundingPodLpFactory();</span>
 195 |     | <span class='unexecuted'>        _getAutoCompoundingPodLpAddresses();</span>
 196 |     | <span class='unexecuted'>        _deployAspTKNOracles();</span>
 197 |     | <span class='unexecuted'>        _deployAspTKNs();</span>
 198 |     | <span class='unexecuted'>        _deployVariableInterestRate();</span>
 199 |     | <span class='unexecuted'>        _deployFraxWhitelist();</span>
 200 |     | <span class='unexecuted'>        _deployFraxPairRegistry();</span>
 201 |     | <span class='unexecuted'>        _deployFraxPairDeployer();</span>
 202 |     | <span class='unexecuted'>        _deployFraxPairs();</span>
 203 |     | <span class='unexecuted'>        _deployLendingAssetVault();</span>
 204 |     | <span class='unexecuted'>        _deployLeverageManager();</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>        _setupActors();</span>
 207 |     | <span class='neutral'></span>
 208 |     | <span class='neutral'>    }</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='unexecuted'>    function _deployUniV3Minter() internal {</span>
 211 |     | <span class='unexecuted'>        _uniV3Minter = new MockUniV3Minter();</span>
 212 |     | <span class='neutral'>    }</span>
 213 |     | <span class='unexecuted'>    function _deployWETH() internal {</span>
 214 |     | <span class='unexecuted'>        _weth = new WETH9();</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>        vm.deal(address(this), 100000 ether);</span>
 217 |     | <span class='unexecuted'>        _weth.deposit{value: 100000 ether}();</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='unexecuted'>        vm.deal(address(_uniV3Minter), 100000 ether);</span>
 220 |     | <span class='unexecuted'>        vm.prank(address(_uniV3Minter));</span>
 221 |     | <span class='unexecuted'>        _weth.deposit{value: 100000 ether}();</span>
 222 |     | <span class='neutral'>    }</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    event Message(string a);</span>
 225 |     | <span class='neutral'>    event MessageUint(string a, uint256 b);</span>
 226 |     | <span class='neutral'>    event MessageBool(string a, bool b);</span>
 227 |     | <span class='neutral'>    event MessageAddress(string a, address b);</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function _deployTokens() internal {</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='unexecuted'>        if (address(this) == 0x7FA9385bE102ac3EAc297483Dd6233D62b3e1496) {</span>
 232 |     | <span class='unexecuted'>            _mockDai = new MockERC20();</span>
 233 |     | <span class='unexecuted'>            _tokenA = new MockERC20();</span>
 234 |     | <span class='unexecuted'>            _tokenB = new MockERC20();</span>
 235 |     | <span class='unexecuted'>            _tokenC = new MockERC20();</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>            _tokenA.initialize(&quot;TOKEN A&quot;, &quot;TA&quot;, 18);</span>
 238 |     | <span class='unexecuted'>            _tokenB.initialize(&quot;TOKEN B&quot;, &quot;TB&quot;, 6);</span>
 239 |     | <span class='unexecuted'>            _tokenC.initialize(&quot;TOKEN C&quot;, &quot;TC&quot;, 18);</span>
 240 |     | <span class='unexecuted'>            bytes memory code = address(_mockDai).code;</span>
 241 |     | <span class='neutral'>        </span>
 242 |     | <span class='unexecuted'>            vm.etch(0x6B175474E89094C44Da98b954EedeAC495271d0F, code);</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>            _mockDai = MockERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);</span>
 245 |     | <span class='unexecuted'>            _mockDai.initialize(&quot;MockDAI&quot;, &quot;mDAI&quot;, 18);</span>
 246 |     | <span class='neutral'></span>
 247 |     | <span class='unexecuted'>            _mockDai.mint(address(this), 100000 ether);</span>
 248 |     | <span class='unexecuted'>            _tokenA.mint(address(this), 100000 ether);</span>
 249 |     | <span class='unexecuted'>            _tokenB.mint(address(this), 100000e6);</span>
 250 |     | <span class='unexecuted'>            _tokenC.mint(address(this), 100000 ether);</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='unexecuted'>            _tokenA.mint(address(_uniV3Minter), 100000 ether);</span>
 253 |     | <span class='unexecuted'>            _tokenB.mint(address(_uniV3Minter), 100000e6);</span>
 254 |     | <span class='unexecuted'>            _tokenC.mint(address(_uniV3Minter), 100000 ether);</span>
 255 |     | <span class='unexecuted'>            _mockDai.mint(address(_uniV3Minter), 100000 ether);</span>
 256 |     | <span class='neutral'>        } else {</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>            _mockDai = MockERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);</span>
 259 |     | <span class='unexecuted'>            _tokenA = new MockERC20();</span>
 260 |     | <span class='unexecuted'>            _tokenB = new MockERC20();</span>
 261 |     | <span class='unexecuted'>            _tokenC = new MockERC20();</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='unexecuted'>            _mockDai.initialize(&quot;MockDAI&quot;, &quot;mDAI&quot;, 18);</span>
 264 |     | <span class='unexecuted'>            _tokenA.initialize(&quot;TOKEN A&quot;, &quot;TA&quot;, 18);</span>
 265 |     | <span class='unexecuted'>            _tokenB.initialize(&quot;TOKEN B&quot;, &quot;TB&quot;, 6);</span>
 266 |     | <span class='unexecuted'>            _tokenC.initialize(&quot;TOKEN C&quot;, &quot;TC&quot;, 18);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>            _tokenA.mint(address(this), 100000 ether);</span>
 269 |     | <span class='unexecuted'>            _tokenB.mint(address(this), 100000e6);</span>
 270 |     | <span class='unexecuted'>            _tokenC.mint(address(this), 100000 ether);</span>
 271 |     | <span class='unexecuted'>            _mockDai.mint(address(this), 100000 ether);</span>
 272 |     | <span class='neutral'></span>
 273 |     | <span class='unexecuted'>            _tokenA.mint(address(_uniV3Minter), 100000 ether);</span>
 274 |     | <span class='unexecuted'>            _tokenB.mint(address(_uniV3Minter), 100000e6);</span>
 275 |     | <span class='unexecuted'>            _tokenC.mint(address(_uniV3Minter), 100000 ether);</span>
 276 |     | <span class='unexecuted'>            _mockDai.mint(address(_uniV3Minter), 100000 ether);</span>
 277 |     | <span class='neutral'>        }</span>
 278 |     | <span class='neutral'>    }</span>
 279 |     | <span class='neutral'></span>
 280 |     | <span class='unexecuted'>    function _deployPeas() internal {</span>
 281 |     | <span class='unexecuted'>        _peas = new PEAS(&#39;Peapods&#39;, &#39;PEAS&#39;);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>        _peas.transfer(address(_uniV3Minter), 100000 ether);</span>
 284 |     | <span class='neutral'>    }</span>
 285 |     | <span class='neutral'></span>
 286 |     | <span class='unexecuted'>    function _deployUniV2() internal {</span>
 287 |     | <span class='unexecuted'>        _uniV2Factory = new UniswapV2Factory(address(this));</span>
 288 |     | <span class='unexecuted'>        _v2SwapRouter = new UniswapV2Router02(address(_uniV2Factory), address(_weth));</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='unexecuted'>    function _deployUniV3() internal {</span>
 292 |     | <span class='unexecuted'>        _uniV3Factory = new UniswapV3Factory();</span>
 293 |     | <span class='unexecuted'>        _v3peasDaiPool = UniswapV3Pool(</span>
 294 |     | <span class='unexecuted'>            _uniV3Factory.createPool(</span>
 295 |     | <span class='unexecuted'>                address(_peas),</span>
 296 |     | <span class='unexecuted'>                address(_mockDai),</span>
 297 |     | <span class='unexecuted'>                500</span>
 298 |     | <span class='neutral'>            )</span>
 299 |     | <span class='neutral'>        );</span>
 300 |     | <span class='unexecuted'>        _v3peasDaiPool.initialize(1&lt;&lt;96);</span>
 301 |     | <span class='neutral'>        </span>
 302 |     | <span class='unexecuted'>        _uniV3Minter.V3addLiquidity(_v3peasDaiPool, 100e18);</span>
 303 |     | <span class='unexecuted'>        _v3wethDaiPool = UniswapV3Pool(</span>
 304 |     | <span class='unexecuted'>            _uniV3Factory.createPool(</span>
 305 |     | <span class='unexecuted'>                address(_weth),</span>
 306 |     | <span class='unexecuted'>                address(_mockDai),</span>
 307 |     | <span class='unexecuted'>                500</span>
 308 |     | <span class='neutral'>            )</span>
 309 |     | <span class='neutral'>        );</span>
 310 |     | <span class='unexecuted'>        _v3wethDaiPool.initialize(1&lt;&lt;96);</span>
 311 |     | <span class='unexecuted'>        _uniV3Minter.V3addLiquidity(_v3wethDaiPool, 100e18);</span>
 312 |     | <span class='unexecuted'>        _v3SwapRouter = new SwapRouter(address(_uniV3Factory), address(_weth));</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='unexecuted'>    function _deployTwapUtils() internal {</span>
 317 |     | <span class='unexecuted'>        _twapUtils = new V3TwapUtilities();</span>
 318 |     | <span class='neutral'>    }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>    function _deployDexAdapter() internal {</span>
 321 |     | <span class='unexecuted'>        _dexAdapter = new UniswapDexAdapter(_twapUtils, address(_v2SwapRouter), address(_v3SwapRouter), false);</span>
 322 |     | <span class='neutral'>    }</span>
 323 |     | <span class='neutral'></span>
 324 |     | <span class='unexecuted'>    function _deployRewardsWhitelist() internal {</span>
 325 |     | <span class='unexecuted'>        _rewardsWhitelist = new RewardsWhitelist();</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    // function _deployProtocolFees() internal {</span>
 329 |     | <span class='neutral'>    //     _protocolFees = new ProtocolFees();</span>
 330 |     | <span class='neutral'>    //     _protocolFees.setYieldAdmin(10000);</span>
 331 |     | <span class='neutral'>    //     _protocolFees.setYieldBurn(10000);</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>    //     _protocolFeeRouter = new ProtocolFeeRouter(_protocolFees);</span>
 334 |     | <span class='neutral'>    // }</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='unexecuted'>    function _deployIndexUtils() internal {</span>
 337 |     | <span class='unexecuted'>        _indexUtils = new MockIndexUtils(</span>
 338 |     | <span class='unexecuted'>            _twapUtils,</span>
 339 |     | <span class='unexecuted'>            _dexAdapter,</span>
 340 |     | <span class='unexecuted'>            address(_v3SwapRouter)</span>
 341 |     | <span class='neutral'>        );</span>
 342 |     | <span class='neutral'>    }</span>
 343 |     | <span class='neutral'></span>
 344 |     | <span class='unexecuted'>    function _deployPriceFeeds() internal {</span>
 345 |     | <span class='unexecuted'>        _peasPriceFeed = new MockV3Aggregator(_peas.decimals(), 3e18);</span>
 346 |     | <span class='unexecuted'>        _daiPriceFeed = new MockV3Aggregator(_mockDai.decimals(), 1e18);</span>
 347 |     | <span class='unexecuted'>        _wethPriceFeed = new MockV3Aggregator(_weth.decimals(), 3000e18);</span>
 348 |     | <span class='unexecuted'>        _tokenAPriceFeed = new MockV3Aggregator(_tokenA.decimals(), 1e18);</span>
 349 |     | <span class='unexecuted'>        _tokenBPriceFeed = new MockV3Aggregator(_tokenB.decimals(), 100e6);</span>
 350 |     | <span class='unexecuted'>        _tokenCPriceFeed = new MockV3Aggregator(_tokenC.decimals(), 50e18);</span>
 351 |     | <span class='neutral'>    }</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    function _deployWeightedIndexes() internal {</span>
 354 |     | <span class='neutral'>        IDecentralizedIndex.Config memory _c;</span>
 355 |     | <span class='neutral'>        IDecentralizedIndex.Fees memory _f;</span>
 356 |     | <span class='unexecuted'>        _f.bond = fee;</span>
 357 |     | <span class='unexecuted'>        _f.debond = fee;</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='neutral'>        // POD1</span>
 360 |     | <span class='unexecuted'>        address[] memory _t1 = new address[](1);</span>
 361 |     | <span class='unexecuted'>        _t1[0] = address(_peas);</span>
 362 |     | <span class='unexecuted'>        uint256[] memory _w1 = new uint256[](1);</span>
 363 |     | <span class='unexecuted'>        _w1[0] = 100;</span>
 364 |     | <span class='unexecuted'>        _pod1 = new WeightedIndex(&#39;Test1&#39;, &#39;pTEST1&#39;, _c, _f, _t1, _w1, address(0), address(_peas), address(_dexAdapter), false);</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='neutral'>        // approve pod asset &amp; pair asset</span>
 367 |     | <span class='unexecuted'>        _peas.approve(address(_pod1), type(uint256).max);</span>
 368 |     | <span class='unexecuted'>        _mockDai.approve(address(_pod1), type(uint256).max);</span>
 369 |     | <span class='neutral'>        // mint some pTKNs</span>
 370 |     | <span class='unexecuted'>        _pod1.bond(</span>
 371 |     | <span class='unexecuted'>            address(_peas),</span>
 372 |     | <span class='unexecuted'>            1 ether,</span>
 373 |     | <span class='neutral'>            1 ether</span>
 374 |     | <span class='neutral'>        );</span>
 375 |     | <span class='neutral'>        // add Liquidity</span>
 376 |     | <span class='unexecuted'>        _pod1.addLiquidityV2(</span>
 377 |     | <span class='unexecuted'>            1 ether,</span>
 378 |     | <span class='neutral'>            1 ether,</span>
 379 |     | <span class='unexecuted'>            100,</span>
 380 |     | <span class='unexecuted'>            block.timestamp</span>
 381 |     | <span class='neutral'>        );</span>
 382 |     | <span class='neutral'></span>
 383 |     | <span class='neutral'>        // add to array for fuzzing</span>
 384 |     | <span class='unexecuted'>        _pods.push(_pod1);</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='neutral'>        // POD2</span>
 387 |     | <span class='unexecuted'>        address[] memory _t2 = new address[](2);</span>
 388 |     | <span class='unexecuted'>        _t2[0] = address(_peas);</span>
 389 |     | <span class='unexecuted'>        _t2[1] = address(_weth);</span>
 390 |     | <span class='unexecuted'>        uint256[] memory _w2 = new uint256[](2);</span>
 391 |     | <span class='unexecuted'>        _w2[0] = 50;</span>
 392 |     | <span class='unexecuted'>        _w2[1] = 50;</span>
 393 |     | <span class='unexecuted'>        _pod2 = new WeightedIndex(&#39;Test2&#39;, &#39;pTEST2&#39;, _c, _f, _t2, _w2, address(0), address(_peas), address(_dexAdapter), false);</span>
 394 |     | <span class='neutral'></span>
 395 |     | <span class='neutral'>        // approve pod asset &amp; pair asset</span>
 396 |     | <span class='unexecuted'>        _peas.approve(address(_pod2), type(uint256).max);</span>
 397 |     | <span class='unexecuted'>        _weth.approve(address(_pod2), type(uint256).max);</span>
 398 |     | <span class='unexecuted'>        _mockDai.approve(address(_pod2), type(uint256).max);</span>
 399 |     | <span class='neutral'>        // mint some pTKNs</span>
 400 |     | <span class='unexecuted'>        _pod2.bond(</span>
 401 |     | <span class='unexecuted'>            address(_peas),</span>
 402 |     | <span class='unexecuted'>            100 ether,</span>
 403 |     | <span class='neutral'>            100 ether</span>
 404 |     | <span class='neutral'>        );</span>
 405 |     | <span class='neutral'>        // add Liquidity</span>
 406 |     | <span class='unexecuted'>        _pod2.addLiquidityV2(</span>
 407 |     | <span class='unexecuted'>            100 ether,</span>
 408 |     | <span class='neutral'>            100 ether,</span>
 409 |     | <span class='unexecuted'>            100,</span>
 410 |     | <span class='unexecuted'>            block.timestamp</span>
 411 |     | <span class='neutral'>        );</span>
 412 |     | <span class='neutral'></span>
 413 |     | <span class='neutral'>        // add to array for fuzzing</span>
 414 |     | <span class='unexecuted'>        _pods.push(_pod2);</span>
 415 |     | <span class='neutral'></span>
 416 |     | <span class='neutral'>        // POD4</span>
 417 |     | <span class='unexecuted'>        address[] memory _t4 = new address[](4);</span>
 418 |     | <span class='unexecuted'>        _t4[0] = address(_weth);</span>
 419 |     | <span class='unexecuted'>        _t4[1] = address(_tokenA);</span>
 420 |     | <span class='unexecuted'>        _t4[2] = address(_tokenB);</span>
 421 |     | <span class='unexecuted'>        _t4[3] = address(_tokenC);</span>
 422 |     | <span class='unexecuted'>        uint256[] memory _w4 = new uint256[](4);</span>
 423 |     | <span class='unexecuted'>        _w4[0] = 25;</span>
 424 |     | <span class='unexecuted'>        _w4[1] = 25;</span>
 425 |     | <span class='unexecuted'>        _w4[2] = 25;</span>
 426 |     | <span class='unexecuted'>        _w4[3] = 25;</span>
 427 |     | <span class='unexecuted'>        _pod4 = new WeightedIndex(&#39;Test4&#39;, &#39;pTEST4&#39;, _c, _f, _t4, _w4, address(0), address(_peas), address(_dexAdapter), false);</span>
 428 |     | <span class='neutral'></span>
 429 |     | <span class='neutral'>        // approve pod asset &amp; pair asset</span>
 430 |     | <span class='unexecuted'>        _weth.approve(address(_pod4), type(uint256).max);</span>
 431 |     | <span class='unexecuted'>        _tokenA.approve(address(_pod4), type(uint256).max);</span>
 432 |     | <span class='unexecuted'>        _tokenB.approve(address(_pod4), type(uint256).max);</span>
 433 |     | <span class='unexecuted'>        _tokenC.approve(address(_pod4), type(uint256).max);</span>
 434 |     | <span class='unexecuted'>        _mockDai.approve(address(_pod4), type(uint256).max);</span>
 435 |     | <span class='neutral'>        // mint some pTKNs</span>
 436 |     | <span class='unexecuted'>        _pod4.bond(</span>
 437 |     | <span class='unexecuted'>            address(_weth),</span>
 438 |     | <span class='unexecuted'>            1 ether,</span>
 439 |     | <span class='neutral'>            1 ether</span>
 440 |     | <span class='neutral'>        );</span>
 441 |     | <span class='neutral'>        // add Liquidity</span>
 442 |     | <span class='unexecuted'>        _pod4.addLiquidityV2(</span>
 443 |     | <span class='unexecuted'>            1 ether,</span>
 444 |     | <span class='neutral'>            1 ether,</span>
 445 |     | <span class='unexecuted'>            100,</span>
 446 |     | <span class='unexecuted'>            block.timestamp</span>
 447 |     | <span class='neutral'>        );</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>        // add to array for fuzzing</span>
 450 |     | <span class='unexecuted'>        _pods.push(_pod4);</span>
 451 |     | <span class='neutral'>    }</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='unexecuted'>    function _deployAutoCompoundingPodLpFactory() internal {</span>
 454 |     | <span class='unexecuted'>        _aspTKNFactory = new AutoCompoundingPodLpFactory();</span>
 455 |     | <span class='neutral'>    }</span>
 456 |     | <span class='neutral'></span>
 457 |     | <span class='unexecuted'>    function _getAutoCompoundingPodLpAddresses() internal {</span>
 458 |     | <span class='unexecuted'>        _aspTKN1Address = _aspTKNFactory.getNewCaFromParams(</span>
 459 |     | <span class='neutral'>            &quot;Test aspTKN1&quot;,</span>
 460 |     | <span class='neutral'>            &quot;aspTKN1&quot;,</span>
 461 |     | <span class='unexecuted'>            _pod1,</span>
 462 |     | <span class='unexecuted'>            _dexAdapter,</span>
 463 |     | <span class='unexecuted'>            _indexUtils,</span>
 464 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 465 |     | <span class='unexecuted'>            _twapUtils,</span>
 466 |     | <span class='neutral'>            0</span>
 467 |     | <span class='neutral'>        );</span>
 468 |     | <span class='neutral'></span>
 469 |     | <span class='unexecuted'>        _aspTKN2Address = _aspTKNFactory.getNewCaFromParams(</span>
 470 |     | <span class='neutral'>            &quot;Test aspTKN2&quot;,</span>
 471 |     | <span class='neutral'>            &quot;aspTKN2&quot;,</span>
 472 |     | <span class='unexecuted'>            _pod2,</span>
 473 |     | <span class='unexecuted'>            _dexAdapter,</span>
 474 |     | <span class='unexecuted'>            _indexUtils,</span>
 475 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 476 |     | <span class='unexecuted'>            _twapUtils,</span>
 477 |     | <span class='neutral'>            0</span>
 478 |     | <span class='neutral'>        );</span>
 479 |     | <span class='neutral'></span>
 480 |     | <span class='unexecuted'>        _aspTKN4Address = _aspTKNFactory.getNewCaFromParams(</span>
 481 |     | <span class='neutral'>            &quot;Test aspTKN4&quot;,</span>
 482 |     | <span class='neutral'>            &quot;aspTKN4&quot;,</span>
 483 |     | <span class='unexecuted'>            _pod4,</span>
 484 |     | <span class='unexecuted'>            _dexAdapter,</span>
 485 |     | <span class='unexecuted'>            _indexUtils,</span>
 486 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 487 |     | <span class='unexecuted'>            _twapUtils,</span>
 488 |     | <span class='neutral'>            0</span>
 489 |     | <span class='neutral'>        );</span>
 490 |     | <span class='neutral'>    }</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='unexecuted'>    function _deployAspTKNOracles() internal {</span>
 493 |     | <span class='unexecuted'>        _v2Res = new V2ReservesUniswap();</span>
 494 |     | <span class='unexecuted'>        _clOracle = new ChainlinkSinglePriceOracle();</span>
 495 |     | <span class='unexecuted'>        _uniOracle = new UniswapV3SinglePriceOracle();</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='unexecuted'>        _aspTKNMinOracle1 = new aspTKNMinimalOracle(</span>
 498 |     | <span class='unexecuted'>            _aspTKN1Address,</span>
 499 |     | <span class='unexecuted'>            address(_mockDai), // DAI</span>
 500 |     | <span class='neutral'>            false,</span>
 501 |     | <span class='unexecuted'>            _pod1.lpStakingPool(),</span>
 502 |     | <span class='unexecuted'>            address(_v3peasDaiPool), // UniV3: PEAS / DAI</span>
 503 |     | <span class='unexecuted'>            address(_daiPriceFeed), // CL: DAI / USD</span>
 504 |     | <span class='neutral'>            address(0),</span>
 505 |     | <span class='neutral'>            address(0),</span>
 506 |     | <span class='neutral'>            address(0),</span>
 507 |     | <span class='unexecuted'>            address(_clOracle),</span>
 508 |     | <span class='unexecuted'>            address(_uniOracle),</span>
 509 |     | <span class='unexecuted'>            address(_v2Res)</span>
 510 |     | <span class='neutral'>        );</span>
 511 |     | <span class='neutral'></span>
 512 |     | <span class='unexecuted'>        _aspTKNMinOracle2 = new aspTKNMinimalOracle(</span>
 513 |     | <span class='unexecuted'>            _aspTKN2Address,</span>
 514 |     | <span class='unexecuted'>            address(_mockDai), // DAI</span>
 515 |     | <span class='neutral'>            false,</span>
 516 |     | <span class='unexecuted'>            _pod2.lpStakingPool(),</span>
 517 |     | <span class='unexecuted'>            address(_v3peasDaiPool), // UniV3: PEAS / DAI</span>
 518 |     | <span class='unexecuted'>            address(_daiPriceFeed), // CL: DAI / USD</span>
 519 |     | <span class='neutral'>            address(0),</span>
 520 |     | <span class='neutral'>            address(0),</span>
 521 |     | <span class='neutral'>            address(0),</span>
 522 |     | <span class='unexecuted'>            address(_clOracle),</span>
 523 |     | <span class='unexecuted'>            address(_uniOracle),</span>
 524 |     | <span class='unexecuted'>            address(_v2Res)</span>
 525 |     | <span class='neutral'>        );</span>
 526 |     | <span class='neutral'></span>
 527 |     | <span class='unexecuted'>        _aspTKNMinOracle4 = new aspTKNMinimalOracle(</span>
 528 |     | <span class='unexecuted'>            _aspTKN4Address,</span>
 529 |     | <span class='unexecuted'>            address(_mockDai), // DAI</span>
 530 |     | <span class='neutral'>            false,</span>
 531 |     | <span class='unexecuted'>            _pod4.lpStakingPool(),</span>
 532 |     | <span class='unexecuted'>            address(_v3wethDaiPool), // UniV3: PEAS / DAI</span>
 533 |     | <span class='unexecuted'>            address(_daiPriceFeed), // CL: DAI / USD</span>
 534 |     | <span class='neutral'>            address(0),</span>
 535 |     | <span class='neutral'>            address(0),</span>
 536 |     | <span class='neutral'>            address(0),</span>
 537 |     | <span class='unexecuted'>            address(_clOracle),</span>
 538 |     | <span class='unexecuted'>            address(_uniOracle),</span>
 539 |     | <span class='unexecuted'>            address(_v2Res)</span>
 540 |     | <span class='neutral'>        );</span>
 541 |     | <span class='neutral'>    }</span>
 542 |     | <span class='neutral'></span>
 543 |     | <span class='unexecuted'>    function _deployAspTKNs() internal {</span>
 544 |     | <span class='unexecuted'>        address _lpToken1 = _pod1.lpStakingPool();</span>
 545 |     | <span class='unexecuted'>        address _stakingToken1 = StakingPoolToken(_lpToken1).stakingToken();</span>
 546 |     | <span class='neutral'>        // Approve pod LP token</span>
 547 |     | <span class='unexecuted'>        IERC20(_stakingToken1).approve(_lpToken1, 1000);</span>
 548 |     | <span class='neutral'>        // Stake liquidity tokens for initial aspTKN deposit</span>
 549 |     | <span class='unexecuted'>        StakingPoolToken(_lpToken1).stake(address(this), 1000);</span>
 550 |     | <span class='neutral'>        // Approve staking token for min deposit</span>
 551 |     | <span class='unexecuted'>        IERC20(_lpToken1).approve(address(_aspTKNFactory), 1000);</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='unexecuted'>        _aspTKNFactory.create(</span>
 554 |     | <span class='neutral'>            &quot;Test aspTKN1&quot;,</span>
 555 |     | <span class='neutral'>            &quot;aspTKN1&quot;,</span>
 556 |     | <span class='unexecuted'>            _pod1,</span>
 557 |     | <span class='unexecuted'>            _dexAdapter,</span>
 558 |     | <span class='unexecuted'>            _indexUtils,</span>
 559 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 560 |     | <span class='unexecuted'>            _twapUtils,</span>
 561 |     | <span class='neutral'>            0</span>
 562 |     | <span class='neutral'>        );</span>
 563 |     | <span class='unexecuted'>        _aspTKN1 = AutoCompoundingPodLp(_aspTKN1Address);</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>        // add to array for fuzzing</span>
 566 |     | <span class='unexecuted'>        _aspTKNs.push(_aspTKN1);</span>
 567 |     | <span class='neutral'></span>
 568 |     | <span class='unexecuted'>        address _lpToken2 = _pod2.lpStakingPool();</span>
 569 |     | <span class='unexecuted'>        address _stakingToken2 = StakingPoolToken(_lpToken2).stakingToken();</span>
 570 |     | <span class='neutral'>        // Approve pod LP token</span>
 571 |     | <span class='unexecuted'>        IERC20(_stakingToken2).approve(_lpToken2, 1000);</span>
 572 |     | <span class='neutral'>        // Stake liquidity tokens for initial aspTKN deposit</span>
 573 |     | <span class='unexecuted'>        StakingPoolToken(_lpToken2).stake(address(this), 1000);</span>
 574 |     | <span class='neutral'>        // Approve staking token for min deposit</span>
 575 |     | <span class='unexecuted'>        IERC20(_lpToken2).approve(address(_aspTKNFactory), 1000);</span>
 576 |     | <span class='neutral'></span>
 577 |     | <span class='unexecuted'>        _aspTKNFactory.create(</span>
 578 |     | <span class='neutral'>            &quot;Test aspTKN2&quot;,</span>
 579 |     | <span class='neutral'>            &quot;aspTKN2&quot;,</span>
 580 |     | <span class='unexecuted'>            _pod2,</span>
 581 |     | <span class='unexecuted'>            _dexAdapter,</span>
 582 |     | <span class='unexecuted'>            _indexUtils,</span>
 583 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 584 |     | <span class='unexecuted'>            _twapUtils,</span>
 585 |     | <span class='neutral'>            0</span>
 586 |     | <span class='neutral'>        );</span>
 587 |     | <span class='unexecuted'>        _aspTKN2 = AutoCompoundingPodLp(_aspTKN2Address);</span>
 588 |     | <span class='neutral'></span>
 589 |     | <span class='neutral'>        // add to array for fuzzing</span>
 590 |     | <span class='unexecuted'>        _aspTKNs.push(_aspTKN2);</span>
 591 |     | <span class='neutral'></span>
 592 |     | <span class='unexecuted'>        address _lpToken4 = _pod4.lpStakingPool();</span>
 593 |     | <span class='unexecuted'>        address _stakingToken4 = StakingPoolToken(_lpToken4).stakingToken();</span>
 594 |     | <span class='neutral'>        // Approve pod LP token</span>
 595 |     | <span class='unexecuted'>        IERC20(_stakingToken4).approve(_lpToken4, 1000);</span>
 596 |     | <span class='neutral'>        // Stake liquidity tokens for initial aspTKN deposit</span>
 597 |     | <span class='unexecuted'>        StakingPoolToken(_lpToken4).stake(address(this), 1000);</span>
 598 |     | <span class='neutral'>        // Approve staking token for min deposit</span>
 599 |     | <span class='unexecuted'>        IERC20(_lpToken4).approve(address(_aspTKNFactory), 1000);</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='unexecuted'>        _aspTKNFactory.create(</span>
 602 |     | <span class='neutral'>            &quot;Test aspTKN4&quot;,</span>
 603 |     | <span class='neutral'>            &quot;aspTKN4&quot;,</span>
 604 |     | <span class='unexecuted'>            _pod4,</span>
 605 |     | <span class='unexecuted'>            _dexAdapter,</span>
 606 |     | <span class='unexecuted'>            _indexUtils,</span>
 607 |     | <span class='unexecuted'>            _rewardsWhitelist,</span>
 608 |     | <span class='unexecuted'>            _twapUtils,</span>
 609 |     | <span class='neutral'>            0</span>
 610 |     | <span class='neutral'>        );</span>
 611 |     | <span class='unexecuted'>        _aspTKN4 = AutoCompoundingPodLp(_aspTKN4Address);</span>
 612 |     | <span class='neutral'></span>
 613 |     | <span class='neutral'>        // add to array for fuzzing</span>
 614 |     | <span class='unexecuted'>        _aspTKNs.push(_aspTKN4);</span>
 615 |     | <span class='neutral'>    }</span>
 616 |     | <span class='neutral'></span>
 617 |     | <span class='unexecuted'>    function _deployVariableInterestRate() internal {</span>
 618 |     | <span class='neutral'>        // These values taken from existing Fraxlend Variable Rate Contract</span>
 619 |     | <span class='unexecuted'>        _variableInterestRate = new VariableInterestRate(</span>
 620 |     | <span class='neutral'>            &quot;[0.5 0.5@.875 5-10k] 2 days (.75-.85)&quot;,</span>
 621 |     | <span class='unexecuted'>            75000,</span>
 622 |     | <span class='unexecuted'>            85000,</span>
 623 |     | <span class='unexecuted'>            87500,</span>
 624 |     | <span class='unexecuted'>            158247046,</span>
 625 |     | <span class='unexecuted'>            1582470460,</span>
 626 |     | <span class='unexecuted'>            3164940920000,</span>
 627 |     | <span class='unexecuted'>            172800,</span>
 628 |     | <span class='unexecuted'>            500000000000000000</span>
 629 |     | <span class='neutral'>        );</span>
 630 |     | <span class='neutral'>    }</span>
 631 |     | <span class='neutral'></span>
 632 |     | <span class='unexecuted'>    function _deployFraxWhitelist() internal {</span>
 633 |     | <span class='unexecuted'>        _fraxWhitelist = new FraxlendWhitelist();</span>
 634 |     | <span class='neutral'>    }</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='unexecuted'>    function _deployFraxPairRegistry() internal {</span>
 637 |     | <span class='unexecuted'>        address[] memory _initialDeployers = new address[](0);</span>
 638 |     | <span class='unexecuted'>        _fraxRegistry = new FraxlendPairRegistry(</span>
 639 |     | <span class='unexecuted'>            address(this),</span>
 640 |     | <span class='neutral'>            _initialDeployers</span>
 641 |     | <span class='neutral'>        );</span>
 642 |     | <span class='neutral'>    }</span>
 643 |     | <span class='neutral'></span>
 644 |     | <span class='unexecuted'>    function _deployFraxPairDeployer() internal {</span>
 645 |     | <span class='unexecuted'>        ConstructorParams memory _params = ConstructorParams(</span>
 646 |     | <span class='unexecuted'>            circuitBreaker,</span>
 647 |     | <span class='unexecuted'>            comptroller,</span>
 648 |     | <span class='unexecuted'>            timelock,</span>
 649 |     | <span class='unexecuted'>            address(_fraxWhitelist),</span>
 650 |     | <span class='unexecuted'>            address(_fraxRegistry)</span>
 651 |     | <span class='neutral'>        );</span>
 652 |     | <span class='unexecuted'>        _fraxDeployer = new FraxlendPairDeployer(</span>
 653 |     | <span class='neutral'>            _params</span>
 654 |     | <span class='neutral'>        );</span>
 655 |     | <span class='neutral'></span>
 656 |     | <span class='unexecuted'>        _fraxDeployer.setCreationCode(type(FraxlendPair).creationCode);</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='unexecuted'>        address[] memory _whitelistDeployer = new address[](1);</span>
 659 |     | <span class='unexecuted'>        _whitelistDeployer[0] = address(this);</span>
 660 |     | <span class='neutral'></span>
 661 |     | <span class='unexecuted'>        _fraxWhitelist.setFraxlendDeployerWhitelist(</span>
 662 |     | <span class='unexecuted'>            _whitelistDeployer,</span>
 663 |     | <span class='neutral'>            true</span>
 664 |     | <span class='neutral'>        );</span>
 665 |     | <span class='neutral'></span>
 666 |     | <span class='unexecuted'>        address[] memory _registryDeployer = new address[](1);</span>
 667 |     | <span class='unexecuted'>        _registryDeployer[0] = address(_fraxDeployer);</span>
 668 |     | <span class='neutral'></span>
 669 |     | <span class='unexecuted'>        _fraxRegistry.setDeployers(</span>
 670 |     | <span class='unexecuted'>            _registryDeployer,</span>
 671 |     | <span class='neutral'>            true</span>
 672 |     | <span class='neutral'>        );</span>
 673 |     | <span class='neutral'>    }</span>
 674 |     | <span class='neutral'></span>
 675 |     | <span class='unexecuted'>    function _deployFraxPairs() internal {</span>
 676 |     | <span class='neutral'></span>
 677 |     | <span class='neutral'>        // moving time to help out the twap</span>
 678 |     | <span class='unexecuted'>        vm.warp(block.timestamp + 1 days);</span>
 679 |     | <span class='neutral'></span>
 680 |     | <span class='unexecuted'>        _fraxLPToken1 = FraxlendPair(</span>
 681 |     | <span class='unexecuted'>            _fraxDeployer.deploy(</span>
 682 |     | <span class='unexecuted'>                abi.encode(</span>
 683 |     | <span class='unexecuted'>                    address(_pod1),</span>
 684 |     | <span class='unexecuted'>                    _aspTKN1Address, </span>
 685 |     | <span class='unexecuted'>                    address(_aspTKNMinOracle1), </span>
 686 |     | <span class='unexecuted'>                    5000, </span>
 687 |     | <span class='unexecuted'>                    address(_variableInterestRate), </span>
 688 |     | <span class='unexecuted'>                    1000, </span>
 689 |     | <span class='unexecuted'>                    75000, </span>
 690 |     | <span class='unexecuted'>                    10000, </span>
 691 |     | <span class='unexecuted'>                    9000, </span>
 692 |     | <span class='unexecuted'>                    2000</span>
 693 |     | <span class='neutral'>                )</span>
 694 |     | <span class='neutral'>            )</span>
 695 |     | <span class='neutral'>        );</span>
 696 |     | <span class='neutral'></span>
 697 |     | <span class='neutral'>        // add to array for fuzzing</span>
 698 |     | <span class='unexecuted'>        _fraxPairs.push(_fraxLPToken1);</span>
 699 |     | <span class='neutral'></span>
 700 |     | <span class='unexecuted'>        _fraxLPToken2 = FraxlendPair(</span>
 701 |     | <span class='unexecuted'>            _fraxDeployer.deploy(</span>
 702 |     | <span class='unexecuted'>                abi.encode(</span>
 703 |     | <span class='unexecuted'>                    address(_pod2),</span>
 704 |     | <span class='unexecuted'>                    _aspTKN2Address, </span>
 705 |     | <span class='unexecuted'>                    address(_aspTKNMinOracle2), </span>
 706 |     | <span class='unexecuted'>                    5000, </span>
 707 |     | <span class='unexecuted'>                    address(_variableInterestRate), </span>
 708 |     | <span class='unexecuted'>                    1000, </span>
 709 |     | <span class='unexecuted'>                    75000, </span>
 710 |     | <span class='unexecuted'>                    10000, </span>
 711 |     | <span class='unexecuted'>                    9000, </span>
 712 |     | <span class='unexecuted'>                    2000</span>
 713 |     | <span class='neutral'>                )</span>
 714 |     | <span class='neutral'>            )</span>
 715 |     | <span class='neutral'>        );</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='neutral'>        // add to array for fuzzing</span>
 718 |     | <span class='unexecuted'>        _fraxPairs.push(_fraxLPToken2);</span>
 719 |     | <span class='neutral'></span>
 720 |     | <span class='unexecuted'>        _fraxLPToken4 = FraxlendPair(</span>
 721 |     | <span class='unexecuted'>            _fraxDeployer.deploy(</span>
 722 |     | <span class='unexecuted'>                abi.encode(</span>
 723 |     | <span class='unexecuted'>                    address(_pod4),</span>
 724 |     | <span class='unexecuted'>                    _aspTKN4Address, </span>
 725 |     | <span class='unexecuted'>                    address(_aspTKNMinOracle4), </span>
 726 |     | <span class='unexecuted'>                    5000, </span>
 727 |     | <span class='unexecuted'>                    address(_variableInterestRate), </span>
 728 |     | <span class='unexecuted'>                    1000, </span>
 729 |     | <span class='unexecuted'>                    75000, </span>
 730 |     | <span class='unexecuted'>                    10000, </span>
 731 |     | <span class='unexecuted'>                    9000, </span>
 732 |     | <span class='unexecuted'>                    2000</span>
 733 |     | <span class='neutral'>                )</span>
 734 |     | <span class='neutral'>            )</span>
 735 |     | <span class='neutral'>        );</span>
 736 |     | <span class='neutral'></span>
 737 |     | <span class='neutral'>        // add to array for fuzzing</span>
 738 |     | <span class='unexecuted'>        _fraxPairs.push(_fraxLPToken4);</span>
 739 |     | <span class='neutral'>    }</span>
 740 |     | <span class='neutral'></span>
 741 |     | <span class='unexecuted'>    function _deployLendingAssetVault() internal {</span>
 742 |     | <span class='unexecuted'>        _lendingAssetVault = new LendingAssetVault(</span>
 743 |     | <span class='neutral'>            &quot;Test LAV&quot;,</span>
 744 |     | <span class='neutral'>            &quot;tLAV&quot;,</span>
 745 |     | <span class='unexecuted'>            address(_mockDai)</span>
 746 |     | <span class='neutral'>        );</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='unexecuted'>        IERC20 vaultAsset1 = IERC20(_fraxLPToken1.asset());</span>
 749 |     | <span class='unexecuted'>        vaultAsset1.approve(address(_fraxLPToken1), vaultAsset1.totalSupply());</span>
 750 |     | <span class='unexecuted'>        vaultAsset1.approve(address(_lendingAssetVault), vaultAsset1.totalSupply());</span>
 751 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken1), true);</span>
 752 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken1), 5000);</span>
 753 |     | <span class='neutral'></span>
 754 |     | <span class='unexecuted'>        IERC20 vaultAsset2 = IERC20(_fraxLPToken2.asset());</span>
 755 |     | <span class='unexecuted'>        vaultAsset2.approve(address(_fraxLPToken2), vaultAsset2.totalSupply());</span>
 756 |     | <span class='unexecuted'>        vaultAsset2.approve(address(_lendingAssetVault), vaultAsset2.totalSupply());</span>
 757 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken2), true);</span>
 758 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken2), 2500);</span>
 759 |     | <span class='neutral'></span>
 760 |     | <span class='unexecuted'>        IERC20 vaultAsset4 = IERC20(_fraxLPToken4.asset());</span>
 761 |     | <span class='unexecuted'>        vaultAsset4.approve(address(_fraxLPToken4), vaultAsset4.totalSupply());</span>
 762 |     | <span class='unexecuted'>        vaultAsset4.approve(address(_lendingAssetVault), vaultAsset4.totalSupply());</span>
 763 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultWhitelist(address(_fraxLPToken4), true);</span>
 764 |     | <span class='unexecuted'>        _lendingAssetVault.setVaultMaxPerc(address(_fraxLPToken4), 2500);</span>
 765 |     | <span class='neutral'>    }</span>
 766 |     | <span class='neutral'></span>
 767 |     | <span class='unexecuted'>    function _deployLeverageManager() internal {</span>
 768 |     | <span class='unexecuted'>        _leverageManager = new LeverageManager(</span>
 769 |     | <span class='neutral'>            &quot;Test LM&quot;,</span>
 770 |     | <span class='neutral'>            &quot;tLM&quot;,</span>
 771 |     | <span class='unexecuted'>            IIndexUtils_LEGACY(address(_indexUtils))</span>
 772 |     | <span class='neutral'>        );</span>
 773 |     | <span class='neutral'>    }</span>
 774 |     | <span class='neutral'></span>
 775 |     | <span class='neutral'>    /*////////////////////////////////////////////////////////////////</span>
 776 |     | <span class='neutral'>                                    HELPERS</span>
 777 |     | <span class='neutral'>    ////////////////////////////////////////////////////////////////*/</span>
 778 |     | <span class='neutral'></span>
 779 |     | <span class='unexecuted'>    function _setupActors() internal {</span>
 780 |     | <span class='unexecuted'>        for (uint256 i; i &lt; users.length; i++) {</span>
 781 |     | <span class='unexecuted'>            vm.deal(users[i], 100000 ether);</span>
 782 |     | <span class='unexecuted'>            vm.prank(users[i]);</span>
 783 |     | <span class='unexecuted'>            _weth.deposit{value: 100000 ether}();</span>
 784 |     | <span class='neutral'></span>
 785 |     | <span class='unexecuted'>            _tokenA.mint(users[i], 100000 ether);</span>
 786 |     | <span class='unexecuted'>            _tokenB.mint(users[i], 100000e6);</span>
 787 |     | <span class='unexecuted'>            _tokenC.mint(users[i], 100000 ether);</span>
 788 |     | <span class='unexecuted'>            _mockDai.mint(users[i], 100000 ether);</span>
 789 |     | <span class='neutral'></span>
 790 |     | <span class='unexecuted'>            _peas.transfer(users[i], 100000 ether);</span>
 791 |     | <span class='neutral'>        }</span>
 792 |     | <span class='neutral'>    }</span>
 793 |     | <span class='neutral'></span>
 794 | *   | <span class='executed'>    function randomAddress(uint256 seed) internal view returns (address) {</span>
 795 | *   | <span class='executed'>        return users[bound(seed, 0, users.length - 1)];</span>
 796 |     | <span class='neutral'>    }</span>
 797 |     | <span class='neutral'></span>
 798 | *   | <span class='executed'>    function randomPod(uint256 seed) internal returns (WeightedIndex) {</span>
 799 | *   | <span class='executed'>        fl.log(&quot;POD 1&quot;, address(_pods[bound(seed, 0, _pods.length - 1)]));</span>
 800 | *   | <span class='executed'>        return _pods[bound(seed, 0, _pods.length - 1)];</span>
 801 |     | <span class='neutral'>    }</span>
 802 |     | <span class='neutral'></span>
 803 | *   | <span class='executed'>    function randomIndexToken(WeightedIndex pod, uint256 seed) internal view returns (address) {</span>
 804 | *   | <span class='executed'>        IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();</span>
 805 | *   | <span class='executed'>        return indexTokens[bound(seed, 0, indexTokens.length - 1)].token;</span>
 806 |     | <span class='neutral'>    }</span>
 807 |     | <span class='neutral'></span>
 808 |     | <span class='neutral'>    function randomAspTKN(uint256 seed) internal view returns (AutoCompoundingPodLp) {</span>
 809 |     | <span class='neutral'>        return _aspTKNs[bound(seed, 0, _aspTKNs.length - 1)];</span>
 810 |     | <span class='neutral'>    }</span>
 811 |     | <span class='neutral'></span>
 812 |     | <span class='neutral'>    function randomFraxPair(uint256 seed) internal view returns (FraxlendPair) {</span>
 813 |     | <span class='neutral'>        return _fraxPairs[bound(seed, 0, _fraxPairs.length - 1)];</span>
 814 |     | <span class='neutral'>    }</span>
 815 |     | <span class='neutral'></span>
 816 | *   | <span class='executed'>    function _approveIndexTokens(WeightedIndex pod, address user, uint256 amount) internal {</span>
 817 | *   | <span class='executed'>        IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();</span>
 818 |     | <span class='neutral'></span>
 819 | *   | <span class='executed'>        for (uint256 i; i &lt; indexTokens.length; i++) {</span>
 820 | *   | <span class='executed'>            vm.prank(user);</span>
 821 | *   | <span class='executed'>            MockERC20(indexTokens[i].token).approve(address(pod), type(uint256).max);</span>
 822 |     | <span class='neutral'>        }</span>
 823 |     | <span class='neutral'>    }</span>
 824 |     | <span class='neutral'></span>
 825 | *   | <span class='executed'>    function _checkTokenBalances(WeightedIndex pod, address token, address user, uint256 amount) internal returns (bool hasEnough) {</span>
 826 | *   | <span class='executed'>        IDecentralizedIndex.IndexAssetInfo[] memory indexTokens = pod.getAllAssets();</span>
 827 |     | <span class='neutral'></span>
 828 | *   | <span class='executed'>        hasEnough = true;</span>
 829 | *   | <span class='executed'>        for (uint256 i; i &lt; indexTokens.length; i++) {</span>
 830 | *   | <span class='executed'>            uint256 amountNeeded = pod.getInitialAmount(</span>
 831 | *   | <span class='executed'>                token,</span>
 832 | *   | <span class='executed'>                amount,</span>
 833 | *   | <span class='executed'>                indexTokens[i].token</span>
 834 |     | <span class='neutral'>            );</span>
 835 |     | <span class='neutral'></span>
 836 | *   | <span class='executed'>            if (amountNeeded &gt; IERC20(indexTokens[i].token).balanceOf(user)) {</span>
 837 | *   | <span class='executed'>                hasEnough = false;</span>
 838 | *   | <span class='executed'>                break;</span>
 839 |     | <span class='neutral'>            }</span>
 840 |     | <span class='neutral'>        }</span>
 841 |     | <span class='neutral'>    }</span>
 842 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/PeapodsInvariant.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {PodHandler} from &quot;./handlers/PodHandler.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 | *r  | <span class='executed'>contract PeapodsInvariant is PodHandler {</span>
  7 |     | <span class='neutral'>    constructor() payable {</span>
  8 |     | <span class='unexecuted'>        setup();</span>
  9 |     | <span class='neutral'>    }</span>
 10 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/handlers/PodHandler.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {Properties} from &quot;../helpers/Properties.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import {WeightedIndex} from &quot;../../../contracts/WeightedIndex.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>import {IERC20} from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 | *r  | <span class='executed'>contract PodHandler is Properties {</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    struct BondTemps {</span>
 13 |     | <span class='neutral'>        address user;</span>
 14 |     | <span class='neutral'>        WeightedIndex pod;</span>
 15 |     | <span class='neutral'>        address token;</span>
 16 |     | <span class='neutral'>    }</span>
 17 | *   | <span class='executed'>    function pod_bond(uint256 userIndexSeed, uint256 podIndexSeed, uint256 indexTokenSeed, uint256 amount) public {</span>
 18 |     | <span class='neutral'>        </span>
 19 |     | <span class='neutral'>        // PRE-CONDITIONS</span>
 20 |     | <span class='neutral'>        BondTemps memory cache;</span>
 21 | *   | <span class='executed'>        cache.user = randomAddress(userIndexSeed);</span>
 22 | *   | <span class='executed'>        cache.pod = randomPod(podIndexSeed);</span>
 23 | *   | <span class='executed'>        cache.token = randomIndexToken(cache.pod, indexTokenSeed);</span>
 24 |     | <span class='neutral'></span>
 25 | *   | <span class='executed'>        amount = fl.clamp(amount, 0, IERC20(cache.token).balanceOf(cache.user));</span>
 26 |     | <span class='neutral'></span>
 27 | *   | <span class='executed'>        _approveIndexTokens(cache.pod, cache.user, amount);</span>
 28 | *   | <span class='executed'>        if (!_checkTokenBalances(cache.pod, cache.token, cache.user, amount)) return;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>        // ACTION</span>
 31 | *   | <span class='executed'>        vm.prank(cache.user);</span>
 32 | *   | <span class='executed'>        try cache.pod.bond(</span>
 33 | *   | <span class='executed'>            cache.token,</span>
 34 |     | <span class='neutral'>            amount,</span>
 35 | *   | <span class='executed'>            0</span>
 36 |     | <span class='neutral'>        ) {} catch {</span>
 37 |     | <span class='unexecuted'>            fl.t(false, &quot;BOND FAILED&quot;);</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/helpers/BeforeAfter.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {FuzzSetup} from &quot;../FuzzSetup.sol&quot;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='unexecuted'>contract BeforeAfter is FuzzSetup {}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/helpers/Properties.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
 2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>import {BeforeAfter} from &quot;./BeforeAfter.sol&quot;;</span>
 5 |     | <span class='neutral'></span>
 6 |     | <span class='unexecuted'>contract Properties is BeforeAfter {}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockERC20.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2 &lt;0.9.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import {IERC20} from &quot;./interfaces/IERC20.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>/// @notice This is a mock contract of the ERC20 standard for testing purposes only, it SHOULD NOT be used in production.</span>
   7 |     | <span class='neutral'>/// @dev Forked from: https://github.com/transmissions11/solmate/blob/0384dbaaa4fcb5715738a9254a7c0a4cb62cf458/src/tokens/ERC20.sol</span>
   8 | *   | <span class='executed'>contract MockERC20 is IERC20 {</span>
   9 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  10 |     | <span class='neutral'>                            METADATA STORAGE</span>
  11 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    string internal _name;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    string internal _symbol;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    uint8 internal _decimals;</span>
  18 |     | <span class='neutral'></span>
  19 | *   | <span class='executed'>    function name() external view override returns (string memory) {</span>
  20 |     | <span class='unexecuted'>        return _name;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>    function symbol() external view override returns (string memory) {</span>
  24 |     | <span class='unexecuted'>        return _symbol;</span>
  25 |     | <span class='neutral'>    }</span>
  26 |     | <span class='neutral'></span>
  27 | *   | <span class='executed'>    function decimals() external view override returns (uint8) {</span>
  28 | *   | <span class='executed'>        return _decimals;</span>
  29 |     | <span class='neutral'>    }</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  32 |     | <span class='neutral'>                              ERC20 STORAGE</span>
  33 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    uint256 internal _totalSupply;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    mapping(address =&gt; uint256) internal _balanceOf;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    mapping(address =&gt; mapping(address =&gt; uint256)) internal _allowance;</span>
  40 |     | <span class='neutral'></span>
  41 | *   | <span class='executed'>    function totalSupply() external view override returns (uint256) {</span>
  42 |     | <span class='unexecuted'>        return _totalSupply;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 | *   | <span class='executed'>    function balanceOf(address owner) external view override returns (uint256) {</span>
  46 | *   | <span class='executed'>        return _balanceOf[owner];</span>
  47 |     | <span class='neutral'>    }</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    function allowance(address owner, address spender) external view override returns (uint256) {</span>
  50 |     | <span class='unexecuted'>        return _allowance[owner][spender];</span>
  51 |     | <span class='neutral'>    }</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  54 |     | <span class='neutral'>                            EIP-2612 STORAGE</span>
  55 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    uint256 internal INITIAL_CHAIN_ID;</span>
  58 |     | <span class='neutral'></span>
  59 |     | <span class='neutral'>    bytes32 internal INITIAL_DOMAIN_SEPARATOR;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
  62 |     | <span class='neutral'></span>
  63 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  64 |     | <span class='neutral'>                               INITIALIZE</span>
  65 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    /// @dev A bool to track whether the contract has been initialized.</span>
  68 |     | <span class='neutral'>    bool private initialized;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @dev To hide constructor warnings across solc versions due to different constructor visibility requirements and</span>
  71 |     | <span class='neutral'>    /// syntaxes, we add an initialization function that can be called only once.</span>
  72 |     | <span class='unexecuted'>    function initialize(string memory name_, string memory symbol_, uint8 decimals_) public {</span>
  73 |     | <span class='unexecuted'>        require(!initialized, &quot;ALREADY_INITIALIZED&quot;);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='unexecuted'>        _name = name_;</span>
  76 |     | <span class='unexecuted'>        _symbol = symbol_;</span>
  77 |     | <span class='unexecuted'>        _decimals = decimals_;</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='unexecuted'>        INITIAL_CHAIN_ID = _pureChainId();</span>
  80 |     | <span class='unexecuted'>        INITIAL_DOMAIN_SEPARATOR = computeDomainSeparator();</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>        initialized = true;</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
  86 |     | <span class='neutral'>                               ERC20 LOGIC</span>
  87 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
  88 |     | <span class='neutral'></span>
  89 | *   | <span class='executed'>    function approve(address spender, uint256 amount) public virtual override returns (bool) {</span>
  90 | *   | <span class='executed'>        _allowance[msg.sender][spender] = amount;</span>
  91 |     | <span class='neutral'></span>
  92 | *   | <span class='executed'>        emit Approval(msg.sender, spender, amount);</span>
  93 |     | <span class='neutral'></span>
  94 | *   | <span class='executed'>        return true;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>    function transfer(address to, uint256 amount) public virtual override returns (bool) {</span>
  98 |     | <span class='unexecuted'>        _balanceOf[msg.sender] = _sub(_balanceOf[msg.sender], amount);</span>
  99 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>        emit Transfer(msg.sender, to, amount);</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>        return true;</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 | *   | <span class='executed'>    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {</span>
 107 | *   | <span class='executed'>        uint256 allowed = _allowance[from][msg.sender]; // Saves gas for limited approvals.</span>
 108 |     | <span class='neutral'></span>
 109 | *   | <span class='executed'>        if (allowed != ~uint256(0)) _allowance[from][msg.sender] = _sub(allowed, amount);</span>
 110 |     | <span class='neutral'></span>
 111 | *   | <span class='executed'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 112 | *   | <span class='executed'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 113 |     | <span class='neutral'></span>
 114 | *   | <span class='executed'>        emit Transfer(from, to, amount);</span>
 115 |     | <span class='neutral'></span>
 116 | *   | <span class='executed'>        return true;</span>
 117 |     | <span class='neutral'>    }</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    event Message(string a);</span>
 120 |     | <span class='neutral'></span>
 121 |     | <span class='unexecuted'>    function mint(address to, uint256 value) public {</span>
 122 |     | <span class='unexecuted'>        emit Message(&quot;HERE&quot;);</span>
 123 |     | <span class='unexecuted'>        _mint(to, value);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='unexecuted'>    function burn(address from, uint256 value) public virtual {</span>
 127 |     | <span class='unexecuted'>        _burn(from, value);</span>
 128 |     | <span class='neutral'>    }</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 131 |     | <span class='neutral'>                             EIP-2612 LOGIC</span>
 132 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 135 |     | <span class='neutral'>        public</span>
 136 |     | <span class='neutral'>        virtual</span>
 137 |     | <span class='unexecuted'>    {</span>
 138 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;PERMIT_DEADLINE_EXPIRED&quot;);</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(</span>
 141 |     | <span class='unexecuted'>            keccak256(</span>
 142 |     | <span class='unexecuted'>                abi.encodePacked(</span>
 143 |     | <span class='neutral'>                    &quot;\x19\x01&quot;,</span>
 144 |     | <span class='unexecuted'>                    DOMAIN_SEPARATOR(),</span>
 145 |     | <span class='unexecuted'>                    keccak256(</span>
 146 |     | <span class='unexecuted'>                        abi.encode(</span>
 147 |     | <span class='unexecuted'>                            keccak256(</span>
 148 |     | <span class='neutral'>                                &quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;</span>
 149 |     | <span class='neutral'>                            ),</span>
 150 |     | <span class='unexecuted'>                            owner,</span>
 151 |     | <span class='unexecuted'>                            spender,</span>
 152 |     | <span class='unexecuted'>                            value,</span>
 153 |     | <span class='unexecuted'>                            nonces[owner]++,</span>
 154 |     | <span class='neutral'>                            deadline</span>
 155 |     | <span class='neutral'>                        )</span>
 156 |     | <span class='neutral'>                    )</span>
 157 |     | <span class='neutral'>                )</span>
 158 |     | <span class='neutral'>            ),</span>
 159 |     | <span class='neutral'>            v,</span>
 160 |     | <span class='neutral'>            r,</span>
 161 |     | <span class='neutral'>            s</span>
 162 |     | <span class='neutral'>        );</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;INVALID_SIGNER&quot;);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        _allowance[recoveredAddress][spender] = value;</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>    function DOMAIN_SEPARATOR() public view virtual returns (bytes32) {</span>
 172 |     | <span class='unexecuted'>        return _pureChainId() == INITIAL_CHAIN_ID ? INITIAL_DOMAIN_SEPARATOR : computeDomainSeparator();</span>
 173 |     | <span class='neutral'>    }</span>
 174 |     | <span class='neutral'></span>
 175 |     | <span class='unexecuted'>    function computeDomainSeparator() internal view virtual returns (bytes32) {</span>
 176 |     | <span class='unexecuted'>        return keccak256(</span>
 177 |     | <span class='unexecuted'>            abi.encode(</span>
 178 |     | <span class='unexecuted'>                keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 179 |     | <span class='unexecuted'>                keccak256(bytes(_name)),</span>
 180 |     | <span class='unexecuted'>                keccak256(&quot;1&quot;),</span>
 181 |     | <span class='unexecuted'>                _pureChainId(),</span>
 182 |     | <span class='unexecuted'>                address(this)</span>
 183 |     | <span class='neutral'>            )</span>
 184 |     | <span class='neutral'>        );</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 188 |     | <span class='neutral'>                        INTERNAL MINT/BURN LOGIC</span>
 189 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>    function _mint(address to, uint256 amount) internal virtual {</span>
 192 |     | <span class='unexecuted'>        _totalSupply = _add(_totalSupply, amount);</span>
 193 |     | <span class='unexecuted'>        _balanceOf[to] = _add(_balanceOf[to], amount);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='unexecuted'>        emit Transfer(address(0), to, amount);</span>
 196 |     | <span class='neutral'>    }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function _burn(address from, uint256 amount) internal virtual {</span>
 199 |     | <span class='unexecuted'>        _balanceOf[from] = _sub(_balanceOf[from], amount);</span>
 200 |     | <span class='unexecuted'>        _totalSupply = _sub(_totalSupply, amount);</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        emit Transfer(from, address(0), amount);</span>
 203 |     | <span class='neutral'>    }</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 206 |     | <span class='neutral'>                        INTERNAL SAFE MATH LOGIC</span>
 207 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 208 |     | <span class='neutral'></span>
 209 | *   | <span class='executed'>    function _add(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 210 | *   | <span class='executed'>        uint256 c = a + b;</span>
 211 | *   | <span class='executed'>        require(c &gt;= a, &quot;ERC20: addition overflow&quot;);</span>
 212 |     | <span class='neutral'>        return c;</span>
 213 |     | <span class='neutral'>    }</span>
 214 |     | <span class='neutral'></span>
 215 | *   | <span class='executed'>    function _sub(uint256 a, uint256 b) internal pure returns (uint256) {</span>
 216 | *   | <span class='executed'>        require(a &gt;= b, &quot;ERC20: subtraction underflow&quot;);</span>
 217 | *   | <span class='executed'>        return a - b;</span>
 218 |     | <span class='neutral'>    }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='neutral'>    /*//////////////////////////////////////////////////////////////</span>
 221 |     | <span class='neutral'>                                HELPERS</span>
 222 |     | <span class='neutral'>    //////////////////////////////////////////////////////////////*/</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    // We use this complex approach of `_viewChainId` and `_pureChainId` to ensure there are no</span>
 225 |     | <span class='neutral'>    // compiler warnings when accessing chain ID in any solidity version supported by forge-std. We</span>
 226 |     | <span class='neutral'>    // can&#39;t simply access the chain ID in a normal view or pure function because the solc View Pure</span>
 227 |     | <span class='neutral'>    // Checker changed `chainid` from pure to view in 0.8.0.</span>
 228 |     | <span class='unexecuted'>    function _viewChainId() private view returns (uint256 chainId) {</span>
 229 |     | <span class='neutral'>        // Assembly required since `block.chainid` was introduced in 0.8.0.</span>
 230 |     | <span class='neutral'>        assembly {</span>
 231 |     | <span class='unexecuted'>            chainId := chainid()</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'></span>
 234 |     | <span class='neutral'>        address(this); // Silence warnings in older Solc versions.</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'></span>
 237 |     | <span class='unexecuted'>    function _pureChainId() private pure returns (uint256 chainId) {</span>
 238 |     | <span class='unexecuted'>        function() internal view returns (uint256) fnIn = _viewChainId;</span>
 239 |     | <span class='neutral'>        function() internal pure returns (uint256) pureChainId;</span>
 240 |     | <span class='neutral'>        assembly {</span>
 241 |     | <span class='neutral'>            pureChainId := fnIn</span>
 242 |     | <span class='neutral'>        }</span>
 243 |     | <span class='unexecuted'>        chainId = pureChainId();</span>
 244 |     | <span class='neutral'>    }</span>
 245 |     | <span class='neutral'>}</span>
 246 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockIndexUtils.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IDecentralizedIndex.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IDexAdapter.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IIndexUtils.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IStakingPoolToken.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/ITokenRewards.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IUniswapV2Factory.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IUniswapV3Pool.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IUniswapV2Router02.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IWETH.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./MockZapper.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract MockIndexUtils is Context, IIndexUtils, MockZapper {</span>
  21 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>  constructor(</span>
  24 |     | <span class='neutral'>    IV3TwapUtilities _v3TwapUtilities,</span>
  25 |     | <span class='neutral'>    IDexAdapter _dexAdapter,</span>
  26 |     | <span class='neutral'>    address _V3_ROUTER</span>
  27 |     | <span class='unexecuted'>  ) MockZapper(_v3TwapUtilities, _dexAdapter, _V3_ROUTER) {}</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='unexecuted'>  function bond(</span>
  30 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
  31 |     | <span class='neutral'>    address _token,</span>
  32 |     | <span class='neutral'>    uint256 _amount,</span>
  33 |     | <span class='neutral'>    uint256 _amountMintMin</span>
  34 |     | <span class='unexecuted'>  ) external {</span>
  35 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund</span>
  36 |     | <span class='neutral'>      .getAllAssets();</span>
  37 |     | <span class='unexecuted'>    uint256[] memory _balsBefore = new uint256[](_assets.length);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    uint256 _tokenCurSupply = IERC20(_token).balanceOf(address(_indexFund));</span>
  40 |     | <span class='unexecuted'>    uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0</span>
  41 |     | <span class='neutral'>      ? FixedPoint96.Q96</span>
  42 |     | <span class='unexecuted'>      : (_amount * FixedPoint96.Q96) / _tokenCurSupply;</span>
  43 |     | <span class='unexecuted'>    uint256 _al = _assets.length;</span>
  44 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
  45 |     | <span class='unexecuted'>      uint256 _amountNeeded = _indexFund.totalSupply() == 0</span>
  46 |     | <span class='unexecuted'>        ? _indexFund.getInitialAmount(_token, _amount, _assets[_i].token)</span>
  47 |     | <span class='unexecuted'>        : (IERC20(_assets[_i].token).balanceOf(address(_indexFund)) *</span>
  48 |     | <span class='unexecuted'>          _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;</span>
  49 |     | <span class='unexecuted'>      _balsBefore[_i] = IERC20(_assets[_i].token).balanceOf(address(this));</span>
  50 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeTransferFrom(</span>
  51 |     | <span class='neutral'>        _msgSender(),</span>
  52 |     | <span class='unexecuted'>        address(this),</span>
  53 |     | <span class='unexecuted'>        _amountNeeded</span>
  54 |     | <span class='neutral'>      );</span>
  55 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeIncreaseAllowance(</span>
  56 |     | <span class='unexecuted'>        address(_indexFund),</span>
  57 |     | <span class='unexecuted'>        _amountNeeded</span>
  58 |     | <span class='neutral'>      );</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='unexecuted'>    uint256 _idxBalBefore = IERC20(_indexFund).balanceOf(address(this));</span>
  61 |     | <span class='unexecuted'>    _indexFund.bond(_token, _amount, _amountMintMin);</span>
  62 |     | <span class='unexecuted'>    IERC20(_indexFund).safeTransfer(</span>
  63 |     | <span class='unexecuted'>      _msgSender(),</span>
  64 |     | <span class='neutral'>      IERC20(_indexFund).balanceOf(address(this)) - _idxBalBefore</span>
  65 |     | <span class='neutral'>    );</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // refund any excess tokens to user we didn&#39;t use to bond</span>
  68 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
  69 |     | <span class='unexecuted'>      _checkAndRefundERC20(_msgSender(), _assets[_i].token, _balsBefore[_i]);</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'>  }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>  function bondWeightedFromNative(</span>
  74 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
  75 |     | <span class='neutral'>    uint256 _assetIdx,</span>
  76 |     | <span class='neutral'>    uint256 _amountTokensForAssetIdx,</span>
  77 |     | <span class='neutral'>    uint256 _amountMintMin,</span>
  78 |     | <span class='neutral'>    uint256 _amountPairedLpTokenMin,</span>
  79 |     | <span class='neutral'>    uint256 _slippage, // 1 == 0.1%, 10 == 1%, 1000 == 100%</span>
  80 |     | <span class='neutral'>    uint256 _deadline,</span>
  81 |     | <span class='neutral'>    bool _stakeAsWell</span>
  82 |     | <span class='unexecuted'>  ) external payable {</span>
  83 |     | <span class='unexecuted'>    require(msg.value &gt; 0, &#39;NATIVE&#39;);</span>
  84 |     | <span class='unexecuted'>    uint256 _ethBalBefore = address(this).balance - msg.value;</span>
  85 |     | <span class='unexecuted'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets = _indexFund</span>
  86 |     | <span class='neutral'>      .getAllAssets();</span>
  87 |     | <span class='unexecuted'>    (</span>
  88 |     | <span class='unexecuted'>      uint256[] memory _balancesBefore,</span>
  89 |     | <span class='unexecuted'>      uint256[] memory _amountsReceived</span>
  90 |     | <span class='unexecuted'>    ) = _swapNativeForTokensWeightedV2(</span>
  91 |     | <span class='unexecuted'>        _indexFund,</span>
  92 |     | <span class='unexecuted'>        _stakeAsWell ? msg.value / 2 : msg.value,</span>
  93 |     | <span class='unexecuted'>        _assets,</span>
  94 |     | <span class='unexecuted'>        _assetIdx,</span>
  95 |     | <span class='unexecuted'>        _amountTokensForAssetIdx</span>
  96 |     | <span class='neutral'>      );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    // allowance for _assetIdx is increased in _bondToRecipient below,</span>
  99 |     | <span class='neutral'>    // we just need to increase allowance for any other index tokens here first</span>
 100 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _assets.length; _i++) {</span>
 101 |     | <span class='unexecuted'>      if (_i == _assetIdx) {</span>
 102 |     | <span class='unexecuted'>        continue;</span>
 103 |     | <span class='neutral'>      }</span>
 104 |     | <span class='unexecuted'>      IERC20(_assets[_i].token).safeIncreaseAllowance(</span>
 105 |     | <span class='unexecuted'>        address(_indexFund),</span>
 106 |     | <span class='unexecuted'>        _amountsReceived[_i]</span>
 107 |     | <span class='neutral'>      );</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='unexecuted'>    uint256 _idxTokensGained = _bondToRecipient(</span>
 110 |     | <span class='unexecuted'>      _indexFund,</span>
 111 |     | <span class='unexecuted'>      _assets[_assetIdx].token,</span>
 112 |     | <span class='unexecuted'>      _amountsReceived[_assetIdx],</span>
 113 |     | <span class='unexecuted'>      _amountMintMin,</span>
 114 |     | <span class='unexecuted'>      _stakeAsWell ? address(this) : _msgSender()</span>
 115 |     | <span class='neutral'>    );</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    if (_stakeAsWell) {</span>
 118 |     | <span class='unexecuted'>      _zapIndexTokensAndNative(</span>
 119 |     | <span class='neutral'>        _msgSender(),</span>
 120 |     | <span class='unexecuted'>        _indexFund,</span>
 121 |     | <span class='unexecuted'>        _idxTokensGained,</span>
 122 |     | <span class='unexecuted'>        msg.value / 2,</span>
 123 |     | <span class='unexecuted'>        _amountPairedLpTokenMin,</span>
 124 |     | <span class='unexecuted'>        _slippage,</span>
 125 |     | <span class='unexecuted'>        _deadline</span>
 126 |     | <span class='neutral'>      );</span>
 127 |     | <span class='neutral'>    }</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='neutral'>    // refund any excess tokens to user we didn&#39;t use to bond</span>
 130 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _assets.length; _i++) {</span>
 131 |     | <span class='unexecuted'>      _checkAndRefundERC20(</span>
 132 |     | <span class='neutral'>        _msgSender(),</span>
 133 |     | <span class='unexecuted'>        _assets[_i].token,</span>
 134 |     | <span class='unexecuted'>        _balancesBefore[_i]</span>
 135 |     | <span class='neutral'>      );</span>
 136 |     | <span class='neutral'>    }</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>    // refund excess ETH</span>
 139 |     | <span class='unexecuted'>    if (address(this).balance &gt; _ethBalBefore) {</span>
 140 |     | <span class='unexecuted'>      (bool _s, ) = payable(_msgSender()).call{</span>
 141 |     | <span class='unexecuted'>        value: address(this).balance - _ethBalBefore</span>
 142 |     | <span class='neutral'>      }(&#39;&#39;);</span>
 143 |     | <span class='unexecuted'>      require(_s, &#39;ETHREFUND&#39;);</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>  }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>  function addLPAndStake(</span>
 148 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 149 |     | <span class='neutral'>    uint256 _amountIdxTokens,</span>
 150 |     | <span class='neutral'>    address _pairedLpTokenProvided,</span>
 151 |     | <span class='neutral'>    uint256 _amtPairedLpTokenProvided,</span>
 152 |     | <span class='neutral'>    uint256 _amountPairedLpTokenMin,</span>
 153 |     | <span class='neutral'>    uint256 _slippage,</span>
 154 |     | <span class='neutral'>    uint256 _deadline</span>
 155 |     | <span class='unexecuted'>  ) external payable override returns (uint256 _amountOut) {</span>
 156 |     | <span class='unexecuted'>    address _indexFundAddy = address(_indexFund);</span>
 157 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 158 |     | <span class='unexecuted'>    uint256 _idxTokensBefore = IERC20(_indexFundAddy).balanceOf(address(this));</span>
 159 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 160 |     | <span class='unexecuted'>      address(this)</span>
 161 |     | <span class='neutral'>    );</span>
 162 |     | <span class='unexecuted'>    uint256 _ethBefore = address(this).balance - msg.value;</span>
 163 |     | <span class='unexecuted'>    IERC20(_indexFundAddy).safeTransferFrom(</span>
 164 |     | <span class='neutral'>      _msgSender(),</span>
 165 |     | <span class='unexecuted'>      address(this),</span>
 166 |     | <span class='unexecuted'>      _amountIdxTokens</span>
 167 |     | <span class='neutral'>    );</span>
 168 |     | <span class='unexecuted'>    if (_pairedLpTokenProvided == address(0)) {</span>
 169 |     | <span class='unexecuted'>      require(msg.value &gt; 0, &#39;NEEDETH&#39;);</span>
 170 |     | <span class='unexecuted'>      _amtPairedLpTokenProvided = msg.value;</span>
 171 |     | <span class='neutral'>    } else {</span>
 172 |     | <span class='unexecuted'>      IERC20(_pairedLpTokenProvided).safeTransferFrom(</span>
 173 |     | <span class='neutral'>        _msgSender(),</span>
 174 |     | <span class='unexecuted'>        address(this),</span>
 175 |     | <span class='unexecuted'>        _amtPairedLpTokenProvided</span>
 176 |     | <span class='neutral'>      );</span>
 177 |     | <span class='neutral'>    }</span>
 178 |     | <span class='unexecuted'>    if (_pairedLpTokenProvided != _pairedLpToken) {</span>
 179 |     | <span class='unexecuted'>      _zap(</span>
 180 |     | <span class='unexecuted'>        _pairedLpTokenProvided,</span>
 181 |     | <span class='unexecuted'>        _pairedLpToken,</span>
 182 |     | <span class='unexecuted'>        _amtPairedLpTokenProvided,</span>
 183 |     | <span class='unexecuted'>        _amountPairedLpTokenMin</span>
 184 |     | <span class='neutral'>      );</span>
 185 |     | <span class='neutral'>    }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(</span>
 188 |     | <span class='unexecuted'>      _indexFundAddy,</span>
 189 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 190 |     | <span class='neutral'>    );</span>
 191 |     | <span class='unexecuted'>    _amountOut = _indexFund.addLiquidityV2(</span>
 192 |     | <span class='unexecuted'>      IERC20(_indexFundAddy).balanceOf(address(this)) - _idxTokensBefore,</span>
 193 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,</span>
 194 |     | <span class='neutral'>      _slippage,</span>
 195 |     | <span class='neutral'>      _deadline</span>
 196 |     | <span class='neutral'>    );</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    IERC20(DEX_ADAPTER.getV2Pool(_indexFundAddy, _pairedLpToken))</span>
 199 |     | <span class='unexecuted'>      .safeIncreaseAllowance(_indexFund.lpStakingPool(), _amountOut);</span>
 200 |     | <span class='unexecuted'>    IStakingPoolToken(_indexFund.lpStakingPool()).stake(</span>
 201 |     | <span class='neutral'>      _msgSender(),</span>
 202 |     | <span class='neutral'>      _amountOut</span>
 203 |     | <span class='neutral'>    );</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    // refunds if needed for index tokens and pairedLpToken</span>
 206 |     | <span class='unexecuted'>    if (address(this).balance &gt; _ethBefore) {</span>
 207 |     | <span class='unexecuted'>      (bool _s, ) = payable(_msgSender()).call{</span>
 208 |     | <span class='unexecuted'>        value: address(this).balance - _ethBefore</span>
 209 |     | <span class='neutral'>      }(&#39;&#39;);</span>
 210 |     | <span class='unexecuted'>      require(_s &amp;&amp; address(this).balance &gt;= _ethBefore, &#39;TOOMUCH&#39;);</span>
 211 |     | <span class='neutral'>    }</span>
 212 |     | <span class='unexecuted'>    _checkAndRefundERC20(_msgSender(), _indexFundAddy, _idxTokensBefore);</span>
 213 |     | <span class='unexecuted'>    _checkAndRefundERC20(_msgSender(), _pairedLpToken, _pairedLpTokenBefore);</span>
 214 |     | <span class='neutral'>  }</span>
 215 |     | <span class='neutral'></span>
 216 |     | <span class='unexecuted'>  function unstakeAndRemoveLP(</span>
 217 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 218 |     | <span class='neutral'>    uint256 _amountStakedTokens,</span>
 219 |     | <span class='neutral'>    uint256 _minLPTokens,</span>
 220 |     | <span class='neutral'>    uint256 _minPairedLpToken,</span>
 221 |     | <span class='neutral'>    uint256 _deadline</span>
 222 |     | <span class='unexecuted'>  ) external override {</span>
 223 |     | <span class='unexecuted'>    address _stakingPool = _indexFund.lpStakingPool();</span>
 224 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 225 |     | <span class='unexecuted'>    uint256 _stakingBalBefore = IERC20(_stakingPool).balanceOf(address(this));</span>
 226 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 227 |     | <span class='unexecuted'>      address(this)</span>
 228 |     | <span class='neutral'>    );</span>
 229 |     | <span class='unexecuted'>    IERC20(_stakingPool).safeTransferFrom(</span>
 230 |     | <span class='neutral'>      _msgSender(),</span>
 231 |     | <span class='unexecuted'>      address(this),</span>
 232 |     | <span class='unexecuted'>      _amountStakedTokens</span>
 233 |     | <span class='neutral'>    );</span>
 234 |     | <span class='unexecuted'>    uint256 _indexBalBefore = _unstakeAndRemoveLP(</span>
 235 |     | <span class='unexecuted'>      _indexFund,</span>
 236 |     | <span class='unexecuted'>      _stakingPool,</span>
 237 |     | <span class='unexecuted'>      IERC20(_stakingPool).balanceOf(address(this)) - _stakingBalBefore,</span>
 238 |     | <span class='unexecuted'>      _minLPTokens,</span>
 239 |     | <span class='unexecuted'>      _minPairedLpToken,</span>
 240 |     | <span class='unexecuted'>      _deadline</span>
 241 |     | <span class='neutral'>    );</span>
 242 |     | <span class='unexecuted'>    if (</span>
 243 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).balanceOf(address(this)) &gt; _indexBalBefore</span>
 244 |     | <span class='neutral'>    ) {</span>
 245 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(</span>
 246 |     | <span class='unexecuted'>        _msgSender(),</span>
 247 |     | <span class='unexecuted'>        IERC20(address(_indexFund)).balanceOf(address(this)) - _indexBalBefore</span>
 248 |     | <span class='neutral'>      );</span>
 249 |     | <span class='neutral'>    }</span>
 250 |     | <span class='unexecuted'>    if (</span>
 251 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) &gt; _pairedLpTokenBefore</span>
 252 |     | <span class='neutral'>    ) {</span>
 253 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).safeTransfer(</span>
 254 |     | <span class='neutral'>        _msgSender(),</span>
 255 |     | <span class='unexecuted'>        IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 256 |     | <span class='neutral'>      );</span>
 257 |     | <span class='neutral'>    }</span>
 258 |     | <span class='neutral'>  }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>  function claimRewardsMulti(address[] memory _rewards) external {</span>
 261 |     | <span class='unexecuted'>    uint256 _rl = _rewards.length;</span>
 262 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _rl; _i++) {</span>
 263 |     | <span class='unexecuted'>      ITokenRewards(_rewards[_i]).claimReward(_msgSender());</span>
 264 |     | <span class='neutral'>    }</span>
 265 |     | <span class='neutral'>  }</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='unexecuted'>  function _swapNativeForTokensWeightedV2(</span>
 268 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 269 |     | <span class='neutral'>    uint256 _amountNative,</span>
 270 |     | <span class='neutral'>    IDecentralizedIndex.IndexAssetInfo[] memory _assets,</span>
 271 |     | <span class='neutral'>    uint256 _poolIdx,</span>
 272 |     | <span class='neutral'>    uint256 _amountForPoolIdx</span>
 273 |     | <span class='unexecuted'>  ) internal returns (uint256[] memory, uint256[] memory) {</span>
 274 |     | <span class='unexecuted'>    uint256[] memory _amountBefore = new uint256[](_assets.length);</span>
 275 |     | <span class='unexecuted'>    uint256[] memory _amountReceived = new uint256[](_assets.length);</span>
 276 |     | <span class='unexecuted'>    uint256 _tokenCurSupply = IERC20(_assets[_poolIdx].token).balanceOf(</span>
 277 |     | <span class='neutral'>      address(_indexFund)</span>
 278 |     | <span class='neutral'>    );</span>
 279 |     | <span class='unexecuted'>    uint256 _tokenAmtSupplyRatioX96 = _indexFund.totalSupply() == 0</span>
 280 |     | <span class='neutral'>      ? FixedPoint96.Q96</span>
 281 |     | <span class='unexecuted'>      : (_amountForPoolIdx * FixedPoint96.Q96) / _tokenCurSupply;</span>
 282 |     | <span class='unexecuted'>    uint256 _nativeLeft = _amountNative;</span>
 283 |     | <span class='unexecuted'>    uint256 _al = _assets.length;</span>
 284 |     | <span class='unexecuted'>    for (uint256 _i; _i &lt; _al; _i++) {</span>
 285 |     | <span class='unexecuted'>      (_nativeLeft, _amountBefore[_i], _amountReceived[_i]) = _swapForIdxToken(</span>
 286 |     | <span class='unexecuted'>        _indexFund,</span>
 287 |     | <span class='unexecuted'>        _assets[_poolIdx].token,</span>
 288 |     | <span class='unexecuted'>        _amountForPoolIdx,</span>
 289 |     | <span class='unexecuted'>        _assets[_i].token,</span>
 290 |     | <span class='unexecuted'>        _tokenAmtSupplyRatioX96,</span>
 291 |     | <span class='unexecuted'>        _nativeLeft</span>
 292 |     | <span class='neutral'>      );</span>
 293 |     | <span class='neutral'>    }</span>
 294 |     | <span class='unexecuted'>    return (_amountBefore, _amountReceived);</span>
 295 |     | <span class='neutral'>  }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>  function _swapForIdxToken(</span>
 298 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 299 |     | <span class='neutral'>    address _initToken,</span>
 300 |     | <span class='neutral'>    uint256 _initTokenAmount,</span>
 301 |     | <span class='neutral'>    address _outToken,</span>
 302 |     | <span class='neutral'>    uint256 _tokenAmtSupplyRatioX96,</span>
 303 |     | <span class='neutral'>    uint256 _nativeLeft</span>
 304 |     | <span class='neutral'>  )</span>
 305 |     | <span class='neutral'>    internal</span>
 306 |     | <span class='neutral'>    returns (</span>
 307 |     | <span class='unexecuted'>      uint256 _newNativeLeft,</span>
 308 |     | <span class='unexecuted'>      uint256 _amountBefore,</span>
 309 |     | <span class='unexecuted'>      uint256 _amountReceived</span>
 310 |     | <span class='neutral'>    )</span>
 311 |     | <span class='unexecuted'>  {</span>
 312 |     | <span class='unexecuted'>    address _weth = DEX_ADAPTER.WETH();</span>
 313 |     | <span class='unexecuted'>    if (address(this).balance &gt; 0) {</span>
 314 |     | <span class='unexecuted'>      IWETH(WETH).deposit{ value: address(this).balance }();</span>
 315 |     | <span class='neutral'>    }</span>
 316 |     | <span class='unexecuted'>    uint256 _nativeBefore = IERC20(_weth).balanceOf(address(this));</span>
 317 |     | <span class='unexecuted'>    _amountBefore = IERC20(_outToken).balanceOf(address(this));</span>
 318 |     | <span class='unexecuted'>    uint256 _amountOut = _indexFund.totalSupply() == 0</span>
 319 |     | <span class='unexecuted'>      ? _indexFund.getInitialAmount(_initToken, _initTokenAmount, _outToken)</span>
 320 |     | <span class='unexecuted'>      : (IERC20(_outToken).balanceOf(address(_indexFund)) *</span>
 321 |     | <span class='unexecuted'>        _tokenAmtSupplyRatioX96) / FixedPoint96.Q96;</span>
 322 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 323 |     | <span class='neutral'>      _weth,</span>
 324 |     | <span class='neutral'>      _outToken,</span>
 325 |     | <span class='neutral'>      _nativeLeft,</span>
 326 |     | <span class='neutral'>      _amountOut,</span>
 327 |     | <span class='unexecuted'>      address(this)</span>
 328 |     | <span class='neutral'>    );</span>
 329 |     | <span class='unexecuted'>    _newNativeLeft =</span>
 330 |     | <span class='unexecuted'>      _nativeLeft -</span>
 331 |     | <span class='unexecuted'>      (_nativeBefore - IERC20(_weth).balanceOf(address(this)));</span>
 332 |     | <span class='unexecuted'>    _amountReceived =</span>
 333 |     | <span class='unexecuted'>      IERC20(_outToken).balanceOf(address(this)) -</span>
 334 |     | <span class='unexecuted'>      _amountBefore;</span>
 335 |     | <span class='neutral'>  }</span>
 336 |     | <span class='neutral'></span>
 337 |     | <span class='unexecuted'>  function _unstakeAndRemoveLP(</span>
 338 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 339 |     | <span class='neutral'>    address _stakingPool,</span>
 340 |     | <span class='neutral'>    uint256 _unstakeAmount,</span>
 341 |     | <span class='neutral'>    uint256 _minLPTokens,</span>
 342 |     | <span class='neutral'>    uint256 _minPairedLpTokens,</span>
 343 |     | <span class='neutral'>    uint256 _deadline</span>
 344 |     | <span class='unexecuted'>  ) internal returns (uint256 _fundTokensBefore) {</span>
 345 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 346 |     | <span class='unexecuted'>    address _v2Pool = DEX_ADAPTER.getV2Pool(</span>
 347 |     | <span class='neutral'>      address(_indexFund),</span>
 348 |     | <span class='neutral'>      _pairedLpToken</span>
 349 |     | <span class='neutral'>    );</span>
 350 |     | <span class='unexecuted'>    uint256 _v2TokensBefore = IERC20(_v2Pool).balanceOf(address(this));</span>
 351 |     | <span class='unexecuted'>    IStakingPoolToken(_stakingPool).unstake(_unstakeAmount);</span>
 352 |     | <span class='neutral'></span>
 353 |     | <span class='unexecuted'>    _fundTokensBefore = _indexFund.balanceOf(address(this));</span>
 354 |     | <span class='unexecuted'>    IERC20(_v2Pool).safeIncreaseAllowance(</span>
 355 |     | <span class='unexecuted'>      address(_indexFund),</span>
 356 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore</span>
 357 |     | <span class='neutral'>    );</span>
 358 |     | <span class='unexecuted'>    _indexFund.removeLiquidityV2(</span>
 359 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _v2TokensBefore,</span>
 360 |     | <span class='neutral'>      _minLPTokens,</span>
 361 |     | <span class='neutral'>      _minPairedLpTokens,</span>
 362 |     | <span class='neutral'>      _deadline</span>
 363 |     | <span class='neutral'>    );</span>
 364 |     | <span class='neutral'>  }</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>  function _bondToRecipient(</span>
 367 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 368 |     | <span class='neutral'>    address _indexToken,</span>
 369 |     | <span class='neutral'>    uint256 _bondTokens,</span>
 370 |     | <span class='neutral'>    uint256 _amountMintMin,</span>
 371 |     | <span class='neutral'>    address _recipient</span>
 372 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 373 |     | <span class='unexecuted'>    uint256 _idxTokensBefore = IERC20(address(_indexFund)).balanceOf(</span>
 374 |     | <span class='unexecuted'>      address(this)</span>
 375 |     | <span class='neutral'>    );</span>
 376 |     | <span class='unexecuted'>    IERC20(_indexToken).safeIncreaseAllowance(address(_indexFund), _bondTokens);</span>
 377 |     | <span class='unexecuted'>    _indexFund.bond(_indexToken, _bondTokens, _amountMintMin);</span>
 378 |     | <span class='unexecuted'>    uint256 _idxTokensGained = IERC20(address(_indexFund)).balanceOf(</span>
 379 |     | <span class='unexecuted'>      address(this)</span>
 380 |     | <span class='unexecuted'>    ) - _idxTokensBefore;</span>
 381 |     | <span class='unexecuted'>    if (_recipient != address(this)) {</span>
 382 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(_recipient, _idxTokensGained);</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='unexecuted'>    return _idxTokensGained;</span>
 385 |     | <span class='neutral'>  }</span>
 386 |     | <span class='neutral'></span>
 387 |     | <span class='unexecuted'>  function _zapIndexTokensAndNative(</span>
 388 |     | <span class='neutral'>    address _user,</span>
 389 |     | <span class='neutral'>    IDecentralizedIndex _indexFund,</span>
 390 |     | <span class='neutral'>    uint256 _amountTokens,</span>
 391 |     | <span class='neutral'>    uint256 _amountETH,</span>
 392 |     | <span class='neutral'>    uint256 _amtPairedLpTokenMin,</span>
 393 |     | <span class='neutral'>    uint256 _slippage,</span>
 394 |     | <span class='neutral'>    uint256 _deadline</span>
 395 |     | <span class='neutral'>  ) internal {</span>
 396 |     | <span class='unexecuted'>    address _pairedLpToken = _indexFund.PAIRED_LP_TOKEN();</span>
 397 |     | <span class='unexecuted'>    uint256 _tokensBefore = IERC20(address(_indexFund)).balanceOf(</span>
 398 |     | <span class='unexecuted'>      address(this)</span>
 399 |     | <span class='unexecuted'>    ) - _amountTokens;</span>
 400 |     | <span class='unexecuted'>    uint256 _pairedLpTokenBefore = IERC20(_pairedLpToken).balanceOf(</span>
 401 |     | <span class='unexecuted'>      address(this)</span>
 402 |     | <span class='neutral'>    );</span>
 403 |     | <span class='unexecuted'>    address _stakingPool = _indexFund.lpStakingPool();</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>    _zap(address(0), _pairedLpToken, _amountETH, _amtPairedLpTokenMin);</span>
 406 |     | <span class='neutral'></span>
 407 |     | <span class='unexecuted'>    address _v2Pool = DEX_ADAPTER.getV2Pool(</span>
 408 |     | <span class='neutral'>      address(_indexFund),</span>
 409 |     | <span class='neutral'>      _pairedLpToken</span>
 410 |     | <span class='neutral'>    );</span>
 411 |     | <span class='unexecuted'>    uint256 _lpTokensBefore = IERC20(_v2Pool).balanceOf(address(this));</span>
 412 |     | <span class='unexecuted'>    IERC20(_pairedLpToken).safeIncreaseAllowance(</span>
 413 |     | <span class='unexecuted'>      address(_indexFund),</span>
 414 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 415 |     | <span class='neutral'>    );</span>
 416 |     | <span class='unexecuted'>    _indexFund.addLiquidityV2(</span>
 417 |     | <span class='unexecuted'>      _amountTokens,</span>
 418 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore,</span>
 419 |     | <span class='neutral'>      _slippage,</span>
 420 |     | <span class='neutral'>      _deadline</span>
 421 |     | <span class='neutral'>    );</span>
 422 |     | <span class='unexecuted'>    IERC20(_v2Pool).safeIncreaseAllowance(</span>
 423 |     | <span class='unexecuted'>      _stakingPool,</span>
 424 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore</span>
 425 |     | <span class='neutral'>    );</span>
 426 |     | <span class='unexecuted'>    IStakingPoolToken(_stakingPool).stake(</span>
 427 |     | <span class='unexecuted'>      _user,</span>
 428 |     | <span class='unexecuted'>      IERC20(_v2Pool).balanceOf(address(this)) - _lpTokensBefore</span>
 429 |     | <span class='neutral'>    );</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>    // check &amp; refund excess tokens from LPing as needed</span>
 432 |     | <span class='unexecuted'>    if (IERC20(address(_indexFund)).balanceOf(address(this)) &gt; _tokensBefore) {</span>
 433 |     | <span class='unexecuted'>      IERC20(address(_indexFund)).safeTransfer(</span>
 434 |     | <span class='unexecuted'>        _user,</span>
 435 |     | <span class='unexecuted'>        IERC20(address(_indexFund)).balanceOf(address(this)) - _tokensBefore</span>
 436 |     | <span class='neutral'>      );</span>
 437 |     | <span class='neutral'>    }</span>
 438 |     | <span class='unexecuted'>    if (</span>
 439 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).balanceOf(address(this)) &gt; _pairedLpTokenBefore</span>
 440 |     | <span class='neutral'>    ) {</span>
 441 |     | <span class='unexecuted'>      IERC20(_pairedLpToken).safeTransfer(</span>
 442 |     | <span class='unexecuted'>        _user,</span>
 443 |     | <span class='unexecuted'>        IERC20(_pairedLpToken).balanceOf(address(this)) - _pairedLpTokenBefore</span>
 444 |     | <span class='neutral'>      );</span>
 445 |     | <span class='neutral'>    }</span>
 446 |     | <span class='neutral'>  }</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>  function _checkAndRefundERC20(</span>
 449 |     | <span class='neutral'>    address _user,</span>
 450 |     | <span class='neutral'>    address _asset,</span>
 451 |     | <span class='neutral'>    uint256 _beforeBal</span>
 452 |     | <span class='neutral'>  ) internal {</span>
 453 |     | <span class='unexecuted'>    uint256 _curBal = IERC20(_asset).balanceOf(address(this));</span>
 454 |     | <span class='unexecuted'>    if (_curBal &gt; _beforeBal) {</span>
 455 |     | <span class='unexecuted'>      IERC20(_asset).safeTransfer(_user, _curBal - _beforeBal);</span>
 456 |     | <span class='neutral'>    }</span>
 457 |     | <span class='neutral'>  }</span>
 458 |     | <span class='neutral'>}</span>
 459 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockUniV3Minter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// uniswap-v3-core</span>
  5 |     | <span class='neutral'>import {UniswapV3Factory} from &quot;v3-core/UniswapV3Factory.sol&quot;;</span>
  6 |     | <span class='neutral'>import {UniswapV3Pool} from &quot;v3-core/UniswapV3Pool.sol&quot;;</span>
  7 |     | <span class='neutral'>import {IUniswapV3MintCallback} from &quot;v3-core/interfaces/callback/IUniswapV3MintCallback.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>// uniswap-v3-periphery</span>
 10 |     | <span class='neutral'>import {SwapRouter} from &quot;v3-periphery/SwapRouter.sol&quot;;</span>
 11 |     | <span class='neutral'>import {LiquidityManagement} from &quot;v3-periphery/base/LiquidityManagement.sol&quot;;</span>
 12 |     | <span class='neutral'>import {PeripheryPayments} from &quot;v3-periphery/base/PeripheryPayments.sol&quot;;</span>
 13 |     | <span class='neutral'>import {PoolAddress} from &quot;v3-periphery/libraries/PoolAddress.sol&quot;;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>// mocks</span>
 17 |     | <span class='neutral'>import {WETH9} from &quot;./WETH.sol&quot;;</span>
 18 |     | <span class='neutral'>import { IERC20 } from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
 19 |     | <span class='neutral'>import {MockERC20} from &quot;./MockERC20.sol&quot;;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>contract MockUniV3Minter is IUniswapV3MintCallback {</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor() {}</span>
 25 |     | <span class='unexecuted'>    function V3addLiquidity(UniswapV3Pool _pool, uint256 amount) public {</span>
 26 |     | <span class='unexecuted'>        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({</span>
 27 |     | <span class='unexecuted'>            token0: _pool.token0(),</span>
 28 |     | <span class='unexecuted'>            token1: _pool.token1(),</span>
 29 |     | <span class='unexecuted'>            fee: _pool.fee()</span>
 30 |     | <span class='neutral'>        });</span>
 31 |     | <span class='unexecuted'>        _pool.mint(</span>
 32 |     | <span class='unexecuted'>            msg.sender,</span>
 33 |     | <span class='unexecuted'>            -887200,</span>
 34 |     | <span class='unexecuted'>            887200,</span>
 35 |     | <span class='unexecuted'>            uint128(amount),</span>
 36 |     | <span class='unexecuted'>            abi.encode(LiquidityManagement.MintCallbackData({</span>
 37 |     | <span class='neutral'>                poolKey: poolKey,</span>
 38 |     | <span class='unexecuted'>                payer: address(this)</span>
 39 |     | <span class='neutral'>                })</span>
 40 |     | <span class='neutral'>            )</span>
 41 |     | <span class='neutral'>        );</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    event MessageUint(string a, uint256 b);</span>
 45 |     | <span class='neutral'>    event MessageAddress(string a, address b);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function uniswapV3MintCallback(</span>
 48 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 49 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 50 |     | <span class='neutral'>        bytes calldata data</span>
 51 |     | <span class='unexecuted'>    ) external override {</span>
 52 |     | <span class='unexecuted'>        emit MessageUint(&quot;amount0Owed&quot;, amount0Owed);</span>
 53 |     | <span class='unexecuted'>        emit MessageUint(&quot;amount1Owed&quot;, amount1Owed);</span>
 54 |     | <span class='neutral'></span>
 55 |     | <span class='unexecuted'>        LiquidityManagement.MintCallbackData memory decoded = abi.decode(data, (LiquidityManagement.MintCallbackData));</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='unexecuted'>        emit MessageUint(&quot;Balance Token0&quot;, IERC20(decoded.poolKey.token0).balanceOf(address(this)));</span>
 58 |     | <span class='unexecuted'>        emit MessageUint(&quot;Balance Token1&quot;, IERC20(decoded.poolKey.token1).balanceOf(address(this)));</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>        emit MessageAddress(&quot;Token0&quot;, decoded.poolKey.token0);</span>
 61 |     | <span class='unexecuted'>        emit MessageAddress(&quot;Token1&quot;, decoded.poolKey.token1);</span>
 62 |     | <span class='neutral'></span>
 63 |     | <span class='unexecuted'>        if (amount0Owed &gt; 0) IERC20(decoded.poolKey.token0).transfer(msg.sender, amount0Owed);</span>
 64 |     | <span class='unexecuted'>        if (amount1Owed &gt; 0) IERC20(decoded.poolKey.token1).transfer(msg.sender, amount1Owed);</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockV3Aggregator.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/**</span>
  5 |     | <span class='neutral'> * @title MockV3Aggregator</span>
  6 |     | <span class='neutral'> * @notice Based on the FluxAggregator contract</span>
  7 |     | <span class='neutral'> * @notice Use this contract when you need to test</span>
  8 |     | <span class='neutral'> * other contract&#39;s ability to read data from an</span>
  9 |     | <span class='neutral'> * aggregator contract, but how the aggregator got</span>
 10 |     | <span class='neutral'> * its answer is unimportant</span>
 11 |     | <span class='neutral'> */</span>
 12 |     | <span class='unexecuted'>contract MockV3Aggregator {</span>
 13 |     | <span class='unexecuted'>    uint256 public constant version = 0;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    uint8 public decimals;</span>
 16 |     | <span class='unexecuted'>    int256 public latestAnswer;</span>
 17 |     | <span class='unexecuted'>    uint256 public latestTimestamp;</span>
 18 |     | <span class='unexecuted'>    uint256 public latestRound;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='unexecuted'>    mapping(uint256 =&gt; int256) public getAnswer;</span>
 21 |     | <span class='unexecuted'>    mapping(uint256 =&gt; uint256) public getTimestamp;</span>
 22 |     | <span class='neutral'>    mapping(uint256 =&gt; uint256) private getStartedAt;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor(uint8 _decimals, int256 _initialAnswer) {</span>
 25 |     | <span class='unexecuted'>        decimals = _decimals;</span>
 26 |     | <span class='unexecuted'>        updateAnswer(_initialAnswer);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>    function updateAnswer(int256 _answer) public {</span>
 30 |     | <span class='unexecuted'>        latestAnswer = _answer;</span>
 31 |     | <span class='unexecuted'>        latestTimestamp = block.timestamp;</span>
 32 |     | <span class='unexecuted'>        latestRound++;</span>
 33 |     | <span class='unexecuted'>        getAnswer[latestRound] = _answer;</span>
 34 |     | <span class='unexecuted'>        getTimestamp[latestRound] = block.timestamp;</span>
 35 |     | <span class='unexecuted'>        getStartedAt[latestRound] = block.timestamp;</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>    function updateRoundData(uint80 _roundId, int256 _answer, uint256 _timestamp, uint256 _startedAt) public {</span>
 39 |     | <span class='unexecuted'>        latestRound = _roundId;</span>
 40 |     | <span class='unexecuted'>        latestAnswer = _answer;</span>
 41 |     | <span class='unexecuted'>        latestTimestamp = _timestamp;</span>
 42 |     | <span class='unexecuted'>        getAnswer[latestRound] = _answer;</span>
 43 |     | <span class='unexecuted'>        getTimestamp[latestRound] = _timestamp;</span>
 44 |     | <span class='unexecuted'>        getStartedAt[latestRound] = _startedAt;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='unexecuted'>    function getRoundData(uint80 _roundId)</span>
 48 |     | <span class='neutral'>        external</span>
 49 |     | <span class='unexecuted'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)</span>
 50 |     | <span class='neutral'>    {</span>
 51 |     | <span class='unexecuted'>        return (_roundId, getAnswer[_roundId], getStartedAt[_roundId], getTimestamp[_roundId], _roundId);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>    function latestRoundData()</span>
 55 |     | <span class='neutral'>        external</span>
 56 |     | <span class='unexecuted'>        returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound)</span>
 57 |     | <span class='neutral'>    {</span>
 58 |     | <span class='neutral'>        return (</span>
 59 |     | <span class='unexecuted'>            uint80(latestRound),</span>
 60 |     | <span class='unexecuted'>            getAnswer[latestRound],</span>
 61 |     | <span class='unexecuted'>            getStartedAt[latestRound],</span>
 62 |     | <span class='unexecuted'>            getTimestamp[latestRound],</span>
 63 |     | <span class='neutral'>            uint80(latestRound)</span>
 64 |     | <span class='neutral'>        );</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'></span>
 67 |     | <span class='unexecuted'>    function description() external pure returns (string memory) {</span>
 68 |     | <span class='unexecuted'>        return &quot;v0.6/tests/MockV3Aggregator.sol&quot;;</span>
 69 |     | <span class='neutral'>    }</span>
 70 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/MockZapper.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/access/Ownable.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/interfaces/IERC4626.sol&#39;;</span>
   6 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/IERC20.sol&#39;;</span>
   7 |     | <span class='neutral'>import &#39;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;@uniswap/v3-core/contracts/libraries/FixedPoint96.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/IPeripheryImmutableState.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;@uniswap/v3-periphery/contracts/interfaces/ISwapRouter.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/ICurvePool.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IDecentralizedIndex.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IDexAdapter.sol&#39;;</span>
  14 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IUniswapV2Pair.sol&#39;;</span>
  15 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IUniswapV3Pool.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IV3TwapUtilities.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IWETH.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;../../../contracts/interfaces/IZapper.sol&#39;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='unexecuted'>contract MockZapper is IZapper, Context, Ownable {</span>
  21 |     | <span class='neutral'>  using SafeERC20 for IERC20;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='unexecuted'>  address constant STYETH = 0x583019fF0f430721aDa9cfb4fac8F06cA104d0B4;</span>
  24 |     | <span class='unexecuted'>  address constant YETH = 0x1BED97CBC3c24A4fb5C069C6E311a967386131f7;</span>
  25 |     | <span class='unexecuted'>  address constant WETH_YETH_POOL = 0x69ACcb968B19a53790f43e57558F5E443A91aF22;</span>
  26 |     | <span class='neutral'>  address V3_ROUTER;</span>
  27 |     | <span class='neutral'>  address immutable V2_ROUTER;</span>
  28 |     | <span class='neutral'>  address immutable WETH;</span>
  29 |     | <span class='neutral'>  IV3TwapUtilities immutable V3_TWAP_UTILS;</span>
  30 |     | <span class='neutral'>  IDexAdapter immutable DEX_ADAPTER;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='unexecuted'>  uint256 _slippage = 30; // 3%</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='unexecuted'>  address public OHM = 0x64aa3364F17a4D01c6f1751Fd97C2BD3D7e7f1D5;</span>
  35 |     | <span class='unexecuted'>  address public pOHM;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>  // token in =&gt; token out =&gt; swap pool(s)</span>
  38 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; Pools)) public zapMap;</span>
  39 |     | <span class='neutral'>  // curve pool =&gt; token =&gt; idx</span>
  40 |     | <span class='unexecuted'>  mapping(address =&gt; mapping(address =&gt; int128)) public curveTokenIdx;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>  event Message(string a);</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>  constructor(IV3TwapUtilities _v3TwapUtilities, IDexAdapter _dexAdapter, address _V3_ROUTER) {</span>
  45 |     | <span class='unexecuted'>    V2_ROUTER = _dexAdapter.V2_ROUTER();</span>
  46 |     | <span class='unexecuted'>    V3_TWAP_UTILS = _v3TwapUtilities;</span>
  47 |     | <span class='unexecuted'>    DEX_ADAPTER = _dexAdapter;</span>
  48 |     | <span class='unexecuted'>    WETH = _dexAdapter.WETH();</span>
  49 |     | <span class='unexecuted'>    V3_ROUTER = _V3_ROUTER;</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='unexecuted'>    emit Message(&quot;Here&quot;);</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    // if (block.chainid == 1) {</span>
  54 |     | <span class='neutral'>    //   // WETH/YETH</span>
  55 |     | <span class='neutral'>    //   _setZapMapFromPoolSingle(</span>
  56 |     | <span class='neutral'>    //     PoolType.CURVE,</span>
  57 |     | <span class='neutral'>    //     0x69ACcb968B19a53790f43e57558F5E443A91aF22</span>
  58 |     | <span class='neutral'>    //   );</span>
  59 |     | <span class='neutral'>    //   // WETH/DAI</span>
  60 |     | <span class='neutral'>    //   _setZapMapFromPoolSingle(</span>
  61 |     | <span class='neutral'>    //     PoolType.V3,</span>
  62 |     | <span class='neutral'>    //     0x60594a405d53811d3BC4766596EFD80fd545A270</span>
  63 |     | <span class='neutral'>    //   );</span>
  64 |     | <span class='neutral'>    //   // WETH/USDC</span>
  65 |     | <span class='neutral'>    //   _setZapMapFromPoolSingle(</span>
  66 |     | <span class='neutral'>    //     PoolType.V3,</span>
  67 |     | <span class='neutral'>    //     0x88e6A0c2dDD26FEEb64F039a2c41296FcB3f5640</span>
  68 |     | <span class='neutral'>    //   );</span>
  69 |     | <span class='neutral'>    //   // WETH/OHM</span>
  70 |     | <span class='neutral'>    //   _setZapMapFromPoolSingle(</span>
  71 |     | <span class='neutral'>    //     PoolType.V3,</span>
  72 |     | <span class='neutral'>    //     0x88051B0eea095007D3bEf21aB287Be961f3d8598</span>
  73 |     | <span class='neutral'>    //   );</span>
  74 |     | <span class='neutral'>    //   // USDC/OHM</span>
  75 |     | <span class='neutral'>    //   _setZapMapFromPoolSingle(</span>
  76 |     | <span class='neutral'>    //     PoolType.V3,</span>
  77 |     | <span class='neutral'>    //     0x893f503FaC2Ee1e5B78665db23F9c94017Aae97D</span>
  78 |     | <span class='neutral'>    //   );</span>
  79 |     | <span class='neutral'>    // }</span>
  80 |     | <span class='neutral'>  }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='unexecuted'>  function _zap(</span>
  83 |     | <span class='neutral'>    address _in,</span>
  84 |     | <span class='neutral'>    address _out,</span>
  85 |     | <span class='neutral'>    uint256 _amountIn,</span>
  86 |     | <span class='neutral'>    uint256 _amountOutMin</span>
  87 |     | <span class='unexecuted'>  ) internal returns (uint256 _amountOut) {</span>
  88 |     | <span class='unexecuted'>    if (_in == address(0)) {</span>
  89 |     | <span class='unexecuted'>      _amountIn = _ethToWETH(_amountIn);</span>
  90 |     | <span class='unexecuted'>      _in = WETH;</span>
  91 |     | <span class='unexecuted'>      if (_out == WETH) {</span>
  92 |     | <span class='unexecuted'>        return _amountIn;</span>
  93 |     | <span class='neutral'>      }</span>
  94 |     | <span class='neutral'>    }</span>
  95 |     | <span class='neutral'>    // handle pOHM separately through pod, modularize later</span>
  96 |     | <span class='unexecuted'>    bool _isOutPOHM;</span>
  97 |     | <span class='unexecuted'>    if (pOHM == _out) {</span>
  98 |     | <span class='unexecuted'>      _isOutPOHM = true;</span>
  99 |     | <span class='unexecuted'>      _out = OHM;</span>
 100 |     | <span class='neutral'>    }</span>
 101 |     | <span class='neutral'>    // handle yETH and st-yETH special through curve pool, modularize later</span>
 102 |     | <span class='unexecuted'>    if (_out == YETH || _out == STYETH) {</span>
 103 |     | <span class='unexecuted'>      require(_in == WETH, &#39;YETHIN&#39;);</span>
 104 |     | <span class='unexecuted'>      return _wethToYeth(_amountIn, _amountOutMin, _out == STYETH);</span>
 105 |     | <span class='unexecuted'>    } else if (_in == YETH || _in == STYETH) {</span>
 106 |     | <span class='unexecuted'>      require(_out == WETH, &#39;YETHOUT&#39;);</span>
 107 |     | <span class='unexecuted'>      return _styethToWeth(_amountIn, _amountOutMin, _in == YETH);</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='unexecuted'>    Pools memory _poolInfo = zapMap[_in][_out];</span>
 110 |     | <span class='neutral'>    // no pool so just try to swap over one path univ2</span>
 111 |     | <span class='unexecuted'>    if (_poolInfo.pool1 == address(0)) {</span>
 112 |     | <span class='unexecuted'>      address[] memory _path = new address[](2);</span>
 113 |     | <span class='unexecuted'>      _path[0] = _in;</span>
 114 |     | <span class='unexecuted'>      _path[1] = _out;</span>
 115 |     | <span class='unexecuted'>      _amountOut = _swapV2(_path, _amountIn, _amountOutMin);</span>
 116 |     | <span class='unexecuted'>    } else {</span>
 117 |     | <span class='unexecuted'>      bool _twoHops = _poolInfo.pool2 != address(0);</span>
 118 |     | <span class='unexecuted'>      if (_poolInfo.poolType == PoolType.CURVE) {</span>
 119 |     | <span class='neutral'>        // curve</span>
 120 |     | <span class='unexecuted'>        _amountOut = _swapCurve(</span>
 121 |     | <span class='unexecuted'>          _poolInfo.pool1,</span>
 122 |     | <span class='unexecuted'>          curveTokenIdx[_poolInfo.pool1][_in],</span>
 123 |     | <span class='unexecuted'>          curveTokenIdx[_poolInfo.pool1][_out],</span>
 124 |     | <span class='unexecuted'>          _amountIn,</span>
 125 |     | <span class='unexecuted'>          _amountOutMin</span>
 126 |     | <span class='neutral'>        );</span>
 127 |     | <span class='unexecuted'>      } else if (_poolInfo.poolType == PoolType.V2) {</span>
 128 |     | <span class='neutral'>        // univ2</span>
 129 |     | <span class='unexecuted'>        address _token0 = IUniswapV2Pair(_poolInfo.pool1).token0();</span>
 130 |     | <span class='unexecuted'>        address[] memory _path = new address[](_twoHops ? 3 : 2);</span>
 131 |     | <span class='unexecuted'>        _path[0] = _in;</span>
 132 |     | <span class='unexecuted'>        _path[1] = !_twoHops ? _out : _token0 == _in</span>
 133 |     | <span class='unexecuted'>          ? IUniswapV2Pair(_poolInfo.pool1).token1()</span>
 134 |     | <span class='unexecuted'>          : _token0;</span>
 135 |     | <span class='unexecuted'>        if (_twoHops) {</span>
 136 |     | <span class='unexecuted'>          _path[2] = _out;</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='unexecuted'>        _amountOut = _swapV2(_path, _amountIn, _amountOutMin);</span>
 139 |     | <span class='neutral'>      } else {</span>
 140 |     | <span class='neutral'>        // univ3</span>
 141 |     | <span class='unexecuted'>        if (_twoHops) {</span>
 142 |     | <span class='unexecuted'>          address _t0 = IUniswapV3Pool(_poolInfo.pool1).token0();</span>
 143 |     | <span class='unexecuted'>          _amountOut = _swapV3Multi(</span>
 144 |     | <span class='unexecuted'>            _in,</span>
 145 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool1),</span>
 146 |     | <span class='unexecuted'>            _t0 == _in ? IUniswapV3Pool(_poolInfo.pool1).token1() : _t0,</span>
 147 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool2),</span>
 148 |     | <span class='unexecuted'>            _out,</span>
 149 |     | <span class='unexecuted'>            _amountIn,</span>
 150 |     | <span class='unexecuted'>            _amountOutMin</span>
 151 |     | <span class='neutral'>          );</span>
 152 |     | <span class='neutral'>        } else {</span>
 153 |     | <span class='unexecuted'>          _amountOut = _swapV3Single(</span>
 154 |     | <span class='unexecuted'>            _in,</span>
 155 |     | <span class='unexecuted'>            _getPoolFee(_poolInfo.pool1),</span>
 156 |     | <span class='unexecuted'>            _out,</span>
 157 |     | <span class='unexecuted'>            _amountIn,</span>
 158 |     | <span class='unexecuted'>            _amountOutMin</span>
 159 |     | <span class='neutral'>          );</span>
 160 |     | <span class='neutral'>        }</span>
 161 |     | <span class='neutral'>      }</span>
 162 |     | <span class='neutral'>    }</span>
 163 |     | <span class='unexecuted'>    if (!_isOutPOHM) {</span>
 164 |     | <span class='unexecuted'>      return _amountOut;</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='unexecuted'>    uint256 _pOHMBefore = IERC20(pOHM).balanceOf(address(this));</span>
 167 |     | <span class='unexecuted'>    IERC20(OHM).safeIncreaseAllowance(pOHM, _amountOut);</span>
 168 |     | <span class='unexecuted'>    IDecentralizedIndex(pOHM).bond(OHM, _amountOut, 0);</span>
 169 |     | <span class='unexecuted'>    return IERC20(pOHM).balanceOf(address(this)) - _pOHMBefore;</span>
 170 |     | <span class='neutral'>  }</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>  function _getPoolFee(address _pool) internal view returns (uint24) {</span>
 173 |     | <span class='unexecuted'>    return block.chainid == 42161 ? 0 : IUniswapV3Pool(_pool).fee();</span>
 174 |     | <span class='neutral'>  }</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>  function _ethToWETH(uint256 _amountETH) internal returns (uint256) {</span>
 177 |     | <span class='unexecuted'>    uint256 _wethBal = IERC20(WETH).balanceOf(address(this));</span>
 178 |     | <span class='unexecuted'>    IWETH(WETH).deposit{ value: _amountETH }();</span>
 179 |     | <span class='unexecuted'>    return IERC20(WETH).balanceOf(address(this)) - _wethBal;</span>
 180 |     | <span class='neutral'>  }</span>
 181 |     | <span class='neutral'></span>
 182 |     | <span class='unexecuted'>  function _swapV3Single(</span>
 183 |     | <span class='neutral'>    address _in,</span>
 184 |     | <span class='neutral'>    uint24 _fee,</span>
 185 |     | <span class='neutral'>    address _out,</span>
 186 |     | <span class='neutral'>    uint256 _amountIn,</span>
 187 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 188 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 189 |     | <span class='unexecuted'>    if (_amountOutMin == 0) {</span>
 190 |     | <span class='unexecuted'>      address _v3Pool;</span>
 191 |     | <span class='unexecuted'>      try DEX_ADAPTER.getV3Pool(_in, _out, uint24(10000)) returns (</span>
 192 |     | <span class='neutral'>        address __v3Pool</span>
 193 |     | <span class='neutral'>      ) {</span>
 194 |     | <span class='unexecuted'>        _v3Pool = __v3Pool;</span>
 195 |     | <span class='neutral'>      } catch {</span>
 196 |     | <span class='unexecuted'>        _v3Pool = DEX_ADAPTER.getV3Pool(_in, _out, int24(200));</span>
 197 |     | <span class='neutral'>      }</span>
 198 |     | <span class='unexecuted'>      address _token0 = _in &lt; _out ? _in : _out;</span>
 199 |     | <span class='unexecuted'>      uint256 _poolPriceX96 = V3_TWAP_UTILS.priceX96FromSqrtPriceX96(</span>
 200 |     | <span class='unexecuted'>        V3_TWAP_UTILS.sqrtPriceX96FromPoolAndInterval(_v3Pool)</span>
 201 |     | <span class='neutral'>      );</span>
 202 |     | <span class='unexecuted'>      _amountOutMin = _in == _token0</span>
 203 |     | <span class='unexecuted'>        ? (_poolPriceX96 * _amountIn) / FixedPoint96.Q96</span>
 204 |     | <span class='unexecuted'>        : (_amountIn * FixedPoint96.Q96) / _poolPriceX96;</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 208 |     | <span class='unexecuted'>    IERC20(_in).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);</span>
 209 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV3Single(</span>
 210 |     | <span class='unexecuted'>      _in,</span>
 211 |     | <span class='unexecuted'>      _out,</span>
 212 |     | <span class='unexecuted'>      _fee,</span>
 213 |     | <span class='unexecuted'>      _amountIn,</span>
 214 |     | <span class='unexecuted'>      (_amountOutMin * (1000 - _slippage)) / 1000,</span>
 215 |     | <span class='unexecuted'>      address(this)</span>
 216 |     | <span class='neutral'>    );</span>
 217 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 218 |     | <span class='neutral'>  }</span>
 219 |     | <span class='neutral'></span>
 220 |     | <span class='unexecuted'>  function _swapV3Multi(</span>
 221 |     | <span class='neutral'>    address _in,</span>
 222 |     | <span class='neutral'>    uint24 _fee1,</span>
 223 |     | <span class='neutral'>    address _in2,</span>
 224 |     | <span class='neutral'>    uint24 _fee2,</span>
 225 |     | <span class='neutral'>    address _out,</span>
 226 |     | <span class='neutral'>    uint256 _amountIn,</span>
 227 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 228 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 229 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 230 |     | <span class='unexecuted'>    IERC20(_in).safeIncreaseAllowance(V3_ROUTER, _amountIn);</span>
 231 |     | <span class='unexecuted'>    bytes memory _path = abi.encodePacked(_in, _fee1, _in2, _fee2, _out);</span>
 232 |     | <span class='unexecuted'>    ISwapRouter(V3_ROUTER).exactInput(</span>
 233 |     | <span class='unexecuted'>      ISwapRouter.ExactInputParams({</span>
 234 |     | <span class='neutral'>        path: _path,</span>
 235 |     | <span class='unexecuted'>        recipient: address(this),</span>
 236 |     | <span class='unexecuted'>        deadline: block.timestamp,</span>
 237 |     | <span class='neutral'>        amountIn: _amountIn,</span>
 238 |     | <span class='neutral'>        amountOutMinimum: _amountOutMin</span>
 239 |     | <span class='neutral'>      })</span>
 240 |     | <span class='neutral'>    );</span>
 241 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 242 |     | <span class='neutral'>  }</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='unexecuted'>  function _swapV2(</span>
 245 |     | <span class='neutral'>    address[] memory _path,</span>
 246 |     | <span class='neutral'>    uint256 _amountIn,</span>
 247 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 248 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 249 |     | <span class='unexecuted'>    address _out = _path.length == 3 ? _path[2] : _path[1];</span>
 250 |     | <span class='unexecuted'>    uint256 _outBefore = IERC20(_out).balanceOf(address(this));</span>
 251 |     | <span class='unexecuted'>    IERC20(_path[0]).safeIncreaseAllowance(address(DEX_ADAPTER), _amountIn);</span>
 252 |     | <span class='unexecuted'>    DEX_ADAPTER.swapV2Single(</span>
 253 |     | <span class='unexecuted'>      _path[0],</span>
 254 |     | <span class='unexecuted'>      _path[1],</span>
 255 |     | <span class='neutral'>      _amountIn,</span>
 256 |     | <span class='neutral'>      _amountOutMin,</span>
 257 |     | <span class='unexecuted'>      address(this)</span>
 258 |     | <span class='neutral'>    );</span>
 259 |     | <span class='unexecuted'>    return IERC20(_out).balanceOf(address(this)) - _outBefore;</span>
 260 |     | <span class='neutral'>  }</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>  function _swapCurve(</span>
 263 |     | <span class='neutral'>    address _pool,</span>
 264 |     | <span class='neutral'>    int128 _i,</span>
 265 |     | <span class='neutral'>    int128 _j,</span>
 266 |     | <span class='neutral'>    uint256 _amountIn,</span>
 267 |     | <span class='neutral'>    uint256 _amountOutMin</span>
 268 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 269 |     | <span class='unexecuted'>    IERC20(ICurvePool(_pool).coins(uint128(_i))).safeIncreaseAllowance(</span>
 270 |     | <span class='unexecuted'>      _pool,</span>
 271 |     | <span class='unexecuted'>      _amountIn</span>
 272 |     | <span class='neutral'>    );</span>
 273 |     | <span class='neutral'>    return</span>
 274 |     | <span class='unexecuted'>      ICurvePool(_pool).exchange(</span>
 275 |     | <span class='neutral'>        _i,</span>
 276 |     | <span class='neutral'>        _j,</span>
 277 |     | <span class='neutral'>        _amountIn,</span>
 278 |     | <span class='neutral'>        _amountOutMin,</span>
 279 |     | <span class='unexecuted'>        address(this)</span>
 280 |     | <span class='neutral'>      );</span>
 281 |     | <span class='neutral'>  }</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='unexecuted'>  function _wethToYeth(</span>
 284 |     | <span class='neutral'>    uint256 _ethAmount,</span>
 285 |     | <span class='neutral'>    uint256 _minYethAmount,</span>
 286 |     | <span class='neutral'>    bool _stakeToStyeth</span>
 287 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 288 |     | <span class='unexecuted'>    uint256 _boughtYeth = _swapCurve(</span>
 289 |     | <span class='neutral'>      WETH_YETH_POOL,</span>
 290 |     | <span class='unexecuted'>      0,</span>
 291 |     | <span class='unexecuted'>      1,</span>
 292 |     | <span class='unexecuted'>      _ethAmount,</span>
 293 |     | <span class='unexecuted'>      _minYethAmount</span>
 294 |     | <span class='neutral'>    );</span>
 295 |     | <span class='unexecuted'>    if (_stakeToStyeth) {</span>
 296 |     | <span class='unexecuted'>      IERC20(YETH).safeIncreaseAllowance(STYETH, _boughtYeth);</span>
 297 |     | <span class='unexecuted'>      return IERC4626(STYETH).deposit(_boughtYeth, address(this));</span>
 298 |     | <span class='neutral'>    }</span>
 299 |     | <span class='neutral'>    return _boughtYeth;</span>
 300 |     | <span class='neutral'>  }</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>  function _styethToWeth(</span>
 303 |     | <span class='neutral'>    uint256 _stYethAmount,</span>
 304 |     | <span class='neutral'>    uint256 _minWethAmount,</span>
 305 |     | <span class='neutral'>    bool _isYethOnly</span>
 306 |     | <span class='unexecuted'>  ) internal returns (uint256) {</span>
 307 |     | <span class='unexecuted'>    uint256 _yethAmount;</span>
 308 |     | <span class='unexecuted'>    if (_isYethOnly) {</span>
 309 |     | <span class='unexecuted'>      _yethAmount = _stYethAmount;</span>
 310 |     | <span class='neutral'>    } else {</span>
 311 |     | <span class='unexecuted'>      _yethAmount = IERC4626(STYETH).redeem(</span>
 312 |     | <span class='neutral'>        _stYethAmount,</span>
 313 |     | <span class='unexecuted'>        address(this),</span>
 314 |     | <span class='neutral'>        address(this)</span>
 315 |     | <span class='neutral'>      );</span>
 316 |     | <span class='neutral'>    }</span>
 317 |     | <span class='unexecuted'>    return _swapCurve(WETH_YETH_POOL, 1, 0, _yethAmount, _minWethAmount);</span>
 318 |     | <span class='neutral'>  }</span>
 319 |     | <span class='neutral'></span>
 320 |     | <span class='unexecuted'>  function _setZapMapFromPoolSingle(PoolType _type, address _pool) internal {</span>
 321 |     | <span class='unexecuted'>    address _t0;</span>
 322 |     | <span class='neutral'>    address _t1;</span>
 323 |     | <span class='unexecuted'>    if (_type == PoolType.CURVE) {</span>
 324 |     | <span class='unexecuted'>      _t0 = ICurvePool(_pool).coins(0);</span>
 325 |     | <span class='unexecuted'>      _t1 = ICurvePool(_pool).coins(1);</span>
 326 |     | <span class='unexecuted'>      curveTokenIdx[_pool][_t0] = 0;</span>
 327 |     | <span class='unexecuted'>      curveTokenIdx[_pool][_t1] = 1;</span>
 328 |     | <span class='neutral'>    } else {</span>
 329 |     | <span class='unexecuted'>      _t0 = IUniswapV3Pool(_pool).token0();</span>
 330 |     | <span class='unexecuted'>      _t1 = IUniswapV3Pool(_pool).token1();</span>
 331 |     | <span class='neutral'>    }</span>
 332 |     | <span class='unexecuted'>    Pools memory _poolConf = Pools({</span>
 333 |     | <span class='unexecuted'>      poolType: _type,</span>
 334 |     | <span class='neutral'>      pool1: _pool,</span>
 335 |     | <span class='neutral'>      pool2: address(0)</span>
 336 |     | <span class='neutral'>    });</span>
 337 |     | <span class='unexecuted'>    zapMap[_t0][_t1] = _poolConf;</span>
 338 |     | <span class='unexecuted'>    zapMap[_t1][_t0] = _poolConf;</span>
 339 |     | <span class='neutral'>  }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='unexecuted'>  function setOHM(address _OHM, address _pOHM) external onlyOwner {</span>
 342 |     | <span class='unexecuted'>    OHM = _OHM == address(0) ? OHM : _OHM;</span>
 343 |     | <span class='unexecuted'>    pOHM = _pOHM == address(0) ? pOHM : _pOHM;</span>
 344 |     | <span class='neutral'>  }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='unexecuted'>  function setSlippage(uint256 _slip) external onlyOwner {</span>
 347 |     | <span class='unexecuted'>    require(_slip &gt;= 0 &amp;&amp; _slip &lt;= 1000, &#39;BOUNDS&#39;);</span>
 348 |     | <span class='unexecuted'>    _slippage = _slip;</span>
 349 |     | <span class='neutral'>  }</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='unexecuted'>  function setZapMap(</span>
 352 |     | <span class='neutral'>    address _in,</span>
 353 |     | <span class='neutral'>    address _out,</span>
 354 |     | <span class='neutral'>    Pools memory _pools</span>
 355 |     | <span class='neutral'>  ) external onlyOwner {</span>
 356 |     | <span class='unexecuted'>    zapMap[_in][_out] = _pools;</span>
 357 |     | <span class='neutral'>  }</span>
 358 |     | <span class='neutral'></span>
 359 |     | <span class='unexecuted'>  function setZapMapFromPoolSingle(</span>
 360 |     | <span class='neutral'>    PoolType _type,</span>
 361 |     | <span class='neutral'>    address _pool</span>
 362 |     | <span class='neutral'>  ) external onlyOwner {</span>
 363 |     | <span class='unexecuted'>    _setZapMapFromPoolSingle(_type, _pool);</span>
 364 |     | <span class='neutral'>  }</span>
 365 |     | <span class='neutral'></span>
 366 |     | <span class='unexecuted'>  function rescueETH() external onlyOwner {</span>
 367 |     | <span class='unexecuted'>    (bool _sent, ) = payable(owner()).call{ value: address(this).balance }(&#39;&#39;);</span>
 368 |     | <span class='unexecuted'>    require(_sent);</span>
 369 |     | <span class='neutral'>  }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='unexecuted'>  function rescueERC20(IERC20 _token) external onlyOwner {</span>
 372 |     | <span class='unexecuted'>    require(_token.balanceOf(address(this)) &gt; 0);</span>
 373 |     | <span class='unexecuted'>    _token.safeTransfer(owner(), _token.balanceOf(address(this)));</span>
 374 |     | <span class='neutral'>  }</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>  receive() external payable {}</span>
 377 |     | <span class='neutral'>}</span>
 378 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/WETH.sol</b>
<code>
   1 |     | <span class='neutral'>/**</span>
   2 |     | <span class='neutral'> *Submitted for verification at Etherscan.io on 2017-12-12</span>
   3 |     | <span class='neutral'> */</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>// Copyright (C) 2015, 2016, 2017 Dapphub</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>// This program is free software: you can redistribute it and/or modify</span>
   8 |     | <span class='neutral'>// it under the terms of the GNU General Public License as published by</span>
   9 |     | <span class='neutral'>// the Free Software Foundation, either version 3 of the License, or</span>
  10 |     | <span class='neutral'>// (at your option) any later version.</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>// This program is distributed in the hope that it will be useful,</span>
  13 |     | <span class='neutral'>// but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
  14 |     | <span class='neutral'>// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
  15 |     | <span class='neutral'>// GNU General Public License for more details.</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>// You should have received a copy of the GNU General Public License</span>
  18 |     | <span class='neutral'>// along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>pragma solidity ^0.8.13;</span>
  21 |     | <span class='neutral'></span>
  22 | *   | <span class='executed'>contract WETH9 {</span>
  23 | *   | <span class='executed'>    string public name = &quot;Wrapped Ether&quot;;</span>
  24 |     | <span class='unexecuted'>    string public symbol = &quot;WETH&quot;;</span>
  25 | *   | <span class='executed'>    uint8 public decimals = 18;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    event Approval(address indexed src, address indexed guy, uint wad);</span>
  28 |     | <span class='neutral'>    event Transfer(address indexed src, address indexed dst, uint wad);</span>
  29 |     | <span class='neutral'>    event Deposit(address indexed dst, uint wad);</span>
  30 |     | <span class='neutral'>    event Withdrawal(address indexed src, uint wad);</span>
  31 |     | <span class='neutral'></span>
  32 | *   | <span class='executed'>    mapping(address =&gt; uint) public balanceOf;</span>
  33 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint)) public allowance;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    receive() external payable {</span>
  36 |     | <span class='unexecuted'>        deposit();</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function deposit() public payable {</span>
  40 |     | <span class='unexecuted'>        balanceOf[msg.sender] += msg.value;</span>
  41 |     | <span class='unexecuted'>        emit Deposit(msg.sender, msg.value);</span>
  42 |     | <span class='neutral'>    }</span>
  43 |     | <span class='neutral'></span>
  44 |     | <span class='unexecuted'>    function withdraw(uint wad) public {</span>
  45 |     | <span class='unexecuted'>        require(balanceOf[msg.sender] &gt;= wad);</span>
  46 |     | <span class='unexecuted'>        balanceOf[msg.sender] -= wad;</span>
  47 |     | <span class='unexecuted'>        msg.sender.call{value: wad}(&quot;&quot;);</span>
  48 |     | <span class='unexecuted'>        emit Withdrawal(msg.sender, wad);</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 | *   | <span class='executed'>    function totalSupply() public view returns (uint) {</span>
  52 |     | <span class='unexecuted'>        return address(this).balance;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 | *   | <span class='executed'>    function approve(address guy, uint wad) public returns (bool) {</span>
  56 | *   | <span class='executed'>        allowance[msg.sender][guy] = wad;</span>
  57 | *   | <span class='executed'>        emit Approval(msg.sender, guy, wad);</span>
  58 | *   | <span class='executed'>        return true;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 | *   | <span class='executed'>    function transfer(address dst, uint wad) public returns (bool) {</span>
  62 | *   | <span class='executed'>        return transferFrom(msg.sender, dst, wad);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 | *   | <span class='executed'>    function transferFrom(</span>
  66 |     | <span class='neutral'>        address src,</span>
  67 |     | <span class='neutral'>        address dst,</span>
  68 |     | <span class='neutral'>        uint wad</span>
  69 | *   | <span class='executed'>    ) public returns (bool) {</span>
  70 | *   | <span class='executed'>        require(balanceOf[src] &gt;= wad);</span>
  71 |     | <span class='neutral'></span>
  72 | *   | <span class='executed'>        if (</span>
  73 | *   | <span class='executed'>            src != msg.sender &amp;&amp; allowance[src][msg.sender] != type(uint256).max</span>
  74 |     | <span class='neutral'>        ) {</span>
  75 |     | <span class='unexecuted'>            require(allowance[src][msg.sender] &gt;= wad);</span>
  76 |     | <span class='unexecuted'>            allowance[src][msg.sender] -= wad;</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'></span>
  79 | *   | <span class='executed'>        balanceOf[src] -= wad;</span>
  80 | *   | <span class='executed'>        balanceOf[dst] += wad;</span>
  81 |     | <span class='neutral'></span>
  82 | *   | <span class='executed'>        emit Transfer(src, dst, wad);</span>
  83 |     | <span class='neutral'></span>
  84 | *   | <span class='executed'>        return true;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'>}</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>/*</span>
  89 |     | <span class='neutral'>                    GNU GENERAL PUBLIC LICENSE</span>
  90 |     | <span class='neutral'>                       Version 3, 29 June 2007</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'> Copyright (C) 2007 Free Software Foundation, Inc. &lt;http://fsf.org/&gt;</span>
  93 |     | <span class='neutral'> Everyone is permitted to copy and distribute verbatim copies</span>
  94 |     | <span class='neutral'> of this license document, but changing it is not allowed.</span>
  95 |     | <span class='neutral'></span>
  96 |     | <span class='neutral'>                            Preamble</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>  The GNU General Public License is a free, copyleft license for</span>
  99 |     | <span class='neutral'>software and other kinds of works.</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>  The licenses for most software and other practical works are designed</span>
 102 |     | <span class='neutral'>to take away your freedom to share and change the works.  By contrast,</span>
 103 |     | <span class='neutral'>the GNU General Public License is intended to guarantee your freedom to</span>
 104 |     | <span class='neutral'>share and change all versions of a program--to make sure it remains free</span>
 105 |     | <span class='neutral'>software for all its users.  We, the Free Software Foundation, use the</span>
 106 |     | <span class='neutral'>GNU General Public License for most of our software; it applies also to</span>
 107 |     | <span class='neutral'>any other work released this way by its authors.  You can apply it to</span>
 108 |     | <span class='neutral'>your programs, too.</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>  When we speak of free software, we are referring to freedom, not</span>
 111 |     | <span class='neutral'>price.  Our General Public Licenses are designed to make sure that you</span>
 112 |     | <span class='neutral'>have the freedom to distribute copies of free software (and charge for</span>
 113 |     | <span class='neutral'>them if you wish), that you receive source code or can get it if you</span>
 114 |     | <span class='neutral'>want it, that you can change the software or use pieces of it in new</span>
 115 |     | <span class='neutral'>free programs, and that you know you can do these things.</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='neutral'>  To protect your rights, we need to prevent others from denying you</span>
 118 |     | <span class='neutral'>these rights or asking you to surrender the rights.  Therefore, you have</span>
 119 |     | <span class='neutral'>certain responsibilities if you distribute copies of the software, or if</span>
 120 |     | <span class='neutral'>you modify it: responsibilities to respect the freedom of others.</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>  For example, if you distribute copies of such a program, whether</span>
 123 |     | <span class='neutral'>gratis or for a fee, you must pass on to the recipients the same</span>
 124 |     | <span class='neutral'>freedoms that you received.  You must make sure that they, too, receive</span>
 125 |     | <span class='neutral'>or can get the source code.  And you must show them these terms so they</span>
 126 |     | <span class='neutral'>know their rights.</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>  Developers that use the GNU GPL protect your rights with two steps:</span>
 129 |     | <span class='neutral'>(1) assert copyright on the software, and (2) offer you this License</span>
 130 |     | <span class='neutral'>giving you legal permission to copy, distribute and/or modify it.</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>  For the developers&#39; and authors&#39; protection, the GPL clearly explains</span>
 133 |     | <span class='neutral'>that there is no warranty for this free software.  For both users&#39; and</span>
 134 |     | <span class='neutral'>authors&#39; sake, the GPL requires that modified versions be marked as</span>
 135 |     | <span class='neutral'>changed, so that their problems will not be attributed erroneously to</span>
 136 |     | <span class='neutral'>authors of previous versions.</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>  Some devices are designed to deny users access to install or run</span>
 139 |     | <span class='neutral'>modified versions of the software inside them, although the manufacturer</span>
 140 |     | <span class='neutral'>can do so.  This is fundamentally incompatible with the aim of</span>
 141 |     | <span class='neutral'>protecting users&#39; freedom to change the software.  The systematic</span>
 142 |     | <span class='neutral'>pattern of such abuse occurs in the area of products for individuals to</span>
 143 |     | <span class='neutral'>use, which is precisely where it is most unacceptable.  Therefore, we</span>
 144 |     | <span class='neutral'>have designed this version of the GPL to prohibit the practice for those</span>
 145 |     | <span class='neutral'>products.  If such problems arise substantially in other domains, we</span>
 146 |     | <span class='neutral'>stand ready to extend this provision to those domains in future versions</span>
 147 |     | <span class='neutral'>of the GPL, as needed to protect the freedom of users.</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>  Finally, every program is threatened constantly by software patents.</span>
 150 |     | <span class='neutral'>States should not allow patents to restrict development and use of</span>
 151 |     | <span class='neutral'>software on general-purpose computers, but in those that do, we wish to</span>
 152 |     | <span class='neutral'>avoid the special danger that patents applied to a free program could</span>
 153 |     | <span class='neutral'>make it effectively proprietary.  To prevent this, the GPL assures that</span>
 154 |     | <span class='neutral'>patents cannot be used to render the program non-free.</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>  The precise terms and conditions for copying, distribution and</span>
 157 |     | <span class='neutral'>modification follow.</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>                       TERMS AND CONDITIONS</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>  0. Definitions.</span>
 162 |     | <span class='neutral'></span>
 163 |     | <span class='neutral'>  &quot;This License&quot; refers to version 3 of the GNU General Public License.</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>  &quot;Copyright&quot; also means copyright-like laws that apply to other kinds of</span>
 166 |     | <span class='neutral'>works, such as semiconductor masks.</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>  &quot;The Program&quot; refers to any copyrightable work licensed under this</span>
 169 |     | <span class='neutral'>License.  Each licensee is addressed as &quot;you&quot;.  &quot;Licensees&quot; and</span>
 170 |     | <span class='neutral'>&quot;recipients&quot; may be individuals or organizations.</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>  To &quot;modify&quot; a work means to copy from or adapt all or part of the work</span>
 173 |     | <span class='neutral'>in a fashion requiring copyright permission, other than the making of an</span>
 174 |     | <span class='neutral'>exact copy.  The resulting work is called a &quot;modified version&quot; of the</span>
 175 |     | <span class='neutral'>earlier work or a work &quot;based on&quot; the earlier work.</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>  A &quot;covered work&quot; means either the unmodified Program or a work based</span>
 178 |     | <span class='neutral'>on the Program.</span>
 179 |     | <span class='neutral'></span>
 180 |     | <span class='neutral'>  To &quot;propagate&quot; a work means to do anything with it that, without</span>
 181 |     | <span class='neutral'>permission, would make you directly or secondarily liable for</span>
 182 |     | <span class='neutral'>infringement under applicable copyright law, except executing it on a</span>
 183 |     | <span class='neutral'>computer or modifying a private copy.  Propagation includes copying,</span>
 184 |     | <span class='neutral'>distribution (with or without modification), making available to the</span>
 185 |     | <span class='neutral'>public, and in some countries other activities as well.</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>  To &quot;convey&quot; a work means any kind of propagation that enables other</span>
 188 |     | <span class='neutral'>parties to make or receive copies.  Mere interaction with a user through</span>
 189 |     | <span class='neutral'>a computer network, with no transfer of a copy, is not conveying.</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>  An interactive user interface displays &quot;Appropriate Legal Notices&quot;</span>
 192 |     | <span class='neutral'>to the extent that it includes a convenient and prominently visible</span>
 193 |     | <span class='neutral'>feature that (1) displays an appropriate copyright notice, and (2)</span>
 194 |     | <span class='neutral'>tells the user that there is no warranty for the work (except to the</span>
 195 |     | <span class='neutral'>extent that warranties are provided), that licensees may convey the</span>
 196 |     | <span class='neutral'>work under this License, and how to view a copy of this License.  If</span>
 197 |     | <span class='neutral'>the interface presents a list of user commands or options, such as a</span>
 198 |     | <span class='neutral'>menu, a prominent item in the list meets this criterion.</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>  1. Source Code.</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>  The &quot;source code&quot; for a work means the preferred form of the work</span>
 203 |     | <span class='neutral'>for making modifications to it.  &quot;Object code&quot; means any non-source</span>
 204 |     | <span class='neutral'>form of a work.</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>  A &quot;Standard Interface&quot; means an interface that either is an official</span>
 207 |     | <span class='neutral'>standard defined by a recognized standards body, or, in the case of</span>
 208 |     | <span class='neutral'>interfaces specified for a particular programming language, one that</span>
 209 |     | <span class='neutral'>is widely used among developers working in that language.</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>  The &quot;System Libraries&quot; of an executable work include anything, other</span>
 212 |     | <span class='neutral'>than the work as a whole, that (a) is included in the normal form of</span>
 213 |     | <span class='neutral'>packaging a Major Component, but which is not part of that Major</span>
 214 |     | <span class='neutral'>Component, and (b) serves only to enable use of the work with that</span>
 215 |     | <span class='neutral'>Major Component, or to implement a Standard Interface for which an</span>
 216 |     | <span class='neutral'>implementation is available to the public in source code form.  A</span>
 217 |     | <span class='neutral'>&quot;Major Component&quot;, in this context, means a major essential component</span>
 218 |     | <span class='neutral'>(kernel, window system, and so on) of the specific operating system</span>
 219 |     | <span class='neutral'>(if any) on which the executable work runs, or a compiler used to</span>
 220 |     | <span class='neutral'>produce the work, or an object code interpreter used to run it.</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>  The &quot;Corresponding Source&quot; for a work in object code form means all</span>
 223 |     | <span class='neutral'>the source code needed to generate, install, and (for an executable</span>
 224 |     | <span class='neutral'>work) run the object code and to modify the work, including scripts to</span>
 225 |     | <span class='neutral'>control those activities.  However, it does not include the work&#39;s</span>
 226 |     | <span class='neutral'>System Libraries, or general-purpose tools or generally available free</span>
 227 |     | <span class='neutral'>programs which are used unmodified in performing those activities but</span>
 228 |     | <span class='neutral'>which are not part of the work.  For example, Corresponding Source</span>
 229 |     | <span class='neutral'>includes interface definition files associated with source files for</span>
 230 |     | <span class='neutral'>the work, and the source code for shared libraries and dynamically</span>
 231 |     | <span class='neutral'>linked subprograms that the work is specifically designed to require,</span>
 232 |     | <span class='neutral'>such as by intimate data communication or control flow between those</span>
 233 |     | <span class='neutral'>subprograms and other parts of the work.</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>  The Corresponding Source need not include anything that users</span>
 236 |     | <span class='neutral'>can regenerate automatically from other parts of the Corresponding</span>
 237 |     | <span class='neutral'>Source.</span>
 238 |     | <span class='neutral'></span>
 239 |     | <span class='neutral'>  The Corresponding Source for a work in source code form is that</span>
 240 |     | <span class='neutral'>same work.</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>  2. Basic Permissions.</span>
 243 |     | <span class='neutral'></span>
 244 |     | <span class='neutral'>  All rights granted under this License are granted for the term of</span>
 245 |     | <span class='neutral'>copyright on the Program, and are irrevocable provided the stated</span>
 246 |     | <span class='neutral'>conditions are met.  This License explicitly affirms your unlimited</span>
 247 |     | <span class='neutral'>permission to run the unmodified Program.  The output from running a</span>
 248 |     | <span class='neutral'>covered work is covered by this License only if the output, given its</span>
 249 |     | <span class='neutral'>content, constitutes a covered work.  This License acknowledges your</span>
 250 |     | <span class='neutral'>rights of fair use or other equivalent, as provided by copyright law.</span>
 251 |     | <span class='neutral'></span>
 252 |     | <span class='neutral'>  You may make, run and propagate covered works that you do not</span>
 253 |     | <span class='neutral'>convey, without conditions so long as your license otherwise remains</span>
 254 |     | <span class='neutral'>in force.  You may convey covered works to others for the sole purpose</span>
 255 |     | <span class='neutral'>of having them make modifications exclusively for you, or provide you</span>
 256 |     | <span class='neutral'>with facilities for running those works, provided that you comply with</span>
 257 |     | <span class='neutral'>the terms of this License in conveying all material for which you do</span>
 258 |     | <span class='neutral'>not control copyright.  Those thus making or running the covered works</span>
 259 |     | <span class='neutral'>for you must do so exclusively on your behalf, under your direction</span>
 260 |     | <span class='neutral'>and control, on terms that prohibit them from making any copies of</span>
 261 |     | <span class='neutral'>your copyrighted material outside their relationship with you.</span>
 262 |     | <span class='neutral'></span>
 263 |     | <span class='neutral'>  Conveying under any other circumstances is permitted solely under</span>
 264 |     | <span class='neutral'>the conditions stated below.  Sublicensing is not allowed; section 10</span>
 265 |     | <span class='neutral'>makes it unnecessary.</span>
 266 |     | <span class='neutral'></span>
 267 |     | <span class='neutral'>  3. Protecting Users&#39; Legal Rights From Anti-Circumvention Law.</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>  No covered work shall be deemed part of an effective technological</span>
 270 |     | <span class='neutral'>measure under any applicable law fulfilling obligations under article</span>
 271 |     | <span class='neutral'>11 of the WIPO copyright treaty adopted on 20 December 1996, or</span>
 272 |     | <span class='neutral'>similar laws prohibiting or restricting circumvention of such</span>
 273 |     | <span class='neutral'>measures.</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='neutral'>  When you convey a covered work, you waive any legal power to forbid</span>
 276 |     | <span class='neutral'>circumvention of technological measures to the extent such circumvention</span>
 277 |     | <span class='neutral'>is effected by exercising rights under this License with respect to</span>
 278 |     | <span class='neutral'>the covered work, and you disclaim any intention to limit operation or</span>
 279 |     | <span class='neutral'>modification of the work as a means of enforcing, against the work&#39;s</span>
 280 |     | <span class='neutral'>users, your or third parties&#39; legal rights to forbid circumvention of</span>
 281 |     | <span class='neutral'>technological measures.</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>  4. Conveying Verbatim Copies.</span>
 284 |     | <span class='neutral'></span>
 285 |     | <span class='neutral'>  You may convey verbatim copies of the Program&#39;s source code as you</span>
 286 |     | <span class='neutral'>receive it, in any medium, provided that you conspicuously and</span>
 287 |     | <span class='neutral'>appropriately publish on each copy an appropriate copyright notice;</span>
 288 |     | <span class='neutral'>keep intact all notices stating that this License and any</span>
 289 |     | <span class='neutral'>non-permissive terms added in accord with section 7 apply to the code;</span>
 290 |     | <span class='neutral'>keep intact all notices of the absence of any warranty; and give all</span>
 291 |     | <span class='neutral'>recipients a copy of this License along with the Program.</span>
 292 |     | <span class='neutral'></span>
 293 |     | <span class='neutral'>  You may charge any price or no price for each copy that you convey,</span>
 294 |     | <span class='neutral'>and you may offer support or warranty protection for a fee.</span>
 295 |     | <span class='neutral'></span>
 296 |     | <span class='neutral'>  5. Conveying Modified Source Versions.</span>
 297 |     | <span class='neutral'></span>
 298 |     | <span class='neutral'>  You may convey a work based on the Program, or the modifications to</span>
 299 |     | <span class='neutral'>produce it from the Program, in the form of source code under the</span>
 300 |     | <span class='neutral'>terms of section 4, provided that you also meet all of these conditions:</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='neutral'>    a) The work must carry prominent notices stating that you modified</span>
 303 |     | <span class='neutral'>    it, and giving a relevant date.</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    b) The work must carry prominent notices stating that it is</span>
 306 |     | <span class='neutral'>    released under this License and any conditions added under section</span>
 307 |     | <span class='neutral'>    7.  This requirement modifies the requirement in section 4 to</span>
 308 |     | <span class='neutral'>    &quot;keep intact all notices&quot;.</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    c) You must license the entire work, as a whole, under this</span>
 311 |     | <span class='neutral'>    License to anyone who comes into possession of a copy.  This</span>
 312 |     | <span class='neutral'>    License will therefore apply, along with any applicable section 7</span>
 313 |     | <span class='neutral'>    additional terms, to the whole of the work, and all its parts,</span>
 314 |     | <span class='neutral'>    regardless of how they are packaged.  This License gives no</span>
 315 |     | <span class='neutral'>    permission to license the work in any other way, but it does not</span>
 316 |     | <span class='neutral'>    invalidate such permission if you have separately received it.</span>
 317 |     | <span class='neutral'></span>
 318 |     | <span class='neutral'>    d) If the work has interactive user interfaces, each must display</span>
 319 |     | <span class='neutral'>    Appropriate Legal Notices; however, if the Program has interactive</span>
 320 |     | <span class='neutral'>    interfaces that do not display Appropriate Legal Notices, your</span>
 321 |     | <span class='neutral'>    work need not make them do so.</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>  A compilation of a covered work with other separate and independent</span>
 324 |     | <span class='neutral'>works, which are not by their nature extensions of the covered work,</span>
 325 |     | <span class='neutral'>and which are not combined with it such as to form a larger program,</span>
 326 |     | <span class='neutral'>in or on a volume of a storage or distribution medium, is called an</span>
 327 |     | <span class='neutral'>&quot;aggregate&quot; if the compilation and its resulting copyright are not</span>
 328 |     | <span class='neutral'>used to limit the access or legal rights of the compilation&#39;s users</span>
 329 |     | <span class='neutral'>beyond what the individual works permit.  Inclusion of a covered work</span>
 330 |     | <span class='neutral'>in an aggregate does not cause this License to apply to the other</span>
 331 |     | <span class='neutral'>parts of the aggregate.</span>
 332 |     | <span class='neutral'></span>
 333 |     | <span class='neutral'>  6. Conveying Non-Source Forms.</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>  You may convey a covered work in object code form under the terms</span>
 336 |     | <span class='neutral'>of sections 4 and 5, provided that you also convey the</span>
 337 |     | <span class='neutral'>machine-readable Corresponding Source under the terms of this License,</span>
 338 |     | <span class='neutral'>in one of these ways:</span>
 339 |     | <span class='neutral'></span>
 340 |     | <span class='neutral'>    a) Convey the object code in, or embodied in, a physical product</span>
 341 |     | <span class='neutral'>    (including a physical distribution medium), accompanied by the</span>
 342 |     | <span class='neutral'>    Corresponding Source fixed on a durable physical medium</span>
 343 |     | <span class='neutral'>    customarily used for software interchange.</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>    b) Convey the object code in, or embodied in, a physical product</span>
 346 |     | <span class='neutral'>    (including a physical distribution medium), accompanied by a</span>
 347 |     | <span class='neutral'>    written offer, valid for at least three years and valid for as</span>
 348 |     | <span class='neutral'>    long as you offer spare parts or customer support for that product</span>
 349 |     | <span class='neutral'>    model, to give anyone who possesses the object code either (1) a</span>
 350 |     | <span class='neutral'>    copy of the Corresponding Source for all the software in the</span>
 351 |     | <span class='neutral'>    product that is covered by this License, on a durable physical</span>
 352 |     | <span class='neutral'>    medium customarily used for software interchange, for a price no</span>
 353 |     | <span class='neutral'>    more than your reasonable cost of physically performing this</span>
 354 |     | <span class='neutral'>    conveying of source, or (2) access to copy the</span>
 355 |     | <span class='neutral'>    Corresponding Source from a network server at no charge.</span>
 356 |     | <span class='neutral'></span>
 357 |     | <span class='neutral'>    c) Convey individual copies of the object code with a copy of the</span>
 358 |     | <span class='neutral'>    written offer to provide the Corresponding Source.  This</span>
 359 |     | <span class='neutral'>    alternative is allowed only occasionally and noncommercially, and</span>
 360 |     | <span class='neutral'>    only if you received the object code with such an offer, in accord</span>
 361 |     | <span class='neutral'>    with subsection 6b.</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    d) Convey the object code by offering access from a designated</span>
 364 |     | <span class='neutral'>    place (gratis or for a charge), and offer equivalent access to the</span>
 365 |     | <span class='neutral'>    Corresponding Source in the same way through the same place at no</span>
 366 |     | <span class='neutral'>    further charge.  You need not require recipients to copy the</span>
 367 |     | <span class='neutral'>    Corresponding Source along with the object code.  If the place to</span>
 368 |     | <span class='neutral'>    copy the object code is a network server, the Corresponding Source</span>
 369 |     | <span class='neutral'>    may be on a different server (operated by you or a third party)</span>
 370 |     | <span class='neutral'>    that supports equivalent copying facilities, provided you maintain</span>
 371 |     | <span class='neutral'>    clear directions next to the object code saying where to find the</span>
 372 |     | <span class='neutral'>    Corresponding Source.  Regardless of what server hosts the</span>
 373 |     | <span class='neutral'>    Corresponding Source, you remain obligated to ensure that it is</span>
 374 |     | <span class='neutral'>    available for as long as needed to satisfy these requirements.</span>
 375 |     | <span class='neutral'></span>
 376 |     | <span class='neutral'>    e) Convey the object code using peer-to-peer transmission, provided</span>
 377 |     | <span class='neutral'>    you inform other peers where the object code and Corresponding</span>
 378 |     | <span class='neutral'>    Source of the work are being offered to the general public at no</span>
 379 |     | <span class='neutral'>    charge under subsection 6d.</span>
 380 |     | <span class='neutral'></span>
 381 |     | <span class='neutral'>  A separable portion of the object code, whose source code is excluded</span>
 382 |     | <span class='neutral'>from the Corresponding Source as a System Library, need not be</span>
 383 |     | <span class='neutral'>included in conveying the object code work.</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>  A &quot;User Product&quot; is either (1) a &quot;consumer product&quot;, which means any</span>
 386 |     | <span class='neutral'>tangible personal property which is normally used for personal, family,</span>
 387 |     | <span class='neutral'>or household purposes, or (2) anything designed or sold for incorporation</span>
 388 |     | <span class='neutral'>into a dwelling.  In determining whether a product is a consumer product,</span>
 389 |     | <span class='neutral'>doubtful cases shall be resolved in favor of coverage.  For a particular</span>
 390 |     | <span class='neutral'>product received by a particular user, &quot;normally used&quot; refers to a</span>
 391 |     | <span class='neutral'>typical or common use of that class of product, regardless of the status</span>
 392 |     | <span class='neutral'>of the particular user or of the way in which the particular user</span>
 393 |     | <span class='neutral'>actually uses, or expects or is expected to use, the product.  A product</span>
 394 |     | <span class='neutral'>is a consumer product regardless of whether the product has substantial</span>
 395 |     | <span class='neutral'>commercial, industrial or non-consumer uses, unless such uses represent</span>
 396 |     | <span class='neutral'>the only significant mode of use of the product.</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>  &quot;Installation Information&quot; for a User Product means any methods,</span>
 399 |     | <span class='neutral'>procedures, authorization keys, or other information required to install</span>
 400 |     | <span class='neutral'>and execute modified versions of a covered work in that User Product from</span>
 401 |     | <span class='neutral'>a modified version of its Corresponding Source.  The information must</span>
 402 |     | <span class='neutral'>suffice to ensure that the continued functioning of the modified object</span>
 403 |     | <span class='neutral'>code is in no case prevented or interfered with solely because</span>
 404 |     | <span class='neutral'>modification has been made.</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>  If you convey an object code work under this section in, or with, or</span>
 407 |     | <span class='neutral'>specifically for use in, a User Product, and the conveying occurs as</span>
 408 |     | <span class='neutral'>part of a transaction in which the right of possession and use of the</span>
 409 |     | <span class='neutral'>User Product is transferred to the recipient in perpetuity or for a</span>
 410 |     | <span class='neutral'>fixed term (regardless of how the transaction is characterized), the</span>
 411 |     | <span class='neutral'>Corresponding Source conveyed under this section must be accompanied</span>
 412 |     | <span class='neutral'>by the Installation Information.  But this requirement does not apply</span>
 413 |     | <span class='neutral'>if neither you nor any third party retains the ability to install</span>
 414 |     | <span class='neutral'>modified object code on the User Product (for example, the work has</span>
 415 |     | <span class='neutral'>been installed in ROM).</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='neutral'>  The requirement to provide Installation Information does not include a</span>
 418 |     | <span class='neutral'>requirement to continue to provide support service, warranty, or updates</span>
 419 |     | <span class='neutral'>for a work that has been modified or installed by the recipient, or for</span>
 420 |     | <span class='neutral'>the User Product in which it has been modified or installed.  Access to a</span>
 421 |     | <span class='neutral'>network may be denied when the modification itself materially and</span>
 422 |     | <span class='neutral'>adversely affects the operation of the network or violates the rules and</span>
 423 |     | <span class='neutral'>protocols for communication across the network.</span>
 424 |     | <span class='neutral'></span>
 425 |     | <span class='neutral'>  Corresponding Source conveyed, and Installation Information provided,</span>
 426 |     | <span class='neutral'>in accord with this section must be in a format that is publicly</span>
 427 |     | <span class='neutral'>documented (and with an implementation available to the public in</span>
 428 |     | <span class='neutral'>source code form), and must require no special password or key for</span>
 429 |     | <span class='neutral'>unpacking, reading or copying.</span>
 430 |     | <span class='neutral'></span>
 431 |     | <span class='neutral'>  7. Additional Terms.</span>
 432 |     | <span class='neutral'></span>
 433 |     | <span class='neutral'>  &quot;Additional permissions&quot; are terms that supplement the terms of this</span>
 434 |     | <span class='neutral'>License by making exceptions from one or more of its conditions.</span>
 435 |     | <span class='neutral'>Additional permissions that are applicable to the entire Program shall</span>
 436 |     | <span class='neutral'>be treated as though they were included in this License, to the extent</span>
 437 |     | <span class='neutral'>that they are valid under applicable law.  If additional permissions</span>
 438 |     | <span class='neutral'>apply only to part of the Program, that part may be used separately</span>
 439 |     | <span class='neutral'>under those permissions, but the entire Program remains governed by</span>
 440 |     | <span class='neutral'>this License without regard to the additional permissions.</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>  When you convey a copy of a covered work, you may at your option</span>
 443 |     | <span class='neutral'>remove any additional permissions from that copy, or from any part of</span>
 444 |     | <span class='neutral'>it.  (Additional permissions may be written to require their own</span>
 445 |     | <span class='neutral'>removal in certain cases when you modify the work.)  You may place</span>
 446 |     | <span class='neutral'>additional permissions on material, added by you to a covered work,</span>
 447 |     | <span class='neutral'>for which you have or can give appropriate copyright permission.</span>
 448 |     | <span class='neutral'></span>
 449 |     | <span class='neutral'>  Notwithstanding any other provision of this License, for material you</span>
 450 |     | <span class='neutral'>add to a covered work, you may (if authorized by the copyright holders of</span>
 451 |     | <span class='neutral'>that material) supplement the terms of this License with terms:</span>
 452 |     | <span class='neutral'></span>
 453 |     | <span class='neutral'>    a) Disclaiming warranty or limiting liability differently from the</span>
 454 |     | <span class='neutral'>    terms of sections 15 and 16 of this License; or</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='neutral'>    b) Requiring preservation of specified reasonable legal notices or</span>
 457 |     | <span class='neutral'>    author attributions in that material or in the Appropriate Legal</span>
 458 |     | <span class='neutral'>    Notices displayed by works containing it; or</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    c) Prohibiting misrepresentation of the origin of that material, or</span>
 461 |     | <span class='neutral'>    requiring that modified versions of such material be marked in</span>
 462 |     | <span class='neutral'>    reasonable ways as different from the original version; or</span>
 463 |     | <span class='neutral'></span>
 464 |     | <span class='neutral'>    d) Limiting the use for publicity purposes of names of licensors or</span>
 465 |     | <span class='neutral'>    authors of the material; or</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>    e) Declining to grant rights under trademark law for use of some</span>
 468 |     | <span class='neutral'>    trade names, trademarks, or service marks; or</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>    f) Requiring indemnification of licensors and authors of that</span>
 471 |     | <span class='neutral'>    material by anyone who conveys the material (or modified versions of</span>
 472 |     | <span class='neutral'>    it) with contractual assumptions of liability to the recipient, for</span>
 473 |     | <span class='neutral'>    any liability that these contractual assumptions directly impose on</span>
 474 |     | <span class='neutral'>    those licensors and authors.</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='neutral'>  All other non-permissive additional terms are considered &quot;further</span>
 477 |     | <span class='neutral'>restrictions&quot; within the meaning of section 10.  If the Program as you</span>
 478 |     | <span class='neutral'>received it, or any part of it, contains a notice stating that it is</span>
 479 |     | <span class='neutral'>governed by this License along with a term that is a further</span>
 480 |     | <span class='neutral'>restriction, you may remove that term.  If a license document contains</span>
 481 |     | <span class='neutral'>a further restriction but permits relicensing or conveying under this</span>
 482 |     | <span class='neutral'>License, you may add to a covered work material governed by the terms</span>
 483 |     | <span class='neutral'>of that license document, provided that the further restriction does</span>
 484 |     | <span class='neutral'>not survive such relicensing or conveying.</span>
 485 |     | <span class='neutral'></span>
 486 |     | <span class='neutral'>  If you add terms to a covered work in accord with this section, you</span>
 487 |     | <span class='neutral'>must place, in the relevant source files, a statement of the</span>
 488 |     | <span class='neutral'>additional terms that apply to those files, or a notice indicating</span>
 489 |     | <span class='neutral'>where to find the applicable terms.</span>
 490 |     | <span class='neutral'></span>
 491 |     | <span class='neutral'>  Additional terms, permissive or non-permissive, may be stated in the</span>
 492 |     | <span class='neutral'>form of a separately written license, or stated as exceptions;</span>
 493 |     | <span class='neutral'>the above requirements apply either way.</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='neutral'>  8. Termination.</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>  You may not propagate or modify a covered work except as expressly</span>
 498 |     | <span class='neutral'>provided under this License.  Any attempt otherwise to propagate or</span>
 499 |     | <span class='neutral'>modify it is void, and will automatically terminate your rights under</span>
 500 |     | <span class='neutral'>this License (including any patent licenses granted under the third</span>
 501 |     | <span class='neutral'>paragraph of section 11).</span>
 502 |     | <span class='neutral'></span>
 503 |     | <span class='neutral'>  However, if you cease all violation of this License, then your</span>
 504 |     | <span class='neutral'>license from a particular copyright holder is reinstated (a)</span>
 505 |     | <span class='neutral'>provisionally, unless and until the copyright holder explicitly and</span>
 506 |     | <span class='neutral'>finally terminates your license, and (b) permanently, if the copyright</span>
 507 |     | <span class='neutral'>holder fails to notify you of the violation by some reasonable means</span>
 508 |     | <span class='neutral'>prior to 60 days after the cessation.</span>
 509 |     | <span class='neutral'></span>
 510 |     | <span class='neutral'>  Moreover, your license from a particular copyright holder is</span>
 511 |     | <span class='neutral'>reinstated permanently if the copyright holder notifies you of the</span>
 512 |     | <span class='neutral'>violation by some reasonable means, this is the first time you have</span>
 513 |     | <span class='neutral'>received notice of violation of this License (for any work) from that</span>
 514 |     | <span class='neutral'>copyright holder, and you cure the violation prior to 30 days after</span>
 515 |     | <span class='neutral'>your receipt of the notice.</span>
 516 |     | <span class='neutral'></span>
 517 |     | <span class='neutral'>  Termination of your rights under this section does not terminate the</span>
 518 |     | <span class='neutral'>licenses of parties who have received copies or rights from you under</span>
 519 |     | <span class='neutral'>this License.  If your rights have been terminated and not permanently</span>
 520 |     | <span class='neutral'>reinstated, you do not qualify to receive new licenses for the same</span>
 521 |     | <span class='neutral'>material under section 10.</span>
 522 |     | <span class='neutral'></span>
 523 |     | <span class='neutral'>  9. Acceptance Not Required for Having Copies.</span>
 524 |     | <span class='neutral'></span>
 525 |     | <span class='neutral'>  You are not required to accept this License in order to receive or</span>
 526 |     | <span class='neutral'>run a copy of the Program.  Ancillary propagation of a covered work</span>
 527 |     | <span class='neutral'>occurring solely as a consequence of using peer-to-peer transmission</span>
 528 |     | <span class='neutral'>to receive a copy likewise does not require acceptance.  However,</span>
 529 |     | <span class='neutral'>nothing other than this License grants you permission to propagate or</span>
 530 |     | <span class='neutral'>modify any covered work.  These actions infringe copyright if you do</span>
 531 |     | <span class='neutral'>not accept this License.  Therefore, by modifying or propagating a</span>
 532 |     | <span class='neutral'>covered work, you indicate your acceptance of this License to do so.</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>  10. Automatic Licensing of Downstream Recipients.</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>  Each time you convey a covered work, the recipient automatically</span>
 537 |     | <span class='neutral'>receives a license from the original licensors, to run, modify and</span>
 538 |     | <span class='neutral'>propagate that work, subject to this License.  You are not responsible</span>
 539 |     | <span class='neutral'>for enforcing compliance by third parties with this License.</span>
 540 |     | <span class='neutral'></span>
 541 |     | <span class='neutral'>  An &quot;entity transaction&quot; is a transaction transferring control of an</span>
 542 |     | <span class='neutral'>organization, or substantially all assets of one, or subdividing an</span>
 543 |     | <span class='neutral'>organization, or merging organizations.  If propagation of a covered</span>
 544 |     | <span class='neutral'>work results from an entity transaction, each party to that</span>
 545 |     | <span class='neutral'>transaction who receives a copy of the work also receives whatever</span>
 546 |     | <span class='neutral'>licenses to the work the party&#39;s predecessor in interest had or could</span>
 547 |     | <span class='neutral'>give under the previous paragraph, plus a right to possession of the</span>
 548 |     | <span class='neutral'>Corresponding Source of the work from the predecessor in interest, if</span>
 549 |     | <span class='neutral'>the predecessor has it or can get it with reasonable efforts.</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='neutral'>  You may not impose any further restrictions on the exercise of the</span>
 552 |     | <span class='neutral'>rights granted or affirmed under this License.  For example, you may</span>
 553 |     | <span class='neutral'>not impose a license fee, royalty, or other charge for exercise of</span>
 554 |     | <span class='neutral'>rights granted under this License, and you may not initiate litigation</span>
 555 |     | <span class='neutral'>(including a cross-claim or counterclaim in a lawsuit) alleging that</span>
 556 |     | <span class='neutral'>any patent claim is infringed by making, using, selling, offering for</span>
 557 |     | <span class='neutral'>sale, or importing the Program or any portion of it.</span>
 558 |     | <span class='neutral'></span>
 559 |     | <span class='neutral'>  11. Patents.</span>
 560 |     | <span class='neutral'></span>
 561 |     | <span class='neutral'>  A &quot;contributor&quot; is a copyright holder who authorizes use under this</span>
 562 |     | <span class='neutral'>License of the Program or a work on which the Program is based.  The</span>
 563 |     | <span class='neutral'>work thus licensed is called the contributor&#39;s &quot;contributor version&quot;.</span>
 564 |     | <span class='neutral'></span>
 565 |     | <span class='neutral'>  A contributor&#39;s &quot;essential patent claims&quot; are all patent claims</span>
 566 |     | <span class='neutral'>owned or controlled by the contributor, whether already acquired or</span>
 567 |     | <span class='neutral'>hereafter acquired, that would be infringed by some manner, permitted</span>
 568 |     | <span class='neutral'>by this License, of making, using, or selling its contributor version,</span>
 569 |     | <span class='neutral'>but do not include claims that would be infringed only as a</span>
 570 |     | <span class='neutral'>consequence of further modification of the contributor version.  For</span>
 571 |     | <span class='neutral'>purposes of this definition, &quot;control&quot; includes the right to grant</span>
 572 |     | <span class='neutral'>patent sublicenses in a manner consistent with the requirements of</span>
 573 |     | <span class='neutral'>this License.</span>
 574 |     | <span class='neutral'></span>
 575 |     | <span class='neutral'>  Each contributor grants you a non-exclusive, worldwide, royalty-free</span>
 576 |     | <span class='neutral'>patent license under the contributor&#39;s essential patent claims, to</span>
 577 |     | <span class='neutral'>make, use, sell, offer for sale, import and otherwise run, modify and</span>
 578 |     | <span class='neutral'>propagate the contents of its contributor version.</span>
 579 |     | <span class='neutral'></span>
 580 |     | <span class='neutral'>  In the following three paragraphs, a &quot;patent license&quot; is any express</span>
 581 |     | <span class='neutral'>agreement or commitment, however denominated, not to enforce a patent</span>
 582 |     | <span class='neutral'>(such as an express permission to practice a patent or covenant not to</span>
 583 |     | <span class='neutral'>sue for patent infringement).  To &quot;grant&quot; such a patent license to a</span>
 584 |     | <span class='neutral'>party means to make such an agreement or commitment not to enforce a</span>
 585 |     | <span class='neutral'>patent against the party.</span>
 586 |     | <span class='neutral'></span>
 587 |     | <span class='neutral'>  If you convey a covered work, knowingly relying on a patent license,</span>
 588 |     | <span class='neutral'>and the Corresponding Source of the work is not available for anyone</span>
 589 |     | <span class='neutral'>to copy, free of charge and under the terms of this License, through a</span>
 590 |     | <span class='neutral'>publicly available network server or other readily accessible means,</span>
 591 |     | <span class='neutral'>then you must either (1) cause the Corresponding Source to be so</span>
 592 |     | <span class='neutral'>available, or (2) arrange to deprive yourself of the benefit of the</span>
 593 |     | <span class='neutral'>patent license for this particular work, or (3) arrange, in a manner</span>
 594 |     | <span class='neutral'>consistent with the requirements of this License, to extend the patent</span>
 595 |     | <span class='neutral'>license to downstream recipients.  &quot;Knowingly relying&quot; means you have</span>
 596 |     | <span class='neutral'>actual knowledge that, but for the patent license, your conveying the</span>
 597 |     | <span class='neutral'>covered work in a country, or your recipient&#39;s use of the covered work</span>
 598 |     | <span class='neutral'>in a country, would infringe one or more identifiable patents in that</span>
 599 |     | <span class='neutral'>country that you have reason to believe are valid.</span>
 600 |     | <span class='neutral'></span>
 601 |     | <span class='neutral'>  If, pursuant to or in connection with a single transaction or</span>
 602 |     | <span class='neutral'>arrangement, you convey, or propagate by procuring conveyance of, a</span>
 603 |     | <span class='neutral'>covered work, and grant a patent license to some of the parties</span>
 604 |     | <span class='neutral'>receiving the covered work authorizing them to use, propagate, modify</span>
 605 |     | <span class='neutral'>or convey a specific copy of the covered work, then the patent license</span>
 606 |     | <span class='neutral'>you grant is automatically extended to all recipients of the covered</span>
 607 |     | <span class='neutral'>work and works based on it.</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='neutral'>  A patent license is &quot;discriminatory&quot; if it does not include within</span>
 610 |     | <span class='neutral'>the scope of its coverage, prohibits the exercise of, or is</span>
 611 |     | <span class='neutral'>conditioned on the non-exercise of one or more of the rights that are</span>
 612 |     | <span class='neutral'>specifically granted under this License.  You may not convey a covered</span>
 613 |     | <span class='neutral'>work if you are a party to an arrangement with a third party that is</span>
 614 |     | <span class='neutral'>in the business of distributing software, under which you make payment</span>
 615 |     | <span class='neutral'>to the third party based on the extent of your activity of conveying</span>
 616 |     | <span class='neutral'>the work, and under which the third party grants, to any of the</span>
 617 |     | <span class='neutral'>parties who would receive the covered work from you, a discriminatory</span>
 618 |     | <span class='neutral'>patent license (a) in connection with copies of the covered work</span>
 619 |     | <span class='neutral'>conveyed by you (or copies made from those copies), or (b) primarily</span>
 620 |     | <span class='neutral'>for and in connection with specific products or compilations that</span>
 621 |     | <span class='neutral'>contain the covered work, unless you entered into that arrangement,</span>
 622 |     | <span class='neutral'>or that patent license was granted, prior to 28 March 2007.</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='neutral'>  Nothing in this License shall be construed as excluding or limiting</span>
 625 |     | <span class='neutral'>any implied license or other defenses to infringement that may</span>
 626 |     | <span class='neutral'>otherwise be available to you under applicable patent law.</span>
 627 |     | <span class='neutral'></span>
 628 |     | <span class='neutral'>  12. No Surrender of Others&#39; Freedom.</span>
 629 |     | <span class='neutral'></span>
 630 |     | <span class='neutral'>  If conditions are imposed on you (whether by court order, agreement or</span>
 631 |     | <span class='neutral'>otherwise) that contradict the conditions of this License, they do not</span>
 632 |     | <span class='neutral'>excuse you from the conditions of this License.  If you cannot convey a</span>
 633 |     | <span class='neutral'>covered work so as to satisfy simultaneously your obligations under this</span>
 634 |     | <span class='neutral'>License and any other pertinent obligations, then as a consequence you may</span>
 635 |     | <span class='neutral'>not convey it at all.  For example, if you agree to terms that obligate you</span>
 636 |     | <span class='neutral'>to collect a royalty for further conveying from those to whom you convey</span>
 637 |     | <span class='neutral'>the Program, the only way you could satisfy both those terms and this</span>
 638 |     | <span class='neutral'>License would be to refrain entirely from conveying the Program.</span>
 639 |     | <span class='neutral'></span>
 640 |     | <span class='neutral'>  13. Use with the GNU Affero General Public License.</span>
 641 |     | <span class='neutral'></span>
 642 |     | <span class='neutral'>  Notwithstanding any other provision of this License, you have</span>
 643 |     | <span class='neutral'>permission to link or combine any covered work with a work licensed</span>
 644 |     | <span class='neutral'>under version 3 of the GNU Affero General Public License into a single</span>
 645 |     | <span class='neutral'>combined work, and to convey the resulting work.  The terms of this</span>
 646 |     | <span class='neutral'>License will continue to apply to the part which is the covered work,</span>
 647 |     | <span class='neutral'>but the special requirements of the GNU Affero General Public License,</span>
 648 |     | <span class='neutral'>section 13, concerning interaction through a network will apply to the</span>
 649 |     | <span class='neutral'>combination as such.</span>
 650 |     | <span class='neutral'></span>
 651 |     | <span class='neutral'>  14. Revised Versions of this License.</span>
 652 |     | <span class='neutral'></span>
 653 |     | <span class='neutral'>  The Free Software Foundation may publish revised and/or new versions of</span>
 654 |     | <span class='neutral'>the GNU General Public License from time to time.  Such new versions will</span>
 655 |     | <span class='neutral'>be similar in spirit to the present version, but may differ in detail to</span>
 656 |     | <span class='neutral'>address new problems or concerns.</span>
 657 |     | <span class='neutral'></span>
 658 |     | <span class='neutral'>  Each version is given a distinguishing version number.  If the</span>
 659 |     | <span class='neutral'>Program specifies that a certain numbered version of the GNU General</span>
 660 |     | <span class='neutral'>Public License &quot;or any later version&quot; applies to it, you have the</span>
 661 |     | <span class='neutral'>option of following the terms and conditions either of that numbered</span>
 662 |     | <span class='neutral'>version or of any later version published by the Free Software</span>
 663 |     | <span class='neutral'>Foundation.  If the Program does not specify a version number of the</span>
 664 |     | <span class='neutral'>GNU General Public License, you may choose any version ever published</span>
 665 |     | <span class='neutral'>by the Free Software Foundation.</span>
 666 |     | <span class='neutral'></span>
 667 |     | <span class='neutral'>  If the Program specifies that a proxy can decide which future</span>
 668 |     | <span class='neutral'>versions of the GNU General Public License can be used, that proxy&#39;s</span>
 669 |     | <span class='neutral'>public statement of acceptance of a version permanently authorizes you</span>
 670 |     | <span class='neutral'>to choose that version for the Program.</span>
 671 |     | <span class='neutral'></span>
 672 |     | <span class='neutral'>  Later license versions may give you additional or different</span>
 673 |     | <span class='neutral'>permissions.  However, no additional obligations are imposed on any</span>
 674 |     | <span class='neutral'>author or copyright holder as a result of your choosing to follow a</span>
 675 |     | <span class='neutral'>later version.</span>
 676 |     | <span class='neutral'></span>
 677 |     | <span class='neutral'>  15. Disclaimer of Warranty.</span>
 678 |     | <span class='neutral'></span>
 679 |     | <span class='neutral'>  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY</span>
 680 |     | <span class='neutral'>APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT</span>
 681 |     | <span class='neutral'>HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY</span>
 682 |     | <span class='neutral'>OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,</span>
 683 |     | <span class='neutral'>THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR</span>
 684 |     | <span class='neutral'>PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM</span>
 685 |     | <span class='neutral'>IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF</span>
 686 |     | <span class='neutral'>ALL NECESSARY SERVICING, REPAIR OR CORRECTION.</span>
 687 |     | <span class='neutral'></span>
 688 |     | <span class='neutral'>  16. Limitation of Liability.</span>
 689 |     | <span class='neutral'></span>
 690 |     | <span class='neutral'>  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING</span>
 691 |     | <span class='neutral'>WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS</span>
 692 |     | <span class='neutral'>THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY</span>
 693 |     | <span class='neutral'>GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE</span>
 694 |     | <span class='neutral'>USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF</span>
 695 |     | <span class='neutral'>DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD</span>
 696 |     | <span class='neutral'>PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),</span>
 697 |     | <span class='neutral'>EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF</span>
 698 |     | <span class='neutral'>SUCH DAMAGES.</span>
 699 |     | <span class='neutral'></span>
 700 |     | <span class='neutral'>  17. Interpretation of Sections 15 and 16.</span>
 701 |     | <span class='neutral'></span>
 702 |     | <span class='neutral'>  If the disclaimer of warranty and limitation of liability provided</span>
 703 |     | <span class='neutral'>above cannot be given local legal effect according to their terms,</span>
 704 |     | <span class='neutral'>reviewing courts shall apply local law that most closely approximates</span>
 705 |     | <span class='neutral'>an absolute waiver of all civil liability in connection with the</span>
 706 |     | <span class='neutral'>Program, unless a warranty or assumption of liability accompanies a</span>
 707 |     | <span class='neutral'>copy of the Program in return for a fee.</span>
 708 |     | <span class='neutral'></span>
 709 |     | <span class='neutral'>                     END OF TERMS AND CONDITIONS</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>            How to Apply These Terms to Your New Programs</span>
 712 |     | <span class='neutral'></span>
 713 |     | <span class='neutral'>  If you develop a new program, and you want it to be of the greatest</span>
 714 |     | <span class='neutral'>possible use to the public, the best way to achieve this is to make it</span>
 715 |     | <span class='neutral'>free software which everyone can redistribute and change under these terms.</span>
 716 |     | <span class='neutral'></span>
 717 |     | <span class='neutral'>  To do so, attach the following notices to the program.  It is safest</span>
 718 |     | <span class='neutral'>to attach them to the start of each source file to most effectively</span>
 719 |     | <span class='neutral'>state the exclusion of warranty; and each file should have at least</span>
 720 |     | <span class='neutral'>the &quot;copyright&quot; line and a pointer to where the full notice is found.</span>
 721 |     | <span class='neutral'></span>
 722 |     | <span class='neutral'>    &lt;one line to give the program&#39;s name and a brief idea of what it does.&gt;</span>
 723 |     | <span class='neutral'>    Copyright (C) &lt;year&gt;  &lt;name of author&gt;</span>
 724 |     | <span class='neutral'></span>
 725 |     | <span class='neutral'>    This program is free software: you can redistribute it and/or modify</span>
 726 |     | <span class='neutral'>    it under the terms of the GNU General Public License as published by</span>
 727 |     | <span class='neutral'>    the Free Software Foundation, either version 3 of the License, or</span>
 728 |     | <span class='neutral'>    (at your option) any later version.</span>
 729 |     | <span class='neutral'></span>
 730 |     | <span class='neutral'>    This program is distributed in the hope that it will be useful,</span>
 731 |     | <span class='neutral'>    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
 732 |     | <span class='neutral'>    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
 733 |     | <span class='neutral'>    GNU General Public License for more details.</span>
 734 |     | <span class='neutral'></span>
 735 |     | <span class='neutral'>    You should have received a copy of the GNU General Public License</span>
 736 |     | <span class='neutral'>    along with this program.  If not, see &lt;http://www.gnu.org/licenses/&gt;.</span>
 737 |     | <span class='neutral'></span>
 738 |     | <span class='neutral'>Also add information on how to contact you by electronic and paper mail.</span>
 739 |     | <span class='neutral'></span>
 740 |     | <span class='neutral'>  If the program does terminal interaction, make it output a short</span>
 741 |     | <span class='neutral'>notice like this when it starts in an interactive mode:</span>
 742 |     | <span class='neutral'></span>
 743 |     | <span class='neutral'>    &lt;program&gt;  Copyright (C) &lt;year&gt;  &lt;name of author&gt;</span>
 744 |     | <span class='neutral'>    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w&#39;.</span>
 745 |     | <span class='neutral'>    This is free software, and you are welcome to redistribute it</span>
 746 |     | <span class='neutral'>    under certain conditions; type `show c&#39; for details.</span>
 747 |     | <span class='neutral'></span>
 748 |     | <span class='neutral'>The hypothetical commands `show w&#39; and `show c&#39; should show the appropriate</span>
 749 |     | <span class='neutral'>parts of the General Public License.  Of course, your program&#39;s commands</span>
 750 |     | <span class='neutral'>might be different; for a GUI interface, you would use an &quot;about box&quot;.</span>
 751 |     | <span class='neutral'></span>
 752 |     | <span class='neutral'>  You should also get your employer (if you work as a programmer) or school,</span>
 753 |     | <span class='neutral'>if any, to sign a &quot;copyright disclaimer&quot; for the program, if necessary.</span>
 754 |     | <span class='neutral'>For more information on this, and how to apply and follow the GNU GPL, see</span>
 755 |     | <span class='neutral'>&lt;http://www.gnu.org/licenses/&gt;.</span>
 756 |     | <span class='neutral'></span>
 757 |     | <span class='neutral'>  The GNU General Public License does not permit incorporating your program</span>
 758 |     | <span class='neutral'>into proprietary programs.  If your program is a subroutine library, you</span>
 759 |     | <span class='neutral'>may consider it more useful to permit linking proprietary applications with</span>
 760 |     | <span class='neutral'>the library.  If this is what you want to do, use the GNU Lesser General</span>
 761 |     | <span class='neutral'>Public License instead of this License.  But first, please read</span>
 762 |     | <span class='neutral'>&lt;http://www.gnu.org/philosophy/why-not-lgpl.html&gt;.</span>
 763 |     | <span class='neutral'></span>
 764 |     | <span class='neutral'>*/</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/mocks/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.6.2;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @dev Interface of the ERC20 standard as defined in the EIP.</span>
  5 |     | <span class='neutral'>/// @dev This includes the optional name, symbol, and decimals metadata.</span>
  6 |     | <span class='neutral'>interface IERC20 {</span>
  7 |     | <span class='neutral'>    /// @dev Emitted when `value` tokens are moved from one account (`from`) to another (`to`).</span>
  8 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @dev Emitted when the allowance of a `spender` for an `owner` is set, where `value`</span>
 11 |     | <span class='neutral'>    /// is the new allowance.</span>
 12 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Returns the amount of tokens in existence.</span>
 15 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @notice Returns the amount of tokens owned by `account`.</span>
 18 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from the caller&#39;s account to `to`.</span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns the remaining number of tokens that `spender` is allowed</span>
 24 |     | <span class='neutral'>    /// to spend on behalf of `owner`</span>
 25 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @notice Sets `amount` as the allowance of `spender` over the caller&#39;s tokens.</span>
 28 |     | <span class='neutral'>    /// @dev Be aware of front-running risks: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729</span>
 29 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Moves `amount` tokens from `from` to `to` using the allowance mechanism.</span>
 32 |     | <span class='neutral'>    /// `amount` is then deducted from the caller&#39;s allowance.</span>
 33 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @notice Returns the name of the token.</span>
 36 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='neutral'>    /// @notice Returns the symbol of the token.</span>
 39 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Returns the decimals places of the token.</span>
 42 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 43 |     | <span class='neutral'>}</span>
 44 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPair.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ========================== FraxlendPair ============================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'>// Sam Kazemian: https://github.com/samkazemian</span>
  22 |     | <span class='neutral'>// Travis Moore: https://github.com/FortisFortuna</span>
  23 |     | <span class='neutral'>// Jack Corddry: https://github.com/corddry</span>
  24 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>// ====================================================================</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>import { ERC20 } from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
  29 |     | <span class='neutral'>import { IERC20 } from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  30 |     | <span class='neutral'>import { IERC20Metadata } from &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  31 |     | <span class='neutral'>import { ReentrancyGuard } from &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span>
  32 |     | <span class='neutral'>import { SafeCast } from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
  33 |     | <span class='neutral'>import { FraxlendPairConstants } from &quot;./FraxlendPairConstants.sol&quot;;</span>
  34 |     | <span class='neutral'>import { FraxlendPairCore } from &quot;./FraxlendPairCore.sol&quot;;</span>
  35 |     | <span class='neutral'>import { Timelock2Step } from &quot;./Timelock2Step.sol&quot;;</span>
  36 |     | <span class='neutral'>import { SafeERC20 } from &quot;./libraries/SafeERC20.sol&quot;;</span>
  37 |     | <span class='neutral'>import { VaultAccount, VaultAccountingLibrary } from &quot;./libraries/VaultAccount.sol&quot;;</span>
  38 |     | <span class='neutral'>import { IRateCalculatorV2 } from &quot;./interfaces/IRateCalculatorV2.sol&quot;;</span>
  39 |     | <span class='neutral'>import { ISwapper } from &quot;./interfaces/ISwapper.sol&quot;;</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>/// @title FraxlendPair</span>
  42 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
  43 |     | <span class='neutral'>/// @notice  The FraxlendPair is a lending pair that allows users to engage in lending and borrowing activities</span>
  44 |     | <span class='unexecuted'>contract FraxlendPair is IERC20Metadata, FraxlendPairCore {</span>
  45 |     | <span class='neutral'>    using VaultAccountingLibrary for VaultAccount;</span>
  46 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  47 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)</span>
  50 |     | <span class='neutral'>    /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)</span>
  51 |     | <span class='neutral'>    /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)</span>
  52 |     | <span class='unexecuted'>    constructor(</span>
  53 |     | <span class='neutral'>        bytes memory _configData,</span>
  54 |     | <span class='neutral'>        bytes memory _immutables,</span>
  55 |     | <span class='neutral'>        bytes memory _customConfigData</span>
  56 |     | <span class='unexecuted'>    ) FraxlendPairCore(_configData, _immutables, _customConfigData) {}</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    // ============================================================================================</span>
  59 |     | <span class='neutral'>    // ERC20 Metadata</span>
  60 |     | <span class='neutral'>    // ============================================================================================</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function name() public view override(ERC20, IERC20Metadata) returns (string memory) {</span>
  63 |     | <span class='unexecuted'>        return nameOfContract;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='unexecuted'>    function symbol() public view override(ERC20, IERC20Metadata) returns (string memory) {</span>
  67 |     | <span class='unexecuted'>        return symbolOfContract;</span>
  68 |     | <span class='neutral'>    }</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='unexecuted'>    function decimals() public view override(ERC20, IERC20Metadata) returns (uint8) {</span>
  71 |     | <span class='unexecuted'>        return decimalsOfContract;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'></span>
  74 |     | <span class='neutral'>    // totalSupply for fToken ERC20 compatibility</span>
  75 |     | <span class='unexecuted'>    function totalSupply() public view override(ERC20, IERC20) returns (uint256) {</span>
  76 |     | <span class='unexecuted'>        return totalAsset.shares;</span>
  77 |     | <span class='neutral'>    }</span>
  78 |     | <span class='neutral'></span>
  79 |     | <span class='neutral'>    // ============================================================================================</span>
  80 |     | <span class='neutral'>    // Functions: Helpers</span>
  81 |     | <span class='neutral'>    // ============================================================================================</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='unexecuted'>    function asset() external view returns (address) {</span>
  84 |     | <span class='unexecuted'>        return address(assetContract);</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'></span>
  87 |     | <span class='unexecuted'>    function getConstants()</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        pure</span>
  90 |     | <span class='neutral'>        returns (</span>
  91 |     | <span class='neutral'>            uint256 _LTV_PRECISION,</span>
  92 |     | <span class='neutral'>            uint256 _LIQ_PRECISION,</span>
  93 |     | <span class='neutral'>            uint256 _UTIL_PREC,</span>
  94 |     | <span class='neutral'>            uint256 _FEE_PRECISION,</span>
  95 |     | <span class='neutral'>            uint256 _EXCHANGE_PRECISION,</span>
  96 |     | <span class='neutral'>            uint256 _DEVIATION_PRECISION,</span>
  97 |     | <span class='neutral'>            uint256 _RATE_PRECISION,</span>
  98 |     | <span class='neutral'>            uint256 _MAX_PROTOCOL_FEE</span>
  99 |     | <span class='neutral'>        )</span>
 100 |     | <span class='neutral'>    {</span>
 101 |     | <span class='neutral'>        _LTV_PRECISION = LTV_PRECISION;</span>
 102 |     | <span class='neutral'>        _LIQ_PRECISION = LIQ_PRECISION;</span>
 103 |     | <span class='neutral'>        _UTIL_PREC = UTIL_PREC;</span>
 104 |     | <span class='neutral'>        _FEE_PRECISION = FEE_PRECISION;</span>
 105 |     | <span class='neutral'>        _EXCHANGE_PRECISION = EXCHANGE_PRECISION;</span>
 106 |     | <span class='neutral'>        _DEVIATION_PRECISION = DEVIATION_PRECISION;</span>
 107 |     | <span class='neutral'>        _RATE_PRECISION = RATE_PRECISION;</span>
 108 |     | <span class='neutral'>        _MAX_PROTOCOL_FEE = MAX_PROTOCOL_FEE;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @notice The ```getUserSnapshot``` function gets user level accounting data</span>
 112 |     | <span class='neutral'>    /// @param _address The user address</span>
 113 |     | <span class='neutral'>    /// @return _userAssetShares The user fToken balance</span>
 114 |     | <span class='neutral'>    /// @return _userBorrowShares The user borrow shares</span>
 115 |     | <span class='neutral'>    /// @return _userCollateralBalance The user collateral balance</span>
 116 |     | <span class='unexecuted'>    function getUserSnapshot(</span>
 117 |     | <span class='neutral'>        address _address</span>
 118 |     | <span class='unexecuted'>    ) external view returns (uint256 _userAssetShares, uint256 _userBorrowShares, uint256 _userCollateralBalance) {</span>
 119 |     | <span class='unexecuted'>        _userAssetShares = balanceOf(_address);</span>
 120 |     | <span class='unexecuted'>        _userBorrowShares = userBorrowShares[_address];</span>
 121 |     | <span class='unexecuted'>        _userCollateralBalance = userCollateralBalance[_address];</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    /// @notice The ```getPairAccounting``` function gets all pair level accounting numbers</span>
 125 |     | <span class='neutral'>    /// @return _totalAssetAmount Total assets deposited and interest accrued, total claims</span>
 126 |     | <span class='neutral'>    /// @return _totalAssetShares Total fTokens</span>
 127 |     | <span class='neutral'>    /// @return _totalBorrowAmount Total borrows</span>
 128 |     | <span class='neutral'>    /// @return _totalBorrowShares Total borrow shares</span>
 129 |     | <span class='neutral'>    /// @return _totalCollateral Total collateral</span>
 130 |     | <span class='unexecuted'>    function getPairAccounting()</span>
 131 |     | <span class='neutral'>        external</span>
 132 |     | <span class='neutral'>        view</span>
 133 |     | <span class='neutral'>        returns (</span>
 134 |     | <span class='unexecuted'>            uint128 _totalAssetAmount,</span>
 135 |     | <span class='unexecuted'>            uint128 _totalAssetShares,</span>
 136 |     | <span class='unexecuted'>            uint128 _totalBorrowAmount,</span>
 137 |     | <span class='unexecuted'>            uint128 _totalBorrowShares,</span>
 138 |     | <span class='unexecuted'>            uint256 _totalCollateral</span>
 139 |     | <span class='neutral'>        )</span>
 140 |     | <span class='neutral'>    {</span>
 141 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, VaultAccount memory _totalBorrow) = previewAddInterest();</span>
 142 |     | <span class='unexecuted'>        _totalAssetAmount = _totalAsset.totalAmount(address(externalAssetVault)).toUint128();</span>
 143 |     | <span class='unexecuted'>        _totalAssetShares = _totalAsset.shares;</span>
 144 |     | <span class='unexecuted'>        _totalBorrowAmount = _totalBorrow.amount;</span>
 145 |     | <span class='unexecuted'>        _totalBorrowShares = _totalBorrow.shares;</span>
 146 |     | <span class='unexecuted'>        _totalCollateral = totalCollateral;</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    /// @notice The ```toBorrowShares``` function converts a given amount of borrow debt into the number of shares</span>
 150 |     | <span class='neutral'>    /// @param _amount Amount of borrow</span>
 151 |     | <span class='neutral'>    /// @param _roundUp Whether to roundup during division</span>
 152 |     | <span class='neutral'>    /// @param _previewInterest Whether to simulate interest accrual</span>
 153 |     | <span class='neutral'>    /// @return _shares The number of shares</span>
 154 |     | <span class='unexecuted'>    function toBorrowShares(</span>
 155 |     | <span class='neutral'>        uint256 _amount,</span>
 156 |     | <span class='neutral'>        bool _roundUp,</span>
 157 |     | <span class='neutral'>        bool _previewInterest</span>
 158 |     | <span class='unexecuted'>    ) external view returns (uint256 _shares) {</span>
 159 |     | <span class='unexecuted'>        if (_previewInterest) {</span>
 160 |     | <span class='unexecuted'>            (, , , , , VaultAccount memory _totalBorrow) = previewAddInterest();</span>
 161 |     | <span class='unexecuted'>            _shares = _totalBorrow.toShares(_amount, _roundUp);</span>
 162 |     | <span class='neutral'>        } else {</span>
 163 |     | <span class='unexecuted'>            _shares = totalBorrow.toShares(_amount, _roundUp);</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'>    }</span>
 166 |     | <span class='neutral'></span>
 167 |     | <span class='neutral'>    /// @notice The ```toBorrowAmount``` function converts a given amount of borrow debt into the number of shares</span>
 168 |     | <span class='neutral'>    /// @param _shares Shares of borrow</span>
 169 |     | <span class='neutral'>    /// @param _roundUp Whether to roundup during division</span>
 170 |     | <span class='neutral'>    /// @param _previewInterest Whether to simulate interest accrual</span>
 171 |     | <span class='neutral'>    /// @return _amount The amount of asset</span>
 172 |     | <span class='unexecuted'>    function toBorrowAmount(</span>
 173 |     | <span class='neutral'>        uint256 _shares,</span>
 174 |     | <span class='neutral'>        bool _roundUp,</span>
 175 |     | <span class='neutral'>        bool _previewInterest</span>
 176 |     | <span class='unexecuted'>    ) external view returns (uint256 _amount) {</span>
 177 |     | <span class='unexecuted'>        if (_previewInterest) {</span>
 178 |     | <span class='unexecuted'>            (, , , , , VaultAccount memory _totalBorrow) = previewAddInterest();</span>
 179 |     | <span class='unexecuted'>            _amount = _totalBorrow.toAmount(_shares, _roundUp);</span>
 180 |     | <span class='neutral'>        } else {</span>
 181 |     | <span class='unexecuted'>            _amount = totalBorrow.toAmount(_shares, _roundUp);</span>
 182 |     | <span class='neutral'>        }</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice The ```toAssetAmount``` function converts a given number of shares to an asset amount</span>
 186 |     | <span class='neutral'>    /// @param _shares Shares of asset (fToken)</span>
 187 |     | <span class='neutral'>    /// @param _roundUp Whether to round up after division</span>
 188 |     | <span class='neutral'>    /// @param _previewInterest Whether to preview interest accrual before calculation</span>
 189 |     | <span class='neutral'>    /// @return _amount The amount of asset</span>
 190 |     | <span class='unexecuted'>    function toAssetAmount(</span>
 191 |     | <span class='neutral'>        uint256 _shares,</span>
 192 |     | <span class='neutral'>        bool _roundUp,</span>
 193 |     | <span class='neutral'>        bool _previewInterest</span>
 194 |     | <span class='unexecuted'>    ) public view returns (uint256 _amount) {</span>
 195 |     | <span class='unexecuted'>        if (_previewInterest) {</span>
 196 |     | <span class='unexecuted'>            (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
 197 |     | <span class='unexecuted'>            _amount = _totalAsset.toAmount(_shares, _roundUp);</span>
 198 |     | <span class='neutral'>        } else {</span>
 199 |     | <span class='unexecuted'>            _amount = totalAsset.toAmount(_shares, _roundUp);</span>
 200 |     | <span class='neutral'>        }</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice The ```toAssetShares``` function converts a given asset amount to a number of asset shares (fTokens)</span>
 204 |     | <span class='neutral'>    /// @param _amount The amount of asset</span>
 205 |     | <span class='neutral'>    /// @param _roundUp Whether to round up after division</span>
 206 |     | <span class='neutral'>    /// @param _previewInterest Whether to preview interest accrual before calculation</span>
 207 |     | <span class='neutral'>    /// @return _shares The number of shares (fTokens)</span>
 208 |     | <span class='unexecuted'>    function toAssetShares(</span>
 209 |     | <span class='neutral'>        uint256 _amount,</span>
 210 |     | <span class='neutral'>        bool _roundUp,</span>
 211 |     | <span class='neutral'>        bool _previewInterest</span>
 212 |     | <span class='unexecuted'>    ) public view returns (uint256 _shares) {</span>
 213 |     | <span class='unexecuted'>        if (_previewInterest) {</span>
 214 |     | <span class='unexecuted'>            (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
 215 |     | <span class='unexecuted'>            _shares = _totalAsset.toShares(_amount, _roundUp);</span>
 216 |     | <span class='neutral'>        } else {</span>
 217 |     | <span class='unexecuted'>            _shares = totalAsset.toShares(_amount, _roundUp);</span>
 218 |     | <span class='neutral'>        }</span>
 219 |     | <span class='neutral'>    }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>    function convertToAssets(uint256 _shares) external view returns (uint256 _assets) {</span>
 222 |     | <span class='unexecuted'>        _assets = toAssetAmount(_shares, false, true);</span>
 223 |     | <span class='neutral'>    }</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='unexecuted'>    function convertToShares(uint256 _assets) external view returns (uint256 _shares) {</span>
 226 |     | <span class='unexecuted'>        _shares = toAssetShares(_assets, false, true);</span>
 227 |     | <span class='neutral'>    }</span>
 228 |     | <span class='neutral'></span>
 229 |     | <span class='unexecuted'>    function pricePerShare() external view returns (uint256 _amount) {</span>
 230 |     | <span class='unexecuted'>        _amount = toAssetAmount(1e18, false, true);</span>
 231 |     | <span class='neutral'>    }</span>
 232 |     | <span class='neutral'></span>
 233 |     | <span class='unexecuted'>    function totalAssets() external view returns (uint256) {</span>
 234 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
 235 |     | <span class='unexecuted'>        return _totalAsset.totalAmount(address(externalAssetVault));</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'></span>
 238 |     | <span class='unexecuted'>    function maxDeposit(address) public view returns (uint256 _maxAssets) {</span>
 239 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
 240 |     | <span class='unexecuted'>        _maxAssets = _totalAsset.totalAmount(address(externalAssetVault)) &gt;= depositLimit ? 0 : depositLimit - _totalAsset.totalAmount(address(externalAssetVault));</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function maxMint(address) external view returns (uint256 _maxShares) {</span>
 244 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
 245 |     | <span class='unexecuted'>        uint256 _maxDeposit = _totalAsset.totalAmount(address(externalAssetVault)) &gt;= depositLimit ? 0 : depositLimit - _totalAsset.totalAmount(address(externalAssetVault));</span>
 246 |     | <span class='unexecuted'>        _maxShares = _totalAsset.toShares(_maxDeposit, false);</span>
 247 |     | <span class='neutral'>    }</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>    function maxWithdraw(address _owner) external view returns (uint256 _maxAssets) {</span>
 250 |     | <span class='unexecuted'>        if (isWithdrawPaused) return 0;</span>
 251 |     | <span class='unexecuted'>        (</span>
 252 |     | <span class='neutral'>            ,</span>
 253 |     | <span class='neutral'>            ,</span>
 254 |     | <span class='unexecuted'>            uint256 _feesShare,</span>
 255 |     | <span class='neutral'>            ,</span>
 256 |     | <span class='unexecuted'>            VaultAccount memory _totalAsset,</span>
 257 |     | <span class='unexecuted'>            VaultAccount memory _totalBorrow</span>
 258 |     | <span class='unexecuted'>        ) = previewAddInterest();</span>
 259 |     | <span class='neutral'>        // Get the owner balance and include the fees share if owner is this contract</span>
 260 |     | <span class='unexecuted'>        uint256 _ownerBalance = _owner == address(this) ? balanceOf(_owner) + _feesShare : balanceOf(_owner);</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='neutral'>        // Return the lower of total assets in contract or total assets available to _owner</span>
 263 |     | <span class='unexecuted'>        uint256 _totalAssetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow, true);</span>
 264 |     | <span class='unexecuted'>        uint256 _totalUserWithdraw = _totalAsset.toAmount(_ownerBalance, false);</span>
 265 |     | <span class='unexecuted'>        _maxAssets = _totalAssetsAvailable &lt; _totalUserWithdraw ? _totalAssetsAvailable : _totalUserWithdraw;</span>
 266 |     | <span class='neutral'>    }</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='unexecuted'>    function maxRedeem(address _owner) external view returns (uint256 _maxShares) {</span>
 269 |     | <span class='unexecuted'>        if (isWithdrawPaused) return 0;</span>
 270 |     | <span class='unexecuted'>        (</span>
 271 |     | <span class='neutral'>            ,</span>
 272 |     | <span class='neutral'>            ,</span>
 273 |     | <span class='unexecuted'>            uint256 _feesShare,</span>
 274 |     | <span class='neutral'>            ,</span>
 275 |     | <span class='unexecuted'>            VaultAccount memory _totalAsset,</span>
 276 |     | <span class='unexecuted'>            VaultAccount memory _totalBorrow</span>
 277 |     | <span class='unexecuted'>        ) = previewAddInterest();</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>        // Calculate the total shares available</span>
 280 |     | <span class='unexecuted'>        uint256 _totalAssetsAvailable = _totalAssetAvailable(_totalAsset, _totalBorrow, true);</span>
 281 |     | <span class='unexecuted'>        uint256 _totalSharesAvailable = _totalAsset.toShares(_totalAssetsAvailable, false);</span>
 282 |     | <span class='neutral'></span>
 283 |     | <span class='neutral'>        // Get the owner balance and include the fees share if owner is this contract</span>
 284 |     | <span class='unexecuted'>        uint256 _ownerBalance = _owner == address(this) ? balanceOf(_owner) + _feesShare : balanceOf(_owner);</span>
 285 |     | <span class='neutral'>        _maxShares = _totalSharesAvailable &lt; _ownerBalance ? _totalSharesAvailable : _ownerBalance;</span>
 286 |     | <span class='neutral'>    }</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='neutral'>    // ============================================================================================</span>
 289 |     | <span class='neutral'>    // Functions: Configuration</span>
 290 |     | <span class='neutral'>    // ============================================================================================</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>    bool public isOracleSetterRevoked;</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='neutral'>    /// @notice The ```RevokeOracleSetter``` event is emitted when the oracle setter is revoked</span>
 295 |     | <span class='neutral'>    event RevokeOracleInfoSetter();</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    /// @notice The ```revokeOracleSetter``` function revokes the oracle setter</span>
 298 |     | <span class='unexecuted'>    function revokeOracleInfoSetter() external {</span>
 299 |     | <span class='unexecuted'>        _requireTimelock();</span>
 300 |     | <span class='unexecuted'>        isOracleSetterRevoked = true;</span>
 301 |     | <span class='unexecuted'>        emit RevokeOracleInfoSetter();</span>
 302 |     | <span class='neutral'>    }</span>
 303 |     | <span class='neutral'></span>
 304 |     | <span class='neutral'>    /// @notice The ```SetOracleInfo``` event is emitted when the oracle info (address and max deviation) is set</span>
 305 |     | <span class='neutral'>    /// @param oldOracle The old oracle address</span>
 306 |     | <span class='neutral'>    /// @param oldMaxOracleDeviation The old max oracle deviation</span>
 307 |     | <span class='neutral'>    /// @param newOracle The new oracle address</span>
 308 |     | <span class='neutral'>    /// @param newMaxOracleDeviation The new max oracle deviation</span>
 309 |     | <span class='neutral'>    event SetOracleInfo(</span>
 310 |     | <span class='neutral'>        address oldOracle,</span>
 311 |     | <span class='neutral'>        uint32 oldMaxOracleDeviation,</span>
 312 |     | <span class='neutral'>        address newOracle,</span>
 313 |     | <span class='neutral'>        uint32 newMaxOracleDeviation</span>
 314 |     | <span class='neutral'>    );</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>    /// @notice The ```setOracleInfo``` function sets the oracle data</span>
 317 |     | <span class='neutral'>    /// @param _newOracle The new oracle address</span>
 318 |     | <span class='neutral'>    /// @param _newMaxOracleDeviation The new max oracle deviation</span>
 319 |     | <span class='unexecuted'>    function setOracle(address _newOracle, uint32 _newMaxOracleDeviation) external {</span>
 320 |     | <span class='unexecuted'>        _requireTimelock();</span>
 321 |     | <span class='unexecuted'>        if (isOracleSetterRevoked) revert SetterRevoked();</span>
 322 |     | <span class='unexecuted'>        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;</span>
 323 |     | <span class='unexecuted'>        emit SetOracleInfo(</span>
 324 |     | <span class='neutral'>            _exchangeRateInfo.oracle,</span>
 325 |     | <span class='neutral'>            _exchangeRateInfo.maxOracleDeviation,</span>
 326 |     | <span class='unexecuted'>            _newOracle,</span>
 327 |     | <span class='unexecuted'>            _newMaxOracleDeviation</span>
 328 |     | <span class='neutral'>        );</span>
 329 |     | <span class='unexecuted'>        _exchangeRateInfo.oracle = _newOracle;</span>
 330 |     | <span class='unexecuted'>        _exchangeRateInfo.maxOracleDeviation = _newMaxOracleDeviation;</span>
 331 |     | <span class='unexecuted'>        exchangeRateInfo = _exchangeRateInfo;</span>
 332 |     | <span class='neutral'>    }</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='unexecuted'>    bool public isMaxLTVSetterRevoked;</span>
 335 |     | <span class='neutral'></span>
 336 |     | <span class='neutral'>    /// @notice The ```RevokeMaxLTVSetter``` event is emitted when the max LTV setter is revoked</span>
 337 |     | <span class='neutral'>    event RevokeMaxLTVSetter();</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    /// @notice The ```revokeMaxLTVSetter``` function revokes the max LTV setter</span>
 340 |     | <span class='unexecuted'>    function revokeMaxLTVSetter() external {</span>
 341 |     | <span class='unexecuted'>        _requireTimelock();</span>
 342 |     | <span class='unexecuted'>        isMaxLTVSetterRevoked = true;</span>
 343 |     | <span class='unexecuted'>        emit RevokeMaxLTVSetter();</span>
 344 |     | <span class='neutral'>    }</span>
 345 |     | <span class='neutral'></span>
 346 |     | <span class='neutral'>    /// @notice The ```SetMaxLTV``` event is emitted when the max LTV is set</span>
 347 |     | <span class='neutral'>    /// @param oldMaxLTV The old max LTV</span>
 348 |     | <span class='neutral'>    /// @param newMaxLTV The new max LTV</span>
 349 |     | <span class='neutral'>    event SetMaxLTV(uint256 oldMaxLTV, uint256 newMaxLTV);</span>
 350 |     | <span class='neutral'></span>
 351 |     | <span class='neutral'>    /// @notice The ```setMaxLTV``` function sets the max LTV</span>
 352 |     | <span class='neutral'>    /// @param _newMaxLTV The new max LTV</span>
 353 |     | <span class='unexecuted'>    function setMaxLTV(uint256 _newMaxLTV) external {</span>
 354 |     | <span class='unexecuted'>        _requireTimelock();</span>
 355 |     | <span class='unexecuted'>        if (isMaxLTVSetterRevoked) revert SetterRevoked();</span>
 356 |     | <span class='unexecuted'>        emit SetMaxLTV(maxLTV, _newMaxLTV);</span>
 357 |     | <span class='unexecuted'>        maxLTV = _newMaxLTV;</span>
 358 |     | <span class='neutral'>    }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='unexecuted'>    bool public isRateContractSetterRevoked;</span>
 361 |     | <span class='neutral'></span>
 362 |     | <span class='neutral'>    /// @notice The ```RevokeRateContractSetter``` event is emitted when the rate contract setter is revoked</span>
 363 |     | <span class='neutral'>    event RevokeRateContractSetter();</span>
 364 |     | <span class='neutral'></span>
 365 |     | <span class='neutral'>    /// @notice The ```revokeRateContractSetter``` function revokes the rate contract setter</span>
 366 |     | <span class='unexecuted'>    function revokeRateContractSetter() external {</span>
 367 |     | <span class='unexecuted'>        _requireTimelock();</span>
 368 |     | <span class='unexecuted'>        isRateContractSetterRevoked = true;</span>
 369 |     | <span class='unexecuted'>        emit RevokeRateContractSetter();</span>
 370 |     | <span class='neutral'>    }</span>
 371 |     | <span class='neutral'></span>
 372 |     | <span class='neutral'>    /// @notice The ```SetRateContract``` event is emitted when the rate contract is set</span>
 373 |     | <span class='neutral'>    /// @param oldRateContract The old rate contract</span>
 374 |     | <span class='neutral'>    /// @param newRateContract The new rate contract</span>
 375 |     | <span class='neutral'>    event SetRateContract(address oldRateContract, address newRateContract);</span>
 376 |     | <span class='neutral'></span>
 377 |     | <span class='neutral'>    /// @notice The ```setRateContract``` function sets the rate contract address</span>
 378 |     | <span class='neutral'>    /// @param _newRateContract The new rate contract address</span>
 379 |     | <span class='unexecuted'>    function setRateContract(address _newRateContract) external {</span>
 380 |     | <span class='unexecuted'>        _requireTimelock();</span>
 381 |     | <span class='unexecuted'>        if (isRateContractSetterRevoked) revert SetterRevoked();</span>
 382 |     | <span class='unexecuted'>        emit SetRateContract(address(rateContract), _newRateContract);</span>
 383 |     | <span class='unexecuted'>        rateContract = IRateCalculatorV2(_newRateContract);</span>
 384 |     | <span class='neutral'>    }</span>
 385 |     | <span class='neutral'></span>
 386 |     | <span class='unexecuted'>    bool public isLiquidationFeeSetterRevoked;</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='neutral'>    /// @notice The ```RevokeLiquidationFeeSetter``` event is emitted when the liquidation fee setter is revoked</span>
 389 |     | <span class='neutral'>    event RevokeLiquidationFeeSetter();</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    /// @notice The ```revokeLiquidationFeeSetter``` function revokes the liquidation fee setter</span>
 392 |     | <span class='unexecuted'>    function revokeLiquidationFeeSetter() external {</span>
 393 |     | <span class='unexecuted'>        _requireTimelock();</span>
 394 |     | <span class='unexecuted'>        isLiquidationFeeSetterRevoked = true;</span>
 395 |     | <span class='unexecuted'>        emit RevokeLiquidationFeeSetter();</span>
 396 |     | <span class='neutral'>    }</span>
 397 |     | <span class='neutral'></span>
 398 |     | <span class='neutral'>    /// @notice The ```SetLiquidationFees``` event is emitted when the liquidation fees are set</span>
 399 |     | <span class='neutral'>    /// @param oldCleanLiquidationFee The old clean liquidation fee</span>
 400 |     | <span class='neutral'>    /// @param oldDirtyLiquidationFee The old dirty liquidation fee</span>
 401 |     | <span class='neutral'>    /// @param oldProtocolLiquidationFee The old protocol liquidation fee</span>
 402 |     | <span class='neutral'>    /// @param newCleanLiquidationFee The new clean liquidation fee</span>
 403 |     | <span class='neutral'>    /// @param newDirtyLiquidationFee The new dirty liquidation fee</span>
 404 |     | <span class='neutral'>    /// @param newProtocolLiquidationFee The new protocol liquidation fee</span>
 405 |     | <span class='neutral'>    event SetLiquidationFees(</span>
 406 |     | <span class='neutral'>        uint256 oldCleanLiquidationFee,</span>
 407 |     | <span class='neutral'>        uint256 oldDirtyLiquidationFee,</span>
 408 |     | <span class='neutral'>        uint256 oldProtocolLiquidationFee,</span>
 409 |     | <span class='neutral'>        uint256 newCleanLiquidationFee,</span>
 410 |     | <span class='neutral'>        uint256 newDirtyLiquidationFee,</span>
 411 |     | <span class='neutral'>        uint256 newProtocolLiquidationFee</span>
 412 |     | <span class='neutral'>    );</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>    /// @notice The ```setLiquidationFees``` function sets the liquidation fees</span>
 415 |     | <span class='neutral'>    /// @param _newCleanLiquidationFee The new clean liquidation fee</span>
 416 |     | <span class='neutral'>    /// @param _newDirtyLiquidationFee The new dirty liquidation fee</span>
 417 |     | <span class='unexecuted'>    function setLiquidationFees(</span>
 418 |     | <span class='neutral'>        uint256 _newCleanLiquidationFee,</span>
 419 |     | <span class='neutral'>        uint256 _newDirtyLiquidationFee,</span>
 420 |     | <span class='neutral'>        uint256 _newProtocolLiquidationFee</span>
 421 |     | <span class='neutral'>    ) external {</span>
 422 |     | <span class='unexecuted'>        _requireTimelock();</span>
 423 |     | <span class='unexecuted'>        if (isLiquidationFeeSetterRevoked) revert SetterRevoked();</span>
 424 |     | <span class='unexecuted'>        emit SetLiquidationFees(</span>
 425 |     | <span class='unexecuted'>            cleanLiquidationFee,</span>
 426 |     | <span class='unexecuted'>            dirtyLiquidationFee,</span>
 427 |     | <span class='unexecuted'>            protocolLiquidationFee,</span>
 428 |     | <span class='neutral'>            _newCleanLiquidationFee,</span>
 429 |     | <span class='neutral'>            _newDirtyLiquidationFee,</span>
 430 |     | <span class='neutral'>            _newProtocolLiquidationFee</span>
 431 |     | <span class='neutral'>        );</span>
 432 |     | <span class='unexecuted'>        cleanLiquidationFee = _newCleanLiquidationFee;</span>
 433 |     | <span class='unexecuted'>        dirtyLiquidationFee = _newDirtyLiquidationFee;</span>
 434 |     | <span class='unexecuted'>        protocolLiquidationFee = _newProtocolLiquidationFee;</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='neutral'>    /// @notice The ```ChangeFee``` event first when the fee is changed</span>
 438 |     | <span class='neutral'>    /// @param newFee The new fee</span>
 439 |     | <span class='neutral'>    event ChangeFee(uint32 newFee);</span>
 440 |     | <span class='neutral'></span>
 441 |     | <span class='neutral'>    /// @notice The ```changeFee``` function changes the protocol fee, max 50%</span>
 442 |     | <span class='neutral'>    /// @param _newFee The new fee</span>
 443 |     | <span class='unexecuted'>    function changeFee(uint32 _newFee) external {</span>
 444 |     | <span class='unexecuted'>        _requireTimelock();</span>
 445 |     | <span class='unexecuted'>        if (isInterestPaused) revert InterestPaused();</span>
 446 |     | <span class='unexecuted'>        if (_newFee &gt; MAX_PROTOCOL_FEE) {</span>
 447 |     | <span class='unexecuted'>            revert BadProtocolFee();</span>
 448 |     | <span class='neutral'>        }</span>
 449 |     | <span class='unexecuted'>        _addInterest();</span>
 450 |     | <span class='unexecuted'>        currentRateInfo.feeToProtocolRate = _newFee;</span>
 451 |     | <span class='unexecuted'>        emit ChangeFee(_newFee);</span>
 452 |     | <span class='neutral'>    }</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>    /// @notice The ```WithdrawFees``` event fires when the fees are withdrawn</span>
 455 |     | <span class='neutral'>    /// @param shares Number of shares (fTokens) redeemed</span>
 456 |     | <span class='neutral'>    /// @param recipient To whom the assets were sent</span>
 457 |     | <span class='neutral'>    /// @param amountToTransfer The amount of fees redeemed</span>
 458 |     | <span class='neutral'>    event WithdrawFees(uint128 shares, address recipient, uint256 amountToTransfer, uint256 collateralAmount);</span>
 459 |     | <span class='neutral'></span>
 460 |     | <span class='neutral'>    /// @notice The ```withdrawFees``` function withdraws fees accumulated</span>
 461 |     | <span class='neutral'>    /// @param _shares Number of fTokens to redeem</span>
 462 |     | <span class='neutral'>    /// @param _recipient Address to send the assets</span>
 463 |     | <span class='neutral'>    /// @return _amountToTransfer Amount of assets sent to recipient</span>
 464 |     | <span class='unexecuted'>    function withdrawFees(uint128 _shares, address _recipient) external onlyOwner returns (uint256 _amountToTransfer) {</span>
 465 |     | <span class='unexecuted'>        if (_recipient == address(0)) revert InvalidReceiver();</span>
 466 |     | <span class='neutral'></span>
 467 |     | <span class='neutral'>        // Grab some data from state to save gas</span>
 468 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
 469 |     | <span class='neutral'></span>
 470 |     | <span class='neutral'>        // Take all available if 0 value passed</span>
 471 |     | <span class='unexecuted'>        if (_shares == 0) _shares = balanceOf(address(this)).toUint128();</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>        // We must calculate this before we subtract from _totalAsset or invoke _burn</span>
 474 |     | <span class='unexecuted'>        _amountToTransfer = _totalAsset.toAmount(_shares, true);</span>
 475 |     | <span class='neutral'></span>
 476 |     | <span class='unexecuted'>        _approve(address(this), msg.sender, _shares);</span>
 477 |     | <span class='unexecuted'>        _redeem(_totalAsset, _amountToTransfer.toUint128(), _shares, _recipient, address(this), false);</span>
 478 |     | <span class='unexecuted'>        uint256 _collateralAmount = userCollateralBalance[address(this)];</span>
 479 |     | <span class='unexecuted'>        _removeCollateral(_collateralAmount, _recipient, address(this));</span>
 480 |     | <span class='unexecuted'>        emit WithdrawFees(_shares, _recipient, _amountToTransfer, _collateralAmount);</span>
 481 |     | <span class='neutral'>    }</span>
 482 |     | <span class='neutral'></span>
 483 |     | <span class='neutral'>    /// @notice The ```SetSwapper``` event fires whenever a swapper is black or whitelisted</span>
 484 |     | <span class='neutral'>    /// @param swapper The swapper address</span>
 485 |     | <span class='neutral'>    /// @param approval The approval</span>
 486 |     | <span class='neutral'>    event SetSwapper(address swapper, bool approval);</span>
 487 |     | <span class='neutral'></span>
 488 |     | <span class='neutral'>    /// @notice The ```setSwapper``` function is called to black or whitelist a given swapper address</span>
 489 |     | <span class='neutral'>    /// @dev</span>
 490 |     | <span class='neutral'>    /// @param _swapper The swapper address</span>
 491 |     | <span class='neutral'>    /// @param _approval The approval</span>
 492 |     | <span class='unexecuted'>    function setSwapper(address _swapper, bool _approval) external onlyOwner {</span>
 493 |     | <span class='unexecuted'>        swappers[_swapper] = _approval;</span>
 494 |     | <span class='unexecuted'>        emit SetSwapper(_swapper, _approval);</span>
 495 |     | <span class='neutral'>    }</span>
 496 |     | <span class='neutral'></span>
 497 |     | <span class='neutral'>    // ============================================================================================</span>
 498 |     | <span class='neutral'>    // Functions: Access Control</span>
 499 |     | <span class='neutral'>    // ============================================================================================</span>
 500 |     | <span class='neutral'></span>
 501 |     | <span class='neutral'>    /// @notice The ```pause``` function is called to pause all contract functionality</span>
 502 |     | <span class='unexecuted'>    function pause() external {</span>
 503 |     | <span class='unexecuted'>        _requireProtocolOrOwner();</span>
 504 |     | <span class='unexecuted'>        if (!isBorrowAccessControlRevoked) _setBorrowLimit(0);</span>
 505 |     | <span class='unexecuted'>        if (!isDepositAccessControlRevoked) _setDepositLimit(0);</span>
 506 |     | <span class='unexecuted'>        if (!isRepayAccessControlRevoked) _pauseRepay(true);</span>
 507 |     | <span class='unexecuted'>        if (!isWithdrawAccessControlRevoked) _pauseWithdraw(true);</span>
 508 |     | <span class='unexecuted'>        if (!isLiquidateAccessControlRevoked) _pauseLiquidate(true);</span>
 509 |     | <span class='unexecuted'>        if (!isInterestAccessControlRevoked) {</span>
 510 |     | <span class='unexecuted'>            _addInterest();</span>
 511 |     | <span class='unexecuted'>            _pauseInterest(true);</span>
 512 |     | <span class='neutral'>        }</span>
 513 |     | <span class='neutral'>    }</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='neutral'>    /// @notice The ```unpause``` function is called to unpause all contract functionality</span>
 516 |     | <span class='unexecuted'>    function unpause() external {</span>
 517 |     | <span class='unexecuted'>        _requireTimelockOrOwner();</span>
 518 |     | <span class='unexecuted'>        if (!isBorrowAccessControlRevoked) _setBorrowLimit(type(uint256).max);</span>
 519 |     | <span class='unexecuted'>        if (!isDepositAccessControlRevoked) _setDepositLimit(type(uint256).max);</span>
 520 |     | <span class='unexecuted'>        if (!isRepayAccessControlRevoked) _pauseRepay(false);</span>
 521 |     | <span class='unexecuted'>        if (!isWithdrawAccessControlRevoked) _pauseWithdraw(false);</span>
 522 |     | <span class='unexecuted'>        if (!isLiquidateAccessControlRevoked) _pauseLiquidate(false);</span>
 523 |     | <span class='unexecuted'>        if (!isInterestAccessControlRevoked) {</span>
 524 |     | <span class='unexecuted'>            _addInterest();</span>
 525 |     | <span class='unexecuted'>            _pauseInterest(false);</span>
 526 |     | <span class='neutral'>        }</span>
 527 |     | <span class='neutral'>    }</span>
 528 |     | <span class='neutral'></span>
 529 |     | <span class='neutral'>    /// @notice The ```pauseBorrow``` function sets borrow limit to 0</span>
 530 |     | <span class='unexecuted'>    function pauseBorrow() external {</span>
 531 |     | <span class='unexecuted'>        _requireProtocolOrOwner();</span>
 532 |     | <span class='unexecuted'>        if (isBorrowAccessControlRevoked) revert AccessControlRevoked();</span>
 533 |     | <span class='unexecuted'>        _setBorrowLimit(0);</span>
 534 |     | <span class='neutral'>    }</span>
 535 |     | <span class='neutral'></span>
 536 |     | <span class='neutral'>    /// @notice The ```setBorrowLimit``` function sets the borrow limit</span>
 537 |     | <span class='neutral'>    /// @param _limit The new borrow limit</span>
 538 |     | <span class='unexecuted'>    function setBorrowLimit(uint256 _limit) external {</span>
 539 |     | <span class='unexecuted'>        _requireTimelockOrOwner();</span>
 540 |     | <span class='unexecuted'>        if (isBorrowAccessControlRevoked) revert AccessControlRevoked();</span>
 541 |     | <span class='unexecuted'>        _setBorrowLimit(_limit);</span>
 542 |     | <span class='neutral'>    }</span>
 543 |     | <span class='neutral'></span>
 544 |     | <span class='neutral'>    /// @notice The ```revokeBorrowLimitAccessControl``` function revokes borrow limit access control</span>
 545 |     | <span class='neutral'>    /// @param _borrowLimit The new borrow limit</span>
 546 |     | <span class='unexecuted'>    function revokeBorrowLimitAccessControl(uint256 _borrowLimit) external {</span>
 547 |     | <span class='unexecuted'>        _requireTimelock();</span>
 548 |     | <span class='unexecuted'>        _revokeBorrowAccessControl(_borrowLimit);</span>
 549 |     | <span class='neutral'>    }</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='neutral'>    /// @notice The ```pauseDeposit``` function pauses deposit functionality</span>
 552 |     | <span class='unexecuted'>    function pauseDeposit() external {</span>
 553 |     | <span class='unexecuted'>        _requireProtocolOrOwner();</span>
 554 |     | <span class='unexecuted'>        if (isDepositAccessControlRevoked) revert AccessControlRevoked();</span>
 555 |     | <span class='unexecuted'>        _setDepositLimit(0);</span>
 556 |     | <span class='neutral'>    }</span>
 557 |     | <span class='neutral'></span>
 558 |     | <span class='neutral'>    /// @notice The ```setDepositLimit``` function sets the deposit limit</span>
 559 |     | <span class='neutral'>    /// @param _limit The new deposit limit</span>
 560 |     | <span class='unexecuted'>    function setDepositLimit(uint256 _limit) external {</span>
 561 |     | <span class='unexecuted'>        _requireTimelockOrOwner();</span>
 562 |     | <span class='unexecuted'>        if (isDepositAccessControlRevoked) revert AccessControlRevoked();</span>
 563 |     | <span class='unexecuted'>        _setDepositLimit(_limit);</span>
 564 |     | <span class='neutral'>    }</span>
 565 |     | <span class='neutral'></span>
 566 |     | <span class='neutral'>    /// @notice The ```revokeDepositLimitAccessControl``` function revokes deposit limit access control</span>
 567 |     | <span class='neutral'>    /// @param _depositLimit The new deposit limit</span>
 568 |     | <span class='unexecuted'>    function revokeDepositLimitAccessControl(uint256 _depositLimit) external {</span>
 569 |     | <span class='unexecuted'>        _requireTimelock();</span>
 570 |     | <span class='unexecuted'>        _revokeDepositAccessControl(_depositLimit);</span>
 571 |     | <span class='neutral'>    }</span>
 572 |     | <span class='neutral'></span>
 573 |     | <span class='neutral'>    /// @notice The ```pauseRepay``` function pauses repay functionality</span>
 574 |     | <span class='neutral'>    /// @param _isPaused The new pause state</span>
 575 |     | <span class='unexecuted'>    function pauseRepay(bool _isPaused) external {</span>
 576 |     | <span class='unexecuted'>        if (_isPaused) {</span>
 577 |     | <span class='unexecuted'>            _requireProtocolOrOwner();</span>
 578 |     | <span class='neutral'>        } else {</span>
 579 |     | <span class='unexecuted'>            _requireTimelockOrOwner();</span>
 580 |     | <span class='neutral'>        }</span>
 581 |     | <span class='unexecuted'>        if (isRepayAccessControlRevoked) revert AccessControlRevoked();</span>
 582 |     | <span class='unexecuted'>        _pauseRepay(_isPaused);</span>
 583 |     | <span class='neutral'>    }</span>
 584 |     | <span class='neutral'></span>
 585 |     | <span class='neutral'>    /// @notice The ```revokeRepayAccessControl``` function revokes repay access control</span>
 586 |     | <span class='unexecuted'>    function revokeRepayAccessControl() external {</span>
 587 |     | <span class='unexecuted'>        _requireTimelock();</span>
 588 |     | <span class='unexecuted'>        _revokeRepayAccessControl();</span>
 589 |     | <span class='neutral'>    }</span>
 590 |     | <span class='neutral'></span>
 591 |     | <span class='neutral'>    /// @notice The ```pauseWithdraw``` function pauses withdraw functionality</span>
 592 |     | <span class='neutral'>    /// @param _isPaused The new pause state</span>
 593 |     | <span class='unexecuted'>    function pauseWithdraw(bool _isPaused) external {</span>
 594 |     | <span class='unexecuted'>        if (_isPaused) {</span>
 595 |     | <span class='unexecuted'>            _requireProtocolOrOwner();</span>
 596 |     | <span class='neutral'>        } else {</span>
 597 |     | <span class='unexecuted'>            _requireTimelockOrOwner();</span>
 598 |     | <span class='neutral'>        }</span>
 599 |     | <span class='unexecuted'>        if (isWithdrawAccessControlRevoked) revert AccessControlRevoked();</span>
 600 |     | <span class='unexecuted'>        _pauseWithdraw(_isPaused);</span>
 601 |     | <span class='neutral'>    }</span>
 602 |     | <span class='neutral'></span>
 603 |     | <span class='neutral'>    /// @notice The ```revokeWithdrawAccessControl``` function revokes withdraw access control</span>
 604 |     | <span class='unexecuted'>    function revokeWithdrawAccessControl() external {</span>
 605 |     | <span class='unexecuted'>        _requireTimelock();</span>
 606 |     | <span class='unexecuted'>        _revokeWithdrawAccessControl();</span>
 607 |     | <span class='neutral'>    }</span>
 608 |     | <span class='neutral'></span>
 609 |     | <span class='neutral'>    /// @notice The ```pauseLiquidate``` function pauses liquidate functionality</span>
 610 |     | <span class='neutral'>    /// @param _isPaused The new pause state</span>
 611 |     | <span class='unexecuted'>    function pauseLiquidate(bool _isPaused) external {</span>
 612 |     | <span class='unexecuted'>        if (_isPaused) {</span>
 613 |     | <span class='unexecuted'>            _requireProtocolOrOwner();</span>
 614 |     | <span class='neutral'>        } else {</span>
 615 |     | <span class='unexecuted'>            _requireTimelockOrOwner();</span>
 616 |     | <span class='neutral'>        }</span>
 617 |     | <span class='unexecuted'>        if (isLiquidateAccessControlRevoked) revert AccessControlRevoked();</span>
 618 |     | <span class='unexecuted'>        _pauseLiquidate(_isPaused);</span>
 619 |     | <span class='neutral'>    }</span>
 620 |     | <span class='neutral'></span>
 621 |     | <span class='neutral'>    /// @notice The ```revokeLiquidateAccessControl``` function revokes liquidate access control</span>
 622 |     | <span class='unexecuted'>    function revokeLiquidateAccessControl() external {</span>
 623 |     | <span class='unexecuted'>        _requireTimelock();</span>
 624 |     | <span class='unexecuted'>        _revokeLiquidateAccessControl();</span>
 625 |     | <span class='neutral'>    }</span>
 626 |     | <span class='neutral'></span>
 627 |     | <span class='neutral'>    /// @notice The ```pauseInterest``` function pauses interest functionality</span>
 628 |     | <span class='neutral'>    /// @param _isPaused The new pause state</span>
 629 |     | <span class='unexecuted'>    function pauseInterest(bool _isPaused) external {</span>
 630 |     | <span class='unexecuted'>        if (_isPaused) {</span>
 631 |     | <span class='unexecuted'>            _requireProtocolOrOwner();</span>
 632 |     | <span class='neutral'>        } else {</span>
 633 |     | <span class='unexecuted'>            _requireTimelockOrOwner();</span>
 634 |     | <span class='neutral'>        }</span>
 635 |     | <span class='unexecuted'>        if (isInterestAccessControlRevoked) revert AccessControlRevoked();</span>
 636 |     | <span class='neutral'>        // Resets the lastTimestamp which has the effect of no interest accruing over the pause period</span>
 637 |     | <span class='unexecuted'>        _addInterest();</span>
 638 |     | <span class='unexecuted'>        _pauseInterest(_isPaused);</span>
 639 |     | <span class='neutral'>    }</span>
 640 |     | <span class='neutral'></span>
 641 |     | <span class='neutral'>    /// @notice The ```revokeInterestAccessControl``` function revokes interest access control</span>
 642 |     | <span class='unexecuted'>    function revokeInterestAccessControl() external {</span>
 643 |     | <span class='unexecuted'>        _requireTimelock();</span>
 644 |     | <span class='unexecuted'>        _revokeInterestAccessControl();</span>
 645 |     | <span class='neutral'>    }</span>
 646 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairAccessControl.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ==================== FraxlendPairAccessControl =====================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>// ====================================================================</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>import { Ownable2Step, Ownable } from &quot;@openzeppelin/contracts/access/Ownable2Step.sol&quot;;</span>
  25 |     | <span class='neutral'>import { Timelock2Step } from &quot;./Timelock2Step.sol&quot;;</span>
  26 |     | <span class='neutral'>import { FraxlendPairAccessControlErrors } from &quot;./FraxlendPairAccessControlErrors.sol&quot;;</span>
  27 |     | <span class='neutral'>import { IERC4626Extended } from &#39;./interfaces/IERC4626Extended.sol&#39;;</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>/// @title FraxlendPairAccessControl</span>
  30 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
  31 |     | <span class='neutral'>/// @notice  An abstract contract which contains the access control logic for FraxlendPair</span>
  32 |     | <span class='neutral'>abstract contract FraxlendPairAccessControl is Timelock2Step, Ownable2Step, FraxlendPairAccessControlErrors {</span>
  33 |     | <span class='neutral'>    // Deployer</span>
  34 |     | <span class='unexecuted'>    address public immutable DEPLOYER_ADDRESS;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Admin contracts</span>
  37 |     | <span class='unexecuted'>    address public circuitBreakerAddress;</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    // External asset vault</span>
  40 |     | <span class='unexecuted'>    IERC4626Extended public externalAssetVault;</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    // access control</span>
  43 |     | <span class='unexecuted'>    uint256 public borrowLimit = type(uint256).max;</span>
  44 |     | <span class='unexecuted'>    bool public isBorrowAccessControlRevoked;</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='unexecuted'>    uint256 public depositLimit = type(uint256).max;</span>
  47 |     | <span class='unexecuted'>    bool public isDepositAccessControlRevoked;</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='unexecuted'>    bool public isRepayPaused;</span>
  50 |     | <span class='unexecuted'>    bool public isRepayAccessControlRevoked;</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='unexecuted'>    bool public isWithdrawPaused;</span>
  53 |     | <span class='unexecuted'>    bool public isWithdrawAccessControlRevoked;</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='unexecuted'>    bool public isLiquidatePaused;</span>
  56 |     | <span class='unexecuted'>    bool public isLiquidateAccessControlRevoked;</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='unexecuted'>    bool public isInterestPaused;</span>
  59 |     | <span class='unexecuted'>    bool public isInterestAccessControlRevoked;</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)</span>
  62 |     | <span class='neutral'>    constructor(bytes memory _immutables) Timelock2Step() Ownable2Step() {</span>
  63 |     | <span class='neutral'>        // Handle Immutables Configuration</span>
  64 |     | <span class='unexecuted'>        (address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress) = abi.decode(</span>
  65 |     | <span class='unexecuted'>            _immutables,</span>
  66 |     | <span class='neutral'>            (address, address, address)</span>
  67 |     | <span class='neutral'>        );</span>
  68 |     | <span class='unexecuted'>        _setTimelock(_timelockAddress);</span>
  69 |     | <span class='unexecuted'>        _transferOwnership(_comptrollerAddress);</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Deployer contract</span>
  72 |     | <span class='unexecuted'>        DEPLOYER_ADDRESS = msg.sender;</span>
  73 |     | <span class='unexecuted'>        circuitBreakerAddress = _circuitBreakerAddress;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    // ============================================================================================</span>
  77 |     | <span class='neutral'>    // Functions: Access Control</span>
  78 |     | <span class='neutral'>    // ============================================================================================</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function _requireProtocolOrOwner() internal view {</span>
  81 |     | <span class='unexecuted'>        if (</span>
  82 |     | <span class='unexecuted'>            msg.sender != circuitBreakerAddress &amp;&amp;</span>
  83 |     | <span class='unexecuted'>            msg.sender != owner() &amp;&amp;</span>
  84 |     | <span class='unexecuted'>            msg.sender != DEPLOYER_ADDRESS &amp;&amp;</span>
  85 |     | <span class='unexecuted'>            msg.sender != timelockAddress</span>
  86 |     | <span class='neutral'>        ) {</span>
  87 |     | <span class='unexecuted'>            revert OnlyProtocolOrOwner();</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='unexecuted'>    function _requireTimelockOrOwner() internal view {</span>
  92 |     | <span class='unexecuted'>        if (msg.sender != owner() &amp;&amp; msg.sender != timelockAddress) {</span>
  93 |     | <span class='unexecuted'>            revert OnlyTimelockOrOwner();</span>
  94 |     | <span class='neutral'>        }</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice The ```RevokeBorrowAccessControl``` event is emitted when access to borrow limit is revoked</span>
  98 |     | <span class='neutral'>    /// @param borrowLimit The final permanent borrow limit</span>
  99 |     | <span class='neutral'>    event RevokeBorrowAccessControl(uint256 borrowLimit);</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='unexecuted'>    function _revokeBorrowAccessControl(uint256 _borrowLimit) internal {</span>
 102 |     | <span class='unexecuted'>        isBorrowAccessControlRevoked = true;</span>
 103 |     | <span class='unexecuted'>        borrowLimit = _borrowLimit;</span>
 104 |     | <span class='unexecuted'>        emit RevokeBorrowAccessControl(_borrowLimit);</span>
 105 |     | <span class='neutral'>    }</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    /// @notice The ```SetBorrowLimit``` event is emitted when the borrow limit is set</span>
 108 |     | <span class='neutral'>    /// @param limit The new borrow limit</span>
 109 |     | <span class='neutral'>    event SetBorrowLimit(uint256 limit);</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='unexecuted'>    function _setBorrowLimit(uint256 _limit) internal {</span>
 112 |     | <span class='unexecuted'>        borrowLimit = _limit;</span>
 113 |     | <span class='unexecuted'>        emit SetBorrowLimit(_limit);</span>
 114 |     | <span class='neutral'>    }</span>
 115 |     | <span class='neutral'></span>
 116 |     | <span class='neutral'>    /// @notice The ```RevokeDepositAccessControl``` event is emitted when access to deposit limit is revoked</span>
 117 |     | <span class='neutral'>    /// @param depositLimit The final permanent deposit limit</span>
 118 |     | <span class='neutral'>    event RevokeDepositAccessControl(uint256 depositLimit);</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function _revokeDepositAccessControl(uint256 _depositLimit) internal {</span>
 121 |     | <span class='unexecuted'>        isDepositAccessControlRevoked = true;</span>
 122 |     | <span class='unexecuted'>        depositLimit = _depositLimit;</span>
 123 |     | <span class='unexecuted'>        emit RevokeDepositAccessControl(_depositLimit);</span>
 124 |     | <span class='neutral'>    }</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    /// @notice The ```SetDepositLimit``` event is emitted when the deposit limit is set</span>
 127 |     | <span class='neutral'>    /// @param limit The new deposit limit</span>
 128 |     | <span class='neutral'>    event SetDepositLimit(uint256 limit);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>    function _setDepositLimit(uint256 _limit) internal {</span>
 131 |     | <span class='unexecuted'>        depositLimit = _limit;</span>
 132 |     | <span class='unexecuted'>        emit SetDepositLimit(_limit);</span>
 133 |     | <span class='neutral'>    }</span>
 134 |     | <span class='neutral'></span>
 135 |     | <span class='neutral'>    /// @notice The ```RevokeRepayAccessControl``` event is emitted when repay access control is revoked</span>
 136 |     | <span class='neutral'>    event RevokeRepayAccessControl();</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='unexecuted'>    function _revokeRepayAccessControl() internal {</span>
 139 |     | <span class='unexecuted'>        isRepayAccessControlRevoked = true;</span>
 140 |     | <span class='unexecuted'>        emit RevokeRepayAccessControl();</span>
 141 |     | <span class='neutral'>    }</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='neutral'>    /// @notice The ```PauseRepay``` event is emitted when repay is paused or unpaused</span>
 144 |     | <span class='neutral'>    /// @param isPaused The new paused state</span>
 145 |     | <span class='neutral'>    event PauseRepay(bool isPaused);</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='unexecuted'>    function _pauseRepay(bool _isPaused) internal {</span>
 148 |     | <span class='unexecuted'>        isRepayPaused = _isPaused;</span>
 149 |     | <span class='unexecuted'>        emit PauseRepay(_isPaused);</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @notice The ```RevokeWithdrawAccessControl``` event is emitted when withdraw access control is revoked</span>
 153 |     | <span class='neutral'>    event RevokeWithdrawAccessControl();</span>
 154 |     | <span class='neutral'></span>
 155 |     | <span class='unexecuted'>    function _revokeWithdrawAccessControl() internal {</span>
 156 |     | <span class='unexecuted'>        isWithdrawAccessControlRevoked = true;</span>
 157 |     | <span class='unexecuted'>        emit RevokeWithdrawAccessControl();</span>
 158 |     | <span class='neutral'>    }</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    /// @notice The ```PauseWithdraw``` event is emitted when withdraw is paused or unpaused</span>
 161 |     | <span class='neutral'>    /// @param isPaused The new paused state</span>
 162 |     | <span class='neutral'>    event PauseWithdraw(bool isPaused);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='unexecuted'>    function _pauseWithdraw(bool _isPaused) internal {</span>
 165 |     | <span class='unexecuted'>        isWithdrawPaused = _isPaused;</span>
 166 |     | <span class='unexecuted'>        emit PauseWithdraw(_isPaused);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /// @notice The ```RevokeLiquidateAccessControl``` event is emitted when liquidate access control is revoked</span>
 170 |     | <span class='neutral'>    event RevokeLiquidateAccessControl();</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='unexecuted'>    function _revokeLiquidateAccessControl() internal {</span>
 173 |     | <span class='unexecuted'>        isLiquidateAccessControlRevoked = true;</span>
 174 |     | <span class='unexecuted'>        emit RevokeLiquidateAccessControl();</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    /// @notice The ```PauseLiquidate``` event is emitted when liquidate is paused or unpaused</span>
 178 |     | <span class='neutral'>    /// @param isPaused The new paused state</span>
 179 |     | <span class='neutral'>    event PauseLiquidate(bool isPaused);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>    function _pauseLiquidate(bool _isPaused) internal {</span>
 182 |     | <span class='unexecuted'>        isLiquidatePaused = _isPaused;</span>
 183 |     | <span class='unexecuted'>        emit PauseLiquidate(_isPaused);</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice The ```RevokeInterestAccessControl``` event is emitted when interest access control is revoked</span>
 187 |     | <span class='neutral'>    event RevokeInterestAccessControl();</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='unexecuted'>    function _revokeInterestAccessControl() internal {</span>
 190 |     | <span class='unexecuted'>        isInterestAccessControlRevoked = true;</span>
 191 |     | <span class='unexecuted'>        emit RevokeInterestAccessControl();</span>
 192 |     | <span class='neutral'>    }</span>
 193 |     | <span class='neutral'></span>
 194 |     | <span class='neutral'>    /// @notice The ```PauseInterest``` event is emitted when interest is paused or unpaused</span>
 195 |     | <span class='neutral'>    /// @param isPaused The new paused state</span>
 196 |     | <span class='neutral'>    event PauseInterest(bool isPaused);</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>    function _pauseInterest(bool _isPaused) internal {</span>
 199 |     | <span class='unexecuted'>        isInterestPaused = _isPaused;</span>
 200 |     | <span class='unexecuted'>        emit PauseInterest(_isPaused);</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    /// @notice The ```SetExternalAssetVault``` event is emitted when the external vault account is changed</span>
 204 |     | <span class='neutral'>    event SetExternalAssetVault(address oldVault, address newVault);</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='unexecuted'>    function _setExternalAssetVault(IERC4626Extended vault) internal {</span>
 207 |     | <span class='unexecuted'>        IERC4626Extended _oldVault = externalAssetVault;</span>
 208 |     | <span class='unexecuted'>        externalAssetVault = vault;</span>
 209 |     | <span class='unexecuted'>        emit SetExternalAssetVault(address(_oldVault), address(vault));</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='unexecuted'>    function setExternalAssetVault(IERC4626Extended vault) external {</span>
 213 |     | <span class='unexecuted'>        _requireTimelock();</span>
 214 |     | <span class='unexecuted'>        _setExternalAssetVault(vault);</span>
 215 |     | <span class='neutral'>    }</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    /// @notice The ```SetCircuitBreaker``` event is emitted when the circuit breaker address is set</span>
 218 |     | <span class='neutral'>    /// @param oldCircuitBreaker The old circuit breaker address</span>
 219 |     | <span class='neutral'>    /// @param newCircuitBreaker The new circuit breaker address</span>
 220 |     | <span class='neutral'>    event SetCircuitBreaker(address oldCircuitBreaker, address newCircuitBreaker);</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice The ```_setCircuitBreaker``` function is called to set the circuit breaker address</span>
 223 |     | <span class='neutral'>    /// @param _newCircuitBreaker The new circuit breaker address</span>
 224 |     | <span class='unexecuted'>    function _setCircuitBreaker(address _newCircuitBreaker) internal {</span>
 225 |     | <span class='unexecuted'>        address oldCircuitBreaker = circuitBreakerAddress;</span>
 226 |     | <span class='unexecuted'>        circuitBreakerAddress = _newCircuitBreaker;</span>
 227 |     | <span class='unexecuted'>        emit SetCircuitBreaker(oldCircuitBreaker, _newCircuitBreaker);</span>
 228 |     | <span class='neutral'>    }</span>
 229 |     | <span class='neutral'></span>
 230 |     | <span class='neutral'>    /// @notice The ```setCircuitBreaker``` function is called to set the circuit breaker address</span>
 231 |     | <span class='neutral'>    /// @param _newCircuitBreaker The new circuit breaker address</span>
 232 |     | <span class='unexecuted'>    function setCircuitBreaker(address _newCircuitBreaker) external virtual {</span>
 233 |     | <span class='unexecuted'>        _requireTimelock();</span>
 234 |     | <span class='unexecuted'>        _setCircuitBreaker(_newCircuitBreaker);</span>
 235 |     | <span class='neutral'>    }</span>
 236 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairAccessControlErrors.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// ====================================================================</span>
  5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
  6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
  7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
  8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
  9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
 10 |     | <span class='neutral'>// |                                                                  |</span>
 11 |     | <span class='neutral'>// ====================================================================</span>
 12 |     | <span class='neutral'>// ================ FraxlendPairAccessControlErrors ===================</span>
 13 |     | <span class='neutral'>// ====================================================================</span>
 14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>// Primary Author</span>
 17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// Reviewers</span>
 20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>// ====================================================================</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>/// @title FraxlendPairAccessControlErrors</span>
 25 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
 26 |     | <span class='neutral'>/// @notice  An abstract contract which contains the errors for the Access Control contract</span>
 27 |     | <span class='neutral'>abstract contract FraxlendPairAccessControlErrors {</span>
 28 |     | <span class='neutral'>    error OnlyProtocolOrOwner();</span>
 29 |     | <span class='neutral'>    error OnlyTimelockOrOwner();</span>
 30 |     | <span class='neutral'>    error ExceedsBorrowLimit();</span>
 31 |     | <span class='neutral'>    error AccessControlRevoked();</span>
 32 |     | <span class='neutral'>    error RepayPaused();</span>
 33 |     | <span class='neutral'>    error ExceedsDepositLimit();</span>
 34 |     | <span class='neutral'>    error WithdrawPaused();</span>
 35 |     | <span class='neutral'>    error LiquidatePaused();</span>
 36 |     | <span class='neutral'>    error InterestPaused();</span>
 37 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairConstants.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// ====================================================================</span>
  5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
  6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
  7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
  8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
  9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
 10 |     | <span class='neutral'>// |                                                                  |</span>
 11 |     | <span class='neutral'>// ====================================================================</span>
 12 |     | <span class='neutral'>// ===================== FraxlendPairConstants ========================</span>
 13 |     | <span class='neutral'>// ====================================================================</span>
 14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>// Primary Author</span>
 17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// Reviewers</span>
 20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
 21 |     | <span class='neutral'>// Sam Kazemian: https://github.com/samkazemian</span>
 22 |     | <span class='neutral'>// Travis Moore: https://github.com/FortisFortuna</span>
 23 |     | <span class='neutral'>// Jack Corddry: https://github.com/corddry</span>
 24 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// ====================================================================</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>/// @title FraxlendPairConstants</span>
 29 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
 30 |     | <span class='neutral'>/// @notice  An abstract contract which contains the errors and constants for the FraxlendPair contract</span>
 31 |     | <span class='neutral'>abstract contract FraxlendPairConstants {</span>
 32 |     | <span class='neutral'>    // ============================================================================================</span>
 33 |     | <span class='neutral'>    // Constants</span>
 34 |     | <span class='neutral'>    // ============================================================================================</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    // Precision settings</span>
 37 |     | <span class='unexecuted'>    uint256 public constant LTV_PRECISION = 1e5; // 5 decimals</span>
 38 |     | <span class='unexecuted'>    uint256 public constant LIQ_PRECISION = 1e5;</span>
 39 |     | <span class='unexecuted'>    uint256 public constant UTIL_PREC = 1e5;</span>
 40 |     | <span class='unexecuted'>    uint256 public constant FEE_PRECISION = 1e5;</span>
 41 |     | <span class='unexecuted'>    uint256 public constant EXCHANGE_PRECISION = 1e18;</span>
 42 |     | <span class='unexecuted'>    uint256 public constant DEVIATION_PRECISION = 1e5;</span>
 43 |     | <span class='unexecuted'>    uint256 public constant RATE_PRECISION = 1e18;</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    // Protocol Fee</span>
 46 |     | <span class='unexecuted'>    uint256 public constant MAX_PROTOCOL_FEE = 5e4; // 50% 1e5 precision</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    error Insolvent(uint256 _borrow, uint256 _collateral, uint256 _exchangeRate);</span>
 49 |     | <span class='neutral'>    error BorrowerSolvent();</span>
 50 |     | <span class='neutral'>    error InsufficientAssetsInContract(uint256 _assets, uint256 _request);</span>
 51 |     | <span class='neutral'>    error SlippageTooHigh(uint256 _minOut, uint256 _actual);</span>
 52 |     | <span class='neutral'>    error BadSwapper();</span>
 53 |     | <span class='neutral'>    error InvalidPath(address _expected, address _actual);</span>
 54 |     | <span class='neutral'>    error BadProtocolFee();</span>
 55 |     | <span class='neutral'>    error PastDeadline(uint256 _blockTimestamp, uint256 _deadline);</span>
 56 |     | <span class='neutral'>    error SetterRevoked();</span>
 57 |     | <span class='neutral'>    error ExceedsMaxOracleDeviation();</span>
 58 |     | <span class='neutral'>    error InvalidReceiver();</span>
 59 |     | <span class='neutral'>    error ExternalAssetVaultOnly();</span>
 60 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairCore.sol</b>
<code>
    1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
    2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
    3 |     | <span class='neutral'></span>
    4 |     | <span class='neutral'>// ====================================================================</span>
    5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
    6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
    7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
    8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
    9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
   10 |     | <span class='neutral'>// |                                                                  |</span>
   11 |     | <span class='neutral'>// ====================================================================</span>
   12 |     | <span class='neutral'>// ========================= FraxlendPairCore =========================</span>
   13 |     | <span class='neutral'>// ====================================================================</span>
   14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
   15 |     | <span class='neutral'></span>
   16 |     | <span class='neutral'>// Primary Author</span>
   17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
   18 |     | <span class='neutral'></span>
   19 |     | <span class='neutral'>// Reviewers</span>
   20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
   21 |     | <span class='neutral'>// Sam Kazemian: https://github.com/samkazemian</span>
   22 |     | <span class='neutral'>// Travis Moore: https://github.com/FortisFortuna</span>
   23 |     | <span class='neutral'>// Jack Corddry: https://github.com/corddry</span>
   24 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
   25 |     | <span class='neutral'></span>
   26 |     | <span class='neutral'>// ====================================================================</span>
   27 |     | <span class='neutral'></span>
   28 |     | <span class='neutral'>import { ERC20 } from &quot;@openzeppelin/contracts/token/ERC20/ERC20.sol&quot;;</span>
   29 |     | <span class='neutral'>import { IERC20 } from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
   30 |     | <span class='neutral'>import { ReentrancyGuard } from &quot;@openzeppelin/contracts/security/ReentrancyGuard.sol&quot;;</span>
   31 |     | <span class='neutral'>import { SafeCast } from &quot;@openzeppelin/contracts/utils/math/SafeCast.sol&quot;;</span>
   32 |     | <span class='neutral'>import { FraxlendPairAccessControl } from &quot;./FraxlendPairAccessControl.sol&quot;;</span>
   33 |     | <span class='neutral'>import { FraxlendPairConstants } from &quot;./FraxlendPairConstants.sol&quot;;</span>
   34 |     | <span class='neutral'>import { VaultAccount, VaultAccountingLibrary } from &quot;./libraries/VaultAccount.sol&quot;;</span>
   35 |     | <span class='neutral'>import { SafeERC20 } from &quot;./libraries/SafeERC20.sol&quot;;</span>
   36 |     | <span class='neutral'>import { IDualOracle } from &quot;./interfaces/IDualOracle.sol&quot;;</span>
   37 |     | <span class='neutral'>import { IRateCalculatorV2 } from &quot;./interfaces/IRateCalculatorV2.sol&quot;;</span>
   38 |     | <span class='neutral'>import { ISwapper } from &quot;./interfaces/ISwapper.sol&quot;;</span>
   39 |     | <span class='neutral'></span>
   40 |     | <span class='neutral'>/// @title FraxlendPairCore</span>
   41 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
   42 |     | <span class='neutral'>/// @notice  An abstract contract which contains the core logic and storage for the FraxlendPair</span>
   43 |     | <span class='neutral'>abstract contract FraxlendPairCore is FraxlendPairAccessControl, FraxlendPairConstants, ERC20, ReentrancyGuard {</span>
   44 |     | <span class='neutral'>    using VaultAccountingLibrary for VaultAccount;</span>
   45 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
   46 |     | <span class='neutral'>    using SafeCast for uint256;</span>
   47 |     | <span class='neutral'></span>
   48 |     | <span class='unexecuted'>    function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {</span>
   49 |     | <span class='unexecuted'>        _major = 3;</span>
   50 |     | <span class='neutral'>        _minor = 0;</span>
   51 |     | <span class='neutral'>        _patch = 0;</span>
   52 |     | <span class='neutral'>    }</span>
   53 |     | <span class='neutral'></span>
   54 |     | <span class='neutral'>    // ============================================================================================</span>
   55 |     | <span class='neutral'>    // Settings set by constructor()</span>
   56 |     | <span class='neutral'>    // ============================================================================================</span>
   57 |     | <span class='neutral'></span>
   58 |     | <span class='neutral'>    // Asset and collateral contracts</span>
   59 |     | <span class='neutral'>    IERC20 internal immutable assetContract;</span>
   60 |     | <span class='unexecuted'>    IERC20 public immutable collateralContract;</span>
   61 |     | <span class='neutral'></span>
   62 |     | <span class='neutral'>    // LTV Settings</span>
   63 |     | <span class='neutral'>    /// @notice The maximum LTV allowed for this pair</span>
   64 |     | <span class='neutral'>    /// @dev 1e5 precision</span>
   65 |     | <span class='unexecuted'>    uint256 public maxLTV;</span>
   66 |     | <span class='neutral'></span>
   67 |     | <span class='neutral'>    // Liquidation Fees</span>
   68 |     | <span class='neutral'>    /// @notice The liquidation fee, given as a % of repayment amount, when all collateral is consumed in liquidation</span>
   69 |     | <span class='neutral'>    /// @dev 1e5 precision</span>
   70 |     | <span class='unexecuted'>    uint256 public cleanLiquidationFee;</span>
   71 |     | <span class='neutral'>    /// @notice The liquidation fee, given as % of repayment amount, when some collateral remains for borrower</span>
   72 |     | <span class='neutral'>    /// @dev 1e5 precision</span>
   73 |     | <span class='unexecuted'>    uint256 public dirtyLiquidationFee;</span>
   74 |     | <span class='neutral'>    /// @notice The portion of the liquidation fee given to protocol</span>
   75 |     | <span class='neutral'>    /// @dev 1e5 precision</span>
   76 |     | <span class='unexecuted'>    uint256 public protocolLiquidationFee;</span>
   77 |     | <span class='neutral'></span>
   78 |     | <span class='neutral'>    // Interest Rate Calculator Contract</span>
   79 |     | <span class='unexecuted'>    IRateCalculatorV2 public rateContract; // For complex rate calculations</span>
   80 |     | <span class='neutral'></span>
   81 |     | <span class='neutral'>    // Swapper</span>
   82 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public swappers; // approved swapper addresses</span>
   83 |     | <span class='neutral'></span>
   84 |     | <span class='neutral'>    // ERC20 Metadata</span>
   85 |     | <span class='neutral'>    string internal nameOfContract;</span>
   86 |     | <span class='neutral'>    string internal symbolOfContract;</span>
   87 |     | <span class='neutral'>    uint8 internal immutable decimalsOfContract;</span>
   88 |     | <span class='neutral'></span>
   89 |     | <span class='neutral'>    // ============================================================================================</span>
   90 |     | <span class='neutral'>    // Storage</span>
   91 |     | <span class='neutral'>    // ============================================================================================</span>
   92 |     | <span class='neutral'></span>
   93 |     | <span class='neutral'>    /// @notice Stores information about the current interest rate</span>
   94 |     | <span class='neutral'>    /// @dev struct is packed to reduce SLOADs. feeToProtocolRate is 1e5 precision, ratePerSec &amp; fullUtilizationRate is 1e18 precision</span>
   95 |     | <span class='unexecuted'>    CurrentRateInfo public currentRateInfo;</span>
   96 |     | <span class='neutral'></span>
   97 |     | <span class='neutral'>    struct CurrentRateInfo {</span>
   98 |     | <span class='neutral'>        uint32 lastBlock;</span>
   99 |     | <span class='neutral'>        uint32 feeToProtocolRate; // Fee amount 1e5 precision</span>
  100 |     | <span class='neutral'>        uint64 lastTimestamp;</span>
  101 |     | <span class='neutral'>        uint64 ratePerSec;</span>
  102 |     | <span class='neutral'>        uint64 fullUtilizationRate;</span>
  103 |     | <span class='neutral'>    }</span>
  104 |     | <span class='neutral'></span>
  105 |     | <span class='neutral'>    /// @notice Stores information about the current exchange rate. Collateral:Asset ratio</span>
  106 |     | <span class='neutral'>    /// @dev Struct packed to save SLOADs. Amount of Collateral Token to buy 1e18 Asset Token</span>
  107 |     | <span class='unexecuted'>    ExchangeRateInfo public exchangeRateInfo;</span>
  108 |     | <span class='neutral'></span>
  109 |     | <span class='neutral'>    struct ExchangeRateInfo {</span>
  110 |     | <span class='neutral'>        address oracle;</span>
  111 |     | <span class='neutral'>        uint32 maxOracleDeviation; // % of larger number, 1e5 precision</span>
  112 |     | <span class='neutral'>        uint184 lastTimestamp;</span>
  113 |     | <span class='neutral'>        uint256 lowExchangeRate;</span>
  114 |     | <span class='neutral'>        uint256 highExchangeRate;</span>
  115 |     | <span class='neutral'>    }</span>
  116 |     | <span class='neutral'></span>
  117 |     | <span class='neutral'>    // Contract Level Accounting</span>
  118 |     | <span class='unexecuted'>    VaultAccount public totalAsset; // amount = total amount of assets, shares = total shares outstanding</span>
  119 |     | <span class='unexecuted'>    VaultAccount public totalBorrow; // amount = total borrow amount with interest accrued, shares = total shares outstanding</span>
  120 |     | <span class='unexecuted'>    uint256 public totalCollateral; // total amount of collateral in contract</span>
  121 |     | <span class='neutral'></span>
  122 |     | <span class='neutral'>    // User Level Accounting</span>
  123 |     | <span class='neutral'>    /// @notice Stores the balance of collateral for each user</span>
  124 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userCollateralBalance; // amount of collateral each user is backed</span>
  125 |     | <span class='neutral'>    /// @notice Stores the balance of borrow shares for each user</span>
  126 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public userBorrowShares; // represents the shares held by individuals</span>
  127 |     | <span class='neutral'></span>
  128 |     | <span class='neutral'>    // NOTE: user shares of assets are represented as ERC-20 tokens and accessible via balanceOf()</span>
  129 |     | <span class='neutral'></span>
  130 |     | <span class='neutral'>    // ============================================================================================</span>
  131 |     | <span class='neutral'>    // Constructor</span>
  132 |     | <span class='neutral'>    // ============================================================================================</span>
  133 |     | <span class='neutral'></span>
  134 |     | <span class='neutral'>    /// @notice The ```constructor``` function is called on deployment</span>
  135 |     | <span class='neutral'>    /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)</span>
  136 |     | <span class='neutral'>    /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)</span>
  137 |     | <span class='neutral'>    /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)</span>
  138 |     | <span class='unexecuted'>    constructor(</span>
  139 |     | <span class='neutral'>        bytes memory _configData,</span>
  140 |     | <span class='neutral'>        bytes memory _immutables,</span>
  141 |     | <span class='neutral'>        bytes memory _customConfigData</span>
  142 |     | <span class='neutral'>    ) FraxlendPairAccessControl(_immutables) ERC20(&quot;&quot;, &quot;&quot;) {</span>
  143 |     | <span class='neutral'>        {</span>
  144 |     | <span class='unexecuted'>            (</span>
  145 |     | <span class='unexecuted'>                address _asset,</span>
  146 |     | <span class='unexecuted'>                address _collateral,</span>
  147 |     | <span class='unexecuted'>                address _oracle,</span>
  148 |     | <span class='unexecuted'>                uint32 _maxOracleDeviation,</span>
  149 |     | <span class='unexecuted'>                address _rateContract,</span>
  150 |     | <span class='unexecuted'>                uint64 _fullUtilizationRate,</span>
  151 |     | <span class='unexecuted'>                uint256 _maxLTV,</span>
  152 |     | <span class='unexecuted'>                uint256 _liquidationFee,</span>
  153 |     | <span class='unexecuted'>                uint256 _protocolLiquidationFee</span>
  154 |     | <span class='unexecuted'>            ) = abi.decode(</span>
  155 |     | <span class='unexecuted'>                    _configData,</span>
  156 |     | <span class='neutral'>                    (address, address, address, uint32, address, uint64, uint256, uint256, uint256)</span>
  157 |     | <span class='neutral'>                );</span>
  158 |     | <span class='neutral'></span>
  159 |     | <span class='neutral'>            // Pair Settings</span>
  160 |     | <span class='unexecuted'>            assetContract = IERC20(_asset);</span>
  161 |     | <span class='unexecuted'>            collateralContract = IERC20(_collateral);</span>
  162 |     | <span class='neutral'></span>
  163 |     | <span class='unexecuted'>            currentRateInfo.feeToProtocolRate = 0;</span>
  164 |     | <span class='unexecuted'>            currentRateInfo.fullUtilizationRate = _fullUtilizationRate;</span>
  165 |     | <span class='unexecuted'>            currentRateInfo.lastTimestamp = uint64(block.timestamp - 1);</span>
  166 |     | <span class='unexecuted'>            currentRateInfo.lastBlock = uint32(block.number - 1);</span>
  167 |     | <span class='neutral'></span>
  168 |     | <span class='unexecuted'>            exchangeRateInfo.oracle = _oracle;</span>
  169 |     | <span class='unexecuted'>            exchangeRateInfo.maxOracleDeviation = _maxOracleDeviation;</span>
  170 |     | <span class='neutral'></span>
  171 |     | <span class='unexecuted'>            rateContract = IRateCalculatorV2(_rateContract);</span>
  172 |     | <span class='neutral'></span>
  173 |     | <span class='neutral'>            //Liquidation Fee Settings</span>
  174 |     | <span class='unexecuted'>            cleanLiquidationFee = _liquidationFee;</span>
  175 |     | <span class='unexecuted'>            dirtyLiquidationFee = (_liquidationFee * 90_000) / LIQ_PRECISION; // 90% of clean fee</span>
  176 |     | <span class='unexecuted'>            protocolLiquidationFee = _protocolLiquidationFee;</span>
  177 |     | <span class='neutral'></span>
  178 |     | <span class='neutral'>            // set maxLTV</span>
  179 |     | <span class='unexecuted'>            maxLTV = _maxLTV;</span>
  180 |     | <span class='neutral'>        }</span>
  181 |     | <span class='neutral'></span>
  182 |     | <span class='unexecuted'>        {</span>
  183 |     | <span class='unexecuted'>            (string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract) = abi.decode(</span>
  184 |     | <span class='neutral'>                _customConfigData,</span>
  185 |     | <span class='neutral'>                (string, string, uint8)</span>
  186 |     | <span class='neutral'>            );</span>
  187 |     | <span class='neutral'></span>
  188 |     | <span class='neutral'>            // ERC20 Metadata</span>
  189 |     | <span class='unexecuted'>            nameOfContract = _nameOfContract;</span>
  190 |     | <span class='unexecuted'>            symbolOfContract = _symbolOfContract;</span>
  191 |     | <span class='unexecuted'>            decimalsOfContract = _decimalsOfContract;</span>
  192 |     | <span class='neutral'></span>
  193 |     | <span class='neutral'>            // Instantiate Interest</span>
  194 |     | <span class='unexecuted'>            _addInterest();</span>
  195 |     | <span class='neutral'>            // Instantiate Exchange Rate</span>
  196 |     | <span class='unexecuted'>            _updateExchangeRate();</span>
  197 |     | <span class='neutral'>        }</span>
  198 |     | <span class='neutral'>    }</span>
  199 |     | <span class='neutral'></span>
  200 |     | <span class='neutral'>    // ============================================================================================</span>
  201 |     | <span class='neutral'>    // Internal Helpers</span>
  202 |     | <span class='neutral'>    // ============================================================================================</span>
  203 |     | <span class='neutral'></span>
  204 |     | <span class='neutral'>    /// @notice The ```_totalAssetAvailable``` function returns the total balance of Asset Tokens in the contract</span>
  205 |     | <span class='neutral'>    /// @param _totalAsset VaultAccount struct which stores total amount and shares for assets</span>
  206 |     | <span class='neutral'>    /// @param _totalBorrow VaultAccount struct which stores total amount and shares for borrows</span>
  207 |     | <span class='neutral'>    /// @return The balance of Asset Tokens held by contract</span>
  208 |     | <span class='unexecuted'>    function _totalAssetAvailable(</span>
  209 |     | <span class='neutral'>        VaultAccount memory _totalAsset,</span>
  210 |     | <span class='neutral'>        VaultAccount memory _totalBorrow,</span>
  211 |     | <span class='neutral'>        bool _includeVault</span>
  212 |     | <span class='unexecuted'>    ) internal view returns (uint256) {</span>
  213 |     | <span class='unexecuted'>        if (_includeVault) {</span>
  214 |     | <span class='unexecuted'>            return _totalAsset.totalAmount(address(externalAssetVault)) - _totalBorrow.amount;</span>
  215 |     | <span class='neutral'>        }</span>
  216 |     | <span class='unexecuted'>        return _totalAsset.amount - _totalBorrow.amount;</span>
  217 |     | <span class='neutral'>    }</span>
  218 |     | <span class='neutral'></span>
  219 |     | <span class='neutral'>    /// @notice The ```_isSolvent``` function determines if a given borrower is solvent given an exchange rate</span>
  220 |     | <span class='neutral'>    /// @param _borrower The borrower address to check</span>
  221 |     | <span class='neutral'>    /// @param _exchangeRate The exchange rate, i.e. the amount of collateral to buy 1e18 asset</span>
  222 |     | <span class='neutral'>    /// @return Whether borrower is solvent</span>
  223 |     | <span class='unexecuted'>    function _isSolvent(address _borrower, uint256 _exchangeRate) internal view returns (bool) {</span>
  224 |     | <span class='unexecuted'>        if (maxLTV == 0) return true;</span>
  225 |     | <span class='unexecuted'>        uint256 _borrowerAmount = totalBorrow.toAmount(userBorrowShares[_borrower], true);</span>
  226 |     | <span class='unexecuted'>        if (_borrowerAmount == 0) return true;</span>
  227 |     | <span class='unexecuted'>        uint256 _collateralAmount = userCollateralBalance[_borrower];</span>
  228 |     | <span class='unexecuted'>        if (_collateralAmount == 0) return false;</span>
  229 |     | <span class='neutral'></span>
  230 |     | <span class='unexecuted'>        uint256 _ltv = (((_borrowerAmount * _exchangeRate) / EXCHANGE_PRECISION) * LTV_PRECISION) / _collateralAmount;</span>
  231 |     | <span class='unexecuted'>        return _ltv &lt;= maxLTV;</span>
  232 |     | <span class='neutral'>    }</span>
  233 |     | <span class='neutral'></span>
  234 |     | <span class='neutral'>    // ============================================================================================</span>
  235 |     | <span class='neutral'>    // Modifiers</span>
  236 |     | <span class='neutral'>    // ============================================================================================</span>
  237 |     | <span class='neutral'></span>
  238 |     | <span class='neutral'>    /// @notice Checks for solvency AFTER executing contract code</span>
  239 |     | <span class='neutral'>    /// @param _borrower The borrower whose solvency we will check</span>
  240 |     | <span class='unexecuted'>    modifier isSolvent(address _borrower) {</span>
  241 |     | <span class='neutral'>        _;</span>
  242 |     | <span class='unexecuted'>        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;</span>
  243 |     | <span class='neutral'></span>
  244 |     | <span class='unexecuted'>        if (!_isSolvent(_borrower, exchangeRateInfo.highExchangeRate)) {</span>
  245 |     | <span class='unexecuted'>            revert Insolvent(</span>
  246 |     | <span class='unexecuted'>                totalBorrow.toAmount(userBorrowShares[_borrower], true),</span>
  247 |     | <span class='unexecuted'>                userCollateralBalance[_borrower],</span>
  248 |     | <span class='unexecuted'>                exchangeRateInfo.highExchangeRate</span>
  249 |     | <span class='neutral'>            );</span>
  250 |     | <span class='neutral'>        }</span>
  251 |     | <span class='neutral'>    }</span>
  252 |     | <span class='neutral'></span>
  253 |     | <span class='neutral'>    // ============================================================================================</span>
  254 |     | <span class='neutral'>    // Functions: Interest Accumulation and Adjustment</span>
  255 |     | <span class='neutral'>    // ============================================================================================</span>
  256 |     | <span class='neutral'></span>
  257 |     | <span class='neutral'>    /// @notice The ```AddInterest``` event is emitted when interest is accrued by borrowers</span>
  258 |     | <span class='neutral'>    /// @param interestEarned The total interest accrued by all borrowers</span>
  259 |     | <span class='neutral'>    /// @param rate The interest rate used to calculate accrued interest</span>
  260 |     | <span class='neutral'>    /// @param feesAmount The amount of fees paid to protocol</span>
  261 |     | <span class='neutral'>    /// @param feesShare The amount of shares distributed to protocol</span>
  262 |     | <span class='neutral'>    event AddInterest(uint256 interestEarned, uint256 rate, uint256 feesAmount, uint256 feesShare);</span>
  263 |     | <span class='neutral'></span>
  264 |     | <span class='neutral'>    /// @notice The ```UpdateRate``` event is emitted when the interest rate is updated</span>
  265 |     | <span class='neutral'>    /// @param oldRatePerSec The old interest rate (per second)</span>
  266 |     | <span class='neutral'>    /// @param oldFullUtilizationRate The old full utilization rate</span>
  267 |     | <span class='neutral'>    /// @param newRatePerSec The new interest rate (per second)</span>
  268 |     | <span class='neutral'>    /// @param newFullUtilizationRate The new full utilization rate</span>
  269 |     | <span class='neutral'>    event UpdateRate(</span>
  270 |     | <span class='neutral'>        uint256 oldRatePerSec,</span>
  271 |     | <span class='neutral'>        uint256 oldFullUtilizationRate,</span>
  272 |     | <span class='neutral'>        uint256 newRatePerSec,</span>
  273 |     | <span class='neutral'>        uint256 newFullUtilizationRate</span>
  274 |     | <span class='neutral'>    );</span>
  275 |     | <span class='neutral'></span>
  276 |     | <span class='neutral'>    /// @notice The ```addInterest``` function is a public implementation of _addInterest and allows 3rd parties to trigger interest accrual</span>
  277 |     | <span class='neutral'>    /// @return _interestEarned The amount of interest accrued by all borrowers</span>
  278 |     | <span class='neutral'>    /// @return _feesAmount The amount of fees paid to protocol</span>
  279 |     | <span class='neutral'>    /// @return _feesShare The amount of shares distributed to protocol</span>
  280 |     | <span class='neutral'>    /// @return _currentRateInfo The new rate info struct</span>
  281 |     | <span class='neutral'>    /// @return _totalAsset The new total asset struct</span>
  282 |     | <span class='neutral'>    /// @return _totalBorrow The new total borrow struct</span>
  283 |     | <span class='unexecuted'>    function addInterest(</span>
  284 |     | <span class='neutral'>        bool _returnAccounting</span>
  285 |     | <span class='neutral'>    )</span>
  286 |     | <span class='neutral'>        external</span>
  287 |     | <span class='neutral'>        nonReentrant</span>
  288 |     | <span class='neutral'>        returns (</span>
  289 |     | <span class='unexecuted'>            uint256 _interestEarned,</span>
  290 |     | <span class='neutral'>            uint256 _feesAmount,</span>
  291 |     | <span class='neutral'>            uint256 _feesShare,</span>
  292 |     | <span class='neutral'>            CurrentRateInfo memory _currentRateInfo,</span>
  293 |     | <span class='neutral'>            VaultAccount memory _totalAsset,</span>
  294 |     | <span class='neutral'>            VaultAccount memory _totalBorrow</span>
  295 |     | <span class='neutral'>        )</span>
  296 |     | <span class='neutral'>    {</span>
  297 |     | <span class='unexecuted'>        (, _interestEarned, _feesAmount, _feesShare, _currentRateInfo) = _addInterest();</span>
  298 |     | <span class='unexecuted'>        if (_returnAccounting) {</span>
  299 |     | <span class='unexecuted'>            _totalAsset = totalAsset;</span>
  300 |     | <span class='unexecuted'>            _totalBorrow = totalBorrow;</span>
  301 |     | <span class='neutral'>        }</span>
  302 |     | <span class='neutral'>    }</span>
  303 |     | <span class='neutral'></span>
  304 |     | <span class='neutral'>    /// @notice The ```previewAddInterest``` function</span>
  305 |     | <span class='neutral'>    /// @return _interestEarned The amount of interest accrued by all borrowers</span>
  306 |     | <span class='neutral'>    /// @return _feesAmount The amount of fees paid to protocol</span>
  307 |     | <span class='neutral'>    /// @return _feesShare The amount of shares distributed to protocol</span>
  308 |     | <span class='neutral'>    /// @return _newCurrentRateInfo The new rate info struct</span>
  309 |     | <span class='neutral'>    /// @return _totalAsset The new total asset struct</span>
  310 |     | <span class='neutral'>    /// @return _totalBorrow The new total borrow struct</span>
  311 |     | <span class='unexecuted'>    function previewAddInterest()</span>
  312 |     | <span class='neutral'>        public</span>
  313 |     | <span class='neutral'>        view</span>
  314 |     | <span class='neutral'>        returns (</span>
  315 |     | <span class='unexecuted'>            uint256 _interestEarned,</span>
  316 |     | <span class='neutral'>            uint256 _feesAmount,</span>
  317 |     | <span class='neutral'>            uint256 _feesShare,</span>
  318 |     | <span class='neutral'>            CurrentRateInfo memory _newCurrentRateInfo,</span>
  319 |     | <span class='neutral'>            VaultAccount memory _totalAsset,</span>
  320 |     | <span class='neutral'>            VaultAccount memory _totalBorrow</span>
  321 |     | <span class='neutral'>        )</span>
  322 |     | <span class='unexecuted'>    {</span>
  323 |     | <span class='unexecuted'>        _newCurrentRateInfo = currentRateInfo;</span>
  324 |     | <span class='neutral'>        // Write return values</span>
  325 |     | <span class='unexecuted'>        InterestCalculationResults memory _results = _calculateInterest(_newCurrentRateInfo);</span>
  326 |     | <span class='neutral'></span>
  327 |     | <span class='unexecuted'>        if (_results.isInterestUpdated) {</span>
  328 |     | <span class='unexecuted'>            _interestEarned = _results.interestEarned;</span>
  329 |     | <span class='unexecuted'>            _feesAmount = _results.feesAmount;</span>
  330 |     | <span class='unexecuted'>            _feesShare = _results.feesShare;</span>
  331 |     | <span class='neutral'></span>
  332 |     | <span class='unexecuted'>            _newCurrentRateInfo.ratePerSec = _results.newRate;</span>
  333 |     | <span class='unexecuted'>            _newCurrentRateInfo.fullUtilizationRate = _results.newFullUtilizationRate;</span>
  334 |     | <span class='neutral'></span>
  335 |     | <span class='unexecuted'>            _totalAsset = _results.totalAsset;</span>
  336 |     | <span class='unexecuted'>            _totalBorrow = _results.totalBorrow;</span>
  337 |     | <span class='neutral'>        } else {</span>
  338 |     | <span class='unexecuted'>            _totalAsset = totalAsset;</span>
  339 |     | <span class='unexecuted'>            _totalBorrow = totalBorrow;</span>
  340 |     | <span class='neutral'>        }</span>
  341 |     | <span class='neutral'>    }</span>
  342 |     | <span class='neutral'></span>
  343 |     | <span class='neutral'>    struct InterestCalculationResults {</span>
  344 |     | <span class='neutral'>        bool isInterestUpdated;</span>
  345 |     | <span class='neutral'>        uint64 newRate;</span>
  346 |     | <span class='neutral'>        uint64 newFullUtilizationRate;</span>
  347 |     | <span class='neutral'>        uint256 interestEarned;</span>
  348 |     | <span class='neutral'>        uint256 feesAmount;</span>
  349 |     | <span class='neutral'>        uint256 feesShare;</span>
  350 |     | <span class='neutral'>        VaultAccount totalAsset;</span>
  351 |     | <span class='neutral'>        VaultAccount totalBorrow;</span>
  352 |     | <span class='neutral'>    }</span>
  353 |     | <span class='neutral'></span>
  354 |     | <span class='neutral'>    /// @notice The ```_calculateInterest``` function calculates the interest to be accrued and the new interest rate info</span>
  355 |     | <span class='neutral'>    /// @param _currentRateInfo The current rate info</span>
  356 |     | <span class='neutral'>    /// @return _results The results of the interest calculation</span>
  357 |     | <span class='unexecuted'>    function _calculateInterest(</span>
  358 |     | <span class='neutral'>        CurrentRateInfo memory _currentRateInfo</span>
  359 |     | <span class='unexecuted'>    ) internal view returns (InterestCalculationResults memory _results) {</span>
  360 |     | <span class='neutral'>        // Short circuit if interest already calculated this block OR if interest is paused</span>
  361 |     | <span class='unexecuted'>        if (_currentRateInfo.lastTimestamp != block.timestamp &amp;&amp; !isInterestPaused) {</span>
  362 |     | <span class='neutral'>            // Indicate that interest is updated and calculated</span>
  363 |     | <span class='unexecuted'>            _results.isInterestUpdated = true;</span>
  364 |     | <span class='neutral'></span>
  365 |     | <span class='neutral'>            // Write return values and use these to save gas</span>
  366 |     | <span class='unexecuted'>            _results.totalAsset = totalAsset;</span>
  367 |     | <span class='unexecuted'>            _results.totalBorrow = totalBorrow;</span>
  368 |     | <span class='neutral'></span>
  369 |     | <span class='neutral'>            // Time elapsed since last interest update</span>
  370 |     | <span class='unexecuted'>            uint256 _deltaTime = block.timestamp - _currentRateInfo.lastTimestamp;</span>
  371 |     | <span class='neutral'></span>
  372 |     | <span class='neutral'>            // Total assets available including what resides in the external vault</span>
  373 |     | <span class='unexecuted'>            uint256 _totalAssetsAvailable = _results.totalAsset.totalAmount(address(externalAssetVault));</span>
  374 |     | <span class='neutral'></span>
  375 |     | <span class='neutral'>            // Get the utilization rate</span>
  376 |     | <span class='unexecuted'>            uint256 _utilizationRate = _totalAssetsAvailable == 0</span>
  377 |     | <span class='unexecuted'>                ? 0</span>
  378 |     | <span class='unexecuted'>                : (UTIL_PREC * _results.totalBorrow.amount) / _totalAssetsAvailable;</span>
  379 |     | <span class='neutral'></span>
  380 |     | <span class='neutral'>            // Request new interest rate and full utilization rate from the rate calculator</span>
  381 |     | <span class='unexecuted'>            (_results.newRate, _results.newFullUtilizationRate) = IRateCalculatorV2(rateContract).getNewRate(</span>
  382 |     | <span class='neutral'>                _deltaTime,</span>
  383 |     | <span class='neutral'>                _utilizationRate,</span>
  384 |     | <span class='unexecuted'>                _currentRateInfo.fullUtilizationRate</span>
  385 |     | <span class='neutral'>            );</span>
  386 |     | <span class='neutral'></span>
  387 |     | <span class='neutral'>            // Calculate interest accrued</span>
  388 |     | <span class='unexecuted'>            _results.interestEarned = (_deltaTime * _results.totalBorrow.amount * _results.newRate) / RATE_PRECISION;</span>
  389 |     | <span class='neutral'></span>
  390 |     | <span class='neutral'>            // Accrue interest (if any) and fees iff no overflow</span>
  391 |     | <span class='unexecuted'>            if (</span>
  392 |     | <span class='unexecuted'>                _results.interestEarned &gt; 0 &amp;&amp;</span>
  393 |     | <span class='unexecuted'>                _results.interestEarned + _results.totalBorrow.amount &lt;= type(uint128).max &amp;&amp;</span>
  394 |     | <span class='unexecuted'>                _results.interestEarned + _totalAssetsAvailable &lt;= type(uint128).max</span>
  395 |     | <span class='neutral'>            ) {</span>
  396 |     | <span class='neutral'>                // Increment totalBorrow and totalAsset by interestEarned</span>
  397 |     | <span class='unexecuted'>                _results.totalBorrow.amount += _results.interestEarned.toUint128();</span>
  398 |     | <span class='unexecuted'>                _results.totalAsset.amount += _results.interestEarned.toUint128();</span>
  399 |     | <span class='unexecuted'>                if (_currentRateInfo.feeToProtocolRate &gt; 0) {</span>
  400 |     | <span class='unexecuted'>                    _results.feesAmount =</span>
  401 |     | <span class='unexecuted'>                        (_results.interestEarned * _currentRateInfo.feeToProtocolRate) /</span>
  402 |     | <span class='neutral'>                        FEE_PRECISION;</span>
  403 |     | <span class='neutral'></span>
  404 |     | <span class='unexecuted'>                    _results.feesShare =</span>
  405 |     | <span class='unexecuted'>                        (_results.feesAmount * _results.totalAsset.shares) /</span>
  406 |     | <span class='unexecuted'>                        (_results.totalAsset.totalAmount(address(0)) - _results.feesAmount);</span>
  407 |     | <span class='neutral'></span>
  408 |     | <span class='neutral'>                    // Effects: Give new shares to this contract, effectively diluting lenders an amount equal to the fees</span>
  409 |     | <span class='neutral'>                    // We can safely cast because _feesShare &lt; _feesAmount &lt; interestEarned which is always less than uint128</span>
  410 |     | <span class='unexecuted'>                    _results.totalAsset.shares += _results.feesShare.toUint128();</span>
  411 |     | <span class='neutral'>                }</span>
  412 |     | <span class='neutral'>            }</span>
  413 |     | <span class='neutral'>        }</span>
  414 |     | <span class='neutral'>    }</span>
  415 |     | <span class='neutral'></span>
  416 |     | <span class='neutral'>    /// @notice The ```_addInterest``` function is invoked prior to every external function and is used to accrue interest and update interest rate</span>
  417 |     | <span class='neutral'>    /// @dev Can only called once per block</span>
  418 |     | <span class='neutral'>    /// @return _isInterestUpdated True if interest was calculated</span>
  419 |     | <span class='neutral'>    /// @return _interestEarned The amount of interest accrued by all borrowers</span>
  420 |     | <span class='neutral'>    /// @return _feesAmount The amount of fees paid to protocol</span>
  421 |     | <span class='neutral'>    /// @return _feesShare The amount of shares distributed to protocol</span>
  422 |     | <span class='neutral'>    /// @return _currentRateInfo The new rate info struct</span>
  423 |     | <span class='unexecuted'>    function _addInterest()</span>
  424 |     | <span class='neutral'>        internal</span>
  425 |     | <span class='neutral'>        returns (</span>
  426 |     | <span class='unexecuted'>            bool _isInterestUpdated,</span>
  427 |     | <span class='unexecuted'>            uint256 _interestEarned,</span>
  428 |     | <span class='unexecuted'>            uint256 _feesAmount,</span>
  429 |     | <span class='unexecuted'>            uint256 _feesShare,</span>
  430 |     | <span class='unexecuted'>            CurrentRateInfo memory _currentRateInfo</span>
  431 |     | <span class='neutral'>        )</span>
  432 |     | <span class='unexecuted'>    {</span>
  433 |     | <span class='neutral'>        // Pull from storage and set default return values</span>
  434 |     | <span class='unexecuted'>        _currentRateInfo = currentRateInfo;</span>
  435 |     | <span class='neutral'></span>
  436 |     | <span class='neutral'>        // Calc interest</span>
  437 |     | <span class='unexecuted'>        InterestCalculationResults memory _results = _calculateInterest(_currentRateInfo);</span>
  438 |     | <span class='neutral'></span>
  439 |     | <span class='neutral'>        // Write return values only if interest was updated and calculated</span>
  440 |     | <span class='unexecuted'>        if (_results.isInterestUpdated) {</span>
  441 |     | <span class='unexecuted'>            _isInterestUpdated = _results.isInterestUpdated;</span>
  442 |     | <span class='unexecuted'>            _interestEarned = _results.interestEarned;</span>
  443 |     | <span class='unexecuted'>            _feesAmount = _results.feesAmount;</span>
  444 |     | <span class='unexecuted'>            _feesShare = _results.feesShare;</span>
  445 |     | <span class='neutral'></span>
  446 |     | <span class='neutral'>            // emit here so that we have access to the old values</span>
  447 |     | <span class='unexecuted'>            emit UpdateRate(</span>
  448 |     | <span class='unexecuted'>                _currentRateInfo.ratePerSec,</span>
  449 |     | <span class='unexecuted'>                _currentRateInfo.fullUtilizationRate,</span>
  450 |     | <span class='unexecuted'>                _results.newRate,</span>
  451 |     | <span class='unexecuted'>                _results.newFullUtilizationRate</span>
  452 |     | <span class='neutral'>            );</span>
  453 |     | <span class='unexecuted'>            emit AddInterest(_interestEarned, _results.newRate, _feesAmount, _feesShare);</span>
  454 |     | <span class='neutral'></span>
  455 |     | <span class='neutral'>            // overwrite original values</span>
  456 |     | <span class='unexecuted'>            _currentRateInfo.ratePerSec = _results.newRate;</span>
  457 |     | <span class='unexecuted'>            _currentRateInfo.fullUtilizationRate = _results.newFullUtilizationRate;</span>
  458 |     | <span class='unexecuted'>            _currentRateInfo.lastTimestamp = uint64(block.timestamp);</span>
  459 |     | <span class='unexecuted'>            _currentRateInfo.lastBlock = uint32(block.number);</span>
  460 |     | <span class='neutral'></span>
  461 |     | <span class='neutral'>            // Effects: write to state</span>
  462 |     | <span class='unexecuted'>            currentRateInfo = _currentRateInfo;</span>
  463 |     | <span class='unexecuted'>            totalAsset = _results.totalAsset;</span>
  464 |     | <span class='unexecuted'>            totalBorrow = _results.totalBorrow;</span>
  465 |     | <span class='unexecuted'>            if (_feesShare &gt; 0) _mint(address(this), _feesShare);</span>
  466 |     | <span class='neutral'>        }</span>
  467 |     | <span class='neutral'>    }</span>
  468 |     | <span class='neutral'></span>
  469 |     | <span class='neutral'>    // ============================================================================================</span>
  470 |     | <span class='neutral'>    // Functions: ExchangeRate</span>
  471 |     | <span class='neutral'>    // ============================================================================================</span>
  472 |     | <span class='neutral'></span>
  473 |     | <span class='neutral'>    /// @notice The ```UpdateExchangeRate``` event is emitted when the Collateral:Asset exchange rate is updated</span>
  474 |     | <span class='neutral'>    /// @param lowExchangeRate The low exchange rate</span>
  475 |     | <span class='neutral'>    /// @param highExchangeRate The high exchange rate</span>
  476 |     | <span class='neutral'>    event UpdateExchangeRate(uint256 lowExchangeRate, uint256 highExchangeRate);</span>
  477 |     | <span class='neutral'></span>
  478 |     | <span class='neutral'>    /// @notice The ```WarnOracleData``` event is emitted when one of the oracles has stale or otherwise problematic data</span>
  479 |     | <span class='neutral'>    /// @param oracle The oracle address</span>
  480 |     | <span class='neutral'>    event WarnOracleData(address oracle);</span>
  481 |     | <span class='neutral'></span>
  482 |     | <span class='neutral'>    /// @notice The ```updateExchangeRate``` function is the external implementation of _updateExchangeRate.</span>
  483 |     | <span class='neutral'>    /// @dev This function is invoked at most once per block as these queries can be expensive</span>
  484 |     | <span class='neutral'>    /// @return _isBorrowAllowed True if deviation is within bounds</span>
  485 |     | <span class='neutral'>    /// @return _lowExchangeRate The low exchange rate</span>
  486 |     | <span class='neutral'>    /// @return _highExchangeRate The high exchange rate</span>
  487 |     | <span class='unexecuted'>    function updateExchangeRate()</span>
  488 |     | <span class='neutral'>        external</span>
  489 |     | <span class='neutral'>        nonReentrant</span>
  490 |     | <span class='unexecuted'>        returns (bool _isBorrowAllowed, uint256 _lowExchangeRate, uint256 _highExchangeRate)</span>
  491 |     | <span class='neutral'>    {</span>
  492 |     | <span class='unexecuted'>        return _updateExchangeRate();</span>
  493 |     | <span class='neutral'>    }</span>
  494 |     | <span class='neutral'></span>
  495 |     | <span class='neutral'>    /// @notice The ```_updateExchangeRate``` function retrieves the latest exchange rate. i.e how much collateral to buy 1e18 asset.</span>
  496 |     | <span class='neutral'>    /// @dev This function is invoked at most once per block as these queries can be expensive</span>
  497 |     | <span class='neutral'>    /// @return _isBorrowAllowed True if deviation is within bounds</span>
  498 |     | <span class='neutral'>    /// @return _lowExchangeRate The low exchange rate</span>
  499 |     | <span class='neutral'>    /// @return _highExchangeRate The high exchange rate</span>
  500 |     | <span class='neutral'></span>
  501 |     | <span class='unexecuted'>    function _updateExchangeRate()</span>
  502 |     | <span class='neutral'>        internal</span>
  503 |     | <span class='neutral'>        returns (bool _isBorrowAllowed, uint256 _lowExchangeRate, uint256 _highExchangeRate)</span>
  504 |     | <span class='unexecuted'>    {</span>
  505 |     | <span class='neutral'>        // Pull from storage to save gas and set default return values</span>
  506 |     | <span class='unexecuted'>        ExchangeRateInfo memory _exchangeRateInfo = exchangeRateInfo;</span>
  507 |     | <span class='neutral'></span>
  508 |     | <span class='neutral'>        // Short circuit if already updated this block</span>
  509 |     | <span class='unexecuted'>        if (_exchangeRateInfo.lastTimestamp != block.timestamp) {</span>
  510 |     | <span class='neutral'>            // Get the latest exchange rate from the dual oracle</span>
  511 |     | <span class='unexecuted'>            bool _oneOracleBad;</span>
  512 |     | <span class='unexecuted'>            (_oneOracleBad, _lowExchangeRate, _highExchangeRate) = IDualOracle(_exchangeRateInfo.oracle).getPrices();</span>
  513 |     | <span class='neutral'></span>
  514 |     | <span class='neutral'>            // If one oracle is bad data, emit an event for off-chain monitoring</span>
  515 |     | <span class='unexecuted'>            if (_oneOracleBad) emit WarnOracleData(_exchangeRateInfo.oracle);</span>
  516 |     | <span class='neutral'></span>
  517 |     | <span class='neutral'>            // Effects: Bookkeeping and write to storage</span>
  518 |     | <span class='unexecuted'>            _exchangeRateInfo.lastTimestamp = uint184(block.timestamp);</span>
  519 |     | <span class='unexecuted'>            _exchangeRateInfo.lowExchangeRate = _lowExchangeRate;</span>
  520 |     | <span class='unexecuted'>            _exchangeRateInfo.highExchangeRate = _highExchangeRate;</span>
  521 |     | <span class='unexecuted'>            exchangeRateInfo = _exchangeRateInfo;</span>
  522 |     | <span class='unexecuted'>            emit UpdateExchangeRate(_lowExchangeRate, _highExchangeRate);</span>
  523 |     | <span class='neutral'>        } else {</span>
  524 |     | <span class='neutral'>            // Use default return values if already updated this block</span>
  525 |     | <span class='unexecuted'>            _lowExchangeRate = _exchangeRateInfo.lowExchangeRate;</span>
  526 |     | <span class='unexecuted'>            _highExchangeRate = _exchangeRateInfo.highExchangeRate;</span>
  527 |     | <span class='neutral'>        }</span>
  528 |     | <span class='neutral'></span>
  529 |     | <span class='unexecuted'>        uint256 _deviation = (DEVIATION_PRECISION *</span>
  530 |     | <span class='unexecuted'>            (_exchangeRateInfo.highExchangeRate - _exchangeRateInfo.lowExchangeRate)) /</span>
  531 |     | <span class='unexecuted'>            _exchangeRateInfo.highExchangeRate;</span>
  532 |     | <span class='unexecuted'>        if (_deviation &lt;= _exchangeRateInfo.maxOracleDeviation) {</span>
  533 |     | <span class='unexecuted'>            _isBorrowAllowed = true;</span>
  534 |     | <span class='neutral'>        }</span>
  535 |     | <span class='neutral'>    }</span>
  536 |     | <span class='neutral'></span>
  537 |     | <span class='neutral'>    // ============================================================================================</span>
  538 |     | <span class='neutral'>    // Functions: Lending</span>
  539 |     | <span class='neutral'>    // ============================================================================================</span>
  540 |     | <span class='neutral'></span>
  541 |     | <span class='neutral'>    /// @notice The ```Deposit``` event fires when a user deposits assets to the pair</span>
  542 |     | <span class='neutral'>    /// @param caller the msg.sender</span>
  543 |     | <span class='neutral'>    /// @param owner the account the fTokens are sent to</span>
  544 |     | <span class='neutral'>    /// @param assets the amount of assets deposited</span>
  545 |     | <span class='neutral'>    /// @param shares the number of fTokens minted</span>
  546 |     | <span class='neutral'>    event Deposit(address indexed caller, address indexed owner, uint256 assets, uint256 shares);</span>
  547 |     | <span class='neutral'></span>
  548 |     | <span class='neutral'>    /// @notice The ```_deposit``` function is the internal implementation for lending assets</span>
  549 |     | <span class='neutral'>    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function</span>
  550 |     | <span class='neutral'>    /// @param _totalAsset An in memory VaultAccount struct representing the total amounts and shares for the Asset Token</span>
  551 |     | <span class='neutral'>    /// @param _amount The amount of Asset Token to be transferred</span>
  552 |     | <span class='neutral'>    /// @param _shares The amount of Asset Shares (fTokens) to be minted</span>
  553 |     | <span class='neutral'>    /// @param _receiver The address to receive the Asset Shares (fTokens)</span>
  554 |     | <span class='neutral'>    /// @param _shouldTransfer Whether asset tokens should be deposited from the sender</span>
  555 |     | <span class='unexecuted'>    function _deposit(VaultAccount memory _totalAsset, uint128 _amount, uint128 _shares, address _receiver, bool _shouldTransfer) internal {</span>
  556 |     | <span class='neutral'>        // Effects: bookkeeping</span>
  557 |     | <span class='unexecuted'>        _totalAsset.amount += _amount;</span>
  558 |     | <span class='unexecuted'>        _totalAsset.shares += _shares;</span>
  559 |     | <span class='neutral'></span>
  560 |     | <span class='neutral'>        // Effects: write back to storage</span>
  561 |     | <span class='unexecuted'>        _mint(_receiver, _shares);</span>
  562 |     | <span class='unexecuted'>        totalAsset = _totalAsset;</span>
  563 |     | <span class='neutral'></span>
  564 |     | <span class='neutral'>        // Interactions</span>
  565 |     | <span class='unexecuted'>        if (_shouldTransfer) {</span>
  566 |     | <span class='unexecuted'>            assetContract.safeTransferFrom(msg.sender, address(this), _amount);</span>
  567 |     | <span class='neutral'>        }</span>
  568 |     | <span class='unexecuted'>        emit Deposit(msg.sender, _receiver, _amount, _shares);</span>
  569 |     | <span class='neutral'>    }</span>
  570 |     | <span class='neutral'></span>
  571 |     | <span class='unexecuted'>    function previewDeposit(uint256 _assets) external view returns (uint256 _sharesReceived) {</span>
  572 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
  573 |     | <span class='unexecuted'>        _sharesReceived = _totalAsset.toShares(_assets, false);</span>
  574 |     | <span class='neutral'>    }</span>
  575 |     | <span class='neutral'></span>
  576 |     | <span class='neutral'>    /// @notice The ```deposit``` function allows a user to Lend Assets by specifying the amount of Asset Tokens to lend</span>
  577 |     | <span class='neutral'>    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function</span>
  578 |     | <span class='neutral'>    /// @param _amount The amount of Asset Token to transfer to Pair</span>
  579 |     | <span class='neutral'>    /// @param _receiver The address to receive the Asset Shares (fTokens)</span>
  580 |     | <span class='neutral'>    /// @return _sharesReceived The number of fTokens received for the deposit</span>
  581 |     | <span class='unexecuted'>    function deposit(uint256 _amount, address _receiver) external nonReentrant returns (uint256 _sharesReceived) {</span>
  582 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  583 |     | <span class='neutral'></span>
  584 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  585 |     | <span class='unexecuted'>        _addInterest();</span>
  586 |     | <span class='neutral'></span>
  587 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  588 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  589 |     | <span class='neutral'></span>
  590 |     | <span class='neutral'>        // Check if this deposit will violate the deposit limit</span>
  591 |     | <span class='unexecuted'>        if (depositLimit &lt; _totalAsset.totalAmount(address(externalAssetVault)) + _amount) revert ExceedsDepositLimit();</span>
  592 |     | <span class='neutral'></span>
  593 |     | <span class='neutral'>        // Calculate the number of fTokens to mint</span>
  594 |     | <span class='unexecuted'>        _sharesReceived = _totalAsset.toShares(_amount, false);</span>
  595 |     | <span class='neutral'></span>
  596 |     | <span class='neutral'>        // Execute the deposit effects</span>
  597 |     | <span class='unexecuted'>        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), _receiver, true);</span>
  598 |     | <span class='neutral'>    }</span>
  599 |     | <span class='neutral'></span>
  600 |     | <span class='neutral'>    /// @notice The ```_depositFromVault``` function deposits assets here from the configured external vault if available</span>
  601 |     | <span class='neutral'>    /// @param _amount The amount of Asset Tokens to be transferred from the vault</span>
  602 |     | <span class='neutral'>    /// @return _sharesReceived The number of Asset Shares (fTokens) to mint for Asset Tokens</span>
  603 |     | <span class='unexecuted'>    function _depositFromVault(uint256 _amount) internal returns (uint256 _sharesReceived) {</span>
  604 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  605 |     | <span class='unexecuted'>        _addInterest();</span>
  606 |     | <span class='neutral'></span>
  607 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  608 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  609 |     | <span class='neutral'></span>
  610 |     | <span class='neutral'>        // Check if this deposit will violate the deposit limit</span>
  611 |     | <span class='unexecuted'>        if (depositLimit &lt; _totalAsset.totalAmount(address(externalAssetVault))) revert ExceedsDepositLimit();</span>
  612 |     | <span class='neutral'></span>
  613 |     | <span class='neutral'>        // Calculate the number of fTokens to mint</span>
  614 |     | <span class='unexecuted'>        _sharesReceived = _totalAsset.toShares(_amount, false);</span>
  615 |     | <span class='neutral'></span>
  616 |     | <span class='neutral'>        // Withdraw assets from external vault here</span>
  617 |     | <span class='unexecuted'>        externalAssetVault.whitelistWithdraw(_amount);</span>
  618 |     | <span class='neutral'></span>
  619 |     | <span class='neutral'>        // Execute the deposit effects</span>
  620 |     | <span class='unexecuted'>        _deposit(_totalAsset, _amount.toUint128(), _sharesReceived.toUint128(), address(externalAssetVault), false);</span>
  621 |     | <span class='neutral'>    }</span>
  622 |     | <span class='neutral'></span>
  623 |     | <span class='neutral'>    /// @notice The ```_withdrawToVault``` function withdraws assets back to an external vault if previously used</span>
  624 |     | <span class='neutral'>    /// @param _amountToReturn The amount of Asset Tokens to be transferred to the vault</span>
  625 |     | <span class='neutral'>    /// @return _shares The number of Asset Shares (fTokens) to burn for Asset Tokens</span>
  626 |     | <span class='unexecuted'>    function _withdrawToVault(uint256 _amountToReturn) internal returns (uint256 _shares) {</span>
  627 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  628 |     | <span class='unexecuted'>        _addInterest();</span>
  629 |     | <span class='neutral'></span>
  630 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  631 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  632 |     | <span class='neutral'></span>
  633 |     | <span class='neutral'>        // Calculate the number of shares to burn based on the assets to transfer</span>
  634 |     | <span class='unexecuted'>        _shares = _totalAsset.toShares(_amountToReturn, true);</span>
  635 |     | <span class='neutral'></span>
  636 |     | <span class='neutral'>        // Execute the withdraw effects for vault</span>
  637 |     | <span class='neutral'>        // receive assets here in order to call whitelistDeposit and handle accounting in external vault</span>
  638 |     | <span class='unexecuted'>        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), address(this), address(externalAssetVault), true);</span>
  639 |     | <span class='neutral'></span>
  640 |     | <span class='neutral'>        // Deposit assets to external vault</span>
  641 |     | <span class='unexecuted'>        assetContract.approve(address(externalAssetVault), _amountToReturn);</span>
  642 |     | <span class='unexecuted'>        externalAssetVault.whitelistDeposit(_amountToReturn);</span>
  643 |     | <span class='neutral'>    }</span>
  644 |     | <span class='neutral'></span>
  645 |     | <span class='neutral'>    function previewMint(uint256 _shares) external view returns (uint256 _amount) {</span>
  646 |     | <span class='neutral'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
  647 |     | <span class='neutral'>        _amount = _totalAsset.toAmount(_shares, false);</span>
  648 |     | <span class='neutral'>    }</span>
  649 |     | <span class='neutral'></span>
  650 |     | <span class='unexecuted'>    function mint(uint256 _shares, address _receiver) external nonReentrant returns (uint256 _amount) {</span>
  651 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  652 |     | <span class='neutral'></span>
  653 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  654 |     | <span class='unexecuted'>        _addInterest();</span>
  655 |     | <span class='neutral'></span>
  656 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  657 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  658 |     | <span class='neutral'></span>
  659 |     | <span class='neutral'>        // Calculate the number of assets to transfer based on the shares to mint</span>
  660 |     | <span class='unexecuted'>        _amount = _totalAsset.toAmount(_shares, false);</span>
  661 |     | <span class='neutral'></span>
  662 |     | <span class='neutral'>        // Check if this deposit will violate the deposit limit</span>
  663 |     | <span class='unexecuted'>        if (depositLimit &lt; _totalAsset.totalAmount(address(externalAssetVault)) + _amount) revert ExceedsDepositLimit();</span>
  664 |     | <span class='neutral'></span>
  665 |     | <span class='neutral'>        // Execute the deposit effects</span>
  666 |     | <span class='unexecuted'>        _deposit(_totalAsset, _amount.toUint128(), _shares.toUint128(), _receiver, true);</span>
  667 |     | <span class='neutral'>    }</span>
  668 |     | <span class='neutral'></span>
  669 |     | <span class='neutral'>    /// @notice The ```Withdraw``` event fires when a user redeems their fTokens for the underlying asset</span>
  670 |     | <span class='neutral'>    /// @param caller the msg.sender</span>
  671 |     | <span class='neutral'>    /// @param receiver The address to which the underlying asset will be transferred to</span>
  672 |     | <span class='neutral'>    /// @param owner The owner of the fTokens</span>
  673 |     | <span class='neutral'>    /// @param assets The assets transferred</span>
  674 |     | <span class='neutral'>    /// @param shares The number of fTokens burned</span>
  675 |     | <span class='neutral'>    event Withdraw(</span>
  676 |     | <span class='neutral'>        address indexed caller,</span>
  677 |     | <span class='neutral'>        address indexed receiver,</span>
  678 |     | <span class='neutral'>        address indexed owner,</span>
  679 |     | <span class='neutral'>        uint256 assets,</span>
  680 |     | <span class='neutral'>        uint256 shares</span>
  681 |     | <span class='neutral'>    );</span>
  682 |     | <span class='neutral'></span>
  683 |     | <span class='neutral'>    /// @notice The ```_redeem``` function is an internal implementation which allows a Lender to pull their Asset Tokens out of the Pair</span>
  684 |     | <span class='neutral'>    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling function</span>
  685 |     | <span class='neutral'>    /// @param _totalAsset An in-memory VaultAccount struct which holds the total amount of Asset Tokens and the total number of Asset Shares (fTokens)</span>
  686 |     | <span class='neutral'>    /// @param _amountToReturn The number of Asset Tokens to return</span>
  687 |     | <span class='neutral'>    /// @param _shares The number of Asset Shares (fTokens) to burn</span>
  688 |     | <span class='neutral'>    /// @param _receiver The address to which the Asset Tokens will be transferred</span>
  689 |     | <span class='neutral'>    /// @param _owner The owner of the Asset Shares (fTokens)</span>
  690 |     | <span class='unexecuted'>    function _redeem(</span>
  691 |     | <span class='neutral'>        VaultAccount memory _totalAsset,</span>
  692 |     | <span class='neutral'>        uint128 _amountToReturn,</span>
  693 |     | <span class='neutral'>        uint128 _shares,</span>
  694 |     | <span class='neutral'>        address _receiver,</span>
  695 |     | <span class='neutral'>        address _owner,</span>
  696 |     | <span class='neutral'>        bool _skipAllowanceCheck</span>
  697 |     | <span class='unexecuted'>    ) internal {</span>
  698 |     | <span class='neutral'>        // Check for sufficient allowance/approval if necessary</span>
  699 |     | <span class='unexecuted'>        if (msg.sender != _owner &amp;&amp; !_skipAllowanceCheck) {</span>
  700 |     | <span class='unexecuted'>            uint256 allowed = allowance(_owner, msg.sender);</span>
  701 |     | <span class='neutral'>            // NOTE: This will revert on underflow ensuring that allowance &gt; shares</span>
  702 |     | <span class='unexecuted'>            if (allowed != type(uint256).max) _approve(_owner, msg.sender, allowed - _shares);</span>
  703 |     | <span class='neutral'>        }</span>
  704 |     | <span class='neutral'></span>
  705 |     | <span class='neutral'>        // Check for sufficient withdraw liquidity (not strictly necessary because balance will underflow)</span>
  706 |     | <span class='unexecuted'>        uint256 _totAssetsAvailable = _totalAssetAvailable(_totalAsset, totalBorrow, true);</span>
  707 |     | <span class='unexecuted'>        if (_totAssetsAvailable &lt; _amountToReturn) {</span>
  708 |     | <span class='unexecuted'>            revert InsufficientAssetsInContract(_totAssetsAvailable, _amountToReturn);</span>
  709 |     | <span class='neutral'>        }</span>
  710 |     | <span class='neutral'></span>
  711 |     | <span class='neutral'>        // If we&#39;re redeeming back to the vault, don&#39;t deposit from the vault</span>
  712 |     | <span class='unexecuted'>        if (_owner != address(externalAssetVault)) {</span>
  713 |     | <span class='unexecuted'>            uint256 _localAssetsAvailable= _totalAssetAvailable(_totalAsset, totalBorrow, false);</span>
  714 |     | <span class='unexecuted'>            if (_localAssetsAvailable &lt; _amountToReturn) {</span>
  715 |     | <span class='unexecuted'>                uint256 _vaultAmt = _amountToReturn - _localAssetsAvailable;</span>
  716 |     | <span class='unexecuted'>                _depositFromVault(_vaultAmt);</span>
  717 |     | <span class='neutral'></span>
  718 |     | <span class='neutral'>                // Rewrite to memory, now it&#39;s the latest value!</span>
  719 |     | <span class='unexecuted'>                _totalAsset = totalAsset;</span>
  720 |     | <span class='neutral'>            }</span>
  721 |     | <span class='neutral'>        }</span>
  722 |     | <span class='neutral'></span>
  723 |     | <span class='neutral'>        // Effects: bookkeeping</span>
  724 |     | <span class='unexecuted'>        _totalAsset.amount -= _amountToReturn;</span>
  725 |     | <span class='unexecuted'>        _totalAsset.shares -= _shares;</span>
  726 |     | <span class='neutral'></span>
  727 |     | <span class='neutral'>        // Effects: write to storage</span>
  728 |     | <span class='unexecuted'>        totalAsset = _totalAsset;</span>
  729 |     | <span class='unexecuted'>        _burn(_owner, _shares);</span>
  730 |     | <span class='neutral'></span>
  731 |     | <span class='neutral'>        // Interactions</span>
  732 |     | <span class='unexecuted'>        assetContract.safeTransfer(_receiver, _amountToReturn);</span>
  733 |     | <span class='unexecuted'>        emit Withdraw(msg.sender, _receiver, _owner, _amountToReturn, _shares);</span>
  734 |     | <span class='neutral'>    }</span>
  735 |     | <span class='neutral'></span>
  736 |     | <span class='unexecuted'>    function previewRedeem(uint256 _shares) external view returns (uint256 _assets) {</span>
  737 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
  738 |     | <span class='unexecuted'>        _assets = _totalAsset.toAmount(_shares, false);</span>
  739 |     | <span class='neutral'>    }</span>
  740 |     | <span class='neutral'></span>
  741 |     | <span class='neutral'>    /// @notice The ```redeem``` function allows the caller to redeem their Asset Shares for Asset Tokens</span>
  742 |     | <span class='neutral'>    /// @param _shares The number of Asset Shares (fTokens) to burn for Asset Tokens</span>
  743 |     | <span class='neutral'>    /// @param _receiver The address to which the Asset Tokens will be transferred</span>
  744 |     | <span class='neutral'>    /// @param _owner The owner of the Asset Shares (fTokens)</span>
  745 |     | <span class='neutral'>    /// @return _amountToReturn The amount of Asset Tokens to be transferred</span>
  746 |     | <span class='unexecuted'>    function redeem(</span>
  747 |     | <span class='neutral'>        uint256 _shares,</span>
  748 |     | <span class='neutral'>        address _receiver,</span>
  749 |     | <span class='neutral'>        address _owner</span>
  750 |     | <span class='unexecuted'>    ) external nonReentrant returns (uint256 _amountToReturn) {</span>
  751 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  752 |     | <span class='neutral'></span>
  753 |     | <span class='neutral'>        // Check if withdraw is paused and revert if necessary</span>
  754 |     | <span class='unexecuted'>        if (isWithdrawPaused) revert WithdrawPaused();</span>
  755 |     | <span class='neutral'></span>
  756 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  757 |     | <span class='unexecuted'>        _addInterest();</span>
  758 |     | <span class='neutral'></span>
  759 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  760 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  761 |     | <span class='neutral'></span>
  762 |     | <span class='neutral'>        // Calculate the number of assets to transfer based on the shares to burn</span>
  763 |     | <span class='unexecuted'>        _amountToReturn = _totalAsset.toAmount(_shares, false);</span>
  764 |     | <span class='neutral'></span>
  765 |     | <span class='neutral'>        // Execute the withdraw effects</span>
  766 |     | <span class='unexecuted'>        _redeem(_totalAsset, _amountToReturn.toUint128(), _shares.toUint128(), _receiver, _owner, false);</span>
  767 |     | <span class='neutral'>    }</span>
  768 |     | <span class='neutral'></span>
  769 |     | <span class='neutral'>    /// @notice The ```previewWithdraw``` function returns the number of Asset Shares (fTokens) that would be burned for a given amount of Asset Tokens</span>
  770 |     | <span class='neutral'>    /// @param _amount The amount of Asset Tokens to be withdrawn</span>
  771 |     | <span class='neutral'>    /// @return _sharesToBurn The number of shares that would be burned</span>
  772 |     | <span class='unexecuted'>    function previewWithdraw(uint256 _amount) external view returns (uint256 _sharesToBurn) {</span>
  773 |     | <span class='unexecuted'>        (, , , , VaultAccount memory _totalAsset, ) = previewAddInterest();</span>
  774 |     | <span class='unexecuted'>        _sharesToBurn = _totalAsset.toShares(_amount, true);</span>
  775 |     | <span class='neutral'>    }</span>
  776 |     | <span class='neutral'></span>
  777 |     | <span class='neutral'>    /// @notice The ```withdraw``` function allows the caller to withdraw their Asset Tokens for a given amount of fTokens</span>
  778 |     | <span class='neutral'>    /// @param _amount The amount to withdraw</span>
  779 |     | <span class='neutral'>    /// @param _receiver The address to which the Asset Tokens will be transferred</span>
  780 |     | <span class='neutral'>    /// @param _owner The owner of the Asset Shares (fTokens)</span>
  781 |     | <span class='neutral'>    /// @return _sharesToBurn The number of shares (fTokens) that were burned</span>
  782 |     | <span class='unexecuted'>    function withdraw(</span>
  783 |     | <span class='neutral'>        uint256 _amount,</span>
  784 |     | <span class='neutral'>        address _receiver,</span>
  785 |     | <span class='neutral'>        address _owner</span>
  786 |     | <span class='unexecuted'>    ) external nonReentrant returns (uint256 _sharesToBurn) {</span>
  787 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  788 |     | <span class='neutral'></span>
  789 |     | <span class='neutral'>        // Check if withdraw is paused and revert if necessary</span>
  790 |     | <span class='unexecuted'>        if (isWithdrawPaused) revert WithdrawPaused();</span>
  791 |     | <span class='neutral'></span>
  792 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  793 |     | <span class='unexecuted'>        _addInterest();</span>
  794 |     | <span class='neutral'></span>
  795 |     | <span class='neutral'>        // Pull from storage to save gas</span>
  796 |     | <span class='unexecuted'>        VaultAccount memory _totalAsset = totalAsset;</span>
  797 |     | <span class='neutral'></span>
  798 |     | <span class='neutral'>        // Calculate the number of shares to burn based on the amount to withdraw</span>
  799 |     | <span class='unexecuted'>        _sharesToBurn = _totalAsset.toShares(_amount, true);</span>
  800 |     | <span class='neutral'></span>
  801 |     | <span class='neutral'>        // Execute the withdraw effects</span>
  802 |     | <span class='unexecuted'>        _redeem(_totalAsset, _amount.toUint128(), _sharesToBurn.toUint128(), _receiver, _owner, false);</span>
  803 |     | <span class='neutral'>    }</span>
  804 |     | <span class='neutral'></span>
  805 |     | <span class='neutral'>    // ============================================================================================</span>
  806 |     | <span class='neutral'>    // Functions: Borrowing</span>
  807 |     | <span class='neutral'>    // ============================================================================================</span>
  808 |     | <span class='neutral'></span>
  809 |     | <span class='neutral'>    /// @notice The ```BorrowAsset``` event is emitted when a borrower increases their position</span>
  810 |     | <span class='neutral'>    /// @param _borrower The borrower whose account was debited</span>
  811 |     | <span class='neutral'>    /// @param _receiver The address to which the Asset Tokens were transferred</span>
  812 |     | <span class='neutral'>    /// @param _borrowAmount The amount of Asset Tokens transferred</span>
  813 |     | <span class='neutral'>    /// @param _sharesAdded The number of Borrow Shares the borrower was debited</span>
  814 |     | <span class='neutral'>    event BorrowAsset(</span>
  815 |     | <span class='neutral'>        address indexed _borrower,</span>
  816 |     | <span class='neutral'>        address indexed _receiver,</span>
  817 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
  818 |     | <span class='neutral'>        uint256 _sharesAdded</span>
  819 |     | <span class='neutral'>    );</span>
  820 |     | <span class='neutral'></span>
  821 |     | <span class='neutral'>    /// @notice The ```_borrowAsset``` function is the internal implementation for borrowing assets</span>
  822 |     | <span class='neutral'>    /// @param _borrowAmount The amount of the Asset Token to borrow</span>
  823 |     | <span class='neutral'>    /// @param _receiver The address to receive the Asset Tokens</span>
  824 |     | <span class='neutral'>    /// @return _sharesAdded The amount of borrow shares the msg.sender will be debited</span>
  825 |     | <span class='unexecuted'>    function _borrowAsset(uint128 _borrowAmount, address _receiver) internal returns (uint256 _sharesAdded) {</span>
  826 |     | <span class='neutral'>        // Get borrow accounting from storage to save gas</span>
  827 |     | <span class='unexecuted'>        VaultAccount memory _totalBorrow = totalBorrow;</span>
  828 |     | <span class='neutral'></span>
  829 |     | <span class='neutral'>        // Check available capital (not strictly necessary because balance will underflow, but better revert message)</span>
  830 |     | <span class='unexecuted'>        uint256 _totalAssetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow, true);</span>
  831 |     | <span class='unexecuted'>        if (_totalAssetsAvailable &lt; _borrowAmount) {</span>
  832 |     | <span class='unexecuted'>            revert InsufficientAssetsInContract(_totalAssetsAvailable, _borrowAmount);</span>
  833 |     | <span class='neutral'>        }</span>
  834 |     | <span class='unexecuted'>        uint256 _localAssetsAvailable = _totalAssetAvailable(totalAsset, _totalBorrow, false);</span>
  835 |     | <span class='unexecuted'>        if (_localAssetsAvailable &lt; _borrowAmount) {</span>
  836 |     | <span class='unexecuted'>            uint256 _externalAmt = _borrowAmount - _localAssetsAvailable;</span>
  837 |     | <span class='unexecuted'>            _depositFromVault(_externalAmt);</span>
  838 |     | <span class='neutral'>        }</span>
  839 |     | <span class='neutral'></span>
  840 |     | <span class='neutral'>        // Calculate the number of shares to add based on the amount to borrow</span>
  841 |     | <span class='unexecuted'>        _sharesAdded = _totalBorrow.toShares(_borrowAmount, true);</span>
  842 |     | <span class='neutral'></span>
  843 |     | <span class='neutral'>        // Effects: Bookkeeping to add shares &amp; amounts to total Borrow accounting</span>
  844 |     | <span class='unexecuted'>        _totalBorrow.amount += _borrowAmount;</span>
  845 |     | <span class='unexecuted'>        _totalBorrow.shares += _sharesAdded.toUint128();</span>
  846 |     | <span class='neutral'>        // NOTE: we can safely cast here because shares are always less than amount and _borrowAmount is uint128</span>
  847 |     | <span class='neutral'></span>
  848 |     | <span class='neutral'>        // Effects: write back to storage</span>
  849 |     | <span class='unexecuted'>        totalBorrow = _totalBorrow;</span>
  850 |     | <span class='unexecuted'>        userBorrowShares[msg.sender] += _sharesAdded;</span>
  851 |     | <span class='neutral'></span>
  852 |     | <span class='neutral'>        // Interactions</span>
  853 |     | <span class='unexecuted'>        if (_receiver != address(this)) {</span>
  854 |     | <span class='unexecuted'>            assetContract.safeTransfer(_receiver, _borrowAmount);</span>
  855 |     | <span class='neutral'>        }</span>
  856 |     | <span class='unexecuted'>        emit BorrowAsset(msg.sender, _receiver, _borrowAmount, _sharesAdded);</span>
  857 |     | <span class='neutral'>    }</span>
  858 |     | <span class='neutral'></span>
  859 |     | <span class='neutral'>    /// @notice The ```borrowAsset``` function allows a user to open/increase a borrow position</span>
  860 |     | <span class='neutral'>    /// @dev Borrower must call ```ERC20.approve``` on the Collateral Token contract if applicable</span>
  861 |     | <span class='neutral'>    /// @param _borrowAmount The amount of Asset Token to borrow</span>
  862 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to transfer to Pair</span>
  863 |     | <span class='neutral'>    /// @param _receiver The address which will receive the Asset Tokens</span>
  864 |     | <span class='neutral'>    /// @return _shares The number of borrow Shares the msg.sender will be debited</span>
  865 |     | <span class='unexecuted'>    function borrowAsset(</span>
  866 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
  867 |     | <span class='neutral'>        uint256 _collateralAmount,</span>
  868 |     | <span class='neutral'>        address _receiver</span>
  869 |     | <span class='unexecuted'>    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _shares) {</span>
  870 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  871 |     | <span class='neutral'></span>
  872 |     | <span class='neutral'>        // Accrue interest if necessary</span>
  873 |     | <span class='unexecuted'>        _addInterest();</span>
  874 |     | <span class='neutral'></span>
  875 |     | <span class='neutral'>        // Check if borrow will violate the borrow limit and revert if necessary</span>
  876 |     | <span class='unexecuted'>        if (borrowLimit &lt; totalBorrow.amount + _borrowAmount) revert ExceedsBorrowLimit();</span>
  877 |     | <span class='neutral'></span>
  878 |     | <span class='neutral'>        // Update _exchangeRate and check if borrow is allowed based on deviation</span>
  879 |     | <span class='unexecuted'>        (bool _isBorrowAllowed, , ) = _updateExchangeRate();</span>
  880 |     | <span class='unexecuted'>        if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();</span>
  881 |     | <span class='neutral'></span>
  882 |     | <span class='neutral'>        // Only add collateral if necessary</span>
  883 |     | <span class='unexecuted'>        if (_collateralAmount &gt; 0) {</span>
  884 |     | <span class='unexecuted'>            _addCollateral(msg.sender, _collateralAmount, msg.sender);</span>
  885 |     | <span class='neutral'>        }</span>
  886 |     | <span class='neutral'></span>
  887 |     | <span class='neutral'>        // Effects: Call internal borrow function</span>
  888 |     | <span class='unexecuted'>        _shares = _borrowAsset(_borrowAmount.toUint128(), _receiver);</span>
  889 |     | <span class='neutral'>    }</span>
  890 |     | <span class='neutral'></span>
  891 |     | <span class='neutral'>    /// @notice The ```AddCollateral``` event is emitted when a borrower adds collateral to their position</span>
  892 |     | <span class='neutral'>    /// @param sender The source of funds for the new collateral</span>
  893 |     | <span class='neutral'>    /// @param borrower The borrower account for which the collateral should be credited</span>
  894 |     | <span class='neutral'>    /// @param collateralAmount The amount of Collateral Token to be transferred</span>
  895 |     | <span class='neutral'>    event AddCollateral(address indexed sender, address indexed borrower, uint256 collateralAmount);</span>
  896 |     | <span class='neutral'></span>
  897 |     | <span class='neutral'>    /// @notice The ```_addCollateral``` function is an internal implementation for adding collateral to a borrowers position</span>
  898 |     | <span class='neutral'>    /// @param _sender The source of funds for the new collateral</span>
  899 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to be transferred</span>
  900 |     | <span class='neutral'>    /// @param _borrower The borrower account for which the collateral should be credited</span>
  901 |     | <span class='unexecuted'>    function _addCollateral(address _sender, uint256 _collateralAmount, address _borrower) internal {</span>
  902 |     | <span class='neutral'>        // Effects: write to state</span>
  903 |     | <span class='unexecuted'>        userCollateralBalance[_borrower] += _collateralAmount;</span>
  904 |     | <span class='unexecuted'>        totalCollateral += _collateralAmount;</span>
  905 |     | <span class='neutral'></span>
  906 |     | <span class='neutral'>        // Interactions</span>
  907 |     | <span class='unexecuted'>        if (_sender != address(this)) {</span>
  908 |     | <span class='unexecuted'>            collateralContract.safeTransferFrom(_sender, address(this), _collateralAmount);</span>
  909 |     | <span class='neutral'>        }</span>
  910 |     | <span class='unexecuted'>        emit AddCollateral(_sender, _borrower, _collateralAmount);</span>
  911 |     | <span class='neutral'>    }</span>
  912 |     | <span class='neutral'></span>
  913 |     | <span class='neutral'>    /// @notice The ```addCollateral``` function allows the caller to add Collateral Token to a borrowers position</span>
  914 |     | <span class='neutral'>    /// @dev msg.sender must call ERC20.approve() on the Collateral Token contract prior to invocation</span>
  915 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to be added to borrower&#39;s position</span>
  916 |     | <span class='neutral'>    /// @param _borrower The account to be credited</span>
  917 |     | <span class='unexecuted'>    function addCollateral(uint256 _collateralAmount, address _borrower) external nonReentrant {</span>
  918 |     | <span class='unexecuted'>        if (_borrower == address(0)) revert InvalidReceiver();</span>
  919 |     | <span class='neutral'></span>
  920 |     | <span class='unexecuted'>        _addInterest();</span>
  921 |     | <span class='unexecuted'>        _addCollateral(msg.sender, _collateralAmount, _borrower);</span>
  922 |     | <span class='neutral'>    }</span>
  923 |     | <span class='neutral'></span>
  924 |     | <span class='neutral'>    /// @notice The ```RemoveCollateral``` event is emitted when collateral is removed from a borrower&#39;s position</span>
  925 |     | <span class='neutral'>    /// @param _sender The account from which funds are transferred</span>
  926 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to be transferred</span>
  927 |     | <span class='neutral'>    /// @param _receiver The address to which Collateral Tokens will be transferred</span>
  928 |     | <span class='neutral'>    event RemoveCollateral(</span>
  929 |     | <span class='neutral'>        address indexed _sender,</span>
  930 |     | <span class='neutral'>        uint256 _collateralAmount,</span>
  931 |     | <span class='neutral'>        address indexed _receiver,</span>
  932 |     | <span class='neutral'>        address indexed _borrower</span>
  933 |     | <span class='neutral'>    );</span>
  934 |     | <span class='neutral'></span>
  935 |     | <span class='neutral'>    /// @notice The ```_removeCollateral``` function is the internal implementation for removing collateral from a borrower&#39;s position</span>
  936 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to remove from the borrower&#39;s position</span>
  937 |     | <span class='neutral'>    /// @param _receiver The address to receive the Collateral Token transferred</span>
  938 |     | <span class='neutral'>    /// @param _borrower The borrower whose account will be debited the Collateral amount</span>
  939 |     | <span class='unexecuted'>    function _removeCollateral(uint256 _collateralAmount, address _receiver, address _borrower) internal {</span>
  940 |     | <span class='neutral'>        // Effects: write to state</span>
  941 |     | <span class='neutral'>        // NOTE: Following line will revert on underflow if _collateralAmount &gt; userCollateralBalance</span>
  942 |     | <span class='unexecuted'>        userCollateralBalance[_borrower] -= _collateralAmount;</span>
  943 |     | <span class='neutral'>        // NOTE: Following line will revert on underflow if totalCollateral &lt; _collateralAmount</span>
  944 |     | <span class='unexecuted'>        totalCollateral -= _collateralAmount;</span>
  945 |     | <span class='neutral'></span>
  946 |     | <span class='neutral'>        // Interactions</span>
  947 |     | <span class='unexecuted'>        if (_receiver != address(this)) {</span>
  948 |     | <span class='unexecuted'>            collateralContract.safeTransfer(_receiver, _collateralAmount);</span>
  949 |     | <span class='neutral'>        }</span>
  950 |     | <span class='unexecuted'>        emit RemoveCollateral(msg.sender, _collateralAmount, _receiver, _borrower);</span>
  951 |     | <span class='neutral'>    }</span>
  952 |     | <span class='neutral'></span>
  953 |     | <span class='neutral'>    /// @notice The ```removeCollateral``` function is used to remove collateral from msg.sender&#39;s borrow position</span>
  954 |     | <span class='neutral'>    /// @dev msg.sender must be solvent after invocation or transaction will revert</span>
  955 |     | <span class='neutral'>    /// @param _collateralAmount The amount of Collateral Token to transfer</span>
  956 |     | <span class='neutral'>    /// @param _receiver The address to receive the transferred funds</span>
  957 |     | <span class='unexecuted'>    function removeCollateral(</span>
  958 |     | <span class='neutral'>        uint256 _collateralAmount,</span>
  959 |     | <span class='neutral'>        address _receiver</span>
  960 |     | <span class='unexecuted'>    ) external nonReentrant isSolvent(msg.sender) {</span>
  961 |     | <span class='unexecuted'>        if (_receiver == address(0)) revert InvalidReceiver();</span>
  962 |     | <span class='neutral'></span>
  963 |     | <span class='unexecuted'>        _addInterest();</span>
  964 |     | <span class='neutral'>        // Note: exchange rate is irrelevant when borrower has no debt shares</span>
  965 |     | <span class='unexecuted'>        if (userBorrowShares[msg.sender] &gt; 0) {</span>
  966 |     | <span class='unexecuted'>            (bool _isBorrowAllowed, , ) = _updateExchangeRate();</span>
  967 |     | <span class='unexecuted'>            if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();</span>
  968 |     | <span class='neutral'>        }</span>
  969 |     | <span class='unexecuted'>        _removeCollateral(_collateralAmount, _receiver, msg.sender);</span>
  970 |     | <span class='neutral'>    }</span>
  971 |     | <span class='neutral'></span>
  972 |     | <span class='neutral'>    /// @notice The ```RepayAsset``` event is emitted whenever a debt position is repaid</span>
  973 |     | <span class='neutral'>    /// @param payer The address paying for the repayment</span>
  974 |     | <span class='neutral'>    /// @param borrower The borrower whose account will be credited</span>
  975 |     | <span class='neutral'>    /// @param amountToRepay The amount of Asset token to be transferred</span>
  976 |     | <span class='neutral'>    /// @param shares The amount of Borrow Shares which will be debited from the borrower after repayment</span>
  977 |     | <span class='neutral'>    event RepayAsset(address indexed payer, address indexed borrower, uint256 amountToRepay, uint256 shares);</span>
  978 |     | <span class='neutral'></span>
  979 |     | <span class='neutral'>    /// @notice The ```_repayAsset``` function is the internal implementation for repaying a borrow position</span>
  980 |     | <span class='neutral'>    /// @dev The payer must have called ERC20.approve() on the Asset Token contract prior to invocation</span>
  981 |     | <span class='neutral'>    /// @param _totalBorrow An in memory copy of the totalBorrow VaultAccount struct</span>
  982 |     | <span class='neutral'>    /// @param _amountToRepay The amount of Asset Token to transfer</span>
  983 |     | <span class='neutral'>    /// @param _shares The number of Borrow Shares the sender is repaying</span>
  984 |     | <span class='neutral'>    /// @param _payer The address from which funds will be transferred</span>
  985 |     | <span class='neutral'>    /// @param _borrower The borrower account which will be credited</span>
  986 |     | <span class='unexecuted'>    function _repayAsset(</span>
  987 |     | <span class='neutral'>        VaultAccount memory _totalBorrow,</span>
  988 |     | <span class='neutral'>        uint128 _amountToRepay,</span>
  989 |     | <span class='neutral'>        uint128 _shares,</span>
  990 |     | <span class='neutral'>        address _payer,</span>
  991 |     | <span class='neutral'>        address _borrower</span>
  992 |     | <span class='unexecuted'>    ) internal {</span>
  993 |     | <span class='neutral'>        // Effects: Bookkeeping</span>
  994 |     | <span class='unexecuted'>        _totalBorrow.amount -= _amountToRepay;</span>
  995 |     | <span class='unexecuted'>        _totalBorrow.shares -= _shares;</span>
  996 |     | <span class='neutral'></span>
  997 |     | <span class='neutral'>        // Effects: write to state</span>
  998 |     | <span class='unexecuted'>        userBorrowShares[_borrower] -= _shares;</span>
  999 |     | <span class='unexecuted'>        totalBorrow = _totalBorrow;</span>
 1000 |     | <span class='neutral'></span>
 1001 |     | <span class='neutral'>        // Interactions</span>
 1002 |     | <span class='unexecuted'>        if (_payer != address(this)) {</span>
 1003 |     | <span class='unexecuted'>            assetContract.safeTransferFrom(_payer, address(this), _amountToRepay);</span>
 1004 |     | <span class='neutral'>        }</span>
 1005 |     | <span class='unexecuted'>        externalAssetVault.whitelistUpdate();</span>
 1006 |     | <span class='unexecuted'>        uint256 _externalAssetsToWithdraw = externalAssetVault.vaultUtilization(address(this));</span>
 1007 |     | <span class='unexecuted'>        if (_externalAssetsToWithdraw &gt; 0) {</span>
 1008 |     | <span class='unexecuted'>            uint256 _extAmount = _externalAssetsToWithdraw &gt; _amountToRepay ? _amountToRepay : _externalAssetsToWithdraw;</span>
 1009 |     | <span class='unexecuted'>            _withdrawToVault(_extAmount);</span>
 1010 |     | <span class='neutral'>        }</span>
 1011 |     | <span class='unexecuted'>        emit RepayAsset(_payer, _borrower, _amountToRepay, _shares);</span>
 1012 |     | <span class='neutral'>    }</span>
 1013 |     | <span class='neutral'></span>
 1014 |     | <span class='neutral'>    /// @notice The ```repayAsset``` function allows the caller to pay down the debt for a given borrower.</span>
 1015 |     | <span class='neutral'>    /// @dev Caller must first invoke ```ERC20.approve()``` for the Asset Token contract</span>
 1016 |     | <span class='neutral'>    /// @param _shares The number of Borrow Shares which will be repaid by the call</span>
 1017 |     | <span class='neutral'>    /// @param _borrower The account for which the debt will be reduced</span>
 1018 |     | <span class='neutral'>    /// @return _amountToRepay The amount of Asset Tokens which were transferred in order to repay the Borrow Shares</span>
 1019 |     | <span class='unexecuted'>    function repayAsset(uint256 _shares, address _borrower) external nonReentrant returns (uint256 _amountToRepay) {</span>
 1020 |     | <span class='unexecuted'>        if (_borrower == address(0)) revert InvalidReceiver();</span>
 1021 |     | <span class='neutral'></span>
 1022 |     | <span class='neutral'>        // Check if repay is paused revert if necessary</span>
 1023 |     | <span class='unexecuted'>        if (isRepayPaused) revert RepayPaused();</span>
 1024 |     | <span class='neutral'></span>
 1025 |     | <span class='neutral'>        // Accrue interest if necessary</span>
 1026 |     | <span class='unexecuted'>        _addInterest();</span>
 1027 |     | <span class='neutral'></span>
 1028 |     | <span class='neutral'>        // Calculate amount to repay based on shares</span>
 1029 |     | <span class='unexecuted'>        VaultAccount memory _totalBorrow = totalBorrow;</span>
 1030 |     | <span class='unexecuted'>        _amountToRepay = _totalBorrow.toAmount(_shares, true);</span>
 1031 |     | <span class='neutral'></span>
 1032 |     | <span class='neutral'>        // Execute repayment effects</span>
 1033 |     | <span class='unexecuted'>        _repayAsset(_totalBorrow, _amountToRepay.toUint128(), _shares.toUint128(), msg.sender, _borrower);</span>
 1034 |     | <span class='neutral'>    }</span>
 1035 |     | <span class='neutral'></span>
 1036 |     | <span class='neutral'>    // ============================================================================================</span>
 1037 |     | <span class='neutral'>    // Functions: Liquidations</span>
 1038 |     | <span class='neutral'>    // ============================================================================================</span>
 1039 |     | <span class='neutral'>    /// @notice The ```Liquidate``` event is emitted when a liquidation occurs</span>
 1040 |     | <span class='neutral'>    /// @param _borrower The borrower account for which the liquidation occurred</span>
 1041 |     | <span class='neutral'>    /// @param _collateralForLiquidator The amount of Collateral Token transferred to the liquidator</span>
 1042 |     | <span class='neutral'>    /// @param _sharesToLiquidate The number of Borrow Shares the liquidator repaid on behalf of the borrower</span>
 1043 |     | <span class='neutral'>    /// @param _sharesToAdjust The number of Borrow Shares that were adjusted on liabilities and assets (a writeoff)</span>
 1044 |     | <span class='neutral'>    event Liquidate(</span>
 1045 |     | <span class='neutral'>        address indexed _borrower,</span>
 1046 |     | <span class='neutral'>        uint256 _collateralForLiquidator,</span>
 1047 |     | <span class='neutral'>        uint256 _sharesToLiquidate,</span>
 1048 |     | <span class='neutral'>        uint256 _amountLiquidatorToRepay,</span>
 1049 |     | <span class='neutral'>        uint256 _feesAmount,</span>
 1050 |     | <span class='neutral'>        uint256 _sharesToAdjust,</span>
 1051 |     | <span class='neutral'>        uint256 _amountToAdjust</span>
 1052 |     | <span class='neutral'>    );</span>
 1053 |     | <span class='neutral'></span>
 1054 |     | <span class='neutral'>    /// @notice The ```liquidate``` function allows a third party to repay a borrower&#39;s debt if they have become insolvent</span>
 1055 |     | <span class='neutral'>    /// @dev Caller must invoke ```ERC20.approve``` on the Asset Token contract prior to calling ```Liquidate()```</span>
 1056 |     | <span class='neutral'>    /// @param _sharesToLiquidate The number of Borrow Shares repaid by the liquidator</span>
 1057 |     | <span class='neutral'>    /// @param _deadline The timestamp after which tx will revert</span>
 1058 |     | <span class='neutral'>    /// @param _borrower The account for which the repayment is credited and from whom collateral will be taken</span>
 1059 |     | <span class='neutral'>    /// @return _collateralForLiquidator The amount of Collateral Token transferred to the liquidator</span>
 1060 |     | <span class='unexecuted'>    function liquidate(</span>
 1061 |     | <span class='neutral'>        uint128 _sharesToLiquidate,</span>
 1062 |     | <span class='neutral'>        uint256 _deadline,</span>
 1063 |     | <span class='neutral'>        address _borrower</span>
 1064 |     | <span class='unexecuted'>    ) external nonReentrant returns (uint256 _collateralForLiquidator) {</span>
 1065 |     | <span class='unexecuted'>        if (_borrower == address(0)) revert InvalidReceiver();</span>
 1066 |     | <span class='neutral'></span>
 1067 |     | <span class='neutral'>        // Check if liquidate is paused revert if necessary</span>
 1068 |     | <span class='unexecuted'>        if (isLiquidatePaused) revert LiquidatePaused();</span>
 1069 |     | <span class='neutral'></span>
 1070 |     | <span class='neutral'>        // Ensure deadline has not passed</span>
 1071 |     | <span class='unexecuted'>        if (block.timestamp &gt; _deadline) revert PastDeadline(block.timestamp, _deadline);</span>
 1072 |     | <span class='neutral'></span>
 1073 |     | <span class='neutral'>        // accrue interest if necessary</span>
 1074 |     | <span class='unexecuted'>        _addInterest();</span>
 1075 |     | <span class='neutral'></span>
 1076 |     | <span class='neutral'>        // Update exchange rate and use the lower rate for liquidations</span>
 1077 |     | <span class='unexecuted'>        (, uint256 _exchangeRate, ) = _updateExchangeRate();</span>
 1078 |     | <span class='neutral'></span>
 1079 |     | <span class='neutral'>        // Check if borrower is solvent, revert if they are</span>
 1080 |     | <span class='unexecuted'>        if (_isSolvent(_borrower, _exchangeRate)) {</span>
 1081 |     | <span class='unexecuted'>            revert BorrowerSolvent();</span>
 1082 |     | <span class='neutral'>        }</span>
 1083 |     | <span class='neutral'></span>
 1084 |     | <span class='neutral'>        // Read from state</span>
 1085 |     | <span class='unexecuted'>        VaultAccount memory _totalBorrow = totalBorrow;</span>
 1086 |     | <span class='unexecuted'>        uint256 _userCollateralBalance = userCollateralBalance[_borrower];</span>
 1087 |     | <span class='unexecuted'>        uint128 _borrowerShares = userBorrowShares[_borrower].toUint128();</span>
 1088 |     | <span class='neutral'></span>
 1089 |     | <span class='neutral'>        // Prevent stack-too-deep</span>
 1090 |     | <span class='unexecuted'>        int256 _leftoverCollateral;</span>
 1091 |     | <span class='neutral'>        uint256 _feesAmount;</span>
 1092 |     | <span class='neutral'>        {</span>
 1093 |     | <span class='neutral'>            // Checks &amp; Calculations</span>
 1094 |     | <span class='neutral'>            // Determine the liquidation amount in collateral units (i.e. how much debt liquidator is going to repay)</span>
 1095 |     | <span class='unexecuted'>            uint256 _liquidationAmountInCollateralUnits = ((_totalBorrow.toAmount(_sharesToLiquidate, false) *</span>
 1096 |     | <span class='unexecuted'>                _exchangeRate) / EXCHANGE_PRECISION);</span>
 1097 |     | <span class='neutral'></span>
 1098 |     | <span class='neutral'>            // We first optimistically calculate the amount of collateral to give the liquidator based on the higher clean liquidation fee</span>
 1099 |     | <span class='neutral'>            // This fee only applies if the liquidator does a full liquidation</span>
 1100 |     | <span class='unexecuted'>            uint256 _optimisticCollateralForLiquidator = (_liquidationAmountInCollateralUnits *</span>
 1101 |     | <span class='unexecuted'>                (LIQ_PRECISION + cleanLiquidationFee)) / LIQ_PRECISION;</span>
 1102 |     | <span class='neutral'></span>
 1103 |     | <span class='neutral'>            // Because interest accrues every block, _liquidationAmountInCollateralUnits from a few lines up is an ever increasing value</span>
 1104 |     | <span class='neutral'>            // This means that leftoverCollateral can occasionally go negative by a few hundred wei (cleanLiqFee premium covers this for liquidator)</span>
 1105 |     | <span class='unexecuted'>            _leftoverCollateral = (_userCollateralBalance.toInt256() - _optimisticCollateralForLiquidator.toInt256());</span>
 1106 |     | <span class='neutral'></span>
 1107 |     | <span class='neutral'>            // If cleanLiquidation fee results in no leftover collateral, give liquidator all the collateral</span>
 1108 |     | <span class='neutral'>            // This will only be true when there liquidator is cleaning out the position</span>
 1109 |     | <span class='unexecuted'>            _collateralForLiquidator = _leftoverCollateral &lt;= 0</span>
 1110 |     | <span class='unexecuted'>                ? _userCollateralBalance</span>
 1111 |     | <span class='unexecuted'>                : (_liquidationAmountInCollateralUnits * (LIQ_PRECISION + dirtyLiquidationFee)) / LIQ_PRECISION;</span>
 1112 |     | <span class='neutral'></span>
 1113 |     | <span class='unexecuted'>            if (protocolLiquidationFee &gt; 0) {</span>
 1114 |     | <span class='unexecuted'>                _feesAmount = (protocolLiquidationFee * _collateralForLiquidator) / LIQ_PRECISION;</span>
 1115 |     | <span class='unexecuted'>                _collateralForLiquidator = _collateralForLiquidator - _feesAmount;</span>
 1116 |     | <span class='neutral'>            }</span>
 1117 |     | <span class='neutral'>        }</span>
 1118 |     | <span class='neutral'></span>
 1119 |     | <span class='neutral'>        // Calculated here for use during repayment, grouped with other calcs before effects start</span>
 1120 |     | <span class='unexecuted'>        uint128 _amountLiquidatorToRepay = (_totalBorrow.toAmount(_sharesToLiquidate, true)).toUint128();</span>
 1121 |     | <span class='neutral'></span>
 1122 |     | <span class='neutral'>        // Determine if and how much debt to adjust</span>
 1123 |     | <span class='unexecuted'>        uint128 _sharesToAdjust = 0;</span>
 1124 |     | <span class='unexecuted'>        {</span>
 1125 |     | <span class='unexecuted'>            uint128 _amountToAdjust = 0;</span>
 1126 |     | <span class='unexecuted'>            if (_leftoverCollateral &lt;= 0) {</span>
 1127 |     | <span class='neutral'>                // Determine if we need to adjust any shares</span>
 1128 |     | <span class='unexecuted'>                _sharesToAdjust = _borrowerShares - _sharesToLiquidate;</span>
 1129 |     | <span class='unexecuted'>                if (_sharesToAdjust &gt; 0) {</span>
 1130 |     | <span class='neutral'>                    // Write off bad debt</span>
 1131 |     | <span class='unexecuted'>                    _amountToAdjust = (_totalBorrow.toAmount(_sharesToAdjust, false)).toUint128();</span>
 1132 |     | <span class='neutral'></span>
 1133 |     | <span class='neutral'>                    // Note: Ensure this memory struct will be passed to _repayAsset for write to state</span>
 1134 |     | <span class='unexecuted'>                    _totalBorrow.amount -= _amountToAdjust;</span>
 1135 |     | <span class='neutral'></span>
 1136 |     | <span class='neutral'>                    // Effects: write to state</span>
 1137 |     | <span class='unexecuted'>                    totalAsset.amount -= _amountToAdjust;</span>
 1138 |     | <span class='neutral'>                }</span>
 1139 |     | <span class='neutral'>            }</span>
 1140 |     | <span class='unexecuted'>            emit Liquidate(</span>
 1141 |     | <span class='unexecuted'>                _borrower,</span>
 1142 |     | <span class='unexecuted'>                _collateralForLiquidator,</span>
 1143 |     | <span class='unexecuted'>                _sharesToLiquidate,</span>
 1144 |     | <span class='unexecuted'>                _amountLiquidatorToRepay,</span>
 1145 |     | <span class='unexecuted'>                _feesAmount,</span>
 1146 |     | <span class='unexecuted'>                _sharesToAdjust,</span>
 1147 |     | <span class='unexecuted'>                _amountToAdjust</span>
 1148 |     | <span class='neutral'>            );</span>
 1149 |     | <span class='neutral'>        }</span>
 1150 |     | <span class='neutral'></span>
 1151 |     | <span class='neutral'>        // Effects &amp; Interactions</span>
 1152 |     | <span class='neutral'>        // NOTE: reverts if _shares &gt; userBorrowShares</span>
 1153 |     | <span class='unexecuted'>        _repayAsset(</span>
 1154 |     | <span class='unexecuted'>            _totalBorrow,</span>
 1155 |     | <span class='unexecuted'>            _amountLiquidatorToRepay,</span>
 1156 |     | <span class='unexecuted'>            _sharesToLiquidate + _sharesToAdjust,</span>
 1157 |     | <span class='unexecuted'>            msg.sender,</span>
 1158 |     | <span class='unexecuted'>            _borrower</span>
 1159 |     | <span class='neutral'>        ); // liquidator repays shares on behalf of borrower</span>
 1160 |     | <span class='neutral'>        // NOTE: reverts if _collateralForLiquidator &gt; userCollateralBalance</span>
 1161 |     | <span class='neutral'>        // Collateral is removed on behalf of borrower and sent to liquidator</span>
 1162 |     | <span class='neutral'>        // NOTE: reverts if _collateralForLiquidator &gt; userCollateralBalance</span>
 1163 |     | <span class='unexecuted'>        _removeCollateral(_collateralForLiquidator, msg.sender, _borrower);</span>
 1164 |     | <span class='neutral'>        // Adjust bookkeeping only (decreases collateral held by borrower)</span>
 1165 |     | <span class='unexecuted'>        _removeCollateral(_feesAmount, address(this), _borrower);</span>
 1166 |     | <span class='neutral'>        // Adjusts bookkeeping only (increases collateral held by protocol)</span>
 1167 |     | <span class='unexecuted'>        _addCollateral(address(this), _feesAmount, address(this));</span>
 1168 |     | <span class='neutral'>    }</span>
 1169 |     | <span class='neutral'></span>
 1170 |     | <span class='neutral'>    // ============================================================================================</span>
 1171 |     | <span class='neutral'>    // Functions: Leverage</span>
 1172 |     | <span class='neutral'>    // ============================================================================================</span>
 1173 |     | <span class='neutral'></span>
 1174 |     | <span class='neutral'>    /// @notice The ```LeveragedPosition``` event is emitted when a borrower takes out a new leveraged position</span>
 1175 |     | <span class='neutral'>    /// @param _borrower The account for which the debt is debited</span>
 1176 |     | <span class='neutral'>    /// @param _swapperAddress The address of the swapper which conforms the FraxSwap interface</span>
 1177 |     | <span class='neutral'>    /// @param _borrowAmount The amount of Asset Token to be borrowed to be borrowed</span>
 1178 |     | <span class='neutral'>    /// @param _borrowShares The number of Borrow Shares the borrower is credited</span>
 1179 |     | <span class='neutral'>    /// @param _initialCollateralAmount The amount of initial Collateral Tokens supplied by the borrower</span>
 1180 |     | <span class='neutral'>    /// @param _amountCollateralOut The amount of Collateral Token which was received for the Asset Tokens</span>
 1181 |     | <span class='neutral'>    event LeveragedPosition(</span>
 1182 |     | <span class='neutral'>        address indexed _borrower,</span>
 1183 |     | <span class='neutral'>        address _swapperAddress,</span>
 1184 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
 1185 |     | <span class='neutral'>        uint256 _borrowShares,</span>
 1186 |     | <span class='neutral'>        uint256 _initialCollateralAmount,</span>
 1187 |     | <span class='neutral'>        uint256 _amountCollateralOut</span>
 1188 |     | <span class='neutral'>    );</span>
 1189 |     | <span class='neutral'></span>
 1190 |     | <span class='neutral'>    /// @notice The ```leveragedPosition``` function allows a user to enter a leveraged borrow position with minimal upfront Collateral</span>
 1191 |     | <span class='neutral'>    /// @dev Caller must invoke ```ERC20.approve()``` on the Collateral Token contract prior to calling function</span>
 1192 |     | <span class='neutral'>    /// @param _swapperAddress The address of the whitelisted swapper to use to swap borrowed Asset Tokens for Collateral Tokens</span>
 1193 |     | <span class='neutral'>    /// @param _borrowAmount The amount of Asset Tokens borrowed</span>
 1194 |     | <span class='neutral'>    /// @param _initialCollateralAmount The initial amount of Collateral Tokens supplied by the borrower</span>
 1195 |     | <span class='neutral'>    /// @param _amountCollateralOutMin The minimum amount of Collateral Tokens to be received in exchange for the borrowed Asset Tokens</span>
 1196 |     | <span class='neutral'>    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.</span>
 1197 |     | <span class='neutral'>    /// @return _totalCollateralBalance The total amount of Collateral Tokens added to a users account (initial + swap)</span>
 1198 |     | <span class='unexecuted'>    function leveragedPosition(</span>
 1199 |     | <span class='neutral'>        address _swapperAddress,</span>
 1200 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
 1201 |     | <span class='neutral'>        uint256 _initialCollateralAmount,</span>
 1202 |     | <span class='neutral'>        uint256 _amountCollateralOutMin,</span>
 1203 |     | <span class='neutral'>        address[] memory _path</span>
 1204 |     | <span class='unexecuted'>    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _totalCollateralBalance) {</span>
 1205 |     | <span class='neutral'>        // Accrue interest if necessary</span>
 1206 |     | <span class='unexecuted'>        _addInterest();</span>
 1207 |     | <span class='neutral'></span>
 1208 |     | <span class='neutral'>        // Update exchange rate and check if borrow is allowed, revert if not</span>
 1209 |     | <span class='neutral'>        {</span>
 1210 |     | <span class='unexecuted'>            (bool _isBorrowAllowed, , ) = _updateExchangeRate();</span>
 1211 |     | <span class='unexecuted'>            if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();</span>
 1212 |     | <span class='neutral'>        }</span>
 1213 |     | <span class='neutral'></span>
 1214 |     | <span class='unexecuted'>        IERC20 _assetContract = assetContract;</span>
 1215 |     | <span class='unexecuted'>        IERC20 _collateralContract = collateralContract;</span>
 1216 |     | <span class='neutral'></span>
 1217 |     | <span class='unexecuted'>        if (!swappers[_swapperAddress]) {</span>
 1218 |     | <span class='unexecuted'>            revert BadSwapper();</span>
 1219 |     | <span class='neutral'>        }</span>
 1220 |     | <span class='unexecuted'>        if (_path[0] != address(_assetContract)) {</span>
 1221 |     | <span class='unexecuted'>            revert InvalidPath(address(_assetContract), _path[0]);</span>
 1222 |     | <span class='neutral'>        }</span>
 1223 |     | <span class='unexecuted'>        if (_path[_path.length - 1] != address(_collateralContract)) {</span>
 1224 |     | <span class='unexecuted'>            revert InvalidPath(address(_collateralContract), _path[_path.length - 1]);</span>
 1225 |     | <span class='neutral'>        }</span>
 1226 |     | <span class='neutral'></span>
 1227 |     | <span class='neutral'>        // Add initial collateral</span>
 1228 |     | <span class='unexecuted'>        if (_initialCollateralAmount &gt; 0) {</span>
 1229 |     | <span class='unexecuted'>            _addCollateral(msg.sender, _initialCollateralAmount, msg.sender);</span>
 1230 |     | <span class='neutral'>        }</span>
 1231 |     | <span class='neutral'></span>
 1232 |     | <span class='neutral'>        // Debit borrowers account</span>
 1233 |     | <span class='neutral'>        // setting recipient to address(this) means no transfer will happen</span>
 1234 |     | <span class='unexecuted'>        uint256 _borrowShares = _borrowAsset(_borrowAmount.toUint128(), address(this));</span>
 1235 |     | <span class='neutral'></span>
 1236 |     | <span class='neutral'>        // Interactions</span>
 1237 |     | <span class='unexecuted'>        _assetContract.approve(_swapperAddress, _borrowAmount);</span>
 1238 |     | <span class='neutral'></span>
 1239 |     | <span class='neutral'>        // Even though swappers are trusted, we verify the balance before and after swap</span>
 1240 |     | <span class='unexecuted'>        uint256 _initialCollateralBalance = _collateralContract.balanceOf(address(this));</span>
 1241 |     | <span class='unexecuted'>        ISwapper(_swapperAddress).swapExactTokensForTokens(</span>
 1242 |     | <span class='unexecuted'>            _borrowAmount,</span>
 1243 |     | <span class='unexecuted'>            _amountCollateralOutMin,</span>
 1244 |     | <span class='unexecuted'>            _path,</span>
 1245 |     | <span class='unexecuted'>            address(this),</span>
 1246 |     | <span class='unexecuted'>            block.timestamp</span>
 1247 |     | <span class='neutral'>        );</span>
 1248 |     | <span class='unexecuted'>        uint256 _finalCollateralBalance = _collateralContract.balanceOf(address(this));</span>
 1249 |     | <span class='neutral'></span>
 1250 |     | <span class='neutral'>        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT</span>
 1251 |     | <span class='neutral'>        // Effects: bookkeeping &amp; write to state</span>
 1252 |     | <span class='unexecuted'>        uint256 _amountCollateralOut = _finalCollateralBalance - _initialCollateralBalance;</span>
 1253 |     | <span class='unexecuted'>        if (_amountCollateralOut &lt; _amountCollateralOutMin) {</span>
 1254 |     | <span class='unexecuted'>            revert SlippageTooHigh(_amountCollateralOutMin, _amountCollateralOut);</span>
 1255 |     | <span class='neutral'>        }</span>
 1256 |     | <span class='neutral'></span>
 1257 |     | <span class='neutral'>        // address(this) as _sender means no transfer occurs as the pair has already received the collateral during swap</span>
 1258 |     | <span class='unexecuted'>        _addCollateral(address(this), _amountCollateralOut, msg.sender);</span>
 1259 |     | <span class='neutral'></span>
 1260 |     | <span class='unexecuted'>        _totalCollateralBalance = _initialCollateralAmount + _amountCollateralOut;</span>
 1261 |     | <span class='unexecuted'>        emit LeveragedPosition(</span>
 1262 |     | <span class='unexecuted'>            msg.sender,</span>
 1263 |     | <span class='unexecuted'>            _swapperAddress,</span>
 1264 |     | <span class='unexecuted'>            _borrowAmount,</span>
 1265 |     | <span class='unexecuted'>            _borrowShares,</span>
 1266 |     | <span class='unexecuted'>            _initialCollateralAmount,</span>
 1267 |     | <span class='unexecuted'>            _amountCollateralOut</span>
 1268 |     | <span class='neutral'>        );</span>
 1269 |     | <span class='neutral'>    }</span>
 1270 |     | <span class='neutral'></span>
 1271 |     | <span class='neutral'>    /// @notice The ```RepayAssetWithCollateral``` event is emitted whenever ```repayAssetWithCollateral()``` is invoked</span>
 1272 |     | <span class='neutral'>    /// @param _borrower The borrower account for which the repayment is taking place</span>
 1273 |     | <span class='neutral'>    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps</span>
 1274 |     | <span class='neutral'>    /// @param _collateralToSwap The amount of Collateral Token to swap and use for repayment</span>
 1275 |     | <span class='neutral'>    /// @param _amountAssetOut The amount of Asset Token which was repaid</span>
 1276 |     | <span class='neutral'>    /// @param _sharesRepaid The number of Borrow Shares which were repaid</span>
 1277 |     | <span class='neutral'>    event RepayAssetWithCollateral(</span>
 1278 |     | <span class='neutral'>        address indexed _borrower,</span>
 1279 |     | <span class='neutral'>        address _swapperAddress,</span>
 1280 |     | <span class='neutral'>        uint256 _collateralToSwap,</span>
 1281 |     | <span class='neutral'>        uint256 _amountAssetOut,</span>
 1282 |     | <span class='neutral'>        uint256 _sharesRepaid</span>
 1283 |     | <span class='neutral'>    );</span>
 1284 |     | <span class='neutral'></span>
 1285 |     | <span class='neutral'>    /// @notice The ```repayAssetWithCollateral``` function allows a borrower to repay their debt using existing collateral in contract</span>
 1286 |     | <span class='neutral'>    /// @param _swapperAddress The address of the whitelisted swapper to use for token swaps</span>
 1287 |     | <span class='neutral'>    /// @param _collateralToSwap The amount of Collateral Tokens to swap for Asset Tokens</span>
 1288 |     | <span class='neutral'>    /// @param _amountAssetOutMin The minimum amount of Asset Tokens to receive during the swap</span>
 1289 |     | <span class='neutral'>    /// @param _path An array containing the addresses of ERC20 tokens to swap.  Adheres to UniV2 style path params.</span>
 1290 |     | <span class='neutral'>    /// @return _amountAssetOut The amount of Asset Tokens received for the Collateral Tokens, the amount the borrowers account was credited</span>
 1291 |     | <span class='unexecuted'>    function repayAssetWithCollateral(</span>
 1292 |     | <span class='neutral'>        address _swapperAddress,</span>
 1293 |     | <span class='neutral'>        uint256 _collateralToSwap,</span>
 1294 |     | <span class='neutral'>        uint256 _amountAssetOutMin,</span>
 1295 |     | <span class='neutral'>        address[] calldata _path</span>
 1296 |     | <span class='unexecuted'>    ) external nonReentrant isSolvent(msg.sender) returns (uint256 _amountAssetOut) {</span>
 1297 |     | <span class='neutral'>        // Accrue interest if necessary</span>
 1298 |     | <span class='unexecuted'>        _addInterest();</span>
 1299 |     | <span class='neutral'></span>
 1300 |     | <span class='neutral'>        // Update exchange rate and check if borrow is allowed, revert if not</span>
 1301 |     | <span class='unexecuted'>        (bool _isBorrowAllowed, , ) = _updateExchangeRate();</span>
 1302 |     | <span class='unexecuted'>        if (!_isBorrowAllowed) revert ExceedsMaxOracleDeviation();</span>
 1303 |     | <span class='neutral'></span>
 1304 |     | <span class='unexecuted'>        IERC20 _assetContract = assetContract;</span>
 1305 |     | <span class='unexecuted'>        IERC20 _collateralContract = collateralContract;</span>
 1306 |     | <span class='neutral'></span>
 1307 |     | <span class='unexecuted'>        if (!swappers[_swapperAddress]) {</span>
 1308 |     | <span class='unexecuted'>            revert BadSwapper();</span>
 1309 |     | <span class='neutral'>        }</span>
 1310 |     | <span class='unexecuted'>        if (_path[0] != address(_collateralContract)) {</span>
 1311 |     | <span class='unexecuted'>            revert InvalidPath(address(_collateralContract), _path[0]);</span>
 1312 |     | <span class='neutral'>        }</span>
 1313 |     | <span class='unexecuted'>        if (_path[_path.length - 1] != address(_assetContract)) {</span>
 1314 |     | <span class='unexecuted'>            revert InvalidPath(address(_assetContract), _path[_path.length - 1]);</span>
 1315 |     | <span class='neutral'>        }</span>
 1316 |     | <span class='neutral'></span>
 1317 |     | <span class='neutral'>        // Effects: bookkeeping &amp; write to state</span>
 1318 |     | <span class='neutral'>        // Debit users collateral balance in preparation for swap, setting _recipient to address(this) means no transfer occurs</span>
 1319 |     | <span class='unexecuted'>        _removeCollateral(_collateralToSwap, address(this), msg.sender);</span>
 1320 |     | <span class='neutral'></span>
 1321 |     | <span class='neutral'>        // Interactions</span>
 1322 |     | <span class='unexecuted'>        _collateralContract.approve(_swapperAddress, _collateralToSwap);</span>
 1323 |     | <span class='neutral'></span>
 1324 |     | <span class='neutral'>        // Even though swappers are trusted, we verify the balance before and after swap</span>
 1325 |     | <span class='unexecuted'>        uint256 _initialAssetBalance = _assetContract.balanceOf(address(this));</span>
 1326 |     | <span class='unexecuted'>        ISwapper(_swapperAddress).swapExactTokensForTokens(</span>
 1327 |     | <span class='unexecuted'>            _collateralToSwap,</span>
 1328 |     | <span class='unexecuted'>            _amountAssetOutMin,</span>
 1329 |     | <span class='unexecuted'>            _path,</span>
 1330 |     | <span class='unexecuted'>            address(this),</span>
 1331 |     | <span class='unexecuted'>            block.timestamp</span>
 1332 |     | <span class='neutral'>        );</span>
 1333 |     | <span class='unexecuted'>        uint256 _finalAssetBalance = _assetContract.balanceOf(address(this));</span>
 1334 |     | <span class='neutral'></span>
 1335 |     | <span class='neutral'>        // Note: VIOLATES CHECKS-EFFECTS-INTERACTION pattern, make sure function is NONREENTRANT</span>
 1336 |     | <span class='neutral'>        // Effects: bookkeeping</span>
 1337 |     | <span class='unexecuted'>        _amountAssetOut = _finalAssetBalance - _initialAssetBalance;</span>
 1338 |     | <span class='unexecuted'>        if (_amountAssetOut &lt; _amountAssetOutMin) {</span>
 1339 |     | <span class='unexecuted'>            revert SlippageTooHigh(_amountAssetOutMin, _amountAssetOut);</span>
 1340 |     | <span class='neutral'>        }</span>
 1341 |     | <span class='neutral'></span>
 1342 |     | <span class='unexecuted'>        VaultAccount memory _totalBorrow = totalBorrow;</span>
 1343 |     | <span class='unexecuted'>        uint256 _sharesToRepay = _totalBorrow.toShares(_amountAssetOut, false);</span>
 1344 |     | <span class='neutral'></span>
 1345 |     | <span class='neutral'>        // Effects: write to state</span>
 1346 |     | <span class='neutral'>        // Note: setting _payer to address(this) means no actual transfer will occur.  Contract already has funds</span>
 1347 |     | <span class='unexecuted'>        _repayAsset(_totalBorrow, _amountAssetOut.toUint128(), _sharesToRepay.toUint128(), address(this), msg.sender);</span>
 1348 |     | <span class='neutral'></span>
 1349 |     | <span class='unexecuted'>        emit RepayAssetWithCollateral(msg.sender, _swapperAddress, _collateralToSwap, _amountAssetOut, _sharesToRepay);</span>
 1350 |     | <span class='neutral'>    }</span>
 1351 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairDeployer.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ====================== FraxlendPairDeployer ========================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'>// Sam Kazemian: https://github.com/samkazemian</span>
  22 |     | <span class='neutral'>// Travis Moore: https://github.com/FortisFortuna</span>
  23 |     | <span class='neutral'>// Jack Corddry: https://github.com/corddry</span>
  24 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>// ====================================================================</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>import { IERC20 } from &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  29 |     | <span class='neutral'>import { Ownable } from &quot;@openzeppelin/contracts/access/Ownable.sol&quot;;</span>
  30 |     | <span class='neutral'>import { Strings } from &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  31 |     | <span class='neutral'>import { SSTORE2 } from &quot;@rari-capital/solmate/src/utils/SSTORE2.sol&quot;;</span>
  32 |     | <span class='neutral'>import { BytesLib } from &quot;solidity-bytes-utils/contracts/BytesLib.sol&quot;;</span>
  33 |     | <span class='neutral'>import { IFraxlendWhitelist } from &quot;./interfaces/IFraxlendWhitelist.sol&quot;;</span>
  34 |     | <span class='neutral'>import { IFraxlendPair } from &quot;./interfaces/IFraxlendPair.sol&quot;;</span>
  35 |     | <span class='neutral'>import { IFraxlendPairRegistry } from &quot;./interfaces/IFraxlendPairRegistry.sol&quot;;</span>
  36 |     | <span class='neutral'>import { SafeERC20 } from &quot;./libraries/SafeERC20.sol&quot;;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>// solhint-disable no-inline-assembly</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>struct ConstructorParams {</span>
  41 |     | <span class='neutral'>    address circuitBreaker;</span>
  42 |     | <span class='neutral'>    address comptroller;</span>
  43 |     | <span class='neutral'>    address timelock;</span>
  44 |     | <span class='neutral'>    address fraxlendWhitelist;</span>
  45 |     | <span class='neutral'>    address fraxlendPairRegistry;</span>
  46 |     | <span class='neutral'>}</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='neutral'>/// @title FraxlendPairDeployer</span>
  49 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
  50 |     | <span class='neutral'>/// @notice Deploys and initializes new FraxlendPairs</span>
  51 |     | <span class='neutral'>/// @dev Uses create2 to deploy the pairs, logs an event, and records a list of all deployed pairs</span>
  52 |     | <span class='unexecuted'>contract FraxlendPairDeployer is Ownable {</span>
  53 |     | <span class='neutral'>    using Strings for uint256;</span>
  54 |     | <span class='neutral'>    using SafeERC20 for IERC20;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    // Storage</span>
  57 |     | <span class='unexecuted'>    address public contractAddress1;</span>
  58 |     | <span class='unexecuted'>    address public contractAddress2;</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    // Admin contracts</span>
  61 |     | <span class='unexecuted'>    address public circuitBreakerAddress;</span>
  62 |     | <span class='unexecuted'>    address public comptrollerAddress;</span>
  63 |     | <span class='unexecuted'>    address public timelockAddress;</span>
  64 |     | <span class='unexecuted'>    address public fraxlendPairRegistryAddress;</span>
  65 |     | <span class='unexecuted'>    address public fraxlendWhitelistAddress;</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='neutral'>    // Default swappers</span>
  68 |     | <span class='unexecuted'>    address[] public defaultSwappers;</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice Emits when a new pair is deployed</span>
  71 |     | <span class='neutral'>    /// @notice The ```LogDeploy``` event is emitted when a new Pair is deployed</span>
  72 |     | <span class='neutral'>    /// @param address_ The address of the pair</span>
  73 |     | <span class='neutral'>    /// @param asset The address of the Asset Token contract</span>
  74 |     | <span class='neutral'>    /// @param collateral The address of the Collateral Token contract</span>
  75 |     | <span class='neutral'>    /// @param name The name of the Pair</span>
  76 |     | <span class='neutral'>    /// @param configData The config data of the Pair</span>
  77 |     | <span class='neutral'>    /// @param immutables The immutables of the Pair</span>
  78 |     | <span class='neutral'>    /// @param customConfigData The custom config data of the Pair</span>
  79 |     | <span class='neutral'>    event LogDeploy(</span>
  80 |     | <span class='neutral'>        address indexed address_,</span>
  81 |     | <span class='neutral'>        address indexed asset,</span>
  82 |     | <span class='neutral'>        address indexed collateral,</span>
  83 |     | <span class='neutral'>        string name,</span>
  84 |     | <span class='neutral'>        bytes configData,</span>
  85 |     | <span class='neutral'>        bytes immutables,</span>
  86 |     | <span class='neutral'>        bytes customConfigData</span>
  87 |     | <span class='neutral'>    );</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @notice List of the names of all deployed Pairs</span>
  90 |     | <span class='unexecuted'>    address[] public deployedPairsArray;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='unexecuted'>    constructor(ConstructorParams memory _params) Ownable() {</span>
  93 |     | <span class='unexecuted'>        circuitBreakerAddress = _params.circuitBreaker;</span>
  94 |     | <span class='unexecuted'>        comptrollerAddress = _params.comptroller;</span>
  95 |     | <span class='unexecuted'>        timelockAddress = _params.timelock;</span>
  96 |     | <span class='unexecuted'>        fraxlendWhitelistAddress = _params.fraxlendWhitelist;</span>
  97 |     | <span class='unexecuted'>        fraxlendPairRegistryAddress = _params.fraxlendPairRegistry;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='unexecuted'>    function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {</span>
 101 |     | <span class='unexecuted'>        return (4, 1, 0);</span>
 102 |     | <span class='neutral'>    }</span>
 103 |     | <span class='neutral'></span>
 104 |     | <span class='neutral'>    // ============================================================================================</span>
 105 |     | <span class='neutral'>    // Functions: View Functions</span>
 106 |     | <span class='neutral'>    // ============================================================================================</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray</span>
 109 |     | <span class='neutral'>    /// @return length of array</span>
 110 |     | <span class='unexecuted'>    function deployedPairsLength() external view returns (uint256) {</span>
 111 |     | <span class='unexecuted'>        return deployedPairsArray.length;</span>
 112 |     | <span class='neutral'>    }</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    /// @notice The ```getAllPairAddresses``` function returns all pair addresses in deployedPairsArray</span>
 115 |     | <span class='neutral'>    /// @return _deployedPairs memory All deployed pair addresses</span>
 116 |     | <span class='unexecuted'>    function getAllPairAddresses() external view returns (address[] memory _deployedPairs) {</span>
 117 |     | <span class='unexecuted'>        _deployedPairs = deployedPairsArray;</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='unexecuted'>    function getNextNameSymbol(</span>
 121 |     | <span class='neutral'>        address _asset,</span>
 122 |     | <span class='neutral'>        address _collateral</span>
 123 |     | <span class='unexecuted'>    ) public view returns (string memory _name, string memory _symbol) {</span>
 124 |     | <span class='unexecuted'>        uint256 _length = IFraxlendPairRegistry(fraxlendPairRegistryAddress).deployedPairsLength();</span>
 125 |     | <span class='unexecuted'>        _name = string(</span>
 126 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 127 |     | <span class='neutral'>                &quot;Fraxlend Interest Bearing &quot;,</span>
 128 |     | <span class='unexecuted'>                IERC20(_asset).safeSymbol(),</span>
 129 |     | <span class='neutral'>                &quot; (&quot;,</span>
 130 |     | <span class='unexecuted'>                IERC20(_collateral).safeName(),</span>
 131 |     | <span class='neutral'>                &quot;)&quot;,</span>
 132 |     | <span class='neutral'>                &quot; - &quot;,</span>
 133 |     | <span class='unexecuted'>                (_length + 1).toString()</span>
 134 |     | <span class='neutral'>            )</span>
 135 |     | <span class='neutral'>        );</span>
 136 |     | <span class='unexecuted'>        _symbol = string(</span>
 137 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 138 |     | <span class='neutral'>                &quot;f&quot;,</span>
 139 |     | <span class='unexecuted'>                IERC20(_asset).safeSymbol(),</span>
 140 |     | <span class='neutral'>                &quot;(&quot;,</span>
 141 |     | <span class='unexecuted'>                IERC20(_collateral).safeSymbol(),</span>
 142 |     | <span class='neutral'>                &quot;)&quot;,</span>
 143 |     | <span class='neutral'>                &quot;-&quot;,</span>
 144 |     | <span class='unexecuted'>                (_length + 1).toString()</span>
 145 |     | <span class='neutral'>            )</span>
 146 |     | <span class='neutral'>        );</span>
 147 |     | <span class='neutral'>    }</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>    // ============================================================================================</span>
 150 |     | <span class='neutral'>    // Functions: Setters</span>
 151 |     | <span class='neutral'>    // ============================================================================================</span>
 152 |     | <span class='neutral'></span>
 153 |     | <span class='neutral'>    /// @notice The ```setCreationCode``` function sets the bytecode for the fraxlendPair</span>
 154 |     | <span class='neutral'>    /// @dev splits the data if necessary to accommodate creation code that is slightly larger than 24kb</span>
 155 |     | <span class='neutral'>    /// @param _creationCode The creationCode for the Fraxlend Pair</span>
 156 |     | <span class='unexecuted'>    function setCreationCode(bytes calldata _creationCode) external onlyOwner {</span>
 157 |     | <span class='unexecuted'>        bytes memory _firstHalf = BytesLib.slice(_creationCode, 0, 13_000);</span>
 158 |     | <span class='unexecuted'>        contractAddress1 = SSTORE2.write(_firstHalf);</span>
 159 |     | <span class='unexecuted'>        if (_creationCode.length &gt; 13_000) {</span>
 160 |     | <span class='unexecuted'>            bytes memory _secondHalf = BytesLib.slice(_creationCode, 13_000, _creationCode.length - 13_000);</span>
 161 |     | <span class='unexecuted'>            contractAddress2 = SSTORE2.write(_secondHalf);</span>
 162 |     | <span class='neutral'>        }</span>
 163 |     | <span class='neutral'>    }</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>    /// @notice The ```setDefaultSwappers``` function is used to set default list of approved swappers</span>
 166 |     | <span class='neutral'>    /// @param _swappers The list of swappers to set as default allowed</span>
 167 |     | <span class='unexecuted'>    function setDefaultSwappers(address[] memory _swappers) external onlyOwner {</span>
 168 |     | <span class='unexecuted'>        defaultSwappers = _swappers;</span>
 169 |     | <span class='neutral'>    }</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='neutral'>    /// @notice The ```SetTimelock``` event is emitted when the timelockAddress is set</span>
 172 |     | <span class='neutral'>    /// @param oldAddress The original address</span>
 173 |     | <span class='neutral'>    /// @param newAddress The new address</span>
 174 |     | <span class='neutral'>    event SetTimelock(address oldAddress, address newAddress);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='neutral'>    /// @notice The ```setTimelock``` function sets the timelockAddress</span>
 177 |     | <span class='neutral'>    /// @param _newAddress the new time lock address</span>
 178 |     | <span class='unexecuted'>    function setTimelock(address _newAddress) external onlyOwner {</span>
 179 |     | <span class='unexecuted'>        emit SetTimelock(timelockAddress, _newAddress);</span>
 180 |     | <span class='unexecuted'>        timelockAddress = _newAddress;</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    /// @notice The ```SetRegistry``` event is emitted when the fraxlendPairRegistryAddress is set</span>
 184 |     | <span class='neutral'>    /// @param oldAddress The old address</span>
 185 |     | <span class='neutral'>    /// @param newAddress The new address</span>
 186 |     | <span class='neutral'>    event SetRegistry(address oldAddress, address newAddress);</span>
 187 |     | <span class='neutral'></span>
 188 |     | <span class='neutral'>    /// @notice The ```setRegistry``` function sets the fraxlendPairRegistryAddress</span>
 189 |     | <span class='neutral'>    /// @param _newAddress The new address</span>
 190 |     | <span class='unexecuted'>    function setRegistry(address _newAddress) external onlyOwner {</span>
 191 |     | <span class='unexecuted'>        emit SetRegistry(fraxlendPairRegistryAddress, _newAddress);</span>
 192 |     | <span class='unexecuted'>        fraxlendPairRegistryAddress = _newAddress;</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    /// @notice The ```SetComptroller``` event is emitted when the comptrollerAddress is set</span>
 196 |     | <span class='neutral'>    /// @param oldAddress The old address</span>
 197 |     | <span class='neutral'>    /// @param newAddress The new address</span>
 198 |     | <span class='neutral'>    event SetComptroller(address oldAddress, address newAddress);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>    /// @notice The ```setComptroller``` function sets the comptrollerAddress</span>
 201 |     | <span class='neutral'>    /// @param _newAddress The new address</span>
 202 |     | <span class='unexecuted'>    function setComptroller(address _newAddress) external onlyOwner {</span>
 203 |     | <span class='unexecuted'>        emit SetComptroller(comptrollerAddress, _newAddress);</span>
 204 |     | <span class='unexecuted'>        comptrollerAddress = _newAddress;</span>
 205 |     | <span class='neutral'>    }</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    /// @notice The ```SetWhitelist``` event is emitted when the fraxlendWhitelistAddress is set</span>
 208 |     | <span class='neutral'>    /// @param oldAddress The old address</span>
 209 |     | <span class='neutral'>    /// @param newAddress The new address</span>
 210 |     | <span class='neutral'>    event SetWhitelist(address oldAddress, address newAddress);</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    /// @notice The ```setWhitelist``` function sets the fraxlendWhitelistAddress</span>
 213 |     | <span class='neutral'>    /// @param _newAddress The new address</span>
 214 |     | <span class='unexecuted'>    function setWhitelist(address _newAddress) external onlyOwner {</span>
 215 |     | <span class='unexecuted'>        emit SetWhitelist(fraxlendWhitelistAddress, _newAddress);</span>
 216 |     | <span class='unexecuted'>        fraxlendWhitelistAddress = _newAddress;</span>
 217 |     | <span class='neutral'>    }</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    /// @notice The ```SetCircuitBreaker``` event is emitted when the circuitBreakerAddress is set</span>
 220 |     | <span class='neutral'>    /// @param oldAddress The old address</span>
 221 |     | <span class='neutral'>    /// @param newAddress The new address</span>
 222 |     | <span class='neutral'>    event SetCircuitBreaker(address oldAddress, address newAddress);</span>
 223 |     | <span class='neutral'></span>
 224 |     | <span class='neutral'>    /// @notice The ```setCircuitBreaker``` function sets the circuitBreakerAddress</span>
 225 |     | <span class='neutral'>    /// @param _newAddress The new address</span>
 226 |     | <span class='unexecuted'>    function setCircuitBreaker(address _newAddress) external onlyOwner {</span>
 227 |     | <span class='unexecuted'>        emit SetCircuitBreaker(circuitBreakerAddress, _newAddress);</span>
 228 |     | <span class='unexecuted'>        circuitBreakerAddress = _newAddress;</span>
 229 |     | <span class='neutral'>    }</span>
 230 |     | <span class='neutral'></span>
 231 |     | <span class='neutral'>    // ============================================================================================</span>
 232 |     | <span class='neutral'>    // Functions: Internal Methods</span>
 233 |     | <span class='neutral'>    // ============================================================================================</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /// @notice The ```_deploy``` function is an internal function with deploys the pair</span>
 236 |     | <span class='neutral'>    /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)</span>
 237 |     | <span class='neutral'>    /// @param _immutables abi.encode(address _circuitBreakerAddress, address _comptrollerAddress, address _timelockAddress)</span>
 238 |     | <span class='neutral'>    /// @param _customConfigData abi.encode(string memory _nameOfContract, string memory _symbolOfContract, uint8 _decimalsOfContract)</span>
 239 |     | <span class='neutral'>    /// @return _pairAddress The address to which the Pair was deployed</span>
 240 |     | <span class='unexecuted'>    function _deploy(</span>
 241 |     | <span class='neutral'>        bytes memory _configData,</span>
 242 |     | <span class='neutral'>        bytes memory _immutables,</span>
 243 |     | <span class='neutral'>        bytes memory _customConfigData</span>
 244 |     | <span class='unexecuted'>    ) private returns (address _pairAddress) {</span>
 245 |     | <span class='neutral'>        // Get creation code</span>
 246 |     | <span class='unexecuted'>        emit Debug(&quot;GETTING CREATION CODE&quot;);</span>
 247 |     | <span class='unexecuted'>        bytes memory _creationCode = BytesLib.concat(SSTORE2.read(contractAddress1), SSTORE2.read(contractAddress2));</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='unexecuted'>        emit Debug(&quot;GETTING BYTECODE&quot;);</span>
 250 |     | <span class='neutral'>        // Get bytecode</span>
 251 |     | <span class='unexecuted'>        bytes memory bytecode = abi.encodePacked(</span>
 252 |     | <span class='unexecuted'>            _creationCode,</span>
 253 |     | <span class='unexecuted'>            abi.encode(_configData, _immutables, _customConfigData)</span>
 254 |     | <span class='neutral'>        );</span>
 255 |     | <span class='neutral'></span>
 256 |     | <span class='unexecuted'>        emit Debug(&quot;GETTING SALT&quot;);</span>
 257 |     | <span class='neutral'>        // Generate salt using constructor params</span>
 258 |     | <span class='unexecuted'>        bytes32 salt = keccak256(abi.encodePacked(_configData, _immutables, _customConfigData));</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='neutral'>        /// @solidity memory-safe-assembly</span>
 261 |     | <span class='neutral'>        assembly {</span>
 262 |     | <span class='unexecuted'>            _pairAddress := create2(0, add(bytecode, 32), mload(bytecode), salt)</span>
 263 |     | <span class='neutral'>        }</span>
 264 |     | <span class='unexecuted'>        if (_pairAddress == address(0)) revert Create2Failed();</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>        deployedPairsArray.push(_pairAddress);</span>
 267 |     | <span class='neutral'></span>
 268 |     | <span class='neutral'>        // Set additional values for FraxlendPair</span>
 269 |     | <span class='neutral'>        IFraxlendPair _fraxlendPair = IFraxlendPair(_pairAddress);</span>
 270 |     | <span class='unexecuted'>        address[] memory _defaultSwappers = defaultSwappers;</span>
 271 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _defaultSwappers.length; i++) {</span>
 272 |     | <span class='unexecuted'>            _fraxlendPair.setSwapper(_defaultSwappers[i], true);</span>
 273 |     | <span class='neutral'>        }</span>
 274 |     | <span class='neutral'></span>
 275 |     | <span class='unexecuted'>        return _pairAddress;</span>
 276 |     | <span class='neutral'>    }</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='neutral'>    // ============================================================================================</span>
 279 |     | <span class='neutral'>    // Functions: External Deploy Methods</span>
 280 |     | <span class='neutral'>    // ============================================================================================</span>
 281 |     | <span class='neutral'></span>
 282 |     | <span class='neutral'>    event Debug(string a);</span>
 283 |     | <span class='neutral'></span>
 284 |     | <span class='neutral'>    /// @notice The ```deploy``` function allows the deployment of a FraxlendPair with default values</span>
 285 |     | <span class='neutral'>    /// @param _configData abi.encode(address _asset, address _collateral, address _oracle, uint32 _maxOracleDeviation, address _rateContract, uint64 _fullUtilizationRate, uint256 _maxLTV, uint256 _cleanLiquidationFee, uint256 _dirtyLiquidationFee, uint256 _protocolLiquidationFee)</span>
 286 |     | <span class='neutral'>    /// @return _pairAddress The address to which the Pair was deployed</span>
 287 |     | <span class='unexecuted'>    function deploy(bytes memory _configData) external returns (address _pairAddress) {</span>
 288 |     | <span class='unexecuted'>        if (!IFraxlendWhitelist(fraxlendWhitelistAddress).fraxlendDeployerWhitelist(msg.sender)) {</span>
 289 |     | <span class='unexecuted'>            revert WhitelistedDeployersOnly();</span>
 290 |     | <span class='neutral'>        }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>        (address _asset, address _collateral, , , , , , , ) = abi.decode(</span>
 293 |     | <span class='unexecuted'>            _configData,</span>
 294 |     | <span class='neutral'>            (address, address, address, uint32, address, uint64, uint256, uint256, uint256)</span>
 295 |     | <span class='neutral'>        );</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='unexecuted'>        (string memory _name, string memory _symbol) = getNextNameSymbol(_asset, _collateral);</span>
 298 |     | <span class='neutral'></span>
 299 |     | <span class='unexecuted'>        bytes memory _immutables = abi.encode(circuitBreakerAddress, comptrollerAddress, timelockAddress);</span>
 300 |     | <span class='unexecuted'>        bytes memory _customConfigData = abi.encode(_name, _symbol, IERC20(_asset).safeDecimals());</span>
 301 |     | <span class='neutral'></span>
 302 |     | <span class='unexecuted'>        emit Debug(&quot;ABOUT TO DEPLOY&quot;);</span>
 303 |     | <span class='unexecuted'>        _pairAddress = _deploy(_configData, _immutables, _customConfigData);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='unexecuted'>        IFraxlendPairRegistry(fraxlendPairRegistryAddress).addPair(_pairAddress);</span>
 306 |     | <span class='neutral'></span>
 307 |     | <span class='unexecuted'>        emit LogDeploy(_pairAddress, _asset, _collateral, _name, _configData, _immutables, _customConfigData);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='neutral'>    // ============================================================================================</span>
 311 |     | <span class='neutral'>    // Functions: Admin</span>
 312 |     | <span class='neutral'>    // ============================================================================================</span>
 313 |     | <span class='neutral'></span>
 314 |     | <span class='neutral'>    /// @notice The ```globalPause``` function calls the pause() function on a given set of pair addresses</span>
 315 |     | <span class='neutral'>    /// @dev Ignores reverts when calling pause()</span>
 316 |     | <span class='neutral'>    /// @param _addresses Addresses to attempt to pause()</span>
 317 |     | <span class='neutral'>    /// @return _updatedAddresses Addresses for which pause() was successful</span>
 318 |     | <span class='unexecuted'>    function globalPause(address[] memory _addresses) external returns (address[] memory _updatedAddresses) {</span>
 319 |     | <span class='unexecuted'>        if (msg.sender != circuitBreakerAddress) revert CircuitBreakerOnly();</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>        address _pairAddress;</span>
 322 |     | <span class='unexecuted'>        uint256 _lengthOfArray = _addresses.length;</span>
 323 |     | <span class='unexecuted'>        _updatedAddresses = new address[](_lengthOfArray);</span>
 324 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _lengthOfArray; ) {</span>
 325 |     | <span class='unexecuted'>            _pairAddress = _addresses[i];</span>
 326 |     | <span class='unexecuted'>            try IFraxlendPair(_pairAddress).pause() {</span>
 327 |     | <span class='unexecuted'>                _updatedAddresses[i] = _addresses[i];</span>
 328 |     | <span class='neutral'>            } catch {}</span>
 329 |     | <span class='neutral'>            unchecked {</span>
 330 |     | <span class='unexecuted'>                i = i + 1;</span>
 331 |     | <span class='neutral'>            }</span>
 332 |     | <span class='neutral'>        }</span>
 333 |     | <span class='neutral'>    }</span>
 334 |     | <span class='neutral'></span>
 335 |     | <span class='neutral'>    // ============================================================================================</span>
 336 |     | <span class='neutral'>    // Errors</span>
 337 |     | <span class='neutral'>    // ============================================================================================</span>
 338 |     | <span class='neutral'></span>
 339 |     | <span class='neutral'>    error CircuitBreakerOnly();</span>
 340 |     | <span class='neutral'>    error WhitelistedDeployersOnly();</span>
 341 |     | <span class='neutral'>    error Create2Failed();</span>
 342 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendPairRegistry.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ====================== FraxlendPairRegistry ========================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>// ====================================================================</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>import { IERC20Metadata } from &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol&quot;;</span>
  26 |     | <span class='neutral'>import { Ownable2Step } from &quot;@openzeppelin/contracts/access/Ownable2Step.sol&quot;;</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='unexecuted'>contract FraxlendPairRegistry is Ownable2Step {</span>
  29 |     | <span class='neutral'>    /// @notice addresses of deployers allowed to add to the registry</span>
  30 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public deployers;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice List of the addresses of all deployed Pairs</span>
  33 |     | <span class='unexecuted'>    address[] public deployedPairsArray;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice name =&gt; deployed address</span>
  36 |     | <span class='unexecuted'>    mapping(string =&gt; address) public deployedPairsByName;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>    constructor(address _ownerAddress, address[] memory _initialDeployers) Ownable2Step() {</span>
  39 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _initialDeployers.length; i++) {</span>
  40 |     | <span class='unexecuted'>            deployers[_initialDeployers[i]] = true;</span>
  41 |     | <span class='neutral'>        }</span>
  42 |     | <span class='unexecuted'>        _transferOwnership(_ownerAddress);</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    // ============================================================================================</span>
  46 |     | <span class='neutral'>    // Functions: View Functions</span>
  47 |     | <span class='neutral'>    // ============================================================================================</span>
  48 |     | <span class='neutral'></span>
  49 |     | <span class='neutral'>    /// @notice The ```deployedPairsLength``` function returns the length of the deployedPairsArray</span>
  50 |     | <span class='neutral'>    /// @return length of array</span>
  51 |     | <span class='unexecuted'>    function deployedPairsLength() external view returns (uint256) {</span>
  52 |     | <span class='unexecuted'>        return deployedPairsArray.length;</span>
  53 |     | <span class='neutral'>    }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice The ```getAllPairAddresses``` function returns an array of all deployed pairs</span>
  56 |     | <span class='neutral'>    /// @return _deployedPairsArray The array of pairs deployed</span>
  57 |     | <span class='unexecuted'>    function getAllPairAddresses() external view returns (address[] memory _deployedPairsArray) {</span>
  58 |     | <span class='unexecuted'>        _deployedPairsArray = deployedPairsArray;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    // ============================================================================================</span>
  62 |     | <span class='neutral'>    // Functions: Setters</span>
  63 |     | <span class='neutral'>    // ============================================================================================</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice The ```SetDeployer``` event is called when a deployer is added or removed from the whitelist</span>
  66 |     | <span class='neutral'>    /// @param deployer The address to be set</span>
  67 |     | <span class='neutral'>    /// @param _bool The value to set (allow or disallow)</span>
  68 |     | <span class='neutral'>    event SetDeployer(address deployer, bool _bool);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    /// @notice The ```setDeployers``` function sets the deployers whitelist</span>
  71 |     | <span class='neutral'>    /// @param _deployers The deployers to set</span>
  72 |     | <span class='neutral'>    /// @param _bool The boolean to set</span>
  73 |     | <span class='unexecuted'>    function setDeployers(address[] memory _deployers, bool _bool) external onlyOwner {</span>
  74 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _deployers.length; i++) {</span>
  75 |     | <span class='unexecuted'>            deployers[_deployers[i]] = _bool;</span>
  76 |     | <span class='unexecuted'>            emit SetDeployer(_deployers[i], _bool);</span>
  77 |     | <span class='neutral'>        }</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='neutral'>    // ============================================================================================</span>
  81 |     | <span class='neutral'>    // Functions: External Methods</span>
  82 |     | <span class='neutral'>    // ============================================================================================</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='neutral'>    /// @notice The ```AddPair``` event is emitted when a new pair is added to the registry</span>
  85 |     | <span class='neutral'>    /// @param pairAddress The address of the pair</span>
  86 |     | <span class='neutral'>    event AddPair(address pairAddress);</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='neutral'>    /// @notice The ```addPair``` function adds a pair to the registry and ensures a unique name</span>
  89 |     | <span class='neutral'>    /// @param _pairAddress The address of the pair</span>
  90 |     | <span class='unexecuted'>    function addPair(address _pairAddress) external {</span>
  91 |     | <span class='neutral'>        // Ensure caller is on the whitelist</span>
  92 |     | <span class='unexecuted'>        if (!deployers[msg.sender]) revert AddressIsNotDeployer();</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>        // Add pair to the global list</span>
  95 |     | <span class='unexecuted'>        deployedPairsArray.push(_pairAddress);</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        // Pull name, ensure uniqueness and add to the name mapping</span>
  98 |     | <span class='unexecuted'>        string memory _name = IERC20Metadata(_pairAddress).name();</span>
  99 |     | <span class='unexecuted'>        if (deployedPairsByName[_name] != address(0)) revert NameMustBeUnique();</span>
 100 |     | <span class='unexecuted'>        deployedPairsByName[_name] = _pairAddress;</span>
 101 |     | <span class='neutral'></span>
 102 |     | <span class='unexecuted'>        emit AddPair(_pairAddress);</span>
 103 |     | <span class='neutral'>    }</span>
 104 |     | <span class='neutral'></span>
 105 |     | <span class='neutral'>    // ============================================================================================</span>
 106 |     | <span class='neutral'>    // Errors</span>
 107 |     | <span class='neutral'>    // ============================================================================================</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    error AddressIsNotDeployer();</span>
 110 |     | <span class='neutral'>    error NameMustBeUnique();</span>
 111 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/FraxlendWhitelist.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>// ====================================================================</span>
  5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
  6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
  7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
  8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
  9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
 10 |     | <span class='neutral'>// |                                                                  |</span>
 11 |     | <span class='neutral'>// ====================================================================</span>
 12 |     | <span class='neutral'>// ======================= FraxlendWhitelist ==========================</span>
 13 |     | <span class='neutral'>// ====================================================================</span>
 14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>// Primary Author</span>
 17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>// Reviewers</span>
 20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
 21 |     | <span class='neutral'>// Sam Kazemian: https://github.com/samkazemian</span>
 22 |     | <span class='neutral'>// Travis Moore: https://github.com/FortisFortuna</span>
 23 |     | <span class='neutral'>// Jack Corddry: https://github.com/corddry</span>
 24 |     | <span class='neutral'>// Rich Gee: https://github.com/zer0blockchain</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>// ====================================================================</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>import { Ownable2Step } from &quot;@openzeppelin/contracts/access/Ownable2Step.sol&quot;;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>contract FraxlendWhitelist is Ownable2Step {</span>
 31 |     | <span class='neutral'>    /// @notice Fraxlend Deployer Whitelist mapping.</span>
 32 |     | <span class='unexecuted'>    mapping(address =&gt; bool) public fraxlendDeployerWhitelist;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='unexecuted'>    constructor() Ownable2Step() {}</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice The ```SetFraxlendDeployerWhitelist``` event fires whenever a status is set for a given address.</span>
 37 |     | <span class='neutral'>    /// @param _address address being set.</span>
 38 |     | <span class='neutral'>    /// @param _bool approval being set.</span>
 39 |     | <span class='neutral'>    event SetFraxlendDeployerWhitelist(address indexed _address, bool _bool);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice The ```setFraxlendDeployerWhitelist``` function sets a given address to true/false for use as a custom deployer.</span>
 42 |     | <span class='neutral'>    /// @param _addresses addresses to set status for.</span>
 43 |     | <span class='neutral'>    /// @param _bool status of approval.</span>
 44 |     | <span class='unexecuted'>    function setFraxlendDeployerWhitelist(address[] calldata _addresses, bool _bool) external onlyOwner {</span>
 45 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; _addresses.length; i++) {</span>
 46 |     | <span class='unexecuted'>            fraxlendDeployerWhitelist[_addresses[i]] = _bool;</span>
 47 |     | <span class='unexecuted'>            emit SetFraxlendDeployerWhitelist(_addresses[i], _bool);</span>
 48 |     | <span class='neutral'>        }</span>
 49 |     | <span class='neutral'>    }</span>
 50 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/Timelock2Step.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ========================== Timelock2Step ===========================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>// ====================================================================</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>/// @title Timelock2Step</span>
  25 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) https://github.com/drakeevans</span>
  26 |     | <span class='neutral'>/// @dev Inspired by the OpenZeppelin&#39;s Ownable2Step contract</span>
  27 |     | <span class='neutral'>/// @notice  An abstract contract which contains 2-step transfer and renounce logic for a timelock address</span>
  28 |     | <span class='neutral'>abstract contract Timelock2Step {</span>
  29 |     | <span class='neutral'>    /// @notice The pending timelock address</span>
  30 |     | <span class='unexecuted'>    address public pendingTimelockAddress;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    /// @notice The current timelock address</span>
  33 |     | <span class='unexecuted'>    address public timelockAddress;</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    constructor() {</span>
  36 |     | <span class='unexecuted'>        timelockAddress = msg.sender;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Emitted when timelock is transferred</span>
  40 |     | <span class='neutral'>    error OnlyTimelock();</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice Emitted when pending timelock is transferred</span>
  43 |     | <span class='neutral'>    error OnlyPendingTimelock();</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    /// @notice The ```TimelockTransferStarted``` event is emitted when the timelock transfer is initiated</span>
  46 |     | <span class='neutral'>    /// @param previousTimelock The address of the previous timelock</span>
  47 |     | <span class='neutral'>    /// @param newTimelock The address of the new timelock</span>
  48 |     | <span class='neutral'>    event TimelockTransferStarted(address indexed previousTimelock, address indexed newTimelock);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice The ```TimelockTransferred``` event is emitted when the timelock transfer is completed</span>
  51 |     | <span class='neutral'>    /// @param previousTimelock The address of the previous timelock</span>
  52 |     | <span class='neutral'>    /// @param newTimelock The address of the new timelock</span>
  53 |     | <span class='neutral'>    event TimelockTransferred(address indexed previousTimelock, address indexed newTimelock);</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>    /// @notice The ```_isSenderTimelock``` function checks if msg.sender is current timelock address</span>
  56 |     | <span class='neutral'>    /// @return Whether or not msg.sender is current timelock address</span>
  57 |     | <span class='neutral'>    function _isSenderTimelock() internal view returns (bool) {</span>
  58 |     | <span class='neutral'>        return msg.sender == timelockAddress;</span>
  59 |     | <span class='neutral'>    }</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>    /// @notice The ```_requireTimelock``` function reverts if msg.sender is not current timelock address</span>
  62 |     | <span class='unexecuted'>    function _requireTimelock() internal view {</span>
  63 |     | <span class='unexecuted'>        if (msg.sender != timelockAddress) revert OnlyTimelock();</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    /// @notice The ```_isSenderPendingTimelock``` function checks if msg.sender is pending timelock address</span>
  67 |     | <span class='neutral'>    /// @return Whether or not msg.sender is pending timelock address</span>
  68 |     | <span class='neutral'>    function _isSenderPendingTimelock() internal view returns (bool) {</span>
  69 |     | <span class='neutral'>        return msg.sender == pendingTimelockAddress;</span>
  70 |     | <span class='neutral'>    }</span>
  71 |     | <span class='neutral'></span>
  72 |     | <span class='neutral'>    /// @notice The ```_requirePendingTimelock``` function reverts if msg.sender is not pending timelock address</span>
  73 |     | <span class='unexecuted'>    function _requirePendingTimelock() internal view {</span>
  74 |     | <span class='unexecuted'>        if (msg.sender != pendingTimelockAddress) revert OnlyPendingTimelock();</span>
  75 |     | <span class='neutral'>    }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>    /// @notice The ```_transferTimelock``` function initiates the timelock transfer</span>
  78 |     | <span class='neutral'>    /// @dev This function is to be implemented by a public function</span>
  79 |     | <span class='neutral'>    /// @param _newTimelock The address of the nominated (pending) timelock</span>
  80 |     | <span class='unexecuted'>    function _transferTimelock(address _newTimelock) internal {</span>
  81 |     | <span class='unexecuted'>        pendingTimelockAddress = _newTimelock;</span>
  82 |     | <span class='unexecuted'>        emit TimelockTransferStarted(timelockAddress, _newTimelock);</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @notice The ```_acceptTransferTimelock``` function completes the timelock transfer</span>
  86 |     | <span class='neutral'>    /// @dev This function is to be implemented by a public function</span>
  87 |     | <span class='unexecuted'>    function _acceptTransferTimelock() internal {</span>
  88 |     | <span class='unexecuted'>        pendingTimelockAddress = address(0);</span>
  89 |     | <span class='unexecuted'>        _setTimelock(msg.sender);</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @notice The ```_setTimelock``` function sets the timelock address</span>
  93 |     | <span class='neutral'>    /// @dev This function is to be implemented by a public function</span>
  94 |     | <span class='neutral'>    /// @param _newTimelock The address of the new timelock</span>
  95 |     | <span class='unexecuted'>    function _setTimelock(address _newTimelock) internal {</span>
  96 |     | <span class='unexecuted'>        emit TimelockTransferred(timelockAddress, _newTimelock);</span>
  97 |     | <span class='unexecuted'>        timelockAddress = _newTimelock;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'></span>
 100 |     | <span class='neutral'>    /// @notice The ```transferTimelock``` function initiates the timelock transfer</span>
 101 |     | <span class='neutral'>    /// @dev Must be called by the current timelock</span>
 102 |     | <span class='neutral'>    /// @param _newTimelock The address of the nominated (pending) timelock</span>
 103 |     | <span class='unexecuted'>    function transferTimelock(address _newTimelock) external virtual {</span>
 104 |     | <span class='unexecuted'>        _requireTimelock();</span>
 105 |     | <span class='unexecuted'>        _transferTimelock(_newTimelock);</span>
 106 |     | <span class='neutral'>    }</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice The ```acceptTransferTimelock``` function completes the timelock transfer</span>
 109 |     | <span class='neutral'>    /// @dev Must be called by the pending timelock</span>
 110 |     | <span class='unexecuted'>    function acceptTransferTimelock() external virtual {</span>
 111 |     | <span class='unexecuted'>        _requirePendingTimelock();</span>
 112 |     | <span class='unexecuted'>        _acceptTransferTimelock();</span>
 113 |     | <span class='neutral'>    }</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice The ```renounceTimelock``` function renounces the timelock after setting pending timelock to current timelock</span>
 116 |     | <span class='neutral'>    /// @dev Pending timelock must be set to current timelock before renouncing, creating a 2-step renounce process</span>
 117 |     | <span class='unexecuted'>    function renounceTimelock() external virtual {</span>
 118 |     | <span class='unexecuted'>        _requireTimelock();</span>
 119 |     | <span class='unexecuted'>        _requirePendingTimelock();</span>
 120 |     | <span class='unexecuted'>        _transferTimelock(address(0));</span>
 121 |     | <span class='unexecuted'>        _setTimelock(address(0));</span>
 122 |     | <span class='neutral'>    }</span>
 123 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/VariableInterestRate.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>// ====================================================================</span>
   5 |     | <span class='neutral'>// |     ______                   _______                             |</span>
   6 |     | <span class='neutral'>// |    / _____________ __  __   / ____(_____  ____ _____  ________   |</span>
   7 |     | <span class='neutral'>// |   / /_  / ___/ __ `| |/_/  / /_  / / __ \/ __ `/ __ \/ ___/ _ \  |</span>
   8 |     | <span class='neutral'>// |  / __/ / /  / /_/ _&gt;  &lt;   / __/ / / / / / /_/ / / / / /__/  __/  |</span>
   9 |     | <span class='neutral'>// | /_/   /_/   \__,_/_/|_|  /_/   /_/_/ /_/\__,_/_/ /_/\___/\___/   |</span>
  10 |     | <span class='neutral'>// |                                                                  |</span>
  11 |     | <span class='neutral'>// ====================================================================</span>
  12 |     | <span class='neutral'>// ====================== VariableInterestRate ========================</span>
  13 |     | <span class='neutral'>// ====================================================================</span>
  14 |     | <span class='neutral'>// Frax Finance: https://github.com/FraxFinance</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>// Primary Author</span>
  17 |     | <span class='neutral'>// Drake Evans: https://github.com/DrakeEvans</span>
  18 |     | <span class='neutral'></span>
  19 |     | <span class='neutral'>// Reviewers</span>
  20 |     | <span class='neutral'>// Dennis: https://github.com/denett</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='neutral'>// ====================================================================</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>import { Strings } from &quot;@openzeppelin/contracts/utils/Strings.sol&quot;;</span>
  25 |     | <span class='neutral'>import { IRateCalculatorV2 } from &quot;./interfaces/IRateCalculatorV2.sol&quot;;</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>/// @title A formula for calculating interest rates as a function of utilization and time</span>
  28 |     | <span class='neutral'>/// @author Drake Evans github.com/drakeevans</span>
  29 |     | <span class='neutral'>/// @notice A Contract for calculating interest rates as a function of utilization and time</span>
  30 |     | <span class='unexecuted'>contract VariableInterestRate is IRateCalculatorV2 {</span>
  31 |     | <span class='neutral'>    using Strings for uint256;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @notice The name suffix for the interest rate calculator</span>
  34 |     | <span class='unexecuted'>    string public suffix;</span>
  35 |     | <span class='neutral'></span>
  36 |     | <span class='neutral'>    // Utilization Settings</span>
  37 |     | <span class='neutral'>    /// @notice The minimum utilization wherein no adjustment to full utilization and vertex rates occurs</span>
  38 |     | <span class='unexecuted'>    uint256 public immutable MIN_TARGET_UTIL;</span>
  39 |     | <span class='neutral'>    /// @notice The maximum utilization wherein no adjustment to full utilization and vertex rates occurs</span>
  40 |     | <span class='unexecuted'>    uint256 public immutable MAX_TARGET_UTIL;</span>
  41 |     | <span class='neutral'>    /// @notice The utilization at which the slope increases</span>
  42 |     | <span class='unexecuted'>    uint256 public immutable VERTEX_UTILIZATION;</span>
  43 |     | <span class='neutral'>    /// @notice precision of utilization calculations</span>
  44 |     | <span class='unexecuted'>    uint256 public constant UTIL_PREC = 1e5; // 5 decimals</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    // Interest Rate Settings (all rates are per second), 365.24 days per year</span>
  47 |     | <span class='neutral'>    /// @notice The minimum interest rate (per second) when utilization is 100%</span>
  48 |     | <span class='unexecuted'>    uint256 public immutable MIN_FULL_UTIL_RATE; // 18 decimals</span>
  49 |     | <span class='neutral'>    /// @notice The maximum interest rate (per second) when utilization is 100%</span>
  50 |     | <span class='unexecuted'>    uint256 public immutable MAX_FULL_UTIL_RATE; // 18 decimals</span>
  51 |     | <span class='neutral'>    /// @notice The interest rate (per second) when utilization is 0%</span>
  52 |     | <span class='unexecuted'>    uint256 public immutable ZERO_UTIL_RATE; // 18 decimals</span>
  53 |     | <span class='neutral'>    /// @notice The interest rate half life in seconds, determines rate of adjustments to rate curve</span>
  54 |     | <span class='unexecuted'>    uint256 public immutable RATE_HALF_LIFE; // 1 decimals</span>
  55 |     | <span class='neutral'>    /// @notice The percent of the delta between max and min</span>
  56 |     | <span class='unexecuted'>    uint256 public immutable VERTEX_RATE_PERCENT; // 18 decimals</span>
  57 |     | <span class='neutral'>    /// @notice The precision of interest rate calculations</span>
  58 |     | <span class='unexecuted'>    uint256 public constant RATE_PREC = 1e18; // 18 decimals</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    /// @notice The ```constructor``` function</span>
  61 |     | <span class='neutral'>    /// @param _suffix The suffix of the contract name</span>
  62 |     | <span class='neutral'>    /// @param _vertexUtilization The utilization at which the slope increases</span>
  63 |     | <span class='neutral'>    /// @param _vertexRatePercentOfDelta The percent of the delta between max and min, defines vertex rate</span>
  64 |     | <span class='neutral'>    /// @param _minUtil The minimum utilization wherein no adjustment to full utilization and vertex rates occurs</span>
  65 |     | <span class='neutral'>    /// @param _maxUtil The maximum utilization wherein no adjustment to full utilization and vertex rates occurs</span>
  66 |     | <span class='neutral'>    /// @param _zeroUtilizationRate The interest rate (per second) when utilization is 0%</span>
  67 |     | <span class='neutral'>    /// @param _minFullUtilizationRate The minimum interest rate at 100% utilization</span>
  68 |     | <span class='neutral'>    /// @param _maxFullUtilizationRate The maximum interest rate at 100% utilization</span>
  69 |     | <span class='neutral'>    /// @param _rateHalfLife The half life parameter for interest rate adjustments</span>
  70 |     | <span class='unexecuted'>    constructor(</span>
  71 |     | <span class='neutral'>        string memory _suffix,</span>
  72 |     | <span class='neutral'>        uint256 _vertexUtilization,</span>
  73 |     | <span class='neutral'>        uint256 _vertexRatePercentOfDelta,</span>
  74 |     | <span class='neutral'>        uint256 _minUtil,</span>
  75 |     | <span class='neutral'>        uint256 _maxUtil,</span>
  76 |     | <span class='neutral'>        uint256 _zeroUtilizationRate,</span>
  77 |     | <span class='neutral'>        uint256 _minFullUtilizationRate,</span>
  78 |     | <span class='neutral'>        uint256 _maxFullUtilizationRate,</span>
  79 |     | <span class='neutral'>        uint256 _rateHalfLife</span>
  80 |     | <span class='neutral'>    ) {</span>
  81 |     | <span class='unexecuted'>        suffix = _suffix;</span>
  82 |     | <span class='unexecuted'>        MIN_TARGET_UTIL = _minUtil;</span>
  83 |     | <span class='unexecuted'>        MAX_TARGET_UTIL = _maxUtil;</span>
  84 |     | <span class='unexecuted'>        VERTEX_UTILIZATION = _vertexUtilization;</span>
  85 |     | <span class='unexecuted'>        ZERO_UTIL_RATE = _zeroUtilizationRate;</span>
  86 |     | <span class='unexecuted'>        MIN_FULL_UTIL_RATE = _minFullUtilizationRate;</span>
  87 |     | <span class='unexecuted'>        MAX_FULL_UTIL_RATE = _maxFullUtilizationRate;</span>
  88 |     | <span class='unexecuted'>        RATE_HALF_LIFE = _rateHalfLife;</span>
  89 |     | <span class='unexecuted'>        VERTEX_RATE_PERCENT = _vertexRatePercentOfDelta;</span>
  90 |     | <span class='neutral'>    }</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @notice The ```name``` function returns the name of the rate contract</span>
  93 |     | <span class='neutral'>    /// @return memory name of contract</span>
  94 |     | <span class='unexecuted'>    function name() external view returns (string memory) {</span>
  95 |     | <span class='unexecuted'>        return string(abi.encodePacked(&quot;Variable Rate V2 &quot;, suffix));</span>
  96 |     | <span class='neutral'>    }</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice The ```version``` function returns the semantic version of the rate contract</span>
  99 |     | <span class='neutral'>    /// @dev Follows semantic versioning</span>
 100 |     | <span class='neutral'>    /// @return _major Major version</span>
 101 |     | <span class='neutral'>    /// @return _minor Minor version</span>
 102 |     | <span class='neutral'>    /// @return _patch Patch version</span>
 103 |     | <span class='unexecuted'>    function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch) {</span>
 104 |     | <span class='unexecuted'>        _major = 2;</span>
 105 |     | <span class='neutral'>        _minor = 0;</span>
 106 |     | <span class='neutral'>        _patch = 0;</span>
 107 |     | <span class='neutral'>    }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    /// @notice The ```getFullUtilizationInterest``` function calculate the new maximum interest rate, i.e. rate when utilization is 100%</span>
 110 |     | <span class='neutral'>    /// @dev Given in interest per second</span>
 111 |     | <span class='neutral'>    /// @param _deltaTime The elapsed time since last update given in seconds</span>
 112 |     | <span class='neutral'>    /// @param _utilization The utilization %, given with 5 decimals of precision</span>
 113 |     | <span class='neutral'>    /// @param _fullUtilizationInterest The interest value when utilization is 100%, given with 18 decimals of precision</span>
 114 |     | <span class='neutral'>    /// @return _newFullUtilizationInterest The new maximum interest rate</span>
 115 |     | <span class='unexecuted'>    function getFullUtilizationInterest(</span>
 116 |     | <span class='neutral'>        uint256 _deltaTime,</span>
 117 |     | <span class='neutral'>        uint256 _utilization,</span>
 118 |     | <span class='neutral'>        uint64 _fullUtilizationInterest</span>
 119 |     | <span class='unexecuted'>    ) internal view returns (uint64 _newFullUtilizationInterest) {</span>
 120 |     | <span class='unexecuted'>        if (_utilization &lt; MIN_TARGET_UTIL) {</span>
 121 |     | <span class='neutral'>            // 18 decimals</span>
 122 |     | <span class='unexecuted'>            uint256 _deltaUtilization = ((MIN_TARGET_UTIL - _utilization) * 1e18) / MIN_TARGET_UTIL;</span>
 123 |     | <span class='neutral'>            // 36 decimals</span>
 124 |     | <span class='unexecuted'>            uint256 _decayGrowth = (RATE_HALF_LIFE * 1e36) + (_deltaUtilization * _deltaUtilization * _deltaTime);</span>
 125 |     | <span class='neutral'>            // 18 decimals</span>
 126 |     | <span class='unexecuted'>            _newFullUtilizationInterest = uint64((_fullUtilizationInterest * (RATE_HALF_LIFE * 1e36)) / _decayGrowth);</span>
 127 |     | <span class='unexecuted'>        } else if (_utilization &gt; MAX_TARGET_UTIL) {</span>
 128 |     | <span class='neutral'>            // 18 decimals</span>
 129 |     | <span class='unexecuted'>            uint256 _deltaUtilization = ((_utilization - MAX_TARGET_UTIL) * 1e18) / (UTIL_PREC - MAX_TARGET_UTIL);</span>
 130 |     | <span class='neutral'>            // 36 decimals</span>
 131 |     | <span class='unexecuted'>            uint256 _decayGrowth = (RATE_HALF_LIFE * 1e36) + (_deltaUtilization * _deltaUtilization * _deltaTime);</span>
 132 |     | <span class='neutral'>            // 18 decimals</span>
 133 |     | <span class='unexecuted'>            _newFullUtilizationInterest = uint64((_fullUtilizationInterest * _decayGrowth) / (RATE_HALF_LIFE * 1e36));</span>
 134 |     | <span class='neutral'>        } else {</span>
 135 |     | <span class='unexecuted'>            _newFullUtilizationInterest = _fullUtilizationInterest;</span>
 136 |     | <span class='neutral'>        }</span>
 137 |     | <span class='unexecuted'>        if (_newFullUtilizationInterest &gt; MAX_FULL_UTIL_RATE) {</span>
 138 |     | <span class='unexecuted'>            _newFullUtilizationInterest = uint64(MAX_FULL_UTIL_RATE);</span>
 139 |     | <span class='unexecuted'>        } else if (_newFullUtilizationInterest &lt; MIN_FULL_UTIL_RATE) {</span>
 140 |     | <span class='unexecuted'>            _newFullUtilizationInterest = uint64(MIN_FULL_UTIL_RATE);</span>
 141 |     | <span class='neutral'>        }</span>
 142 |     | <span class='neutral'>    }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    /// @notice The ```getNewRate``` function calculates interest rates using two linear functions f(utilization)</span>
 145 |     | <span class='neutral'>    /// @param _deltaTime The elapsed time since last update, given in seconds</span>
 146 |     | <span class='neutral'>    /// @param _utilization The utilization %, given with 5 decimals of precision</span>
 147 |     | <span class='neutral'>    /// @param _oldFullUtilizationInterest The interest value when utilization is 100%, given with 18 decimals of precision</span>
 148 |     | <span class='neutral'>    /// @return _newRatePerSec The new interest rate, 18 decimals of precision</span>
 149 |     | <span class='neutral'>    /// @return _newFullUtilizationInterest The new max interest rate, 18 decimals of precision</span>
 150 |     | <span class='unexecuted'>    function getNewRate(</span>
 151 |     | <span class='neutral'>        uint256 _deltaTime,</span>
 152 |     | <span class='neutral'>        uint256 _utilization,</span>
 153 |     | <span class='neutral'>        uint64 _oldFullUtilizationInterest</span>
 154 |     | <span class='unexecuted'>    ) external view returns (uint64 _newRatePerSec, uint64 _newFullUtilizationInterest) {</span>
 155 |     | <span class='unexecuted'>        _newFullUtilizationInterest = getFullUtilizationInterest(_deltaTime, _utilization, _oldFullUtilizationInterest);</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>        // _vertexInterest is calculated as the percentage of the delta between min and max interest</span>
 158 |     | <span class='unexecuted'>        uint256 _vertexInterest = (((_newFullUtilizationInterest - ZERO_UTIL_RATE) * VERTEX_RATE_PERCENT) / RATE_PREC) +</span>
 159 |     | <span class='unexecuted'>            ZERO_UTIL_RATE;</span>
 160 |     | <span class='unexecuted'>        if (_utilization &lt; VERTEX_UTILIZATION) {</span>
 161 |     | <span class='neutral'>            // For readability, the following formula is equivalent to:</span>
 162 |     | <span class='neutral'>            // uint256 _slope = ((_vertexInterest - ZERO_UTIL_RATE) * UTIL_PREC) / VERTEX_UTILIZATION;</span>
 163 |     | <span class='neutral'>            // _newRatePerSec = uint64(ZERO_UTIL_RATE + ((_utilization * _slope) / UTIL_PREC));</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='neutral'>            // 18 decimals</span>
 166 |     | <span class='unexecuted'>            _newRatePerSec = uint64(</span>
 167 |     | <span class='unexecuted'>                ZERO_UTIL_RATE + (_utilization * (_vertexInterest - ZERO_UTIL_RATE)) / VERTEX_UTILIZATION</span>
 168 |     | <span class='neutral'>            );</span>
 169 |     | <span class='neutral'>        } else {</span>
 170 |     | <span class='neutral'>            // For readability, the following formula is equivalent to:</span>
 171 |     | <span class='neutral'>            // uint256 _slope = (((_newFullUtilizationInterest - _vertexInterest) * UTIL_PREC) / (UTIL_PREC - VERTEX_UTILIZATION));</span>
 172 |     | <span class='neutral'>            // _newRatePerSec = uint64(_vertexInterest + (((_utilization - VERTEX_UTILIZATION) * _slope) / UTIL_PREC));</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>            // 18 decimals</span>
 175 |     | <span class='unexecuted'>            _newRatePerSec = uint64(</span>
 176 |     | <span class='unexecuted'>                _vertexInterest +</span>
 177 |     | <span class='unexecuted'>                    ((_utilization - VERTEX_UTILIZATION) * (_newFullUtilizationInterest - _vertexInterest)) /</span>
 178 |     | <span class='unexecuted'>                    (UTIL_PREC - VERTEX_UTILIZATION)</span>
 179 |     | <span class='neutral'>            );</span>
 180 |     | <span class='neutral'>        }</span>
 181 |     | <span class='neutral'>    }</span>
 182 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IDualOracle.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { IERC165 } from &quot;@openzeppelin/contracts/utils/introspection/IERC165.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IDualOracle is IERC165 {</span>
  7 |     | <span class='neutral'>    function ORACLE_PRECISION() external view returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function BASE_TOKEN_0() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function BASE_TOKEN_0_DECIMALS() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function BASE_TOKEN_1() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function BASE_TOKEN_1_DECIMALS() external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function getPricesNormalized() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function getPrices() external view returns (bool _isBadData, uint256 _priceLow, uint256 _priceHigh);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function NORMALIZATION_0() external view returns (int256);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function NORMALIZATION_1() external view returns (int256);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function QUOTE_TOKEN_0() external view returns (address);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function QUOTE_TOKEN_0_DECIMALS() external view returns (uint256);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>    function QUOTE_TOKEN_1() external view returns (address);</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    function QUOTE_TOKEN_1_DECIMALS() external view returns (uint256);</span>
 36 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IERC4626Extended.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: UNLICENSED</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { IERC4626 } from &quot;@openzeppelin/contracts/interfaces/IERC4626.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>interface IERC4626Extended is IERC4626 {</span>
  7 |     | <span class='neutral'>    function vaultUtilization(address vault) external view returns (uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function totalAssetsUtilized() external view returns (uint256);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function totalAvailableAssets() external view returns (uint256);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function whitelistUpdate() external;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function whitelistWithdraw(uint256 amount) external;</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function whitelistDeposit(uint256 amount) external;</span>
 18 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendPair.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.19;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>interface IFraxlendPair {</span>
   5 |     | <span class='neutral'>    function CIRCUIT_BREAKER_ADDRESS() external view returns (address);</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>    function COMPTROLLER_ADDRESS() external view returns (address);</span>
   8 |     | <span class='neutral'></span>
   9 |     | <span class='neutral'>    function DEPLOYER_ADDRESS() external view returns (address);</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>    function FRAXLEND_WHITELIST_ADDRESS() external view returns (address);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    function timelockAddress() external view returns (address);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function addCollateral(uint256 _collateralAmount, address _borrower) external;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    function addInterest()</span>
  18 |     | <span class='neutral'>        external</span>
  19 |     | <span class='neutral'>        returns (uint256 _interestEarned, uint256 _feesAmount, uint256 _feesShare, uint64 _newRate);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
  24 |     | <span class='neutral'></span>
  25 |     | <span class='neutral'>    function approvedBorrowers(address) external view returns (bool);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='neutral'>    function approvedLenders(address) external view returns (bool);</span>
  28 |     | <span class='neutral'></span>
  29 |     | <span class='neutral'>    function asset() external view returns (address);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    function borrowAsset(</span>
  34 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
  35 |     | <span class='neutral'>        uint256 _collateralAmount,</span>
  36 |     | <span class='neutral'>        address _receiver</span>
  37 |     | <span class='neutral'>    ) external returns (uint256 _shares);</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    function borrowerWhitelistActive() external view returns (bool);</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    function changeFee(uint32 _newFee) external;</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function cleanLiquidationFee() external view returns (uint256);</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='neutral'>    function collateralContract() external view returns (address);</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    function currentRateInfo()</span>
  48 |     | <span class='neutral'>        external</span>
  49 |     | <span class='neutral'>        view</span>
  50 |     | <span class='neutral'>        returns (</span>
  51 |     | <span class='neutral'>            uint32 lastBlock,</span>
  52 |     | <span class='neutral'>            uint32 feeToProtocolRate,</span>
  53 |     | <span class='neutral'>            uint64 lastTimestamp,</span>
  54 |     | <span class='neutral'>            uint64 ratePerSec,</span>
  55 |     | <span class='neutral'>            uint64 fullUtilizationRate</span>
  56 |     | <span class='neutral'>        );</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    function decreaseAllowance(address spender, uint256 subtractedValue) external returns (bool);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>    function deposit(uint256 _amount, address _receiver) external returns (uint256 _sharesReceived);</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    function dirtyLiquidationFee() external view returns (uint256);</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    function exchangeRateInfo() external view returns (uint32 lastTimestamp, uint224 exchangeRate);</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='neutral'>    function getConstants()</span>
  69 |     | <span class='neutral'>        external</span>
  70 |     | <span class='neutral'>        pure</span>
  71 |     | <span class='neutral'>        returns (</span>
  72 |     | <span class='neutral'>            uint256 _LTV_PRECISION,</span>
  73 |     | <span class='neutral'>            uint256 _LIQ_PRECISION,</span>
  74 |     | <span class='neutral'>            uint256 _UTIL_PREC,</span>
  75 |     | <span class='neutral'>            uint256 _FEE_PRECISION,</span>
  76 |     | <span class='neutral'>            uint256 _EXCHANGE_PRECISION,</span>
  77 |     | <span class='neutral'>            uint64 _DEFAULT_INT,</span>
  78 |     | <span class='neutral'>            uint16 _DEFAULT_PROTOCOL_FEE,</span>
  79 |     | <span class='neutral'>            uint256 _MAX_PROTOCOL_FEE</span>
  80 |     | <span class='neutral'>        );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    function getImmutableAddressBool()</span>
  83 |     | <span class='neutral'>        external</span>
  84 |     | <span class='neutral'>        view</span>
  85 |     | <span class='neutral'>        returns (</span>
  86 |     | <span class='neutral'>            address _assetContract,</span>
  87 |     | <span class='neutral'>            address _collateralContract,</span>
  88 |     | <span class='neutral'>            address _oracleMultiply,</span>
  89 |     | <span class='neutral'>            address _oracleDivide,</span>
  90 |     | <span class='neutral'>            address _rateContract,</span>
  91 |     | <span class='neutral'>            address _DEPLOYER_CONTRACT,</span>
  92 |     | <span class='neutral'>            address _COMPTROLLER_ADDRESS,</span>
  93 |     | <span class='neutral'>            address _FRAXLEND_WHITELIST,</span>
  94 |     | <span class='neutral'>            bool _borrowerWhitelistActive,</span>
  95 |     | <span class='neutral'>            bool _lenderWhitelistActive</span>
  96 |     | <span class='neutral'>        );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    function getImmutableUint256()</span>
  99 |     | <span class='neutral'>        external</span>
 100 |     | <span class='neutral'>        view</span>
 101 |     | <span class='neutral'>        returns (</span>
 102 |     | <span class='neutral'>            uint256 _oracleNormalization,</span>
 103 |     | <span class='neutral'>            uint256 _maxLTV,</span>
 104 |     | <span class='neutral'>            uint256 _cleanLiquidationFee,</span>
 105 |     | <span class='neutral'>            uint256 _maturityDate,</span>
 106 |     | <span class='neutral'>            uint256 _penaltyRate</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='neutral'>    function getPairAccounting()</span>
 110 |     | <span class='neutral'>        external</span>
 111 |     | <span class='neutral'>        view</span>
 112 |     | <span class='neutral'>        returns (</span>
 113 |     | <span class='neutral'>            uint128 _totalAssetAmount,</span>
 114 |     | <span class='neutral'>            uint128 _totalAssetShares,</span>
 115 |     | <span class='neutral'>            uint128 _totalBorrowAmount,</span>
 116 |     | <span class='neutral'>            uint128 _totalBorrowShares,</span>
 117 |     | <span class='neutral'>            uint256 _totalCollateral</span>
 118 |     | <span class='neutral'>        );</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    function getUserSnapshot(</span>
 121 |     | <span class='neutral'>        address _address</span>
 122 |     | <span class='neutral'>    ) external view returns (uint256 _userAssetShares, uint256 _userBorrowShares, uint256 _userCollateralBalance);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function increaseAllowance(address spender, uint256 addedValue) external returns (bool);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function lenderWhitelistActive() external view returns (bool);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='neutral'>    function leveragedPosition(</span>
 129 |     | <span class='neutral'>        address _swapperAddress,</span>
 130 |     | <span class='neutral'>        uint256 _borrowAmount,</span>
 131 |     | <span class='neutral'>        uint256 _initialCollateralAmount,</span>
 132 |     | <span class='neutral'>        uint256 _amountCollateralOutMin,</span>
 133 |     | <span class='neutral'>        address[] memory _path</span>
 134 |     | <span class='neutral'>    ) external returns (uint256 _totalCollateralBalance);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>    function liquidate(</span>
 137 |     | <span class='neutral'>        uint128 _sharesToLiquidate,</span>
 138 |     | <span class='neutral'>        uint256 _deadline,</span>
 139 |     | <span class='neutral'>        address _borrower</span>
 140 |     | <span class='neutral'>    ) external returns (uint256 _collateralForLiquidator);</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    function maturityDate() external view returns (uint256);</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='neutral'>    function maxLTV() external view returns (uint256);</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>    function maxOracleDelay() external view returns (uint256);</span>
 147 |     | <span class='neutral'></span>
 148 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    function oracleDivide() external view returns (address);</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    function oracleMultiply() external view returns (address);</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='neutral'>    function oracleNormalization() external view returns (uint256);</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 157 |     | <span class='neutral'></span>
 158 |     | <span class='neutral'>    function pause() external;</span>
 159 |     | <span class='neutral'></span>
 160 |     | <span class='neutral'>    function paused() external view returns (bool);</span>
 161 |     | <span class='neutral'></span>
 162 |     | <span class='neutral'>    function penaltyRate() external view returns (uint256);</span>
 163 |     | <span class='neutral'></span>
 164 |     | <span class='neutral'>    function rateContract() external view returns (address);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>    function redeem(uint256 _shares, address _receiver, address _owner) external returns (uint256 _amountToReturn);</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>    function removeCollateral(uint256 _collateralAmount, address _receiver) external;</span>
 169 |     | <span class='neutral'></span>
 170 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 171 |     | <span class='neutral'></span>
 172 |     | <span class='neutral'>    function repayAsset(uint256 _shares, address _borrower) external returns (uint256 _amountToRepay);</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='neutral'>    function repayAssetWithCollateral(</span>
 175 |     | <span class='neutral'>        address _swapperAddress,</span>
 176 |     | <span class='neutral'>        uint256 _collateralToSwap,</span>
 177 |     | <span class='neutral'>        uint256 _amountAssetOutMin,</span>
 178 |     | <span class='neutral'>        address[] memory _path</span>
 179 |     | <span class='neutral'>    ) external returns (uint256 _amountAssetOut);</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='neutral'>    function setApprovedBorrowers(address[] memory _borrowers, bool _approval) external;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='neutral'>    function setApprovedLenders(address[] memory _lenders, bool _approval) external;</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    function setMaxOracleDelay(uint256 _newDelay) external;</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>    function setSwapper(address _swapper, bool _approval) external;</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>    function setTimelock(address _newAddress) external;</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='neutral'>    function swappers(address) external view returns (bool);</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    function toAssetAmount(uint256 _shares, bool _roundUp) external view returns (uint256);</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>    function toAssetShares(uint256 _amount, bool _roundUp) external view returns (uint256);</span>
 198 |     | <span class='neutral'></span>
 199 |     | <span class='neutral'>    function toBorrowAmount(uint256 _shares, bool _roundUp) external view returns (uint256);</span>
 200 |     | <span class='neutral'></span>
 201 |     | <span class='neutral'>    function toBorrowShares(uint256 _amount, bool _roundUp) external view returns (uint256);</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    function totalAsset() external view returns (uint128 amount, uint128 shares);</span>
 204 |     | <span class='neutral'></span>
 205 |     | <span class='neutral'>    function totalBorrow() external view returns (uint128 amount, uint128 shares);</span>
 206 |     | <span class='neutral'></span>
 207 |     | <span class='neutral'>    function totalCollateral() external view returns (uint256);</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>    function transfer(address to, uint256 amount) external returns (bool);</span>
 212 |     | <span class='neutral'></span>
 213 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 amount) external returns (bool);</span>
 214 |     | <span class='neutral'></span>
 215 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 216 |     | <span class='neutral'></span>
 217 |     | <span class='neutral'>    function unpause() external;</span>
 218 |     | <span class='neutral'></span>
 219 |     | <span class='neutral'>    function updateExchangeRate() external returns (uint256 _exchangeRate);</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>    function userBorrowShares(address) external view returns (uint256);</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>    function userCollateralBalance(address) external view returns (uint256);</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>    function version() external pure returns (uint256 _major, uint256 _minor, uint256 _patch);</span>
 226 |     | <span class='neutral'></span>
 227 |     | <span class='neutral'>    function withdrawFees(uint128 _shares, address _recipient) external returns (uint256 _amountToTransfer);</span>
 228 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendPairRegistry.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IFraxlendPairRegistry {</span>
  5 |     | <span class='neutral'>    event AddPair(address pairAddress);</span>
  6 |     | <span class='neutral'>    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);</span>
  7 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  8 |     | <span class='neutral'>    event SetDeployer(address deployer, bool _bool);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function acceptOwnership() external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function addPair(address _pairAddress) external;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function deployedPairsArray(uint256) external view returns (address);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function deployedPairsByName(string memory) external view returns (address);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function deployedPairsLength() external view returns (uint256);</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function deployers(address) external view returns (bool);</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    function getAllPairAddresses() external view returns (address[] memory _deployedPairsArray);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    function pendingOwner() external view returns (address);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    function setDeployers(address[] memory _deployers, bool _bool) external;</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 33 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IFraxlendWhitelist.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IFraxlendWhitelist {</span>
  5 |     | <span class='neutral'>    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);</span>
  6 |     | <span class='neutral'>    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);</span>
  7 |     | <span class='neutral'>    event SetFraxlendDeployerWhitelist(address indexed _address, bool _bool);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function acceptOwnership() external;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function fraxlendDeployerWhitelist(address) external view returns (bool);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function pendingOwner() external view returns (address);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function renounceOwnership() external;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function setFraxlendDeployerWhitelist(address[] memory _addresses, bool _bool) external;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function transferOwnership(address newOwner) external;</span>
 22 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/IRateCalculatorV2.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface IRateCalculatorV2 {</span>
  5 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function version() external view returns (uint256, uint256, uint256);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function getNewRate(</span>
 10 |     | <span class='neutral'>        uint256 _deltaTime,</span>
 11 |     | <span class='neutral'>        uint256 _utilization,</span>
 12 |     | <span class='neutral'>        uint64 _maxInterest</span>
 13 |     | <span class='neutral'>    ) external view returns (uint64 _newRatePerSec, uint64 _newMaxInterest);</span>
 14 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/interfaces/ISwapper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>interface ISwapper {</span>
  5 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
  6 |     | <span class='neutral'>        uint256 amountIn,</span>
  7 |     | <span class='neutral'>        uint256 amountOutMin,</span>
  8 |     | <span class='neutral'>        address[] calldata path,</span>
  9 |     | <span class='neutral'>        address to,</span>
 10 |     | <span class='neutral'>        uint256 deadline</span>
 11 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
 12 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/BytesLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: Unlicense</span>
   2 |     | <span class='neutral'>/*</span>
   3 |     | <span class='neutral'> * @title Solidity Bytes Arrays Utils</span>
   4 |     | <span class='neutral'> * @author Gonalo S &lt;goncalo.sa@consensys.net&gt;</span>
   5 |     | <span class='neutral'> *</span>
   6 |     | <span class='neutral'> * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.</span>
   7 |     | <span class='neutral'> *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>pragma solidity &gt;=0.8.0 &lt;0.9.0;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='unexecuted'>library BytesLib {</span>
  13 |     | <span class='unexecuted'>    function concat(</span>
  14 |     | <span class='neutral'>        bytes memory _preBytes,</span>
  15 |     | <span class='neutral'>        bytes memory _postBytes</span>
  16 |     | <span class='neutral'>    )</span>
  17 |     | <span class='neutral'>        internal</span>
  18 |     | <span class='neutral'>        pure</span>
  19 |     | <span class='unexecuted'>        returns (bytes memory)</span>
  20 |     | <span class='neutral'>    {</span>
  21 |     | <span class='unexecuted'>        bytes memory tempBytes;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>        assembly {</span>
  24 |     | <span class='neutral'>            // Get a location of some free memory and store it in tempBytes as</span>
  25 |     | <span class='neutral'>            // Solidity does for memory variables.</span>
  26 |     | <span class='unexecuted'>            tempBytes := mload(0x40)</span>
  27 |     | <span class='neutral'></span>
  28 |     | <span class='neutral'>            // Store the length of the first bytes array at the beginning of</span>
  29 |     | <span class='neutral'>            // the memory for tempBytes.</span>
  30 |     | <span class='unexecuted'>            let length := mload(_preBytes)</span>
  31 |     | <span class='unexecuted'>            mstore(tempBytes, length)</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>            // Maintain a memory counter for the current write location in the</span>
  34 |     | <span class='neutral'>            // temp bytes array by adding the 32 bytes for the array length to</span>
  35 |     | <span class='neutral'>            // the starting location.</span>
  36 |     | <span class='unexecuted'>            let mc := add(tempBytes, 0x20)</span>
  37 |     | <span class='neutral'>            // Stop copying when the memory counter reaches the length of the</span>
  38 |     | <span class='neutral'>            // first bytes array.</span>
  39 |     | <span class='unexecuted'>            let end := add(mc, length)</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='unexecuted'>            for {</span>
  42 |     | <span class='neutral'>                // Initialize a copy counter to the start of the _preBytes data,</span>
  43 |     | <span class='neutral'>                // 32 bytes into its memory.</span>
  44 |     | <span class='unexecuted'>                let cc := add(_preBytes, 0x20)</span>
  45 |     | <span class='unexecuted'>            } lt(mc, end) {</span>
  46 |     | <span class='neutral'>                // Increase both counters by 32 bytes each iteration.</span>
  47 |     | <span class='unexecuted'>                mc := add(mc, 0x20)</span>
  48 |     | <span class='unexecuted'>                cc := add(cc, 0x20)</span>
  49 |     | <span class='neutral'>            } {</span>
  50 |     | <span class='neutral'>                // Write the _preBytes data into the tempBytes memory 32 bytes</span>
  51 |     | <span class='neutral'>                // at a time.</span>
  52 |     | <span class='unexecuted'>                mstore(mc, mload(cc))</span>
  53 |     | <span class='neutral'>            }</span>
  54 |     | <span class='neutral'></span>
  55 |     | <span class='neutral'>            // Add the length of _postBytes to the current length of tempBytes</span>
  56 |     | <span class='neutral'>            // and store it as the new length in the first 32 bytes of the</span>
  57 |     | <span class='neutral'>            // tempBytes memory.</span>
  58 |     | <span class='unexecuted'>            length := mload(_postBytes)</span>
  59 |     | <span class='unexecuted'>            mstore(tempBytes, add(length, mload(tempBytes)))</span>
  60 |     | <span class='neutral'></span>
  61 |     | <span class='neutral'>            // Move the memory counter back from a multiple of 0x20 to the</span>
  62 |     | <span class='neutral'>            // actual end of the _preBytes data.</span>
  63 |     | <span class='unexecuted'>            mc := end</span>
  64 |     | <span class='neutral'>            // Stop copying when the memory counter reaches the new combined</span>
  65 |     | <span class='neutral'>            // length of the arrays.</span>
  66 |     | <span class='unexecuted'>            end := add(mc, length)</span>
  67 |     | <span class='neutral'></span>
  68 |     | <span class='unexecuted'>            for {</span>
  69 |     | <span class='unexecuted'>                let cc := add(_postBytes, 0x20)</span>
  70 |     | <span class='unexecuted'>            } lt(mc, end) {</span>
  71 |     | <span class='unexecuted'>                mc := add(mc, 0x20)</span>
  72 |     | <span class='unexecuted'>                cc := add(cc, 0x20)</span>
  73 |     | <span class='neutral'>            } {</span>
  74 |     | <span class='unexecuted'>                mstore(mc, mload(cc))</span>
  75 |     | <span class='neutral'>            }</span>
  76 |     | <span class='neutral'></span>
  77 |     | <span class='neutral'>            // Update the free-memory pointer by padding our last write location</span>
  78 |     | <span class='neutral'>            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the</span>
  79 |     | <span class='neutral'>            // next 32 byte block, then round down to the nearest multiple of</span>
  80 |     | <span class='neutral'>            // 32. If the sum of the length of the two arrays is zero then add</span>
  81 |     | <span class='neutral'>            // one before rounding down to leave a blank 32 bytes (the length block with 0).</span>
  82 |     | <span class='unexecuted'>            mstore(0x40, and(</span>
  83 |     | <span class='unexecuted'>              add(add(end, iszero(add(length, mload(_preBytes)))), 31),</span>
  84 |     | <span class='unexecuted'>              not(31) // Round down to the nearest 32 bytes.</span>
  85 |     | <span class='neutral'>            ))</span>
  86 |     | <span class='neutral'>        }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>        return tempBytes;</span>
  89 |     | <span class='neutral'>    }</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {</span>
  92 |     | <span class='neutral'>        assembly {</span>
  93 |     | <span class='neutral'>            // Read the first 32 bytes of _preBytes storage, which is the length</span>
  94 |     | <span class='neutral'>            // of the array. (We don&#39;t need to use the offset into the slot</span>
  95 |     | <span class='neutral'>            // because arrays use the entire slot.)</span>
  96 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
  97 |     | <span class='neutral'>            // Arrays of 31 bytes or less have an even value in their slot,</span>
  98 |     | <span class='neutral'>            // while longer arrays have an odd value. The actual length is</span>
  99 |     | <span class='neutral'>            // the slot divided by two for odd values, and the lowest order</span>
 100 |     | <span class='neutral'>            // byte divided by two for even values.</span>
 101 |     | <span class='neutral'>            // If the slot is even, bitwise and the slot with 255 and divide by</span>
 102 |     | <span class='neutral'>            // two to get the length. If the slot is odd, bitwise and the slot</span>
 103 |     | <span class='neutral'>            // with -1 and divide by two.</span>
 104 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 105 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 106 |     | <span class='neutral'>            let newlength := add(slength, mlength)</span>
 107 |     | <span class='neutral'>            // slength can contain both the length and contents of the array</span>
 108 |     | <span class='neutral'>            // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 109 |     | <span class='neutral'>            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 110 |     | <span class='neutral'>            switch add(lt(slength, 32), lt(newlength, 32))</span>
 111 |     | <span class='neutral'>            case 2 {</span>
 112 |     | <span class='neutral'>                // Since the new array still fits in the slot, we just need to</span>
 113 |     | <span class='neutral'>                // update the contents of the slot.</span>
 114 |     | <span class='neutral'>                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length</span>
 115 |     | <span class='neutral'>                sstore(</span>
 116 |     | <span class='neutral'>                    _preBytes.slot,</span>
 117 |     | <span class='neutral'>                    // all the modifications to the slot are inside this</span>
 118 |     | <span class='neutral'>                    // next block</span>
 119 |     | <span class='neutral'>                    add(</span>
 120 |     | <span class='neutral'>                        // we can just add to the slot contents because the</span>
 121 |     | <span class='neutral'>                        // bytes we want to change are the LSBs</span>
 122 |     | <span class='neutral'>                        fslot,</span>
 123 |     | <span class='neutral'>                        add(</span>
 124 |     | <span class='neutral'>                            mul(</span>
 125 |     | <span class='neutral'>                                div(</span>
 126 |     | <span class='neutral'>                                    // load the bytes from memory</span>
 127 |     | <span class='neutral'>                                    mload(add(_postBytes, 0x20)),</span>
 128 |     | <span class='neutral'>                                    // zero all bytes to the right</span>
 129 |     | <span class='neutral'>                                    exp(0x100, sub(32, mlength))</span>
 130 |     | <span class='neutral'>                                ),</span>
 131 |     | <span class='neutral'>                                // and now shift left the number of bytes to</span>
 132 |     | <span class='neutral'>                                // leave space for the length in the slot</span>
 133 |     | <span class='neutral'>                                exp(0x100, sub(32, newlength))</span>
 134 |     | <span class='neutral'>                            ),</span>
 135 |     | <span class='neutral'>                            // increase length by the double of the memory</span>
 136 |     | <span class='neutral'>                            // bytes length</span>
 137 |     | <span class='neutral'>                            mul(mlength, 2)</span>
 138 |     | <span class='neutral'>                        )</span>
 139 |     | <span class='neutral'>                    )</span>
 140 |     | <span class='neutral'>                )</span>
 141 |     | <span class='neutral'>            }</span>
 142 |     | <span class='neutral'>            case 1 {</span>
 143 |     | <span class='neutral'>                // The stored value fits in the slot, but the combined value</span>
 144 |     | <span class='neutral'>                // will exceed it.</span>
 145 |     | <span class='neutral'>                // get the keccak hash to get the contents of the array</span>
 146 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 147 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'>                // save new length</span>
 150 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>                // The contents of the _postBytes array start 32 bytes into</span>
 153 |     | <span class='neutral'>                // the structure. Our first read should obtain the `submod`</span>
 154 |     | <span class='neutral'>                // bytes that can fit into the unused space in the last word</span>
 155 |     | <span class='neutral'>                // of the stored array. To get this, we read 32 bytes starting</span>
 156 |     | <span class='neutral'>                // from `submod`, so the data we read overlaps with the array</span>
 157 |     | <span class='neutral'>                // contents by `submod` bytes. Masking the lowest-order</span>
 158 |     | <span class='neutral'>                // `submod` bytes allows us to add that value directly to the</span>
 159 |     | <span class='neutral'>                // stored value.</span>
 160 |     | <span class='neutral'></span>
 161 |     | <span class='neutral'>                let submod := sub(32, slength)</span>
 162 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 163 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 164 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='neutral'>                sstore(</span>
 167 |     | <span class='neutral'>                    sc,</span>
 168 |     | <span class='neutral'>                    add(</span>
 169 |     | <span class='neutral'>                        and(</span>
 170 |     | <span class='neutral'>                            fslot,</span>
 171 |     | <span class='neutral'>                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00</span>
 172 |     | <span class='neutral'>                        ),</span>
 173 |     | <span class='neutral'>                        and(mload(mc), mask)</span>
 174 |     | <span class='neutral'>                    )</span>
 175 |     | <span class='neutral'>                )</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>                for {</span>
 178 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 179 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 180 |     | <span class='neutral'>                } lt(mc, end) {</span>
 181 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 182 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 183 |     | <span class='neutral'>                } {</span>
 184 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 185 |     | <span class='neutral'>                }</span>
 186 |     | <span class='neutral'></span>
 187 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 188 |     | <span class='neutral'></span>
 189 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 190 |     | <span class='neutral'>            }</span>
 191 |     | <span class='neutral'>            default {</span>
 192 |     | <span class='neutral'>                // get the keccak hash to get the contents of the array</span>
 193 |     | <span class='neutral'>                mstore(0x0, _preBytes.slot)</span>
 194 |     | <span class='neutral'>                // Start copying to the last used word of the stored array.</span>
 195 |     | <span class='neutral'>                let sc := add(keccak256(0x0, 0x20), div(slength, 32))</span>
 196 |     | <span class='neutral'></span>
 197 |     | <span class='neutral'>                // save new length</span>
 198 |     | <span class='neutral'>                sstore(_preBytes.slot, add(mul(newlength, 2), 1))</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>                // Copy over the first `submod` bytes of the new data as in</span>
 201 |     | <span class='neutral'>                // case 1 above.</span>
 202 |     | <span class='neutral'>                let slengthmod := mod(slength, 32)</span>
 203 |     | <span class='neutral'>                let mlengthmod := mod(mlength, 32)</span>
 204 |     | <span class='neutral'>                let submod := sub(32, slengthmod)</span>
 205 |     | <span class='neutral'>                let mc := add(_postBytes, submod)</span>
 206 |     | <span class='neutral'>                let end := add(_postBytes, mlength)</span>
 207 |     | <span class='neutral'>                let mask := sub(exp(0x100, submod), 1)</span>
 208 |     | <span class='neutral'></span>
 209 |     | <span class='neutral'>                sstore(sc, add(sload(sc), and(mload(mc), mask)))</span>
 210 |     | <span class='neutral'></span>
 211 |     | <span class='neutral'>                for {</span>
 212 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 213 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 214 |     | <span class='neutral'>                } lt(mc, end) {</span>
 215 |     | <span class='neutral'>                    sc := add(sc, 1)</span>
 216 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 217 |     | <span class='neutral'>                } {</span>
 218 |     | <span class='neutral'>                    sstore(sc, mload(mc))</span>
 219 |     | <span class='neutral'>                }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>                mask := exp(0x100, sub(mc, end))</span>
 222 |     | <span class='neutral'></span>
 223 |     | <span class='neutral'>                sstore(sc, mul(div(mload(mc), mask), mask))</span>
 224 |     | <span class='neutral'>            }</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    function slice(</span>
 229 |     | <span class='neutral'>        bytes memory _bytes,</span>
 230 |     | <span class='neutral'>        uint256 _start,</span>
 231 |     | <span class='neutral'>        uint256 _length</span>
 232 |     | <span class='neutral'>    )</span>
 233 |     | <span class='neutral'>        internal</span>
 234 |     | <span class='neutral'>        pure</span>
 235 |     | <span class='unexecuted'>        returns (bytes memory)</span>
 236 |     | <span class='neutral'>    {</span>
 237 |     | <span class='unexecuted'>        require(_length + 31 &gt;= _length, &quot;slice_overflow&quot;);</span>
 238 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + _length, &quot;slice_outOfBounds&quot;);</span>
 239 |     | <span class='neutral'></span>
 240 |     | <span class='unexecuted'>        bytes memory tempBytes;</span>
 241 |     | <span class='neutral'></span>
 242 |     | <span class='neutral'>        assembly {</span>
 243 |     | <span class='unexecuted'>            switch iszero(_length)</span>
 244 |     | <span class='unexecuted'>            case 0 {</span>
 245 |     | <span class='neutral'>                // Get a location of some free memory and store it in tempBytes as</span>
 246 |     | <span class='neutral'>                // Solidity does for memory variables.</span>
 247 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 248 |     | <span class='neutral'></span>
 249 |     | <span class='neutral'>                // The first word of the slice result is potentially a partial</span>
 250 |     | <span class='neutral'>                // word read from the original array. To read it, we calculate</span>
 251 |     | <span class='neutral'>                // the length of that partial word and start copying that many</span>
 252 |     | <span class='neutral'>                // bytes into the array. The first word we copy will start with</span>
 253 |     | <span class='neutral'>                // data we don&#39;t care about, but the last `lengthmod` bytes will</span>
 254 |     | <span class='neutral'>                // land at the beginning of the contents of the new array. When</span>
 255 |     | <span class='neutral'>                // we&#39;re done copying, we overwrite the full first word with</span>
 256 |     | <span class='neutral'>                // the actual length of the slice.</span>
 257 |     | <span class='unexecuted'>                let lengthmod := and(_length, 31)</span>
 258 |     | <span class='neutral'></span>
 259 |     | <span class='neutral'>                // The multiplication in the next line is necessary</span>
 260 |     | <span class='neutral'>                // because when slicing multiples of 32 bytes (lengthmod == 0)</span>
 261 |     | <span class='neutral'>                // the following copy loop was copying the origin&#39;s length</span>
 262 |     | <span class='neutral'>                // and then ending prematurely not copying everything it should.</span>
 263 |     | <span class='unexecuted'>                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))</span>
 264 |     | <span class='unexecuted'>                let end := add(mc, _length)</span>
 265 |     | <span class='neutral'></span>
 266 |     | <span class='unexecuted'>                for {</span>
 267 |     | <span class='neutral'>                    // The multiplication in the next line has the same exact purpose</span>
 268 |     | <span class='neutral'>                    // as the one above.</span>
 269 |     | <span class='unexecuted'>                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)</span>
 270 |     | <span class='unexecuted'>                } lt(mc, end) {</span>
 271 |     | <span class='unexecuted'>                    mc := add(mc, 0x20)</span>
 272 |     | <span class='unexecuted'>                    cc := add(cc, 0x20)</span>
 273 |     | <span class='neutral'>                } {</span>
 274 |     | <span class='unexecuted'>                    mstore(mc, mload(cc))</span>
 275 |     | <span class='neutral'>                }</span>
 276 |     | <span class='neutral'></span>
 277 |     | <span class='unexecuted'>                mstore(tempBytes, _length)</span>
 278 |     | <span class='neutral'></span>
 279 |     | <span class='neutral'>                //update free-memory pointer</span>
 280 |     | <span class='neutral'>                //allocating the array padded to 32 bytes like the compiler does now</span>
 281 |     | <span class='unexecuted'>                mstore(0x40, and(add(mc, 31), not(31)))</span>
 282 |     | <span class='neutral'>            }</span>
 283 |     | <span class='neutral'>            //if we want a zero-length slice let&#39;s just return a zero-length array</span>
 284 |     | <span class='neutral'>            default {</span>
 285 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
 286 |     | <span class='neutral'>                //zero out the 32 bytes slice we are about to return</span>
 287 |     | <span class='neutral'>                //we need to do it because Solidity does not garbage collect</span>
 288 |     | <span class='unexecuted'>                mstore(tempBytes, 0)</span>
 289 |     | <span class='neutral'></span>
 290 |     | <span class='unexecuted'>                mstore(0x40, add(tempBytes, 0x20))</span>
 291 |     | <span class='neutral'>            }</span>
 292 |     | <span class='neutral'>        }</span>
 293 |     | <span class='neutral'></span>
 294 |     | <span class='unexecuted'>        return tempBytes;</span>
 295 |     | <span class='neutral'>    }</span>
 296 |     | <span class='neutral'></span>
 297 |     | <span class='neutral'>    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {</span>
 298 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 20, &quot;toAddress_outOfBounds&quot;);</span>
 299 |     | <span class='neutral'>        address tempAddress;</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>        assembly {</span>
 302 |     | <span class='neutral'>            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)</span>
 303 |     | <span class='neutral'>        }</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>        return tempAddress;</span>
 306 |     | <span class='neutral'>    }</span>
 307 |     | <span class='neutral'></span>
 308 |     | <span class='neutral'>    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {</span>
 309 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 1 , &quot;toUint8_outOfBounds&quot;);</span>
 310 |     | <span class='neutral'>        uint8 tempUint;</span>
 311 |     | <span class='neutral'></span>
 312 |     | <span class='neutral'>        assembly {</span>
 313 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x1), _start))</span>
 314 |     | <span class='neutral'>        }</span>
 315 |     | <span class='neutral'></span>
 316 |     | <span class='neutral'>        return tempUint;</span>
 317 |     | <span class='neutral'>    }</span>
 318 |     | <span class='neutral'></span>
 319 |     | <span class='neutral'>    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {</span>
 320 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 2, &quot;toUint16_outOfBounds&quot;);</span>
 321 |     | <span class='neutral'>        uint16 tempUint;</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='neutral'>        assembly {</span>
 324 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x2), _start))</span>
 325 |     | <span class='neutral'>        }</span>
 326 |     | <span class='neutral'></span>
 327 |     | <span class='neutral'>        return tempUint;</span>
 328 |     | <span class='neutral'>    }</span>
 329 |     | <span class='neutral'></span>
 330 |     | <span class='neutral'>    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {</span>
 331 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 4, &quot;toUint32_outOfBounds&quot;);</span>
 332 |     | <span class='neutral'>        uint32 tempUint;</span>
 333 |     | <span class='neutral'></span>
 334 |     | <span class='neutral'>        assembly {</span>
 335 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x4), _start))</span>
 336 |     | <span class='neutral'>        }</span>
 337 |     | <span class='neutral'></span>
 338 |     | <span class='neutral'>        return tempUint;</span>
 339 |     | <span class='neutral'>    }</span>
 340 |     | <span class='neutral'></span>
 341 |     | <span class='neutral'>    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {</span>
 342 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 8, &quot;toUint64_outOfBounds&quot;);</span>
 343 |     | <span class='neutral'>        uint64 tempUint;</span>
 344 |     | <span class='neutral'></span>
 345 |     | <span class='neutral'>        assembly {</span>
 346 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x8), _start))</span>
 347 |     | <span class='neutral'>        }</span>
 348 |     | <span class='neutral'></span>
 349 |     | <span class='neutral'>        return tempUint;</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='neutral'>    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {</span>
 353 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 12, &quot;toUint96_outOfBounds&quot;);</span>
 354 |     | <span class='neutral'>        uint96 tempUint;</span>
 355 |     | <span class='neutral'></span>
 356 |     | <span class='neutral'>        assembly {</span>
 357 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0xc), _start))</span>
 358 |     | <span class='neutral'>        }</span>
 359 |     | <span class='neutral'></span>
 360 |     | <span class='neutral'>        return tempUint;</span>
 361 |     | <span class='neutral'>    }</span>
 362 |     | <span class='neutral'></span>
 363 |     | <span class='neutral'>    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {</span>
 364 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 16, &quot;toUint128_outOfBounds&quot;);</span>
 365 |     | <span class='neutral'>        uint128 tempUint;</span>
 366 |     | <span class='neutral'></span>
 367 |     | <span class='neutral'>        assembly {</span>
 368 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x10), _start))</span>
 369 |     | <span class='neutral'>        }</span>
 370 |     | <span class='neutral'></span>
 371 |     | <span class='neutral'>        return tempUint;</span>
 372 |     | <span class='neutral'>    }</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='neutral'>    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {</span>
 375 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 32, &quot;toUint256_outOfBounds&quot;);</span>
 376 |     | <span class='neutral'>        uint256 tempUint;</span>
 377 |     | <span class='neutral'></span>
 378 |     | <span class='neutral'>        assembly {</span>
 379 |     | <span class='neutral'>            tempUint := mload(add(add(_bytes, 0x20), _start))</span>
 380 |     | <span class='neutral'>        }</span>
 381 |     | <span class='neutral'></span>
 382 |     | <span class='neutral'>        return tempUint;</span>
 383 |     | <span class='neutral'>    }</span>
 384 |     | <span class='neutral'></span>
 385 |     | <span class='neutral'>    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {</span>
 386 |     | <span class='neutral'>        require(_bytes.length &gt;= _start + 32, &quot;toBytes32_outOfBounds&quot;);</span>
 387 |     | <span class='neutral'>        bytes32 tempBytes32;</span>
 388 |     | <span class='neutral'></span>
 389 |     | <span class='neutral'>        assembly {</span>
 390 |     | <span class='neutral'>            tempBytes32 := mload(add(add(_bytes, 0x20), _start))</span>
 391 |     | <span class='neutral'>        }</span>
 392 |     | <span class='neutral'></span>
 393 |     | <span class='neutral'>        return tempBytes32;</span>
 394 |     | <span class='neutral'>    }</span>
 395 |     | <span class='neutral'></span>
 396 |     | <span class='neutral'>    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {</span>
 397 |     | <span class='neutral'>        bool success = true;</span>
 398 |     | <span class='neutral'></span>
 399 |     | <span class='neutral'>        assembly {</span>
 400 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
 401 |     | <span class='neutral'></span>
 402 |     | <span class='neutral'>            // if lengths don&#39;t match the arrays are not equal</span>
 403 |     | <span class='neutral'>            switch eq(length, mload(_postBytes))</span>
 404 |     | <span class='neutral'>            case 1 {</span>
 405 |     | <span class='neutral'>                // cb is a circuit breaker in the for loop since there&#39;s</span>
 406 |     | <span class='neutral'>                //  no said feature for inline assembly loops</span>
 407 |     | <span class='neutral'>                // cb = 1 - don&#39;t breaker</span>
 408 |     | <span class='neutral'>                // cb = 0 - break</span>
 409 |     | <span class='neutral'>                let cb := 1</span>
 410 |     | <span class='neutral'></span>
 411 |     | <span class='neutral'>                let mc := add(_preBytes, 0x20)</span>
 412 |     | <span class='neutral'>                let end := add(mc, length)</span>
 413 |     | <span class='neutral'></span>
 414 |     | <span class='neutral'>                for {</span>
 415 |     | <span class='neutral'>                    let cc := add(_postBytes, 0x20)</span>
 416 |     | <span class='neutral'>                // the next line is the loop condition:</span>
 417 |     | <span class='neutral'>                // while(uint256(mc &lt; end) + cb == 2)</span>
 418 |     | <span class='neutral'>                } eq(add(lt(mc, end), cb), 2) {</span>
 419 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 420 |     | <span class='neutral'>                    cc := add(cc, 0x20)</span>
 421 |     | <span class='neutral'>                } {</span>
 422 |     | <span class='neutral'>                    // if any of these checks fails then arrays are not equal</span>
 423 |     | <span class='neutral'>                    if iszero(eq(mload(mc), mload(cc))) {</span>
 424 |     | <span class='neutral'>                        // unsuccess:</span>
 425 |     | <span class='neutral'>                        success := 0</span>
 426 |     | <span class='neutral'>                        cb := 0</span>
 427 |     | <span class='neutral'>                    }</span>
 428 |     | <span class='neutral'>                }</span>
 429 |     | <span class='neutral'>            }</span>
 430 |     | <span class='neutral'>            default {</span>
 431 |     | <span class='neutral'>                // unsuccess:</span>
 432 |     | <span class='neutral'>                success := 0</span>
 433 |     | <span class='neutral'>            }</span>
 434 |     | <span class='neutral'>        }</span>
 435 |     | <span class='neutral'></span>
 436 |     | <span class='neutral'>        return success;</span>
 437 |     | <span class='neutral'>    }</span>
 438 |     | <span class='neutral'></span>
 439 |     | <span class='neutral'>    function equal_nonAligned(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {</span>
 440 |     | <span class='neutral'>        bool success = true;</span>
 441 |     | <span class='neutral'></span>
 442 |     | <span class='neutral'>        assembly {</span>
 443 |     | <span class='neutral'>            let length := mload(_preBytes)</span>
 444 |     | <span class='neutral'></span>
 445 |     | <span class='neutral'>            // if lengths don&#39;t match the arrays are not equal</span>
 446 |     | <span class='neutral'>            switch eq(length, mload(_postBytes))</span>
 447 |     | <span class='neutral'>            case 1 {</span>
 448 |     | <span class='neutral'>                // cb is a circuit breaker in the for loop since there&#39;s</span>
 449 |     | <span class='neutral'>                //  no said feature for inline assembly loops</span>
 450 |     | <span class='neutral'>                // cb = 1 - don&#39;t breaker</span>
 451 |     | <span class='neutral'>                // cb = 0 - break</span>
 452 |     | <span class='neutral'>                let cb := 1</span>
 453 |     | <span class='neutral'></span>
 454 |     | <span class='neutral'>                let endMinusWord := add(_preBytes, length)</span>
 455 |     | <span class='neutral'>                let mc := add(_preBytes, 0x20)</span>
 456 |     | <span class='neutral'>                let cc := add(_postBytes, 0x20)</span>
 457 |     | <span class='neutral'></span>
 458 |     | <span class='neutral'>                for {</span>
 459 |     | <span class='neutral'>                // the next line is the loop condition:</span>
 460 |     | <span class='neutral'>                // while(uint256(mc &lt; endWord) + cb == 2)</span>
 461 |     | <span class='neutral'>                } eq(add(lt(mc, endMinusWord), cb), 2) {</span>
 462 |     | <span class='neutral'>                    mc := add(mc, 0x20)</span>
 463 |     | <span class='neutral'>                    cc := add(cc, 0x20)</span>
 464 |     | <span class='neutral'>                } {</span>
 465 |     | <span class='neutral'>                    // if any of these checks fails then arrays are not equal</span>
 466 |     | <span class='neutral'>                    if iszero(eq(mload(mc), mload(cc))) {</span>
 467 |     | <span class='neutral'>                        // unsuccess:</span>
 468 |     | <span class='neutral'>                        success := 0</span>
 469 |     | <span class='neutral'>                        cb := 0</span>
 470 |     | <span class='neutral'>                    }</span>
 471 |     | <span class='neutral'>                }</span>
 472 |     | <span class='neutral'></span>
 473 |     | <span class='neutral'>                // Only if still successful</span>
 474 |     | <span class='neutral'>                // For &lt;1 word tail bytes</span>
 475 |     | <span class='neutral'>                if gt(success, 0) {</span>
 476 |     | <span class='neutral'>                    // Get the remainder of length/32</span>
 477 |     | <span class='neutral'>                    // length % 32 = AND(length, 32 - 1)</span>
 478 |     | <span class='neutral'>                    let numTailBytes := and(length, 0x1f)</span>
 479 |     | <span class='neutral'>                    let mcRem := mload(mc)</span>
 480 |     | <span class='neutral'>                    let ccRem := mload(cc)</span>
 481 |     | <span class='neutral'>                    for {</span>
 482 |     | <span class='neutral'>                        let i := 0</span>
 483 |     | <span class='neutral'>                    // the next line is the loop condition:</span>
 484 |     | <span class='neutral'>                    // while(uint256(i &lt; numTailBytes) + cb == 2)</span>
 485 |     | <span class='neutral'>                    } eq(add(lt(i, numTailBytes), cb), 2) {</span>
 486 |     | <span class='neutral'>                        i := add(i, 1)</span>
 487 |     | <span class='neutral'>                    } {</span>
 488 |     | <span class='neutral'>                        if iszero(eq(byte(i, mcRem), byte(i, ccRem))) {</span>
 489 |     | <span class='neutral'>                            // unsuccess:</span>
 490 |     | <span class='neutral'>                            success := 0</span>
 491 |     | <span class='neutral'>                            cb := 0</span>
 492 |     | <span class='neutral'>                        }</span>
 493 |     | <span class='neutral'>                    }</span>
 494 |     | <span class='neutral'>                }</span>
 495 |     | <span class='neutral'>            }</span>
 496 |     | <span class='neutral'>            default {</span>
 497 |     | <span class='neutral'>                // unsuccess:</span>
 498 |     | <span class='neutral'>                success := 0</span>
 499 |     | <span class='neutral'>            }</span>
 500 |     | <span class='neutral'>        }</span>
 501 |     | <span class='neutral'></span>
 502 |     | <span class='neutral'>        return success;</span>
 503 |     | <span class='neutral'>    }</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='neutral'>    function equalStorage(</span>
 506 |     | <span class='neutral'>        bytes storage _preBytes,</span>
 507 |     | <span class='neutral'>        bytes memory _postBytes</span>
 508 |     | <span class='neutral'>    )</span>
 509 |     | <span class='neutral'>        internal</span>
 510 |     | <span class='neutral'>        view</span>
 511 |     | <span class='neutral'>        returns (bool)</span>
 512 |     | <span class='neutral'>    {</span>
 513 |     | <span class='neutral'>        bool success = true;</span>
 514 |     | <span class='neutral'></span>
 515 |     | <span class='neutral'>        assembly {</span>
 516 |     | <span class='neutral'>            // we know _preBytes_offset is 0</span>
 517 |     | <span class='neutral'>            let fslot := sload(_preBytes.slot)</span>
 518 |     | <span class='neutral'>            // Decode the length of the stored array like in concatStorage().</span>
 519 |     | <span class='neutral'>            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)</span>
 520 |     | <span class='neutral'>            let mlength := mload(_postBytes)</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='neutral'>            // if lengths don&#39;t match the arrays are not equal</span>
 523 |     | <span class='neutral'>            switch eq(slength, mlength)</span>
 524 |     | <span class='neutral'>            case 1 {</span>
 525 |     | <span class='neutral'>                // slength can contain both the length and contents of the array</span>
 526 |     | <span class='neutral'>                // if length &lt; 32 bytes so let&#39;s prepare for that</span>
 527 |     | <span class='neutral'>                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage</span>
 528 |     | <span class='neutral'>                if iszero(iszero(slength)) {</span>
 529 |     | <span class='neutral'>                    switch lt(slength, 32)</span>
 530 |     | <span class='neutral'>                    case 1 {</span>
 531 |     | <span class='neutral'>                        // blank the last byte which is the length</span>
 532 |     | <span class='neutral'>                        fslot := mul(div(fslot, 0x100), 0x100)</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {</span>
 535 |     | <span class='neutral'>                            // unsuccess:</span>
 536 |     | <span class='neutral'>                            success := 0</span>
 537 |     | <span class='neutral'>                        }</span>
 538 |     | <span class='neutral'>                    }</span>
 539 |     | <span class='neutral'>                    default {</span>
 540 |     | <span class='neutral'>                        // cb is a circuit breaker in the for loop since there&#39;s</span>
 541 |     | <span class='neutral'>                        //  no said feature for inline assembly loops</span>
 542 |     | <span class='neutral'>                        // cb = 1 - don&#39;t breaker</span>
 543 |     | <span class='neutral'>                        // cb = 0 - break</span>
 544 |     | <span class='neutral'>                        let cb := 1</span>
 545 |     | <span class='neutral'></span>
 546 |     | <span class='neutral'>                        // get the keccak hash to get the contents of the array</span>
 547 |     | <span class='neutral'>                        mstore(0x0, _preBytes.slot)</span>
 548 |     | <span class='neutral'>                        let sc := keccak256(0x0, 0x20)</span>
 549 |     | <span class='neutral'></span>
 550 |     | <span class='neutral'>                        let mc := add(_postBytes, 0x20)</span>
 551 |     | <span class='neutral'>                        let end := add(mc, mlength)</span>
 552 |     | <span class='neutral'></span>
 553 |     | <span class='neutral'>                        // the next line is the loop condition:</span>
 554 |     | <span class='neutral'>                        // while(uint256(mc &lt; end) + cb == 2)</span>
 555 |     | <span class='neutral'>                        for {} eq(add(lt(mc, end), cb), 2) {</span>
 556 |     | <span class='neutral'>                            sc := add(sc, 1)</span>
 557 |     | <span class='neutral'>                            mc := add(mc, 0x20)</span>
 558 |     | <span class='neutral'>                        } {</span>
 559 |     | <span class='neutral'>                            if iszero(eq(sload(sc), mload(mc))) {</span>
 560 |     | <span class='neutral'>                                // unsuccess:</span>
 561 |     | <span class='neutral'>                                success := 0</span>
 562 |     | <span class='neutral'>                                cb := 0</span>
 563 |     | <span class='neutral'>                            }</span>
 564 |     | <span class='neutral'>                        }</span>
 565 |     | <span class='neutral'>                    }</span>
 566 |     | <span class='neutral'>                }</span>
 567 |     | <span class='neutral'>            }</span>
 568 |     | <span class='neutral'>            default {</span>
 569 |     | <span class='neutral'>                // unsuccess:</span>
 570 |     | <span class='neutral'>                success := 0</span>
 571 |     | <span class='neutral'>            }</span>
 572 |     | <span class='neutral'>        }</span>
 573 |     | <span class='neutral'></span>
 574 |     | <span class='neutral'>        return success;</span>
 575 |     | <span class='neutral'>    }</span>
 576 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/SafeERC20.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { IERC20 } from &quot;@openzeppelin/contracts/interfaces/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import { SafeERC20 as OZSafeERC20 } from &quot;@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>// solhint-disable avoid-low-level-calls</span>
  8 |     | <span class='neutral'>// solhint-disable max-line-length</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @title SafeERC20 provides helper functions for safe transfers as well as safe metadata access</span>
 11 |     | <span class='neutral'>/// @author Library originally written by @Boring_Crypto github.com/boring_crypto, modified by Drake Evans (Frax Finance) github.com/drakeevans</span>
 12 |     | <span class='neutral'>/// @dev original: https://github.com/boringcrypto/BoringSolidity/blob/fed25c5d43cb7ce20764cd0b838e21a02ea162e9/contracts/libraries/BoringERC20.sol</span>
 13 |     | <span class='unexecuted'>library SafeERC20 {</span>
 14 |     | <span class='neutral'>    bytes4 private constant SIG_SYMBOL = 0x95d89b41; // symbol()</span>
 15 |     | <span class='neutral'>    bytes4 private constant SIG_NAME = 0x06fdde03; // name()</span>
 16 |     | <span class='neutral'>    bytes4 private constant SIG_DECIMALS = 0x313ce567; // decimals()</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='unexecuted'>    function returnDataToString(bytes memory data) internal pure returns (string memory) {</span>
 19 |     | <span class='unexecuted'>        if (data.length &gt;= 64) {</span>
 20 |     | <span class='unexecuted'>            return abi.decode(data, (string));</span>
 21 |     | <span class='unexecuted'>        } else if (data.length == 32) {</span>
 22 |     | <span class='unexecuted'>            uint8 i = 0;</span>
 23 |     | <span class='unexecuted'>            while (i &lt; 32 &amp;&amp; data[i] != 0) {</span>
 24 |     | <span class='unexecuted'>                i++;</span>
 25 |     | <span class='neutral'>            }</span>
 26 |     | <span class='unexecuted'>            bytes memory bytesArray = new bytes(i);</span>
 27 |     | <span class='unexecuted'>            for (i = 0; i &lt; 32 &amp;&amp; data[i] != 0; i++) {</span>
 28 |     | <span class='unexecuted'>                bytesArray[i] = data[i];</span>
 29 |     | <span class='neutral'>            }</span>
 30 |     | <span class='unexecuted'>            return string(bytesArray);</span>
 31 |     | <span class='neutral'>        } else {</span>
 32 |     | <span class='unexecuted'>            return &quot;???&quot;;</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.symbol version which returns &#39;???&#39; as fallback string.</span>
 37 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
 38 |     | <span class='neutral'>    /// @return (string) Token symbol.</span>
 39 |     | <span class='unexecuted'>    function safeSymbol(IERC20 token) internal view returns (string memory) {</span>
 40 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_SYMBOL));</span>
 41 |     | <span class='unexecuted'>        return success ? returnDataToString(data) : &quot;???&quot;;</span>
 42 |     | <span class='neutral'>    }</span>
 43 |     | <span class='neutral'></span>
 44 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.name version which returns &#39;???&#39; as fallback string.</span>
 45 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
 46 |     | <span class='neutral'>    /// @return (string) Token name.</span>
 47 |     | <span class='unexecuted'>    function safeName(IERC20 token) internal view returns (string memory) {</span>
 48 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_NAME));</span>
 49 |     | <span class='neutral'>        return success ? returnDataToString(data) : &quot;???&quot;;</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /// @notice Provides a safe ERC20.decimals version which returns &#39;18&#39; as fallback value.</span>
 53 |     | <span class='neutral'>    /// @param token The address of the ERC-20 token contract.</span>
 54 |     | <span class='neutral'>    /// @return (uint8) Token decimals.</span>
 55 |     | <span class='unexecuted'>    function safeDecimals(IERC20 token) internal view returns (uint8) {</span>
 56 |     | <span class='unexecuted'>        (bool success, bytes memory data) = address(token).staticcall(abi.encodeWithSelector(SIG_DECIMALS));</span>
 57 |     | <span class='unexecuted'>        return success &amp;&amp; data.length == 32 ? abi.decode(data, (uint8)) : 18;</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function safeTransfer(IERC20 token, address to, uint256 value) internal {</span>
 61 |     | <span class='unexecuted'>        OZSafeERC20.safeTransfer(token, to, value);</span>
 62 |     | <span class='neutral'>    }</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='unexecuted'>    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {</span>
 65 |     | <span class='unexecuted'>        OZSafeERC20.safeTransferFrom(token, from, to, value);</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/fraxlend/libraries/VaultAccount.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: ISC</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.19;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import { IERC4626Extended } from &quot;../interfaces/IERC4626Extended.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>struct VaultAccount {</span>
  7 |     | <span class='neutral'>    uint128 amount; // Total amount, analogous to market cap</span>
  8 |     | <span class='neutral'>    uint128 shares; // Total shares, analogous to shares outstanding</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title VaultAccount Library</span>
 12 |     | <span class='neutral'>/// @author Drake Evans (Frax Finance) github.com/drakeevans, modified from work by @Boring_Crypto github.com/boring_crypto</span>
 13 |     | <span class='neutral'>/// @notice Provides a library for use with the VaultAccount struct, provides convenient math implementations</span>
 14 |     | <span class='neutral'>/// @dev Uses uint128 to save on storage</span>
 15 |     | <span class='unexecuted'>library VaultAccountingLibrary {</span>
 16 |     | <span class='unexecuted'>    function totalAmount(VaultAccount memory total, address vault) internal view returns (uint256 amount) {</span>
 17 |     | <span class='unexecuted'>        if (vault == address(0)) {</span>
 18 |     | <span class='unexecuted'>          return total.amount;</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='unexecuted'>        return total.amount + IERC4626Extended(vault).totalAvailableAssets();</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Calculates the shares value in relationship to `amount` and `total`</span>
 24 |     | <span class='neutral'>    /// @dev Given an amount, return the appropriate number of shares</span>
 25 |     | <span class='unexecuted'>    function toShares(VaultAccount memory total, uint256 amount, bool roundUp) internal pure returns (uint256 shares) {</span>
 26 |     | <span class='unexecuted'>        if (total.amount == 0) {</span>
 27 |     | <span class='unexecuted'>            shares = amount;</span>
 28 |     | <span class='neutral'>        } else {</span>
 29 |     | <span class='unexecuted'>            shares = (amount * total.shares) / total.amount;</span>
 30 |     | <span class='unexecuted'>            if (roundUp &amp;&amp; (shares * total.amount) / total.shares &lt; amount) {</span>
 31 |     | <span class='unexecuted'>                shares = shares + 1;</span>
 32 |     | <span class='neutral'>            }</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Calculates the amount value in relationship to `shares` and `total`</span>
 37 |     | <span class='neutral'>    /// @dev Given a number of shares, returns the appropriate amount</span>
 38 |     | <span class='unexecuted'>    function toAmount(VaultAccount memory total, uint256 shares, bool roundUp) internal pure returns (uint256 amount) {</span>
 39 |     | <span class='unexecuted'>        if (total.shares == 0) {</span>
 40 |     | <span class='unexecuted'>            amount = shares;</span>
 41 |     | <span class='neutral'>        } else {</span>
 42 |     | <span class='unexecuted'>            amount = (shares * total.amount) / total.shares;</span>
 43 |     | <span class='unexecuted'>            if (roundUp &amp;&amp; (amount * total.shares) / total.amount &lt; shares) {</span>
 44 |     | <span class='neutral'>                amount = amount + 1;</span>
 45 |     | <span class='neutral'>            }</span>
 46 |     | <span class='neutral'>        }</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-3.0-or-later</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false</span>
  6 |     | <span class='unexecuted'>library TransferHelper {</span>
  7 |     | <span class='neutral'>    function safeApprove(address token, address to, uint256 value) internal {</span>
  8 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;approve(address,uint256)&#39;)));</span>
  9 |     | <span class='neutral'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));</span>
 10 |     | <span class='neutral'>        require(</span>
 11 |     | <span class='neutral'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;TransferHelper::safeApprove: approve failed&quot;</span>
 12 |     | <span class='neutral'>        );</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint256 value) internal {</span>
 16 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;transfer(address,uint256)&#39;)));</span>
 17 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));</span>
 18 |     | <span class='unexecuted'>        require(</span>
 19 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;TransferHelper::safeTransfer: transfer failed&quot;</span>
 20 |     | <span class='neutral'>        );</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function safeTransferFrom(address token, address from, address to, uint256 value) internal {</span>
 24 |     | <span class='neutral'>        // bytes4(keccak256(bytes(&#39;transferFrom(address,address,uint256)&#39;)));</span>
 25 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));</span>
 26 |     | <span class='unexecuted'>        require(</span>
 27 |     | <span class='unexecuted'>            success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))),</span>
 28 |     | <span class='neutral'>            &quot;TransferHelper::transferFrom: transferFrom failed&quot;</span>
 29 |     | <span class='neutral'>        );</span>
 30 |     | <span class='neutral'>    }</span>
 31 |     | <span class='neutral'></span>
 32 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 value) internal {</span>
 33 |     | <span class='unexecuted'>        (bool success,) = to.call{value: value}(new bytes(0));</span>
 34 |     | <span class='unexecuted'>        require(success, &quot;TransferHelper::safeTransferETH: ETH transfer failed&quot;);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'>}</span>
 37 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2ERC20.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;./libraries/SafeMath.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract UniswapV2ERC20 is IUniswapV2ERC20 {</span>
  7 |     | <span class='neutral'>    using SafeMath for uint256;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='unexecuted'>    string public constant name = &quot;Uniswap V2&quot;;</span>
 10 |     | <span class='unexecuted'>    string public constant symbol = &quot;UNI-V2&quot;;</span>
 11 |     | <span class='unexecuted'>    uint8 public constant decimals = 18;</span>
 12 |     | <span class='unexecuted'>    uint256 public totalSupply;</span>
 13 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public balanceOf;</span>
 14 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; uint256)) public allowance;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>    bytes32 public DOMAIN_SEPARATOR;</span>
 17 |     | <span class='neutral'>    // keccak256(&quot;Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)&quot;);</span>
 18 |     | <span class='unexecuted'>    bytes32 public constant PERMIT_TYPEHASH = 0x6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c9;</span>
 19 |     | <span class='unexecuted'>    mapping(address =&gt; uint256) public nonces;</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    // event Approval(address indexed owner, address indexed spender, uint value);</span>
 22 |     | <span class='neutral'>    // event Transfer(address indexed from, address indexed to, uint value);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='unexecuted'>    constructor() {</span>
 25 |     | <span class='neutral'>        uint256 chainId;</span>
 26 |     | <span class='unexecuted'>        DOMAIN_SEPARATOR = keccak256(</span>
 27 |     | <span class='unexecuted'>            abi.encode(</span>
 28 |     | <span class='unexecuted'>                keccak256(&quot;EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)&quot;),</span>
 29 |     | <span class='unexecuted'>                keccak256(bytes(name)),</span>
 30 |     | <span class='unexecuted'>                keccak256(bytes(&quot;1&quot;)),</span>
 31 |     | <span class='neutral'>                chainId,</span>
 32 |     | <span class='unexecuted'>                address(this)</span>
 33 |     | <span class='neutral'>            )</span>
 34 |     | <span class='neutral'>        );</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='unexecuted'>    function _mint(address to, uint256 value) internal {</span>
 38 |     | <span class='unexecuted'>        totalSupply = totalSupply.add(value);</span>
 39 |     | <span class='unexecuted'>        balanceOf[to] = balanceOf[to].add(value);</span>
 40 |     | <span class='unexecuted'>        emit Transfer(address(0), to, value);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function _burn(address from, uint256 value) internal {</span>
 44 |     | <span class='unexecuted'>        balanceOf[from] = balanceOf[from].sub(value);</span>
 45 |     | <span class='unexecuted'>        totalSupply = totalSupply.sub(value);</span>
 46 |     | <span class='unexecuted'>        emit Transfer(from, address(0), value);</span>
 47 |     | <span class='neutral'>    }</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>    function _approve(address owner, address spender, uint256 value) private {</span>
 50 |     | <span class='unexecuted'>        allowance[owner][spender] = value;</span>
 51 |     | <span class='unexecuted'>        emit Approval(owner, spender, value);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='unexecuted'>    function _transfer(address from, address to, uint256 value) private {</span>
 55 |     | <span class='unexecuted'>        balanceOf[from] = balanceOf[from].sub(value);</span>
 56 |     | <span class='unexecuted'>        balanceOf[to] = balanceOf[to].add(value);</span>
 57 |     | <span class='unexecuted'>        emit Transfer(from, to, value);</span>
 58 |     | <span class='neutral'>    }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='unexecuted'>    function approve(address spender, uint256 value) external returns (bool) {</span>
 61 |     | <span class='unexecuted'>        _approve(msg.sender, spender, value);</span>
 62 |     | <span class='unexecuted'>        return true;</span>
 63 |     | <span class='neutral'>    }</span>
 64 |     | <span class='neutral'></span>
 65 |     | <span class='unexecuted'>    function transfer(address to, uint256 value) external returns (bool) {</span>
 66 |     | <span class='unexecuted'>        _transfer(msg.sender, to, value);</span>
 67 |     | <span class='neutral'>        return true;</span>
 68 |     | <span class='neutral'>    }</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='unexecuted'>    function transferFrom(address from, address to, uint256 value) external returns (bool) {</span>
 71 |     | <span class='unexecuted'>        if (allowance[from][msg.sender] != type(uint256).max) {</span>
 72 |     | <span class='unexecuted'>            allowance[from][msg.sender] = allowance[from][msg.sender].sub(value);</span>
 73 |     | <span class='neutral'>        }</span>
 74 |     | <span class='unexecuted'>        _transfer(from, to, value);</span>
 75 |     | <span class='unexecuted'>        return true;</span>
 76 |     | <span class='neutral'>    }</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='unexecuted'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 79 |     | <span class='neutral'>        external</span>
 80 |     | <span class='unexecuted'>    {</span>
 81 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;UniswapV2: EXPIRED&quot;);</span>
 82 |     | <span class='unexecuted'>        bytes32 digest = keccak256(</span>
 83 |     | <span class='unexecuted'>            abi.encodePacked(</span>
 84 |     | <span class='neutral'>                &quot;\x19\x01&quot;,</span>
 85 |     | <span class='unexecuted'>                DOMAIN_SEPARATOR,</span>
 86 |     | <span class='unexecuted'>                keccak256(abi.encode(PERMIT_TYPEHASH, owner, spender, value, nonces[owner]++, deadline))</span>
 87 |     | <span class='neutral'>            )</span>
 88 |     | <span class='neutral'>        );</span>
 89 |     | <span class='unexecuted'>        address recoveredAddress = ecrecover(digest, v, r, s);</span>
 90 |     | <span class='unexecuted'>        require(recoveredAddress != address(0) &amp;&amp; recoveredAddress == owner, &quot;UniswapV2: INVALID_SIGNATURE&quot;);</span>
 91 |     | <span class='unexecuted'>        _approve(owner, spender, value);</span>
 92 |     | <span class='neutral'>    }</span>
 93 |     | <span class='neutral'>}</span>
 94 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2Factory.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;./UniswapV2Pair.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>contract UniswapV2Factory is IUniswapV2Factory {</span>
  7 |     | <span class='unexecuted'>    address public feeTo;</span>
  8 |     | <span class='unexecuted'>    address public feeToSetter;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; address)) public getPair;</span>
 11 |     | <span class='unexecuted'>    address[] public allPairs;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    // event PairCreated(address indexed token0, address indexed token1, address pair, uint);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='unexecuted'>    constructor(address _feeToSetter) {</span>
 16 |     | <span class='unexecuted'>        feeToSetter = _feeToSetter;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='unexecuted'>    function allPairsLength() external view returns (uint256) {</span>
 20 |     | <span class='unexecuted'>        return allPairs.length;</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    function createPair(address tokenA, address tokenB) external returns (address pair) {</span>
 24 |     | <span class='unexecuted'>        require(tokenA != tokenB, &quot;UniswapV2: IDENTICAL_ADDRESSES&quot;);</span>
 25 |     | <span class='unexecuted'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 26 |     | <span class='unexecuted'>        require(token0 != address(0), &quot;UniswapV2: ZERO_ADDRESS&quot;);</span>
 27 |     | <span class='unexecuted'>        require(getPair[token0][token1] == address(0), &quot;UniswapV2: PAIR_EXISTS&quot;); // single check is sufficient</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='unexecuted'>        bytes memory bytecode = type(UniswapV2Pair).creationCode;</span>
 30 |     | <span class='unexecuted'>        bytes32 salt = keccak256(abi.encodePacked(token0, token1));</span>
 31 |     | <span class='neutral'>        assembly {</span>
 32 |     | <span class='unexecuted'>            pair := create2(0, add(bytecode, 32), mload(bytecode), salt)</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).initialize(token0, token1);</span>
 36 |     | <span class='unexecuted'>        getPair[token0][token1] = pair;</span>
 37 |     | <span class='unexecuted'>        getPair[token1][token0] = pair; // populate mapping in the reverse direction</span>
 38 |     | <span class='unexecuted'>        allPairs.push(pair);</span>
 39 |     | <span class='neutral'></span>
 40 |     | <span class='unexecuted'>        emit PairCreated(token0, token1, pair, allPairs.length);</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='unexecuted'>    function setFeeTo(address _feeTo) external {</span>
 44 |     | <span class='unexecuted'>        require(msg.sender == feeToSetter, &quot;UniswapV2: FORBIDDEN&quot;);</span>
 45 |     | <span class='unexecuted'>        feeTo = _feeTo;</span>
 46 |     | <span class='neutral'>    }</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='unexecuted'>    function setFeeToSetter(address _feeToSetter) external {</span>
 49 |     | <span class='unexecuted'>        require(msg.sender == feeToSetter, &quot;UniswapV2: FORBIDDEN&quot;);</span>
 50 |     | <span class='unexecuted'>        feeToSetter = _feeToSetter;</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'>}</span>
 53 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/UniswapV2Pair.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2Pair.sol&quot;;</span>
   4 |     | <span class='neutral'>import &quot;./UniswapV2ERC20.sol&quot;;</span>
   5 |     | <span class='neutral'>import &quot;./libraries/Math.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;./libraries/UQ112x112.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./interfaces/IERC20.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2Factory.sol&quot;;</span>
   9 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2Callee.sol&quot;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>contract UniswapV2Pair is UniswapV2ERC20 {</span>
  12 |     | <span class='neutral'>    using SafeMath for uint256;</span>
  13 |     | <span class='neutral'>    using UQ112x112 for uint224;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='unexecuted'>    uint256 public constant MINIMUM_LIQUIDITY = 10 ** 3;</span>
  16 |     | <span class='unexecuted'>    bytes4 private constant SELECTOR = bytes4(keccak256(bytes(&quot;transfer(address,uint256)&quot;)));</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='unexecuted'>    address public factory;</span>
  19 |     | <span class='unexecuted'>    address public token0;</span>
  20 |     | <span class='unexecuted'>    address public token1;</span>
  21 |     | <span class='neutral'></span>
  22 |     | <span class='unexecuted'>    uint112 public reserve0; // uses single storage slot, accessible via getReserves</span>
  23 |     | <span class='unexecuted'>    uint112 public reserve1; // uses single storage slot, accessible via getReserves</span>
  24 |     | <span class='unexecuted'>    uint32 public blockTimestampLast; // uses single storage slot, accessible via getReserves</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='unexecuted'>    uint256 public price0CumulativeLast;</span>
  27 |     | <span class='unexecuted'>    uint256 public price1CumulativeLast;</span>
  28 |     | <span class='unexecuted'>    uint256 public kLast; // reserve0 * reserve1, as of immediately after the most recent liquidity event</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>    uint256 private unlocked = 1;</span>
  31 |     | <span class='neutral'></span>
  32 |     | <span class='neutral'>    modifier lock() {</span>
  33 |     | <span class='unexecuted'>        require(unlocked == 1, &quot;UniswapV2: LOCKED&quot;);</span>
  34 |     | <span class='unexecuted'>        unlocked = 0;</span>
  35 |     | <span class='neutral'>        _;</span>
  36 |     | <span class='unexecuted'>        unlocked = 1;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='unexecuted'>    function getReserves() public view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast) {</span>
  40 |     | <span class='unexecuted'>        _reserve0 = reserve0;</span>
  41 |     | <span class='unexecuted'>        _reserve1 = reserve1;</span>
  42 |     | <span class='unexecuted'>        _blockTimestampLast = blockTimestampLast;</span>
  43 |     | <span class='neutral'>    }</span>
  44 |     | <span class='neutral'></span>
  45 |     | <span class='unexecuted'>    function _safeTransfer(address token, address to, uint256 value) private {</span>
  46 |     | <span class='unexecuted'>        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(SELECTOR, to, value));</span>
  47 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;UniswapV2: TRANSFER_FAILED&quot;);</span>
  48 |     | <span class='neutral'>    }</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    event Mint(address indexed sender, uint256 amount0, uint256 amount1);</span>
  51 |     | <span class='neutral'>    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);</span>
  52 |     | <span class='neutral'>    event Swap(</span>
  53 |     | <span class='neutral'>        address indexed sender,</span>
  54 |     | <span class='neutral'>        uint256 amount0In,</span>
  55 |     | <span class='neutral'>        uint256 amount1In,</span>
  56 |     | <span class='neutral'>        uint256 amount0Out,</span>
  57 |     | <span class='neutral'>        uint256 amount1Out,</span>
  58 |     | <span class='neutral'>        address indexed to</span>
  59 |     | <span class='neutral'>    );</span>
  60 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    constructor() {</span>
  63 |     | <span class='unexecuted'>        factory = msg.sender;</span>
  64 |     | <span class='neutral'>    }</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>    // called once by the factory at time of deployment</span>
  67 |     | <span class='unexecuted'>    function initialize(address _token0, address _token1) external {</span>
  68 |     | <span class='unexecuted'>        require(msg.sender == factory, &quot;UniswapV2: FORBIDDEN&quot;); // sufficient check</span>
  69 |     | <span class='unexecuted'>        token0 = _token0;</span>
  70 |     | <span class='unexecuted'>        token1 = _token1;</span>
  71 |     | <span class='neutral'>    }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='neutral'>    // update reserves and, on the first call per block, price accumulators</span>
  74 |     | <span class='unexecuted'>    function _update(uint256 balance0, uint256 balance1, uint112 _reserve0, uint112 _reserve1) private {</span>
  75 |     | <span class='unexecuted'>        require(balance0 &lt;= type(uint112).max &amp;&amp; balance1 &lt;= type(uint112).max, &quot;UniswapV2: OVERFLOW&quot;);</span>
  76 |     | <span class='unexecuted'>        uint32 blockTimestamp = uint32(block.timestamp % 2 ** 32);</span>
  77 |     | <span class='unexecuted'>        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired</span>
  78 |     | <span class='unexecuted'>        if (timeElapsed &gt; 0 &amp;&amp; _reserve0 != 0 &amp;&amp; _reserve1 != 0) {</span>
  79 |     | <span class='neutral'>            // * never overflows, and + overflow is desired</span>
  80 |     | <span class='unexecuted'>            price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed;</span>
  81 |     | <span class='unexecuted'>            price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed;</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='unexecuted'>        reserve0 = uint112(balance0);</span>
  84 |     | <span class='unexecuted'>        reserve1 = uint112(balance1);</span>
  85 |     | <span class='unexecuted'>        blockTimestampLast = blockTimestamp;</span>
  86 |     | <span class='unexecuted'>        emit Sync(reserve0, reserve1);</span>
  87 |     | <span class='neutral'>    }</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    // if fee is on, mint liquidity equivalent to 1/6th of the growth in sqrt(k)</span>
  90 |     | <span class='unexecuted'>    function _mintFee(uint112 _reserve0, uint112 _reserve1) private returns (bool feeOn) {</span>
  91 |     | <span class='unexecuted'>        address feeTo = IUniswapV2Factory(factory).feeTo();</span>
  92 |     | <span class='unexecuted'>        feeOn = feeTo != address(0);</span>
  93 |     | <span class='unexecuted'>        uint256 _kLast = kLast; // gas savings</span>
  94 |     | <span class='unexecuted'>        if (feeOn) {</span>
  95 |     | <span class='unexecuted'>            if (_kLast != 0) {</span>
  96 |     | <span class='unexecuted'>                uint256 rootK = Math.sqrt(uint256(_reserve0).mul(_reserve1));</span>
  97 |     | <span class='unexecuted'>                uint256 rootKLast = Math.sqrt(_kLast);</span>
  98 |     | <span class='unexecuted'>                if (rootK &gt; rootKLast) {</span>
  99 |     | <span class='unexecuted'>                    uint256 numerator = totalSupply.mul(rootK.sub(rootKLast));</span>
 100 |     | <span class='unexecuted'>                    uint256 denominator = rootK.mul(5).add(rootKLast);</span>
 101 |     | <span class='unexecuted'>                    uint256 liquidity = numerator / denominator;</span>
 102 |     | <span class='unexecuted'>                    if (liquidity &gt; 0) _mint(feeTo, liquidity);</span>
 103 |     | <span class='neutral'>                }</span>
 104 |     | <span class='neutral'>            }</span>
 105 |     | <span class='unexecuted'>        } else if (_kLast != 0) {</span>
 106 |     | <span class='unexecuted'>            kLast = 0;</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 111 |     | <span class='unexecuted'>    function mint(address to) external lock returns (uint256 liquidity) {</span>
 112 |     | <span class='unexecuted'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 113 |     | <span class='unexecuted'>        uint256 balance0 = IERC20(token0).balanceOf(address(this));</span>
 114 |     | <span class='unexecuted'>        uint256 balance1 = IERC20(token1).balanceOf(address(this));</span>
 115 |     | <span class='unexecuted'>        uint256 amount0 = balance0.sub(_reserve0);</span>
 116 |     | <span class='unexecuted'>        uint256 amount1 = balance1.sub(_reserve1);</span>
 117 |     | <span class='neutral'></span>
 118 |     | <span class='unexecuted'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 119 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 120 |     | <span class='unexecuted'>        if (_totalSupply == 0) {</span>
 121 |     | <span class='unexecuted'>            liquidity = Math.sqrt(amount0.mul(amount1)).sub(MINIMUM_LIQUIDITY);</span>
 122 |     | <span class='unexecuted'>            _mint(address(0), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens</span>
 123 |     | <span class='neutral'>        } else {</span>
 124 |     | <span class='unexecuted'>            liquidity = Math.min(amount0.mul(_totalSupply) / _reserve0, amount1.mul(_totalSupply) / _reserve1);</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='unexecuted'>        require(liquidity &gt; 0, &quot;UniswapV2: INSUFFICIENT_LIQUIDITY_MINTED&quot;);</span>
 127 |     | <span class='unexecuted'>        _mint(to, liquidity);</span>
 128 |     | <span class='neutral'></span>
 129 |     | <span class='unexecuted'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 130 |     | <span class='unexecuted'>        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span>
 131 |     | <span class='unexecuted'>        emit Mint(msg.sender, amount0, amount1);</span>
 132 |     | <span class='neutral'>    }</span>
 133 |     | <span class='neutral'></span>
 134 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 135 |     | <span class='unexecuted'>    function burn(address to) external lock returns (uint256 amount0, uint256 amount1) {</span>
 136 |     | <span class='unexecuted'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 137 |     | <span class='unexecuted'>        address _token0 = token0; // gas savings</span>
 138 |     | <span class='unexecuted'>        address _token1 = token1; // gas savings</span>
 139 |     | <span class='unexecuted'>        uint256 balance0 = IERC20(_token0).balanceOf(address(this));</span>
 140 |     | <span class='unexecuted'>        uint256 balance1 = IERC20(_token1).balanceOf(address(this));</span>
 141 |     | <span class='unexecuted'>        uint256 liquidity = balanceOf[address(this)];</span>
 142 |     | <span class='neutral'></span>
 143 |     | <span class='unexecuted'>        bool feeOn = _mintFee(_reserve0, _reserve1);</span>
 144 |     | <span class='unexecuted'>        uint256 _totalSupply = totalSupply; // gas savings, must be defined here since totalSupply can update in _mintFee</span>
 145 |     | <span class='unexecuted'>        amount0 = liquidity.mul(balance0) / _totalSupply; // using balances ensures pro-rata distribution</span>
 146 |     | <span class='unexecuted'>        amount1 = liquidity.mul(balance1) / _totalSupply; // using balances ensures pro-rata distribution</span>
 147 |     | <span class='unexecuted'>        require(amount0 &gt; 0 &amp;&amp; amount1 &gt; 0, &quot;UniswapV2: INSUFFICIENT_LIQUIDITY_BURNED&quot;);</span>
 148 |     | <span class='unexecuted'>        _burn(address(this), liquidity);</span>
 149 |     | <span class='unexecuted'>        _safeTransfer(_token0, to, amount0);</span>
 150 |     | <span class='unexecuted'>        _safeTransfer(_token1, to, amount1);</span>
 151 |     | <span class='unexecuted'>        balance0 = IERC20(_token0).balanceOf(address(this));</span>
 152 |     | <span class='unexecuted'>        balance1 = IERC20(_token1).balanceOf(address(this));</span>
 153 |     | <span class='neutral'></span>
 154 |     | <span class='unexecuted'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 155 |     | <span class='unexecuted'>        if (feeOn) kLast = uint256(reserve0).mul(reserve1); // reserve0 and reserve1 are up-to-date</span>
 156 |     | <span class='unexecuted'>        emit Burn(msg.sender, amount0, amount1, to);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    // this low-level function should be called from a contract which performs important safety checks</span>
 160 |     | <span class='unexecuted'>    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external lock {</span>
 161 |     | <span class='unexecuted'>        require(amount0Out &gt; 0 || amount1Out &gt; 0, &quot;UniswapV2: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 162 |     | <span class='unexecuted'>        (uint112 _reserve0, uint112 _reserve1,) = getReserves(); // gas savings</span>
 163 |     | <span class='unexecuted'>        require(amount0Out &lt; _reserve0 &amp;&amp; amount1Out &lt; _reserve1, &quot;UniswapV2: INSUFFICIENT_LIQUIDITY&quot;);</span>
 164 |     | <span class='neutral'></span>
 165 |     | <span class='unexecuted'>        uint256 balance0;</span>
 166 |     | <span class='neutral'>        uint256 balance1;</span>
 167 |     | <span class='unexecuted'>        {</span>
 168 |     | <span class='neutral'>            // scope for _token{0,1}, avoids stack too deep errors</span>
 169 |     | <span class='unexecuted'>            address _token0 = token0;</span>
 170 |     | <span class='unexecuted'>            address _token1 = token1;</span>
 171 |     | <span class='unexecuted'>            require(to != _token0 &amp;&amp; to != _token1, &quot;UniswapV2: INVALID_TO&quot;);</span>
 172 |     | <span class='unexecuted'>            if (amount0Out &gt; 0) _safeTransfer(_token0, to, amount0Out); // optimistically transfer tokens</span>
 173 |     | <span class='unexecuted'>            if (amount1Out &gt; 0) _safeTransfer(_token1, to, amount1Out); // optimistically transfer tokens</span>
 174 |     | <span class='unexecuted'>            if (data.length &gt; 0) IUniswapV2Callee(to).uniswapV2Call(msg.sender, amount0Out, amount1Out, data);</span>
 175 |     | <span class='unexecuted'>            balance0 = IERC20(_token0).balanceOf(address(this));</span>
 176 |     | <span class='unexecuted'>            balance1 = IERC20(_token1).balanceOf(address(this));</span>
 177 |     | <span class='neutral'>        }</span>
 178 |     | <span class='unexecuted'>        uint256 amount0In = balance0 &gt; _reserve0 - amount0Out ? balance0 - (_reserve0 - amount0Out) : 0;</span>
 179 |     | <span class='unexecuted'>        uint256 amount1In = balance1 &gt; _reserve1 - amount1Out ? balance1 - (_reserve1 - amount1Out) : 0;</span>
 180 |     | <span class='unexecuted'>        require(amount0In &gt; 0 || amount1In &gt; 0, &quot;UniswapV2: INSUFFICIENT_INPUT_AMOUNT&quot;);</span>
 181 |     | <span class='unexecuted'>        {</span>
 182 |     | <span class='neutral'>            // scope for reserve{0,1}Adjusted, avoids stack too deep errors</span>
 183 |     | <span class='unexecuted'>            uint256 balance0Adjusted = balance0.mul(1000).sub(amount0In.mul(3));</span>
 184 |     | <span class='unexecuted'>            uint256 balance1Adjusted = balance1.mul(1000).sub(amount1In.mul(3));</span>
 185 |     | <span class='unexecuted'>            require(</span>
 186 |     | <span class='unexecuted'>                balance0Adjusted.mul(balance1Adjusted) &gt;= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),</span>
 187 |     | <span class='neutral'>                &quot;UniswapV2: K&quot;</span>
 188 |     | <span class='neutral'>            );</span>
 189 |     | <span class='neutral'>        }</span>
 190 |     | <span class='neutral'></span>
 191 |     | <span class='unexecuted'>        _update(balance0, balance1, _reserve0, _reserve1);</span>
 192 |     | <span class='unexecuted'>        emit Swap(msg.sender, amount0In, amount1In, amount0Out, amount1Out, to);</span>
 193 |     | <span class='neutral'>    }</span>
 194 |     | <span class='neutral'></span>
 195 |     | <span class='neutral'>    // force balances to match reserves</span>
 196 |     | <span class='unexecuted'>    function skim(address to) external lock {</span>
 197 |     | <span class='unexecuted'>        address _token0 = token0; // gas savings</span>
 198 |     | <span class='unexecuted'>        address _token1 = token1; // gas savings</span>
 199 |     | <span class='unexecuted'>        _safeTransfer(_token0, to, IERC20(_token0).balanceOf(address(this)).sub(reserve0));</span>
 200 |     | <span class='unexecuted'>        _safeTransfer(_token1, to, IERC20(_token1).balanceOf(address(this)).sub(reserve1));</span>
 201 |     | <span class='neutral'>    }</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='neutral'>    // force reserves to match balances</span>
 204 |     | <span class='unexecuted'>    function sync() external lock {</span>
 205 |     | <span class='unexecuted'>        _update(IERC20(token0).balanceOf(address(this)), IERC20(token1).balanceOf(address(this)), reserve0, reserve1);</span>
 206 |     | <span class='neutral'>    }</span>
 207 |     | <span class='neutral'>}</span>
 208 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IERC20 {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external view returns (string memory);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function symbol() external view returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function decimals() external view returns (uint8);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Callee.sol</b>
<code>
 1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
 2 |     | <span class='neutral'></span>
 3 |     | <span class='neutral'>interface IUniswapV2Callee {</span>
 4 |     | <span class='neutral'>    function uniswapV2Call(address sender, uint256 amount0, uint256 amount1, bytes calldata data) external;</span>
 5 |     | <span class='neutral'>}</span>
 6 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2ERC20.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2ERC20 {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function decimals() external pure returns (uint8);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 32 |     | <span class='neutral'>        external;</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Factory.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Factory {</span>
  4 |     | <span class='neutral'>    event PairCreated(address indexed token0, address indexed token1, address pair, uint256);</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    function feeTo() external view returns (address);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function feeToSetter() external view returns (address);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    function getPair(address tokenA, address tokenB) external view returns (address pair);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    function allPairs(uint256) external view returns (address pair);</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    function allPairsLength() external view returns (uint256);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    function createPair(address tokenA, address tokenB) external returns (address pair);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    function setFeeTo(address) external;</span>
 19 |     | <span class='neutral'></span>
 20 |     | <span class='neutral'>    function setFeeToSetter(address) external;</span>
 21 |     | <span class='neutral'>}</span>
 22 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/interfaces/IUniswapV2Pair.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IUniswapV2Pair {</span>
  4 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
  5 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>    function name() external pure returns (string memory);</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    function symbol() external pure returns (string memory);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    function decimals() external pure returns (uint8);</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    function totalSupply() external view returns (uint256);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function balanceOf(address owner) external view returns (uint256);</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    function approve(address spender, uint256 value) external returns (bool);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    function transferFrom(address from, address to, uint256 value) external returns (bool);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='neutral'>    function DOMAIN_SEPARATOR() external view returns (bytes32);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    function PERMIT_TYPEHASH() external pure returns (bytes32);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    function nonces(address owner) external view returns (uint256);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)</span>
 32 |     | <span class='neutral'>        external;</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    event Mint(address indexed sender, uint256 amount0, uint256 amount1);</span>
 35 |     | <span class='neutral'>    event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to);</span>
 36 |     | <span class='neutral'>    event Swap(</span>
 37 |     | <span class='neutral'>        address indexed sender,</span>
 38 |     | <span class='neutral'>        uint256 amount0In,</span>
 39 |     | <span class='neutral'>        uint256 amount1In,</span>
 40 |     | <span class='neutral'>        uint256 amount0Out,</span>
 41 |     | <span class='neutral'>        uint256 amount1Out,</span>
 42 |     | <span class='neutral'>        address indexed to</span>
 43 |     | <span class='neutral'>    );</span>
 44 |     | <span class='neutral'>    event Sync(uint112 reserve0, uint112 reserve1);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='neutral'>    function MINIMUM_LIQUIDITY() external pure returns (uint256);</span>
 47 |     | <span class='neutral'></span>
 48 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    function price0CumulativeLast() external view returns (uint256);</span>
 57 |     | <span class='neutral'></span>
 58 |     | <span class='neutral'>    function price1CumulativeLast() external view returns (uint256);</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>    function kLast() external view returns (uint256);</span>
 61 |     | <span class='neutral'></span>
 62 |     | <span class='neutral'>    function mint(address to) external returns (uint256 liquidity);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    function burn(address to) external returns (uint256 amount0, uint256 amount1);</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>    function swap(uint256 amount0Out, uint256 amount1Out, address to, bytes calldata data) external;</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    function skim(address to) external;</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>    function sync() external;</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    function initialize(address, address) external;</span>
 73 |     | <span class='neutral'>}</span>
 74 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/Math.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for performing various math operations</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library Math {</span>
  6 |     | <span class='unexecuted'>    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  7 |     | <span class='unexecuted'>        z = x &lt; y ? x : y;</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)</span>
 11 |     | <span class='unexecuted'>    function sqrt(uint256 y) internal pure returns (uint256 z) {</span>
 12 |     | <span class='unexecuted'>        if (y &gt; 3) {</span>
 13 |     | <span class='unexecuted'>            z = y;</span>
 14 |     | <span class='unexecuted'>            uint256 x = y / 2 + 1;</span>
 15 |     | <span class='unexecuted'>            while (x &lt; z) {</span>
 16 |     | <span class='unexecuted'>                z = x;</span>
 17 |     | <span class='unexecuted'>                x = (y / x + x) / 2;</span>
 18 |     | <span class='neutral'>            }</span>
 19 |     | <span class='unexecuted'>        } else if (y != 0) {</span>
 20 |     | <span class='unexecuted'>            z = 1;</span>
 21 |     | <span class='neutral'>        }</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'>}</span>
 24 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/SafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for performing overflow-safe math, courtesy of DappHub (https://github.com/dapphub/ds-math)</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='unexecuted'>library SafeMath {</span>
  6 |     | <span class='unexecuted'>    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
  7 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x, &quot;ds-math-add-overflow&quot;);</span>
  8 |     | <span class='neutral'>    }</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='unexecuted'>    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 11 |     | <span class='unexecuted'>        require((z = x - y) &lt;= x, &quot;ds-math-sub-underflow&quot;);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='unexecuted'>    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 15 |     | <span class='unexecuted'>        require(y == 0 || (z = x * y) / y == x, &quot;ds-math-mul-overflow&quot;);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>
 18 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-core/contracts/libraries/UQ112x112.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>// a library for handling binary fixed point numbers (https://en.wikipedia.org/wiki/Q_(number_format))</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>// range: [0, 2**112 - 1]</span>
  6 |     | <span class='neutral'>// resolution: 1 / 2**112</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='unexecuted'>library UQ112x112 {</span>
  9 |     | <span class='neutral'>    uint224 constant Q112 = 2 ** 112;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    // encode a uint112 as a UQ112x112</span>
 12 |     | <span class='unexecuted'>    function encode(uint112 y) internal pure returns (uint224 z) {</span>
 13 |     | <span class='unexecuted'>        z = uint224(y) * Q112; // never overflows</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // divide a UQ112x112 by a uint112, returning a UQ112x112</span>
 17 |     | <span class='unexecuted'>    function uqdiv(uint224 x, uint112 y) internal pure returns (uint224 z) {</span>
 18 |     | <span class='unexecuted'>        z = x / uint224(y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'>}</span>
 21 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/UniswapV2Router02.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>import &quot;v2-core/interfaces/IUniswapV2Factory.sol&quot;;</span>
   4 |     | <span class='neutral'>import &quot;uniswap-v2/libraries/TransferHelper.sol&quot;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &quot;./interfaces/IUniswapV2Router02.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;./libraries/UniswapV2Library.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;./interfaces/IWETH.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='unexecuted'>contract UniswapV2Router02 is IUniswapV2Router02 {</span>
  11 |     | <span class='neutral'>    using SafeMath for uint256;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='unexecuted'>    address public immutable factory;</span>
  14 |     | <span class='unexecuted'>    address public immutable WETH;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    modifier ensure(uint256 deadline) {</span>
  17 |     | <span class='unexecuted'>        require(deadline &gt;= block.timestamp, &quot;UniswapV2Router: EXPIRED&quot;);</span>
  18 |     | <span class='neutral'>        _;</span>
  19 |     | <span class='neutral'>    }</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>    constructor(address _factory, address _WETH) {</span>
  22 |     | <span class='unexecuted'>        factory = _factory;</span>
  23 |     | <span class='unexecuted'>        WETH = _WETH;</span>
  24 |     | <span class='neutral'>    }</span>
  25 |     | <span class='neutral'></span>
  26 |     | <span class='neutral'>    receive() external payable {</span>
  27 |     | <span class='unexecuted'>        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract</span>
  28 |     | <span class='neutral'>    }</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>    // **** ADD LIQUIDITY ****</span>
  31 |     | <span class='unexecuted'>    function _addLiquidity(</span>
  32 |     | <span class='neutral'>        address tokenA,</span>
  33 |     | <span class='neutral'>        address tokenB,</span>
  34 |     | <span class='neutral'>        uint256 amountADesired,</span>
  35 |     | <span class='neutral'>        uint256 amountBDesired,</span>
  36 |     | <span class='neutral'>        uint256 amountAMin,</span>
  37 |     | <span class='neutral'>        uint256 amountBMin</span>
  38 |     | <span class='unexecuted'>    ) internal virtual returns (uint256 amountA, uint256 amountB) {</span>
  39 |     | <span class='neutral'>        // create the pair if it doesn&#39;t exist yet</span>
  40 |     | <span class='unexecuted'>        if (IUniswapV2Factory(factory).getPair(tokenA, tokenB) == address(0)) {</span>
  41 |     | <span class='unexecuted'>            IUniswapV2Factory(factory).createPair(tokenA, tokenB);</span>
  42 |     | <span class='neutral'>        }</span>
  43 |     | <span class='unexecuted'>        (uint256 reserveA, uint256 reserveB) = UniswapV2Library.getReserves(factory, tokenA, tokenB);</span>
  44 |     | <span class='unexecuted'>        if (reserveA == 0 &amp;&amp; reserveB == 0) {</span>
  45 |     | <span class='unexecuted'>            (amountA, amountB) = (amountADesired, amountBDesired);</span>
  46 |     | <span class='unexecuted'>        } else {</span>
  47 |     | <span class='unexecuted'>            uint256 amountBOptimal = UniswapV2Library.quote(amountADesired, reserveA, reserveB);</span>
  48 |     | <span class='unexecuted'>            if (amountBOptimal &lt;= amountBDesired) {</span>
  49 |     | <span class='unexecuted'>                require(amountBOptimal &gt;= amountBMin, &quot;UniswapV2Router: INSUFFICIENT_B_AMOUNT&quot;);</span>
  50 |     | <span class='unexecuted'>                (amountA, amountB) = (amountADesired, amountBOptimal);</span>
  51 |     | <span class='neutral'>            } else {</span>
  52 |     | <span class='unexecuted'>                uint256 amountAOptimal = UniswapV2Library.quote(amountBDesired, reserveB, reserveA);</span>
  53 |     | <span class='unexecuted'>                assert(amountAOptimal &lt;= amountADesired);</span>
  54 |     | <span class='unexecuted'>                require(amountAOptimal &gt;= amountAMin, &quot;UniswapV2Router: INSUFFICIENT_A_AMOUNT&quot;);</span>
  55 |     | <span class='unexecuted'>                (amountA, amountB) = (amountAOptimal, amountBDesired);</span>
  56 |     | <span class='neutral'>            }</span>
  57 |     | <span class='neutral'>        }</span>
  58 |     | <span class='neutral'>    }</span>
  59 |     | <span class='neutral'></span>
  60 |     | <span class='neutral'>    event MessageNum(string a, uint256 b);</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='unexecuted'>    function addLiquidity(</span>
  63 |     | <span class='neutral'>        address tokenA,</span>
  64 |     | <span class='neutral'>        address tokenB,</span>
  65 |     | <span class='neutral'>        uint256 amountADesired,</span>
  66 |     | <span class='neutral'>        uint256 amountBDesired,</span>
  67 |     | <span class='neutral'>        uint256 amountAMin,</span>
  68 |     | <span class='neutral'>        uint256 amountBMin,</span>
  69 |     | <span class='neutral'>        address to,</span>
  70 |     | <span class='neutral'>        uint256 deadline</span>
  71 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB, uint256 liquidity) {</span>
  72 |     | <span class='unexecuted'>        (amountA, amountB) = _addLiquidity(tokenA, tokenB, amountADesired, amountBDesired, amountAMin, amountBMin);</span>
  73 |     | <span class='unexecuted'>        address pair = IUniswapV2Factory(factory).getPair(tokenA, tokenB);</span>
  74 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(tokenA, msg.sender, pair, amountA);</span>
  75 |     | <span class='unexecuted'>        emit MessageNum(&quot;amount transfered&quot;, amountB);</span>
  76 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(tokenB, msg.sender, pair, amountB);</span>
  77 |     | <span class='unexecuted'>        liquidity = IUniswapV2Pair(pair).mint(to);</span>
  78 |     | <span class='neutral'>    }</span>
  79 |     | <span class='neutral'></span>
  80 |     | <span class='unexecuted'>    function addLiquidityETH(</span>
  81 |     | <span class='neutral'>        address token,</span>
  82 |     | <span class='neutral'>        uint256 amountTokenDesired,</span>
  83 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
  84 |     | <span class='neutral'>        uint256 amountETHMin,</span>
  85 |     | <span class='neutral'>        address to,</span>
  86 |     | <span class='neutral'>        uint256 deadline</span>
  87 |     | <span class='neutral'>    )</span>
  88 |     | <span class='neutral'>        external</span>
  89 |     | <span class='neutral'>        payable</span>
  90 |     | <span class='neutral'>        virtual</span>
  91 |     | <span class='neutral'>        override</span>
  92 |     | <span class='unexecuted'>        ensure(deadline)</span>
  93 |     | <span class='unexecuted'>        returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)</span>
  94 |     | <span class='unexecuted'>    {</span>
  95 |     | <span class='unexecuted'>        (amountToken, amountETH) =</span>
  96 |     | <span class='unexecuted'>            _addLiquidity(token, WETH, amountTokenDesired, msg.value, amountTokenMin, amountETHMin);</span>
  97 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, token, WETH);</span>
  98 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(token, msg.sender, pair, amountToken);</span>
  99 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amountETH}();</span>
 100 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(pair, amountETH));</span>
 101 |     | <span class='unexecuted'>        liquidity = IUniswapV2Pair(pair).mint(to);</span>
 102 |     | <span class='neutral'>        // refund dust eth, if any</span>
 103 |     | <span class='unexecuted'>        if (msg.value &gt; amountETH) TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH);</span>
 104 |     | <span class='neutral'>    }</span>
 105 |     | <span class='neutral'></span>
 106 |     | <span class='neutral'>    // **** REMOVE LIQUIDITY ****</span>
 107 |     | <span class='unexecuted'>    function removeLiquidity(</span>
 108 |     | <span class='neutral'>        address tokenA,</span>
 109 |     | <span class='neutral'>        address tokenB,</span>
 110 |     | <span class='neutral'>        uint256 liquidity,</span>
 111 |     | <span class='neutral'>        uint256 amountAMin,</span>
 112 |     | <span class='neutral'>        uint256 amountBMin,</span>
 113 |     | <span class='neutral'>        address to,</span>
 114 |     | <span class='neutral'>        uint256 deadline</span>
 115 |     | <span class='unexecuted'>    ) public virtual override ensure(deadline) returns (uint256 amountA, uint256 amountB) {</span>
 116 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 117 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).transferFrom(msg.sender, pair, liquidity); // send liquidity to pair</span>
 118 |     | <span class='unexecuted'>        (uint256 amount0, uint256 amount1) = IUniswapV2Pair(pair).burn(to);</span>
 119 |     | <span class='unexecuted'>        (address token0,) = UniswapV2Library.sortTokens(tokenA, tokenB);</span>
 120 |     | <span class='unexecuted'>        (amountA, amountB) = tokenA == token0 ? (amount0, amount1) : (amount1, amount0);</span>
 121 |     | <span class='unexecuted'>        require(amountA &gt;= amountAMin, &quot;UniswapV2Router: INSUFFICIENT_A_AMOUNT&quot;);</span>
 122 |     | <span class='unexecuted'>        require(amountB &gt;= amountBMin, &quot;UniswapV2Router: INSUFFICIENT_B_AMOUNT&quot;);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>    function removeLiquidityETH(</span>
 126 |     | <span class='neutral'>        address token,</span>
 127 |     | <span class='neutral'>        uint256 liquidity,</span>
 128 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 129 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 130 |     | <span class='neutral'>        address to,</span>
 131 |     | <span class='neutral'>        uint256 deadline</span>
 132 |     | <span class='unexecuted'>    ) public virtual override ensure(deadline) returns (uint256 amountToken, uint256 amountETH) {</span>
 133 |     | <span class='unexecuted'>        (amountToken, amountETH) =</span>
 134 |     | <span class='unexecuted'>            removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);</span>
 135 |     | <span class='unexecuted'>        TransferHelper.safeTransfer(token, to, amountToken);</span>
 136 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amountETH);</span>
 137 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amountETH);</span>
 138 |     | <span class='neutral'>    }</span>
 139 |     | <span class='neutral'></span>
 140 |     | <span class='unexecuted'>    function removeLiquidityWithPermit(</span>
 141 |     | <span class='neutral'>        address tokenA,</span>
 142 |     | <span class='neutral'>        address tokenB,</span>
 143 |     | <span class='neutral'>        uint256 liquidity,</span>
 144 |     | <span class='neutral'>        uint256 amountAMin,</span>
 145 |     | <span class='neutral'>        uint256 amountBMin,</span>
 146 |     | <span class='neutral'>        address to,</span>
 147 |     | <span class='neutral'>        uint256 deadline,</span>
 148 |     | <span class='neutral'>        bool approveMax,</span>
 149 |     | <span class='neutral'>        uint8 v,</span>
 150 |     | <span class='neutral'>        bytes32 r,</span>
 151 |     | <span class='neutral'>        bytes32 s</span>
 152 |     | <span class='unexecuted'>    ) external virtual override returns (uint256 amountA, uint256 amountB) {</span>
 153 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, tokenA, tokenB);</span>
 154 |     | <span class='unexecuted'>        uint256 value = approveMax ? type(uint256).max : liquidity;</span>
 155 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 156 |     | <span class='unexecuted'>        (amountA, amountB) = removeLiquidity(tokenA, tokenB, liquidity, amountAMin, amountBMin, to, deadline);</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='unexecuted'>    function removeLiquidityETHWithPermit(</span>
 160 |     | <span class='neutral'>        address token,</span>
 161 |     | <span class='neutral'>        uint256 liquidity,</span>
 162 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 163 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 164 |     | <span class='neutral'>        address to,</span>
 165 |     | <span class='neutral'>        uint256 deadline,</span>
 166 |     | <span class='neutral'>        bool approveMax,</span>
 167 |     | <span class='neutral'>        uint8 v,</span>
 168 |     | <span class='neutral'>        bytes32 r,</span>
 169 |     | <span class='neutral'>        bytes32 s</span>
 170 |     | <span class='unexecuted'>    ) external virtual override returns (uint256 amountToken, uint256 amountETH) {</span>
 171 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, token, WETH);</span>
 172 |     | <span class='unexecuted'>        uint256 value = approveMax ? type(uint256).max : liquidity;</span>
 173 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 174 |     | <span class='unexecuted'>        (amountToken, amountETH) = removeLiquidityETH(token, liquidity, amountTokenMin, amountETHMin, to, deadline);</span>
 175 |     | <span class='neutral'>    }</span>
 176 |     | <span class='neutral'></span>
 177 |     | <span class='neutral'>    // **** REMOVE LIQUIDITY (supporting fee-on-transfer tokens) ****</span>
 178 |     | <span class='unexecuted'>    function removeLiquidityETHSupportingFeeOnTransferTokens(</span>
 179 |     | <span class='neutral'>        address token,</span>
 180 |     | <span class='neutral'>        uint256 liquidity,</span>
 181 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 182 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 183 |     | <span class='neutral'>        address to,</span>
 184 |     | <span class='neutral'>        uint256 deadline</span>
 185 |     | <span class='unexecuted'>    ) public virtual override ensure(deadline) returns (uint256 amountETH) {</span>
 186 |     | <span class='unexecuted'>        (, amountETH) = removeLiquidity(token, WETH, liquidity, amountTokenMin, amountETHMin, address(this), deadline);</span>
 187 |     | <span class='unexecuted'>        TransferHelper.safeTransfer(token, to, IERC20(token).balanceOf(address(this)));</span>
 188 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amountETH);</span>
 189 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amountETH);</span>
 190 |     | <span class='neutral'>    }</span>
 191 |     | <span class='neutral'></span>
 192 |     | <span class='unexecuted'>    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(</span>
 193 |     | <span class='neutral'>        address token,</span>
 194 |     | <span class='neutral'>        uint256 liquidity,</span>
 195 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 196 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 197 |     | <span class='neutral'>        address to,</span>
 198 |     | <span class='neutral'>        uint256 deadline,</span>
 199 |     | <span class='neutral'>        bool approveMax,</span>
 200 |     | <span class='neutral'>        uint8 v,</span>
 201 |     | <span class='neutral'>        bytes32 r,</span>
 202 |     | <span class='neutral'>        bytes32 s</span>
 203 |     | <span class='unexecuted'>    ) external virtual override returns (uint256 amountETH) {</span>
 204 |     | <span class='unexecuted'>        address pair = UniswapV2Library.pairFor(factory, token, WETH);</span>
 205 |     | <span class='unexecuted'>        uint256 value = approveMax ? type(uint256).max : liquidity;</span>
 206 |     | <span class='unexecuted'>        IUniswapV2Pair(pair).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 207 |     | <span class='unexecuted'>        amountETH = removeLiquidityETHSupportingFeeOnTransferTokens(</span>
 208 |     | <span class='unexecuted'>            token, liquidity, amountTokenMin, amountETHMin, to, deadline</span>
 209 |     | <span class='neutral'>        );</span>
 210 |     | <span class='neutral'>    }</span>
 211 |     | <span class='neutral'></span>
 212 |     | <span class='neutral'>    // **** SWAP ****</span>
 213 |     | <span class='neutral'>    // requires the initial amount to have already been sent to the first pair</span>
 214 |     | <span class='unexecuted'>    function _swap(uint256[] memory amounts, address[] memory path, address _to) internal virtual {</span>
 215 |     | <span class='unexecuted'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 216 |     | <span class='unexecuted'>            (address input, address output) = (path[i], path[i + 1]);</span>
 217 |     | <span class='unexecuted'>            (address token0,) = UniswapV2Library.sortTokens(input, output);</span>
 218 |     | <span class='unexecuted'>            uint256 amountOut = amounts[i + 1];</span>
 219 |     | <span class='unexecuted'>            (uint256 amount0Out, uint256 amount1Out) =</span>
 220 |     | <span class='unexecuted'>                input == token0 ? (uint256(0), amountOut) : (amountOut, uint256(0));</span>
 221 |     | <span class='unexecuted'>            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span>
 222 |     | <span class='unexecuted'>            IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output)).swap(</span>
 223 |     | <span class='unexecuted'>                amount0Out, amount1Out, to, new bytes(0)</span>
 224 |     | <span class='neutral'>            );</span>
 225 |     | <span class='neutral'>        }</span>
 226 |     | <span class='neutral'>    }</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='unexecuted'>    function swapExactTokensForTokens(</span>
 229 |     | <span class='neutral'>        uint256 amountIn,</span>
 230 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 231 |     | <span class='neutral'>        address[] calldata path,</span>
 232 |     | <span class='neutral'>        address to,</span>
 233 |     | <span class='neutral'>        uint256 deadline</span>
 234 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 235 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 236 |     | <span class='unexecuted'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 237 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(</span>
 238 |     | <span class='unexecuted'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span>
 239 |     | <span class='neutral'>        );</span>
 240 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 241 |     | <span class='neutral'>    }</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>    function swapTokensForExactTokens(</span>
 244 |     | <span class='neutral'>        uint256 amountOut,</span>
 245 |     | <span class='neutral'>        uint256 amountInMax,</span>
 246 |     | <span class='neutral'>        address[] calldata path,</span>
 247 |     | <span class='neutral'>        address to,</span>
 248 |     | <span class='neutral'>        uint256 deadline</span>
 249 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 250 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 251 |     | <span class='unexecuted'>        require(amounts[0] &lt;= amountInMax, &quot;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&quot;);</span>
 252 |     | <span class='neutral'>        TransferHelper.safeTransferFrom(</span>
 253 |     | <span class='neutral'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span>
 254 |     | <span class='neutral'>        );</span>
 255 |     | <span class='neutral'>        _swap(amounts, path, to);</span>
 256 |     | <span class='neutral'>    }</span>
 257 |     | <span class='neutral'></span>
 258 |     | <span class='unexecuted'>    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)</span>
 259 |     | <span class='neutral'>        external</span>
 260 |     | <span class='neutral'>        payable</span>
 261 |     | <span class='neutral'>        virtual</span>
 262 |     | <span class='neutral'>        override</span>
 263 |     | <span class='unexecuted'>        ensure(deadline)</span>
 264 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 265 |     | <span class='neutral'>    {</span>
 266 |     | <span class='unexecuted'>        require(path[0] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 267 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsOut(factory, msg.value, path);</span>
 268 |     | <span class='unexecuted'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 269 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amounts[0]}();</span>
 270 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));</span>
 271 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 272 |     | <span class='neutral'>    }</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>    function swapTokensForExactETH(</span>
 275 |     | <span class='neutral'>        uint256 amountOut,</span>
 276 |     | <span class='neutral'>        uint256 amountInMax,</span>
 277 |     | <span class='neutral'>        address[] calldata path,</span>
 278 |     | <span class='neutral'>        address to,</span>
 279 |     | <span class='neutral'>        uint256 deadline</span>
 280 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 281 |     | <span class='unexecuted'>        require(path[path.length - 1] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 282 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 283 |     | <span class='unexecuted'>        require(amounts[0] &lt;= amountInMax, &quot;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&quot;);</span>
 284 |     | <span class='neutral'>        TransferHelper.safeTransferFrom(</span>
 285 |     | <span class='neutral'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span>
 286 |     | <span class='neutral'>        );</span>
 287 |     | <span class='neutral'>        _swap(amounts, path, address(this));</span>
 288 |     | <span class='neutral'>        IWETH(WETH).withdraw(amounts[amounts.length - 1]);</span>
 289 |     | <span class='neutral'>        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);</span>
 290 |     | <span class='neutral'>    }</span>
 291 |     | <span class='neutral'></span>
 292 |     | <span class='unexecuted'>    function swapExactTokensForETH(</span>
 293 |     | <span class='neutral'>        uint256 amountIn,</span>
 294 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 295 |     | <span class='neutral'>        address[] calldata path,</span>
 296 |     | <span class='neutral'>        address to,</span>
 297 |     | <span class='neutral'>        uint256 deadline</span>
 298 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) returns (uint256[] memory amounts) {</span>
 299 |     | <span class='unexecuted'>        require(path[path.length - 1] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 300 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 301 |     | <span class='unexecuted'>        require(amounts[amounts.length - 1] &gt;= amountOutMin, &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 302 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(</span>
 303 |     | <span class='unexecuted'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]</span>
 304 |     | <span class='neutral'>        );</span>
 305 |     | <span class='unexecuted'>        _swap(amounts, path, address(this));</span>
 306 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amounts[amounts.length - 1]);</span>
 307 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amounts[amounts.length - 1]);</span>
 308 |     | <span class='neutral'>    }</span>
 309 |     | <span class='neutral'></span>
 310 |     | <span class='unexecuted'>    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)</span>
 311 |     | <span class='neutral'>        external</span>
 312 |     | <span class='neutral'>        payable</span>
 313 |     | <span class='neutral'>        virtual</span>
 314 |     | <span class='neutral'>        override</span>
 315 |     | <span class='unexecuted'>        ensure(deadline)</span>
 316 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 317 |     | <span class='neutral'>    {</span>
 318 |     | <span class='unexecuted'>        require(path[0] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 319 |     | <span class='unexecuted'>        amounts = UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 320 |     | <span class='unexecuted'>        require(amounts[0] &lt;= msg.value, &quot;UniswapV2Router: EXCESSIVE_INPUT_AMOUNT&quot;);</span>
 321 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amounts[0]}();</span>
 322 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amounts[0]));</span>
 323 |     | <span class='unexecuted'>        _swap(amounts, path, to);</span>
 324 |     | <span class='neutral'>        // refund dust eth, if any</span>
 325 |     | <span class='unexecuted'>        if (msg.value &gt; amounts[0]) TransferHelper.safeTransferETH(msg.sender, msg.value - amounts[0]);</span>
 326 |     | <span class='neutral'>    }</span>
 327 |     | <span class='neutral'></span>
 328 |     | <span class='neutral'>    // **** SWAP (supporting fee-on-transfer tokens) ****</span>
 329 |     | <span class='neutral'>    // requires the initial amount to have already been sent to the first pair</span>
 330 |     | <span class='unexecuted'>    function _swapSupportingFeeOnTransferTokens(address[] memory path, address _to) internal virtual {</span>
 331 |     | <span class='unexecuted'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 332 |     | <span class='unexecuted'>            (address input, address output) = (path[i], path[i + 1]);</span>
 333 |     | <span class='unexecuted'>            (address token0,) = UniswapV2Library.sortTokens(input, output);</span>
 334 |     | <span class='unexecuted'>            IUniswapV2Pair pair = IUniswapV2Pair(UniswapV2Library.pairFor(factory, input, output));</span>
 335 |     | <span class='unexecuted'>            uint256 amountInput;</span>
 336 |     | <span class='unexecuted'>            uint256 amountOutput;</span>
 337 |     | <span class='unexecuted'>            {</span>
 338 |     | <span class='neutral'>                // scope to avoid stack too deep errors</span>
 339 |     | <span class='unexecuted'>                (uint256 reserve0, uint256 reserve1,) = pair.getReserves();</span>
 340 |     | <span class='unexecuted'>                (uint256 reserveInput, uint256 reserveOutput) =</span>
 341 |     | <span class='unexecuted'>                    input == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span>
 342 |     | <span class='unexecuted'>                amountInput = IERC20(input).balanceOf(address(pair)).sub(reserveInput);</span>
 343 |     | <span class='unexecuted'>                amountOutput = UniswapV2Library.getAmountOut(amountInput, reserveInput, reserveOutput);</span>
 344 |     | <span class='neutral'>            }</span>
 345 |     | <span class='unexecuted'>            (uint256 amount0Out, uint256 amount1Out) =</span>
 346 |     | <span class='unexecuted'>                input == token0 ? (uint256(0), amountOutput) : (amountOutput, uint256(0));</span>
 347 |     | <span class='unexecuted'>            address to = i &lt; path.length - 2 ? UniswapV2Library.pairFor(factory, output, path[i + 2]) : _to;</span>
 348 |     | <span class='unexecuted'>            pair.swap(amount0Out, amount1Out, to, new bytes(0));</span>
 349 |     | <span class='neutral'>        }</span>
 350 |     | <span class='neutral'>    }</span>
 351 |     | <span class='neutral'></span>
 352 |     | <span class='unexecuted'>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 353 |     | <span class='neutral'>        uint256 amountIn,</span>
 354 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 355 |     | <span class='neutral'>        address[] calldata path,</span>
 356 |     | <span class='neutral'>        address to,</span>
 357 |     | <span class='neutral'>        uint256 deadline</span>
 358 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) {</span>
 359 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(</span>
 360 |     | <span class='unexecuted'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn</span>
 361 |     | <span class='neutral'>        );</span>
 362 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span>
 363 |     | <span class='unexecuted'>        _swapSupportingFeeOnTransferTokens(path, to);</span>
 364 |     | <span class='unexecuted'>        require(</span>
 365 |     | <span class='unexecuted'>            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,</span>
 366 |     | <span class='neutral'>            &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;</span>
 367 |     | <span class='neutral'>        );</span>
 368 |     | <span class='neutral'>    }</span>
 369 |     | <span class='neutral'></span>
 370 |     | <span class='unexecuted'>    function swapExactETHForTokensSupportingFeeOnTransferTokens(</span>
 371 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 372 |     | <span class='neutral'>        address[] calldata path,</span>
 373 |     | <span class='neutral'>        address to,</span>
 374 |     | <span class='neutral'>        uint256 deadline</span>
 375 |     | <span class='unexecuted'>    ) external payable virtual override ensure(deadline) {</span>
 376 |     | <span class='unexecuted'>        require(path[0] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 377 |     | <span class='unexecuted'>        uint256 amountIn = msg.value;</span>
 378 |     | <span class='unexecuted'>        IWETH(WETH).deposit{value: amountIn}();</span>
 379 |     | <span class='unexecuted'>        assert(IWETH(WETH).transfer(UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn));</span>
 380 |     | <span class='unexecuted'>        uint256 balanceBefore = IERC20(path[path.length - 1]).balanceOf(to);</span>
 381 |     | <span class='unexecuted'>        _swapSupportingFeeOnTransferTokens(path, to);</span>
 382 |     | <span class='neutral'>        require(</span>
 383 |     | <span class='unexecuted'>            IERC20(path[path.length - 1]).balanceOf(to).sub(balanceBefore) &gt;= amountOutMin,</span>
 384 |     | <span class='neutral'>            &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;</span>
 385 |     | <span class='neutral'>        );</span>
 386 |     | <span class='neutral'>    }</span>
 387 |     | <span class='neutral'></span>
 388 |     | <span class='unexecuted'>    function swapExactTokensForETHSupportingFeeOnTransferTokens(</span>
 389 |     | <span class='neutral'>        uint256 amountIn,</span>
 390 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 391 |     | <span class='neutral'>        address[] calldata path,</span>
 392 |     | <span class='neutral'>        address to,</span>
 393 |     | <span class='neutral'>        uint256 deadline</span>
 394 |     | <span class='unexecuted'>    ) external virtual override ensure(deadline) {</span>
 395 |     | <span class='unexecuted'>        require(path[path.length - 1] == WETH, &quot;UniswapV2Router: INVALID_PATH&quot;);</span>
 396 |     | <span class='unexecuted'>        TransferHelper.safeTransferFrom(</span>
 397 |     | <span class='unexecuted'>            path[0], msg.sender, UniswapV2Library.pairFor(factory, path[0], path[1]), amountIn</span>
 398 |     | <span class='neutral'>        );</span>
 399 |     | <span class='unexecuted'>        _swapSupportingFeeOnTransferTokens(path, address(this));</span>
 400 |     | <span class='unexecuted'>        uint256 amountOut = IERC20(WETH).balanceOf(address(this));</span>
 401 |     | <span class='unexecuted'>        require(amountOut &gt;= amountOutMin, &quot;UniswapV2Router: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 402 |     | <span class='unexecuted'>        IWETH(WETH).withdraw(amountOut);</span>
 403 |     | <span class='unexecuted'>        TransferHelper.safeTransferETH(to, amountOut);</span>
 404 |     | <span class='neutral'>    }</span>
 405 |     | <span class='neutral'></span>
 406 |     | <span class='neutral'>    // **** LIBRARY FUNCTIONS ****</span>
 407 |     | <span class='unexecuted'>    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB)</span>
 408 |     | <span class='neutral'>        public</span>
 409 |     | <span class='neutral'>        pure</span>
 410 |     | <span class='neutral'>        virtual</span>
 411 |     | <span class='neutral'>        override</span>
 412 |     | <span class='unexecuted'>        returns (uint256 amountB)</span>
 413 |     | <span class='neutral'>    {</span>
 414 |     | <span class='unexecuted'>        return UniswapV2Library.quote(amountA, reserveA, reserveB);</span>
 415 |     | <span class='neutral'>    }</span>
 416 |     | <span class='neutral'></span>
 417 |     | <span class='unexecuted'>    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)</span>
 418 |     | <span class='neutral'>        public</span>
 419 |     | <span class='neutral'>        pure</span>
 420 |     | <span class='neutral'>        virtual</span>
 421 |     | <span class='neutral'>        override</span>
 422 |     | <span class='unexecuted'>        returns (uint256 amountOut)</span>
 423 |     | <span class='neutral'>    {</span>
 424 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountOut(amountIn, reserveIn, reserveOut);</span>
 425 |     | <span class='neutral'>    }</span>
 426 |     | <span class='neutral'></span>
 427 |     | <span class='unexecuted'>    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)</span>
 428 |     | <span class='neutral'>        public</span>
 429 |     | <span class='neutral'>        pure</span>
 430 |     | <span class='neutral'>        virtual</span>
 431 |     | <span class='neutral'>        override</span>
 432 |     | <span class='unexecuted'>        returns (uint256 amountIn)</span>
 433 |     | <span class='neutral'>    {</span>
 434 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountIn(amountOut, reserveIn, reserveOut);</span>
 435 |     | <span class='neutral'>    }</span>
 436 |     | <span class='neutral'></span>
 437 |     | <span class='unexecuted'>    function getAmountsOut(uint256 amountIn, address[] memory path)</span>
 438 |     | <span class='neutral'>        public</span>
 439 |     | <span class='neutral'>        virtual</span>
 440 |     | <span class='neutral'>        override</span>
 441 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 442 |     | <span class='neutral'>    {</span>
 443 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountsOut(factory, amountIn, path);</span>
 444 |     | <span class='neutral'>    }</span>
 445 |     | <span class='neutral'></span>
 446 |     | <span class='unexecuted'>    function getAmountsIn(uint256 amountOut, address[] memory path)</span>
 447 |     | <span class='neutral'>        public</span>
 448 |     | <span class='neutral'>        virtual</span>
 449 |     | <span class='neutral'>        override</span>
 450 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 451 |     | <span class='neutral'>    {</span>
 452 |     | <span class='unexecuted'>        return UniswapV2Library.getAmountsIn(factory, amountOut, path);</span>
 453 |     | <span class='neutral'>    }</span>
 454 |     | <span class='neutral'>}</span>
 455 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol</b>
<code>
   1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   2 |     | <span class='neutral'></span>
   3 |     | <span class='neutral'>interface IUniswapV2Router01 {</span>
   4 |     | <span class='neutral'>    function addLiquidity(</span>
   5 |     | <span class='neutral'>        address tokenA,</span>
   6 |     | <span class='neutral'>        address tokenB,</span>
   7 |     | <span class='neutral'>        uint256 amountADesired,</span>
   8 |     | <span class='neutral'>        uint256 amountBDesired,</span>
   9 |     | <span class='neutral'>        uint256 amountAMin,</span>
  10 |     | <span class='neutral'>        uint256 amountBMin,</span>
  11 |     | <span class='neutral'>        address to,</span>
  12 |     | <span class='neutral'>        uint256 deadline</span>
  13 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB, uint256 liquidity);</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>    function addLiquidityETH(</span>
  16 |     | <span class='neutral'>        address token,</span>
  17 |     | <span class='neutral'>        uint256 amountTokenDesired,</span>
  18 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
  19 |     | <span class='neutral'>        uint256 amountETHMin,</span>
  20 |     | <span class='neutral'>        address to,</span>
  21 |     | <span class='neutral'>        uint256 deadline</span>
  22 |     | <span class='neutral'>    ) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity);</span>
  23 |     | <span class='neutral'></span>
  24 |     | <span class='neutral'>    function removeLiquidity(</span>
  25 |     | <span class='neutral'>        address tokenA,</span>
  26 |     | <span class='neutral'>        address tokenB,</span>
  27 |     | <span class='neutral'>        uint256 liquidity,</span>
  28 |     | <span class='neutral'>        uint256 amountAMin,</span>
  29 |     | <span class='neutral'>        uint256 amountBMin,</span>
  30 |     | <span class='neutral'>        address to,</span>
  31 |     | <span class='neutral'>        uint256 deadline</span>
  32 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB);</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    function removeLiquidityETH(</span>
  35 |     | <span class='neutral'>        address token,</span>
  36 |     | <span class='neutral'>        uint256 liquidity,</span>
  37 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
  38 |     | <span class='neutral'>        uint256 amountETHMin,</span>
  39 |     | <span class='neutral'>        address to,</span>
  40 |     | <span class='neutral'>        uint256 deadline</span>
  41 |     | <span class='neutral'>    ) external returns (uint256 amountToken, uint256 amountETH);</span>
  42 |     | <span class='neutral'></span>
  43 |     | <span class='neutral'>    function removeLiquidityWithPermit(</span>
  44 |     | <span class='neutral'>        address tokenA,</span>
  45 |     | <span class='neutral'>        address tokenB,</span>
  46 |     | <span class='neutral'>        uint256 liquidity,</span>
  47 |     | <span class='neutral'>        uint256 amountAMin,</span>
  48 |     | <span class='neutral'>        uint256 amountBMin,</span>
  49 |     | <span class='neutral'>        address to,</span>
  50 |     | <span class='neutral'>        uint256 deadline,</span>
  51 |     | <span class='neutral'>        bool approveMax,</span>
  52 |     | <span class='neutral'>        uint8 v,</span>
  53 |     | <span class='neutral'>        bytes32 r,</span>
  54 |     | <span class='neutral'>        bytes32 s</span>
  55 |     | <span class='neutral'>    ) external returns (uint256 amountA, uint256 amountB);</span>
  56 |     | <span class='neutral'></span>
  57 |     | <span class='neutral'>    function removeLiquidityETHWithPermit(</span>
  58 |     | <span class='neutral'>        address token,</span>
  59 |     | <span class='neutral'>        uint256 liquidity,</span>
  60 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
  61 |     | <span class='neutral'>        uint256 amountETHMin,</span>
  62 |     | <span class='neutral'>        address to,</span>
  63 |     | <span class='neutral'>        uint256 deadline,</span>
  64 |     | <span class='neutral'>        bool approveMax,</span>
  65 |     | <span class='neutral'>        uint8 v,</span>
  66 |     | <span class='neutral'>        bytes32 r,</span>
  67 |     | <span class='neutral'>        bytes32 s</span>
  68 |     | <span class='neutral'>    ) external returns (uint256 amountToken, uint256 amountETH);</span>
  69 |     | <span class='neutral'></span>
  70 |     | <span class='neutral'>    function swapExactTokensForTokens(</span>
  71 |     | <span class='neutral'>        uint256 amountIn,</span>
  72 |     | <span class='neutral'>        uint256 amountOutMin,</span>
  73 |     | <span class='neutral'>        address[] calldata path,</span>
  74 |     | <span class='neutral'>        address to,</span>
  75 |     | <span class='neutral'>        uint256 deadline</span>
  76 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    function swapTokensForExactTokens(</span>
  79 |     | <span class='neutral'>        uint256 amountOut,</span>
  80 |     | <span class='neutral'>        uint256 amountInMax,</span>
  81 |     | <span class='neutral'>        address[] calldata path,</span>
  82 |     | <span class='neutral'>        address to,</span>
  83 |     | <span class='neutral'>        uint256 deadline</span>
  84 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
  85 |     | <span class='neutral'></span>
  86 |     | <span class='neutral'>    function swapExactETHForTokens(uint256 amountOutMin, address[] calldata path, address to, uint256 deadline)</span>
  87 |     | <span class='neutral'>        external</span>
  88 |     | <span class='neutral'>        payable</span>
  89 |     | <span class='neutral'>        returns (uint256[] memory amounts);</span>
  90 |     | <span class='neutral'></span>
  91 |     | <span class='neutral'>    function swapTokensForExactETH(</span>
  92 |     | <span class='neutral'>        uint256 amountOut,</span>
  93 |     | <span class='neutral'>        uint256 amountInMax,</span>
  94 |     | <span class='neutral'>        address[] calldata path,</span>
  95 |     | <span class='neutral'>        address to,</span>
  96 |     | <span class='neutral'>        uint256 deadline</span>
  97 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    function swapExactTokensForETH(</span>
 100 |     | <span class='neutral'>        uint256 amountIn,</span>
 101 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 102 |     | <span class='neutral'>        address[] calldata path,</span>
 103 |     | <span class='neutral'>        address to,</span>
 104 |     | <span class='neutral'>        uint256 deadline</span>
 105 |     | <span class='neutral'>    ) external returns (uint256[] memory amounts);</span>
 106 |     | <span class='neutral'></span>
 107 |     | <span class='neutral'>    function swapETHForExactTokens(uint256 amountOut, address[] calldata path, address to, uint256 deadline)</span>
 108 |     | <span class='neutral'>        external</span>
 109 |     | <span class='neutral'>        payable</span>
 110 |     | <span class='neutral'>        returns (uint256[] memory amounts);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) external pure returns (uint256 amountB);</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)</span>
 115 |     | <span class='neutral'>        external</span>
 116 |     | <span class='neutral'>        pure</span>
 117 |     | <span class='neutral'>        returns (uint256 amountOut);</span>
 118 |     | <span class='neutral'></span>
 119 |     | <span class='neutral'>    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)</span>
 120 |     | <span class='neutral'>        external</span>
 121 |     | <span class='neutral'>        pure</span>
 122 |     | <span class='neutral'>        returns (uint256 amountIn);</span>
 123 |     | <span class='neutral'></span>
 124 |     | <span class='neutral'>    function getAmountsOut(uint256 amountIn, address[] calldata path) external returns (uint256[] memory amounts);</span>
 125 |     | <span class='neutral'></span>
 126 |     | <span class='neutral'>    function getAmountsIn(uint256 amountOut, address[] calldata path) external returns (uint256[] memory amounts);</span>
 127 |     | <span class='neutral'>}</span>
 128 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;./IUniswapV2Router01.sol&quot;;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>interface IUniswapV2Router02 is IUniswapV2Router01 {</span>
  6 |     | <span class='neutral'>    function removeLiquidityETHSupportingFeeOnTransferTokens(</span>
  7 |     | <span class='neutral'>        address token,</span>
  8 |     | <span class='neutral'>        uint256 liquidity,</span>
  9 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 10 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 11 |     | <span class='neutral'>        address to,</span>
 12 |     | <span class='neutral'>        uint256 deadline</span>
 13 |     | <span class='neutral'>    ) external returns (uint256 amountETH);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(</span>
 16 |     | <span class='neutral'>        address token,</span>
 17 |     | <span class='neutral'>        uint256 liquidity,</span>
 18 |     | <span class='neutral'>        uint256 amountTokenMin,</span>
 19 |     | <span class='neutral'>        uint256 amountETHMin,</span>
 20 |     | <span class='neutral'>        address to,</span>
 21 |     | <span class='neutral'>        uint256 deadline,</span>
 22 |     | <span class='neutral'>        bool approveMax,</span>
 23 |     | <span class='neutral'>        uint8 v,</span>
 24 |     | <span class='neutral'>        bytes32 r,</span>
 25 |     | <span class='neutral'>        bytes32 s</span>
 26 |     | <span class='neutral'>    ) external returns (uint256 amountETH);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='neutral'>    function swapExactTokensForTokensSupportingFeeOnTransferTokens(</span>
 29 |     | <span class='neutral'>        uint256 amountIn,</span>
 30 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 31 |     | <span class='neutral'>        address[] calldata path,</span>
 32 |     | <span class='neutral'>        address to,</span>
 33 |     | <span class='neutral'>        uint256 deadline</span>
 34 |     | <span class='neutral'>    ) external;</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    function swapExactETHForTokensSupportingFeeOnTransferTokens(</span>
 37 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 38 |     | <span class='neutral'>        address[] calldata path,</span>
 39 |     | <span class='neutral'>        address to,</span>
 40 |     | <span class='neutral'>        uint256 deadline</span>
 41 |     | <span class='neutral'>    ) external payable;</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    function swapExactTokensForETHSupportingFeeOnTransferTokens(</span>
 44 |     | <span class='neutral'>        uint256 amountIn,</span>
 45 |     | <span class='neutral'>        uint256 amountOutMin,</span>
 46 |     | <span class='neutral'>        address[] calldata path,</span>
 47 |     | <span class='neutral'>        address to,</span>
 48 |     | <span class='neutral'>        uint256 deadline</span>
 49 |     | <span class='neutral'>    ) external;</span>
 50 |     | <span class='neutral'>}</span>
 51 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/interfaces/IWETH.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>interface IWETH {</span>
  4 |     | <span class='neutral'>    function deposit() external payable;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>    function transfer(address to, uint256 value) external returns (bool);</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>    function withdraw(uint256) external;</span>
  9 |     | <span class='neutral'>}</span>
 10 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/uniswap-v2/v2-periphery/contracts/libraries/UniswapV2Library.sol</b>
<code>
  1 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  2 |     | <span class='neutral'></span>
  3 |     | <span class='neutral'>import &quot;v2-core/interfaces/IUniswapV2Pair.sol&quot;;</span>
  4 |     | <span class='neutral'>import &quot;v2-core/UniswapV2Pair.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library UniswapV2Library {</span>
  7 |     | <span class='neutral'>    using SafeMath for uint256;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    // returns sorted token addresses, used to handle return values from pairs sorted in this order</span>
 10 |     | <span class='unexecuted'>    function sortTokens(address tokenA, address tokenB) internal view returns (address token0, address token1) {</span>
 11 |     | <span class='unexecuted'>        require(tokenA != tokenB, &quot;UniswapV2Library: IDENTICAL_ADDRESSES&quot;);</span>
 12 |     | <span class='unexecuted'>        (token0, token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 13 |     | <span class='unexecuted'>        require(token0 != address(0), &quot;UniswapV2Library: ZERO_ADDRESS&quot;);</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    // calculates the CREATE2 address for a pair without making any external calls</span>
 17 |     | <span class='unexecuted'>    function pairFor(address factory, address tokenA, address tokenB) internal view returns (address pair) {</span>
 18 |     | <span class='unexecuted'>        (address token0, address token1) = sortTokens(tokenA, tokenB);</span>
 19 |     | <span class='unexecuted'>        pair = IUniswapV2Factory(factory).getPair(token0, token1);</span>
 20 |     | <span class='neutral'>    }</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    // fetches and sorts the reserves for a pair</span>
 23 |     | <span class='neutral'>    event Message(string a);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>    function getReserves(address factory, address tokenA, address tokenB)</span>
 26 |     | <span class='neutral'>        internal</span>
 27 |     | <span class='neutral'>        view</span>
 28 |     | <span class='unexecuted'>        returns (uint256 reserveA, uint256 reserveB)</span>
 29 |     | <span class='neutral'>    {</span>
 30 |     | <span class='unexecuted'>        (address token0,) = sortTokens(tokenA, tokenB);</span>
 31 |     | <span class='unexecuted'>        (uint256 reserve0, uint256 reserve1,) = UniswapV2Pair(pairFor(factory, tokenA, tokenB)).getReserves();</span>
 32 |     | <span class='unexecuted'>        (reserveA, reserveB) = tokenA == token0 ? (reserve0, reserve1) : (reserve1, reserve0);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    // given some amount of an asset and pair reserves, returns an equivalent amount of the other asset</span>
 36 |     | <span class='unexecuted'>    function quote(uint256 amountA, uint256 reserveA, uint256 reserveB) internal pure returns (uint256 amountB) {</span>
 37 |     | <span class='unexecuted'>        require(amountA &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_AMOUNT&quot;);</span>
 38 |     | <span class='unexecuted'>        require(reserveA &gt; 0 &amp;&amp; reserveB &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
 39 |     | <span class='unexecuted'>        amountB = amountA.mul(reserveB) / reserveA;</span>
 40 |     | <span class='neutral'>    }</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    // given an input amount of an asset and pair reserves, returns the maximum output amount of the other asset</span>
 43 |     | <span class='unexecuted'>    function getAmountOut(uint256 amountIn, uint256 reserveIn, uint256 reserveOut)</span>
 44 |     | <span class='neutral'>        internal</span>
 45 |     | <span class='neutral'>        pure</span>
 46 |     | <span class='unexecuted'>        returns (uint256 amountOut)</span>
 47 |     | <span class='neutral'>    {</span>
 48 |     | <span class='unexecuted'>        require(amountIn &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_INPUT_AMOUNT&quot;);</span>
 49 |     | <span class='unexecuted'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
 50 |     | <span class='unexecuted'>        uint256 amountInWithFee = amountIn.mul(997);</span>
 51 |     | <span class='unexecuted'>        uint256 numerator = amountInWithFee.mul(reserveOut);</span>
 52 |     | <span class='unexecuted'>        uint256 denominator = reserveIn.mul(1000).add(amountInWithFee);</span>
 53 |     | <span class='unexecuted'>        amountOut = numerator / denominator;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    // given an output amount of an asset and pair reserves, returns a required input amount of the other asset</span>
 57 |     | <span class='unexecuted'>    function getAmountIn(uint256 amountOut, uint256 reserveIn, uint256 reserveOut)</span>
 58 |     | <span class='neutral'>        internal</span>
 59 |     | <span class='neutral'>        pure</span>
 60 |     | <span class='unexecuted'>        returns (uint256 amountIn)</span>
 61 |     | <span class='neutral'>    {</span>
 62 |     | <span class='unexecuted'>        require(amountOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_OUTPUT_AMOUNT&quot;);</span>
 63 |     | <span class='unexecuted'>        require(reserveIn &gt; 0 &amp;&amp; reserveOut &gt; 0, &quot;UniswapV2Library: INSUFFICIENT_LIQUIDITY&quot;);</span>
 64 |     | <span class='unexecuted'>        uint256 numerator = reserveIn.mul(amountOut).mul(1000);</span>
 65 |     | <span class='unexecuted'>        uint256 denominator = reserveOut.sub(amountOut).mul(997);</span>
 66 |     | <span class='unexecuted'>        amountIn = (numerator / denominator).add(1);</span>
 67 |     | <span class='neutral'>    }</span>
 68 |     | <span class='neutral'></span>
 69 |     | <span class='neutral'>    // performs chained getAmountOut calculations on any number of pairs</span>
 70 |     | <span class='unexecuted'>    function getAmountsOut(address factory, uint256 amountIn, address[] memory path)</span>
 71 |     | <span class='neutral'>        internal</span>
 72 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 73 |     | <span class='neutral'>    {</span>
 74 |     | <span class='unexecuted'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
 75 |     | <span class='unexecuted'>        amounts = new uint256[](path.length);</span>
 76 |     | <span class='unexecuted'>        amounts[0] = amountIn;</span>
 77 |     | <span class='unexecuted'>        for (uint256 i; i &lt; path.length - 1; i++) {</span>
 78 |     | <span class='unexecuted'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i], path[i + 1]);</span>
 79 |     | <span class='unexecuted'>            amounts[i + 1] = getAmountOut(amounts[i], reserveIn, reserveOut);</span>
 80 |     | <span class='neutral'>        }</span>
 81 |     | <span class='neutral'>    }</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>    // performs chained getAmountIn calculations on any number of pairs</span>
 84 |     | <span class='unexecuted'>    function getAmountsIn(address factory, uint256 amountOut, address[] memory path)</span>
 85 |     | <span class='neutral'>        internal</span>
 86 |     | <span class='unexecuted'>        returns (uint256[] memory amounts)</span>
 87 |     | <span class='neutral'>    {</span>
 88 |     | <span class='unexecuted'>        require(path.length &gt;= 2, &quot;UniswapV2Library: INVALID_PATH&quot;);</span>
 89 |     | <span class='unexecuted'>        amounts = new uint256[](path.length);</span>
 90 |     | <span class='unexecuted'>        amounts[amounts.length - 1] = amountOut;</span>
 91 |     | <span class='unexecuted'>        for (uint256 i = path.length - 1; i &gt; 0; i--) {</span>
 92 |     | <span class='unexecuted'>            (uint256 reserveIn, uint256 reserveOut) = getReserves(factory, path[i - 1], path[i]);</span>
 93 |     | <span class='unexecuted'>            amounts[i - 1] = getAmountIn(amounts[i], reserveIn, reserveOut);</span>
 94 |     | <span class='neutral'>        }</span>
 95 |     | <span class='neutral'>    }</span>
 96 |     | <span class='neutral'>}</span>
 97 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/NoDelegateCall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.12;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Prevents delegatecall to a contract</span>
  5 |     | <span class='neutral'>/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract</span>
  6 |     | <span class='neutral'>/// @dev    Changed pragma to &gt;=0.8.12</span>
  7 |     | <span class='neutral'>abstract contract NoDelegateCall {</span>
  8 |     | <span class='neutral'>    /// @dev The original address of this contract</span>
  9 |     | <span class='neutral'>    address private immutable original;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    constructor() {</span>
 12 |     | <span class='neutral'>        // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.</span>
 13 |     | <span class='neutral'>        // In other words, this variable won&#39;t change when it&#39;s checked at runtime.</span>
 14 |     | <span class='unexecuted'>        original = address(this);</span>
 15 |     | <span class='neutral'>    }</span>
 16 |     | <span class='neutral'></span>
 17 |     | <span class='neutral'>    /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,</span>
 18 |     | <span class='neutral'>    ///     and the use of immutable means the address bytes are copied in every place the modifier is used.</span>
 19 |     | <span class='unexecuted'>    function checkNotDelegateCall() private view {</span>
 20 |     | <span class='unexecuted'>        require(address(this) == original);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Prevents delegatecall into the modified method</span>
 24 |     | <span class='neutral'>    modifier noDelegateCall() {</span>
 25 |     | <span class='unexecuted'>        checkNotDelegateCall();</span>
 26 |     | <span class='unexecuted'>        _;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>
 29 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.12;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IUniswapV3Factory} from</span>
  5 |     | <span class='neutral'>    &quot;./interfaces/IUniswapV3Factory.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {UniswapV3PoolDeployer} from &quot;./UniswapV3PoolDeployer.sol&quot;;</span>
  8 |     | <span class='neutral'>import {NoDelegateCall} from &quot;./NoDelegateCall.sol&quot;;</span>
  9 |     | <span class='neutral'>import {UniswapV3Pool} from &quot;./UniswapV3Pool.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title Canonical Uniswap V3 factory</span>
 12 |     | <span class='neutral'>/// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees</span>
 13 |     | <span class='neutral'>/// @dev    Changed pragma to &gt;=0.8.12</span>
 14 |     | <span class='unexecuted'>contract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {</span>
 15 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 16 |     | <span class='unexecuted'>    address public override owner;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 19 |     | <span class='unexecuted'>    mapping(uint24 =&gt; int24) public override feeAmountTickSpacing;</span>
 20 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 21 |     | <span class='unexecuted'>    mapping(address =&gt; mapping(address =&gt; mapping(uint24 =&gt; address))) public override getPool;</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>    constructor() {</span>
 24 |     | <span class='unexecuted'>        owner = msg.sender;</span>
 25 |     | <span class='unexecuted'>        emit OwnerChanged(address(0), msg.sender);</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='unexecuted'>        feeAmountTickSpacing[500] = 10;</span>
 28 |     | <span class='unexecuted'>        emit FeeAmountEnabled(500, 10);</span>
 29 |     | <span class='unexecuted'>        feeAmountTickSpacing[3000] = 60;</span>
 30 |     | <span class='unexecuted'>        emit FeeAmountEnabled(3000, 60);</span>
 31 |     | <span class='unexecuted'>        feeAmountTickSpacing[10_000] = 200;</span>
 32 |     | <span class='unexecuted'>        emit FeeAmountEnabled(10_000, 200);</span>
 33 |     | <span class='neutral'>    }</span>
 34 |     | <span class='neutral'></span>
 35 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 36 |     | <span class='unexecuted'>    function createPool(</span>
 37 |     | <span class='neutral'>        address tokenA,</span>
 38 |     | <span class='neutral'>        address tokenB,</span>
 39 |     | <span class='neutral'>        uint24 fee</span>
 40 |     | <span class='unexecuted'>    ) external override noDelegateCall returns (address pool) {</span>
 41 |     | <span class='unexecuted'>        require(tokenA != tokenB);</span>
 42 |     | <span class='unexecuted'>        (address token0, address token1) = tokenA &lt; tokenB ? (tokenA, tokenB) : (tokenB, tokenA);</span>
 43 |     | <span class='unexecuted'>        require(token0 != address(0));</span>
 44 |     | <span class='unexecuted'>        int24 tickSpacing = feeAmountTickSpacing[fee];</span>
 45 |     | <span class='unexecuted'>        require(tickSpacing != 0);</span>
 46 |     | <span class='unexecuted'>        require(getPool[token0][token1][fee] == address(0));</span>
 47 |     | <span class='unexecuted'>        pool = deploy(address(this), token0, token1, fee, tickSpacing);</span>
 48 |     | <span class='unexecuted'>        getPool[token0][token1][fee] = pool;</span>
 49 |     | <span class='neutral'>        // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses</span>
 50 |     | <span class='unexecuted'>        getPool[token1][token0][fee] = pool;</span>
 51 |     | <span class='unexecuted'>        emit PoolCreated(token0, token1, fee, tickSpacing, pool);</span>
 52 |     | <span class='neutral'>    }</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 55 |     | <span class='unexecuted'>    function setOwner(address _owner) external override {</span>
 56 |     | <span class='unexecuted'>        require(msg.sender == owner);</span>
 57 |     | <span class='unexecuted'>        emit OwnerChanged(owner, _owner);</span>
 58 |     | <span class='unexecuted'>        owner = _owner;</span>
 59 |     | <span class='neutral'>    }</span>
 60 |     | <span class='neutral'></span>
 61 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3Factory</span>
 62 |     | <span class='unexecuted'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {</span>
 63 |     | <span class='unexecuted'>        require(msg.sender == owner);</span>
 64 |     | <span class='unexecuted'>        require(fee &lt; 1_000_000);</span>
 65 |     | <span class='neutral'>        // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that</span>
 66 |     | <span class='neutral'>        // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick</span>
 67 |     | <span class='neutral'>        // 16384 ticks represents a &gt;5x price change with ticks of 1 bips</span>
 68 |     | <span class='unexecuted'>        require(tickSpacing &gt; 0 &amp;&amp; tickSpacing &lt; 16_384);</span>
 69 |     | <span class='unexecuted'>        require(feeAmountTickSpacing[fee] == 0);</span>
 70 |     | <span class='neutral'></span>
 71 |     | <span class='unexecuted'>        feeAmountTickSpacing[fee] = tickSpacing;</span>
 72 |     | <span class='unexecuted'>        emit FeeAmountEnabled(fee, tickSpacing);</span>
 73 |     | <span class='neutral'>    }</span>
 74 |     | <span class='neutral'>}</span>
 75 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3Pool.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Pool.sol&#39;;</span>
   5 |     | <span class='neutral'></span>
   6 |     | <span class='neutral'>import &#39;./NoDelegateCall.sol&#39;;</span>
   7 |     | <span class='neutral'></span>
   8 |     | <span class='neutral'>import &#39;./libraries/LowGasSafeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./libraries/SafeCast.sol&#39;;</span>
  10 |     | <span class='neutral'>import &#39;./libraries/Tick.sol&#39;;</span>
  11 |     | <span class='neutral'>import &#39;./libraries/TickBitmap.sol&#39;;</span>
  12 |     | <span class='neutral'>import &#39;./libraries/Position.sol&#39;;</span>
  13 |     | <span class='neutral'>import &#39;./libraries/Oracle.sol&#39;;</span>
  14 |     | <span class='neutral'></span>
  15 |     | <span class='neutral'>import &#39;./libraries/FullMath.sol&#39;;</span>
  16 |     | <span class='neutral'>import &#39;./libraries/FixedPoint128.sol&#39;;</span>
  17 |     | <span class='neutral'>import &#39;./libraries/TransferHelper.sol&#39;;</span>
  18 |     | <span class='neutral'>import &#39;./libraries/TickMath.sol&#39;;</span>
  19 |     | <span class='neutral'>import &#39;./libraries/LiquidityMath.sol&#39;;</span>
  20 |     | <span class='neutral'>import &#39;./libraries/SqrtPriceMath.sol&#39;;</span>
  21 |     | <span class='neutral'>import &#39;./libraries/SwapMath.sol&#39;;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3PoolDeployer.sol&#39;;</span>
  24 |     | <span class='neutral'>import &#39;./interfaces/IUniswapV3Factory.sol&#39;;</span>
  25 |     | <span class='neutral'>import &#39;./interfaces/IERC20Minimal.sol&#39;;</span>
  26 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3MintCallback.sol&#39;;</span>
  27 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3SwapCallback.sol&#39;;</span>
  28 |     | <span class='neutral'>import &#39;./interfaces/callback/IUniswapV3FlashCallback.sol&#39;;</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='unexecuted'>contract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {</span>
  31 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  32 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
  33 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  34 |     | <span class='neutral'>    using SafeCast for int256;</span>
  35 |     | <span class='neutral'>    using Tick for mapping(int24 =&gt; Tick.Info);</span>
  36 |     | <span class='neutral'>    using TickBitmap for mapping(int16 =&gt; uint256);</span>
  37 |     | <span class='neutral'>    using Position for mapping(bytes32 =&gt; Position.Info);</span>
  38 |     | <span class='neutral'>    using Position for Position.Info;</span>
  39 |     | <span class='neutral'>    using Oracle for Oracle.Observation[65535];</span>
  40 |     | <span class='neutral'></span>
  41 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  42 |     | <span class='unexecuted'>    address public immutable override factory;</span>
  43 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  44 |     | <span class='unexecuted'>    address public immutable override token0;</span>
  45 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  46 |     | <span class='unexecuted'>    address public immutable override token1;</span>
  47 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  48 |     | <span class='unexecuted'>    uint24 public immutable override fee;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  51 |     | <span class='unexecuted'>    int24 public immutable override tickSpacing;</span>
  52 |     | <span class='neutral'></span>
  53 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolImmutables</span>
  54 |     | <span class='unexecuted'>    uint128 public immutable override maxLiquidityPerTick;</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    struct Slot0 {</span>
  57 |     | <span class='neutral'>        // the current price</span>
  58 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
  59 |     | <span class='neutral'>        // the current tick</span>
  60 |     | <span class='neutral'>        int24 tick;</span>
  61 |     | <span class='neutral'>        // the most-recently updated index of the observations array</span>
  62 |     | <span class='neutral'>        uint16 observationIndex;</span>
  63 |     | <span class='neutral'>        // the current maximum number of observations that are being stored</span>
  64 |     | <span class='neutral'>        uint16 observationCardinality;</span>
  65 |     | <span class='neutral'>        // the next maximum number of observations to store, triggered in observations.write</span>
  66 |     | <span class='neutral'>        uint16 observationCardinalityNext;</span>
  67 |     | <span class='neutral'>        // the current protocol fee as a percentage of the swap fee taken on withdrawal</span>
  68 |     | <span class='neutral'>        // represented as an integer denominator (1/x)%</span>
  69 |     | <span class='neutral'>        uint8 feeProtocol;</span>
  70 |     | <span class='neutral'>        // whether the pool is locked</span>
  71 |     | <span class='neutral'>        bool unlocked;</span>
  72 |     | <span class='neutral'>    }</span>
  73 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  74 |     | <span class='unexecuted'>    Slot0 public override slot0;</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  77 |     | <span class='unexecuted'>    uint256 public override feeGrowthGlobal0X128;</span>
  78 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  79 |     | <span class='unexecuted'>    uint256 public override feeGrowthGlobal1X128;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    // accumulated protocol fees in token0/token1 units</span>
  82 |     | <span class='neutral'>    struct ProtocolFees {</span>
  83 |     | <span class='neutral'>        uint128 token0;</span>
  84 |     | <span class='neutral'>        uint128 token1;</span>
  85 |     | <span class='neutral'>    }</span>
  86 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  87 |     | <span class='unexecuted'>    ProtocolFees public override protocolFees;</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  90 |     | <span class='unexecuted'>    uint128 public override liquidity;</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  93 |     | <span class='unexecuted'>    mapping(int24 =&gt; Tick.Info) public override ticks;</span>
  94 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  95 |     | <span class='unexecuted'>    mapping(int16 =&gt; uint256) public override tickBitmap;</span>
  96 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  97 |     | <span class='unexecuted'>    mapping(bytes32 =&gt; Position.Info) public override positions;</span>
  98 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolState</span>
  99 |     | <span class='unexecuted'>    Oracle.Observation[65535] public override observations;</span>
 100 |     | <span class='neutral'></span>
 101 |     | <span class='neutral'>    /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance</span>
 102 |     | <span class='neutral'>    /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because</span>
 103 |     | <span class='neutral'>    /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.</span>
 104 |     | <span class='neutral'>    modifier lock() {</span>
 105 |     | <span class='unexecuted'>        require(slot0.unlocked, &#39;LOK&#39;);</span>
 106 |     | <span class='unexecuted'>        slot0.unlocked = false;</span>
 107 |     | <span class='neutral'>        _;</span>
 108 |     | <span class='unexecuted'>        slot0.unlocked = true;</span>
 109 |     | <span class='neutral'>    }</span>
 110 |     | <span class='neutral'></span>
 111 |     | <span class='neutral'>    /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()</span>
 112 |     | <span class='neutral'>    modifier onlyFactoryOwner() {</span>
 113 |     | <span class='unexecuted'>        require(msg.sender == IUniswapV3Factory(factory).owner());</span>
 114 |     | <span class='neutral'>        _;</span>
 115 |     | <span class='neutral'>    }</span>
 116 |     | <span class='neutral'></span>
 117 |     | <span class='unexecuted'>    constructor() {</span>
 118 |     | <span class='unexecuted'>        int24 _tickSpacing;</span>
 119 |     | <span class='unexecuted'>        (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();</span>
 120 |     | <span class='unexecuted'>        tickSpacing = _tickSpacing;</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='unexecuted'>        maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);</span>
 123 |     | <span class='neutral'>    }</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='neutral'>    /// @dev Common checks for valid tick inputs.</span>
 126 |     | <span class='unexecuted'>    function checkTicks(int24 tickLower, int24 tickUpper) private pure {</span>
 127 |     | <span class='unexecuted'>        require(tickLower &lt; tickUpper, &#39;TLU&#39;);</span>
 128 |     | <span class='unexecuted'>        require(tickLower &gt;= TickMath.MIN_TICK, &#39;TLM&#39;);</span>
 129 |     | <span class='unexecuted'>        require(tickUpper &lt;= TickMath.MAX_TICK, &#39;TUM&#39;);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.</span>
 133 |     | <span class='neutral'>    function _blockTimestamp() internal view virtual returns (uint32) {</span>
 134 |     | <span class='unexecuted'>        return uint32(block.timestamp); // truncation is desired</span>
 135 |     | <span class='neutral'>    }</span>
 136 |     | <span class='neutral'></span>
 137 |     | <span class='neutral'>    /// @dev Get the pool&#39;s balance of token0</span>
 138 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
 139 |     | <span class='neutral'>    /// check</span>
 140 |     | <span class='unexecuted'>    function balance0() private view returns (uint256) {</span>
 141 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 142 |     | <span class='unexecuted'>            token0.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));</span>
 143 |     | <span class='unexecuted'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 144 |     | <span class='unexecuted'>        return abi.decode(data, (uint256));</span>
 145 |     | <span class='neutral'>    }</span>
 146 |     | <span class='neutral'></span>
 147 |     | <span class='neutral'>    /// @dev Get the pool&#39;s balance of token1</span>
 148 |     | <span class='neutral'>    /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize</span>
 149 |     | <span class='neutral'>    /// check</span>
 150 |     | <span class='unexecuted'>    function balance1() private view returns (uint256) {</span>
 151 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 152 |     | <span class='unexecuted'>            token1.staticcall(abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this)));</span>
 153 |     | <span class='neutral'>        require(success &amp;&amp; data.length &gt;= 32);</span>
 154 |     | <span class='neutral'>        return abi.decode(data, (uint256));</span>
 155 |     | <span class='neutral'>    }</span>
 156 |     | <span class='neutral'></span>
 157 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
 158 |     | <span class='unexecuted'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 159 |     | <span class='neutral'>        external</span>
 160 |     | <span class='neutral'>        view</span>
 161 |     | <span class='neutral'>        override</span>
 162 |     | <span class='neutral'>        noDelegateCall</span>
 163 |     | <span class='neutral'>        returns (</span>
 164 |     | <span class='unexecuted'>            int56 tickCumulativeInside,</span>
 165 |     | <span class='unexecuted'>            uint160 secondsPerLiquidityInsideX128,</span>
 166 |     | <span class='unexecuted'>            uint32 secondsInside</span>
 167 |     | <span class='neutral'>        )</span>
 168 |     | <span class='neutral'>    {</span>
 169 |     | <span class='unexecuted'>        checkTicks(tickLower, tickUpper);</span>
 170 |     | <span class='neutral'></span>
 171 |     | <span class='unexecuted'>        int56 tickCumulativeLower;</span>
 172 |     | <span class='neutral'>        int56 tickCumulativeUpper;</span>
 173 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideLowerX128;</span>
 174 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideUpperX128;</span>
 175 |     | <span class='neutral'>        uint32 secondsOutsideLower;</span>
 176 |     | <span class='neutral'>        uint32 secondsOutsideUpper;</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>        {</span>
 179 |     | <span class='unexecuted'>            Tick.Info storage lower = ticks[tickLower];</span>
 180 |     | <span class='unexecuted'>            Tick.Info storage upper = ticks[tickUpper];</span>
 181 |     | <span class='neutral'>            bool initializedLower;</span>
 182 |     | <span class='neutral'>            (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (</span>
 183 |     | <span class='unexecuted'>                lower.tickCumulativeOutside,</span>
 184 |     | <span class='unexecuted'>                lower.secondsPerLiquidityOutsideX128,</span>
 185 |     | <span class='unexecuted'>                lower.secondsOutside,</span>
 186 |     | <span class='unexecuted'>                lower.initialized</span>
 187 |     | <span class='neutral'>            );</span>
 188 |     | <span class='unexecuted'>            require(initializedLower);</span>
 189 |     | <span class='neutral'></span>
 190 |     | <span class='neutral'>            bool initializedUpper;</span>
 191 |     | <span class='neutral'>            (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (</span>
 192 |     | <span class='unexecuted'>                upper.tickCumulativeOutside,</span>
 193 |     | <span class='unexecuted'>                upper.secondsPerLiquidityOutsideX128,</span>
 194 |     | <span class='unexecuted'>                upper.secondsOutside,</span>
 195 |     | <span class='unexecuted'>                upper.initialized</span>
 196 |     | <span class='neutral'>            );</span>
 197 |     | <span class='unexecuted'>            require(initializedUpper);</span>
 198 |     | <span class='neutral'>        }</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        Slot0 memory _slot0 = slot0;</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='unexecuted'>        if (_slot0.tick &lt; tickLower) {</span>
 203 |     | <span class='unexecuted'>            return (</span>
 204 |     | <span class='unexecuted'>                tickCumulativeLower - tickCumulativeUpper,</span>
 205 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,</span>
 206 |     | <span class='unexecuted'>                secondsOutsideLower - secondsOutsideUpper</span>
 207 |     | <span class='neutral'>            );</span>
 208 |     | <span class='unexecuted'>        } else if (_slot0.tick &lt; tickUpper) {</span>
 209 |     | <span class='unexecuted'>            uint32 time = _blockTimestamp();</span>
 210 |     | <span class='unexecuted'>            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =</span>
 211 |     | <span class='unexecuted'>                observations.observeSingle(</span>
 212 |     | <span class='neutral'>                    time,</span>
 213 |     | <span class='neutral'>                    0,</span>
 214 |     | <span class='unexecuted'>                    _slot0.tick,</span>
 215 |     | <span class='unexecuted'>                    _slot0.observationIndex,</span>
 216 |     | <span class='unexecuted'>                    liquidity,</span>
 217 |     | <span class='unexecuted'>                    _slot0.observationCardinality</span>
 218 |     | <span class='neutral'>                );</span>
 219 |     | <span class='unexecuted'>            return (</span>
 220 |     | <span class='unexecuted'>                tickCumulative - tickCumulativeLower - tickCumulativeUpper,</span>
 221 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128 -</span>
 222 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideLowerX128 -</span>
 223 |     | <span class='unexecuted'>                    secondsPerLiquidityOutsideUpperX128,</span>
 224 |     | <span class='unexecuted'>                time - secondsOutsideLower - secondsOutsideUpper</span>
 225 |     | <span class='neutral'>            );</span>
 226 |     | <span class='neutral'>        } else {</span>
 227 |     | <span class='neutral'>            return (</span>
 228 |     | <span class='unexecuted'>                tickCumulativeUpper - tickCumulativeLower,</span>
 229 |     | <span class='unexecuted'>                secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,</span>
 230 |     | <span class='unexecuted'>                secondsOutsideUpper - secondsOutsideLower</span>
 231 |     | <span class='neutral'>            );</span>
 232 |     | <span class='neutral'>        }</span>
 233 |     | <span class='neutral'>    }</span>
 234 |     | <span class='neutral'></span>
 235 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDerivedState</span>
 236 |     | <span class='unexecuted'>    function observe(uint32[] calldata secondsAgos)</span>
 237 |     | <span class='neutral'>        external</span>
 238 |     | <span class='neutral'>        view</span>
 239 |     | <span class='neutral'>        override</span>
 240 |     | <span class='neutral'>        noDelegateCall</span>
 241 |     | <span class='unexecuted'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)</span>
 242 |     | <span class='neutral'>    {</span>
 243 |     | <span class='unexecuted'>        return</span>
 244 |     | <span class='unexecuted'>            observations.observe(</span>
 245 |     | <span class='neutral'>                _blockTimestamp(),</span>
 246 |     | <span class='unexecuted'>                secondsAgos,</span>
 247 |     | <span class='unexecuted'>                slot0.tick,</span>
 248 |     | <span class='unexecuted'>                slot0.observationIndex,</span>
 249 |     | <span class='unexecuted'>                liquidity,</span>
 250 |     | <span class='unexecuted'>                slot0.observationCardinality</span>
 251 |     | <span class='neutral'>            );</span>
 252 |     | <span class='neutral'>    }</span>
 253 |     | <span class='neutral'></span>
 254 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 255 |     | <span class='unexecuted'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext)</span>
 256 |     | <span class='neutral'>        external</span>
 257 |     | <span class='neutral'>        override</span>
 258 |     | <span class='neutral'>        lock</span>
 259 |     | <span class='neutral'>        noDelegateCall</span>
 260 |     | <span class='neutral'>    {</span>
 261 |     | <span class='unexecuted'>        uint16 observationCardinalityNextOld = slot0.observationCardinalityNext; // for the event</span>
 262 |     | <span class='unexecuted'>        uint16 observationCardinalityNextNew =</span>
 263 |     | <span class='unexecuted'>            observations.grow(observationCardinalityNextOld, observationCardinalityNext);</span>
 264 |     | <span class='unexecuted'>        slot0.observationCardinalityNext = observationCardinalityNextNew;</span>
 265 |     | <span class='unexecuted'>        if (observationCardinalityNextOld != observationCardinalityNextNew)</span>
 266 |     | <span class='unexecuted'>            emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);</span>
 267 |     | <span class='neutral'>    }</span>
 268 |     | <span class='neutral'></span>
 269 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 270 |     | <span class='neutral'>    /// @dev not locked because it initializes unlocked</span>
 271 |     | <span class='unexecuted'>    function initialize(uint160 sqrtPriceX96) external override {</span>
 272 |     | <span class='unexecuted'>        require(slot0.sqrtPriceX96 == 0, &#39;AI&#39;);</span>
 273 |     | <span class='neutral'></span>
 274 |     | <span class='unexecuted'>        int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);</span>
 275 |     | <span class='neutral'></span>
 276 |     | <span class='unexecuted'>        (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());</span>
 277 |     | <span class='neutral'></span>
 278 |     | <span class='unexecuted'>        slot0 = Slot0({</span>
 279 |     | <span class='neutral'>            sqrtPriceX96: sqrtPriceX96,</span>
 280 |     | <span class='neutral'>            tick: tick,</span>
 281 |     | <span class='neutral'>            observationIndex: 0,</span>
 282 |     | <span class='neutral'>            observationCardinality: cardinality,</span>
 283 |     | <span class='neutral'>            observationCardinalityNext: cardinalityNext,</span>
 284 |     | <span class='neutral'>            feeProtocol: 0,</span>
 285 |     | <span class='neutral'>            unlocked: true</span>
 286 |     | <span class='neutral'>        });</span>
 287 |     | <span class='neutral'></span>
 288 |     | <span class='unexecuted'>        emit Initialize(sqrtPriceX96, tick);</span>
 289 |     | <span class='neutral'>    }</span>
 290 |     | <span class='neutral'></span>
 291 |     | <span class='neutral'>    struct ModifyPositionParams {</span>
 292 |     | <span class='neutral'>        // the address that owns the position</span>
 293 |     | <span class='neutral'>        address owner;</span>
 294 |     | <span class='neutral'>        // the lower and upper tick of the position</span>
 295 |     | <span class='neutral'>        int24 tickLower;</span>
 296 |     | <span class='neutral'>        int24 tickUpper;</span>
 297 |     | <span class='neutral'>        // any change in liquidity</span>
 298 |     | <span class='neutral'>        int128 liquidityDelta;</span>
 299 |     | <span class='neutral'>    }</span>
 300 |     | <span class='neutral'></span>
 301 |     | <span class='neutral'>    event Message(string a);</span>
 302 |     | <span class='neutral'>    event MessageUint160(string a, uint160 b);</span>
 303 |     | <span class='neutral'>    event MessageUint128(string a, int128 b);</span>
 304 |     | <span class='neutral'></span>
 305 |     | <span class='neutral'>    /// @dev Effect some changes to a position</span>
 306 |     | <span class='neutral'>    /// @param params the position details and the change to the position&#39;s liquidity to effect</span>
 307 |     | <span class='neutral'>    /// @return position a storage pointer referencing the position with the given owner and tick range</span>
 308 |     | <span class='neutral'>    /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient</span>
 309 |     | <span class='neutral'>    /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient</span>
 310 |     | <span class='unexecuted'>    function _modifyPosition(ModifyPositionParams memory params)</span>
 311 |     | <span class='neutral'>        private</span>
 312 |     | <span class='neutral'>        noDelegateCall</span>
 313 |     | <span class='neutral'>        returns (</span>
 314 |     | <span class='unexecuted'>            Position.Info storage position,</span>
 315 |     | <span class='unexecuted'>            int256 amount0,</span>
 316 |     | <span class='unexecuted'>            int256 amount1</span>
 317 |     | <span class='neutral'>        )</span>
 318 |     | <span class='unexecuted'>    {</span>
 319 |     | <span class='unexecuted'>        checkTicks(params.tickLower, params.tickUpper);</span>
 320 |     | <span class='neutral'></span>
 321 |     | <span class='unexecuted'>        Slot0 memory _slot0 = slot0; // SLOAD for gas optimization</span>
 322 |     | <span class='neutral'></span>
 323 |     | <span class='unexecuted'>        emit Message(&quot;HERE&quot;);</span>
 324 |     | <span class='unexecuted'>        position = _updatePosition(</span>
 325 |     | <span class='unexecuted'>            params.owner,</span>
 326 |     | <span class='unexecuted'>            params.tickLower,</span>
 327 |     | <span class='unexecuted'>            params.tickUpper,</span>
 328 |     | <span class='unexecuted'>            params.liquidityDelta,</span>
 329 |     | <span class='unexecuted'>            _slot0.tick</span>
 330 |     | <span class='neutral'>        );</span>
 331 |     | <span class='unexecuted'>        emit Message(&quot;HERE1&quot;);</span>
 332 |     | <span class='unexecuted'>        if (params.liquidityDelta != 0) {</span>
 333 |     | <span class='unexecuted'>            if (_slot0.tick &lt; params.tickLower) {</span>
 334 |     | <span class='neutral'>                // current tick is below the passed range; liquidity can only become in range by crossing from left to</span>
 335 |     | <span class='neutral'>                // right, when we&#39;ll need _more_ token0 (it&#39;s becoming more valuable) so user must provide it</span>
 336 |     | <span class='unexecuted'>                emit Message(&quot;HERE2&quot;);</span>
 337 |     | <span class='unexecuted'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
 338 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 339 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 340 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
 341 |     | <span class='neutral'>                );</span>
 342 |     | <span class='unexecuted'>                emit Message(&quot;HERE3&quot;);</span>
 343 |     | <span class='unexecuted'>            } else if (_slot0.tick &lt; params.tickUpper) {</span>
 344 |     | <span class='unexecuted'>                emit Message(&quot;HERE4&quot;);</span>
 345 |     | <span class='neutral'>                // current tick is inside the passed range</span>
 346 |     | <span class='unexecuted'>                uint128 liquidityBefore = liquidity; // SLOAD for gas optimization</span>
 347 |     | <span class='neutral'></span>
 348 |     | <span class='neutral'>                // write an oracle entry</span>
 349 |     | <span class='unexecuted'>                (slot0.observationIndex, slot0.observationCardinality) = observations.write(</span>
 350 |     | <span class='unexecuted'>                    _slot0.observationIndex,</span>
 351 |     | <span class='neutral'>                    _blockTimestamp(),</span>
 352 |     | <span class='unexecuted'>                    _slot0.tick,</span>
 353 |     | <span class='unexecuted'>                    liquidityBefore,</span>
 354 |     | <span class='unexecuted'>                    _slot0.observationCardinality,</span>
 355 |     | <span class='unexecuted'>                    _slot0.observationCardinalityNext</span>
 356 |     | <span class='neutral'>                );</span>
 357 |     | <span class='unexecuted'>                emit Message(&quot;HERE4a&quot;);</span>
 358 |     | <span class='unexecuted'>                emit MessageUint160(&quot;sqrtA&quot;, _slot0.sqrtPriceX96);</span>
 359 |     | <span class='unexecuted'>                emit MessageUint160(&quot;sqrtB&quot;, TickMath.getSqrtRatioAtTick(params.tickUpper));</span>
 360 |     | <span class='unexecuted'>                emit MessageUint128(&quot;liquidity&quot;, params.liquidityDelta);</span>
 361 |     | <span class='unexecuted'>                amount0 = SqrtPriceMath.getAmount0Delta(</span>
 362 |     | <span class='unexecuted'>                    _slot0.sqrtPriceX96,</span>
 363 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 364 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
 365 |     | <span class='neutral'>                );</span>
 366 |     | <span class='unexecuted'>                emit Message(&quot;HERE4b&quot;);</span>
 367 |     | <span class='unexecuted'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
 368 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 369 |     | <span class='unexecuted'>                    _slot0.sqrtPriceX96,</span>
 370 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
 371 |     | <span class='neutral'>                );</span>
 372 |     | <span class='unexecuted'>                emit Message(&quot;HERE4c&quot;);</span>
 373 |     | <span class='neutral'></span>
 374 |     | <span class='unexecuted'>                liquidity = LiquidityMath.addDelta(liquidityBefore, params.liquidityDelta);</span>
 375 |     | <span class='unexecuted'>                emit Message(&quot;HERE5&quot;);</span>
 376 |     | <span class='neutral'>            } else {</span>
 377 |     | <span class='neutral'>                // current tick is above the passed range; liquidity can only become in range by crossing from right to</span>
 378 |     | <span class='neutral'>                // left, when we&#39;ll need _more_ token1 (it&#39;s becoming more valuable) so user must provide it</span>
 379 |     | <span class='unexecuted'>                emit Message(&quot;HERE6&quot;);</span>
 380 |     | <span class='unexecuted'>                amount1 = SqrtPriceMath.getAmount1Delta(</span>
 381 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickLower),</span>
 382 |     | <span class='unexecuted'>                    TickMath.getSqrtRatioAtTick(params.tickUpper),</span>
 383 |     | <span class='unexecuted'>                    params.liquidityDelta</span>
 384 |     | <span class='neutral'>                );</span>
 385 |     | <span class='unexecuted'>                emit Message(&quot;HERE7&quot;);</span>
 386 |     | <span class='neutral'>            }</span>
 387 |     | <span class='neutral'>        }</span>
 388 |     | <span class='unexecuted'>        emit Message(&quot;HERE8&quot;);</span>
 389 |     | <span class='neutral'>    }</span>
 390 |     | <span class='neutral'></span>
 391 |     | <span class='neutral'>    /// @dev Gets and updates a position with the given liquidity delta</span>
 392 |     | <span class='neutral'>    /// @param owner the owner of the position</span>
 393 |     | <span class='neutral'>    /// @param tickLower the lower tick of the position&#39;s tick range</span>
 394 |     | <span class='neutral'>    /// @param tickUpper the upper tick of the position&#39;s tick range</span>
 395 |     | <span class='neutral'>    /// @param tick the current tick, passed to avoid sloads</span>
 396 |     | <span class='unexecuted'>    function _updatePosition(</span>
 397 |     | <span class='neutral'>        address owner,</span>
 398 |     | <span class='neutral'>        int24 tickLower,</span>
 399 |     | <span class='neutral'>        int24 tickUpper,</span>
 400 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 401 |     | <span class='neutral'>        int24 tick</span>
 402 |     | <span class='unexecuted'>    ) private returns (Position.Info storage position) {</span>
 403 |     | <span class='unexecuted'>        position = positions.get(owner, tickLower, tickUpper);</span>
 404 |     | <span class='neutral'></span>
 405 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128; // SLOAD for gas optimization</span>
 406 |     | <span class='unexecuted'>        uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128; // SLOAD for gas optimization</span>
 407 |     | <span class='neutral'></span>
 408 |     | <span class='neutral'>        // if we need to update the ticks, do it</span>
 409 |     | <span class='neutral'>        bool flippedLower;</span>
 410 |     | <span class='neutral'>        bool flippedUpper;</span>
 411 |     | <span class='unexecuted'>        if (liquidityDelta != 0) {</span>
 412 |     | <span class='unexecuted'>            uint32 time = _blockTimestamp();</span>
 413 |     | <span class='unexecuted'>            (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) =</span>
 414 |     | <span class='unexecuted'>                observations.observeSingle(</span>
 415 |     | <span class='neutral'>                    time,</span>
 416 |     | <span class='neutral'>                    0,</span>
 417 |     | <span class='unexecuted'>                    slot0.tick,</span>
 418 |     | <span class='unexecuted'>                    slot0.observationIndex,</span>
 419 |     | <span class='unexecuted'>                    liquidity,</span>
 420 |     | <span class='unexecuted'>                    slot0.observationCardinality</span>
 421 |     | <span class='neutral'>                );</span>
 422 |     | <span class='neutral'></span>
 423 |     | <span class='unexecuted'>            flippedLower = ticks.update(</span>
 424 |     | <span class='unexecuted'>                tickLower,</span>
 425 |     | <span class='unexecuted'>                tick,</span>
 426 |     | <span class='unexecuted'>                liquidityDelta,</span>
 427 |     | <span class='unexecuted'>                _feeGrowthGlobal0X128,</span>
 428 |     | <span class='unexecuted'>                _feeGrowthGlobal1X128,</span>
 429 |     | <span class='neutral'>                secondsPerLiquidityCumulativeX128,</span>
 430 |     | <span class='neutral'>                tickCumulative,</span>
 431 |     | <span class='unexecuted'>                time,</span>
 432 |     | <span class='unexecuted'>                false,</span>
 433 |     | <span class='unexecuted'>                maxLiquidityPerTick</span>
 434 |     | <span class='neutral'>            );</span>
 435 |     | <span class='unexecuted'>            flippedUpper = ticks.update(</span>
 436 |     | <span class='unexecuted'>                tickUpper,</span>
 437 |     | <span class='unexecuted'>                tick,</span>
 438 |     | <span class='unexecuted'>                liquidityDelta,</span>
 439 |     | <span class='unexecuted'>                _feeGrowthGlobal0X128,</span>
 440 |     | <span class='unexecuted'>                _feeGrowthGlobal1X128,</span>
 441 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128,</span>
 442 |     | <span class='unexecuted'>                tickCumulative,</span>
 443 |     | <span class='unexecuted'>                time,</span>
 444 |     | <span class='unexecuted'>                true,</span>
 445 |     | <span class='unexecuted'>                maxLiquidityPerTick</span>
 446 |     | <span class='neutral'>            );</span>
 447 |     | <span class='neutral'></span>
 448 |     | <span class='unexecuted'>            if (flippedLower) {</span>
 449 |     | <span class='unexecuted'>                tickBitmap.flipTick(tickLower, tickSpacing);</span>
 450 |     | <span class='neutral'>            }</span>
 451 |     | <span class='unexecuted'>            if (flippedUpper) {</span>
 452 |     | <span class='unexecuted'>                tickBitmap.flipTick(tickUpper, tickSpacing);</span>
 453 |     | <span class='neutral'>            }</span>
 454 |     | <span class='neutral'>        }</span>
 455 |     | <span class='neutral'></span>
 456 |     | <span class='unexecuted'>        (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) =</span>
 457 |     | <span class='unexecuted'>            ticks.getFeeGrowthInside(tickLower, tickUpper, tick, _feeGrowthGlobal0X128, _feeGrowthGlobal1X128);</span>
 458 |     | <span class='neutral'></span>
 459 |     | <span class='unexecuted'>        position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);</span>
 460 |     | <span class='neutral'></span>
 461 |     | <span class='neutral'>        // clear any tick data that is no longer needed</span>
 462 |     | <span class='unexecuted'>        if (liquidityDelta &lt; 0) {</span>
 463 |     | <span class='unexecuted'>            if (flippedLower) {</span>
 464 |     | <span class='unexecuted'>                ticks.clear(tickLower);</span>
 465 |     | <span class='neutral'>            }</span>
 466 |     | <span class='unexecuted'>            if (flippedUpper) {</span>
 467 |     | <span class='unexecuted'>                ticks.clear(tickUpper);</span>
 468 |     | <span class='neutral'>            }</span>
 469 |     | <span class='neutral'>        }</span>
 470 |     | <span class='neutral'>    }</span>
 471 |     | <span class='neutral'>    event MessageAddress(string a, address b);</span>
 472 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 473 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
 474 |     | <span class='unexecuted'>    function mint(</span>
 475 |     | <span class='neutral'>        address recipient,</span>
 476 |     | <span class='neutral'>        int24 tickLower,</span>
 477 |     | <span class='neutral'>        int24 tickUpper,</span>
 478 |     | <span class='neutral'>        uint128 amount,</span>
 479 |     | <span class='neutral'>        bytes calldata data</span>
 480 |     | <span class='unexecuted'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
 481 |     | <span class='unexecuted'>        require(amount &gt; 0);</span>
 482 |     | <span class='unexecuted'>        (, int256 amount0Int, int256 amount1Int) =</span>
 483 |     | <span class='unexecuted'>            _modifyPosition(</span>
 484 |     | <span class='unexecuted'>                ModifyPositionParams({</span>
 485 |     | <span class='unexecuted'>                    owner: recipient,</span>
 486 |     | <span class='unexecuted'>                    tickLower: tickLower,</span>
 487 |     | <span class='unexecuted'>                    tickUpper: tickUpper,</span>
 488 |     | <span class='unexecuted'>                    liquidityDelta: int256(int128(amount)).toInt128()</span>
 489 |     | <span class='neutral'>                })</span>
 490 |     | <span class='neutral'>            );</span>
 491 |     | <span class='neutral'></span>
 492 |     | <span class='unexecuted'>        amount0 = uint256(amount0Int);</span>
 493 |     | <span class='unexecuted'>        amount1 = uint256(amount1Int);</span>
 494 |     | <span class='neutral'></span>
 495 |     | <span class='unexecuted'>        uint256 balance0Before;</span>
 496 |     | <span class='unexecuted'>        uint256 balance1Before;</span>
 497 |     | <span class='unexecuted'>        if (amount0 &gt; 0) balance0Before = balance0();</span>
 498 |     | <span class='unexecuted'>        if (amount1 &gt; 0) balance1Before = balance1();</span>
 499 |     | <span class='unexecuted'>        emit Message(&quot;BEFORE MINT&quot;);</span>
 500 |     | <span class='unexecuted'>        emit MessageAddress(&quot;msg.sender&quot;, msg.sender);</span>
 501 |     | <span class='unexecuted'>        IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);</span>
 502 |     | <span class='unexecuted'>        if (amount0 &gt; 0) require(balance0Before.add(amount0) &lt;= balance0(), &#39;M0&#39;);</span>
 503 |     | <span class='unexecuted'>        if (amount1 &gt; 0) require(balance1Before.add(amount1) &lt;= balance1(), &#39;M1&#39;);</span>
 504 |     | <span class='neutral'></span>
 505 |     | <span class='unexecuted'>        emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);</span>
 506 |     | <span class='neutral'>    }</span>
 507 |     | <span class='neutral'></span>
 508 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 509 |     | <span class='unexecuted'>    function collect(</span>
 510 |     | <span class='neutral'>        address recipient,</span>
 511 |     | <span class='neutral'>        int24 tickLower,</span>
 512 |     | <span class='neutral'>        int24 tickUpper,</span>
 513 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 514 |     | <span class='neutral'>        uint128 amount1Requested</span>
 515 |     | <span class='unexecuted'>    ) external override lock returns (uint128 amount0, uint128 amount1) {</span>
 516 |     | <span class='neutral'>        // we don&#39;t need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}</span>
 517 |     | <span class='unexecuted'>        Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);</span>
 518 |     | <span class='neutral'></span>
 519 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;</span>
 520 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;</span>
 521 |     | <span class='neutral'></span>
 522 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 523 |     | <span class='unexecuted'>            position.tokensOwed0 -= amount0;</span>
 524 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 525 |     | <span class='neutral'>        }</span>
 526 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 527 |     | <span class='unexecuted'>            position.tokensOwed1 -= amount1;</span>
 528 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 529 |     | <span class='neutral'>        }</span>
 530 |     | <span class='neutral'></span>
 531 |     | <span class='unexecuted'>        emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);</span>
 532 |     | <span class='neutral'>    }</span>
 533 |     | <span class='neutral'></span>
 534 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 535 |     | <span class='neutral'>    /// @dev noDelegateCall is applied indirectly via _modifyPosition</span>
 536 |     | <span class='unexecuted'>    function burn(</span>
 537 |     | <span class='neutral'>        int24 tickLower,</span>
 538 |     | <span class='neutral'>        int24 tickUpper,</span>
 539 |     | <span class='neutral'>        uint128 amount</span>
 540 |     | <span class='unexecuted'>    ) external override lock returns (uint256 amount0, uint256 amount1) {</span>
 541 |     | <span class='unexecuted'>        (Position.Info storage position, int256 amount0Int, int256 amount1Int) =</span>
 542 |     | <span class='unexecuted'>            _modifyPosition(</span>
 543 |     | <span class='unexecuted'>                ModifyPositionParams({</span>
 544 |     | <span class='unexecuted'>                    owner: msg.sender,</span>
 545 |     | <span class='neutral'>                    tickLower: tickLower,</span>
 546 |     | <span class='neutral'>                    tickUpper: tickUpper,</span>
 547 |     | <span class='unexecuted'>                    liquidityDelta: -int256(int128(amount)).toInt128()</span>
 548 |     | <span class='neutral'>                })</span>
 549 |     | <span class='neutral'>            );</span>
 550 |     | <span class='neutral'></span>
 551 |     | <span class='unexecuted'>        amount0 = uint256(-amount0Int);</span>
 552 |     | <span class='unexecuted'>        amount1 = uint256(-amount1Int);</span>
 553 |     | <span class='neutral'></span>
 554 |     | <span class='unexecuted'>        if (amount0 &gt; 0 || amount1 &gt; 0) {</span>
 555 |     | <span class='unexecuted'>            (position.tokensOwed0, position.tokensOwed1) = (</span>
 556 |     | <span class='unexecuted'>                position.tokensOwed0 + uint128(amount0),</span>
 557 |     | <span class='unexecuted'>                position.tokensOwed1 + uint128(amount1)</span>
 558 |     | <span class='neutral'>            );</span>
 559 |     | <span class='neutral'>        }</span>
 560 |     | <span class='neutral'></span>
 561 |     | <span class='unexecuted'>        emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);</span>
 562 |     | <span class='neutral'>    }</span>
 563 |     | <span class='neutral'></span>
 564 |     | <span class='neutral'>    struct SwapCache {</span>
 565 |     | <span class='neutral'>        // the protocol fee for the input token</span>
 566 |     | <span class='neutral'>        uint8 feeProtocol;</span>
 567 |     | <span class='neutral'>        // liquidity at the beginning of the swap</span>
 568 |     | <span class='neutral'>        uint128 liquidityStart;</span>
 569 |     | <span class='neutral'>        // the timestamp of the current block</span>
 570 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
 571 |     | <span class='neutral'>        // the current value of the tick accumulator, computed only if we cross an initialized tick</span>
 572 |     | <span class='neutral'>        int56 tickCumulative;</span>
 573 |     | <span class='neutral'>        // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick</span>
 574 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
 575 |     | <span class='neutral'>        // whether we&#39;ve computed and cached the above two accumulators</span>
 576 |     | <span class='neutral'>        bool computedLatestObservation;</span>
 577 |     | <span class='neutral'>    }</span>
 578 |     | <span class='neutral'></span>
 579 |     | <span class='neutral'>    // the top level state of the swap, the results of which are recorded in storage at the end</span>
 580 |     | <span class='neutral'>    struct SwapState {</span>
 581 |     | <span class='neutral'>        // the amount remaining to be swapped in/out of the input/output asset</span>
 582 |     | <span class='neutral'>        int256 amountSpecifiedRemaining;</span>
 583 |     | <span class='neutral'>        // the amount already swapped out/in of the output/input asset</span>
 584 |     | <span class='neutral'>        int256 amountCalculated;</span>
 585 |     | <span class='neutral'>        // current sqrt(price)</span>
 586 |     | <span class='neutral'>        uint160 sqrtPriceX96;</span>
 587 |     | <span class='neutral'>        // the tick associated with the current price</span>
 588 |     | <span class='neutral'>        int24 tick;</span>
 589 |     | <span class='neutral'>        // the global fee growth of the input token</span>
 590 |     | <span class='neutral'>        uint256 feeGrowthGlobalX128;</span>
 591 |     | <span class='neutral'>        // amount of input token paid as protocol fee</span>
 592 |     | <span class='neutral'>        uint128 protocolFee;</span>
 593 |     | <span class='neutral'>        // the current liquidity in range</span>
 594 |     | <span class='neutral'>        uint128 liquidity;</span>
 595 |     | <span class='neutral'>    }</span>
 596 |     | <span class='neutral'></span>
 597 |     | <span class='neutral'>    struct StepComputations {</span>
 598 |     | <span class='neutral'>        // the price at the beginning of the step</span>
 599 |     | <span class='neutral'>        uint160 sqrtPriceStartX96;</span>
 600 |     | <span class='neutral'>        // the next tick to swap to from the current tick in the swap direction</span>
 601 |     | <span class='neutral'>        int24 tickNext;</span>
 602 |     | <span class='neutral'>        // whether tickNext is initialized or not</span>
 603 |     | <span class='neutral'>        bool initialized;</span>
 604 |     | <span class='neutral'>        // sqrt(price) for the next tick (1/0)</span>
 605 |     | <span class='neutral'>        uint160 sqrtPriceNextX96;</span>
 606 |     | <span class='neutral'>        // how much is being swapped in in this step</span>
 607 |     | <span class='neutral'>        uint256 amountIn;</span>
 608 |     | <span class='neutral'>        // how much is being swapped out</span>
 609 |     | <span class='neutral'>        uint256 amountOut;</span>
 610 |     | <span class='neutral'>        // how much fee is being paid in</span>
 611 |     | <span class='neutral'>        uint256 feeAmount;</span>
 612 |     | <span class='neutral'>    }</span>
 613 |     | <span class='neutral'></span>
 614 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 615 |     | <span class='unexecuted'>    function swap(</span>
 616 |     | <span class='neutral'>        address recipient,</span>
 617 |     | <span class='neutral'>        bool zeroForOne,</span>
 618 |     | <span class='neutral'>        int256 amountSpecified,</span>
 619 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
 620 |     | <span class='neutral'>        bytes calldata data</span>
 621 |     | <span class='unexecuted'>    ) external override noDelegateCall returns (int256 amount0, int256 amount1) {</span>
 622 |     | <span class='unexecuted'>        require(amountSpecified != 0, &#39;AS&#39;);</span>
 623 |     | <span class='neutral'></span>
 624 |     | <span class='unexecuted'>        Slot0 memory slot0Start = slot0;</span>
 625 |     | <span class='neutral'></span>
 626 |     | <span class='unexecuted'>        require(slot0Start.unlocked, &#39;LOK&#39;);</span>
 627 |     | <span class='unexecuted'>        require(</span>
 628 |     | <span class='unexecuted'>            zeroForOne</span>
 629 |     | <span class='unexecuted'>                ? sqrtPriceLimitX96 &lt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &gt; TickMath.MIN_SQRT_RATIO</span>
 630 |     | <span class='unexecuted'>                : sqrtPriceLimitX96 &gt; slot0Start.sqrtPriceX96 &amp;&amp; sqrtPriceLimitX96 &lt; TickMath.MAX_SQRT_RATIO,</span>
 631 |     | <span class='neutral'>            &#39;SPL&#39;</span>
 632 |     | <span class='neutral'>        );</span>
 633 |     | <span class='neutral'></span>
 634 |     | <span class='unexecuted'>        slot0.unlocked = false;</span>
 635 |     | <span class='neutral'></span>
 636 |     | <span class='unexecuted'>        SwapCache memory cache =</span>
 637 |     | <span class='unexecuted'>            SwapCache({</span>
 638 |     | <span class='unexecuted'>                liquidityStart: liquidity,</span>
 639 |     | <span class='neutral'>                blockTimestamp: _blockTimestamp(),</span>
 640 |     | <span class='unexecuted'>                feeProtocol: zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol &gt;&gt; 4),</span>
 641 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128: 0,</span>
 642 |     | <span class='unexecuted'>                tickCumulative: 0,</span>
 643 |     | <span class='unexecuted'>                computedLatestObservation: false</span>
 644 |     | <span class='neutral'>            });</span>
 645 |     | <span class='neutral'></span>
 646 |     | <span class='unexecuted'>        bool exactInput = amountSpecified &gt; 0;</span>
 647 |     | <span class='neutral'></span>
 648 |     | <span class='unexecuted'>        SwapState memory state =</span>
 649 |     | <span class='unexecuted'>            SwapState({</span>
 650 |     | <span class='unexecuted'>                amountSpecifiedRemaining: amountSpecified,</span>
 651 |     | <span class='unexecuted'>                amountCalculated: 0,</span>
 652 |     | <span class='unexecuted'>                sqrtPriceX96: slot0Start.sqrtPriceX96,</span>
 653 |     | <span class='unexecuted'>                tick: slot0Start.tick,</span>
 654 |     | <span class='unexecuted'>                feeGrowthGlobalX128: zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,</span>
 655 |     | <span class='unexecuted'>                protocolFee: 0,</span>
 656 |     | <span class='unexecuted'>                liquidity: cache.liquidityStart</span>
 657 |     | <span class='neutral'>            });</span>
 658 |     | <span class='neutral'></span>
 659 |     | <span class='neutral'>        // continue swapping as long as we haven&#39;t used the entire input/output and haven&#39;t reached the price limit</span>
 660 |     | <span class='unexecuted'>        while (state.amountSpecifiedRemaining != 0 &amp;&amp; state.sqrtPriceX96 != sqrtPriceLimitX96) {</span>
 661 |     | <span class='neutral'>            StepComputations memory step;</span>
 662 |     | <span class='neutral'></span>
 663 |     | <span class='unexecuted'>            step.sqrtPriceStartX96 = state.sqrtPriceX96;</span>
 664 |     | <span class='neutral'></span>
 665 |     | <span class='unexecuted'>            (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(</span>
 666 |     | <span class='unexecuted'>                state.tick,</span>
 667 |     | <span class='unexecuted'>                tickSpacing,</span>
 668 |     | <span class='unexecuted'>                zeroForOne</span>
 669 |     | <span class='neutral'>            );</span>
 670 |     | <span class='neutral'></span>
 671 |     | <span class='neutral'>            // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds</span>
 672 |     | <span class='unexecuted'>            if (step.tickNext &lt; TickMath.MIN_TICK) {</span>
 673 |     | <span class='unexecuted'>                step.tickNext = TickMath.MIN_TICK;</span>
 674 |     | <span class='unexecuted'>            } else if (step.tickNext &gt; TickMath.MAX_TICK) {</span>
 675 |     | <span class='unexecuted'>                step.tickNext = TickMath.MAX_TICK;</span>
 676 |     | <span class='neutral'>            }</span>
 677 |     | <span class='neutral'></span>
 678 |     | <span class='neutral'>            // get the price for the next tick</span>
 679 |     | <span class='unexecuted'>            step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);</span>
 680 |     | <span class='neutral'></span>
 681 |     | <span class='neutral'>            // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted</span>
 682 |     | <span class='unexecuted'>            (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(</span>
 683 |     | <span class='unexecuted'>                state.sqrtPriceX96,</span>
 684 |     | <span class='unexecuted'>                (zeroForOne ? step.sqrtPriceNextX96 &lt; sqrtPriceLimitX96 : step.sqrtPriceNextX96 &gt; sqrtPriceLimitX96)</span>
 685 |     | <span class='unexecuted'>                    ? sqrtPriceLimitX96</span>
 686 |     | <span class='unexecuted'>                    : step.sqrtPriceNextX96,</span>
 687 |     | <span class='unexecuted'>                state.liquidity,</span>
 688 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining,</span>
 689 |     | <span class='unexecuted'>                fee</span>
 690 |     | <span class='neutral'>            );</span>
 691 |     | <span class='neutral'></span>
 692 |     | <span class='unexecuted'>            if (exactInput) {</span>
 693 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();</span>
 694 |     | <span class='unexecuted'>                state.amountCalculated = state.amountCalculated.sub(step.amountOut.toInt256());</span>
 695 |     | <span class='neutral'>            } else {</span>
 696 |     | <span class='unexecuted'>                state.amountSpecifiedRemaining += step.amountOut.toInt256();</span>
 697 |     | <span class='unexecuted'>                state.amountCalculated = state.amountCalculated.add((step.amountIn + step.feeAmount).toInt256());</span>
 698 |     | <span class='neutral'>            }</span>
 699 |     | <span class='neutral'></span>
 700 |     | <span class='neutral'>            // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee</span>
 701 |     | <span class='unexecuted'>            if (cache.feeProtocol &gt; 0) {</span>
 702 |     | <span class='unexecuted'>                uint256 delta = step.feeAmount / cache.feeProtocol;</span>
 703 |     | <span class='unexecuted'>                step.feeAmount -= delta;</span>
 704 |     | <span class='unexecuted'>                state.protocolFee += uint128(delta);</span>
 705 |     | <span class='neutral'>            }</span>
 706 |     | <span class='neutral'></span>
 707 |     | <span class='neutral'>            // update global fee tracker</span>
 708 |     | <span class='unexecuted'>            if (state.liquidity &gt; 0)</span>
 709 |     | <span class='unexecuted'>                state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);</span>
 710 |     | <span class='neutral'></span>
 711 |     | <span class='neutral'>            // shift tick if we reached the next price</span>
 712 |     | <span class='unexecuted'>            if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {</span>
 713 |     | <span class='neutral'>                // if the tick is initialized, run the tick transition</span>
 714 |     | <span class='unexecuted'>                if (step.initialized) {</span>
 715 |     | <span class='neutral'>                    // check for the placeholder value, which we replace with the actual value the first time the swap</span>
 716 |     | <span class='neutral'>                    // crosses an initialized tick</span>
 717 |     | <span class='unexecuted'>                    if (!cache.computedLatestObservation) {</span>
 718 |     | <span class='unexecuted'>                        (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(</span>
 719 |     | <span class='unexecuted'>                            cache.blockTimestamp,</span>
 720 |     | <span class='unexecuted'>                            0,</span>
 721 |     | <span class='unexecuted'>                            slot0Start.tick,</span>
 722 |     | <span class='unexecuted'>                            slot0Start.observationIndex,</span>
 723 |     | <span class='unexecuted'>                            cache.liquidityStart,</span>
 724 |     | <span class='unexecuted'>                            slot0Start.observationCardinality</span>
 725 |     | <span class='neutral'>                        );</span>
 726 |     | <span class='unexecuted'>                        cache.computedLatestObservation = true;</span>
 727 |     | <span class='neutral'>                    }</span>
 728 |     | <span class='unexecuted'>                    int128 liquidityNet =</span>
 729 |     | <span class='unexecuted'>                        ticks.cross(</span>
 730 |     | <span class='unexecuted'>                            step.tickNext,</span>
 731 |     | <span class='unexecuted'>                            (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),</span>
 732 |     | <span class='unexecuted'>                            (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),</span>
 733 |     | <span class='unexecuted'>                            cache.secondsPerLiquidityCumulativeX128,</span>
 734 |     | <span class='unexecuted'>                            cache.tickCumulative,</span>
 735 |     | <span class='unexecuted'>                            cache.blockTimestamp</span>
 736 |     | <span class='neutral'>                        );</span>
 737 |     | <span class='neutral'>                    // if we&#39;re moving leftward, we interpret liquidityNet as the opposite sign</span>
 738 |     | <span class='neutral'>                    // safe because liquidityNet cannot be type(int128).min</span>
 739 |     | <span class='unexecuted'>                    if (zeroForOne) liquidityNet = -liquidityNet;</span>
 740 |     | <span class='neutral'></span>
 741 |     | <span class='unexecuted'>                    state.liquidity = LiquidityMath.addDelta(state.liquidity, liquidityNet);</span>
 742 |     | <span class='neutral'>                }</span>
 743 |     | <span class='neutral'></span>
 744 |     | <span class='unexecuted'>                state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;</span>
 745 |     | <span class='unexecuted'>            } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {</span>
 746 |     | <span class='neutral'>                // recompute unless we&#39;re on a lower tick boundary (i.e. already transitioned ticks), and haven&#39;t moved</span>
 747 |     | <span class='unexecuted'>                state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);</span>
 748 |     | <span class='neutral'>            }</span>
 749 |     | <span class='neutral'>        }</span>
 750 |     | <span class='neutral'></span>
 751 |     | <span class='neutral'>        // update tick and write an oracle entry if the tick change</span>
 752 |     | <span class='unexecuted'>        if (state.tick != slot0Start.tick) {</span>
 753 |     | <span class='unexecuted'>            (uint16 observationIndex, uint16 observationCardinality) =</span>
 754 |     | <span class='unexecuted'>                observations.write(</span>
 755 |     | <span class='unexecuted'>                    slot0Start.observationIndex,</span>
 756 |     | <span class='unexecuted'>                    cache.blockTimestamp,</span>
 757 |     | <span class='unexecuted'>                    slot0Start.tick,</span>
 758 |     | <span class='unexecuted'>                    cache.liquidityStart,</span>
 759 |     | <span class='unexecuted'>                    slot0Start.observationCardinality,</span>
 760 |     | <span class='unexecuted'>                    slot0Start.observationCardinalityNext</span>
 761 |     | <span class='neutral'>                );</span>
 762 |     | <span class='unexecuted'>            (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (</span>
 763 |     | <span class='unexecuted'>                state.sqrtPriceX96,</span>
 764 |     | <span class='unexecuted'>                state.tick,</span>
 765 |     | <span class='neutral'>                observationIndex,</span>
 766 |     | <span class='neutral'>                observationCardinality</span>
 767 |     | <span class='neutral'>            );</span>
 768 |     | <span class='neutral'>        } else {</span>
 769 |     | <span class='neutral'>            // otherwise just update the price</span>
 770 |     | <span class='unexecuted'>            slot0.sqrtPriceX96 = state.sqrtPriceX96;</span>
 771 |     | <span class='neutral'>        }</span>
 772 |     | <span class='neutral'></span>
 773 |     | <span class='neutral'>        // update liquidity if it changed</span>
 774 |     | <span class='unexecuted'>        if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;</span>
 775 |     | <span class='neutral'></span>
 776 |     | <span class='neutral'>        // update fee growth global and, if necessary, protocol fees</span>
 777 |     | <span class='neutral'>        // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees</span>
 778 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 779 |     | <span class='unexecuted'>            feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;</span>
 780 |     | <span class='unexecuted'>            if (state.protocolFee &gt; 0) protocolFees.token0 += state.protocolFee;</span>
 781 |     | <span class='neutral'>        } else {</span>
 782 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;</span>
 783 |     | <span class='unexecuted'>            if (state.protocolFee &gt; 0) protocolFees.token1 += state.protocolFee;</span>
 784 |     | <span class='neutral'>        }</span>
 785 |     | <span class='neutral'></span>
 786 |     | <span class='unexecuted'>        (amount0, amount1) = zeroForOne == exactInput</span>
 787 |     | <span class='unexecuted'>            ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)</span>
 788 |     | <span class='unexecuted'>            : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);</span>
 789 |     | <span class='neutral'></span>
 790 |     | <span class='neutral'>        // do the transfers and collect payment</span>
 791 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 792 |     | <span class='unexecuted'>            if (amount1 &lt; 0) TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));</span>
 793 |     | <span class='neutral'></span>
 794 |     | <span class='unexecuted'>            uint256 balance0Before = balance0();</span>
 795 |     | <span class='unexecuted'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span>
 796 |     | <span class='unexecuted'>            require(balance0Before.add(uint256(amount0)) &lt;= balance0(), &#39;IIA&#39;);</span>
 797 |     | <span class='unexecuted'>        } else {</span>
 798 |     | <span class='unexecuted'>            if (amount0 &lt; 0) TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));</span>
 799 |     | <span class='neutral'></span>
 800 |     | <span class='unexecuted'>            uint256 balance1Before = balance1();</span>
 801 |     | <span class='unexecuted'>            IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);</span>
 802 |     | <span class='unexecuted'>            require(balance1Before.add(uint256(amount1)) &lt;= balance1(), &#39;IIA&#39;);</span>
 803 |     | <span class='neutral'>        }</span>
 804 |     | <span class='neutral'></span>
 805 |     | <span class='unexecuted'>        emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);</span>
 806 |     | <span class='unexecuted'>        slot0.unlocked = true;</span>
 807 |     | <span class='neutral'>    }</span>
 808 |     | <span class='neutral'></span>
 809 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolActions</span>
 810 |     | <span class='unexecuted'>    function flash(</span>
 811 |     | <span class='neutral'>        address recipient,</span>
 812 |     | <span class='neutral'>        uint256 amount0,</span>
 813 |     | <span class='neutral'>        uint256 amount1,</span>
 814 |     | <span class='neutral'>        bytes calldata data</span>
 815 |     | <span class='neutral'>    ) external override lock noDelegateCall {</span>
 816 |     | <span class='unexecuted'>        uint128 _liquidity = liquidity;</span>
 817 |     | <span class='unexecuted'>        require(_liquidity &gt; 0, &#39;L&#39;);</span>
 818 |     | <span class='neutral'></span>
 819 |     | <span class='unexecuted'>        uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);</span>
 820 |     | <span class='unexecuted'>        uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);</span>
 821 |     | <span class='unexecuted'>        uint256 balance0Before = balance0();</span>
 822 |     | <span class='unexecuted'>        uint256 balance1Before = balance1();</span>
 823 |     | <span class='neutral'></span>
 824 |     | <span class='unexecuted'>        if (amount0 &gt; 0) TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 825 |     | <span class='unexecuted'>        if (amount1 &gt; 0) TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 826 |     | <span class='neutral'></span>
 827 |     | <span class='unexecuted'>        IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);</span>
 828 |     | <span class='neutral'></span>
 829 |     | <span class='unexecuted'>        uint256 balance0After = balance0();</span>
 830 |     | <span class='unexecuted'>        uint256 balance1After = balance1();</span>
 831 |     | <span class='neutral'></span>
 832 |     | <span class='unexecuted'>        require(balance0Before.add(fee0) &lt;= balance0After, &#39;F0&#39;);</span>
 833 |     | <span class='unexecuted'>        require(balance1Before.add(fee1) &lt;= balance1After, &#39;F1&#39;);</span>
 834 |     | <span class='neutral'></span>
 835 |     | <span class='neutral'>        // sub is safe because we know balanceAfter is gt balanceBefore by at least fee</span>
 836 |     | <span class='unexecuted'>        uint256 paid0 = balance0After - balance0Before;</span>
 837 |     | <span class='unexecuted'>        uint256 paid1 = balance1After - balance1Before;</span>
 838 |     | <span class='neutral'></span>
 839 |     | <span class='unexecuted'>        if (paid0 &gt; 0) {</span>
 840 |     | <span class='unexecuted'>            uint8 feeProtocol0 = slot0.feeProtocol % 16;</span>
 841 |     | <span class='unexecuted'>            uint256 fees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;</span>
 842 |     | <span class='unexecuted'>            if (uint128(fees0) &gt; 0) protocolFees.token0 += uint128(fees0);</span>
 843 |     | <span class='unexecuted'>            feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - fees0, FixedPoint128.Q128, _liquidity);</span>
 844 |     | <span class='neutral'>        }</span>
 845 |     | <span class='unexecuted'>        if (paid1 &gt; 0) {</span>
 846 |     | <span class='unexecuted'>            uint8 feeProtocol1 = slot0.feeProtocol &gt;&gt; 4;</span>
 847 |     | <span class='unexecuted'>            uint256 fees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;</span>
 848 |     | <span class='unexecuted'>            if (uint128(fees1) &gt; 0) protocolFees.token1 += uint128(fees1);</span>
 849 |     | <span class='unexecuted'>            feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - fees1, FixedPoint128.Q128, _liquidity);</span>
 850 |     | <span class='neutral'>        }</span>
 851 |     | <span class='neutral'></span>
 852 |     | <span class='unexecuted'>        emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);</span>
 853 |     | <span class='neutral'>    }</span>
 854 |     | <span class='neutral'></span>
 855 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 856 |     | <span class='unexecuted'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {</span>
 857 |     | <span class='unexecuted'>        require(</span>
 858 |     | <span class='unexecuted'>            (feeProtocol0 == 0 || (feeProtocol0 &gt;= 4 &amp;&amp; feeProtocol0 &lt;= 10)) &amp;&amp;</span>
 859 |     | <span class='unexecuted'>                (feeProtocol1 == 0 || (feeProtocol1 &gt;= 4 &amp;&amp; feeProtocol1 &lt;= 10))</span>
 860 |     | <span class='neutral'>        );</span>
 861 |     | <span class='unexecuted'>        uint8 feeProtocolOld = slot0.feeProtocol;</span>
 862 |     | <span class='unexecuted'>        slot0.feeProtocol = feeProtocol0 + (feeProtocol1 &lt;&lt; 4);</span>
 863 |     | <span class='unexecuted'>        emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld &gt;&gt; 4, feeProtocol0, feeProtocol1);</span>
 864 |     | <span class='neutral'>    }</span>
 865 |     | <span class='neutral'></span>
 866 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolOwnerActions</span>
 867 |     | <span class='unexecuted'>    function collectProtocol(</span>
 868 |     | <span class='neutral'>        address recipient,</span>
 869 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 870 |     | <span class='neutral'>        uint128 amount1Requested</span>
 871 |     | <span class='unexecuted'>    ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {</span>
 872 |     | <span class='unexecuted'>        amount0 = amount0Requested &gt; protocolFees.token0 ? protocolFees.token0 : amount0Requested;</span>
 873 |     | <span class='unexecuted'>        amount1 = amount1Requested &gt; protocolFees.token1 ? protocolFees.token1 : amount1Requested;</span>
 874 |     | <span class='neutral'></span>
 875 |     | <span class='unexecuted'>        if (amount0 &gt; 0) {</span>
 876 |     | <span class='unexecuted'>            if (amount0 == protocolFees.token0) amount0--; // ensure that the slot is not cleared, for gas savings</span>
 877 |     | <span class='unexecuted'>            protocolFees.token0 -= amount0;</span>
 878 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token0, recipient, amount0);</span>
 879 |     | <span class='neutral'>        }</span>
 880 |     | <span class='unexecuted'>        if (amount1 &gt; 0) {</span>
 881 |     | <span class='unexecuted'>            if (amount1 == protocolFees.token1) amount1--; // ensure that the slot is not cleared, for gas savings</span>
 882 |     | <span class='unexecuted'>            protocolFees.token1 -= amount1;</span>
 883 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token1, recipient, amount1);</span>
 884 |     | <span class='neutral'>        }</span>
 885 |     | <span class='neutral'></span>
 886 |     | <span class='unexecuted'>        emit CollectProtocol(msg.sender, recipient, amount0, amount1);</span>
 887 |     | <span class='neutral'>    }</span>
 888 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/UniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.12;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import {IUniswapV3PoolDeployer} from</span>
  5 |     | <span class='neutral'>    &quot;./interfaces/IUniswapV3PoolDeployer.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import {UniswapV3Pool} from &quot;./UniswapV3Pool.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>/// @dev    Changed pragma to &gt;=0.8.12</span>
 10 |     | <span class='unexecuted'>contract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {</span>
 11 |     | <span class='neutral'>    struct Parameters {</span>
 12 |     | <span class='neutral'>        address factory;</span>
 13 |     | <span class='neutral'>        address token0;</span>
 14 |     | <span class='neutral'>        address token1;</span>
 15 |     | <span class='neutral'>        uint24 fee;</span>
 16 |     | <span class='neutral'>        int24 tickSpacing;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3PoolDeployer</span>
 20 |     | <span class='unexecuted'>    Parameters public override parameters;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then</span>
 23 |     | <span class='neutral'>    /// clearing it after deploying the pool.</span>
 24 |     | <span class='neutral'>    /// @param factory The contract address of the Uniswap V3 factory</span>
 25 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 26 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 27 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 28 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 29 |     | <span class='unexecuted'>    function deploy(</span>
 30 |     | <span class='neutral'>        address factory,</span>
 31 |     | <span class='neutral'>        address token0,</span>
 32 |     | <span class='neutral'>        address token1,</span>
 33 |     | <span class='neutral'>        uint24 fee,</span>
 34 |     | <span class='neutral'>        int24 tickSpacing</span>
 35 |     | <span class='neutral'>    ) internal returns (address pool) {</span>
 36 |     | <span class='unexecuted'>        parameters = Parameters({</span>
 37 |     | <span class='neutral'>            factory: factory,</span>
 38 |     | <span class='neutral'>            token0: token0,</span>
 39 |     | <span class='neutral'>            token1: token1,</span>
 40 |     | <span class='neutral'>            fee: fee,</span>
 41 |     | <span class='neutral'>            tickSpacing: tickSpacing</span>
 42 |     | <span class='neutral'>        });</span>
 43 |     | <span class='unexecuted'>        pool = address(new UniswapV3Pool{salt: keccak256(abi.encode(token0, token1, fee))}());</span>
 44 |     | <span class='unexecuted'>        delete parameters;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IERC20Minimal.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Minimal ERC20 interface for Uniswap</span>
  5 |     | <span class='neutral'>/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3</span>
  6 |     | <span class='neutral'>interface IERC20Minimal {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the balance of a token</span>
  8 |     | <span class='neutral'>    /// @param account The account for which to look up the number of tokens it has, i.e. its balance</span>
  9 |     | <span class='neutral'>    /// @return The number of tokens held by the account</span>
 10 |     | <span class='neutral'>    function balanceOf(address account) external view returns (uint256);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Transfers the amount of token from the `msg.sender` to the recipient</span>
 13 |     | <span class='neutral'>    /// @param recipient The account that will receive the amount transferred</span>
 14 |     | <span class='neutral'>    /// @param amount The number of tokens to send from the sender to the recipient</span>
 15 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for an unsuccessful transfer</span>
 16 |     | <span class='neutral'>    function transfer(address recipient, uint256 amount) external returns (bool);</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Returns the current allowance given to a spender by an owner</span>
 19 |     | <span class='neutral'>    /// @param owner The account of the token owner</span>
 20 |     | <span class='neutral'>    /// @param spender The account of the token spender</span>
 21 |     | <span class='neutral'>    /// @return The current allowance granted by `owner` to `spender`</span>
 22 |     | <span class='neutral'>    function allowance(address owner, address spender) external view returns (uint256);</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`</span>
 25 |     | <span class='neutral'>    /// @param spender The account which will be allowed to spend a given amount of the owners tokens</span>
 26 |     | <span class='neutral'>    /// @param amount The amount of tokens allowed to be used by `spender`</span>
 27 |     | <span class='neutral'>    /// @return Returns true for a successful approval, false for unsuccessful</span>
 28 |     | <span class='neutral'>    function approve(address spender, uint256 amount) external returns (bool);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`</span>
 31 |     | <span class='neutral'>    /// @param sender The account from which the transfer will be initiated</span>
 32 |     | <span class='neutral'>    /// @param recipient The recipient of the transfer</span>
 33 |     | <span class='neutral'>    /// @param amount The amount of the transfer</span>
 34 |     | <span class='neutral'>    /// @return Returns true for a successful transfer, false for unsuccessful</span>
 35 |     | <span class='neutral'>    function transferFrom(</span>
 36 |     | <span class='neutral'>        address sender,</span>
 37 |     | <span class='neutral'>        address recipient,</span>
 38 |     | <span class='neutral'>        uint256 amount</span>
 39 |     | <span class='neutral'>    ) external returns (bool);</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.</span>
 42 |     | <span class='neutral'>    /// @param from The account from which the tokens were sent, i.e. the balance decreased</span>
 43 |     | <span class='neutral'>    /// @param to The account to which the tokens were sent, i.e. the balance increased</span>
 44 |     | <span class='neutral'>    /// @param value The amount of tokens that were transferred</span>
 45 |     | <span class='neutral'>    event Transfer(address indexed from, address indexed to, uint256 value);</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Event emitted when the approval amount for the spender of a given owner&#39;s tokens changes.</span>
 48 |     | <span class='neutral'>    /// @param owner The account that approved spending of its tokens</span>
 49 |     | <span class='neutral'>    /// @param spender The account for which the spending allowance was modified</span>
 50 |     | <span class='neutral'>    /// @param value The new allowance from the owner to the spender</span>
 51 |     | <span class='neutral'>    event Approval(address indexed owner, address indexed spender, uint256 value);</span>
 52 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3Factory.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title The interface for the Uniswap V3 Factory</span>
  5 |     | <span class='neutral'>/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees</span>
  6 |     | <span class='neutral'>interface IUniswapV3Factory {</span>
  7 |     | <span class='neutral'>    /// @notice Emitted when the owner of the factory is changed</span>
  8 |     | <span class='neutral'>    /// @param oldOwner The owner before the owner was changed</span>
  9 |     | <span class='neutral'>    /// @param newOwner The owner after the owner was changed</span>
 10 |     | <span class='neutral'>    event OwnerChanged(address indexed oldOwner, address indexed newOwner);</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Emitted when a pool is created</span>
 13 |     | <span class='neutral'>    /// @param token0 The first token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// @param token1 The second token of the pool by address sort order</span>
 15 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 16 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks</span>
 17 |     | <span class='neutral'>    /// @param pool The address of the created pool</span>
 18 |     | <span class='neutral'>    event PoolCreated(</span>
 19 |     | <span class='neutral'>        address indexed token0,</span>
 20 |     | <span class='neutral'>        address indexed token1,</span>
 21 |     | <span class='neutral'>        uint24 indexed fee,</span>
 22 |     | <span class='neutral'>        int24 tickSpacing,</span>
 23 |     | <span class='neutral'>        address pool</span>
 24 |     | <span class='neutral'>    );</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory</span>
 27 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip</span>
 28 |     | <span class='neutral'>    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee</span>
 29 |     | <span class='neutral'>    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns the current owner of the factory</span>
 32 |     | <span class='neutral'>    /// @dev Can be changed by the current owner via setOwner</span>
 33 |     | <span class='neutral'>    /// @return The address of the factory owner</span>
 34 |     | <span class='neutral'>    function owner() external view returns (address);</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled</span>
 37 |     | <span class='neutral'>    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context</span>
 38 |     | <span class='neutral'>    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee</span>
 39 |     | <span class='neutral'>    /// @return The tick spacing</span>
 40 |     | <span class='neutral'>    function feeAmountTickSpacing(uint24 fee) external view returns (int24);</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist</span>
 43 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order</span>
 44 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 45 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 46 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 47 |     | <span class='neutral'>    /// @return pool The pool address</span>
 48 |     | <span class='neutral'>    function getPool(</span>
 49 |     | <span class='neutral'>        address tokenA,</span>
 50 |     | <span class='neutral'>        address tokenB,</span>
 51 |     | <span class='neutral'>        uint24 fee</span>
 52 |     | <span class='neutral'>    ) external view returns (address pool);</span>
 53 |     | <span class='neutral'></span>
 54 |     | <span class='neutral'>    /// @notice Creates a pool for the given two tokens and fee</span>
 55 |     | <span class='neutral'>    /// @param tokenA One of the two tokens in the desired pool</span>
 56 |     | <span class='neutral'>    /// @param tokenB The other of the two tokens in the desired pool</span>
 57 |     | <span class='neutral'>    /// @param fee The desired fee for the pool</span>
 58 |     | <span class='neutral'>    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved</span>
 59 |     | <span class='neutral'>    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments</span>
 60 |     | <span class='neutral'>    /// are invalid.</span>
 61 |     | <span class='neutral'>    /// @return pool The address of the newly created pool</span>
 62 |     | <span class='neutral'>    function createPool(</span>
 63 |     | <span class='neutral'>        address tokenA,</span>
 64 |     | <span class='neutral'>        address tokenB,</span>
 65 |     | <span class='neutral'>        uint24 fee</span>
 66 |     | <span class='neutral'>    ) external returns (address pool);</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>    /// @notice Updates the owner of the factory</span>
 69 |     | <span class='neutral'>    /// @dev Must be called by the current owner</span>
 70 |     | <span class='neutral'>    /// @param _owner The new owner of the factory</span>
 71 |     | <span class='neutral'>    function setOwner(address _owner) external;</span>
 72 |     | <span class='neutral'></span>
 73 |     | <span class='neutral'>    /// @notice Enables a fee amount with the given tickSpacing</span>
 74 |     | <span class='neutral'>    /// @dev Fee amounts may never be removed once enabled</span>
 75 |     | <span class='neutral'>    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)</span>
 76 |     | <span class='neutral'>    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount</span>
 77 |     | <span class='neutral'>    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;</span>
 78 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3Pool.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolImmutables.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolState.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolDerivedState.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolActions.sol&#39;;</span>
  8 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolOwnerActions.sol&#39;;</span>
  9 |     | <span class='neutral'>import &#39;./pool/IUniswapV3PoolEvents.sol&#39;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>/// @title The interface for a Uniswap V3 Pool</span>
 12 |     | <span class='neutral'>/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform</span>
 13 |     | <span class='neutral'>/// to the ERC20 specification</span>
 14 |     | <span class='neutral'>/// @dev The pool interface is broken up into many smaller pieces</span>
 15 |     | <span class='neutral'>interface IUniswapV3Pool is</span>
 16 |     | <span class='neutral'>    IUniswapV3PoolImmutables,</span>
 17 |     | <span class='neutral'>    IUniswapV3PoolState,</span>
 18 |     | <span class='neutral'>    IUniswapV3PoolDerivedState,</span>
 19 |     | <span class='neutral'>    IUniswapV3PoolActions,</span>
 20 |     | <span class='neutral'>    IUniswapV3PoolOwnerActions,</span>
 21 |     | <span class='neutral'>    IUniswapV3PoolEvents</span>
 22 |     | <span class='neutral'>{</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/IUniswapV3PoolDeployer.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools</span>
  5 |     | <span class='neutral'>/// @notice A contract that constructs a pool must implement this to pass arguments to the pool</span>
  6 |     | <span class='neutral'>/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash</span>
  7 |     | <span class='neutral'>/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain</span>
  8 |     | <span class='neutral'>interface IUniswapV3PoolDeployer {</span>
  9 |     | <span class='neutral'>    /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.</span>
 10 |     | <span class='neutral'>    /// @dev Called by the pool constructor to fetch the parameters of the pool</span>
 11 |     | <span class='neutral'>    /// Returns factory The factory address</span>
 12 |     | <span class='neutral'>    /// Returns token0 The first token of the pool by address sort order</span>
 13 |     | <span class='neutral'>    /// Returns token1 The second token of the pool by address sort order</span>
 14 |     | <span class='neutral'>    /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 15 |     | <span class='neutral'>    /// Returns tickSpacing The minimum number of ticks between initialized ticks</span>
 16 |     | <span class='neutral'>    function parameters()</span>
 17 |     | <span class='neutral'>        external</span>
 18 |     | <span class='neutral'>        view</span>
 19 |     | <span class='neutral'>        returns (</span>
 20 |     | <span class='neutral'>            address factory,</span>
 21 |     | <span class='neutral'>            address token0,</span>
 22 |     | <span class='neutral'>            address token1,</span>
 23 |     | <span class='neutral'>            uint24 fee,</span>
 24 |     | <span class='neutral'>            int24 tickSpacing</span>
 25 |     | <span class='neutral'>        );</span>
 26 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3FlashCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#flash</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3FlashCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param fee0 The fee amount in token0 due to the pool by the end of the flash</span>
 11 |     | <span class='neutral'>    /// @param fee1 The fee amount in token1 due to the pool by the end of the flash</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call</span>
 13 |     | <span class='neutral'>    function uniswapV3FlashCallback(</span>
 14 |     | <span class='neutral'>        uint256 fee0,</span>
 15 |     | <span class='neutral'>        uint256 fee1,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3MintCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#mint</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3MintCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity</span>
 11 |     | <span class='neutral'>    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity</span>
 12 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call</span>
 13 |     | <span class='neutral'>    function uniswapV3MintCallback(</span>
 14 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 15 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 16 |     | <span class='neutral'>        bytes calldata data</span>
 17 |     | <span class='neutral'>    ) external;</span>
 18 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/callback/IUniswapV3SwapCallback.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Callback for IUniswapV3PoolActions#swap</span>
  5 |     | <span class='neutral'>/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface</span>
  6 |     | <span class='neutral'>interface IUniswapV3SwapCallback {</span>
  7 |     | <span class='neutral'>    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.</span>
  8 |     | <span class='neutral'>    /// @dev In the implementation you must pay the pool tokens owed for the swap.</span>
  9 |     | <span class='neutral'>    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.</span>
 10 |     | <span class='neutral'>    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.</span>
 11 |     | <span class='neutral'>    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by</span>
 12 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.</span>
 13 |     | <span class='neutral'>    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by</span>
 14 |     | <span class='neutral'>    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.</span>
 15 |     | <span class='neutral'>    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call</span>
 16 |     | <span class='neutral'>    function uniswapV3SwapCallback(</span>
 17 |     | <span class='neutral'>        int256 amount0Delta,</span>
 18 |     | <span class='neutral'>        int256 amount1Delta,</span>
 19 |     | <span class='neutral'>        bytes calldata data</span>
 20 |     | <span class='neutral'>    ) external;</span>
 21 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolActions.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Permissionless pool actions</span>
   5 |     | <span class='neutral'>/// @notice Contains pool methods that can be called by anyone</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolActions {</span>
   7 |     | <span class='neutral'>    /// @notice Sets the initial price for the pool</span>
   8 |     | <span class='neutral'>    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96</span>
  10 |     | <span class='neutral'>    function initialize(uint160 sqrtPriceX96) external;</span>
  11 |     | <span class='neutral'></span>
  12 |     | <span class='neutral'>    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position</span>
  13 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback</span>
  14 |     | <span class='neutral'>    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends</span>
  15 |     | <span class='neutral'>    /// on tickLower, tickUpper, the amount of liquidity, and the current price.</span>
  16 |     | <span class='neutral'>    /// @param recipient The address for which the liquidity will be created</span>
  17 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position in which to add liquidity</span>
  18 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position in which to add liquidity</span>
  19 |     | <span class='neutral'>    /// @param amount The amount of liquidity to mint</span>
  20 |     | <span class='neutral'>    /// @param data Any data that should be passed through to the callback</span>
  21 |     | <span class='neutral'>    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  22 |     | <span class='neutral'>    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback</span>
  23 |     | <span class='neutral'>    function mint(</span>
  24 |     | <span class='neutral'>        address recipient,</span>
  25 |     | <span class='neutral'>        int24 tickLower,</span>
  26 |     | <span class='neutral'>        int24 tickUpper,</span>
  27 |     | <span class='neutral'>        uint128 amount,</span>
  28 |     | <span class='neutral'>        bytes calldata data</span>
  29 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Collects tokens owed to a position</span>
  32 |     | <span class='neutral'>    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.</span>
  33 |     | <span class='neutral'>    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or</span>
  34 |     | <span class='neutral'>    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the</span>
  35 |     | <span class='neutral'>    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.</span>
  36 |     | <span class='neutral'>    /// @param recipient The address which should receive the fees collected</span>
  37 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to collect fees</span>
  38 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to collect fees</span>
  39 |     | <span class='neutral'>    /// @param amount0Requested How much token0 should be withdrawn from the fees owed</span>
  40 |     | <span class='neutral'>    /// @param amount1Requested How much token1 should be withdrawn from the fees owed</span>
  41 |     | <span class='neutral'>    /// @return amount0 The amount of fees collected in token0</span>
  42 |     | <span class='neutral'>    /// @return amount1 The amount of fees collected in token1</span>
  43 |     | <span class='neutral'>    function collect(</span>
  44 |     | <span class='neutral'>        address recipient,</span>
  45 |     | <span class='neutral'>        int24 tickLower,</span>
  46 |     | <span class='neutral'>        int24 tickUpper,</span>
  47 |     | <span class='neutral'>        uint128 amount0Requested,</span>
  48 |     | <span class='neutral'>        uint128 amount1Requested</span>
  49 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position</span>
  52 |     | <span class='neutral'>    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0</span>
  53 |     | <span class='neutral'>    /// @dev Fees must be collected separately via a call to #collect</span>
  54 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position for which to burn liquidity</span>
  55 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position for which to burn liquidity</span>
  56 |     | <span class='neutral'>    /// @param amount How much liquidity to burn</span>
  57 |     | <span class='neutral'>    /// @return amount0 The amount of token0 sent to the recipient</span>
  58 |     | <span class='neutral'>    /// @return amount1 The amount of token1 sent to the recipient</span>
  59 |     | <span class='neutral'>    function burn(</span>
  60 |     | <span class='neutral'>        int24 tickLower,</span>
  61 |     | <span class='neutral'>        int24 tickUpper,</span>
  62 |     | <span class='neutral'>        uint128 amount</span>
  63 |     | <span class='neutral'>    ) external returns (uint256 amount0, uint256 amount1);</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Swap token0 for token1, or token1 for token0</span>
  66 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback</span>
  67 |     | <span class='neutral'>    /// @param recipient The address to receive the output of the swap</span>
  68 |     | <span class='neutral'>    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0</span>
  69 |     | <span class='neutral'>    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)</span>
  70 |     | <span class='neutral'>    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this</span>
  71 |     | <span class='neutral'>    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap</span>
  72 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  73 |     | <span class='neutral'>    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive</span>
  74 |     | <span class='neutral'>    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive</span>
  75 |     | <span class='neutral'>    function swap(</span>
  76 |     | <span class='neutral'>        address recipient,</span>
  77 |     | <span class='neutral'>        bool zeroForOne,</span>
  78 |     | <span class='neutral'>        int256 amountSpecified,</span>
  79 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  80 |     | <span class='neutral'>        bytes calldata data</span>
  81 |     | <span class='neutral'>    ) external returns (int256 amount0, int256 amount1);</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback</span>
  84 |     | <span class='neutral'>    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback</span>
  85 |     | <span class='neutral'>    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling</span>
  86 |     | <span class='neutral'>    /// with 0 amount{0,1} and sending the donation amount(s) from the callback</span>
  87 |     | <span class='neutral'>    /// @param recipient The address which will receive the token0 and token1 amounts</span>
  88 |     | <span class='neutral'>    /// @param amount0 The amount of token0 to send</span>
  89 |     | <span class='neutral'>    /// @param amount1 The amount of token1 to send</span>
  90 |     | <span class='neutral'>    /// @param data Any data to be passed through to the callback</span>
  91 |     | <span class='neutral'>    function flash(</span>
  92 |     | <span class='neutral'>        address recipient,</span>
  93 |     | <span class='neutral'>        uint256 amount0,</span>
  94 |     | <span class='neutral'>        uint256 amount1,</span>
  95 |     | <span class='neutral'>        bytes calldata data</span>
  96 |     | <span class='neutral'>    ) external;</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Increase the maximum number of price and liquidity observations that this pool will store</span>
  99 |     | <span class='neutral'>    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to</span>
 100 |     | <span class='neutral'>    /// the input observationCardinalityNext.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store</span>
 102 |     | <span class='neutral'>    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;</span>
 103 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that is not stored</span>
  5 |     | <span class='neutral'>/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the</span>
  6 |     | <span class='neutral'>/// blockchain. The functions here may have variable gas costs.</span>
  7 |     | <span class='neutral'>interface IUniswapV3PoolDerivedState {</span>
  8 |     | <span class='neutral'>    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp</span>
  9 |     | <span class='neutral'>    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing</span>
 10 |     | <span class='neutral'>    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,</span>
 11 |     | <span class='neutral'>    /// you must call it with secondsAgos = [3600, 0].</span>
 12 |     | <span class='neutral'>    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in</span>
 13 |     | <span class='neutral'>    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.</span>
 14 |     | <span class='neutral'>    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned</span>
 15 |     | <span class='neutral'>    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp</span>
 16 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block</span>
 17 |     | <span class='neutral'>    /// timestamp</span>
 18 |     | <span class='neutral'>    function observe(uint32[] calldata secondsAgos)</span>
 19 |     | <span class='neutral'>        external</span>
 20 |     | <span class='neutral'>        view</span>
 21 |     | <span class='neutral'>        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range</span>
 24 |     | <span class='neutral'>    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.</span>
 25 |     | <span class='neutral'>    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first</span>
 26 |     | <span class='neutral'>    /// snapshot is taken and the second snapshot is taken.</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick of the range</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the range</span>
 29 |     | <span class='neutral'>    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range</span>
 30 |     | <span class='neutral'>    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range</span>
 31 |     | <span class='neutral'>    /// @return secondsInside The snapshot of seconds per liquidity for the range</span>
 32 |     | <span class='neutral'>    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)</span>
 33 |     | <span class='neutral'>        external</span>
 34 |     | <span class='neutral'>        view</span>
 35 |     | <span class='neutral'>        returns (</span>
 36 |     | <span class='neutral'>            int56 tickCumulativeInside,</span>
 37 |     | <span class='neutral'>            uint160 secondsPerLiquidityInsideX128,</span>
 38 |     | <span class='neutral'>            uint32 secondsInside</span>
 39 |     | <span class='neutral'>        );</span>
 40 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolEvents.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Events emitted by a pool</span>
   5 |     | <span class='neutral'>/// @notice Contains all events emitted by the pool</span>
   6 |     | <span class='neutral'>interface IUniswapV3PoolEvents {</span>
   7 |     | <span class='neutral'>    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool</span>
   8 |     | <span class='neutral'>    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize</span>
   9 |     | <span class='neutral'>    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96</span>
  10 |     | <span class='neutral'>    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool</span>
  11 |     | <span class='neutral'>    event Initialize(uint160 sqrtPriceX96, int24 tick);</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @notice Emitted when liquidity is minted for a given position</span>
  14 |     | <span class='neutral'>    /// @param sender The address that minted the liquidity</span>
  15 |     | <span class='neutral'>    /// @param owner The owner of the position and recipient of any minted liquidity</span>
  16 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  17 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  18 |     | <span class='neutral'>    /// @param amount The amount of liquidity minted to the position range</span>
  19 |     | <span class='neutral'>    /// @param amount0 How much token0 was required for the minted liquidity</span>
  20 |     | <span class='neutral'>    /// @param amount1 How much token1 was required for the minted liquidity</span>
  21 |     | <span class='neutral'>    event Mint(</span>
  22 |     | <span class='neutral'>        address sender,</span>
  23 |     | <span class='neutral'>        address indexed owner,</span>
  24 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  25 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  26 |     | <span class='neutral'>        uint128 amount,</span>
  27 |     | <span class='neutral'>        uint256 amount0,</span>
  28 |     | <span class='neutral'>        uint256 amount1</span>
  29 |     | <span class='neutral'>    );</span>
  30 |     | <span class='neutral'></span>
  31 |     | <span class='neutral'>    /// @notice Emitted when fees are collected by the owner of a position</span>
  32 |     | <span class='neutral'>    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees</span>
  33 |     | <span class='neutral'>    /// @param owner The owner of the position for which fees are collected</span>
  34 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  35 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  36 |     | <span class='neutral'>    /// @param amount0 The amount of token0 fees collected</span>
  37 |     | <span class='neutral'>    /// @param amount1 The amount of token1 fees collected</span>
  38 |     | <span class='neutral'>    event Collect(</span>
  39 |     | <span class='neutral'>        address indexed owner,</span>
  40 |     | <span class='neutral'>        address recipient,</span>
  41 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  42 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  43 |     | <span class='neutral'>        uint128 amount0,</span>
  44 |     | <span class='neutral'>        uint128 amount1</span>
  45 |     | <span class='neutral'>    );</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Emitted when a position&#39;s liquidity is removed</span>
  48 |     | <span class='neutral'>    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect</span>
  49 |     | <span class='neutral'>    /// @param owner The owner of the position for which liquidity is removed</span>
  50 |     | <span class='neutral'>    /// @param tickLower The lower tick of the position</span>
  51 |     | <span class='neutral'>    /// @param tickUpper The upper tick of the position</span>
  52 |     | <span class='neutral'>    /// @param amount The amount of liquidity to remove</span>
  53 |     | <span class='neutral'>    /// @param amount0 The amount of token0 withdrawn</span>
  54 |     | <span class='neutral'>    /// @param amount1 The amount of token1 withdrawn</span>
  55 |     | <span class='neutral'>    event Burn(</span>
  56 |     | <span class='neutral'>        address indexed owner,</span>
  57 |     | <span class='neutral'>        int24 indexed tickLower,</span>
  58 |     | <span class='neutral'>        int24 indexed tickUpper,</span>
  59 |     | <span class='neutral'>        uint128 amount,</span>
  60 |     | <span class='neutral'>        uint256 amount0,</span>
  61 |     | <span class='neutral'>        uint256 amount1</span>
  62 |     | <span class='neutral'>    );</span>
  63 |     | <span class='neutral'></span>
  64 |     | <span class='neutral'>    /// @notice Emitted by the pool for any swaps between token0 and token1</span>
  65 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  66 |     | <span class='neutral'>    /// @param recipient The address that received the output of the swap</span>
  67 |     | <span class='neutral'>    /// @param amount0 The delta of the token0 balance of the pool</span>
  68 |     | <span class='neutral'>    /// @param amount1 The delta of the token1 balance of the pool</span>
  69 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96</span>
  70 |     | <span class='neutral'>    /// @param liquidity The liquidity of the pool after the swap</span>
  71 |     | <span class='neutral'>    /// @param tick The log base 1.0001 of price of the pool after the swap</span>
  72 |     | <span class='neutral'>    event Swap(</span>
  73 |     | <span class='neutral'>        address indexed sender,</span>
  74 |     | <span class='neutral'>        address indexed recipient,</span>
  75 |     | <span class='neutral'>        int256 amount0,</span>
  76 |     | <span class='neutral'>        int256 amount1,</span>
  77 |     | <span class='neutral'>        uint160 sqrtPriceX96,</span>
  78 |     | <span class='neutral'>        uint128 liquidity,</span>
  79 |     | <span class='neutral'>        int24 tick</span>
  80 |     | <span class='neutral'>    );</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>    /// @notice Emitted by the pool for any flashes of token0/token1</span>
  83 |     | <span class='neutral'>    /// @param sender The address that initiated the swap call, and that received the callback</span>
  84 |     | <span class='neutral'>    /// @param recipient The address that received the tokens from flash</span>
  85 |     | <span class='neutral'>    /// @param amount0 The amount of token0 that was flashed</span>
  86 |     | <span class='neutral'>    /// @param amount1 The amount of token1 that was flashed</span>
  87 |     | <span class='neutral'>    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee</span>
  88 |     | <span class='neutral'>    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee</span>
  89 |     | <span class='neutral'>    event Flash(</span>
  90 |     | <span class='neutral'>        address indexed sender,</span>
  91 |     | <span class='neutral'>        address indexed recipient,</span>
  92 |     | <span class='neutral'>        uint256 amount0,</span>
  93 |     | <span class='neutral'>        uint256 amount1,</span>
  94 |     | <span class='neutral'>        uint256 paid0,</span>
  95 |     | <span class='neutral'>        uint256 paid1</span>
  96 |     | <span class='neutral'>    );</span>
  97 |     | <span class='neutral'></span>
  98 |     | <span class='neutral'>    /// @notice Emitted by the pool for increases to the number of observations that can be stored</span>
  99 |     | <span class='neutral'>    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index</span>
 100 |     | <span class='neutral'>    /// just before a mint/swap/burn.</span>
 101 |     | <span class='neutral'>    /// @param observationCardinalityNextOld The previous value of the next observation cardinality</span>
 102 |     | <span class='neutral'>    /// @param observationCardinalityNextNew The updated value of the next observation cardinality</span>
 103 |     | <span class='neutral'>    event IncreaseObservationCardinalityNext(</span>
 104 |     | <span class='neutral'>        uint16 observationCardinalityNextOld,</span>
 105 |     | <span class='neutral'>        uint16 observationCardinalityNextNew</span>
 106 |     | <span class='neutral'>    );</span>
 107 |     | <span class='neutral'></span>
 108 |     | <span class='neutral'>    /// @notice Emitted when the protocol fee is changed by the pool</span>
 109 |     | <span class='neutral'>    /// @param feeProtocol0Old The previous value of the token0 protocol fee</span>
 110 |     | <span class='neutral'>    /// @param feeProtocol1Old The previous value of the token1 protocol fee</span>
 111 |     | <span class='neutral'>    /// @param feeProtocol0New The updated value of the token0 protocol fee</span>
 112 |     | <span class='neutral'>    /// @param feeProtocol1New The updated value of the token1 protocol fee</span>
 113 |     | <span class='neutral'>    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner</span>
 116 |     | <span class='neutral'>    /// @param sender The address that collects the protocol fees</span>
 117 |     | <span class='neutral'>    /// @param recipient The address that receives the collected protocol fees</span>
 118 |     | <span class='neutral'>    /// @param amount0 The amount of token0 protocol fees that is withdrawn</span>
 119 |     | <span class='neutral'>    /// @param amount0 The amount of token1 protocol fees that is withdrawn</span>
 120 |     | <span class='neutral'>    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);</span>
 121 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolImmutables.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Pool state that never changes</span>
  5 |     | <span class='neutral'>/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolImmutables {</span>
  7 |     | <span class='neutral'>    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface</span>
  8 |     | <span class='neutral'>    /// @return The contract address</span>
  9 |     | <span class='neutral'>    function factory() external view returns (address);</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice The first of the two tokens of the pool, sorted by address</span>
 12 |     | <span class='neutral'>    /// @return The token contract address</span>
 13 |     | <span class='neutral'>    function token0() external view returns (address);</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice The second of the two tokens of the pool, sorted by address</span>
 16 |     | <span class='neutral'>    /// @return The token contract address</span>
 17 |     | <span class='neutral'>    function token1() external view returns (address);</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice The pool&#39;s fee in hundredths of a bip, i.e. 1e-6</span>
 20 |     | <span class='neutral'>    /// @return The fee</span>
 21 |     | <span class='neutral'>    function fee() external view returns (uint24);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice The pool tick spacing</span>
 24 |     | <span class='neutral'>    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive</span>
 25 |     | <span class='neutral'>    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...</span>
 26 |     | <span class='neutral'>    /// This value is an int24 to avoid casting even though it is always positive.</span>
 27 |     | <span class='neutral'>    /// @return The tick spacing</span>
 28 |     | <span class='neutral'>    function tickSpacing() external view returns (int24);</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice The maximum amount of position liquidity that can use any tick in the range</span>
 31 |     | <span class='neutral'>    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and</span>
 32 |     | <span class='neutral'>    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool</span>
 33 |     | <span class='neutral'>    /// @return The max amount of liquidity per tick</span>
 34 |     | <span class='neutral'>    function maxLiquidityPerTick() external view returns (uint128);</span>
 35 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Permissioned pool actions</span>
  5 |     | <span class='neutral'>/// @notice Contains pool methods that may only be called by the factory owner</span>
  6 |     | <span class='neutral'>interface IUniswapV3PoolOwnerActions {</span>
  7 |     | <span class='neutral'>    /// @notice Set the denominator of the protocol&#39;s % share of the fees</span>
  8 |     | <span class='neutral'>    /// @param feeProtocol0 new protocol fee for token0 of the pool</span>
  9 |     | <span class='neutral'>    /// @param feeProtocol1 new protocol fee for token1 of the pool</span>
 10 |     | <span class='neutral'>    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;</span>
 11 |     | <span class='neutral'></span>
 12 |     | <span class='neutral'>    /// @notice Collect the protocol fee accrued to the pool</span>
 13 |     | <span class='neutral'>    /// @param recipient The address to which collected protocol fees should be sent</span>
 14 |     | <span class='neutral'>    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1</span>
 15 |     | <span class='neutral'>    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0</span>
 16 |     | <span class='neutral'>    /// @return amount0 The protocol fee collected in token0</span>
 17 |     | <span class='neutral'>    /// @return amount1 The protocol fee collected in token1</span>
 18 |     | <span class='neutral'>    function collectProtocol(</span>
 19 |     | <span class='neutral'>        address recipient,</span>
 20 |     | <span class='neutral'>        uint128 amount0Requested,</span>
 21 |     | <span class='neutral'>        uint128 amount1Requested</span>
 22 |     | <span class='neutral'>    ) external returns (uint128 amount0, uint128 amount1);</span>
 23 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/interfaces/pool/IUniswapV3PoolState.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Pool state that can change</span>
   5 |     | <span class='neutral'>/// @notice These methods compose the pool&#39;s state, and can change with any frequency including multiple times</span>
   6 |     | <span class='neutral'>/// per transaction</span>
   7 |     | <span class='neutral'>interface IUniswapV3PoolState {</span>
   8 |     | <span class='neutral'>    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas</span>
   9 |     | <span class='neutral'>    /// when accessed externally.</span>
  10 |     | <span class='neutral'>    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value</span>
  11 |     | <span class='neutral'>    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.</span>
  12 |     | <span class='neutral'>    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick</span>
  13 |     | <span class='neutral'>    /// boundary.</span>
  14 |     | <span class='neutral'>    /// observationIndex The index of the last oracle observation that was written,</span>
  15 |     | <span class='neutral'>    /// observationCardinality The current maximum number of observations stored in the pool,</span>
  16 |     | <span class='neutral'>    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.</span>
  17 |     | <span class='neutral'>    /// feeProtocol The protocol fee for both tokens of the pool.</span>
  18 |     | <span class='neutral'>    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0</span>
  19 |     | <span class='neutral'>    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.</span>
  20 |     | <span class='neutral'>    /// unlocked Whether the pool is currently locked to reentrancy</span>
  21 |     | <span class='neutral'>    function slot0()</span>
  22 |     | <span class='neutral'>        external</span>
  23 |     | <span class='neutral'>        view</span>
  24 |     | <span class='neutral'>        returns (</span>
  25 |     | <span class='neutral'>            uint160 sqrtPriceX96,</span>
  26 |     | <span class='neutral'>            int24 tick,</span>
  27 |     | <span class='neutral'>            uint16 observationIndex,</span>
  28 |     | <span class='neutral'>            uint16 observationCardinality,</span>
  29 |     | <span class='neutral'>            uint16 observationCardinalityNext,</span>
  30 |     | <span class='neutral'>            uint8 feeProtocol,</span>
  31 |     | <span class='neutral'>            bool unlocked</span>
  32 |     | <span class='neutral'>        );</span>
  33 |     | <span class='neutral'></span>
  34 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool</span>
  35 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  36 |     | <span class='neutral'>    function feeGrowthGlobal0X128() external view returns (uint256);</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='neutral'>    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool</span>
  39 |     | <span class='neutral'>    /// @dev This value can overflow the uint256</span>
  40 |     | <span class='neutral'>    function feeGrowthGlobal1X128() external view returns (uint256);</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @notice The amounts of token0 and token1 that are owed to the protocol</span>
  43 |     | <span class='neutral'>    /// @dev Protocol fees will never exceed uint128 max in either token</span>
  44 |     | <span class='neutral'>    function protocolFees() external view returns (uint128 token0, uint128 token1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>    /// @notice The currently in range liquidity available to the pool</span>
  47 |     | <span class='neutral'>    /// @dev This value has no relationship to the total liquidity across all ticks</span>
  48 |     | <span class='neutral'>    function liquidity() external view returns (uint128);</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>    /// @notice Look up information about a specific tick in the pool</span>
  51 |     | <span class='neutral'>    /// @param tick The tick to look up</span>
  52 |     | <span class='neutral'>    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or</span>
  53 |     | <span class='neutral'>    /// tick upper,</span>
  54 |     | <span class='neutral'>    /// liquidityNet how much liquidity changes when the pool price crosses the tick,</span>
  55 |     | <span class='neutral'>    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,</span>
  56 |     | <span class='neutral'>    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,</span>
  57 |     | <span class='neutral'>    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick</span>
  58 |     | <span class='neutral'>    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,</span>
  59 |     | <span class='neutral'>    /// secondsOutside the seconds spent on the other side of the tick from the current tick,</span>
  60 |     | <span class='neutral'>    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.</span>
  61 |     | <span class='neutral'>    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.</span>
  62 |     | <span class='neutral'>    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for</span>
  63 |     | <span class='neutral'>    /// a specific position.</span>
  64 |     | <span class='neutral'>    function ticks(int24 tick)</span>
  65 |     | <span class='neutral'>        external</span>
  66 |     | <span class='neutral'>        view</span>
  67 |     | <span class='neutral'>        returns (</span>
  68 |     | <span class='neutral'>            uint128 liquidityGross,</span>
  69 |     | <span class='neutral'>            int128 liquidityNet,</span>
  70 |     | <span class='neutral'>            uint256 feeGrowthOutside0X128,</span>
  71 |     | <span class='neutral'>            uint256 feeGrowthOutside1X128,</span>
  72 |     | <span class='neutral'>            int56 tickCumulativeOutside,</span>
  73 |     | <span class='neutral'>            uint160 secondsPerLiquidityOutsideX128,</span>
  74 |     | <span class='neutral'>            uint32 secondsOutside,</span>
  75 |     | <span class='neutral'>            bool initialized</span>
  76 |     | <span class='neutral'>        );</span>
  77 |     | <span class='neutral'></span>
  78 |     | <span class='neutral'>    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information</span>
  79 |     | <span class='neutral'>    function tickBitmap(int16 wordPosition) external view returns (uint256);</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Returns the information about a position by the position&#39;s key</span>
  82 |     | <span class='neutral'>    /// @param key The position&#39;s key is a hash of a preimage composed by the owner, tickLower and tickUpper</span>
  83 |     | <span class='neutral'>    /// @return _liquidity The amount of liquidity in the position,</span>
  84 |     | <span class='neutral'>    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,</span>
  85 |     | <span class='neutral'>    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,</span>
  86 |     | <span class='neutral'>    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,</span>
  87 |     | <span class='neutral'>    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke</span>
  88 |     | <span class='neutral'>    function positions(bytes32 key)</span>
  89 |     | <span class='neutral'>        external</span>
  90 |     | <span class='neutral'>        view</span>
  91 |     | <span class='neutral'>        returns (</span>
  92 |     | <span class='neutral'>            uint128 _liquidity,</span>
  93 |     | <span class='neutral'>            uint256 feeGrowthInside0LastX128,</span>
  94 |     | <span class='neutral'>            uint256 feeGrowthInside1LastX128,</span>
  95 |     | <span class='neutral'>            uint128 tokensOwed0,</span>
  96 |     | <span class='neutral'>            uint128 tokensOwed1</span>
  97 |     | <span class='neutral'>        );</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Returns data about a specific observation index</span>
 100 |     | <span class='neutral'>    /// @param index The element of the observations array to fetch</span>
 101 |     | <span class='neutral'>    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time</span>
 102 |     | <span class='neutral'>    /// ago, rather than at a specific index in the array.</span>
 103 |     | <span class='neutral'>    /// @return blockTimestamp The timestamp of the observation,</span>
 104 |     | <span class='neutral'>    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,</span>
 105 |     | <span class='neutral'>    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,</span>
 106 |     | <span class='neutral'>    /// Returns initialized whether the observation has been initialized and the values are safe to use</span>
 107 |     | <span class='neutral'>    function observations(uint256 index)</span>
 108 |     | <span class='neutral'>        external</span>
 109 |     | <span class='neutral'>        view</span>
 110 |     | <span class='neutral'>        returns (</span>
 111 |     | <span class='neutral'>            uint32 blockTimestamp,</span>
 112 |     | <span class='neutral'>            int56 tickCumulative,</span>
 113 |     | <span class='neutral'>            uint160 secondsPerLiquidityCumulativeX128,</span>
 114 |     | <span class='neutral'>            bool initialized</span>
 115 |     | <span class='neutral'>        );</span>
 116 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/BitMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title BitMath</span>
  5 |     | <span class='neutral'>/// @dev This library provides functionality for computing bit properties of an unsigned integer</span>
  6 |     | <span class='unexecuted'>library BitMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns the index of the most significant bit of the number,</span>
  8 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
  9 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 10 |     | <span class='neutral'>    ///     x &gt;= 2**mostSignificantBit(x) and x &lt; 2**(mostSignificantBit(x)+1)</span>
 11 |     | <span class='neutral'>    /// @param x the value for which to compute the most significant bit, must be greater than 0</span>
 12 |     | <span class='neutral'>    /// @return r the index of the most significant bit</span>
 13 |     | <span class='unexecuted'>    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 14 |     | <span class='unexecuted'>        require(x &gt; 0);</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='unexecuted'>        if (x &gt;= 0x100000000000000000000000000000000) {</span>
 17 |     | <span class='unexecuted'>            x &gt;&gt;= 128;</span>
 18 |     | <span class='unexecuted'>            r += 128;</span>
 19 |     | <span class='neutral'>        }</span>
 20 |     | <span class='unexecuted'>        if (x &gt;= 0x10000000000000000) {</span>
 21 |     | <span class='unexecuted'>            x &gt;&gt;= 64;</span>
 22 |     | <span class='unexecuted'>            r += 64;</span>
 23 |     | <span class='neutral'>        }</span>
 24 |     | <span class='unexecuted'>        if (x &gt;= 0x100000000) {</span>
 25 |     | <span class='unexecuted'>            x &gt;&gt;= 32;</span>
 26 |     | <span class='unexecuted'>            r += 32;</span>
 27 |     | <span class='neutral'>        }</span>
 28 |     | <span class='unexecuted'>        if (x &gt;= 0x10000) {</span>
 29 |     | <span class='unexecuted'>            x &gt;&gt;= 16;</span>
 30 |     | <span class='unexecuted'>            r += 16;</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='unexecuted'>        if (x &gt;= 0x100) {</span>
 33 |     | <span class='unexecuted'>            x &gt;&gt;= 8;</span>
 34 |     | <span class='unexecuted'>            r += 8;</span>
 35 |     | <span class='neutral'>        }</span>
 36 |     | <span class='unexecuted'>        if (x &gt;= 0x10) {</span>
 37 |     | <span class='unexecuted'>            x &gt;&gt;= 4;</span>
 38 |     | <span class='unexecuted'>            r += 4;</span>
 39 |     | <span class='neutral'>        }</span>
 40 |     | <span class='unexecuted'>        if (x &gt;= 0x4) {</span>
 41 |     | <span class='unexecuted'>            x &gt;&gt;= 2;</span>
 42 |     | <span class='unexecuted'>            r += 2;</span>
 43 |     | <span class='neutral'>        }</span>
 44 |     | <span class='unexecuted'>        if (x &gt;= 0x2) r += 1;</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'></span>
 47 |     | <span class='neutral'>    /// @notice Returns the index of the least significant bit of the number,</span>
 48 |     | <span class='neutral'>    ///     where the least significant bit is at index 0 and the most significant bit is at index 255</span>
 49 |     | <span class='neutral'>    /// @dev The function satisfies the property:</span>
 50 |     | <span class='neutral'>    ///     (x &amp; 2**leastSignificantBit(x)) != 0 and (x &amp; (2**(leastSignificantBit(x)) - 1)) == 0)</span>
 51 |     | <span class='neutral'>    /// @param x the value for which to compute the least significant bit, must be greater than 0</span>
 52 |     | <span class='neutral'>    /// @return r the index of the least significant bit</span>
 53 |     | <span class='unexecuted'>    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {</span>
 54 |     | <span class='unexecuted'>        require(x &gt; 0);</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='unexecuted'>        r = 255;</span>
 57 |     | <span class='unexecuted'>        if (x &amp; type(uint128).max &gt; 0) {</span>
 58 |     | <span class='unexecuted'>            r -= 128;</span>
 59 |     | <span class='neutral'>        } else {</span>
 60 |     | <span class='unexecuted'>            x &gt;&gt;= 128;</span>
 61 |     | <span class='neutral'>        }</span>
 62 |     | <span class='unexecuted'>        if (x &amp; type(uint64).max &gt; 0) {</span>
 63 |     | <span class='unexecuted'>            r -= 64;</span>
 64 |     | <span class='neutral'>        } else {</span>
 65 |     | <span class='unexecuted'>            x &gt;&gt;= 64;</span>
 66 |     | <span class='neutral'>        }</span>
 67 |     | <span class='unexecuted'>        if (x &amp; type(uint32).max &gt; 0) {</span>
 68 |     | <span class='unexecuted'>            r -= 32;</span>
 69 |     | <span class='neutral'>        } else {</span>
 70 |     | <span class='unexecuted'>            x &gt;&gt;= 32;</span>
 71 |     | <span class='neutral'>        }</span>
 72 |     | <span class='unexecuted'>        if (x &amp; type(uint16).max &gt; 0) {</span>
 73 |     | <span class='unexecuted'>            r -= 16;</span>
 74 |     | <span class='neutral'>        } else {</span>
 75 |     | <span class='unexecuted'>            x &gt;&gt;= 16;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='unexecuted'>        if (x &amp; type(uint8).max &gt; 0) {</span>
 78 |     | <span class='unexecuted'>            r -= 8;</span>
 79 |     | <span class='neutral'>        } else {</span>
 80 |     | <span class='unexecuted'>            x &gt;&gt;= 8;</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='unexecuted'>        if (x &amp; 0xf &gt; 0) {</span>
 83 |     | <span class='unexecuted'>            r -= 4;</span>
 84 |     | <span class='neutral'>        } else {</span>
 85 |     | <span class='unexecuted'>            x &gt;&gt;= 4;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='unexecuted'>        if (x &amp; 0x3 &gt; 0) {</span>
 88 |     | <span class='unexecuted'>            r -= 2;</span>
 89 |     | <span class='neutral'>        } else {</span>
 90 |     | <span class='unexecuted'>            x &gt;&gt;= 2;</span>
 91 |     | <span class='neutral'>        }</span>
 92 |     | <span class='unexecuted'>        if (x &amp; 0x1 &gt; 0) r -= 1;</span>
 93 |     | <span class='neutral'>    }</span>
 94 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FixedPoint128.sol</b>
<code>
 1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
 2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
 3 |     | <span class='neutral'></span>
 4 |     | <span class='neutral'>/// @title FixedPoint128</span>
 5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
 6 |     | <span class='unexecuted'>library FixedPoint128 {</span>
 7 |     | <span class='neutral'>    uint256 internal constant Q128 = 0x100000000000000000000000000000000;</span>
 8 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FixedPoint96.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title FixedPoint96</span>
  5 |     | <span class='neutral'>/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)</span>
  6 |     | <span class='neutral'>/// @dev Used in SqrtPriceMath.sol</span>
  7 |     | <span class='unexecuted'>library FixedPoint96 {</span>
  8 |     | <span class='unexecuted'>    uint8 internal constant RESOLUTION = 96;</span>
  9 |     | <span class='neutral'>    uint256 internal constant Q96 = 0x1000000000000000000000000;</span>
 10 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/FullMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: MIT</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Contains 512-bit math functions</span>
   5 |     | <span class='neutral'>/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision</span>
   6 |     | <span class='neutral'>/// @dev Handles &quot;phantom overflow&quot; i.e., allows multiplication and division where an intermediate value overflows 256 bits</span>
   7 |     | <span class='unexecuted'>library FullMath {</span>
   8 |     | <span class='neutral'>    /// @notice Calculates floor(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
   9 |     | <span class='neutral'>    /// @param a The multiplicand</span>
  10 |     | <span class='neutral'>    /// @param b The multiplier</span>
  11 |     | <span class='neutral'>    /// @param denominator The divisor</span>
  12 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
  13 |     | <span class='neutral'>    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv</span>
  14 |     | <span class='unexecuted'>    function mulDiv(</span>
  15 |     | <span class='neutral'>        uint256 a,</span>
  16 |     | <span class='neutral'>        uint256 b,</span>
  17 |     | <span class='neutral'>        uint256 denominator</span>
  18 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
  19 |     | <span class='neutral'>        unchecked{</span>
  20 |     | <span class='neutral'>        // 512-bit multiply [prod1 prod0] = a * b</span>
  21 |     | <span class='neutral'>        // Compute the product mod 2**256 and mod 2**256 - 1</span>
  22 |     | <span class='neutral'>        // then use the Chinese Remainder Theorem to reconstruct</span>
  23 |     | <span class='neutral'>        // the 512 bit result. The result is stored in two 256</span>
  24 |     | <span class='neutral'>        // variables such that product = prod1 * 2**256 + prod0</span>
  25 |     | <span class='neutral'>        uint256 prod0; // Least significant 256 bits of the product</span>
  26 |     | <span class='neutral'>        uint256 prod1; // Most significant 256 bits of the product</span>
  27 |     | <span class='neutral'>        assembly {</span>
  28 |     | <span class='unexecuted'>            let mm := mulmod(a, b, not(0))</span>
  29 |     | <span class='unexecuted'>            prod0 := mul(a, b)</span>
  30 |     | <span class='unexecuted'>            prod1 := sub(sub(mm, prod0), lt(mm, prod0))</span>
  31 |     | <span class='neutral'>        }</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>        // Handle non-overflow cases, 256 by 256 division</span>
  34 |     | <span class='unexecuted'>        if (prod1 == 0) {</span>
  35 |     | <span class='unexecuted'>            require(denominator &gt; 0);</span>
  36 |     | <span class='neutral'>            assembly {</span>
  37 |     | <span class='unexecuted'>                result := div(prod0, denominator)</span>
  38 |     | <span class='neutral'>            }</span>
  39 |     | <span class='unexecuted'>            return result;</span>
  40 |     | <span class='neutral'>        }</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>        // Make sure the result is less than 2**256.</span>
  43 |     | <span class='neutral'>        // Also prevents denominator == 0</span>
  44 |     | <span class='unexecuted'>        require(denominator &gt; prod1);</span>
  45 |     | <span class='neutral'></span>
  46 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  47 |     | <span class='neutral'>        // 512 by 256 division.</span>
  48 |     | <span class='neutral'>        ///////////////////////////////////////////////</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // Make division exact by subtracting the remainder from [prod1 prod0]</span>
  51 |     | <span class='neutral'>        // Compute remainder using mulmod</span>
  52 |     | <span class='unexecuted'>        uint256 remainder;</span>
  53 |     | <span class='neutral'>        assembly {</span>
  54 |     | <span class='unexecuted'>            remainder := mulmod(a, b, denominator)</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>        // Subtract 256 bit number from 512 bit number</span>
  57 |     | <span class='neutral'>        assembly {</span>
  58 |     | <span class='unexecuted'>            prod1 := sub(prod1, gt(remainder, prod0))</span>
  59 |     | <span class='unexecuted'>            prod0 := sub(prod0, remainder)</span>
  60 |     | <span class='neutral'>        }</span>
  61 |     | <span class='neutral'></span>
  62 |     | <span class='neutral'>        // Factor powers of two out of denominator</span>
  63 |     | <span class='neutral'>        // Compute largest power of two divisor of denominator.</span>
  64 |     | <span class='neutral'>        // Always &gt;= 1.</span>
  65 |     | <span class='unexecuted'>        uint256 twos = uint256(-int256(denominator) &amp; int256(denominator));</span>
  66 |     | <span class='neutral'>        // Divide denominator by power of two</span>
  67 |     | <span class='neutral'>        assembly {</span>
  68 |     | <span class='unexecuted'>            denominator := div(denominator, twos)</span>
  69 |     | <span class='neutral'>        }</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // Divide [prod1 prod0] by the factors of two</span>
  72 |     | <span class='neutral'>        assembly {</span>
  73 |     | <span class='unexecuted'>            prod0 := div(prod0, twos)</span>
  74 |     | <span class='neutral'>        }</span>
  75 |     | <span class='neutral'>        // Shift in bits from prod1 into prod0. For this we need</span>
  76 |     | <span class='neutral'>        // to flip `twos` such that it is 2**256 / twos.</span>
  77 |     | <span class='neutral'>        // If twos is zero, then it becomes one</span>
  78 |     | <span class='neutral'>        assembly {</span>
  79 |     | <span class='unexecuted'>            twos := add(div(sub(0, twos), twos), 1)</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='unexecuted'>        prod0 |= prod1 * twos;</span>
  82 |     | <span class='neutral'></span>
  83 |     | <span class='neutral'>        // Invert denominator mod 2**256</span>
  84 |     | <span class='neutral'>        // Now that denominator is an odd number, it has an inverse</span>
  85 |     | <span class='neutral'>        // modulo 2**256 such that denominator * inv = 1 mod 2**256.</span>
  86 |     | <span class='neutral'>        // Compute the inverse by starting with a seed that is correct</span>
  87 |     | <span class='neutral'>        // correct for four bits. That is, denominator * inv = 1 mod 2**4</span>
  88 |     | <span class='unexecuted'>        uint256 inv = (3 * denominator) ^ 2;</span>
  89 |     | <span class='neutral'>        // Now use Newton-Raphson iteration to improve the precision.</span>
  90 |     | <span class='neutral'>        // Thanks to Hensel&#39;s lifting lemma, this also works in modular</span>
  91 |     | <span class='neutral'>        // arithmetic, doubling the correct bits in each step.</span>
  92 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**8</span>
  93 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**16</span>
  94 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**32</span>
  95 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**64</span>
  96 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**128</span>
  97 |     | <span class='unexecuted'>        inv *= 2 - denominator * inv; // inverse mod 2**256</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>        // Because the division is now exact we can divide by multiplying</span>
 100 |     | <span class='neutral'>        // with the modular inverse of denominator. This will give us the</span>
 101 |     | <span class='neutral'>        // correct result modulo 2**256. Since the precoditions guarantee</span>
 102 |     | <span class='neutral'>        // that the outcome is less than 2**256, this is the final result.</span>
 103 |     | <span class='neutral'>        // We don&#39;t need to compute the high bits of the result and prod1</span>
 104 |     | <span class='neutral'>        // is no longer required.</span>
 105 |     | <span class='unexecuted'>        result = prod0 * inv;</span>
 106 |     | <span class='neutral'>        }</span>
 107 |     | <span class='neutral'>        return result;</span>
 108 |     | <span class='neutral'>    }</span>
 109 |     | <span class='neutral'></span>
 110 |     | <span class='neutral'>    /// @notice Calculates ceil(abdenominator) with full precision. Throws if result overflows a uint256 or denominator == 0</span>
 111 |     | <span class='neutral'>    /// @param a The multiplicand</span>
 112 |     | <span class='neutral'>    /// @param b The multiplier</span>
 113 |     | <span class='neutral'>    /// @param denominator The divisor</span>
 114 |     | <span class='neutral'>    /// @return result The 256-bit result</span>
 115 |     | <span class='unexecuted'>    function mulDivRoundingUp(</span>
 116 |     | <span class='neutral'>        uint256 a,</span>
 117 |     | <span class='neutral'>        uint256 b,</span>
 118 |     | <span class='neutral'>        uint256 denominator</span>
 119 |     | <span class='unexecuted'>    ) internal pure returns (uint256 result) {</span>
 120 |     | <span class='unexecuted'>        result = mulDiv(a, b, denominator);</span>
 121 |     | <span class='unexecuted'>        if (mulmod(a, b, denominator) &gt; 0) {</span>
 122 |     | <span class='unexecuted'>            require(result &lt; type(uint256).max);</span>
 123 |     | <span class='unexecuted'>            result++;</span>
 124 |     | <span class='neutral'>        }</span>
 125 |     | <span class='neutral'>    }</span>
 126 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/LiquidityMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Math library for liquidity</span>
  5 |     | <span class='unexecuted'>library LiquidityMath {</span>
  6 |     | <span class='neutral'>    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows</span>
  7 |     | <span class='neutral'>    /// @param x The liquidity before change</span>
  8 |     | <span class='neutral'>    /// @param y The delta by which liquidity should be changed</span>
  9 |     | <span class='neutral'>    /// @return z The liquidity delta</span>
 10 |     | <span class='unexecuted'>    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {</span>
 11 |     | <span class='unexecuted'>        if (y &lt; 0) {</span>
 12 |     | <span class='unexecuted'>            require((z = x - uint128(-y)) &lt; x, &#39;LS&#39;);</span>
 13 |     | <span class='neutral'>        } else {</span>
 14 |     | <span class='unexecuted'>            require((z = x + uint128(y)) &gt;= x, &#39;LA&#39;);</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/LowGasSafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Optimized overflow and underflow safe math operations</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost</span>
  6 |     | <span class='unexecuted'>library LowGasSafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if sum overflows uint256</span>
  8 |     | <span class='neutral'>    /// @param x The augend</span>
  9 |     | <span class='neutral'>    /// @param y The addend</span>
 10 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 11 |     | <span class='unexecuted'>    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 12 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if underflows</span>
 16 |     | <span class='neutral'>    /// @param x The minuend</span>
 17 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 18 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 19 |     | <span class='neutral'>    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 20 |     | <span class='neutral'>        require((z = x - y) &lt;= x);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns x * y, reverts if overflows</span>
 24 |     | <span class='neutral'>    /// @param x The multiplicand</span>
 25 |     | <span class='neutral'>    /// @param y The multiplier</span>
 26 |     | <span class='neutral'>    /// @return z The product of x and y</span>
 27 |     | <span class='neutral'>    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 28 |     | <span class='neutral'>        require(x == 0 || (z = x * y) / x == y);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if overflows or underflows</span>
 32 |     | <span class='neutral'>    /// @param x The augend</span>
 33 |     | <span class='neutral'>    /// @param y The addend</span>
 34 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 35 |     | <span class='unexecuted'>    function add(int256 x, int256 y) internal pure returns (int256 z) {</span>
 36 |     | <span class='unexecuted'>        require((z = x + y) &gt;= x == (y &gt;= 0));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if overflows or underflows</span>
 40 |     | <span class='neutral'>    /// @param x The minuend</span>
 41 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 42 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 43 |     | <span class='unexecuted'>    function sub(int256 x, int256 y) internal pure returns (int256 z) {</span>
 44 |     | <span class='unexecuted'>        require((z = x - y) &lt;= x == (y &gt;= 0));</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Oracle.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Oracle</span>
   5 |     | <span class='neutral'>/// @notice Provides price and liquidity data useful for a wide variety of system designs</span>
   6 |     | <span class='neutral'>/// @dev Instances of stored oracle data, &quot;observations&quot;, are collected in the oracle array</span>
   7 |     | <span class='neutral'>/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the</span>
   8 |     | <span class='neutral'>/// maximum length of the oracle array. New slots will be added when the array is fully populated.</span>
   9 |     | <span class='neutral'>/// Observations are overwritten when the full length of the oracle array is populated.</span>
  10 |     | <span class='neutral'>/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()</span>
  11 |     | <span class='unexecuted'>library Oracle {</span>
  12 |     | <span class='neutral'>    struct Observation {</span>
  13 |     | <span class='neutral'>        // the block timestamp of the observation</span>
  14 |     | <span class='neutral'>        uint32 blockTimestamp;</span>
  15 |     | <span class='neutral'>        // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized</span>
  16 |     | <span class='neutral'>        int56 tickCumulative;</span>
  17 |     | <span class='neutral'>        // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized</span>
  18 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128;</span>
  19 |     | <span class='neutral'>        // whether or not the observation is initialized</span>
  20 |     | <span class='neutral'>        bool initialized;</span>
  21 |     | <span class='neutral'>    }</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>    /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values</span>
  24 |     | <span class='neutral'>    /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows</span>
  25 |     | <span class='neutral'>    /// @param last The specified observation to be transformed</span>
  26 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  27 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  28 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  29 |     | <span class='neutral'>    /// @return Observation The newly populated observation</span>
  30 |     | <span class='unexecuted'>    function transform(</span>
  31 |     | <span class='neutral'>        Observation memory last,</span>
  32 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  33 |     | <span class='neutral'>        int24 tick,</span>
  34 |     | <span class='neutral'>        uint128 liquidity</span>
  35 |     | <span class='neutral'>    ) private pure returns (Observation memory) {</span>
  36 |     | <span class='unexecuted'>        uint32 delta = blockTimestamp - last.blockTimestamp;</span>
  37 |     | <span class='unexecuted'>        return</span>
  38 |     | <span class='unexecuted'>            Observation({</span>
  39 |     | <span class='unexecuted'>                blockTimestamp: blockTimestamp,</span>
  40 |     | <span class='unexecuted'>                tickCumulative: last.tickCumulative + int56(tick) * int56(int32(delta)),</span>
  41 |     | <span class='unexecuted'>                secondsPerLiquidityCumulativeX128: last.secondsPerLiquidityCumulativeX128 +</span>
  42 |     | <span class='unexecuted'>                    ((uint160(delta) &lt;&lt; 128) / (liquidity &gt; 0 ? liquidity : 1)),</span>
  43 |     | <span class='unexecuted'>                initialized: true</span>
  44 |     | <span class='neutral'>            });</span>
  45 |     | <span class='neutral'>    }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='neutral'>    /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array</span>
  48 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  49 |     | <span class='neutral'>    /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32</span>
  50 |     | <span class='neutral'>    /// @return cardinality The number of populated elements in the oracle array</span>
  51 |     | <span class='neutral'>    /// @return cardinalityNext The new length of the oracle array, independent of population</span>
  52 |     | <span class='neutral'>    function initialize(Observation[65535] storage self, uint32 time)</span>
  53 |     | <span class='neutral'>        internal</span>
  54 |     | <span class='neutral'>        returns (uint16 cardinality, uint16 cardinalityNext)</span>
  55 |     | <span class='neutral'>    {</span>
  56 |     | <span class='unexecuted'>        self[0] = Observation({</span>
  57 |     | <span class='neutral'>            blockTimestamp: time,</span>
  58 |     | <span class='neutral'>            tickCumulative: 0,</span>
  59 |     | <span class='neutral'>            secondsPerLiquidityCumulativeX128: 0,</span>
  60 |     | <span class='unexecuted'>            initialized: true</span>
  61 |     | <span class='neutral'>        });</span>
  62 |     | <span class='neutral'>        return (1, 1);</span>
  63 |     | <span class='neutral'>    }</span>
  64 |     | <span class='neutral'></span>
  65 |     | <span class='neutral'>    /// @notice Writes an oracle observation to the array</span>
  66 |     | <span class='neutral'>    /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.</span>
  67 |     | <span class='neutral'>    /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality</span>
  68 |     | <span class='neutral'>    /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.</span>
  69 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
  70 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
  71 |     | <span class='neutral'>    /// @param blockTimestamp The timestamp of the new observation</span>
  72 |     | <span class='neutral'>    /// @param tick The active tick at the time of the new observation</span>
  73 |     | <span class='neutral'>    /// @param liquidity The total in-range liquidity at the time of the new observation</span>
  74 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
  75 |     | <span class='neutral'>    /// @param cardinalityNext The new length of the oracle array, independent of population</span>
  76 |     | <span class='neutral'>    /// @return indexUpdated The new index of the most recently written element in the oracle array</span>
  77 |     | <span class='neutral'>    /// @return cardinalityUpdated The new cardinality of the oracle array</span>
  78 |     | <span class='unexecuted'>    function write(</span>
  79 |     | <span class='neutral'>        Observation[65535] storage self,</span>
  80 |     | <span class='neutral'>        uint16 index,</span>
  81 |     | <span class='neutral'>        uint32 blockTimestamp,</span>
  82 |     | <span class='neutral'>        int24 tick,</span>
  83 |     | <span class='neutral'>        uint128 liquidity,</span>
  84 |     | <span class='neutral'>        uint16 cardinality,</span>
  85 |     | <span class='neutral'>        uint16 cardinalityNext</span>
  86 |     | <span class='unexecuted'>    ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {</span>
  87 |     | <span class='unexecuted'>        Observation memory last = self[index];</span>
  88 |     | <span class='neutral'></span>
  89 |     | <span class='neutral'>        // early return if we&#39;ve already written an observation this block</span>
  90 |     | <span class='unexecuted'>        if (last.blockTimestamp == blockTimestamp) return (index, cardinality);</span>
  91 |     | <span class='neutral'></span>
  92 |     | <span class='neutral'>        // if the conditions are right, we can bump the cardinality</span>
  93 |     | <span class='unexecuted'>        if (cardinalityNext &gt; cardinality &amp;&amp; index == (cardinality - 1)) {</span>
  94 |     | <span class='unexecuted'>            cardinalityUpdated = cardinalityNext;</span>
  95 |     | <span class='neutral'>        } else {</span>
  96 |     | <span class='unexecuted'>            cardinalityUpdated = cardinality;</span>
  97 |     | <span class='neutral'>        }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        indexUpdated = (index + 1) % cardinalityUpdated;</span>
 100 |     | <span class='unexecuted'>        self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Prepares the oracle array to store up to `next` observations</span>
 104 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 105 |     | <span class='neutral'>    /// @param current The current next cardinality of the oracle array</span>
 106 |     | <span class='neutral'>    /// @param next The proposed next cardinality which will be populated in the oracle array</span>
 107 |     | <span class='neutral'>    /// @return next The next cardinality which will be populated in the oracle array</span>
 108 |     | <span class='unexecuted'>    function grow(</span>
 109 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 110 |     | <span class='neutral'>        uint16 current,</span>
 111 |     | <span class='neutral'>        uint16 next</span>
 112 |     | <span class='unexecuted'>    ) internal returns (uint16) {</span>
 113 |     | <span class='unexecuted'>        require(current &gt; 0, &#39;I&#39;);</span>
 114 |     | <span class='neutral'>        // no-op if the passed next value isn&#39;t greater than the current next value</span>
 115 |     | <span class='unexecuted'>        if (next &lt;= current) return current;</span>
 116 |     | <span class='neutral'>        // store in each slot to prevent fresh SSTOREs in swaps</span>
 117 |     | <span class='neutral'>        // this data will not be used because the initialized boolean is still false</span>
 118 |     | <span class='unexecuted'>        for (uint16 i = current; i &lt; next; i++) self[i].blockTimestamp = 1;</span>
 119 |     | <span class='unexecuted'>        return next;</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice comparator for 32-bit timestamps</span>
 123 |     | <span class='neutral'>    /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time</span>
 124 |     | <span class='neutral'>    /// @param time A timestamp truncated to 32 bits</span>
 125 |     | <span class='neutral'>    /// @param a A comparison timestamp from which to determine the relative position of `time`</span>
 126 |     | <span class='neutral'>    /// @param b From which to determine the relative position of `time`</span>
 127 |     | <span class='neutral'>    /// @return bool Whether `a` is chronologically &lt;= `b`</span>
 128 |     | <span class='unexecuted'>    function lte(</span>
 129 |     | <span class='neutral'>        uint32 time,</span>
 130 |     | <span class='neutral'>        uint32 a,</span>
 131 |     | <span class='neutral'>        uint32 b</span>
 132 |     | <span class='unexecuted'>    ) private pure returns (bool) {</span>
 133 |     | <span class='neutral'>        // if there hasn&#39;t been overflow, no need to adjust</span>
 134 |     | <span class='unexecuted'>        if (a &lt;= time &amp;&amp; b &lt;= time) return a &lt;= b;</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='unexecuted'>        uint256 aAdjusted = a &gt; time ? a : a + 2**32;</span>
 137 |     | <span class='unexecuted'>        uint256 bAdjusted = b &gt; time ? b : b + 2**32;</span>
 138 |     | <span class='neutral'></span>
 139 |     | <span class='unexecuted'>        return aAdjusted &lt;= bAdjusted;</span>
 140 |     | <span class='neutral'>    }</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.</span>
 143 |     | <span class='neutral'>    /// The result may be the same observation, or adjacent observations.</span>
 144 |     | <span class='neutral'>    /// @dev The answer must be contained in the array, used when the target is located within the stored observation</span>
 145 |     | <span class='neutral'>    /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation</span>
 146 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 147 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 148 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 149 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 150 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 151 |     | <span class='neutral'>    /// @return beforeOrAt The observation recorded before, or at, the target</span>
 152 |     | <span class='neutral'>    /// @return atOrAfter The observation recorded at, or after, the target</span>
 153 |     | <span class='unexecuted'>    function binarySearch(</span>
 154 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 155 |     | <span class='neutral'>        uint32 time,</span>
 156 |     | <span class='neutral'>        uint32 target,</span>
 157 |     | <span class='neutral'>        uint16 index,</span>
 158 |     | <span class='neutral'>        uint16 cardinality</span>
 159 |     | <span class='unexecuted'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 160 |     | <span class='unexecuted'>        uint256 l = (index + 1) % cardinality; // oldest observation</span>
 161 |     | <span class='unexecuted'>        uint256 r = l + cardinality - 1; // newest observation</span>
 162 |     | <span class='unexecuted'>        uint256 i;</span>
 163 |     | <span class='unexecuted'>        while (true) {</span>
 164 |     | <span class='unexecuted'>            i = (l + r) / 2;</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>            beforeOrAt = self[i % cardinality];</span>
 167 |     | <span class='neutral'></span>
 168 |     | <span class='neutral'>            // we&#39;ve landed on an uninitialized tick, keep searching higher (more recently)</span>
 169 |     | <span class='unexecuted'>            if (!beforeOrAt.initialized) {</span>
 170 |     | <span class='unexecuted'>                l = i + 1;</span>
 171 |     | <span class='unexecuted'>                continue;</span>
 172 |     | <span class='neutral'>            }</span>
 173 |     | <span class='neutral'></span>
 174 |     | <span class='unexecuted'>            atOrAfter = self[(i + 1) % cardinality];</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>            bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);</span>
 177 |     | <span class='neutral'></span>
 178 |     | <span class='neutral'>            // check if we&#39;ve found the answer!</span>
 179 |     | <span class='unexecuted'>            if (targetAtOrAfter &amp;&amp; lte(time, target, atOrAfter.blockTimestamp)) break;</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>            if (!targetAtOrAfter) r = i - 1;</span>
 182 |     | <span class='unexecuted'>            else l = i + 1;</span>
 183 |     | <span class='neutral'>        }</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'></span>
 186 |     | <span class='neutral'>    /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied</span>
 187 |     | <span class='neutral'>    /// @dev Assumes there is at least 1 initialized observation.</span>
 188 |     | <span class='neutral'>    /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.</span>
 189 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 190 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 191 |     | <span class='neutral'>    /// @param target The timestamp at which the reserved observation should be for</span>
 192 |     | <span class='neutral'>    /// @param tick The active tick at the time of the returned or simulated observation</span>
 193 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 194 |     | <span class='neutral'>    /// @param liquidity The total pool liquidity at the time of the call</span>
 195 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 196 |     | <span class='neutral'>    /// @return beforeOrAt The observation which occurred at, or before, the given timestamp</span>
 197 |     | <span class='neutral'>    /// @return atOrAfter The observation which occurred at, or after, the given timestamp</span>
 198 |     | <span class='unexecuted'>    function getSurroundingObservations(</span>
 199 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 200 |     | <span class='neutral'>        uint32 time,</span>
 201 |     | <span class='neutral'>        uint32 target,</span>
 202 |     | <span class='neutral'>        int24 tick,</span>
 203 |     | <span class='neutral'>        uint16 index,</span>
 204 |     | <span class='neutral'>        uint128 liquidity,</span>
 205 |     | <span class='neutral'>        uint16 cardinality</span>
 206 |     | <span class='neutral'>    ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {</span>
 207 |     | <span class='neutral'>        // optimistically set before to the newest observation</span>
 208 |     | <span class='unexecuted'>        beforeOrAt = self[index];</span>
 209 |     | <span class='neutral'></span>
 210 |     | <span class='neutral'>        // if the target is chronologically at or after the newest observation, we can early return</span>
 211 |     | <span class='unexecuted'>        if (lte(time, beforeOrAt.blockTimestamp, target)) {</span>
 212 |     | <span class='unexecuted'>            if (beforeOrAt.blockTimestamp == target) {</span>
 213 |     | <span class='neutral'>                // if newest observation equals target, we&#39;re in the same block, so we can ignore atOrAfter</span>
 214 |     | <span class='unexecuted'>                return (beforeOrAt, atOrAfter);</span>
 215 |     | <span class='neutral'>            } else {</span>
 216 |     | <span class='neutral'>                // otherwise, we need to transform</span>
 217 |     | <span class='unexecuted'>                return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));</span>
 218 |     | <span class='neutral'>            }</span>
 219 |     | <span class='neutral'>        }</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='neutral'>        // now, set before to the oldest observation</span>
 222 |     | <span class='unexecuted'>        beforeOrAt = self[(index + 1) % cardinality];</span>
 223 |     | <span class='unexecuted'>        if (!beforeOrAt.initialized) beforeOrAt = self[0];</span>
 224 |     | <span class='neutral'></span>
 225 |     | <span class='neutral'>        // ensure that the target is chronologically at or after the oldest observation</span>
 226 |     | <span class='unexecuted'>        require(lte(time, beforeOrAt.blockTimestamp, target), &#39;OLD&#39;);</span>
 227 |     | <span class='neutral'></span>
 228 |     | <span class='neutral'>        // if we&#39;ve reached this point, we have to binary search</span>
 229 |     | <span class='unexecuted'>        return binarySearch(self, time, target, index, cardinality);</span>
 230 |     | <span class='neutral'>    }</span>
 231 |     | <span class='neutral'></span>
 232 |     | <span class='neutral'>    /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.</span>
 233 |     | <span class='neutral'>    /// 0 may be passed as `secondsAgo&#39; to return the current cumulative values.</span>
 234 |     | <span class='neutral'>    /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values</span>
 235 |     | <span class='neutral'>    /// at exactly the timestamp between the two observations.</span>
 236 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 237 |     | <span class='neutral'>    /// @param time The current block timestamp</span>
 238 |     | <span class='neutral'>    /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation</span>
 239 |     | <span class='neutral'>    /// @param tick The current tick</span>
 240 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 241 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 242 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 243 |     | <span class='neutral'>    /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`</span>
 244 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`</span>
 245 |     | <span class='unexecuted'>    function observeSingle(</span>
 246 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 247 |     | <span class='neutral'>        uint32 time,</span>
 248 |     | <span class='neutral'>        uint32 secondsAgo,</span>
 249 |     | <span class='neutral'>        int24 tick,</span>
 250 |     | <span class='neutral'>        uint16 index,</span>
 251 |     | <span class='neutral'>        uint128 liquidity,</span>
 252 |     | <span class='neutral'>        uint16 cardinality</span>
 253 |     | <span class='unexecuted'>    ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {</span>
 254 |     | <span class='unexecuted'>        if (secondsAgo == 0) {</span>
 255 |     | <span class='unexecuted'>            Observation memory last = self[index];</span>
 256 |     | <span class='unexecuted'>            if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);</span>
 257 |     | <span class='unexecuted'>            return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);</span>
 258 |     | <span class='neutral'>        }</span>
 259 |     | <span class='neutral'></span>
 260 |     | <span class='unexecuted'>        uint32 target = time - secondsAgo;</span>
 261 |     | <span class='neutral'></span>
 262 |     | <span class='unexecuted'>        (Observation memory beforeOrAt, Observation memory atOrAfter) =</span>
 263 |     | <span class='unexecuted'>            getSurroundingObservations(self, time, target, tick, index, liquidity, cardinality);</span>
 264 |     | <span class='neutral'></span>
 265 |     | <span class='unexecuted'>        if (target == beforeOrAt.blockTimestamp) {</span>
 266 |     | <span class='neutral'>            // we&#39;re at the left boundary</span>
 267 |     | <span class='unexecuted'>            return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);</span>
 268 |     | <span class='unexecuted'>        } else if (target == atOrAfter.blockTimestamp) {</span>
 269 |     | <span class='neutral'>            // we&#39;re at the right boundary</span>
 270 |     | <span class='unexecuted'>            return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);</span>
 271 |     | <span class='neutral'>        } else {</span>
 272 |     | <span class='neutral'>            // we&#39;re in the middle</span>
 273 |     | <span class='unexecuted'>            uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;</span>
 274 |     | <span class='unexecuted'>            uint32 targetDelta = target - beforeOrAt.blockTimestamp;</span>
 275 |     | <span class='unexecuted'>            return (</span>
 276 |     | <span class='unexecuted'>                beforeOrAt.tickCumulative +</span>
 277 |     | <span class='unexecuted'>                    ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(int32(observationTimeDelta))) *</span>
 278 |     | <span class='unexecuted'>                    int56(int32(targetDelta)),</span>
 279 |     | <span class='unexecuted'>                beforeOrAt.secondsPerLiquidityCumulativeX128 +</span>
 280 |     | <span class='neutral'>                    uint160(</span>
 281 |     | <span class='unexecuted'>                        (uint256(</span>
 282 |     | <span class='unexecuted'>                            atOrAfter.secondsPerLiquidityCumulativeX128 - beforeOrAt.secondsPerLiquidityCumulativeX128</span>
 283 |     | <span class='unexecuted'>                        ) * targetDelta) / observationTimeDelta</span>
 284 |     | <span class='neutral'>                    )</span>
 285 |     | <span class='neutral'>            );</span>
 286 |     | <span class='neutral'>        }</span>
 287 |     | <span class='neutral'>    }</span>
 288 |     | <span class='neutral'></span>
 289 |     | <span class='neutral'>    /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`</span>
 290 |     | <span class='neutral'>    /// @dev Reverts if `secondsAgos` &gt; oldest observation</span>
 291 |     | <span class='neutral'>    /// @param self The stored oracle array</span>
 292 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 293 |     | <span class='neutral'>    /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation</span>
 294 |     | <span class='neutral'>    /// @param tick The current tick</span>
 295 |     | <span class='neutral'>    /// @param index The index of the observation that was most recently written to the observations array</span>
 296 |     | <span class='neutral'>    /// @param liquidity The current in-range pool liquidity</span>
 297 |     | <span class='neutral'>    /// @param cardinality The number of populated elements in the oracle array</span>
 298 |     | <span class='neutral'>    /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`</span>
 299 |     | <span class='neutral'>    /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`</span>
 300 |     | <span class='unexecuted'>    function observe(</span>
 301 |     | <span class='neutral'>        Observation[65535] storage self,</span>
 302 |     | <span class='neutral'>        uint32 time,</span>
 303 |     | <span class='neutral'>        uint32[] memory secondsAgos,</span>
 304 |     | <span class='neutral'>        int24 tick,</span>
 305 |     | <span class='neutral'>        uint16 index,</span>
 306 |     | <span class='neutral'>        uint128 liquidity,</span>
 307 |     | <span class='neutral'>        uint16 cardinality</span>
 308 |     | <span class='unexecuted'>    ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {</span>
 309 |     | <span class='unexecuted'>        require(cardinality &gt; 0, &#39;I&#39;);</span>
 310 |     | <span class='neutral'></span>
 311 |     | <span class='unexecuted'>        tickCumulatives = new int56[](secondsAgos.length);</span>
 312 |     | <span class='unexecuted'>        secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);</span>
 313 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; secondsAgos.length; i++) {</span>
 314 |     | <span class='unexecuted'>            (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(</span>
 315 |     | <span class='unexecuted'>                self,</span>
 316 |     | <span class='unexecuted'>                time,</span>
 317 |     | <span class='unexecuted'>                secondsAgos[i],</span>
 318 |     | <span class='unexecuted'>                tick,</span>
 319 |     | <span class='unexecuted'>                index,</span>
 320 |     | <span class='unexecuted'>                liquidity,</span>
 321 |     | <span class='unexecuted'>                cardinality</span>
 322 |     | <span class='neutral'>            );</span>
 323 |     | <span class='neutral'>        }</span>
 324 |     | <span class='neutral'>    }</span>
 325 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Position.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./FixedPoint128.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @title Position</span>
  9 |     | <span class='neutral'>/// @notice Positions represent an owner address&#39; liquidity between a lower and upper tick boundary</span>
 10 |     | <span class='neutral'>/// @dev Positions store additional state for tracking fees owed to the position</span>
 11 |     | <span class='unexecuted'>library Position {</span>
 12 |     | <span class='neutral'>    // info stored for each user&#39;s position</span>
 13 |     | <span class='neutral'>    struct Info {</span>
 14 |     | <span class='neutral'>        // the amount of liquidity owned by this position</span>
 15 |     | <span class='neutral'>        uint128 liquidity;</span>
 16 |     | <span class='neutral'>        // fee growth per unit of liquidity as of the last update to liquidity or fees owed</span>
 17 |     | <span class='neutral'>        uint256 feeGrowthInside0LastX128;</span>
 18 |     | <span class='neutral'>        uint256 feeGrowthInside1LastX128;</span>
 19 |     | <span class='neutral'>        // the fees owed to the position owner in token0/token1</span>
 20 |     | <span class='neutral'>        uint128 tokensOwed0;</span>
 21 |     | <span class='neutral'>        uint128 tokensOwed1;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Returns the Info struct of a position, given an owner and position boundaries</span>
 25 |     | <span class='neutral'>    /// @param self The mapping containing all user positions</span>
 26 |     | <span class='neutral'>    /// @param owner The address of the position owner</span>
 27 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
 28 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
 29 |     | <span class='neutral'>    /// @return position The position info struct of the given owners&#39; position</span>
 30 |     | <span class='unexecuted'>    function get(</span>
 31 |     | <span class='neutral'>        mapping(bytes32 =&gt; Info) storage self,</span>
 32 |     | <span class='neutral'>        address owner,</span>
 33 |     | <span class='neutral'>        int24 tickLower,</span>
 34 |     | <span class='neutral'>        int24 tickUpper</span>
 35 |     | <span class='neutral'>    ) internal view returns (Position.Info storage position) {</span>
 36 |     | <span class='unexecuted'>        position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Credits accumulated fees to a user&#39;s position</span>
 40 |     | <span class='neutral'>    /// @param self The individual position to update</span>
 41 |     | <span class='neutral'>    /// @param liquidityDelta The change in pool liquidity as a result of the position update</span>
 42 |     | <span class='neutral'>    /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 43 |     | <span class='neutral'>    /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
 44 |     | <span class='unexecuted'>    function update(</span>
 45 |     | <span class='neutral'>        Info storage self,</span>
 46 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 47 |     | <span class='neutral'>        uint256 feeGrowthInside0X128,</span>
 48 |     | <span class='neutral'>        uint256 feeGrowthInside1X128</span>
 49 |     | <span class='unexecuted'>    ) internal {</span>
 50 |     | <span class='unexecuted'>        Info memory _self = self;</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>        uint128 liquidityNext;</span>
 53 |     | <span class='unexecuted'>        if (liquidityDelta == 0) {</span>
 54 |     | <span class='unexecuted'>            require(_self.liquidity &gt; 0, &#39;NP&#39;); // disallow pokes for 0 liquidity positions</span>
 55 |     | <span class='unexecuted'>            liquidityNext = _self.liquidity;</span>
 56 |     | <span class='neutral'>        } else {</span>
 57 |     | <span class='unexecuted'>            liquidityNext = LiquidityMath.addDelta(_self.liquidity, liquidityDelta);</span>
 58 |     | <span class='neutral'>        }</span>
 59 |     | <span class='neutral'></span>
 60 |     | <span class='neutral'>        // calculate accumulated fees</span>
 61 |     | <span class='unexecuted'>        uint128 tokensOwed0 =</span>
 62 |     | <span class='neutral'>            uint128(</span>
 63 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
 64 |     | <span class='unexecuted'>                    feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,</span>
 65 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 66 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 67 |     | <span class='neutral'>                )</span>
 68 |     | <span class='neutral'>            );</span>
 69 |     | <span class='unexecuted'>        uint128 tokensOwed1 =</span>
 70 |     | <span class='neutral'>            uint128(</span>
 71 |     | <span class='unexecuted'>                FullMath.mulDiv(</span>
 72 |     | <span class='unexecuted'>                    feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,</span>
 73 |     | <span class='unexecuted'>                    _self.liquidity,</span>
 74 |     | <span class='neutral'>                    FixedPoint128.Q128</span>
 75 |     | <span class='neutral'>                )</span>
 76 |     | <span class='neutral'>            );</span>
 77 |     | <span class='neutral'></span>
 78 |     | <span class='neutral'>        // update the position</span>
 79 |     | <span class='unexecuted'>        if (liquidityDelta != 0) self.liquidity = liquidityNext;</span>
 80 |     | <span class='unexecuted'>        self.feeGrowthInside0LastX128 = feeGrowthInside0X128;</span>
 81 |     | <span class='unexecuted'>        self.feeGrowthInside1LastX128 = feeGrowthInside1X128;</span>
 82 |     | <span class='unexecuted'>        if (tokensOwed0 &gt; 0 || tokensOwed1 &gt; 0) {</span>
 83 |     | <span class='neutral'>            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees</span>
 84 |     | <span class='unexecuted'>            self.tokensOwed0 += tokensOwed0;</span>
 85 |     | <span class='unexecuted'>            self.tokensOwed1 += tokensOwed1;</span>
 86 |     | <span class='neutral'>        }</span>
 87 |     | <span class='neutral'>    }</span>
 88 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SafeCast.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Safe casting methods</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for safely casting between types</span>
  6 |     | <span class='unexecuted'>library SafeCast {</span>
  7 |     | <span class='neutral'>    /// @notice Cast a uint256 to a uint160, revert on overflow</span>
  8 |     | <span class='neutral'>    /// @param y The uint256 to be downcasted</span>
  9 |     | <span class='neutral'>    /// @return z The downcasted integer, now type uint160</span>
 10 |     | <span class='unexecuted'>    function toUint160(uint256 y) internal pure returns (uint160 z) {</span>
 11 |     | <span class='unexecuted'>        require((z = uint160(y)) == y);</span>
 12 |     | <span class='neutral'>    }</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    /// @notice Cast a int256 to a int128, revert on overflow or underflow</span>
 15 |     | <span class='neutral'>    /// @param y The int256 to be downcasted</span>
 16 |     | <span class='neutral'>    /// @return z The downcasted integer, now type int128</span>
 17 |     | <span class='unexecuted'>    function toInt128(int256 y) internal pure returns (int128 z) {</span>
 18 |     | <span class='unexecuted'>        require((z = int128(y)) == y);</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Cast a uint256 to a int256, revert on overflow</span>
 22 |     | <span class='neutral'>    /// @param y The uint256 to be casted</span>
 23 |     | <span class='neutral'>    /// @return z The casted integer, now type int256</span>
 24 |     | <span class='unexecuted'>    function toInt256(uint256 y) internal pure returns (int256 z) {</span>
 25 |     | <span class='unexecuted'>        require(y &lt; 2**255);</span>
 26 |     | <span class='unexecuted'>        z = int256(y);</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SqrtPriceMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./UnsafeMath.sol&#39;;</span>
   9 |     | <span class='neutral'>import &#39;./FixedPoint96.sol&#39;;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='neutral'>/// @title Functions based on Q64.96 sqrt price and liquidity</span>
  12 |     | <span class='neutral'>/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas</span>
  13 |     | <span class='unexecuted'>library SqrtPriceMath {</span>
  14 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
  15 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token0</span>
  18 |     | <span class='neutral'>    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least</span>
  19 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the</span>
  20 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  21 |     | <span class='neutral'>    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),</span>
  22 |     | <span class='neutral'>    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).</span>
  23 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta</span>
  24 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  25 |     | <span class='neutral'>    /// @param amount How much of token0 to add or remove from virtual reserves</span>
  26 |     | <span class='neutral'>    /// @param add Whether to add or remove the amount of token0</span>
  27 |     | <span class='neutral'>    /// @return The price after adding or removing amount, depending on add</span>
  28 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount0RoundingUp(</span>
  29 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  30 |     | <span class='neutral'>        uint128 liquidity,</span>
  31 |     | <span class='neutral'>        uint256 amount,</span>
  32 |     | <span class='neutral'>        bool add</span>
  33 |     | <span class='unexecuted'>    ) internal pure returns (uint160) {</span>
  34 |     | <span class='neutral'>        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price</span>
  35 |     | <span class='unexecuted'>        if (amount == 0) return sqrtPX96;</span>
  36 |     | <span class='unexecuted'>        uint256 numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
  37 |     | <span class='neutral'></span>
  38 |     | <span class='unexecuted'>        if (add) {</span>
  39 |     | <span class='unexecuted'>            uint256 product;</span>
  40 |     | <span class='unexecuted'>            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {</span>
  41 |     | <span class='unexecuted'>                uint256 denominator = numerator1 + product;</span>
  42 |     | <span class='unexecuted'>                if (denominator &gt;= numerator1)</span>
  43 |     | <span class='neutral'>                    // always fits in 160 bits</span>
  44 |     | <span class='unexecuted'>                    return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));</span>
  45 |     | <span class='neutral'>            }</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>            return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96).add(amount)));</span>
  48 |     | <span class='neutral'>        } else {</span>
  49 |     | <span class='unexecuted'>            uint256 product;</span>
  50 |     | <span class='neutral'>            // if the product overflows, we know the denominator underflows</span>
  51 |     | <span class='neutral'>            // in addition, we must check that the denominator does not underflow</span>
  52 |     | <span class='unexecuted'>            require((product = amount * sqrtPX96) / amount == sqrtPX96 &amp;&amp; numerator1 &gt; product);</span>
  53 |     | <span class='unexecuted'>            uint256 denominator = numerator1 - product;</span>
  54 |     | <span class='unexecuted'>            return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();</span>
  55 |     | <span class='neutral'>        }</span>
  56 |     | <span class='neutral'>    }</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given a delta of token1</span>
  59 |     | <span class='neutral'>    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least</span>
  60 |     | <span class='neutral'>    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the</span>
  61 |     | <span class='neutral'>    /// price less in order to not send too much output.</span>
  62 |     | <span class='neutral'>    /// The formula we compute is within &lt;1 wei of the lossless version: sqrtPX96 +- amount / liquidity</span>
  63 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta</span>
  64 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
  65 |     | <span class='neutral'>    /// @param amount How much of token1 to add, or remove, from virtual reserves</span>
  66 |     | <span class='neutral'>    /// @param add Whether to add, or remove, the amount of token1</span>
  67 |     | <span class='neutral'>    /// @return The price after adding or removing `amount`</span>
  68 |     | <span class='unexecuted'>    function getNextSqrtPriceFromAmount1RoundingDown(</span>
  69 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
  70 |     | <span class='neutral'>        uint128 liquidity,</span>
  71 |     | <span class='neutral'>        uint256 amount,</span>
  72 |     | <span class='neutral'>        bool add</span>
  73 |     | <span class='unexecuted'>    ) internal pure returns (uint160) {</span>
  74 |     | <span class='neutral'>        // if we&#39;re adding (subtracting), rounding down requires rounding the quotient down (up)</span>
  75 |     | <span class='neutral'>        // in both cases, avoid a mulDiv for most inputs</span>
  76 |     | <span class='unexecuted'>        if (add) {</span>
  77 |     | <span class='unexecuted'>            uint256 quotient =</span>
  78 |     | <span class='neutral'>                (</span>
  79 |     | <span class='unexecuted'>                    amount &lt;= type(uint160).max</span>
  80 |     | <span class='unexecuted'>                        ? (amount &lt;&lt; FixedPoint96.RESOLUTION) / liquidity</span>
  81 |     | <span class='unexecuted'>                        : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)</span>
  82 |     | <span class='neutral'>                );</span>
  83 |     | <span class='neutral'></span>
  84 |     | <span class='unexecuted'>            return uint256(sqrtPX96).add(quotient).toUint160();</span>
  85 |     | <span class='neutral'>        } else {</span>
  86 |     | <span class='unexecuted'>            uint256 quotient =</span>
  87 |     | <span class='neutral'>                (</span>
  88 |     | <span class='unexecuted'>                    amount &lt;= type(uint160).max</span>
  89 |     | <span class='unexecuted'>                        ? UnsafeMath.divRoundingUp(amount &lt;&lt; FixedPoint96.RESOLUTION, liquidity)</span>
  90 |     | <span class='unexecuted'>                        : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)</span>
  91 |     | <span class='neutral'>                );</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>            require(sqrtPX96 &gt; quotient);</span>
  94 |     | <span class='neutral'>            // always fits 160 bits</span>
  95 |     | <span class='unexecuted'>            return uint160(sqrtPX96 - quotient);</span>
  96 |     | <span class='neutral'>        }</span>
  97 |     | <span class='neutral'>    }</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an input amount of token0 or token1</span>
 100 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds</span>
 101 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount</span>
 102 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 103 |     | <span class='neutral'>    /// @param amountIn How much of token0, or token1, is being swapped in</span>
 104 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount in is token0 or token1</span>
 105 |     | <span class='neutral'>    /// @return sqrtQX96 The price after adding the input amount to token0 or token1</span>
 106 |     | <span class='unexecuted'>    function getNextSqrtPriceFromInput(</span>
 107 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 108 |     | <span class='neutral'>        uint128 liquidity,</span>
 109 |     | <span class='neutral'>        uint256 amountIn,</span>
 110 |     | <span class='neutral'>        bool zeroForOne</span>
 111 |     | <span class='unexecuted'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 112 |     | <span class='unexecuted'>        require(sqrtPX96 &gt; 0);</span>
 113 |     | <span class='unexecuted'>        require(liquidity &gt; 0);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        // round to make sure that we don&#39;t pass the target price</span>
 116 |     | <span class='neutral'>        return</span>
 117 |     | <span class='unexecuted'>            zeroForOne</span>
 118 |     | <span class='unexecuted'>                ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)</span>
 119 |     | <span class='unexecuted'>                : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);</span>
 120 |     | <span class='neutral'>    }</span>
 121 |     | <span class='neutral'></span>
 122 |     | <span class='neutral'>    /// @notice Gets the next sqrt price given an output amount of token0 or token1</span>
 123 |     | <span class='neutral'>    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds</span>
 124 |     | <span class='neutral'>    /// @param sqrtPX96 The starting price before accounting for the output amount</span>
 125 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 126 |     | <span class='neutral'>    /// @param amountOut How much of token0, or token1, is being swapped out</span>
 127 |     | <span class='neutral'>    /// @param zeroForOne Whether the amount out is token0 or token1</span>
 128 |     | <span class='neutral'>    /// @return sqrtQX96 The price after removing the output amount of token0 or token1</span>
 129 |     | <span class='unexecuted'>    function getNextSqrtPriceFromOutput(</span>
 130 |     | <span class='neutral'>        uint160 sqrtPX96,</span>
 131 |     | <span class='neutral'>        uint128 liquidity,</span>
 132 |     | <span class='neutral'>        uint256 amountOut,</span>
 133 |     | <span class='neutral'>        bool zeroForOne</span>
 134 |     | <span class='unexecuted'>    ) internal pure returns (uint160 sqrtQX96) {</span>
 135 |     | <span class='unexecuted'>        require(sqrtPX96 &gt; 0);</span>
 136 |     | <span class='unexecuted'>        require(liquidity &gt; 0);</span>
 137 |     | <span class='neutral'></span>
 138 |     | <span class='neutral'>        // round to make sure that we pass the target price</span>
 139 |     | <span class='neutral'>        return</span>
 140 |     | <span class='unexecuted'>            zeroForOne</span>
 141 |     | <span class='unexecuted'>                ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)</span>
 142 |     | <span class='unexecuted'>                : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);</span>
 143 |     | <span class='neutral'>    }</span>
 144 |     | <span class='neutral'>    </span>
 145 |     | <span class='neutral'>    event Message(string a);</span>
 146 |     | <span class='neutral'>    event MessageUint160(string a, uint160 b);</span>
 147 |     | <span class='neutral'>    event MessageUint256(string a, uint256 b);</span>
 148 |     | <span class='neutral'></span>
 149 |     | <span class='neutral'></span>
 150 |     | <span class='neutral'>    /// @notice Gets the amount0 delta between two prices</span>
 151 |     | <span class='neutral'>    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),</span>
 152 |     | <span class='neutral'>    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))</span>
 153 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 154 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 155 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 156 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up or down</span>
 157 |     | <span class='neutral'>    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices</span>
 158 |     | <span class='unexecuted'>    function getAmount0Delta(</span>
 159 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 160 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 161 |     | <span class='neutral'>        uint128 liquidity,</span>
 162 |     | <span class='neutral'>        bool roundUp</span>
 163 |     | <span class='unexecuted'>    ) internal returns (uint256 amount0) {</span>
 164 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        emit Message(&quot;HERE9&quot;);</span>
 167 |     | <span class='neutral'>        uint256 numerator1;</span>
 168 |     | <span class='neutral'>        unchecked {</span>
 169 |     | <span class='unexecuted'>            numerator1 = uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION;</span>
 170 |     | <span class='neutral'>        }</span>
 171 |     | <span class='unexecuted'>        emit MessageUint256(&quot;numerator1&quot;, numerator1);</span>
 172 |     | <span class='unexecuted'>        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;</span>
 173 |     | <span class='unexecuted'>        emit MessageUint256(&quot;numerator2&quot;, numerator2);</span>
 174 |     | <span class='unexecuted'>        require(sqrtRatioAX96 &gt; 0);</span>
 175 |     | <span class='neutral'></span>
 176 |     | <span class='unexecuted'>        return</span>
 177 |     | <span class='unexecuted'>            roundUp</span>
 178 |     | <span class='unexecuted'>                ? UnsafeMath.divRoundingUp(</span>
 179 |     | <span class='unexecuted'>                    FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),</span>
 180 |     | <span class='unexecuted'>                    sqrtRatioAX96</span>
 181 |     | <span class='neutral'>                )</span>
 182 |     | <span class='unexecuted'>                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;</span>
 183 |     | <span class='neutral'>    }</span>
 184 |     | <span class='neutral'></span>
 185 |     | <span class='neutral'>    /// @notice Gets the amount1 delta between two prices</span>
 186 |     | <span class='neutral'>    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))</span>
 187 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 188 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 189 |     | <span class='neutral'>    /// @param liquidity The amount of usable liquidity</span>
 190 |     | <span class='neutral'>    /// @param roundUp Whether to round the amount up, or down</span>
 191 |     | <span class='neutral'>    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices</span>
 192 |     | <span class='unexecuted'>    function getAmount1Delta(</span>
 193 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 194 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 195 |     | <span class='neutral'>        uint128 liquidity,</span>
 196 |     | <span class='neutral'>        bool roundUp</span>
 197 |     | <span class='unexecuted'>    ) internal pure returns (uint256 amount1) {</span>
 198 |     | <span class='unexecuted'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='neutral'>        return</span>
 201 |     | <span class='unexecuted'>            roundUp</span>
 202 |     | <span class='unexecuted'>                ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)</span>
 203 |     | <span class='unexecuted'>                : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'></span>
 206 |     | <span class='neutral'>    /// @notice Helper that gets signed token0 delta</span>
 207 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 208 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 209 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount0 delta</span>
 210 |     | <span class='neutral'>    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices</span>
 211 |     | <span class='unexecuted'>    function getAmount0Delta(</span>
 212 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 213 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 214 |     | <span class='neutral'>        int128 liquidity</span>
 215 |     | <span class='unexecuted'>    ) internal  returns (int256 amount0) {</span>
 216 |     | <span class='neutral'>        return</span>
 217 |     | <span class='unexecuted'>            liquidity &lt; 0</span>
 218 |     | <span class='unexecuted'>                ? -getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 219 |     | <span class='unexecuted'>                : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 220 |     | <span class='neutral'>    }</span>
 221 |     | <span class='neutral'></span>
 222 |     | <span class='neutral'>    /// @notice Helper that gets signed token1 delta</span>
 223 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price</span>
 224 |     | <span class='neutral'>    /// @param sqrtRatioBX96 Another sqrt price</span>
 225 |     | <span class='neutral'>    /// @param liquidity The change in liquidity for which to compute the amount1 delta</span>
 226 |     | <span class='neutral'>    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices</span>
 227 |     | <span class='unexecuted'>    function getAmount1Delta(</span>
 228 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 229 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 230 |     | <span class='neutral'>        int128 liquidity</span>
 231 |     | <span class='unexecuted'>    ) internal pure returns (int256 amount1) {</span>
 232 |     | <span class='neutral'>        return</span>
 233 |     | <span class='unexecuted'>            liquidity &lt; 0</span>
 234 |     | <span class='unexecuted'>                ? -getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(-liquidity), false).toInt256()</span>
 235 |     | <span class='unexecuted'>                : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();</span>
 236 |     | <span class='neutral'>    }</span>
 237 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/SwapMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./FullMath.sol&#39;;</span>
  5 |     | <span class='neutral'>import &#39;./SqrtPriceMath.sol&#39;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Computes the result of a swap within ticks</span>
  8 |     | <span class='neutral'>/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.</span>
  9 |     | <span class='unexecuted'>library SwapMath {</span>
 10 |     | <span class='neutral'>    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap</span>
 11 |     | <span class='neutral'>    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap&#39;s `amountSpecified` is positive</span>
 12 |     | <span class='neutral'>    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool</span>
 13 |     | <span class='neutral'>    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred</span>
 14 |     | <span class='neutral'>    /// @param liquidity The usable liquidity</span>
 15 |     | <span class='neutral'>    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out</span>
 16 |     | <span class='neutral'>    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip</span>
 17 |     | <span class='neutral'>    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target</span>
 18 |     | <span class='neutral'>    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap</span>
 19 |     | <span class='neutral'>    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap</span>
 20 |     | <span class='neutral'>    /// @return feeAmount The amount of input that will be taken as a fee</span>
 21 |     | <span class='unexecuted'>    function computeSwapStep(</span>
 22 |     | <span class='neutral'>        uint160 sqrtRatioCurrentX96,</span>
 23 |     | <span class='neutral'>        uint160 sqrtRatioTargetX96,</span>
 24 |     | <span class='neutral'>        uint128 liquidity,</span>
 25 |     | <span class='neutral'>        int256 amountRemaining,</span>
 26 |     | <span class='neutral'>        uint24 feePips</span>
 27 |     | <span class='neutral'>    )</span>
 28 |     | <span class='neutral'>        internal</span>
 29 |     | <span class='neutral'>        returns (</span>
 30 |     | <span class='unexecuted'>            uint160 sqrtRatioNextX96,</span>
 31 |     | <span class='neutral'>            uint256 amountIn,</span>
 32 |     | <span class='neutral'>            uint256 amountOut,</span>
 33 |     | <span class='neutral'>            uint256 feeAmount</span>
 34 |     | <span class='neutral'>        )</span>
 35 |     | <span class='unexecuted'>    {</span>
 36 |     | <span class='unexecuted'>        bool zeroForOne = sqrtRatioCurrentX96 &gt;= sqrtRatioTargetX96;</span>
 37 |     | <span class='unexecuted'>        bool exactIn = amountRemaining &gt;= 0;</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='unexecuted'>        if (exactIn) {</span>
 40 |     | <span class='unexecuted'>            uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);</span>
 41 |     | <span class='unexecuted'>            amountIn = zeroForOne</span>
 42 |     | <span class='unexecuted'>                ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)</span>
 43 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);</span>
 44 |     | <span class='unexecuted'>            if (amountRemainingLessFee &gt;= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
 45 |     | <span class='neutral'>            else</span>
 46 |     | <span class='unexecuted'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(</span>
 47 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
 48 |     | <span class='unexecuted'>                    liquidity,</span>
 49 |     | <span class='unexecuted'>                    amountRemainingLessFee,</span>
 50 |     | <span class='unexecuted'>                    zeroForOne</span>
 51 |     | <span class='neutral'>                );</span>
 52 |     | <span class='neutral'>        } else {</span>
 53 |     | <span class='unexecuted'>            amountOut = zeroForOne</span>
 54 |     | <span class='unexecuted'>                ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)</span>
 55 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);</span>
 56 |     | <span class='unexecuted'>            if (uint256(-amountRemaining) &gt;= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;</span>
 57 |     | <span class='neutral'>            else</span>
 58 |     | <span class='unexecuted'>                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(</span>
 59 |     | <span class='unexecuted'>                    sqrtRatioCurrentX96,</span>
 60 |     | <span class='unexecuted'>                    liquidity,</span>
 61 |     | <span class='unexecuted'>                    uint256(-amountRemaining),</span>
 62 |     | <span class='unexecuted'>                    zeroForOne</span>
 63 |     | <span class='neutral'>                );</span>
 64 |     | <span class='neutral'>        }</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='unexecuted'>        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>        // get the input/output amounts</span>
 69 |     | <span class='unexecuted'>        if (zeroForOne) {</span>
 70 |     | <span class='unexecuted'>            amountIn = max &amp;&amp; exactIn</span>
 71 |     | <span class='unexecuted'>                ? amountIn</span>
 72 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);</span>
 73 |     | <span class='unexecuted'>            amountOut = max &amp;&amp; !exactIn</span>
 74 |     | <span class='unexecuted'>                ? amountOut</span>
 75 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);</span>
 76 |     | <span class='neutral'>        } else {</span>
 77 |     | <span class='unexecuted'>            amountIn = max &amp;&amp; exactIn</span>
 78 |     | <span class='unexecuted'>                ? amountIn</span>
 79 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);</span>
 80 |     | <span class='unexecuted'>            amountOut = max &amp;&amp; !exactIn</span>
 81 |     | <span class='unexecuted'>                ? amountOut</span>
 82 |     | <span class='unexecuted'>                : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);</span>
 83 |     | <span class='neutral'>        }</span>
 84 |     | <span class='neutral'></span>
 85 |     | <span class='neutral'>        // cap the output amount to not exceed the remaining output amount</span>
 86 |     | <span class='unexecuted'>        if (!exactIn &amp;&amp; amountOut &gt; uint256(-amountRemaining)) {</span>
 87 |     | <span class='unexecuted'>            amountOut = uint256(-amountRemaining);</span>
 88 |     | <span class='neutral'>        }</span>
 89 |     | <span class='neutral'></span>
 90 |     | <span class='unexecuted'>        if (exactIn &amp;&amp; sqrtRatioNextX96 != sqrtRatioTargetX96) {</span>
 91 |     | <span class='neutral'>            // we didn&#39;t reach the target, so take the remainder of the maximum input as fee</span>
 92 |     | <span class='unexecuted'>            feeAmount = uint256(amountRemaining) - amountIn;</span>
 93 |     | <span class='neutral'>        } else {</span>
 94 |     | <span class='unexecuted'>            feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);</span>
 95 |     | <span class='neutral'>        }</span>
 96 |     | <span class='neutral'>    }</span>
 97 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/Tick.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;./LowGasSafeMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;./SafeCast.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>import &#39;./TickMath.sol&#39;;</span>
   8 |     | <span class='neutral'>import &#39;./LiquidityMath.sol&#39;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>/// @title Tick</span>
  11 |     | <span class='neutral'>/// @notice Contains functions for managing tick processes and relevant calculations</span>
  12 |     | <span class='unexecuted'>library Tick {</span>
  13 |     | <span class='neutral'>    using LowGasSafeMath for int256;</span>
  14 |     | <span class='neutral'>    using SafeCast for int256;</span>
  15 |     | <span class='neutral'></span>
  16 |     | <span class='neutral'>    // info stored for each initialized individual tick</span>
  17 |     | <span class='neutral'>    struct Info {</span>
  18 |     | <span class='neutral'>        // the total position liquidity that references this tick</span>
  19 |     | <span class='neutral'>        uint128 liquidityGross;</span>
  20 |     | <span class='neutral'>        // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),</span>
  21 |     | <span class='neutral'>        int128 liquidityNet;</span>
  22 |     | <span class='neutral'>        // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  23 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  24 |     | <span class='neutral'>        uint256 feeGrowthOutside0X128;</span>
  25 |     | <span class='neutral'>        uint256 feeGrowthOutside1X128;</span>
  26 |     | <span class='neutral'>        // the cumulative tick value on the other side of the tick</span>
  27 |     | <span class='neutral'>        int56 tickCumulativeOutside;</span>
  28 |     | <span class='neutral'>        // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)</span>
  29 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  30 |     | <span class='neutral'>        uint160 secondsPerLiquidityOutsideX128;</span>
  31 |     | <span class='neutral'>        // the seconds spent on the other side of the tick (relative to the current tick)</span>
  32 |     | <span class='neutral'>        // only has relative meaning, not absolute  the value depends on when the tick is initialized</span>
  33 |     | <span class='neutral'>        uint32 secondsOutside;</span>
  34 |     | <span class='neutral'>        // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0</span>
  35 |     | <span class='neutral'>        // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks</span>
  36 |     | <span class='neutral'>        bool initialized;</span>
  37 |     | <span class='neutral'>    }</span>
  38 |     | <span class='neutral'></span>
  39 |     | <span class='neutral'>    /// @notice Derives max liquidity per tick from given tick spacing</span>
  40 |     | <span class='neutral'>    /// @dev Executed within the pool constructor</span>
  41 |     | <span class='neutral'>    /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`</span>
  42 |     | <span class='neutral'>    ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...</span>
  43 |     | <span class='neutral'>    /// @return The max liquidity per tick</span>
  44 |     | <span class='unexecuted'>    function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {</span>
  45 |     | <span class='unexecuted'>        int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;</span>
  46 |     | <span class='unexecuted'>        int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;</span>
  47 |     | <span class='unexecuted'>        uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;</span>
  48 |     | <span class='unexecuted'>        return type(uint128).max / numTicks;</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    /// @notice Retrieves fee growth data</span>
  52 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  53 |     | <span class='neutral'>    /// @param tickLower The lower tick boundary of the position</span>
  54 |     | <span class='neutral'>    /// @param tickUpper The upper tick boundary of the position</span>
  55 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
  56 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
  57 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
  58 |     | <span class='neutral'>    /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  59 |     | <span class='neutral'>    /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position&#39;s tick boundaries</span>
  60 |     | <span class='unexecuted'>    function getFeeGrowthInside(</span>
  61 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
  62 |     | <span class='neutral'>        int24 tickLower,</span>
  63 |     | <span class='neutral'>        int24 tickUpper,</span>
  64 |     | <span class='neutral'>        int24 tickCurrent,</span>
  65 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
  66 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128</span>
  67 |     | <span class='unexecuted'>    ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {</span>
  68 |     | <span class='unexecuted'>        Info storage lower = self[tickLower];</span>
  69 |     | <span class='unexecuted'>        Info storage upper = self[tickUpper];</span>
  70 |     | <span class='neutral'></span>
  71 |     | <span class='neutral'>        // calculate fee growth below</span>
  72 |     | <span class='neutral'>        uint256 feeGrowthBelow0X128;</span>
  73 |     | <span class='neutral'>        uint256 feeGrowthBelow1X128;</span>
  74 |     | <span class='unexecuted'>        if (tickCurrent &gt;= tickLower) {</span>
  75 |     | <span class='unexecuted'>            feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;</span>
  76 |     | <span class='unexecuted'>            feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;</span>
  77 |     | <span class='neutral'>        } else {</span>
  78 |     | <span class='unexecuted'>            feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;</span>
  79 |     | <span class='unexecuted'>            feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;</span>
  80 |     | <span class='neutral'>        }</span>
  81 |     | <span class='neutral'></span>
  82 |     | <span class='neutral'>        // calculate fee growth above</span>
  83 |     | <span class='unexecuted'>        uint256 feeGrowthAbove0X128;</span>
  84 |     | <span class='unexecuted'>        uint256 feeGrowthAbove1X128;</span>
  85 |     | <span class='unexecuted'>        if (tickCurrent &lt; tickUpper) {</span>
  86 |     | <span class='unexecuted'>            feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;</span>
  87 |     | <span class='unexecuted'>            feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;</span>
  88 |     | <span class='neutral'>        } else {</span>
  89 |     | <span class='unexecuted'>            feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;</span>
  90 |     | <span class='unexecuted'>            feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;</span>
  91 |     | <span class='neutral'>        }</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='unexecuted'>        feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;</span>
  94 |     | <span class='unexecuted'>        feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;</span>
  95 |     | <span class='neutral'>    }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>    /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa</span>
  98 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
  99 |     | <span class='neutral'>    /// @param tick The tick that will be updated</span>
 100 |     | <span class='neutral'>    /// @param tickCurrent The current tick</span>
 101 |     | <span class='neutral'>    /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)</span>
 102 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 103 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 104 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool</span>
 105 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 106 |     | <span class='neutral'>    /// @param time The current block timestamp cast to a uint32</span>
 107 |     | <span class='neutral'>    /// @param upper true for updating a position&#39;s upper tick, or false for updating a position&#39;s lower tick</span>
 108 |     | <span class='neutral'>    /// @param maxLiquidity The maximum liquidity allocation for a single tick</span>
 109 |     | <span class='neutral'>    /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa</span>
 110 |     | <span class='unexecuted'>    function update(</span>
 111 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 112 |     | <span class='neutral'>        int24 tick,</span>
 113 |     | <span class='neutral'>        int24 tickCurrent,</span>
 114 |     | <span class='neutral'>        int128 liquidityDelta,</span>
 115 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 116 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 117 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 118 |     | <span class='neutral'>        int56 tickCumulative,</span>
 119 |     | <span class='neutral'>        uint32 time,</span>
 120 |     | <span class='neutral'>        bool upper,</span>
 121 |     | <span class='neutral'>        uint128 maxLiquidity</span>
 122 |     | <span class='unexecuted'>    ) internal returns (bool flipped) {</span>
 123 |     | <span class='unexecuted'>        Tick.Info storage info = self[tick];</span>
 124 |     | <span class='neutral'></span>
 125 |     | <span class='unexecuted'>        uint128 liquidityGrossBefore = info.liquidityGross;</span>
 126 |     | <span class='unexecuted'>        uint128 liquidityGrossAfter = LiquidityMath.addDelta(liquidityGrossBefore, liquidityDelta);</span>
 127 |     | <span class='neutral'></span>
 128 |     | <span class='unexecuted'>        require(liquidityGrossAfter &lt;= maxLiquidity, &#39;LO&#39;);</span>
 129 |     | <span class='neutral'></span>
 130 |     | <span class='unexecuted'>        flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='unexecuted'>        if (liquidityGrossBefore == 0) {</span>
 133 |     | <span class='neutral'>            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick</span>
 134 |     | <span class='unexecuted'>            if (tick &lt;= tickCurrent) {</span>
 135 |     | <span class='unexecuted'>                info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;</span>
 136 |     | <span class='unexecuted'>                info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;</span>
 137 |     | <span class='unexecuted'>                info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;</span>
 138 |     | <span class='unexecuted'>                info.tickCumulativeOutside = tickCumulative;</span>
 139 |     | <span class='unexecuted'>                info.secondsOutside = time;</span>
 140 |     | <span class='neutral'>            }</span>
 141 |     | <span class='unexecuted'>            info.initialized = true;</span>
 142 |     | <span class='neutral'>        }</span>
 143 |     | <span class='neutral'></span>
 144 |     | <span class='unexecuted'>        info.liquidityGross = liquidityGrossAfter;</span>
 145 |     | <span class='neutral'></span>
 146 |     | <span class='neutral'>        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)</span>
 147 |     | <span class='unexecuted'>        info.liquidityNet = upper</span>
 148 |     | <span class='unexecuted'>            ? int256(info.liquidityNet).sub(liquidityDelta).toInt128()</span>
 149 |     | <span class='unexecuted'>            : int256(info.liquidityNet).add(liquidityDelta).toInt128();</span>
 150 |     | <span class='neutral'>    }</span>
 151 |     | <span class='neutral'></span>
 152 |     | <span class='neutral'>    /// @notice Clears tick data</span>
 153 |     | <span class='neutral'>    /// @param self The mapping containing all initialized tick information for initialized ticks</span>
 154 |     | <span class='neutral'>    /// @param tick The tick that will be cleared</span>
 155 |     | <span class='neutral'>    function clear(mapping(int24 =&gt; Tick.Info) storage self, int24 tick) internal {</span>
 156 |     | <span class='unexecuted'>        delete self[tick];</span>
 157 |     | <span class='neutral'>    }</span>
 158 |     | <span class='neutral'></span>
 159 |     | <span class='neutral'>    /// @notice Transitions to next tick as needed by price movement</span>
 160 |     | <span class='neutral'>    /// @param self The mapping containing all tick information for initialized ticks</span>
 161 |     | <span class='neutral'>    /// @param tick The destination tick of the transition</span>
 162 |     | <span class='neutral'>    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0</span>
 163 |     | <span class='neutral'>    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1</span>
 164 |     | <span class='neutral'>    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity</span>
 165 |     | <span class='neutral'>    /// @param tickCumulative The tick * time elapsed since the pool was first initialized</span>
 166 |     | <span class='neutral'>    /// @param time The current block.timestamp</span>
 167 |     | <span class='neutral'>    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)</span>
 168 |     | <span class='unexecuted'>    function cross(</span>
 169 |     | <span class='neutral'>        mapping(int24 =&gt; Tick.Info) storage self,</span>
 170 |     | <span class='neutral'>        int24 tick,</span>
 171 |     | <span class='neutral'>        uint256 feeGrowthGlobal0X128,</span>
 172 |     | <span class='neutral'>        uint256 feeGrowthGlobal1X128,</span>
 173 |     | <span class='neutral'>        uint160 secondsPerLiquidityCumulativeX128,</span>
 174 |     | <span class='neutral'>        int56 tickCumulative,</span>
 175 |     | <span class='neutral'>        uint32 time</span>
 176 |     | <span class='unexecuted'>    ) internal returns (int128 liquidityNet) {</span>
 177 |     | <span class='unexecuted'>        Tick.Info storage info = self[tick];</span>
 178 |     | <span class='unexecuted'>        info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;</span>
 179 |     | <span class='unexecuted'>        info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;</span>
 180 |     | <span class='unexecuted'>        info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128 - info.secondsPerLiquidityOutsideX128;</span>
 181 |     | <span class='unexecuted'>        info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;</span>
 182 |     | <span class='unexecuted'>        info.secondsOutside = time - info.secondsOutside;</span>
 183 |     | <span class='unexecuted'>        liquidityNet = info.liquidityNet;</span>
 184 |     | <span class='neutral'>    }</span>
 185 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TickBitmap.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: BUSL-1.1</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &#39;./BitMath.sol&#39;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Packed tick initialized state library</span>
  7 |     | <span class='neutral'>/// @notice Stores a packed mapping of tick index to its initialized state</span>
  8 |     | <span class='neutral'>/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.</span>
  9 |     | <span class='unexecuted'>library TickBitmap {</span>
 10 |     | <span class='neutral'>    /// @notice Computes the position in the mapping where the initialized bit for a tick lives</span>
 11 |     | <span class='neutral'>    /// @param tick The tick for which to compute the position</span>
 12 |     | <span class='neutral'>    /// @return wordPos The key in the mapping containing the word in which the bit is stored</span>
 13 |     | <span class='neutral'>    /// @return bitPos The bit position in the word where the flag is stored</span>
 14 |     | <span class='unexecuted'>    function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {</span>
 15 |     | <span class='unexecuted'>        wordPos = int16(tick &gt;&gt; 8);</span>
 16 |     | <span class='unexecuted'>        bitPos = uint8(uint24(tick % 256));</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Flips the initialized state for a given tick from false to true, or vice versa</span>
 20 |     | <span class='neutral'>    /// @param self The mapping in which to flip the tick</span>
 21 |     | <span class='neutral'>    /// @param tick The tick to flip</span>
 22 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 23 |     | <span class='unexecuted'>    function flipTick(</span>
 24 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 25 |     | <span class='neutral'>        int24 tick,</span>
 26 |     | <span class='neutral'>        int24 tickSpacing</span>
 27 |     | <span class='neutral'>    ) internal {</span>
 28 |     | <span class='unexecuted'>        require(tick % tickSpacing == 0); // ensure that the tick is spaced</span>
 29 |     | <span class='unexecuted'>        (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);</span>
 30 |     | <span class='unexecuted'>        uint256 mask = 1 &lt;&lt; bitPos;</span>
 31 |     | <span class='unexecuted'>        self[wordPos] ^= mask;</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'></span>
 34 |     | <span class='neutral'>    /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either</span>
 35 |     | <span class='neutral'>    /// to the left (less than or equal to) or right (greater than) of the given tick</span>
 36 |     | <span class='neutral'>    /// @param self The mapping in which to compute the next initialized tick</span>
 37 |     | <span class='neutral'>    /// @param tick The starting tick</span>
 38 |     | <span class='neutral'>    /// @param tickSpacing The spacing between usable ticks</span>
 39 |     | <span class='neutral'>    /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)</span>
 40 |     | <span class='neutral'>    /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick</span>
 41 |     | <span class='neutral'>    /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks</span>
 42 |     | <span class='unexecuted'>    function nextInitializedTickWithinOneWord(</span>
 43 |     | <span class='neutral'>        mapping(int16 =&gt; uint256) storage self,</span>
 44 |     | <span class='neutral'>        int24 tick,</span>
 45 |     | <span class='neutral'>        int24 tickSpacing,</span>
 46 |     | <span class='neutral'>        bool lte</span>
 47 |     | <span class='unexecuted'>    ) internal view returns (int24 next, bool initialized) {</span>
 48 |     | <span class='unexecuted'>        int24 compressed = tick / tickSpacing;</span>
 49 |     | <span class='unexecuted'>        if (tick &lt; 0 &amp;&amp; tick % tickSpacing != 0) compressed--; // round towards negative infinity</span>
 50 |     | <span class='neutral'></span>
 51 |     | <span class='unexecuted'>        if (lte) {</span>
 52 |     | <span class='unexecuted'>            (int16 wordPos, uint8 bitPos) = position(compressed);</span>
 53 |     | <span class='neutral'>            // all the 1s at or to the right of the current bitPos</span>
 54 |     | <span class='unexecuted'>            uint256 mask = (1 &lt;&lt; bitPos) - 1 + (1 &lt;&lt; bitPos);</span>
 55 |     | <span class='unexecuted'>            uint256 masked = self[wordPos] &amp; mask;</span>
 56 |     | <span class='neutral'></span>
 57 |     | <span class='neutral'>            // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word</span>
 58 |     | <span class='unexecuted'>            initialized = masked != 0;</span>
 59 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 60 |     | <span class='unexecuted'>            next = initialized</span>
 61 |     | <span class='unexecuted'>                ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing</span>
 62 |     | <span class='unexecuted'>                : (compressed - int24(uint24(bitPos))) * tickSpacing;</span>
 63 |     | <span class='unexecuted'>        } else {</span>
 64 |     | <span class='neutral'>            // start from the word of the next tick, since the current tick state doesn&#39;t matter</span>
 65 |     | <span class='unexecuted'>            (int16 wordPos, uint8 bitPos) = position(compressed + 1);</span>
 66 |     | <span class='neutral'>            // all the 1s at or to the left of the bitPos</span>
 67 |     | <span class='unexecuted'>            uint256 mask = ~((1 &lt;&lt; bitPos) - 1);</span>
 68 |     | <span class='unexecuted'>            uint256 masked = self[wordPos] &amp; mask;</span>
 69 |     | <span class='neutral'></span>
 70 |     | <span class='neutral'>            // if there are no initialized ticks to the left of the current tick, return leftmost in the word</span>
 71 |     | <span class='unexecuted'>            initialized = masked != 0;</span>
 72 |     | <span class='neutral'>            // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick</span>
 73 |     | <span class='unexecuted'>            next = initialized</span>
 74 |     | <span class='unexecuted'>                ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing</span>
 75 |     | <span class='unexecuted'>                : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;</span>
 76 |     | <span class='neutral'>        }</span>
 77 |     | <span class='neutral'>    }</span>
 78 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TickMath.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>/// @title Math library for computing sqrt prices from ticks and vice versa</span>
   5 |     | <span class='neutral'>/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports</span>
   6 |     | <span class='neutral'>/// prices between 2**-128 and 2**128</span>
   7 |     | <span class='unexecuted'>library TickMath {</span>
   8 |     | <span class='neutral'>    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128</span>
   9 |     | <span class='neutral'>    int24 internal constant MIN_TICK = -887272;</span>
  10 |     | <span class='neutral'>    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128</span>
  11 |     | <span class='unexecuted'>    int24 internal constant MAX_TICK = -MIN_TICK;</span>
  12 |     | <span class='neutral'></span>
  13 |     | <span class='neutral'>    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)</span>
  14 |     | <span class='unexecuted'>    uint160 internal constant MIN_SQRT_RATIO = 4295128739;</span>
  15 |     | <span class='neutral'>    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)</span>
  16 |     | <span class='unexecuted'>    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;</span>
  17 |     | <span class='neutral'></span>
  18 |     | <span class='neutral'>    /// @notice Calculates sqrt(1.0001^tick) * 2^96</span>
  19 |     | <span class='neutral'>    /// @dev Throws if |tick| &gt; max tick</span>
  20 |     | <span class='neutral'>    /// @param tick The input tick for the above formula</span>
  21 |     | <span class='neutral'>    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)</span>
  22 |     | <span class='neutral'>    /// at the given tick</span>
  23 |     | <span class='unexecuted'>    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {</span>
  24 |     | <span class='unexecuted'>        uint256 absTick = tick &lt; 0 ? uint256(-int256(tick)) : uint256(int256(tick));</span>
  25 |     | <span class='unexecuted'>        require(absTick &lt;= uint256(uint24(MAX_TICK)), &#39;T&#39;);</span>
  26 |     | <span class='neutral'></span>
  27 |     | <span class='unexecuted'>        uint256 ratio = absTick &amp; 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;</span>
  28 |     | <span class='unexecuted'>        if (absTick &amp; 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) &gt;&gt; 128;</span>
  29 |     | <span class='unexecuted'>        if (absTick &amp; 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) &gt;&gt; 128;</span>
  30 |     | <span class='unexecuted'>        if (absTick &amp; 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) &gt;&gt; 128;</span>
  31 |     | <span class='unexecuted'>        if (absTick &amp; 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) &gt;&gt; 128;</span>
  32 |     | <span class='unexecuted'>        if (absTick &amp; 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) &gt;&gt; 128;</span>
  33 |     | <span class='unexecuted'>        if (absTick &amp; 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) &gt;&gt; 128;</span>
  34 |     | <span class='unexecuted'>        if (absTick &amp; 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) &gt;&gt; 128;</span>
  35 |     | <span class='unexecuted'>        if (absTick &amp; 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) &gt;&gt; 128;</span>
  36 |     | <span class='unexecuted'>        if (absTick &amp; 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) &gt;&gt; 128;</span>
  37 |     | <span class='unexecuted'>        if (absTick &amp; 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) &gt;&gt; 128;</span>
  38 |     | <span class='unexecuted'>        if (absTick &amp; 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) &gt;&gt; 128;</span>
  39 |     | <span class='unexecuted'>        if (absTick &amp; 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) &gt;&gt; 128;</span>
  40 |     | <span class='unexecuted'>        if (absTick &amp; 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) &gt;&gt; 128;</span>
  41 |     | <span class='unexecuted'>        if (absTick &amp; 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) &gt;&gt; 128;</span>
  42 |     | <span class='unexecuted'>        if (absTick &amp; 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) &gt;&gt; 128;</span>
  43 |     | <span class='unexecuted'>        if (absTick &amp; 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) &gt;&gt; 128;</span>
  44 |     | <span class='unexecuted'>        if (absTick &amp; 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) &gt;&gt; 128;</span>
  45 |     | <span class='unexecuted'>        if (absTick &amp; 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) &gt;&gt; 128;</span>
  46 |     | <span class='unexecuted'>        if (absTick &amp; 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) &gt;&gt; 128;</span>
  47 |     | <span class='neutral'></span>
  48 |     | <span class='unexecuted'>        if (tick &gt; 0) ratio = type(uint256).max / ratio;</span>
  49 |     | <span class='neutral'></span>
  50 |     | <span class='neutral'>        // this divides by 1&lt;&lt;32 rounding up to go from a Q128.128 to a Q128.96.</span>
  51 |     | <span class='neutral'>        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint</span>
  52 |     | <span class='neutral'>        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent</span>
  53 |     | <span class='unexecuted'>        sqrtPriceX96 = uint160((ratio &gt;&gt; 32) + (ratio % (1 &lt;&lt; 32) == 0 ? 0 : 1));</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) &lt;= ratio</span>
  57 |     | <span class='neutral'>    /// @dev Throws in case sqrtPriceX96 &lt; MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may</span>
  58 |     | <span class='neutral'>    /// ever return.</span>
  59 |     | <span class='neutral'>    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96</span>
  60 |     | <span class='neutral'>    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio</span>
  61 |     | <span class='unexecuted'>    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {</span>
  62 |     | <span class='neutral'>        // second inequality must be &lt; because the price can never reach the price at the max tick</span>
  63 |     | <span class='unexecuted'>        require(sqrtPriceX96 &gt;= MIN_SQRT_RATIO &amp;&amp; sqrtPriceX96 &lt; MAX_SQRT_RATIO, &#39;R&#39;);</span>
  64 |     | <span class='unexecuted'>        uint256 ratio = uint256(sqrtPriceX96) &lt;&lt; 32;</span>
  65 |     | <span class='neutral'></span>
  66 |     | <span class='neutral'>        uint256 r = ratio;</span>
  67 |     | <span class='neutral'>        uint256 msb = 0;</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        assembly {</span>
  70 |     | <span class='unexecuted'>            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))</span>
  71 |     | <span class='neutral'>            msb := or(msb, f)</span>
  72 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  73 |     | <span class='neutral'>        }</span>
  74 |     | <span class='neutral'>        assembly {</span>
  75 |     | <span class='unexecuted'>            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))</span>
  76 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  77 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>        assembly {</span>
  80 |     | <span class='unexecuted'>            let f := shl(5, gt(r, 0xFFFFFFFF))</span>
  81 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  82 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'>        assembly {</span>
  85 |     | <span class='unexecuted'>            let f := shl(4, gt(r, 0xFFFF))</span>
  86 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  87 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  88 |     | <span class='neutral'>        }</span>
  89 |     | <span class='neutral'>        assembly {</span>
  90 |     | <span class='unexecuted'>            let f := shl(3, gt(r, 0xFF))</span>
  91 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  92 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  93 |     | <span class='neutral'>        }</span>
  94 |     | <span class='neutral'>        assembly {</span>
  95 |     | <span class='unexecuted'>            let f := shl(2, gt(r, 0xF))</span>
  96 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
  97 |     | <span class='unexecuted'>            r := shr(f, r)</span>
  98 |     | <span class='neutral'>        }</span>
  99 |     | <span class='neutral'>        assembly {</span>
 100 |     | <span class='unexecuted'>            let f := shl(1, gt(r, 0x3))</span>
 101 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 102 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 103 |     | <span class='neutral'>        }</span>
 104 |     | <span class='neutral'>        assembly {</span>
 105 |     | <span class='unexecuted'>            let f := gt(r, 0x1)</span>
 106 |     | <span class='unexecuted'>            msb := or(msb, f)</span>
 107 |     | <span class='neutral'>        }</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        if (msb &gt;= 128) r = ratio &gt;&gt; (msb - 127);</span>
 110 |     | <span class='unexecuted'>        else r = ratio &lt;&lt; (127 - msb);</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='unexecuted'>        int256 log_2 = (int256(msb) - 128) &lt;&lt; 64;</span>
 113 |     | <span class='neutral'></span>
 114 |     | <span class='neutral'>        assembly {</span>
 115 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 116 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 117 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(63, f))</span>
 118 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 119 |     | <span class='neutral'>        }</span>
 120 |     | <span class='neutral'>        assembly {</span>
 121 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 122 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 123 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(62, f))</span>
 124 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 125 |     | <span class='neutral'>        }</span>
 126 |     | <span class='neutral'>        assembly {</span>
 127 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 128 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 129 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(61, f))</span>
 130 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 131 |     | <span class='neutral'>        }</span>
 132 |     | <span class='neutral'>        assembly {</span>
 133 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 134 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 135 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(60, f))</span>
 136 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 137 |     | <span class='neutral'>        }</span>
 138 |     | <span class='neutral'>        assembly {</span>
 139 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 140 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 141 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(59, f))</span>
 142 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>        assembly {</span>
 145 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 146 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 147 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(58, f))</span>
 148 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 149 |     | <span class='neutral'>        }</span>
 150 |     | <span class='neutral'>        assembly {</span>
 151 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 152 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 153 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(57, f))</span>
 154 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 155 |     | <span class='neutral'>        }</span>
 156 |     | <span class='neutral'>        assembly {</span>
 157 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 158 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 159 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(56, f))</span>
 160 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 161 |     | <span class='neutral'>        }</span>
 162 |     | <span class='neutral'>        assembly {</span>
 163 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 164 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 165 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(55, f))</span>
 166 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 167 |     | <span class='neutral'>        }</span>
 168 |     | <span class='neutral'>        assembly {</span>
 169 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 170 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 171 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(54, f))</span>
 172 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 173 |     | <span class='neutral'>        }</span>
 174 |     | <span class='neutral'>        assembly {</span>
 175 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 176 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 177 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(53, f))</span>
 178 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 179 |     | <span class='neutral'>        }</span>
 180 |     | <span class='neutral'>        assembly {</span>
 181 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 182 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 183 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(52, f))</span>
 184 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 185 |     | <span class='neutral'>        }</span>
 186 |     | <span class='neutral'>        assembly {</span>
 187 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 188 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 189 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(51, f))</span>
 190 |     | <span class='unexecuted'>            r := shr(f, r)</span>
 191 |     | <span class='neutral'>        }</span>
 192 |     | <span class='neutral'>        assembly {</span>
 193 |     | <span class='unexecuted'>            r := shr(127, mul(r, r))</span>
 194 |     | <span class='unexecuted'>            let f := shr(128, r)</span>
 195 |     | <span class='unexecuted'>            log_2 := or(log_2, shl(50, f))</span>
 196 |     | <span class='neutral'>        }</span>
 197 |     | <span class='neutral'></span>
 198 |     | <span class='unexecuted'>        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number</span>
 199 |     | <span class='neutral'></span>
 200 |     | <span class='unexecuted'>        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) &gt;&gt; 128);</span>
 201 |     | <span class='unexecuted'>        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) &gt;&gt; 128);</span>
 202 |     | <span class='neutral'></span>
 203 |     | <span class='unexecuted'>        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) &lt;= sqrtPriceX96 ? tickHi : tickLow;</span>
 204 |     | <span class='neutral'>    }</span>
 205 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library TransferHelper {</span>
  7 |     | <span class='neutral'>    /// @notice Transfers tokens from the targeted address to the given destination</span>
  8 |     | <span class='neutral'>    /// @notice Errors with &#39;STF&#39; if transfer fails</span>
  9 |     | <span class='neutral'>    /// @param token The contract address of the token to be transferred</span>
 10 |     | <span class='neutral'>    /// @param from The originating address from which the tokens will be transferred</span>
 11 |     | <span class='neutral'>    /// @param to The destination address of the transfer</span>
 12 |     | <span class='neutral'>    /// @param value The amount to be transferred</span>
 13 |     | <span class='neutral'>    function safeTransferFrom(address token, address from, address to, uint256 value) internal {</span>
 14 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 15 |     | <span class='neutral'>            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));</span>
 16 |     | <span class='neutral'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;STF&quot;);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Transfers tokens from msg.sender to a recipient</span>
 20 |     | <span class='neutral'>    /// @dev Errors with ST if transfer fails</span>
 21 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred</span>
 22 |     | <span class='neutral'>    /// @param to The recipient of the transfer</span>
 23 |     | <span class='neutral'>    /// @param value The value of the transfer</span>
 24 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint256 value) internal {</span>
 25 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 26 |     | <span class='unexecuted'>            token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));</span>
 27 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;ST&quot;);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Approves the stipulated contract to spend the given allowance in the given token</span>
 31 |     | <span class='neutral'>    /// @dev Errors with &#39;SA&#39; if transfer fails</span>
 32 |     | <span class='neutral'>    /// @param token The contract address of the token to be approved</span>
 33 |     | <span class='neutral'>    /// @param to The target of the approval</span>
 34 |     | <span class='neutral'>    /// @param value The amount of the given token the target will be allowed to spend</span>
 35 |     | <span class='neutral'>    function safeApprove(address token, address to, uint256 value) internal {</span>
 36 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 37 |     | <span class='neutral'>            token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));</span>
 38 |     | <span class='neutral'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;SA&quot;);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Transfers ETH to the recipient address</span>
 42 |     | <span class='neutral'>    /// @dev Fails with `STE`</span>
 43 |     | <span class='neutral'>    /// @param to The destination of the transfer</span>
 44 |     | <span class='neutral'>    /// @param value The value to be transferred</span>
 45 |     | <span class='neutral'>    function safeTransferETH(address to, uint256 value) internal {</span>
 46 |     | <span class='neutral'>        (bool success,) = to.call{value: value}(new bytes(0));</span>
 47 |     | <span class='neutral'>        require(success, &quot;STE&quot;);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-core/libraries/UnsafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Math functions that do not check inputs or outputs</span>
  5 |     | <span class='neutral'>/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks</span>
  6 |     | <span class='unexecuted'>library UnsafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns ceil(x / y)</span>
  8 |     | <span class='neutral'>    /// @dev division by 0 has unspecified behavior, and must be checked externally</span>
  9 |     | <span class='neutral'>    /// @param x The dividend</span>
 10 |     | <span class='neutral'>    /// @param y The divisor</span>
 11 |     | <span class='neutral'>    /// @return z The quotient, ceil(x / y)</span>
 12 |     | <span class='unexecuted'>    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 13 |     | <span class='neutral'>        assembly {</span>
 14 |     | <span class='unexecuted'>            z := add(div(x, y), gt(mod(x, y), 0))</span>
 15 |     | <span class='neutral'>        }</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/SwapRouter.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
   3 |     | <span class='neutral'>pragma abicoder v2;</span>
   4 |     | <span class='neutral'></span>
   5 |     | <span class='neutral'>import &quot;v3-core/libraries/SafeCast.sol&quot;;</span>
   6 |     | <span class='neutral'>import &quot;v3-core/libraries/TickMath.sol&quot;;</span>
   7 |     | <span class='neutral'>import &quot;v3-core/interfaces/IUniswapV3Pool.sol&quot;;</span>
   8 |     | <span class='neutral'>import &quot;v3-core/interfaces/IUniswapV3Factory.sol&quot;;</span>
   9 |     | <span class='neutral'></span>
  10 |     | <span class='neutral'>import &quot;./interfaces/ISwapRouter.sol&quot;;</span>
  11 |     | <span class='neutral'>import &quot;./base/PeripheryImmutableState.sol&quot;;</span>
  12 |     | <span class='neutral'>import &quot;./base/PeripheryValidation.sol&quot;;</span>
  13 |     | <span class='neutral'>import &quot;./base/PeripheryPaymentsWithFee.sol&quot;;</span>
  14 |     | <span class='neutral'>import &quot;./base/Multicall.sol&quot;;</span>
  15 |     | <span class='neutral'>import &quot;./base/SelfPermit.sol&quot;;</span>
  16 |     | <span class='neutral'>import &quot;./libraries/Path.sol&quot;;</span>
  17 |     | <span class='neutral'>import &quot;./libraries/CallbackValidation.sol&quot;;</span>
  18 |     | <span class='neutral'>import &quot;./interfaces/external/IWETH9.sol&quot;;</span>
  19 |     | <span class='neutral'></span>
  20 |     | <span class='neutral'>/// @title Uniswap V3 Swap Router</span>
  21 |     | <span class='neutral'>/// @notice Router for stateless execution of swaps against Uniswap V3</span>
  22 |     | <span class='unexecuted'>contract SwapRouter is</span>
  23 |     | <span class='neutral'>    ISwapRouter,</span>
  24 |     | <span class='neutral'>    PeripheryImmutableState,</span>
  25 |     | <span class='neutral'>    PeripheryValidation,</span>
  26 |     | <span class='neutral'>    PeripheryPaymentsWithFee,</span>
  27 |     | <span class='neutral'>    Multicall,</span>
  28 |     | <span class='neutral'>    SelfPermit</span>
  29 |     | <span class='neutral'>{</span>
  30 |     | <span class='neutral'>    using Path for bytes;</span>
  31 |     | <span class='neutral'>    using SafeCast for uint256;</span>
  32 |     | <span class='neutral'></span>
  33 |     | <span class='neutral'>    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap</span>
  34 |     | <span class='neutral'>    /// can never actually be this value</span>
  35 |     | <span class='neutral'>    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;</span>
  36 |     | <span class='neutral'></span>
  37 |     | <span class='neutral'>    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.</span>
  38 |     | <span class='unexecuted'>    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='unexecuted'>    constructor(address _factory, address _WETH9) PeripheryImmutableState(_factory, _WETH9) {}</span>
  41 |     | <span class='neutral'></span>
  42 |     | <span class='neutral'>    /// @dev Returns the pool for the given token pair and fee. The pool contract may or may not exist.</span>
  43 |     | <span class='unexecuted'>    function getPool(</span>
  44 |     | <span class='neutral'>        address tokenA,</span>
  45 |     | <span class='neutral'>        address tokenB,</span>
  46 |     | <span class='neutral'>        uint24 fee</span>
  47 |     | <span class='unexecuted'>    ) private view returns (IUniswapV3Pool) {</span>
  48 |     | <span class='unexecuted'>        return IUniswapV3Pool(IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee));</span>
  49 |     | <span class='neutral'>    }</span>
  50 |     | <span class='neutral'></span>
  51 |     | <span class='neutral'>    struct SwapCallbackData {</span>
  52 |     | <span class='neutral'>        bytes path;</span>
  53 |     | <span class='neutral'>        address payer;</span>
  54 |     | <span class='neutral'>    }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3SwapCallback</span>
  57 |     | <span class='unexecuted'>    function uniswapV3SwapCallback(</span>
  58 |     | <span class='neutral'>        int256 amount0Delta,</span>
  59 |     | <span class='neutral'>        int256 amount1Delta,</span>
  60 |     | <span class='neutral'>        bytes calldata _data</span>
  61 |     | <span class='neutral'>    ) external override {</span>
  62 |     | <span class='unexecuted'>        require(amount0Delta &gt; 0 || amount1Delta &gt; 0); // swaps entirely within 0-liquidity regions are not supported</span>
  63 |     | <span class='unexecuted'>        SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));</span>
  64 |     | <span class='unexecuted'>        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();</span>
  65 |     | <span class='unexecuted'>        CallbackValidation.verifyCallback(factory, tokenIn, tokenOut, fee);</span>
  66 |     | <span class='neutral'></span>
  67 |     | <span class='unexecuted'>        (bool isExactInput, uint256 amountToPay) = amount0Delta &gt; 0</span>
  68 |     | <span class='unexecuted'>            ? (tokenIn &lt; tokenOut, uint256(amount0Delta))</span>
  69 |     | <span class='unexecuted'>            : (tokenOut &lt; tokenIn, uint256(amount1Delta));</span>
  70 |     | <span class='unexecuted'>        if (isExactInput) {</span>
  71 |     | <span class='unexecuted'>            pay(tokenIn, data.payer, msg.sender, amountToPay);</span>
  72 |     | <span class='neutral'>        } else {</span>
  73 |     | <span class='neutral'>            // either initiate the next swap or pay</span>
  74 |     | <span class='unexecuted'>            if (data.path.hasMultiplePools()) {</span>
  75 |     | <span class='unexecuted'>                data.path = data.path.skipToken();</span>
  76 |     | <span class='unexecuted'>                exactOutputInternal(amountToPay, msg.sender, 0, data);</span>
  77 |     | <span class='neutral'>            } else {</span>
  78 |     | <span class='unexecuted'>                amountInCached = amountToPay;</span>
  79 |     | <span class='unexecuted'>                tokenIn = tokenOut; // swap in/out because exact output swaps are reversed</span>
  80 |     | <span class='unexecuted'>                pay(tokenIn, data.payer, msg.sender, amountToPay);</span>
  81 |     | <span class='neutral'>            }</span>
  82 |     | <span class='neutral'>        }</span>
  83 |     | <span class='neutral'>    }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>    /// @dev Performs a single exact input swap</span>
  86 |     | <span class='unexecuted'>    function exactInputInternal(</span>
  87 |     | <span class='neutral'>        uint256 amountIn,</span>
  88 |     | <span class='neutral'>        address recipient,</span>
  89 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
  90 |     | <span class='neutral'>        SwapCallbackData memory data</span>
  91 |     | <span class='unexecuted'>    ) private returns (uint256 amountOut) {</span>
  92 |     | <span class='neutral'>        // allow swapping to the router address with address 0</span>
  93 |     | <span class='unexecuted'>        if (recipient == address(0)) recipient = address(this);</span>
  94 |     | <span class='neutral'></span>
  95 |     | <span class='unexecuted'>        (address tokenIn, address tokenOut, uint24 fee) = data.path.decodeFirstPool();</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='unexecuted'>        bool zeroForOne = tokenIn &lt; tokenOut;</span>
  98 |     | <span class='neutral'></span>
  99 |     | <span class='unexecuted'>        (int256 amount0, int256 amount1) = getPool(tokenIn, tokenOut, fee).swap(</span>
 100 |     | <span class='unexecuted'>            recipient,</span>
 101 |     | <span class='unexecuted'>            zeroForOne,</span>
 102 |     | <span class='unexecuted'>            amountIn.toInt256(),</span>
 103 |     | <span class='unexecuted'>            sqrtPriceLimitX96 == 0</span>
 104 |     | <span class='unexecuted'>                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)</span>
 105 |     | <span class='unexecuted'>                : sqrtPriceLimitX96,</span>
 106 |     | <span class='unexecuted'>            abi.encode(data)</span>
 107 |     | <span class='neutral'>        );</span>
 108 |     | <span class='neutral'></span>
 109 |     | <span class='unexecuted'>        return uint256(-(zeroForOne ? amount1 : amount0));</span>
 110 |     | <span class='neutral'>    }</span>
 111 |     | <span class='neutral'></span>
 112 |     | <span class='neutral'>    /// @inheritdoc ISwapRouter</span>
 113 |     | <span class='unexecuted'>    function exactInputSingle(ExactInputSingleParams calldata params)</span>
 114 |     | <span class='neutral'>        external</span>
 115 |     | <span class='neutral'>        payable</span>
 116 |     | <span class='neutral'>        override</span>
 117 |     | <span class='unexecuted'>        checkDeadline(params.deadline)</span>
 118 |     | <span class='unexecuted'>        returns (uint256 amountOut)</span>
 119 |     | <span class='neutral'>    {</span>
 120 |     | <span class='unexecuted'>        amountOut = exactInputInternal(</span>
 121 |     | <span class='unexecuted'>            params.amountIn,</span>
 122 |     | <span class='unexecuted'>            params.recipient,</span>
 123 |     | <span class='unexecuted'>            params.sqrtPriceLimitX96,</span>
 124 |     | <span class='unexecuted'>            SwapCallbackData({</span>
 125 |     | <span class='unexecuted'>                path: abi.encodePacked(params.tokenIn, params.fee, params.tokenOut),</span>
 126 |     | <span class='unexecuted'>                payer: msg.sender</span>
 127 |     | <span class='neutral'>            })</span>
 128 |     | <span class='neutral'>        );</span>
 129 |     | <span class='unexecuted'>        require(amountOut &gt;= params.amountOutMinimum, &quot;Too little received&quot;);</span>
 130 |     | <span class='neutral'>    }</span>
 131 |     | <span class='neutral'></span>
 132 |     | <span class='neutral'>    /// @inheritdoc ISwapRouter</span>
 133 |     | <span class='unexecuted'>    function exactInput(ExactInputParams memory params)</span>
 134 |     | <span class='neutral'>        external</span>
 135 |     | <span class='neutral'>        payable</span>
 136 |     | <span class='neutral'>        override</span>
 137 |     | <span class='unexecuted'>        checkDeadline(params.deadline)</span>
 138 |     | <span class='unexecuted'>        returns (uint256 amountOut)</span>
 139 |     | <span class='unexecuted'>    {</span>
 140 |     | <span class='unexecuted'>        address payer = msg.sender; // msg.sender pays for the first hop</span>
 141 |     | <span class='neutral'></span>
 142 |     | <span class='unexecuted'>        while (true) {</span>
 143 |     | <span class='unexecuted'>            bool hasMultiplePools = params.path.hasMultiplePools();</span>
 144 |     | <span class='neutral'></span>
 145 |     | <span class='neutral'>            // the outputs of prior swaps become the inputs to subsequent ones</span>
 146 |     | <span class='unexecuted'>            params.amountIn = exactInputInternal(</span>
 147 |     | <span class='unexecuted'>                params.amountIn,</span>
 148 |     | <span class='unexecuted'>                hasMultiplePools ? address(this) : params.recipient, // for intermediate swaps, this contract custodies</span>
 149 |     | <span class='unexecuted'>                0,</span>
 150 |     | <span class='unexecuted'>                SwapCallbackData({</span>
 151 |     | <span class='unexecuted'>                    path: params.path.getFirstPool(), // only the first pool in the path is necessary</span>
 152 |     | <span class='unexecuted'>                    payer: payer</span>
 153 |     | <span class='neutral'>                })</span>
 154 |     | <span class='neutral'>            );</span>
 155 |     | <span class='neutral'></span>
 156 |     | <span class='neutral'>            // decide whether to continue or terminate</span>
 157 |     | <span class='unexecuted'>            if (hasMultiplePools) {</span>
 158 |     | <span class='unexecuted'>                payer = address(this); // at this point, the caller has paid</span>
 159 |     | <span class='unexecuted'>                params.path = params.path.skipToken();</span>
 160 |     | <span class='neutral'>            } else {</span>
 161 |     | <span class='unexecuted'>                amountOut = params.amountIn;</span>
 162 |     | <span class='unexecuted'>                break;</span>
 163 |     | <span class='neutral'>            }</span>
 164 |     | <span class='neutral'>        }</span>
 165 |     | <span class='neutral'></span>
 166 |     | <span class='unexecuted'>        require(amountOut &gt;= params.amountOutMinimum, &quot;Too little received&quot;);</span>
 167 |     | <span class='neutral'>    }</span>
 168 |     | <span class='neutral'></span>
 169 |     | <span class='neutral'>    /// @dev Performs a single exact output swap</span>
 170 |     | <span class='unexecuted'>    function exactOutputInternal(</span>
 171 |     | <span class='neutral'>        uint256 amountOut,</span>
 172 |     | <span class='neutral'>        address recipient,</span>
 173 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96,</span>
 174 |     | <span class='neutral'>        SwapCallbackData memory data</span>
 175 |     | <span class='unexecuted'>    ) private returns (uint256 amountIn) {</span>
 176 |     | <span class='neutral'>        // allow swapping to the router address with address 0</span>
 177 |     | <span class='unexecuted'>        if (recipient == address(0)) recipient = address(this);</span>
 178 |     | <span class='neutral'></span>
 179 |     | <span class='unexecuted'>        (address tokenOut, address tokenIn, uint24 fee) = data.path.decodeFirstPool();</span>
 180 |     | <span class='neutral'></span>
 181 |     | <span class='unexecuted'>        bool zeroForOne = tokenIn &lt; tokenOut;</span>
 182 |     | <span class='neutral'></span>
 183 |     | <span class='unexecuted'>        (int256 amount0Delta, int256 amount1Delta) = getPool(tokenIn, tokenOut, fee).swap(</span>
 184 |     | <span class='unexecuted'>            recipient,</span>
 185 |     | <span class='unexecuted'>            zeroForOne,</span>
 186 |     | <span class='unexecuted'>            -amountOut.toInt256(),</span>
 187 |     | <span class='unexecuted'>            sqrtPriceLimitX96 == 0</span>
 188 |     | <span class='unexecuted'>                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)</span>
 189 |     | <span class='unexecuted'>                : sqrtPriceLimitX96,</span>
 190 |     | <span class='unexecuted'>            abi.encode(data)</span>
 191 |     | <span class='neutral'>        );</span>
 192 |     | <span class='neutral'></span>
 193 |     | <span class='unexecuted'>        uint256 amountOutReceived;</span>
 194 |     | <span class='unexecuted'>        (amountIn, amountOutReceived) = zeroForOne</span>
 195 |     | <span class='unexecuted'>            ? (uint256(amount0Delta), uint256(-amount1Delta))</span>
 196 |     | <span class='unexecuted'>            : (uint256(amount1Delta), uint256(-amount0Delta));</span>
 197 |     | <span class='neutral'>        // it&#39;s technically possible to not receive the full output amount,</span>
 198 |     | <span class='neutral'>        // so if no price limit has been specified, require this possibility away</span>
 199 |     | <span class='unexecuted'>        if (sqrtPriceLimitX96 == 0) require(amountOutReceived == amountOut);</span>
 200 |     | <span class='neutral'>    }</span>
 201 |     | <span class='neutral'></span>
 202 |     | <span class='neutral'>    /// @inheritdoc ISwapRouter</span>
 203 |     | <span class='unexecuted'>    function exactOutputSingle(ExactOutputSingleParams calldata params)</span>
 204 |     | <span class='neutral'>        external</span>
 205 |     | <span class='neutral'>        payable</span>
 206 |     | <span class='neutral'>        override</span>
 207 |     | <span class='unexecuted'>        checkDeadline(params.deadline)</span>
 208 |     | <span class='unexecuted'>        returns (uint256 amountIn)</span>
 209 |     | <span class='neutral'>    {</span>
 210 |     | <span class='neutral'>        // avoid an SLOAD by using the swap return data</span>
 211 |     | <span class='unexecuted'>        amountIn = exactOutputInternal(</span>
 212 |     | <span class='unexecuted'>            params.amountOut,</span>
 213 |     | <span class='unexecuted'>            params.recipient,</span>
 214 |     | <span class='unexecuted'>            params.sqrtPriceLimitX96,</span>
 215 |     | <span class='unexecuted'>            SwapCallbackData({</span>
 216 |     | <span class='unexecuted'>                path: abi.encodePacked(params.tokenOut, params.fee, params.tokenIn),</span>
 217 |     | <span class='unexecuted'>                payer: msg.sender</span>
 218 |     | <span class='neutral'>            })</span>
 219 |     | <span class='neutral'>        );</span>
 220 |     | <span class='neutral'></span>
 221 |     | <span class='unexecuted'>        require(amountIn &lt;= params.amountInMaximum, &quot;Too much requested&quot;);</span>
 222 |     | <span class='neutral'>        // has to be reset even though we don&#39;t use it in the single hop case</span>
 223 |     | <span class='unexecuted'>        amountInCached = DEFAULT_AMOUNT_IN_CACHED;</span>
 224 |     | <span class='neutral'>    }</span>
 225 |     | <span class='neutral'></span>
 226 |     | <span class='neutral'>    /// @inheritdoc ISwapRouter</span>
 227 |     | <span class='unexecuted'>    function exactOutput(ExactOutputParams calldata params)</span>
 228 |     | <span class='neutral'>        external</span>
 229 |     | <span class='neutral'>        payable</span>
 230 |     | <span class='neutral'>        override</span>
 231 |     | <span class='unexecuted'>        checkDeadline(params.deadline)</span>
 232 |     | <span class='unexecuted'>        returns (uint256 amountIn)</span>
 233 |     | <span class='neutral'>    {</span>
 234 |     | <span class='neutral'>        // it&#39;s okay that the payer is fixed to msg.sender here, as they&#39;re only paying for the &quot;final&quot; exact output</span>
 235 |     | <span class='neutral'>        // swap, which happens first, and subsequent swaps are paid for within nested callback frames</span>
 236 |     | <span class='unexecuted'>        exactOutputInternal(</span>
 237 |     | <span class='unexecuted'>            params.amountOut,</span>
 238 |     | <span class='unexecuted'>            params.recipient,</span>
 239 |     | <span class='unexecuted'>            0,</span>
 240 |     | <span class='unexecuted'>            SwapCallbackData({path: params.path, payer: msg.sender})</span>
 241 |     | <span class='neutral'>        );</span>
 242 |     | <span class='neutral'></span>
 243 |     | <span class='unexecuted'>        amountIn = amountInCached;</span>
 244 |     | <span class='unexecuted'>        require(amountIn &lt;= params.amountInMaximum, &quot;Too much requested&quot;);</span>
 245 |     | <span class='neutral'>        amountInCached = DEFAULT_AMOUNT_IN_CACHED;</span>
 246 |     | <span class='neutral'>    }</span>
 247 |     | <span class='neutral'>}</span>
 248 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/BlockTimestamp.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Function for getting block timestamp</span>
  5 |     | <span class='neutral'>/// @dev Base contract that is overridden for tests</span>
  6 |     | <span class='neutral'>abstract contract BlockTimestamp {</span>
  7 |     | <span class='neutral'>    /// @dev Method that exists purely to be overridden for tests</span>
  8 |     | <span class='neutral'>    /// @return The current block timestamp</span>
  9 |     | <span class='unexecuted'>    function _blockTimestamp() internal view virtual returns (uint256) {</span>
 10 |     | <span class='unexecuted'>        return block.timestamp;</span>
 11 |     | <span class='neutral'>    }</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/LiquidityManagement.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &#39;v3-core/interfaces/IUniswapV3Factory.sol&#39;;</span>
  6 |     | <span class='neutral'>import &#39;v3-core/interfaces/callback/IUniswapV3MintCallback.sol&#39;;</span>
  7 |     | <span class='neutral'>import &#39;v3-core/libraries/TickMath.sol&#39;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import &#39;../libraries/PoolAddress.sol&#39;;</span>
 10 |     | <span class='neutral'>import &#39;../libraries/CallbackValidation.sol&#39;;</span>
 11 |     | <span class='neutral'>import &#39;../libraries/LiquidityAmounts.sol&#39;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>import &#39;./PeripheryPayments.sol&#39;;</span>
 14 |     | <span class='neutral'>import &#39;./PeripheryImmutableState.sol&#39;;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>/// @title Liquidity management functions</span>
 17 |     | <span class='neutral'>/// @notice Internal functions for safely managing liquidity in Uniswap V3</span>
 18 |     | <span class='neutral'>abstract contract LiquidityManagement is IUniswapV3MintCallback, PeripheryImmutableState, PeripheryPayments {</span>
 19 |     | <span class='neutral'>    struct MintCallbackData {</span>
 20 |     | <span class='neutral'>        PoolAddress.PoolKey poolKey;</span>
 21 |     | <span class='neutral'>        address payer;</span>
 22 |     | <span class='neutral'>    }</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @inheritdoc IUniswapV3MintCallback</span>
 25 |     | <span class='neutral'>    function uniswapV3MintCallback(</span>
 26 |     | <span class='neutral'>        uint256 amount0Owed,</span>
 27 |     | <span class='neutral'>        uint256 amount1Owed,</span>
 28 |     | <span class='neutral'>        bytes calldata data</span>
 29 |     | <span class='neutral'>    ) external override {</span>
 30 |     | <span class='neutral'>        MintCallbackData memory decoded = abi.decode(data, (MintCallbackData));</span>
 31 |     | <span class='neutral'>        CallbackValidation.verifyCallback(factory, decoded.poolKey);</span>
 32 |     | <span class='neutral'></span>
 33 |     | <span class='neutral'>        if (amount0Owed &gt; 0) pay(decoded.poolKey.token0, decoded.payer, msg.sender, amount0Owed);</span>
 34 |     | <span class='neutral'>        if (amount1Owed &gt; 0) pay(decoded.poolKey.token1, decoded.payer, msg.sender, amount1Owed);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    struct AddLiquidityParams {</span>
 38 |     | <span class='neutral'>        address token0;</span>
 39 |     | <span class='neutral'>        address token1;</span>
 40 |     | <span class='neutral'>        uint24 fee;</span>
 41 |     | <span class='neutral'>        address recipient;</span>
 42 |     | <span class='neutral'>        int24 tickLower;</span>
 43 |     | <span class='neutral'>        int24 tickUpper;</span>
 44 |     | <span class='neutral'>        uint256 amount0Desired;</span>
 45 |     | <span class='neutral'>        uint256 amount1Desired;</span>
 46 |     | <span class='neutral'>        uint256 amount0Min;</span>
 47 |     | <span class='neutral'>        uint256 amount1Min;</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @notice Add liquidity to an initialized pool</span>
 51 |     | <span class='neutral'>    function addLiquidity(AddLiquidityParams memory params)</span>
 52 |     | <span class='neutral'>        internal</span>
 53 |     | <span class='neutral'>        returns (</span>
 54 |     | <span class='neutral'>            uint128 liquidity,</span>
 55 |     | <span class='neutral'>            uint256 amount0,</span>
 56 |     | <span class='neutral'>            uint256 amount1,</span>
 57 |     | <span class='neutral'>            IUniswapV3Pool pool</span>
 58 |     | <span class='neutral'>        )</span>
 59 |     | <span class='neutral'>    {</span>
 60 |     | <span class='neutral'>        PoolAddress.PoolKey memory poolKey = PoolAddress.PoolKey({</span>
 61 |     | <span class='neutral'>            token0: params.token0,</span>
 62 |     | <span class='neutral'>            token1: params.token1,</span>
 63 |     | <span class='neutral'>            fee: params.fee</span>
 64 |     | <span class='neutral'>        });</span>
 65 |     | <span class='neutral'></span>
 66 |     | <span class='neutral'>        pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));</span>
 67 |     | <span class='neutral'></span>
 68 |     | <span class='neutral'>        // compute the liquidity amount</span>
 69 |     | <span class='neutral'>        {</span>
 70 |     | <span class='neutral'>            (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();</span>
 71 |     | <span class='neutral'>            uint160 sqrtRatioAX96 = TickMath.getSqrtRatioAtTick(params.tickLower);</span>
 72 |     | <span class='neutral'>            uint160 sqrtRatioBX96 = TickMath.getSqrtRatioAtTick(params.tickUpper);</span>
 73 |     | <span class='neutral'></span>
 74 |     | <span class='neutral'>            liquidity = LiquidityAmounts.getLiquidityForAmounts(</span>
 75 |     | <span class='neutral'>                sqrtPriceX96,</span>
 76 |     | <span class='neutral'>                sqrtRatioAX96,</span>
 77 |     | <span class='neutral'>                sqrtRatioBX96,</span>
 78 |     | <span class='neutral'>                params.amount0Desired,</span>
 79 |     | <span class='neutral'>                params.amount1Desired</span>
 80 |     | <span class='neutral'>            );</span>
 81 |     | <span class='neutral'>        }</span>
 82 |     | <span class='neutral'></span>
 83 |     | <span class='neutral'>        (amount0, amount1) = pool.mint(</span>
 84 |     | <span class='neutral'>            params.recipient,</span>
 85 |     | <span class='neutral'>            params.tickLower,</span>
 86 |     | <span class='neutral'>            params.tickUpper,</span>
 87 |     | <span class='neutral'>            liquidity,</span>
 88 |     | <span class='neutral'>            abi.encode(MintCallbackData({poolKey: poolKey, payer: msg.sender}))</span>
 89 |     | <span class='neutral'>        );</span>
 90 |     | <span class='neutral'></span>
 91 |     | <span class='neutral'>        require(amount0 &gt;= params.amount0Min &amp;&amp; amount1 &gt;= params.amount1Min, &#39;Price slippage check&#39;);</span>
 92 |     | <span class='neutral'>    }</span>
 93 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/Multicall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;../interfaces/IMulticall.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Multicall</span>
  8 |     | <span class='neutral'>/// @notice Enables calling multiple methods in a single call to the contract</span>
  9 |     | <span class='neutral'>abstract contract Multicall is IMulticall {</span>
 10 |     | <span class='neutral'>    /// @inheritdoc IMulticall</span>
 11 |     | <span class='unexecuted'>    function multicall(bytes[] calldata data)</span>
 12 |     | <span class='neutral'>        public</span>
 13 |     | <span class='neutral'>        payable</span>
 14 |     | <span class='neutral'>        override</span>
 15 |     | <span class='unexecuted'>        returns (bytes[] memory results)</span>
 16 |     | <span class='neutral'>    {</span>
 17 |     | <span class='unexecuted'>        results = new bytes[](data.length);</span>
 18 |     | <span class='unexecuted'>        for (uint256 i = 0; i &lt; data.length; i++) {</span>
 19 |     | <span class='unexecuted'>            (bool success, bytes memory result) = address(this).delegatecall(data[i]);</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='unexecuted'>            if (!success) {</span>
 22 |     | <span class='neutral'>                // Next 5 lines from https://ethereum.stackexchange.com/a/83577</span>
 23 |     | <span class='unexecuted'>                if (result.length &lt; 68) revert();</span>
 24 |     | <span class='neutral'>                assembly {</span>
 25 |     | <span class='unexecuted'>                    result := add(result, 0x04)</span>
 26 |     | <span class='neutral'>                }</span>
 27 |     | <span class='unexecuted'>                revert(abi.decode(result, (string)));</span>
 28 |     | <span class='neutral'>            }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='unexecuted'>            results[i] = result;</span>
 31 |     | <span class='neutral'>        }</span>
 32 |     | <span class='neutral'>    }</span>
 33 |     | <span class='neutral'>}</span>
 34 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryImmutableState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;../interfaces/IPeripheryImmutableState.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Immutable state</span>
  7 |     | <span class='neutral'>/// @notice Immutable state used by periphery contracts</span>
  8 |     | <span class='neutral'>abstract contract PeripheryImmutableState is IPeripheryImmutableState {</span>
  9 |     | <span class='neutral'>    /// @inheritdoc IPeripheryImmutableState</span>
 10 |     | <span class='unexecuted'>    address public immutable override factory;</span>
 11 |     | <span class='neutral'>    /// @inheritdoc IPeripheryImmutableState</span>
 12 |     | <span class='unexecuted'>    address public immutable override WETH9;</span>
 13 |     | <span class='neutral'></span>
 14 |     | <span class='neutral'>    constructor(address _factory, address _WETH9) {</span>
 15 |     | <span class='unexecuted'>        factory = _factory;</span>
 16 |     | <span class='unexecuted'>        WETH9 = _WETH9;</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'>}</span>
 19 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryPayments.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>import &quot;../interfaces/IPeripheryPayments.sol&quot;;</span>
  7 |     | <span class='neutral'>import &quot;../interfaces/external/IWETH9.sol&quot;;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>import &quot;../libraries/TransferHelper.sol&quot;;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>import &quot;./PeripheryImmutableState.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>abstract contract PeripheryPayments is IPeripheryPayments, PeripheryImmutableState {</span>
 14 |     | <span class='neutral'>    receive() external payable {</span>
 15 |     | <span class='unexecuted'>        require(msg.sender == WETH9, &quot;Not WETH9&quot;);</span>
 16 |     | <span class='neutral'>    }</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @inheritdoc IPeripheryPayments</span>
 19 |     | <span class='unexecuted'>    function unwrapWETH9(uint256 amountMinimum, address recipient) public payable override {</span>
 20 |     | <span class='unexecuted'>        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));</span>
 21 |     | <span class='unexecuted'>        require(balanceWETH9 &gt;= amountMinimum, &quot;Insufficient WETH9&quot;);</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='unexecuted'>        if (balanceWETH9 &gt; 0) {</span>
 24 |     | <span class='unexecuted'>            IWETH9(WETH9).withdraw(balanceWETH9);</span>
 25 |     | <span class='unexecuted'>            TransferHelper.safeTransferETH(recipient, balanceWETH9);</span>
 26 |     | <span class='neutral'>        }</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @inheritdoc IPeripheryPayments</span>
 30 |     | <span class='unexecuted'>    function sweepToken(</span>
 31 |     | <span class='neutral'>        address token,</span>
 32 |     | <span class='neutral'>        uint256 amountMinimum,</span>
 33 |     | <span class='neutral'>        address recipient</span>
 34 |     | <span class='unexecuted'>    ) public payable override {</span>
 35 |     | <span class='unexecuted'>        uint256 balanceToken = IERC20(token).balanceOf(address(this));</span>
 36 |     | <span class='unexecuted'>        require(balanceToken &gt;= amountMinimum, &quot;Insufficient token&quot;);</span>
 37 |     | <span class='neutral'></span>
 38 |     | <span class='unexecuted'>        if (balanceToken &gt; 0) {</span>
 39 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token, recipient, balanceToken);</span>
 40 |     | <span class='neutral'>        }</span>
 41 |     | <span class='neutral'>    }</span>
 42 |     | <span class='neutral'></span>
 43 |     | <span class='neutral'>    /// @inheritdoc IPeripheryPayments</span>
 44 |     | <span class='unexecuted'>    function refundETH() external payable override {</span>
 45 |     | <span class='unexecuted'>        if (address(this).balance &gt; 0) {</span>
 46 |     | <span class='unexecuted'>            TransferHelper.safeTransferETH(msg.sender, address(this).balance);</span>
 47 |     | <span class='neutral'>        }</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'></span>
 50 |     | <span class='neutral'>    /// @param token The token to pay</span>
 51 |     | <span class='neutral'>    /// @param payer The entity that must pay</span>
 52 |     | <span class='neutral'>    /// @param recipient The entity that will receive payment</span>
 53 |     | <span class='neutral'>    /// @param value The amount to pay</span>
 54 |     | <span class='unexecuted'>    function pay(address token, address payer, address recipient, uint256 value) internal {</span>
 55 |     | <span class='unexecuted'>        if (token == WETH9 &amp;&amp; address(this).balance &gt;= value) {</span>
 56 |     | <span class='neutral'>            // pay with WETH9</span>
 57 |     | <span class='unexecuted'>            IWETH9(WETH9).deposit{value: value}(); // wrap only what is needed to pay</span>
 58 |     | <span class='unexecuted'>            IWETH9(WETH9).transfer(recipient, value);</span>
 59 |     | <span class='unexecuted'>        } else if (payer == address(this)) {</span>
 60 |     | <span class='neutral'>            // pay with tokens already in the contract (for the exact input multihop case)</span>
 61 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token, recipient, value);</span>
 62 |     | <span class='neutral'>        } else {</span>
 63 |     | <span class='neutral'>            // pull payment</span>
 64 |     | <span class='unexecuted'>            TransferHelper.safeTransferFrom(token, payer, recipient, value);</span>
 65 |     | <span class='neutral'>        }</span>
 66 |     | <span class='neutral'>    }</span>
 67 |     | <span class='neutral'>}</span>
 68 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryPaymentsWithFee.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC721/ERC721.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;../libraries/LowGasSafeMath.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;./PeripheryPayments.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../interfaces/IPeripheryPaymentsWithFee.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>import &quot;../interfaces/external/IWETH9.sol&quot;;</span>
 11 |     | <span class='neutral'>import &quot;../libraries/TransferHelper.sol&quot;;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>abstract contract PeripheryPaymentsWithFee is PeripheryPayments, IPeripheryPaymentsWithFee {</span>
 14 |     | <span class='neutral'>    using LowGasSafeMath for uint256;</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @inheritdoc IPeripheryPaymentsWithFee</span>
 17 |     | <span class='unexecuted'>    function unwrapWETH9WithFee(</span>
 18 |     | <span class='neutral'>        uint256 amountMinimum,</span>
 19 |     | <span class='neutral'>        address recipient,</span>
 20 |     | <span class='neutral'>        uint256 feeBips,</span>
 21 |     | <span class='neutral'>        address feeRecipient</span>
 22 |     | <span class='unexecuted'>    ) public payable override {</span>
 23 |     | <span class='unexecuted'>        require(feeBips &gt; 0 &amp;&amp; feeBips &lt;= 100);</span>
 24 |     | <span class='neutral'></span>
 25 |     | <span class='unexecuted'>        uint256 balanceWETH9 = IWETH9(WETH9).balanceOf(address(this));</span>
 26 |     | <span class='unexecuted'>        require(balanceWETH9 &gt;= amountMinimum, &quot;Insufficient WETH9&quot;);</span>
 27 |     | <span class='neutral'></span>
 28 |     | <span class='unexecuted'>        if (balanceWETH9 &gt; 0) {</span>
 29 |     | <span class='unexecuted'>            IWETH9(WETH9).withdraw(balanceWETH9);</span>
 30 |     | <span class='unexecuted'>            uint256 feeAmount = balanceWETH9.mul(feeBips) / 10_000;</span>
 31 |     | <span class='unexecuted'>            if (feeAmount &gt; 0) TransferHelper.safeTransferETH(feeRecipient, feeAmount);</span>
 32 |     | <span class='unexecuted'>            TransferHelper.safeTransferETH(recipient, balanceWETH9 - feeAmount);</span>
 33 |     | <span class='neutral'>        }</span>
 34 |     | <span class='neutral'>    }</span>
 35 |     | <span class='neutral'></span>
 36 |     | <span class='neutral'>    /// @inheritdoc IPeripheryPaymentsWithFee</span>
 37 |     | <span class='unexecuted'>    function sweepTokenWithFee(</span>
 38 |     | <span class='neutral'>        address token,</span>
 39 |     | <span class='neutral'>        uint256 amountMinimum,</span>
 40 |     | <span class='neutral'>        address recipient,</span>
 41 |     | <span class='neutral'>        uint256 feeBips,</span>
 42 |     | <span class='neutral'>        address feeRecipient</span>
 43 |     | <span class='unexecuted'>    ) public payable override {</span>
 44 |     | <span class='unexecuted'>        require(feeBips &gt; 0 &amp;&amp; feeBips &lt;= 100);</span>
 45 |     | <span class='neutral'></span>
 46 |     | <span class='unexecuted'>        uint256 balanceToken = IERC20(token).balanceOf(address(this));</span>
 47 |     | <span class='unexecuted'>        require(balanceToken &gt;= amountMinimum, &quot;Insufficient token&quot;);</span>
 48 |     | <span class='neutral'></span>
 49 |     | <span class='unexecuted'>        if (balanceToken &gt; 0) {</span>
 50 |     | <span class='unexecuted'>            uint256 feeAmount = balanceToken.mul(feeBips) / 10_000;</span>
 51 |     | <span class='unexecuted'>            if (feeAmount &gt; 0) TransferHelper.safeTransfer(token, feeRecipient, feeAmount);</span>
 52 |     | <span class='unexecuted'>            TransferHelper.safeTransfer(token, recipient, balanceToken - feeAmount);</span>
 53 |     | <span class='neutral'>        }</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'>}</span>
 56 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/PeripheryValidation.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./BlockTimestamp.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>abstract contract PeripheryValidation is BlockTimestamp {</span>
  7 |     | <span class='neutral'>    modifier checkDeadline(uint256 deadline) {</span>
  8 |     | <span class='unexecuted'>        require(_blockTimestamp() &lt;= deadline, &quot;Transaction too old&quot;);</span>
  9 |     | <span class='neutral'>        _;</span>
 10 |     | <span class='neutral'>    }</span>
 11 |     | <span class='neutral'>}</span>
 12 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/base/SelfPermit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>import &quot;../interfaces/ISelfPermit.sol&quot;;</span>
  8 |     | <span class='neutral'>import &quot;../interfaces/external/IERC20PermitAllowed.sol&quot;;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>/// @title Self Permit</span>
 11 |     | <span class='neutral'>/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route</span>
 12 |     | <span class='neutral'>/// @dev These functions are expected to be embedded in multicalls to allow EOAs to approve a contract and call a function</span>
 13 |     | <span class='neutral'>/// that requires an approval in a single transaction.</span>
 14 |     | <span class='neutral'>abstract contract SelfPermit is ISelfPermit {</span>
 15 |     | <span class='neutral'>    /// @inheritdoc ISelfPermit</span>
 16 |     | <span class='unexecuted'>    function selfPermit(</span>
 17 |     | <span class='neutral'>        address token,</span>
 18 |     | <span class='neutral'>        uint256 value,</span>
 19 |     | <span class='neutral'>        uint256 deadline,</span>
 20 |     | <span class='neutral'>        uint8 v,</span>
 21 |     | <span class='neutral'>        bytes32 r,</span>
 22 |     | <span class='neutral'>        bytes32 s</span>
 23 |     | <span class='neutral'>    ) public payable override {</span>
 24 |     | <span class='unexecuted'>        IERC20Permit(token).permit(msg.sender, address(this), value, deadline, v, r, s);</span>
 25 |     | <span class='neutral'>    }</span>
 26 |     | <span class='neutral'></span>
 27 |     | <span class='neutral'>    /// @inheritdoc ISelfPermit</span>
 28 |     | <span class='unexecuted'>    function selfPermitIfNecessary(</span>
 29 |     | <span class='neutral'>        address token,</span>
 30 |     | <span class='neutral'>        uint256 value,</span>
 31 |     | <span class='neutral'>        uint256 deadline,</span>
 32 |     | <span class='neutral'>        uint8 v,</span>
 33 |     | <span class='neutral'>        bytes32 r,</span>
 34 |     | <span class='neutral'>        bytes32 s</span>
 35 |     | <span class='neutral'>    ) external payable override {</span>
 36 |     | <span class='unexecuted'>        if (IERC20(token).allowance(msg.sender, address(this)) &lt; value) {</span>
 37 |     | <span class='unexecuted'>            selfPermit(token, value, deadline, v, r, s);</span>
 38 |     | <span class='neutral'>        }</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @inheritdoc ISelfPermit</span>
 42 |     | <span class='unexecuted'>    function selfPermitAllowed(</span>
 43 |     | <span class='neutral'>        address token,</span>
 44 |     | <span class='neutral'>        uint256 nonce,</span>
 45 |     | <span class='neutral'>        uint256 expiry,</span>
 46 |     | <span class='neutral'>        uint8 v,</span>
 47 |     | <span class='neutral'>        bytes32 r,</span>
 48 |     | <span class='neutral'>        bytes32 s</span>
 49 |     | <span class='neutral'>    ) public payable override {</span>
 50 |     | <span class='unexecuted'>        IERC20PermitAllowed(token).permit(msg.sender, address(this), nonce, expiry, true, v, r, s);</span>
 51 |     | <span class='neutral'>    }</span>
 52 |     | <span class='neutral'></span>
 53 |     | <span class='neutral'>    /// @inheritdoc ISelfPermit</span>
 54 |     | <span class='unexecuted'>    function selfPermitAllowedIfNecessary(</span>
 55 |     | <span class='neutral'>        address token,</span>
 56 |     | <span class='neutral'>        uint256 nonce,</span>
 57 |     | <span class='neutral'>        uint256 expiry,</span>
 58 |     | <span class='neutral'>        uint8 v,</span>
 59 |     | <span class='neutral'>        bytes32 r,</span>
 60 |     | <span class='neutral'>        bytes32 s</span>
 61 |     | <span class='neutral'>    ) external payable override {</span>
 62 |     | <span class='unexecuted'>        if (IERC20(token).allowance(msg.sender, address(this)) &lt; type(uint256).max) {</span>
 63 |     | <span class='unexecuted'>            selfPermitAllowed(token, nonce, expiry, v, r, s);</span>
 64 |     | <span class='neutral'>        }</span>
 65 |     | <span class='neutral'>    }</span>
 66 |     | <span class='neutral'>}</span>
 67 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IMulticall.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>/// @title Multicall interface</span>
  6 |     | <span class='neutral'>/// @notice Enables calling multiple methods in a single call to the contract</span>
  7 |     | <span class='neutral'>interface IMulticall {</span>
  8 |     | <span class='neutral'>    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed</span>
  9 |     | <span class='neutral'>    /// @dev The `msg.value` should not be trusted for any method callable from multicall.</span>
 10 |     | <span class='neutral'>    /// @param data The encoded function data for each of the calls to make to this contract</span>
 11 |     | <span class='neutral'>    /// @return results The results from each of the calls passed in via data</span>
 12 |     | <span class='neutral'>    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryImmutableState.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Immutable state</span>
  5 |     | <span class='neutral'>/// @notice Functions that return immutable state of the router</span>
  6 |     | <span class='neutral'>interface IPeripheryImmutableState {</span>
  7 |     | <span class='neutral'>    /// @return Returns the address of the Uniswap V3 factory</span>
  8 |     | <span class='neutral'>    function factory() external view returns (address);</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @return Returns the address of WETH9</span>
 11 |     | <span class='neutral'>    function WETH9() external view returns (address);</span>
 12 |     | <span class='neutral'>}</span>
 13 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryPayments.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Periphery Payments</span>
  5 |     | <span class='neutral'>/// @notice Functions to ease deposits and withdrawals of ETH</span>
  6 |     | <span class='neutral'>interface IPeripheryPayments {</span>
  7 |     | <span class='neutral'>    /// @notice Unwraps the contract&#39;s WETH9 balance and sends it to recipient as ETH.</span>
  8 |     | <span class='neutral'>    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.</span>
  9 |     | <span class='neutral'>    /// @param amountMinimum The minimum amount of WETH9 to unwrap</span>
 10 |     | <span class='neutral'>    /// @param recipient The address receiving ETH</span>
 11 |     | <span class='neutral'>    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;</span>
 12 |     | <span class='neutral'></span>
 13 |     | <span class='neutral'>    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`</span>
 14 |     | <span class='neutral'>    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps</span>
 15 |     | <span class='neutral'>    /// that use ether for the input amount</span>
 16 |     | <span class='neutral'>    function refundETH() external payable;</span>
 17 |     | <span class='neutral'></span>
 18 |     | <span class='neutral'>    /// @notice Transfers the full amount of a token held by this contract to recipient</span>
 19 |     | <span class='neutral'>    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users</span>
 20 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred to `recipient`</span>
 21 |     | <span class='neutral'>    /// @param amountMinimum The minimum amount of token required for a transfer</span>
 22 |     | <span class='neutral'>    /// @param recipient The destination address of the token</span>
 23 |     | <span class='neutral'>    function sweepToken(address token, uint256 amountMinimum, address recipient) external payable;</span>
 24 |     | <span class='neutral'>}</span>
 25 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/IPeripheryPaymentsWithFee.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./IPeripheryPayments.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Periphery Payments</span>
  7 |     | <span class='neutral'>/// @notice Functions to ease deposits and withdrawals of ETH</span>
  8 |     | <span class='neutral'>interface IPeripheryPaymentsWithFee is IPeripheryPayments {</span>
  9 |     | <span class='neutral'>    /// @notice Unwraps the contract&#39;s WETH9 balance and sends it to recipient as ETH, with a percentage between</span>
 10 |     | <span class='neutral'>    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient</span>
 11 |     | <span class='neutral'>    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.</span>
 12 |     | <span class='neutral'>    function unwrapWETH9WithFee(</span>
 13 |     | <span class='neutral'>        uint256 amountMinimum,</span>
 14 |     | <span class='neutral'>        address recipient,</span>
 15 |     | <span class='neutral'>        uint256 feeBips,</span>
 16 |     | <span class='neutral'>        address feeRecipient</span>
 17 |     | <span class='neutral'>    ) external payable;</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between</span>
 20 |     | <span class='neutral'>    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient</span>
 21 |     | <span class='neutral'>    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users</span>
 22 |     | <span class='neutral'>    function sweepTokenWithFee(</span>
 23 |     | <span class='neutral'>        address token,</span>
 24 |     | <span class='neutral'>        uint256 amountMinimum,</span>
 25 |     | <span class='neutral'>        address recipient,</span>
 26 |     | <span class='neutral'>        uint256 feeBips,</span>
 27 |     | <span class='neutral'>        address feeRecipient</span>
 28 |     | <span class='neutral'>    ) external payable;</span>
 29 |     | <span class='neutral'>}</span>
 30 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/ISelfPermit.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Self Permit</span>
  5 |     | <span class='neutral'>/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route</span>
  6 |     | <span class='neutral'>interface ISelfPermit {</span>
  7 |     | <span class='neutral'>    /// @notice Permits this contract to spend a given token from `msg.sender`</span>
  8 |     | <span class='neutral'>    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).</span>
  9 |     | <span class='neutral'>    /// @param token The address of the token spent</span>
 10 |     | <span class='neutral'>    /// @param value The amount that can be spent of token</span>
 11 |     | <span class='neutral'>    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp</span>
 12 |     | <span class='neutral'>    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`</span>
 13 |     | <span class='neutral'>    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`</span>
 14 |     | <span class='neutral'>    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`</span>
 15 |     | <span class='neutral'>    function selfPermit(</span>
 16 |     | <span class='neutral'>        address token,</span>
 17 |     | <span class='neutral'>        uint256 value,</span>
 18 |     | <span class='neutral'>        uint256 deadline,</span>
 19 |     | <span class='neutral'>        uint8 v,</span>
 20 |     | <span class='neutral'>        bytes32 r,</span>
 21 |     | <span class='neutral'>        bytes32 s</span>
 22 |     | <span class='neutral'>    ) external payable;</span>
 23 |     | <span class='neutral'></span>
 24 |     | <span class='neutral'>    /// @notice Permits this contract to spend a given token from `msg.sender`</span>
 25 |     | <span class='neutral'>    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).</span>
 26 |     | <span class='neutral'>    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit</span>
 27 |     | <span class='neutral'>    /// @param token The address of the token spent</span>
 28 |     | <span class='neutral'>    /// @param value The amount that can be spent of token</span>
 29 |     | <span class='neutral'>    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp</span>
 30 |     | <span class='neutral'>    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`</span>
 31 |     | <span class='neutral'>    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`</span>
 32 |     | <span class='neutral'>    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`</span>
 33 |     | <span class='neutral'>    function selfPermitIfNecessary(</span>
 34 |     | <span class='neutral'>        address token,</span>
 35 |     | <span class='neutral'>        uint256 value,</span>
 36 |     | <span class='neutral'>        uint256 deadline,</span>
 37 |     | <span class='neutral'>        uint8 v,</span>
 38 |     | <span class='neutral'>        bytes32 r,</span>
 39 |     | <span class='neutral'>        bytes32 s</span>
 40 |     | <span class='neutral'>    ) external payable;</span>
 41 |     | <span class='neutral'></span>
 42 |     | <span class='neutral'>    /// @notice Permits this contract to spend the sender&#39;s tokens for permit signatures that have the `allowed` parameter</span>
 43 |     | <span class='neutral'>    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)</span>
 44 |     | <span class='neutral'>    /// @param token The address of the token spent</span>
 45 |     | <span class='neutral'>    /// @param nonce The current nonce of the owner</span>
 46 |     | <span class='neutral'>    /// @param expiry The timestamp at which the permit is no longer valid</span>
 47 |     | <span class='neutral'>    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`</span>
 48 |     | <span class='neutral'>    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`</span>
 49 |     | <span class='neutral'>    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`</span>
 50 |     | <span class='neutral'>    function selfPermitAllowed(</span>
 51 |     | <span class='neutral'>        address token,</span>
 52 |     | <span class='neutral'>        uint256 nonce,</span>
 53 |     | <span class='neutral'>        uint256 expiry,</span>
 54 |     | <span class='neutral'>        uint8 v,</span>
 55 |     | <span class='neutral'>        bytes32 r,</span>
 56 |     | <span class='neutral'>        bytes32 s</span>
 57 |     | <span class='neutral'>    ) external payable;</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Permits this contract to spend the sender&#39;s tokens for permit signatures that have the `allowed` parameter</span>
 60 |     | <span class='neutral'>    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)</span>
 61 |     | <span class='neutral'>    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.</span>
 62 |     | <span class='neutral'>    /// @param token The address of the token spent</span>
 63 |     | <span class='neutral'>    /// @param nonce The current nonce of the owner</span>
 64 |     | <span class='neutral'>    /// @param expiry The timestamp at which the permit is no longer valid</span>
 65 |     | <span class='neutral'>    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`</span>
 66 |     | <span class='neutral'>    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`</span>
 67 |     | <span class='neutral'>    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`</span>
 68 |     | <span class='neutral'>    function selfPermitAllowedIfNecessary(</span>
 69 |     | <span class='neutral'>        address token,</span>
 70 |     | <span class='neutral'>        uint256 nonce,</span>
 71 |     | <span class='neutral'>        uint256 expiry,</span>
 72 |     | <span class='neutral'>        uint8 v,</span>
 73 |     | <span class='neutral'>        bytes32 r,</span>
 74 |     | <span class='neutral'>        bytes32 s</span>
 75 |     | <span class='neutral'>    ) external payable;</span>
 76 |     | <span class='neutral'>}</span>
 77 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/ISwapRouter.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'>pragma abicoder v2;</span>
  4 |     | <span class='neutral'></span>
  5 |     | <span class='neutral'>import &quot;@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol&quot;;</span>
  6 |     | <span class='neutral'></span>
  7 |     | <span class='neutral'>/// @title Router token swapping functionality</span>
  8 |     | <span class='neutral'>/// @notice Functions for swapping tokens via Uniswap V3</span>
  9 |     | <span class='neutral'>interface ISwapRouter is IUniswapV3SwapCallback {</span>
 10 |     | <span class='neutral'>    struct ExactInputSingleParams {</span>
 11 |     | <span class='neutral'>        address tokenIn;</span>
 12 |     | <span class='neutral'>        address tokenOut;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>        address recipient;</span>
 15 |     | <span class='neutral'>        uint256 deadline;</span>
 16 |     | <span class='neutral'>        uint256 amountIn;</span>
 17 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 18 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 19 |     | <span class='neutral'>    }</span>
 20 |     | <span class='neutral'></span>
 21 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another token</span>
 22 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata</span>
 23 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 24 |     | <span class='neutral'>    function exactInputSingle(ExactInputSingleParams calldata params)</span>
 25 |     | <span class='neutral'>        external</span>
 26 |     | <span class='neutral'>        payable</span>
 27 |     | <span class='neutral'>        returns (uint256 amountOut);</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    struct ExactInputParams {</span>
 30 |     | <span class='neutral'>        bytes path;</span>
 31 |     | <span class='neutral'>        address recipient;</span>
 32 |     | <span class='neutral'>        uint256 deadline;</span>
 33 |     | <span class='neutral'>        uint256 amountIn;</span>
 34 |     | <span class='neutral'>        uint256 amountOutMinimum;</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path</span>
 38 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata</span>
 39 |     | <span class='neutral'>    /// @return amountOut The amount of the received token</span>
 40 |     | <span class='neutral'>    function exactInput(ExactInputParams calldata params)</span>
 41 |     | <span class='neutral'>        external</span>
 42 |     | <span class='neutral'>        payable</span>
 43 |     | <span class='neutral'>        returns (uint256 amountOut);</span>
 44 |     | <span class='neutral'></span>
 45 |     | <span class='neutral'>    struct ExactOutputSingleParams {</span>
 46 |     | <span class='neutral'>        address tokenIn;</span>
 47 |     | <span class='neutral'>        address tokenOut;</span>
 48 |     | <span class='neutral'>        uint24 fee;</span>
 49 |     | <span class='neutral'>        address recipient;</span>
 50 |     | <span class='neutral'>        uint256 deadline;</span>
 51 |     | <span class='neutral'>        uint256 amountOut;</span>
 52 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 53 |     | <span class='neutral'>        uint160 sqrtPriceLimitX96;</span>
 54 |     | <span class='neutral'>    }</span>
 55 |     | <span class='neutral'></span>
 56 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another token</span>
 57 |     | <span class='neutral'>    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata</span>
 58 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 59 |     | <span class='neutral'>    function exactOutputSingle(ExactOutputSingleParams calldata params)</span>
 60 |     | <span class='neutral'>        external</span>
 61 |     | <span class='neutral'>        payable</span>
 62 |     | <span class='neutral'>        returns (uint256 amountIn);</span>
 63 |     | <span class='neutral'></span>
 64 |     | <span class='neutral'>    struct ExactOutputParams {</span>
 65 |     | <span class='neutral'>        bytes path;</span>
 66 |     | <span class='neutral'>        address recipient;</span>
 67 |     | <span class='neutral'>        uint256 deadline;</span>
 68 |     | <span class='neutral'>        uint256 amountOut;</span>
 69 |     | <span class='neutral'>        uint256 amountInMaximum;</span>
 70 |     | <span class='neutral'>    }</span>
 71 |     | <span class='neutral'></span>
 72 |     | <span class='neutral'>    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)</span>
 73 |     | <span class='neutral'>    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata</span>
 74 |     | <span class='neutral'>    /// @return amountIn The amount of the input token</span>
 75 |     | <span class='neutral'>    function exactOutput(ExactOutputParams calldata params)</span>
 76 |     | <span class='neutral'>        external</span>
 77 |     | <span class='neutral'>        payable</span>
 78 |     | <span class='neutral'>        returns (uint256 amountIn);</span>
 79 |     | <span class='neutral'>}</span>
 80 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/external/IERC20PermitAllowed.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Interface for permit</span>
  5 |     | <span class='neutral'>/// @notice Interface used by DAI/CHAI for permit</span>
  6 |     | <span class='neutral'>interface IERC20PermitAllowed {</span>
  7 |     | <span class='neutral'>    /// @notice Approve the spender to spend some tokens via the holder signature</span>
  8 |     | <span class='neutral'>    /// @dev This is the permit interface used by DAI and CHAI</span>
  9 |     | <span class='neutral'>    /// @param holder The address of the token holder, the token owner</span>
 10 |     | <span class='neutral'>    /// @param spender The address of the token spender</span>
 11 |     | <span class='neutral'>    /// @param nonce The holder&#39;s nonce, increases at each call to permit</span>
 12 |     | <span class='neutral'>    /// @param expiry The timestamp at which the permit is no longer valid</span>
 13 |     | <span class='neutral'>    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0</span>
 14 |     | <span class='neutral'>    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`</span>
 15 |     | <span class='neutral'>    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`</span>
 16 |     | <span class='neutral'>    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`</span>
 17 |     | <span class='neutral'>    function permit(</span>
 18 |     | <span class='neutral'>        address holder,</span>
 19 |     | <span class='neutral'>        address spender,</span>
 20 |     | <span class='neutral'>        uint256 nonce,</span>
 21 |     | <span class='neutral'>        uint256 expiry,</span>
 22 |     | <span class='neutral'>        bool allowed,</span>
 23 |     | <span class='neutral'>        uint8 v,</span>
 24 |     | <span class='neutral'>        bytes32 r,</span>
 25 |     | <span class='neutral'>        bytes32 s</span>
 26 |     | <span class='neutral'>    ) external;</span>
 27 |     | <span class='neutral'>}</span>
 28 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/interfaces/external/IWETH9.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Interface for WETH9</span>
  7 |     | <span class='neutral'>interface IWETH9 is IERC20 {</span>
  8 |     | <span class='neutral'>    /// @notice Deposit ether to get wrapped ether</span>
  9 |     | <span class='neutral'>    function deposit() external payable;</span>
 10 |     | <span class='neutral'></span>
 11 |     | <span class='neutral'>    /// @notice Withdraw wrapped ether to get ether</span>
 12 |     | <span class='neutral'>    function withdraw(uint256) external;</span>
 13 |     | <span class='neutral'>}</span>
 14 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/BytesLib.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>/*</span>
   3 |     | <span class='neutral'> * @title Solidity Bytes Arrays Utils</span>
   4 |     | <span class='neutral'> * @author Gonalo S &lt;goncalo.sa@consensys.net&gt;</span>
   5 |     | <span class='neutral'> *</span>
   6 |     | <span class='neutral'> * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.</span>
   7 |     | <span class='neutral'> *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.</span>
   8 |     | <span class='neutral'> */</span>
   9 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  10 |     | <span class='neutral'></span>
  11 |     | <span class='unexecuted'>library BytesLib {</span>
  12 |     | <span class='unexecuted'>    function slice(</span>
  13 |     | <span class='neutral'>        bytes memory _bytes,</span>
  14 |     | <span class='neutral'>        uint256 _start,</span>
  15 |     | <span class='neutral'>        uint256 _length</span>
  16 |     | <span class='unexecuted'>    ) internal pure returns (bytes memory) {</span>
  17 |     | <span class='unexecuted'>        require(_length + 31 &gt;= _length, &quot;slice_overflow&quot;);</span>
  18 |     | <span class='unexecuted'>        require(_start + _length &gt;= _start, &quot;slice_overflow&quot;);</span>
  19 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + _length, &quot;slice_outOfBounds&quot;);</span>
  20 |     | <span class='neutral'></span>
  21 |     | <span class='unexecuted'>        bytes memory tempBytes;</span>
  22 |     | <span class='neutral'></span>
  23 |     | <span class='neutral'>        assembly {</span>
  24 |     | <span class='unexecuted'>            switch iszero(_length)</span>
  25 |     | <span class='unexecuted'>            case 0 {</span>
  26 |     | <span class='neutral'>                // Get a location of some free memory and store it in tempBytes as</span>
  27 |     | <span class='neutral'>                // Solidity does for memory variables.</span>
  28 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
  29 |     | <span class='neutral'></span>
  30 |     | <span class='neutral'>                // The first word of the slice result is potentially a partial</span>
  31 |     | <span class='neutral'>                // word read from the original array. To read it, we calculate</span>
  32 |     | <span class='neutral'>                // the length of that partial word and start copying that many</span>
  33 |     | <span class='neutral'>                // bytes into the array. The first word we copy will start with</span>
  34 |     | <span class='neutral'>                // data we don&#39;t care about, but the last `lengthmod` bytes will</span>
  35 |     | <span class='neutral'>                // land at the beginning of the contents of the new array. When</span>
  36 |     | <span class='neutral'>                // we&#39;re done copying, we overwrite the full first word with</span>
  37 |     | <span class='neutral'>                // the actual length of the slice.</span>
  38 |     | <span class='unexecuted'>                let lengthmod := and(_length, 31)</span>
  39 |     | <span class='neutral'></span>
  40 |     | <span class='neutral'>                // The multiplication in the next line is necessary</span>
  41 |     | <span class='neutral'>                // because when slicing multiples of 32 bytes (lengthmod == 0)</span>
  42 |     | <span class='neutral'>                // the following copy loop was copying the origin&#39;s length</span>
  43 |     | <span class='neutral'>                // and then ending prematurely not copying everything it should.</span>
  44 |     | <span class='unexecuted'>                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))</span>
  45 |     | <span class='unexecuted'>                let end := add(mc, _length)</span>
  46 |     | <span class='neutral'></span>
  47 |     | <span class='unexecuted'>                for {</span>
  48 |     | <span class='neutral'>                    // The multiplication in the next line has the same exact purpose</span>
  49 |     | <span class='neutral'>                    // as the one above.</span>
  50 |     | <span class='unexecuted'>                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)</span>
  51 |     | <span class='unexecuted'>                } lt(mc, end) {</span>
  52 |     | <span class='unexecuted'>                    mc := add(mc, 0x20)</span>
  53 |     | <span class='unexecuted'>                    cc := add(cc, 0x20)</span>
  54 |     | <span class='unexecuted'>                } { mstore(mc, mload(cc)) }</span>
  55 |     | <span class='neutral'></span>
  56 |     | <span class='unexecuted'>                mstore(tempBytes, _length)</span>
  57 |     | <span class='neutral'></span>
  58 |     | <span class='neutral'>                //update free-memory pointer</span>
  59 |     | <span class='neutral'>                //allocating the array padded to 32 bytes like the compiler does now</span>
  60 |     | <span class='unexecuted'>                mstore(0x40, and(add(mc, 31), not(31)))</span>
  61 |     | <span class='neutral'>            }</span>
  62 |     | <span class='neutral'>            //if we want a zero-length slice let&#39;s just return a zero-length array</span>
  63 |     | <span class='neutral'>            default {</span>
  64 |     | <span class='unexecuted'>                tempBytes := mload(0x40)</span>
  65 |     | <span class='neutral'>                //zero out the 32 bytes slice we are about to return</span>
  66 |     | <span class='neutral'>                //we need to do it because Solidity does not garbage collect</span>
  67 |     | <span class='unexecuted'>                mstore(tempBytes, 0)</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='unexecuted'>                mstore(0x40, add(tempBytes, 0x20))</span>
  70 |     | <span class='neutral'>            }</span>
  71 |     | <span class='neutral'>        }</span>
  72 |     | <span class='neutral'></span>
  73 |     | <span class='unexecuted'>        return tempBytes;</span>
  74 |     | <span class='neutral'>    }</span>
  75 |     | <span class='neutral'></span>
  76 |     | <span class='unexecuted'>    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {</span>
  77 |     | <span class='unexecuted'>        require(_start + 20 &gt;= _start, &quot;toAddress_overflow&quot;);</span>
  78 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 20, &quot;toAddress_outOfBounds&quot;);</span>
  79 |     | <span class='neutral'>        address tempAddress;</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>        assembly {</span>
  82 |     | <span class='unexecuted'>            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)</span>
  83 |     | <span class='neutral'>        }</span>
  84 |     | <span class='neutral'></span>
  85 |     | <span class='neutral'>        return tempAddress;</span>
  86 |     | <span class='neutral'>    }</span>
  87 |     | <span class='neutral'></span>
  88 |     | <span class='unexecuted'>    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {</span>
  89 |     | <span class='unexecuted'>        require(_start + 3 &gt;= _start, &quot;toUint24_overflow&quot;);</span>
  90 |     | <span class='unexecuted'>        require(_bytes.length &gt;= _start + 3, &quot;toUint24_outOfBounds&quot;);</span>
  91 |     | <span class='neutral'>        uint24 tempUint;</span>
  92 |     | <span class='neutral'></span>
  93 |     | <span class='neutral'>        assembly {</span>
  94 |     | <span class='unexecuted'>            tempUint := mload(add(add(_bytes, 0x3), _start))</span>
  95 |     | <span class='neutral'>        }</span>
  96 |     | <span class='neutral'></span>
  97 |     | <span class='neutral'>        return tempUint;</span>
  98 |     | <span class='neutral'>    }</span>
  99 |     | <span class='neutral'>}</span>
 100 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/CallbackValidation.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;v3-core/interfaces/IUniswapV3Pool.sol&quot;;</span>
  5 |     | <span class='neutral'>import &quot;v3-core/interfaces/IUniswapV3Factory.sol&quot;;</span>
  6 |     | <span class='neutral'>import &quot;./PoolAddress.sol&quot;;</span>
  7 |     | <span class='neutral'></span>
  8 |     | <span class='neutral'>/// @notice Provides validation for callbacks from Uniswap V3 Pools</span>
  9 |     | <span class='unexecuted'>library CallbackValidation {</span>
 10 |     | <span class='neutral'>    /// @notice Returns the address of a valid Uniswap V3 Pool</span>
 11 |     | <span class='neutral'>    /// @param factory The contract address of the Uniswap V3 factory</span>
 12 |     | <span class='neutral'>    /// @param tokenA The contract address of either token0 or token1</span>
 13 |     | <span class='neutral'>    /// @param tokenB The contract address of the other token</span>
 14 |     | <span class='neutral'>    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip</span>
 15 |     | <span class='neutral'>    /// @return pool The V3 pool contract address</span>
 16 |     | <span class='unexecuted'>    function verifyCallback(</span>
 17 |     | <span class='neutral'>        address factory,</span>
 18 |     | <span class='neutral'>        address tokenA,</span>
 19 |     | <span class='neutral'>        address tokenB,</span>
 20 |     | <span class='neutral'>        uint24 fee</span>
 21 |     | <span class='unexecuted'>    ) internal view returns (IUniswapV3Pool pool) {</span>
 22 |     | <span class='unexecuted'>        pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(tokenA, tokenB, fee));</span>
 23 |     | <span class='unexecuted'>        require(msg.sender == address(pool));</span>
 24 |     | <span class='neutral'>    }</span>
 25 |     | <span class='neutral'></span>
 26 |     | <span class='neutral'>    /// @notice Returns the address of a valid Uniswap V3 Pool</span>
 27 |     | <span class='neutral'>    /// @param factory The contract address of the Uniswap V3 factory</span>
 28 |     | <span class='neutral'>    /// @param poolKey The identifying key of the V3 pool</span>
 29 |     | <span class='neutral'>    /// @return pool The V3 pool contract address</span>
 30 |     | <span class='neutral'>    function verifyCallback(</span>
 31 |     | <span class='neutral'>        address factory,</span>
 32 |     | <span class='neutral'>        PoolAddress.PoolKey memory poolKey</span>
 33 |     | <span class='neutral'>    ) internal view returns (IUniswapV3Pool pool) {</span>
 34 |     | <span class='neutral'>        pool = IUniswapV3Pool(IUniswapV3Factory(factory).getPool(poolKey.token0, poolKey.token1, poolKey.fee));</span>
 35 |     | <span class='neutral'>        require(msg.sender == address(pool));</span>
 36 |     | <span class='neutral'>    }</span>
 37 |     | <span class='neutral'>}</span>
 38 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/LiquidityAmounts.sol</b>
<code>
   1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
   2 |     | <span class='neutral'>pragma solidity &gt;=0.8.0;</span>
   3 |     | <span class='neutral'></span>
   4 |     | <span class='neutral'>import &#39;v3-core/libraries/FullMath.sol&#39;;</span>
   5 |     | <span class='neutral'>import &#39;v3-core/libraries/FixedPoint96.sol&#39;;</span>
   6 |     | <span class='neutral'></span>
   7 |     | <span class='neutral'>/// @title Liquidity amount functions</span>
   8 |     | <span class='neutral'>/// @notice Provides functions for computing liquidity amounts from token amounts and prices</span>
   9 |     | <span class='unexecuted'>library LiquidityAmounts {</span>
  10 |     | <span class='neutral'>    /// @notice Downcasts uint256 to uint128</span>
  11 |     | <span class='neutral'>    /// @param x The uint258 to be downcasted</span>
  12 |     | <span class='neutral'>    /// @return y The passed value, downcasted to uint128</span>
  13 |     | <span class='neutral'>    function toUint128(uint256 x) private pure returns (uint128 y) {</span>
  14 |     | <span class='neutral'>        require((y = uint128(x)) == x);</span>
  15 |     | <span class='neutral'>    }</span>
  16 |     | <span class='neutral'></span>
  17 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range</span>
  18 |     | <span class='neutral'>    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower))</span>
  19 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  20 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  21 |     | <span class='neutral'>    /// @param amount0 The amount0 being sent in</span>
  22 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  23 |     | <span class='neutral'>    function getLiquidityForAmount0(</span>
  24 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  25 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  26 |     | <span class='neutral'>        uint256 amount0</span>
  27 |     | <span class='neutral'>    ) internal pure returns (uint128 liquidity) {</span>
  28 |     | <span class='neutral'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  29 |     | <span class='neutral'>        uint256 intermediate = FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);</span>
  30 |     | <span class='neutral'>        unchecked {</span>
  31 |     | <span class='neutral'>            return toUint128(FullMath.mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));</span>
  32 |     | <span class='neutral'>        }</span>
  33 |     | <span class='neutral'>    }</span>
  34 |     | <span class='neutral'></span>
  35 |     | <span class='neutral'>    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range</span>
  36 |     | <span class='neutral'>    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).</span>
  37 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  38 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  39 |     | <span class='neutral'>    /// @param amount1 The amount1 being sent in</span>
  40 |     | <span class='neutral'>    /// @return liquidity The amount of returned liquidity</span>
  41 |     | <span class='neutral'>    function getLiquidityForAmount1(</span>
  42 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  43 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  44 |     | <span class='neutral'>        uint256 amount1</span>
  45 |     | <span class='neutral'>    ) internal pure returns (uint128 liquidity) {</span>
  46 |     | <span class='neutral'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  47 |     | <span class='neutral'>        unchecked {</span>
  48 |     | <span class='neutral'>            return toUint128(FullMath.mulDiv(amount1, FixedPoint96.Q96, sqrtRatioBX96 - sqrtRatioAX96));</span>
  49 |     | <span class='neutral'>        }</span>
  50 |     | <span class='neutral'>    }</span>
  51 |     | <span class='neutral'></span>
  52 |     | <span class='neutral'>    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current</span>
  53 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
  54 |     | <span class='neutral'>    /// @param sqrtRatioX96 A sqrt price representing the current pool prices</span>
  55 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  56 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  57 |     | <span class='neutral'>    /// @param amount0 The amount of token0 being sent in</span>
  58 |     | <span class='neutral'>    /// @param amount1 The amount of token1 being sent in</span>
  59 |     | <span class='neutral'>    /// @return liquidity The maximum amount of liquidity received</span>
  60 |     | <span class='neutral'>    function getLiquidityForAmounts(</span>
  61 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
  62 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  63 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  64 |     | <span class='neutral'>        uint256 amount0,</span>
  65 |     | <span class='neutral'>        uint256 amount1</span>
  66 |     | <span class='neutral'>    ) internal pure returns (uint128 liquidity) {</span>
  67 |     | <span class='neutral'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  68 |     | <span class='neutral'></span>
  69 |     | <span class='neutral'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
  70 |     | <span class='neutral'>            liquidity = getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);</span>
  71 |     | <span class='neutral'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
  72 |     | <span class='neutral'>            uint128 liquidity0 = getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);</span>
  73 |     | <span class='neutral'>            uint128 liquidity1 = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);</span>
  74 |     | <span class='neutral'></span>
  75 |     | <span class='neutral'>            liquidity = liquidity0 &lt; liquidity1 ? liquidity0 : liquidity1;</span>
  76 |     | <span class='neutral'>        } else {</span>
  77 |     | <span class='neutral'>            liquidity = getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);</span>
  78 |     | <span class='neutral'>        }</span>
  79 |     | <span class='neutral'>    }</span>
  80 |     | <span class='neutral'></span>
  81 |     | <span class='neutral'>    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range</span>
  82 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
  83 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
  84 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
  85 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
  86 |     | <span class='neutral'>    function getAmount0ForLiquidity(</span>
  87 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
  88 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
  89 |     | <span class='neutral'>        uint128 liquidity</span>
  90 |     | <span class='neutral'>    ) internal pure returns (uint256 amount0) {</span>
  91 |     | <span class='neutral'>        unchecked {</span>
  92 |     | <span class='neutral'>            if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
  93 |     | <span class='neutral'></span>
  94 |     | <span class='neutral'>            return</span>
  95 |     | <span class='neutral'>                FullMath.mulDiv(</span>
  96 |     | <span class='neutral'>                    uint256(liquidity) &lt;&lt; FixedPoint96.RESOLUTION,</span>
  97 |     | <span class='neutral'>                    sqrtRatioBX96 - sqrtRatioAX96,</span>
  98 |     | <span class='neutral'>                    sqrtRatioBX96</span>
  99 |     | <span class='neutral'>                ) / sqrtRatioAX96;</span>
 100 |     | <span class='neutral'>        }</span>
 101 |     | <span class='neutral'>    }</span>
 102 |     | <span class='neutral'></span>
 103 |     | <span class='neutral'>    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range</span>
 104 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
 105 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
 106 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 107 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
 108 |     | <span class='neutral'>    function getAmount1ForLiquidity(</span>
 109 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 110 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 111 |     | <span class='neutral'>        uint128 liquidity</span>
 112 |     | <span class='neutral'>    ) internal pure returns (uint256 amount1) {</span>
 113 |     | <span class='neutral'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 114 |     | <span class='neutral'></span>
 115 |     | <span class='neutral'>        unchecked {</span>
 116 |     | <span class='neutral'>            return FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);</span>
 117 |     | <span class='neutral'>        }</span>
 118 |     | <span class='neutral'>    }</span>
 119 |     | <span class='neutral'></span>
 120 |     | <span class='neutral'>    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current</span>
 121 |     | <span class='neutral'>    /// pool prices and the prices at the tick boundaries</span>
 122 |     | <span class='neutral'>    /// @param sqrtRatioX96 A sqrt price representing the current pool prices</span>
 123 |     | <span class='neutral'>    /// @param sqrtRatioAX96 A sqrt price representing the first tick boundary</span>
 124 |     | <span class='neutral'>    /// @param sqrtRatioBX96 A sqrt price representing the second tick boundary</span>
 125 |     | <span class='neutral'>    /// @param liquidity The liquidity being valued</span>
 126 |     | <span class='neutral'>    /// @return amount0 The amount of token0</span>
 127 |     | <span class='neutral'>    /// @return amount1 The amount of token1</span>
 128 |     | <span class='neutral'>    function getAmountsForLiquidity(</span>
 129 |     | <span class='neutral'>        uint160 sqrtRatioX96,</span>
 130 |     | <span class='neutral'>        uint160 sqrtRatioAX96,</span>
 131 |     | <span class='neutral'>        uint160 sqrtRatioBX96,</span>
 132 |     | <span class='neutral'>        uint128 liquidity</span>
 133 |     | <span class='neutral'>    ) internal pure returns (uint256 amount0, uint256 amount1) {</span>
 134 |     | <span class='neutral'>        if (sqrtRatioAX96 &gt; sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);</span>
 135 |     | <span class='neutral'></span>
 136 |     | <span class='neutral'>        if (sqrtRatioX96 &lt;= sqrtRatioAX96) {</span>
 137 |     | <span class='neutral'>            amount0 = getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);</span>
 138 |     | <span class='neutral'>        } else if (sqrtRatioX96 &lt; sqrtRatioBX96) {</span>
 139 |     | <span class='neutral'>            amount0 = getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);</span>
 140 |     | <span class='neutral'>            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);</span>
 141 |     | <span class='neutral'>        } else {</span>
 142 |     | <span class='neutral'>            amount1 = getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);</span>
 143 |     | <span class='neutral'>        }</span>
 144 |     | <span class='neutral'>    }</span>
 145 |     | <span class='neutral'>}</span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/LowGasSafeMath.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Optimized overflow and underflow safe math operations</span>
  5 |     | <span class='neutral'>/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost</span>
  6 |     | <span class='unexecuted'>library LowGasSafeMath {</span>
  7 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if sum overflows uint256</span>
  8 |     | <span class='neutral'>    /// @param x The augend</span>
  9 |     | <span class='neutral'>    /// @param y The addend</span>
 10 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 11 |     | <span class='neutral'>    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 12 |     | <span class='neutral'>        require((z = x + y) &gt;= x);</span>
 13 |     | <span class='neutral'>    }</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if underflows</span>
 16 |     | <span class='neutral'>    /// @param x The minuend</span>
 17 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 18 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 19 |     | <span class='neutral'>    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 20 |     | <span class='neutral'>        require((z = x - y) &lt;= x);</span>
 21 |     | <span class='neutral'>    }</span>
 22 |     | <span class='neutral'></span>
 23 |     | <span class='neutral'>    /// @notice Returns x * y, reverts if overflows</span>
 24 |     | <span class='neutral'>    /// @param x The multiplicand</span>
 25 |     | <span class='neutral'>    /// @param y The multiplier</span>
 26 |     | <span class='neutral'>    /// @return z The product of x and y</span>
 27 |     | <span class='unexecuted'>    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {</span>
 28 |     | <span class='unexecuted'>        require(x == 0 || (z = x * y) / x == y);</span>
 29 |     | <span class='neutral'>    }</span>
 30 |     | <span class='neutral'></span>
 31 |     | <span class='neutral'>    /// @notice Returns x + y, reverts if overflows or underflows</span>
 32 |     | <span class='neutral'>    /// @param x The augend</span>
 33 |     | <span class='neutral'>    /// @param y The addend</span>
 34 |     | <span class='neutral'>    /// @return z The sum of x and y</span>
 35 |     | <span class='neutral'>    function add(int256 x, int256 y) internal pure returns (int256 z) {</span>
 36 |     | <span class='neutral'>        require((z = x + y) &gt;= x == (y &gt;= 0));</span>
 37 |     | <span class='neutral'>    }</span>
 38 |     | <span class='neutral'></span>
 39 |     | <span class='neutral'>    /// @notice Returns x - y, reverts if overflows or underflows</span>
 40 |     | <span class='neutral'>    /// @param x The minuend</span>
 41 |     | <span class='neutral'>    /// @param y The subtrahend</span>
 42 |     | <span class='neutral'>    /// @return z The difference of x and y</span>
 43 |     | <span class='neutral'>    function sub(int256 x, int256 y) internal pure returns (int256 z) {</span>
 44 |     | <span class='neutral'>        require((z = x - y) &lt;= x == (y &gt;= 0));</span>
 45 |     | <span class='neutral'>    }</span>
 46 |     | <span class='neutral'>}</span>
 47 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/Path.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;./BytesLib.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='neutral'>/// @title Functions for manipulating path data for multihop swaps</span>
  7 |     | <span class='unexecuted'>library Path {</span>
  8 |     | <span class='neutral'>    using BytesLib for bytes;</span>
  9 |     | <span class='neutral'></span>
 10 |     | <span class='neutral'>    /// @dev The length of the bytes encoded address</span>
 11 |     | <span class='unexecuted'>    uint256 private constant ADDR_SIZE = 20;</span>
 12 |     | <span class='neutral'>    /// @dev The length of the bytes encoded fee</span>
 13 |     | <span class='unexecuted'>    uint256 private constant FEE_SIZE = 3;</span>
 14 |     | <span class='neutral'></span>
 15 |     | <span class='neutral'>    /// @dev The offset of a single token address and pool fee</span>
 16 |     | <span class='unexecuted'>    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;</span>
 17 |     | <span class='neutral'>    /// @dev The offset of an encoded pool key</span>
 18 |     | <span class='unexecuted'>    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;</span>
 19 |     | <span class='neutral'>    /// @dev The minimum length of an encoding that contains 2 or more pools</span>
 20 |     | <span class='unexecuted'>    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;</span>
 21 |     | <span class='neutral'></span>
 22 |     | <span class='neutral'>    /// @notice Returns true iff the path contains two or more pools</span>
 23 |     | <span class='neutral'>    /// @param path The encoded swap path</span>
 24 |     | <span class='neutral'>    /// @return True if path contains two or more pools, otherwise false</span>
 25 |     | <span class='unexecuted'>    function hasMultiplePools(bytes memory path) internal pure returns (bool) {</span>
 26 |     | <span class='unexecuted'>        return path.length &gt;= MULTIPLE_POOLS_MIN_LENGTH;</span>
 27 |     | <span class='neutral'>    }</span>
 28 |     | <span class='neutral'></span>
 29 |     | <span class='neutral'>    /// @notice Returns the number of pools in the path</span>
 30 |     | <span class='neutral'>    /// @param path The encoded swap path</span>
 31 |     | <span class='neutral'>    /// @return The number of pools in the path</span>
 32 |     | <span class='neutral'>    function numPools(bytes memory path) internal pure returns (uint256) {</span>
 33 |     | <span class='neutral'>        // Ignore the first token address. From then on every fee and token offset indicates a pool.</span>
 34 |     | <span class='neutral'>        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);</span>
 35 |     | <span class='neutral'>    }</span>
 36 |     | <span class='neutral'></span>
 37 |     | <span class='neutral'>    /// @notice Decodes the first pool in path</span>
 38 |     | <span class='neutral'>    /// @param path The bytes encoded swap path</span>
 39 |     | <span class='neutral'>    /// @return tokenA The first token of the given pool</span>
 40 |     | <span class='neutral'>    /// @return tokenB The second token of the given pool</span>
 41 |     | <span class='neutral'>    /// @return fee The fee level of the pool</span>
 42 |     | <span class='unexecuted'>    function decodeFirstPool(bytes memory path)</span>
 43 |     | <span class='neutral'>        internal</span>
 44 |     | <span class='neutral'>        pure</span>
 45 |     | <span class='unexecuted'>        returns (address tokenA, address tokenB, uint24 fee)</span>
 46 |     | <span class='neutral'>    {</span>
 47 |     | <span class='unexecuted'>        tokenA = path.toAddress(0);</span>
 48 |     | <span class='unexecuted'>        fee = path.toUint24(ADDR_SIZE);</span>
 49 |     | <span class='unexecuted'>        tokenB = path.toAddress(NEXT_OFFSET);</span>
 50 |     | <span class='neutral'>    }</span>
 51 |     | <span class='neutral'></span>
 52 |     | <span class='neutral'>    /// @notice Gets the segment corresponding to the first pool in the path</span>
 53 |     | <span class='neutral'>    /// @param path The bytes encoded swap path</span>
 54 |     | <span class='neutral'>    /// @return The segment containing all data necessary to target the first pool in the path</span>
 55 |     | <span class='unexecuted'>    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {</span>
 56 |     | <span class='unexecuted'>        return path.slice(0, POP_OFFSET);</span>
 57 |     | <span class='neutral'>    }</span>
 58 |     | <span class='neutral'></span>
 59 |     | <span class='neutral'>    /// @notice Skips a token + fee element from the buffer and returns the remainder</span>
 60 |     | <span class='neutral'>    /// @param path The swap path</span>
 61 |     | <span class='neutral'>    /// @return The remaining token + fee elements in the path</span>
 62 |     | <span class='unexecuted'>    function skipToken(bytes memory path) internal pure returns (bytes memory) {</span>
 63 |     | <span class='unexecuted'>        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);</span>
 64 |     | <span class='neutral'>    }</span>
 65 |     | <span class='neutral'>}</span>
 66 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/PoolAddress.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee</span>
  5 |     | <span class='unexecuted'>library PoolAddress {</span>
  6 |     | <span class='neutral'>    bytes32 internal constant POOL_INIT_CODE_HASH =</span>
  7 |     | <span class='neutral'>        0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;</span>
  8 |     | <span class='neutral'></span>
  9 |     | <span class='neutral'>    /// @notice The identifying key of the pool</span>
 10 |     | <span class='neutral'>    struct PoolKey {</span>
 11 |     | <span class='neutral'>        address token0;</span>
 12 |     | <span class='neutral'>        address token1;</span>
 13 |     | <span class='neutral'>        uint24 fee;</span>
 14 |     | <span class='neutral'>    }</span>
 15 |     | <span class='neutral'></span>
 16 |     | <span class='neutral'>    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels</span>
 17 |     | <span class='neutral'>    /// @param tokenA The first token of a pool, unsorted</span>
 18 |     | <span class='neutral'>    /// @param tokenB The second token of a pool, unsorted</span>
 19 |     | <span class='neutral'>    /// @param fee The fee level of the pool</span>
 20 |     | <span class='neutral'>    /// @return Poolkey The pool details with ordered token0 and token1 assignments</span>
 21 |     | <span class='neutral'>    function getPoolKey(</span>
 22 |     | <span class='neutral'>        address tokenA,</span>
 23 |     | <span class='neutral'>        address tokenB,</span>
 24 |     | <span class='neutral'>        uint24 fee</span>
 25 |     | <span class='neutral'>    ) internal pure returns (PoolKey memory) {</span>
 26 |     | <span class='neutral'>        if (tokenA &gt; tokenB) (tokenA, tokenB) = (tokenB, tokenA);</span>
 27 |     | <span class='neutral'>        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Deterministically computes the pool address given the factory and PoolKey</span>
 31 |     | <span class='neutral'>    /// @param factory The Uniswap V3 factory contract address</span>
 32 |     | <span class='neutral'>    /// @param key The PoolKey</span>
 33 |     | <span class='neutral'>    /// @return pool The contract address of the V3 pool</span>
 34 |     | <span class='neutral'>    function computeAddress(</span>
 35 |     | <span class='neutral'>        address factory,</span>
 36 |     | <span class='neutral'>        PoolKey memory key</span>
 37 |     | <span class='neutral'>    ) internal pure returns (address pool) {</span>
 38 |     | <span class='neutral'>        require(key.token0 &lt; key.token1);</span>
 39 |     | <span class='neutral'>        pool = address(</span>
 40 |     | <span class='neutral'>            uint160(</span>
 41 |     | <span class='neutral'>                uint256(</span>
 42 |     | <span class='neutral'>                    keccak256(</span>
 43 |     | <span class='neutral'>                        abi.encodePacked(</span>
 44 |     | <span class='neutral'>                            hex&quot;ff&quot;,</span>
 45 |     | <span class='neutral'>                            factory,</span>
 46 |     | <span class='neutral'>                            keccak256(abi.encode(key.token0, key.token1, key.fee)),</span>
 47 |     | <span class='neutral'>                            POOL_INIT_CODE_HASH</span>
 48 |     | <span class='neutral'>                        )</span>
 49 |     | <span class='neutral'>                    )</span>
 50 |     | <span class='neutral'>                )</span>
 51 |     | <span class='neutral'>            )</span>
 52 |     | <span class='neutral'>        );</span>
 53 |     | <span class='neutral'>    }</span>
 54 |     | <span class='neutral'>}</span>
 55 |     | <span class='neutral'></span>

</code>
<br />

<b>/Users/dirtymic/guardian/peapods/peapods-fuzzing/test/invariant/modules/v3-periphery/libraries/TransferHelper.sol</b>
<code>
  1 |     | <span class='neutral'>// SPDX-License-Identifier: GPL-2.0-or-later</span>
  2 |     | <span class='neutral'>pragma solidity ^0.8.0;</span>
  3 |     | <span class='neutral'></span>
  4 |     | <span class='neutral'>import &quot;@openzeppelin/contracts/token/ERC20/IERC20.sol&quot;;</span>
  5 |     | <span class='neutral'></span>
  6 |     | <span class='unexecuted'>library TransferHelper {</span>
  7 |     | <span class='neutral'>    /// @notice Transfers tokens from the targeted address to the given destination</span>
  8 |     | <span class='neutral'>    /// @notice Errors with &#39;STF&#39; if transfer fails</span>
  9 |     | <span class='neutral'>    /// @param token The contract address of the token to be transferred</span>
 10 |     | <span class='neutral'>    /// @param from The originating address from which the tokens will be transferred</span>
 11 |     | <span class='neutral'>    /// @param to The destination address of the transfer</span>
 12 |     | <span class='neutral'>    /// @param value The amount to be transferred</span>
 13 |     | <span class='unexecuted'>    function safeTransferFrom(address token, address from, address to, uint256 value) internal {</span>
 14 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 15 |     | <span class='unexecuted'>            token.call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));</span>
 16 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;STF&quot;);</span>
 17 |     | <span class='neutral'>    }</span>
 18 |     | <span class='neutral'></span>
 19 |     | <span class='neutral'>    /// @notice Transfers tokens from msg.sender to a recipient</span>
 20 |     | <span class='neutral'>    /// @dev Errors with ST if transfer fails</span>
 21 |     | <span class='neutral'>    /// @param token The contract address of the token which will be transferred</span>
 22 |     | <span class='neutral'>    /// @param to The recipient of the transfer</span>
 23 |     | <span class='neutral'>    /// @param value The value of the transfer</span>
 24 |     | <span class='unexecuted'>    function safeTransfer(address token, address to, uint256 value) internal {</span>
 25 |     | <span class='unexecuted'>        (bool success, bytes memory data) =</span>
 26 |     | <span class='unexecuted'>            token.call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));</span>
 27 |     | <span class='unexecuted'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;ST&quot;);</span>
 28 |     | <span class='neutral'>    }</span>
 29 |     | <span class='neutral'></span>
 30 |     | <span class='neutral'>    /// @notice Approves the stipulated contract to spend the given allowance in the given token</span>
 31 |     | <span class='neutral'>    /// @dev Errors with &#39;SA&#39; if transfer fails</span>
 32 |     | <span class='neutral'>    /// @param token The contract address of the token to be approved</span>
 33 |     | <span class='neutral'>    /// @param to The target of the approval</span>
 34 |     | <span class='neutral'>    /// @param value The amount of the given token the target will be allowed to spend</span>
 35 |     | <span class='neutral'>    function safeApprove(address token, address to, uint256 value) internal {</span>
 36 |     | <span class='neutral'>        (bool success, bytes memory data) =</span>
 37 |     | <span class='neutral'>            token.call(abi.encodeWithSelector(IERC20.approve.selector, to, value));</span>
 38 |     | <span class='neutral'>        require(success &amp;&amp; (data.length == 0 || abi.decode(data, (bool))), &quot;SA&quot;);</span>
 39 |     | <span class='neutral'>    }</span>
 40 |     | <span class='neutral'></span>
 41 |     | <span class='neutral'>    /// @notice Transfers ETH to the recipient address</span>
 42 |     | <span class='neutral'>    /// @dev Fails with `STE`</span>
 43 |     | <span class='neutral'>    /// @param to The destination of the transfer</span>
 44 |     | <span class='neutral'>    /// @param value The value to be transferred</span>
 45 |     | <span class='unexecuted'>    function safeTransferETH(address to, uint256 value) internal {</span>
 46 |     | <span class='unexecuted'>        (bool success,) = to.call{value: value}(new bytes(0));</span>
 47 |     | <span class='unexecuted'>        require(success, &quot;STE&quot;);</span>
 48 |     | <span class='neutral'>    }</span>
 49 |     | <span class='neutral'>}</span>
 50 |     | <span class='neutral'></span>

</code>
<br />

